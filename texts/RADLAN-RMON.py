#
# PySNMP MIB module RADLAN-RMON (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radlan/RADLAN-RMON
# Produced by pysmi-1.1.8 at Fri Jan  7 15:37:02 2022
# On host fv-az42-180 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
EntryStatus, OwnerString = mibBuilder.importSymbols("RMON-MIB", "EntryStatus", "OwnerString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Counter64, iso, ObjectIdentity, ModuleIdentity, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Bits, Unsigned32, IpAddress, NotificationType, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "iso", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Bits", "Unsigned32", "IpAddress", "NotificationType", "Integer32")
TextualConvention, RowStatus, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "DisplayString")
DisplayString, = mibBuilder.importSymbols("SNMPv2-TC-v1", "DisplayString")
rlRmonControl = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 49))
rlRmonControl.setRevisions(('2004-06-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlRmonControl.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlRmonControl.setLastUpdated('200406010000Z')
if mibBuilder.loadTexts: rlRmonControl.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rlRmonControl.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlRmonControl.setDescription('The private MIB module definition for RND RMON MIB.')
rlRmonControlMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlRmonControlMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlMibVersion.setDescription("The MIB's version. The current version is 1")
rlRmonControlHistoryControlQuotaBucket = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRmonControlHistoryControlQuotaBucket.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlHistoryControlQuotaBucket.setDescription('Maximum number of buckets to be used by each\n        History Control group entry.\n        changed to read only, value is derived from\n        rsMaxRmonEtherHistoryEntrie')
rlRmonControlHistoryControlMaxGlobalBuckets = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlRmonControlHistoryControlMaxGlobalBuckets.setStatus('current')
if mibBuilder.loadTexts: rlRmonControlHistoryControlMaxGlobalBuckets.setDescription('Maximum number of buckets to be used by all\n        History Control group entries together.')
rlHistoryControlTable = MibTable((1, 3, 6, 1, 4, 1, 89, 49, 4), )
if mibBuilder.loadTexts: rlHistoryControlTable.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlTable.setDescription('A list of rlHistory control entries. This table is exactly like the\n        corresponding RMON I History control group table, but is used to sample\n        statistics of counters not specified by the RMON I statistics group.')
rlHistoryControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 49, 4, 1), ).setIndexNames((0, "RADLAN-RMON", "rlHistoryControlIndex"))
if mibBuilder.loadTexts: rlHistoryControlEntry.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlEntry.setDescription('A list of parameters that set up a periodic sampling\n        of statistics.  As an example, an instance of the\n        rlHistoryControlInterval object might be named\n        rlHistoryControlInterval.2')
rlHistoryControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryControlIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlIndex.setDescription('An index that uniquely identifies an entry in the\n        rlHistoryControl table.  Each such entry defines a\n        set of samples at a particular interval for a sampled counter.')
rlHistoryControlDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlDataSource.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlDataSource.setDescription('This object identifies the source of the data for\n        which historical data was collected and\n        placed in the rlHistory table.\n\n        This object may not be modified if the associated\n        rlHistoryControlStatus object is equal to valid(1).')
rlHistoryControlBucketsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlBucketsRequested.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlBucketsRequested.setDescription('The requested number of discrete time intervals\n        over which data is to be saved in the part of the\n        rlHistory table associated with this rlHistoryControlEntry.\n\n        When this object is created or modified, the probe\n        should set rlHistoryControlBucketsGranted as closely to\n        this object as is possible for the particular probe\n        implementation and available resources.')
rlHistoryControlBucketsGranted = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryControlBucketsGranted.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlBucketsGranted.setDescription('The number of discrete sampling intervals\n        over which data shall be saved in the part of\n        the rlHistory table associated with this\n        rlHistoryControlEntry.\n\n        When the associated rlHistoryControlBucketsRequested\n        object is created or modified, the probe\n        should set this object as closely to the requested\n        value as is possible for the particular\n        probe implementation and available resources.  The\n        probe must not lower this value except as a result\n        of a modification to the associated\n        rlHistoryControlBucketsRequested object.\n\n        There will be times when the actual number of\n        buckets associated with this entry is less than\n        the value of this object.  In this case, at the\n        end of each sampling interval, a new bucket will\n        be added to the rlHistory  table.\n\n        When the number of buckets reaches the value of\n        this object and a new bucket is to be added to the\n        media-specific table, the oldest bucket associated\n        with this rlHistoryControlEntry shall be deleted by\n        the agent so that the new bucket can be added.\n\n        When the value of this object changes to a value less\n        than the current value, entries are deleted\n        from the rlHistory table. Enough of the oldest of these\n        entries shall be deleted by the agent so that their\n        number remains less than or equal to the new value of\n        this object.\n\n        When the value of this object changes to a value\n        greater than the current value, the number of\n        associated rlHistory table entries may be allowed to\n        grow.')
rlHistoryControlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlInterval.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlInterval.setDescription('The interval in seconds over which the data is\n        sampled for each bucket in the part of the\n        rlHistory table associated with this\n        rlHistoryControlEntry.  This interval can\n        be set to any number of seconds between 1 and\n        3600 (1 hour).\n\n        Because the counters in a bucket may overflow at their\n        maximum value with no indication, a prudent manager\n        will take into account the possibility of overflow\n        in any of the associated counters.  It is important\n        to consider the minimum time in which any counter\n        could overflow and set the rlHistoryControlInterval object to a value\n        This object may not be modified if the associated\n        rlHistoryControlStatus object is equal to valid(1).')
rlHistoryControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 6), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlOwner.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlOwner.setDescription('The entity that configured this entry and is\n        therefore using the resources assigned to it.')
rlHistoryControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 4, 1, 7), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlHistoryControlStatus.setStatus('current')
if mibBuilder.loadTexts: rlHistoryControlStatus.setDescription('The status of this rlHistoryControl entry.\n\n        Each instance of the rlHistory table associated\n        with this rlHistoryControlEntry will be deleted by the\n        agent if this rlHistoryControlEntry is not equal to\n        valid(1).')
rlHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 89, 49, 5), )
if mibBuilder.loadTexts: rlHistoryTable.setStatus('current')
if mibBuilder.loadTexts: rlHistoryTable.setDescription('A list of history entries.')
rlHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 49, 5, 1), ).setIndexNames((0, "RADLAN-RMON", "rlHistoryIndex"), (0, "RADLAN-RMON", "rlHistorySampleIndex"))
if mibBuilder.loadTexts: rlHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: rlHistoryEntry.setDescription('An historical statistics sample of a counter specified\n        by the corresponding history control entry.\n        This sample is associated with the rlHistoryControlEntry which set up\n        the parameters for a regular collection of these\n        samples.  As an example, an instance of the\n        rlHistoryPkts object might be named\n        rlHistoryPkts.2.89')
rlHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistoryIndex.setDescription('The history of which this entry is a part.  The\n        history identified by a particular value of this\n        index is the same history as identified\n        by the same value of rlHistoryControlIndex.')
rlHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistorySampleIndex.setStatus('current')
if mibBuilder.loadTexts: rlHistorySampleIndex.setDescription('An index that uniquely identifies the particular\n        sample this entry represents among all samples\n        associated with the same rlHistoryControlEntry.\n        This index starts at 1 and increases by one\n        as each new sample is taken.')
rlHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryIntervalStart.setStatus('current')
if mibBuilder.loadTexts: rlHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval\n        over which this sample was measured.  If the probe\n        keeps track of the time of day, it should start\n        the first sample of the history at a time such that\n        when the next hour of the day begins, a sample is\n        started at that instant.  Note that following this\n        rule may require the probe to delay collecting the\n        first sample of the history, as each sample must be\n        of the same interval.  Also note that the sample which\n        is currently being collected is not accessible in this\n        table until the end of its interval.')
rlHistoryValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 49, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHistoryValue.setStatus('current')
if mibBuilder.loadTexts: rlHistoryValue.setDescription('The value of the sampled counter at the time of this sampling.')
rlControlHistoryControlQuotaBucket = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryControlQuotaBucket.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryControlQuotaBucket.setDescription('Maximum number of buckets to be used by each rlHistoryControlTable\n        entry.')
rlControlHistoryControlMaxGlobalBuckets = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryControlMaxGlobalBuckets.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryControlMaxGlobalBuckets.setDescription('Maximum number of buckets to be used by all\n        rlHistoryControlTable entries together.')
rlControlHistoryMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 49, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlControlHistoryMaxEntries.setStatus('current')
if mibBuilder.loadTexts: rlControlHistoryMaxEntries.setDescription('Maximum number of rlHistoryTable entries.')
mibBuilder.exportSymbols("RADLAN-RMON", rlRmonControlHistoryControlQuotaBucket=rlRmonControlHistoryControlQuotaBucket, rlHistoryControlDataSource=rlHistoryControlDataSource, rlHistoryEntry=rlHistoryEntry, rlHistoryIndex=rlHistoryIndex, rlHistoryControlInterval=rlHistoryControlInterval, rlControlHistoryMaxEntries=rlControlHistoryMaxEntries, rlHistorySampleIndex=rlHistorySampleIndex, rlRmonControlHistoryControlMaxGlobalBuckets=rlRmonControlHistoryControlMaxGlobalBuckets, rlRmonControl=rlRmonControl, rlHistoryControlBucketsRequested=rlHistoryControlBucketsRequested, rlControlHistoryControlMaxGlobalBuckets=rlControlHistoryControlMaxGlobalBuckets, rlHistoryControlTable=rlHistoryControlTable, rlControlHistoryControlQuotaBucket=rlControlHistoryControlQuotaBucket, PYSNMP_MODULE_ID=rlRmonControl, rlHistoryControlOwner=rlHistoryControlOwner, rlHistoryControlStatus=rlHistoryControlStatus, rlHistoryIntervalStart=rlHistoryIntervalStart, rlRmonControlMibVersion=rlRmonControlMibVersion, rlHistoryControlBucketsGranted=rlHistoryControlBucketsGranted, rlHistoryControlIndex=rlHistoryControlIndex, rlHistoryValue=rlHistoryValue, rlHistoryTable=rlHistoryTable, rlHistoryControlEntry=rlHistoryControlEntry)
