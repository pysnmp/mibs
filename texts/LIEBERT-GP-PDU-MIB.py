#
# PySNMP MIB module LIEBERT-GP-PDU-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/liebert/LIEBERT-GP-PDU-MIB
# Produced by pysmi-1.1.12 at Wed Jul  3 09:58:42 2024
# On host fv-az530-296 platform Linux version 6.5.0-1022-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
liebertPduModuleReg, lgpPdu = mibBuilder.importSymbols("LIEBERT-GP-REGISTRATION-MIB", "liebertPduModuleReg", "lgpPdu")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter32, NotificationType, ObjectIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, IpAddress, TimeTicks, iso, Integer32, Bits, Unsigned32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "NotificationType", "ObjectIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "IpAddress", "TimeTicks", "iso", "Integer32", "Bits", "Unsigned32", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
liebertGlobalProductsPduModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 1, 9, 1))
liebertGlobalProductsPduModule.setRevisions(('2008-07-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: liebertGlobalProductsPduModule.setRevisionsDescriptions(('Initial Version',))
if mibBuilder.loadTexts: liebertGlobalProductsPduModule.setLastUpdated('200807020000Z')
if mibBuilder.loadTexts: liebertGlobalProductsPduModule.setOrganization('Liebert Corporation')
if mibBuilder.loadTexts: liebertGlobalProductsPduModule.setContactInfo('Contact:   Technical Support\n\n      Postal:\n      Liebert Corporation\n      1050 Dearborn Drive\n      P.O. Box 29186\n      Columbus OH, 43229\n      US\n\n      Tel: +1 (800) 222-5877\n\n      E-mail: liebert.monitoring@vertivco.com\n      Web:    www.vertivco.com\n\n      Author:  Keith Sarbaugh')
if mibBuilder.loadTexts: liebertGlobalProductsPduModule.setDescription("The MIB module used to register Liebert POWER related SNMP OIDs.\n\n      Copyright 2008-2008 Liebert Corporation. All rights reserved.\n      Reproduction of this document is authorized on the condition\n      that the forgoing copyright notice is included.\n\n      This Specification is supplied 'AS IS' and Liebert Corporation\n      makes no warranty, either express or implied, as to the use,\n      operation, condition, or performance of the Specification.")
lgpPduGlobalData = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 5))
if mibBuilder.loadTexts: lgpPduGlobalData.setStatus('current')
if mibBuilder.loadTexts: lgpPduGlobalData.setDescription("This sub-tree contains data and control associated with PDU's controlled\n         by this agent.  Data in this sub-tree will affect the behavior of all\n         PDU's controlled by this agent.")
if mibBuilder.loadTexts: lgpPduGlobalData.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduEntrySWOverTemperatureProtectionConfig = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("local", 0), ("array", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntrySWOverTemperatureProtectionConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySWOverTemperatureProtectionConfig.setDescription('This configures the scope of behavior for the PDU Software Over \n        Temperature Protection feature.  \n        See lgpPduRcpEntrySwOverTemperatureProtection to enable this feature\n        and get further information about what actions will be performed.\n\n            local (0)\n               Only receptacles on the PDU with the alarming temperature sensor \n               will be affected.\n            array (1)\n               All receptacles in the PDU array will be affected, regardless of \n               which PDU the alarming temperature sensor is connected to.\n        ')
lgpPduEntrySWOverTemperatureProtectionDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 5, 10), Unsigned32()).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntrySWOverTemperatureProtectionDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySWOverTemperatureProtectionDelay.setDescription('This sets the delay for the PDU Software Over Temperature Protection \n        feature.  This value determines the amount of time to delay, after the\n        high temperature alarm becomes active, before taking action on the \n        enabled receptacles.  If the high temperature alarm becomes inactive\n        before the expiration of the delay time, no action will be taken on \n        the enabled receptacles.  \n        See lgpPduRcpEntrySwOverTemperatureProtection to enable this feature\n        and get further information about what actions will be performed.\n        ')
lgpPduCluster = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 10))
if mibBuilder.loadTexts: lgpPduCluster.setStatus('current')
if mibBuilder.loadTexts: lgpPduCluster.setDescription("This sub-tree contains information about PDU clusters.  Clusters are\n         groups of PDU's under a single monitoring or control domain.")
if mibBuilder.loadTexts: lgpPduCluster.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduGrpSysStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 10, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduGrpSysStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPduGrpSysStatus.setDescription("This value represents a bit-field of the various operational\n     states of the PDUs that are part of the cluster of PDUs\n     being monitored by this agent.\n\n     This value is the bit-wise logical OR of all of the\n     'lgpPduEntrySysStatus' columns in the 'lgpPduTable'\n     which represents the combined statuses of all PDUs for this agent.\n\n     Note the bit-position is given parenthetically next to the operational\n     state in the description below.  The bit position is big-endian\n     (least significant digit is the right-most digit).  The state is\n     present in the PDU when the bit is on (value = 1).\n\n     The value is a logical OR of all of the following potential states of\n     each PDU in the cluster.\n\n         normalOperation(1)\n             One or more PDUs in the cluster are operating normally with no\n             active warnings or alarms.\n         startUp(2)\n             One or more PDUs are in the startup state (initializing).  Control\n             and monitoring operations may be inhibited or unavailable\n             while the PDU is in this state.  This state will clear\n             automatically when the PDU(s) are fully initialized and ready to\n             accept control and monitoring commands.\n         unknownNoSupport(4)\n             The state of one or more PDUs are not known at this time or\n             there is no support for this piece of information from 1 or more\n             PDUs in the cluster/group.\n         normalWithWarning(8)\n             One or more PDUs are operating normally with one or more active\n             warnings.  Appropriate personnel should investigate the\n             warning(s) as soon as possible and take appropriate action.\n         normalWithAlarm(16)\n             One or more PDUs are operating normally with one or more active\n             alarms.  Appropriate personnel should investigate the alarm(s)\n             as soon as possible and take appropriate action.\n         abnormalOperation(32)\n            One ore more PDUs are operating abnormally.  There is a\n            failure within the system that is unexpected under normal\n            operating conditions.  Appropriate personnel should investigate\n            the cause as soon as possible.  The normal functioning of\n            the system is likely inhibited.\n         unknownCommFailure(64)\n            The state of one or more PDUs are not known due to a communications\n            failure between the PDU hardware and the communications\n            module.  This state is usually indicative of a hardware\n            problem.\n     ")
lgpPduTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 19), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduTableCount.setDescription('Number of PDUs being monitored by this agent.  This is the\n         number of entries in the lgpPduTable.')
lgpPduTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20), )
if mibBuilder.loadTexts: lgpPduTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduTable.setDescription('This table contains a list of PDU entries.\n         The table contains zero, one, or many rows, depending upon the number\n         of PDUs being monitored.  The Network Management System (NMS)\n         cannot create or delete rows in the table. The rows are created by\n         the agent based upon the number of PDUs being managed.\n         Each row in the table represents a PDU in the system.')
lgpPduEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"))
if mibBuilder.loadTexts: lgpPduEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntry.setDescription("This entry defines the columns to be populated in the\n             'lgpPduTable'.  Each column represents an attribute of a PDU.\n             This table is indexed by the PDU identifier that is unique\n             within the agent.\n            ")
lgpPduEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduEntryIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryIndex.setDescription("This is the index that indicates the row of the 'lgpPduTable'.")
lgpPduEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntryId.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryId.setDescription('This is an internal index representing a unique identifier for\n             each PDU represented by this agent.  The value is assigned\n             by the agent.')
lgpPduEntryUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntryUsrLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryUsrLabel.setDescription('This is a user assigned label representing the PDU.')
lgpPduEntrySysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntrySysAssignLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySysAssignLabel.setDescription('System assigned identifier representing the PDU. The value\n             is independent of any user assigned label or tag. The exact format\n             of this label is system dependent and is subject to change,\n             therefore, it should not be referenced for programmatic use.')
lgpPduEntryPositionRelative = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 20), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntryPositionRelative.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryPositionRelative.setDescription("This is a one-based value that indicates the PDU's relative\n             position within a rack or other enclosing entity.")
lgpPduEntrySysStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntrySysStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySysStatus.setDescription('This value represents a bit-field of the various operational\n             states of the PDU. The value is a logical OR of all of the\n             following potential states of the PDU.  Note the bit-position\n             is given parenthetically next to the operational state in the\n             description below.  The bit position is assumed to be a big-endian\n             format (least significant digit is the right-most digit).  The\n             state is present in the PDU when the bit is on (value = 1).\n\n             normalOperation(1)\n                 The PDU is operating normally with no active warnings or alarms.\n             startUp(2)\n                 The PDU is in the startup state (initializing).  Control\n                 and monitoring operations maybe inhibited or unavailable\n                 while the PDU is in this state.  This state will clear\n                 automatically when the PDU(s) are fully initialized and\n                 ready to accept control and monitoring commands.\n             normalWithWarning(8)\n                 The PDU is operating normally with one or more active\n                 warnings.  Appropriate personnel should investigate the\n                 warning(s) as soon as possible and take appropriate action.\n             normalWithAlarm(16)\n                 The PDU is operating normally with one or more active\n                 alarms.  Appropriate personnel should investigate the alarm(s)\n                 as soon as possible and take appropriate action.\n             abnormalOperation(32)\n                The PDU is operating abnormally.  That is there is some\n                failure within the system that is unexpected under normal\n                operating conditions.  Appropriate personnel should investigate\n                the cause as soon as possible.  The normal functioning of\n                the system is likely inhibited.\n             ')
lgpPduEntryUsrTag1 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 35), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntryUsrTag1.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryUsrTag1.setDescription('This is a user assigned Tag for the PDU.  This value may be\n             useful for end-user grouping or asset tracking purposes.\n             The value for this tag does not need to be unique for this\n             unit or across other units.')
lgpPduEntryUsrTag2 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 40), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntryUsrTag2.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryUsrTag2.setDescription('This is a user assigned Tag for the PDU.  This value may be\n             useful for end-user grouping or asset tracking purposes.\n             The value for this tag does not need to be unique for this\n             unit or across other units.')
lgpPduEntrySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 45), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntrySerialNumber.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySerialNumber.setDescription('System assigned serial number for this PDU.  This number is\n             assigned at time of manufacture, is globally unique with respect\n             to all PDU units.')
lgpPduEntryRbCount = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 50), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduEntryRbCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntryRbCount.setDescription('Number of receptacle branches (Rb) within this PDU.')
lgpPduEntrySWOverCurrentProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 20, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduEntrySWOverCurrentProtection.setStatus('current')
if mibBuilder.loadTexts: lgpPduEntrySWOverCurrentProtection.setDescription("This is the PDU Software Over Current Protection feature which will\n             prevent unused receptacles from turning on when the\n             'PDU Over Current Warning' or 'PDU Over Current Alarm' threshold\n             is violated. Such receptacles shall get locked to prevent any user\n             from switching them ON. Only device-admin shall have the authorization\n             to unlock such receptacles.\n             If the feature is enabled, in case of PDU Over Current Warning or Alarm condition,\n             following action will be taken on the receptacles:\n                a. Locked & OFF  No change\n                b. Locked & ON -  No change\n                c. UnLocked & OFF  Receptacle shall be locked\n                d. Unlocked & ON  If the receptacle is being used (current>0), no change.\n                   If that outlet is being unused(current=0), turn it off and lock it in that position.\n\n             No action will be taken if the feature is disabled.\n\n             Note: Only applicable to PDU models where receptacle measurement and control is supported.\n             Not applicable for PDU models that support only branch monitoring.\n\n         disabled\n              This function is disabled.\n         enable\n              This function is enabled.")
lgpPduPowerSource = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30))
if mibBuilder.loadTexts: lgpPduPowerSource.setStatus('current')
if mibBuilder.loadTexts: lgpPduPowerSource.setDescription('This sub-tree contains information about PDU power sources.')
if mibBuilder.loadTexts: lgpPduPowerSource.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduPsTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 19), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsTableCount.setDescription('Number of power sources in the lgpPduPsTable.')
lgpPduPsTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20), )
if mibBuilder.loadTexts: lgpPduPsTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsTable.setDescription("This table contains a list of the PDU's power source(s).\n         The table contains zero, one, or more rows, depending\n         upon the number of PDUs being monitored and the number of\n         power sources installed for each PDU.\n         The NMS cannot create or delete rows in the table. The rows are\n         created by the agent based upon the capabilities of the PDUs\n         being monitored.  Each row in the table represents a PDU's\n         Power Source.")
lgpPduPsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduPsEntryIndex"))
if mibBuilder.loadTexts: lgpPduPsEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduPsTable' (Power Source Table).\n             This table is indexed by both the 'lgpPduEntryIndex' which is\n             the sole index into the 'lgpPduTable' and the 'lgpPduPsEntryIndex'\n             which is a unique identifier for the Power Source within a\n             given PDU.  Taken together these two indexes uniquely identify\n             a Power Source within this agent.\n            ")
lgpPduPsEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 5), Unsigned32())
if mibBuilder.loadTexts: lgpPduPsEntryIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryIndex.setDescription("This is a unique identifier for the Power Source within a\n             given PDU. This is one of two indexes used to indicate the row of\n             the 'lgpPduTable'.")
lgpPduPsEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryId.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryId.setDescription('This is a unique entry id representing a given PDU power source\n             for the PDU.')
lgpPduPsEntrySysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntrySysAssignLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntrySysAssignLabel.setDescription('System assigned identifier for this power source.  The value\n             is independent of any user assigned label or tag. The exact format\n             of this label is system dependent and is subject to change,\n             therefore, it should not be referenced for programmatic use.')
lgpPduPsEntryModel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryModel.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryModel.setDescription('This is the model name (identifier) of the power supply.')
lgpPduPsEntryWiringType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-specified", 0), ("single-phase-3-wire-L1-N-PE", 1), ("two-phase-3-wire-L1-L2-PE", 2), ("three-phase-4-wire-L1-L2-L3-PE", 3), ("three-phase-5-wire-L1-L2-L3-N-PE", 4), ("two-phase-4-wire-L1-L2-N-PE", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryWiringType.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryWiringType.setDescription("The PDU's power supply physical wiring type.\n                not-specified\n                    The type has not been specified/configured.  The end_user\n                    must configure this object to specify the physical wiring\n                    type.\n                single-phase-3-wire-L1-N-PE\n                    Single Phase input with 3 wires (Line 1, Neutral and\n                    Protective Earth).\n                two-phase-3-wire-L1-L2-PE\n                    Two Phase input with 3 wires (Line 1, Line 2, and\n                    Protective Earth).\n                three-phase-4-wire-L1-L2-L3-PE\n                    Three Phase input with 4 wires (Line 1, Line 2, Line 3,\n                    and Protective Earth).\n                three-phase-5-wire-L1-L2-L3-N-PE\n                    Three Phase input with 5 wires (Line 1, Line 2, Line 3,\n                    Neutral and Protective Earth).\n                two-phase-4-wire-L1-L2-N-PE\n                    Two Phase input with 4 wires (Line 1, Line 2, Neutral,\n                    and Protective Earth).")
lgpPduPsEntryEpInputRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 30), Unsigned32()).setUnits('VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryEpInputRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEpInputRated.setDescription("Rated Input Line Voltage for the power source (i.e. this is the\n             nominal line input voltage; it is NOT a measured voltage).\n\n             The value is defined to be the rated line voltage\n             (either line-to-neutral or line-to-line depending upon the\n             power source's type).")
lgpPduPsEntryEcInputRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 35), Unsigned32()).setUnits('0.1 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryEcInputRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcInputRated.setDescription('This is the rated input line current for the module\n             (it is NOT the measured current).')
lgpPduPsEntryFreqRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 40), Unsigned32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryFreqRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryFreqRated.setDescription('Rated input line frequency for this power source\n             (i.e. This is the expected line frequency; it is NOT a\n             measured frequency; it is typically 50 Hz or 60 Hz).')
lgpPduPsEntryEnergyAccum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 50), Unsigned32()).setUnits('0.1 Kilowatt-Hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryEnergyAccum.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEnergyAccum.setDescription('Total accumulated energy, measured at the power source input, since\n             the last energy reset. Writing a value of 0 (zero) to this\n             causes the accumulated energy to be reset. Writing a non-zero\n             value is invalid and shall result in a write error and the\n             total energy value remains unchanged.\n\n             If the energy has not been reset and has not wrapped,\n             then this is the total energy since installation.\n\n             This value persists across boot events.')
lgpPduPsEntrySerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 55), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntrySerialNum.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntrySerialNum.setDescription('This is a unique serial number of the power supply.  This number\n             is assigned to the power supply at the time of manufacture.')
lgpPduPsEntryFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 60), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryFirmwareVersion.setDescription("This is the version of the firmware installed on the PDU's\n             power supply.")
lgpPduPsEntryPwrTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 65), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryPwrTotal.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryPwrTotal.setDescription('Total input power for this power supply.  This is the sum of the\n             power for all phases')
lgpPduPsEntryEcNeutral = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 70), Unsigned32()).setUnits('0.1 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutral.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutral.setDescription("The neutral current measured at the PDU's power source.")
lgpPduPsEntryEcNeutralThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 75), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutralThrshldOvrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutralThrshldOvrWarn.setDescription('The threshold at which an over current warning is activated. If the\n             measured neutral current (lgpPduPsEntryEcNeutral) is above this\n             percentage of the full scale rated value\n             (lgpPduPsEntryEcInputRated), an over neutral current warning\n             (lgpConditionSource1NeutralOverCurrent) is activated.')
lgpPduPsEntryEcNeutralThrshldOvrAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 80), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutralThrshldOvrAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcNeutralThrshldOvrAlarm.setDescription('The threshold at which an over current alarm is activated. If the\n             measured neutral current (lgpPduPsEntryEcNeutral) is above this\n             percentage of the full scale rated value\n             (lgpPduPsEntryEcInputRated), an over neutral current alarm\n             (lgpConditionSource1NeutralOverCurrent) is activated.')
lgpPduPsEntryUnbalancedLoadThrshldAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 85), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryUnbalancedLoadThrshldAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryUnbalancedLoadThrshldAlarm.setDescription("The parameter is for setting the maximum acceptable percentage of\n             'Unbalanced Load' between any two phases. This setting shall\n             trigger an alarm when the % load between any two phases varies by\n             a percentage higher than this configurable value. If this value is\n             0% then the alarm would be deactivated.")
lgpPduPsEntryApTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 90), Unsigned32()).setUnits('VoltAmp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryApTotal.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryApTotal.setDescription('Total Apparent power for this power supply.  This is the sum of the\n             apparent power for all phases')
lgpPduPsEntryPfTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 95), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryPfTotal.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryPfTotal.setDescription('Total power factor, which is real power/apparent power for all\n             phases combined. This is the sum of the real power for all phases\n             divided by the sum of the apparent power for all phases.')
lgpPduPsEntryEcResidual = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 100), Unsigned32()).setUnits('0.001 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsEntryEcResidual.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcResidual.setDescription('The measured residual current.')
lgpPduPsEntryEcResidualThrshldOvrAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 20, 1, 105), Unsigned32()).setUnits('0.001 Amp-AC-RMS').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsEntryEcResidualThrshldOvrAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsEntryEcResidualThrshldOvrAlarm.setDescription('The threshold at which an over current alarm is activated. If the\n             measured residual current (lgpPduPsEntryEcResidual) is above this\n             value, an over current alarm is activated.  Setting this to 0mA\n             disables the alarm.')
lgpPduPsLineTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40), )
if mibBuilder.loadTexts: lgpPduPsLineTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineTable.setDescription("This table contains a list of PDU's power source line/phase\n         measurements. The table contains zero, one, or many rows, depending\n         upon the number of PDU's Power Sources being monitored.\n         The NMS cannot create or delete rows in the table.\n         The rows are created by the agent based upon the capabilities of the\n         managed PDU's power supply(s).  Each row in the table represents a\n         particular phase/line measurement of a power supply for a\n         given PDU.")
lgpPduPsLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduPsEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduPsLineEntryIndex"))
if mibBuilder.loadTexts: lgpPduPsLineEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduPsLineTable'.\n             The table is index by three indexes which taken together\n             uniquely identify line/phase information for a given power source\n             within a PDU.  The 'lgpPduEntryIndex' is an index into the\n             'lgpPduTable'.  This identifies the PDU that the power source\n             is on.  The 'lgpPduPsEntryIndex' is an index that together with\n             the 'lgpPduEntryIndex' uniquely identifies the power source\n             within the PDU that the row in this table represents.  The final\n             index 'lgpPduPsLineEntryIndex' identifies the particular\n             line/phase that the measurement applies to within the identified\n             power source.")
lgpPduPsLineEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 5), Unsigned32())
if mibBuilder.loadTexts: lgpPduPsLineEntryIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryIndex.setDescription("This is the index that indicates the line/phase of the measurements\n             in the given row of the 'lgpPduPsLineTable'.")
lgpPduPsLineEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryId.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryId.setDescription("Unique identifier (within a PDU) for the PDU's power source.\n             The object may not be available in non-modular systems.")
lgpPduPsLineEntryLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("phase1", 1), ("phase2", 2), ("phase3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryLine.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryLine.setDescription('The line number (phase) that the measurement represents for all\n             measurements in a given row of the table.  Note that this always\n             matches the lgpPduPsLineEntryIndex of the same row in the table.\n             The line/phases are as follows:\n\n              Line#  Description\n              -----  ---------------------------------------------------\n                 1   Line 1-N (A) for Line-to-Neutral measurements\n                 2   Line 2-N (B) for Line-to-Neutral measurements\n                 3   Line 3-N (C) for Line-to-Neutral measurements\n\n                 1   Line 1-2 (A-B) for Line-to-Line measurements\n                 2   Line 2-3 (B-C) for Line-to-Line measurements\n                 3   Line 3-1 (C-A) for Line-to-Line measurements\n             ')
lgpPduPsLineEntryEpLNTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 19), Unsigned32()).setUnits('0.1 Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLNTenths.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLNTenths.setDescription('Alternating Current RMS Line to Neutral Electrical Potential\n             measurement.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEpLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 20), Unsigned32()).setUnits('Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLN.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLN.setDescription('Alternating Current RMS Line to Neutral Electrical Potential\n             measurement.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEc = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 21), Unsigned32()).setUnits('0.1 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEc.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEc.setDescription('Total input line-to-neutral electrical current.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEcHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 22), Unsigned32()).setUnits('0.01 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcHundredths.setDescription('Total input line-to-neutral electrical current.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEcThrshldUndrAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 35), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldUndrAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldUndrAlarm.setDescription('The threshold at which an under current alarm is activated.  If\n             the measured current (lgpPduPsLineEntryEc) is equal to or below\n             this percentage of the full scale rated value\n             (lgpPduPsEntryEcInputRated), an under current alarm\n             is activated.')
lgpPduPsLineEntryEcThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 36), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldOvrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldOvrWarn.setDescription('The threshold at which an over current warning is activated.  If\n             the measured current (lgpPduPsLineEntryEc) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduPsEntryEcInputRated), an over current warning\n             is activated.')
lgpPduPsLineEntryEcThrshldOvrAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 37), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldOvrAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcThrshldOvrAlarm.setDescription('The threshold at which an over current alarm is activated.  If\n             the measured current (lgpPduPsLineEntryEc) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduPsEntryEcInputRated), an over current alarm\n             is activated.')
lgpPduPsLineEntryEcAvailBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 38), Unsigned32()).setUnits('0.1 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcAvailBeforeAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcAvailBeforeAlarm.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduPsLineEntryEcUsedBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 39), Unsigned32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcUsedBeforeAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcUsedBeforeAlarm.setDescription('The percent of current utilization relative to the over current\n             alarm threshold.')
lgpPduPsLineEntryEpLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 60), Unsigned32()).setUnits('Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLL.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLL.setDescription('Line to Line Electrical Potential.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEpLLTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 61), Unsigned32()).setUnits('0.1 Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLLTenths.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEpLLTenths.setDescription('Line to Line Electrical Potential.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryEcAvailBeforeAlarmHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 62), Unsigned32()).setUnits('0.01 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryEcAvailBeforeAlarmHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryEcAvailBeforeAlarmHundredths.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduPsLineEntryPwrLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 63), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryPwrLN.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryPwrLN.setDescription('The line-to-neutral measurement of the Real Power (Watts).\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryPwrLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 64), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryPwrLL.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryPwrLL.setDescription('The line-to-line measurement of the Real Power (Watts).\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryApLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 65), Unsigned32()).setUnits('VoltAmp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryApLN.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryApLN.setDescription('The line-to-neutral measurement of the Apparent Power (VA).\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryApLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 66), Unsigned32()).setUnits('VoltAmp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryApLL.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryApLL.setDescription('The line-to-line measurement of the Apparent Power (VA).\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryPfLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 67), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryPfLN.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryPfLN.setDescription('The line-to-neutral measurement of the Power Factor of the\n             power source.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduPsLineEntryPfLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 30, 40, 1, 68), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduPsLineEntryPfLL.setStatus('current')
if mibBuilder.loadTexts: lgpPduPsLineEntryPfLL.setDescription('The line-to-line measurement of the Power Factor of the\n             power source.\n             The line/phase being measured is indicated by the corresponding\n             lgpPduPsLineEntryLine value of this row in the table.')
lgpPduReceptacleBranch = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40))
if mibBuilder.loadTexts: lgpPduReceptacleBranch.setStatus('current')
if mibBuilder.loadTexts: lgpPduReceptacleBranch.setDescription('This sub-tree contains information about PDU receptacle branches.')
if mibBuilder.loadTexts: lgpPduReceptacleBranch.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduRbTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 19), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbTableCount.setDescription('Number of receptacle branches in the lgpPduRbTable.')
lgpPduRbTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20), )
if mibBuilder.loadTexts: lgpPduRbTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbTable.setDescription('This table contains a list of PDU Receptacle branches.\n         The table contains zero, one, or many rows, depending\n         upon the number of PDUs being managed and how many\n         receptacle branches each PDU has installed.\n         The NMS cannot create or delete rows in the table. The rows are\n         created by the agent based upon the capabilities of the PDUs\n         being managed.  Each row in the table represents a receptacle branch\n         for a given PDU.  The PDU that a branch is installed\n         on is indicated by the column lgpPduEntryIndex.  The branch\n         within the lgpPduEntryIndex PDU is indicated by the column\n         lgpPduRbEntryIndex.')
lgpPduRbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduRbEntryIndex"))
if mibBuilder.loadTexts: lgpPduRbEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduRbTable'.  The table is indexed\n             by both the 'lgpPduEntryIndex' and 'lgpPduRbEntryIndex'.  The\n             lgpPduEntryIndex specifies the PDU, defined in the lgpPduTable\n             that the branch is on.  The lgpPduRbEntryIndex uniquely identifies\n             the branch within that PDU.  Taken together the two indexes\n             uniquely identify a branch being monitored by this agent.\n            ")
lgpPduRbEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduRbEntryIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryIndex.setDescription("This is the index that indicates the row of the\n             'lgpPduRbTable'")
lgpPduRbEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryId.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryId.setDescription('A unique id representing the receptacle branch within the\n             collection of branches being monitored by this agent.  The\n             uniqueness of this id is within the PDUs being managed by\n             a single agent.')
lgpPduRbEntryUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryUsrLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryUsrLabel.setDescription('A user assigned label representing the receptacle branch.')
lgpPduRbEntrySysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntrySysAssignLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntrySysAssignLabel.setDescription('System assigned identifier for this receptacle branch.  The value\n             is independent of any user assigned label or tag. The exact format\n             of this label is system dependent and is subject to change,\n             therefore, it should not be referenced for programmatic use.')
lgpPduRbEntryPositionRelative = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 25), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryPositionRelative.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryPositionRelative.setDescription('This is a one-based value that indicates the relative\n             position of the branch within the PDU.')
lgpPduRbEntrySerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 30), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntrySerialNum.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntrySerialNum.setDescription('A globally unique serial number for this branch.  This number\n             is assigned to the branch at the time of manufacture and can not\n             be modified.  NOTE: Generally only PDUs with replaceable\n             receptacle branches will have serial numbers.')
lgpPduRbEntryModel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 35), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryModel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryModel.setDescription('This is the model designation for this receptacle branch.')
lgpPduRbEntryFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 40), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryFirmwareVersion.setDescription('This is the firmware version number of the control software\n             running on the receptacle branch.  Only PDUs with\n             replaceable receptacle branches will typically support this\n             object.')
lgpPduRbEntryUsrTag1 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 41), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryUsrTag1.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryUsrTag1.setDescription('This is a user assigned Tag for the receptacle branch.  This\n             value may be useful for end-user grouping or asset tracking\n             purposes.  The value for this tag does not need to be unique\n             for this unit or across other units.')
lgpPduRbEntryUsrTag2 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 42), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryUsrTag2.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryUsrTag2.setDescription('This is a user assigned Tag for the receptacle branch.  This\n             value may be useful for end-user grouping or asset tracking\n             purposes.  The value for this tag does not need to be unique\n             for this unit or across other units.')
lgpPduRbEntryReceptacleType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("not-specified", 0), ("nema-5-20R-20-Amp", 1), ("iec-C13-sheet-F-10-Amp", 2), ("iec-C19-sheet-J-16-Amp", 3), ("iec-C13-sheet-F-10-Amp-and-iec-C19-sheet-J-16-Amp", 4), ("nema-5-20R-20-Amp-and-iec-C13-sheet-F-10-Amp", 5), ("nema-5-20R-20-Amp-and-iec-C19-sheet-J-16-Amp", 6), ("cee-7-type-E-schuko", 7), ("nema-L6-30R-30-Amp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryReceptacleType.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryReceptacleType.setDescription('This enumeration represents the type of receptacles installed\n             on this receptacle branch.  All receptacles on this branch are\n             of this type/style.\n\n             not-specified\n                 If this value is returned, either the receptacle type has\n                 not been specified/configured or the agent monitoring this\n                 PDU does not have a SNMP enumeration defined to the type.\n            ')
lgpPduRbEntryCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-specified", 0), ("no-optional-capabilities", 1), ("measurement-only", 2), ("measurement-and-control", 3), ("control-only", 4), ("current-measurement-only", 5), ("current-measurement-and-control", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryCapabilities.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryCapabilities.setDescription('Receptacle branch capabilities describes what an individual branch\n             is capable of.\n\n             no-optional-capabilities\n                 The branch is unable to report measurements and lacks\n                 control capabilities.\n             measurement-only\n                 The branch is capable of reporting multiple measurements.\n             measurement-and-control\n                 The branch is capable of reporting multiple measurements\n                 and controlling the state.\n             control-only\n                 The branch is capable of controlling the state.\n             current-measurement-only\n                 The branch is capable of reporting the current/amperage only.\n             current-measurement-and-control\n                 The branch is capable of reporting the current/amperage and\n                 has the ability to control the state.')
lgpPduRbEntryLineSource = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("not-specified", 0), ("line-1-neutral", 1), ("line-2-neutral", 2), ("line-3-neutral", 3), ("line-1-line-2", 4), ("line-2-line-3", 5), ("line-3-line-1", 6), ("line-1-line-2-and-line-1-neutral", 7), ("line-2-line-3-and-line-2-neutral", 8), ("line-3-line-1-and-line-3-neutral", 9), ("unknown-line-neutral", 10), ("unknown-line-line", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryLineSource.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryLineSource.setDescription('This represents the line source that is supplying power to this\n            receptacle branch.\n                not-specified\n                    The line source supplying power to the load for this\n                    receptacle branch has not been specified/configured.\n                line-1-N\n                    The load for this receptacle branch is supplied by\n                    a line-to-neutral configuration. (line 1 to neutral).\n                line-2-N\n                    The load for this receptacle branch is supplied by\n                    a line-to-neutral configuration. (line 2 to neutral).\n                line-3-N\n                    The load for this receptacle branch is supplied by\n                    a line-to-neutral configuration. (line 3 to neutral).\n                line-1-line-2\n                    The load for this receptacle branch is supplied by\n                    a line-to-line configuration (line 1 to line 2).\n                line-2-line-3\n                    The load for this receptacle branch is supplied by\n                    a line-to-line configuration (line 2 to line 3).\n                line-3-line-1\n                    The load for this receptacle branch is supplied by\n                    a line-to-line configuration (line 3 to line 1).\n                line-1-line-2-and-line-1-neutral\n                    The load for this mixed receptacle branch is supplied by\n                    a line-to-line and line-to-neutral configuration\n                    (line 1 to line 2 and line 1 to neutral).\n                line-2-line-3-and-line-2-neutral\n                    The load for this mixed receptacle branch is supplied by\n                    a line-to-line and line-to-neutral configuration\n                    (line 2 to line 3 and line 2 to neutral).\n                line-3-line-1-and-line-3-neutral\n                    The load for this mixed receptacle branch is supplied by\n                    a line-to-line and line-to-neutral configuration\n                    (line 3 to line 1 and line 3 to neutral).\n                unknown-line-neutral\n                    The load for this branch is supplied by\n                    a line-to-neutral configuration. The system is unable to\n                    determine which lines are supporting the load.\n                unknown-line-line\n                    The load for this branch is supplied by\n                    a line-to-line configuration. The system is unable to\n                    determine which lines are supporting the load.\n            ')
lgpPduRbEntryRcpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 60), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryRcpCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryRcpCount.setDescription('The number of receptacles on this receptacle branch.')
lgpPduRbEntryEpRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 70), Unsigned32()).setUnits('VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEpRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEpRated.setDescription('Rated Line Voltage for the receptacle branch and its associated\n             receptacles (i.e. This is the nominal line voltage that is\n             available to the connected load; it is NOT a measured voltage.)')
lgpPduRbEntryEcRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 75), Unsigned32()).setUnits('0.1 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEcRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcRated.setDescription('This is the rated input line current for the module\n            (it is NOT the measured current).')
lgpPduRbEntryFreqRated = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 80), Unsigned32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryFreqRated.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryFreqRated.setDescription('This is the rated electrical frequency for the receptacle branch\n             and its associated receptacles')
lgpPduRbEntryEnergyAccum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 85), Unsigned32()).setUnits('0.1 Kilowatt-Hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryEnergyAccum.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEnergyAccum.setDescription('Total accumulated energy, measured at the receptacle branch input,\n             since the last energy reset. Writing a value of 0 (zero) to this\n             causes the accumulated energy to be reset. Writing a non-zero\n             value is invalid and shall result in a write error and the\n             total energy value remains unchanged.\n\n             If the energy has not been reset and has not wrapped, then this\n             is the total energy since installation.\n\n             This value persists across boot events.\n\n             NOTE: Resetting this value does not reset the values for the\n             individual receptacles.')
lgpPduRbEntryEpLNTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 100), Unsigned32()).setUnits('0.1 VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEpLNTenths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEpLNTenths.setDescription('The line-to-neutral measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduRbEntryPwr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 115), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryPwr.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryPwr.setDescription('The line-to-neutral measurement of the Real Power (Wattage)')
lgpPduRbEntryAp = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 120), Unsigned32()).setUnits('VoltAmp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryAp.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryAp.setDescription('The line-to-neutral measurement of the Apparent Power (VA)')
lgpPduRbEntryPf = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 125), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryPf.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryPf.setDescription("The line-to-neutral measurement of the Power Factor of the\n             receptacle branches' input.")
lgpPduRbEntryEcHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 130), Unsigned32()).setUnits('0.01 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEcHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcHundredths.setDescription('The line-to-neutral measurement of the Electrical Current\n             measured in Amperes RMS (Root Mean Squared).')
lgpPduRbEntryEcThrshldUndrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 135), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldUndrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldUndrAlm.setDescription('The threshold at which an under current alarm is activated.  If\n             the measured current (lgpPduRbEntryEc) is equal to or below\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an under current alarm\n             is activated')
lgpPduRbEntryEcThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 140), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldOvrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldOvrWarn.setDescription('The threshold at which an over current warning is activated.  If\n             the measured current (lgpPduRbEntryEc) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current warning\n             is activated')
lgpPduRbEntryEcThrshldOvrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 145), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldOvrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcThrshldOvrAlm.setDescription('The threshold at which an over current alarm is activated.  If\n             the measured current (lgpPduRbEntryEcLN) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current alarm\n             is activated')
lgpPduRbEntryEcAvailBeforeAlarmHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 150), Unsigned32()).setUnits('0.01 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEcAvailBeforeAlarmHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcAvailBeforeAlarmHundredths.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduRbEntryEcUsedBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 160), Unsigned32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEcUsedBeforeAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEcUsedBeforeAlarm.setDescription('The percent of current utilization relative to the over current\n             alarm threshold.')
lgpPduRbEntryEpLLTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 170), Unsigned32()).setUnits('0.1 VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbEntryEpLLTenths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntryEpLLTenths.setDescription('The line-to-line measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduRbEntrySwOverCurrentProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 20, 1, 175), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbEntrySwOverCurrentProtection.setStatus('current')
if mibBuilder.loadTexts: lgpPduRbEntrySwOverCurrentProtection.setDescription('The configuration parameter to enable or disable the Branch\n            SW Over Current Protection feature.If the feature is enabled, in case of Over Current Warning or Alarm condition, following action will be taken on the receptacles:\n            Locked & On - No Change\n            Locked & Off - No Change\n            Unlocked & Off - Turn it Off and Lock it\n            Unlocked & On - If load present, No Change. If no load, turn it Off and Lock it.\n            No action will be taken if the feature is disabled.\n            Note: Only applicable to PDU models where receptacle measurement and control is possible. Not applicable to branch monoitoring models\n\n         disabled\n              This function is disabled.\n         enable\n              This function is enabled.')
lgpPduRbLineTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40), )
if mibBuilder.loadTexts: lgpPduRbLineTable.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineTable.setDescription('This table contains a list of PDU receptacle branch line/phase\n         measurements. The table contains zero, one, or many rows, depending\n         upon the number of PDUs and the number of receptacle branches\n         on each PDU that are being monitored.\n\n         The NMS cannot create or delete rows in the table.\n         The rows are created by the agent based upon the capabilities of the\n         PDU(s) being monitored.  Each row in the table represents a\n         particular phase/line measurement of a PDU Receptacle\n         Branch.\n\n         Rows in the table are uniquely identified by three indexes representing\n         respectively the PDU (lgpPduEntryIndex), the receptacle\n         branch (lgpPduRbEntryIndex) and the line/phase being\n         measured (lgpPduRbLineEntryIndex).\n         ')
lgpPduRbLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduRbEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduRbLineEntryIndex"))
if mibBuilder.loadTexts: lgpPduRbLineEntry.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduRbLineTable'.  The table is\n             indexed by three indexes.  The 'lgpPduEntryIndex' references\n             a PDU in the 'lgpPduTable' to which this receptacle branch\n             line/phase measurement belongs.  The 'lgpPduRbEntryIndex' together\n             with the 'lgpPduEntryIndex' references the receptacle branch\n             in the 'lgpPduRbTable'.  The 'lgpPduRbLineEntryIndex' represents\n             the line/phase of the measurements in the row of this table.\n             Together these three indexes uniquely identify a phase/line\n             measurement on a receptacle branch within a PDU being monitored\n             by this agent.\n            ")
lgpPduRbLineEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduRbLineEntryIndex.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryIndex.setDescription("This is the index that indicates the row of the\n             'lgpPduRbLineTable'")
lgpPduRbLineEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryId.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryId.setDescription('Runtime assigned branch identifier.')
lgpPduRbLineEntryLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("phase1", 1), ("phase2", 2), ("phase3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryLine.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryLine.setDescription('The line number or phase that the measurement for this\n             receptacle branch represents for each measurement in this row of\n             the table.  The phases are as follows:\n              Line#  Description\n              -----  ---------------------------------------------------\n                 1   Line 1-N (A) for Line-to-Neutral measurements\n                 2   Line 2-N (B) for Line-to-Neutral measurements\n                 3   Line 3-N (C) for Line-to-Neutral measurements\n\n                 1   Line 1-2 (A-B) for Line-to-Line measurements\n                 2   Line 2-3 (B-C) for Line-to-Line measurements\n                 3   Line 3-1 (C-A) for Line-to-Line measurements\n             ')
lgpPduRbLineEntryEpLNTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 19), Unsigned32()).setUnits('0.1 VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLNTenths.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLNTenths.setDescription('The line-to-neutral measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduRbLineEntryEpLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 20), Unsigned32()).setUnits('VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLN.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLN.setDescription('The line-to-neutral measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduRbLineEntryEc = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 21), Unsigned32()).setUnits('0.1 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEc.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEc.setDescription('The line-to-neutral measurement of the Electrical Current\n             measured in Amperes RMS (Root Mean Squared).')
lgpPduRbLineEntryPwr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 22), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryPwr.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryPwr.setDescription('The line-to-neutral measurement of the Real Power (Wattage)')
lgpPduRbLineEntryAp = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 23), Unsigned32()).setUnits('VoltAmp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryAp.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryAp.setDescription('The line-to-neutral measurement of the Apparent Power (VA)')
lgpPduRbLineEntryPf = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 24), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryPf.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryPf.setDescription("The line-to-neutral measurement of the Power Factor of the\n             receptacle branches' input.")
lgpPduRbLineEntryEcHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 25), Unsigned32()).setUnits('0.01 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcHundredths.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcHundredths.setDescription('The line-to-neutral measurement of the Electrical Current\n             measured in Amperes RMS (Root Mean Squared).')
lgpPduRbLineEntryEcThrshldUndrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 35), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldUndrAlm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldUndrAlm.setDescription('The threshold at which an under current alarm is activated.  If\n             the measured current (lgpPduRbLineEntryEc) is equal to or below\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an under current alarm\n             is activated')
lgpPduRbLineEntryEcThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 36), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldOvrWarn.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldOvrWarn.setDescription('The threshold at which an over current warning is activated.  If\n             the measured current (lgpPduRbLineEntryEc) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current warning\n             is activated')
lgpPduRbLineEntryEcThrshldOvrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 37), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldOvrAlm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcThrshldOvrAlm.setDescription('The threshold at which an over current alarm is activated.  If\n             the measured current (lgpPduRbLineEntryEcLN) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current alarm\n             is activated')
lgpPduRbLineEntryEcAvailBeforeAlarmHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 39), Unsigned32()).setUnits('0.01 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcAvailBeforeAlarmHundredths.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcAvailBeforeAlarmHundredths.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduRbLineEntryEcAvailBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 40), Unsigned32()).setUnits('0.1 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcAvailBeforeAlarm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcAvailBeforeAlarm.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduRbLineEntryEcUsedBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 41), Unsigned32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEcUsedBeforeAlarm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEcUsedBeforeAlarm.setDescription('The percent of current utilization relative to the over current\n             alarm threshold.')
lgpPduRbLineEntryEpLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 60), Unsigned32()).setUnits('VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLL.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLL.setDescription('The line-to-line measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduRbLineEntryEpLLTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 40, 40, 1, 61), Unsigned32()).setUnits('0.1 VoltRMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLLTenths.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduRbLineEntryEpLLTenths.setDescription('The line-to-line measurement of the Electrical Potential\n             measured in Volts RMS (Root Mean Squared).')
lgpPduReceptacle = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50))
if mibBuilder.loadTexts: lgpPduReceptacle.setStatus('current')
if mibBuilder.loadTexts: lgpPduReceptacle.setDescription('This sub-tree contains information about PDU receptacles.')
if mibBuilder.loadTexts: lgpPduReceptacle.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduRcpTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 19), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpTableCount.setDescription('Number of receptacles in the lgpPduRcpTable.')
lgpPduRcpTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20), )
if mibBuilder.loadTexts: lgpPduRcpTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpTable.setDescription('This table contains a list of PDU receptacle entries.\n         The table contains numerous rows representing an individual\n         receptacle, depending upon the number and configuration of\n         the PDU(s) being monitored by the agent.\n\n         The NMS cannot create or delete rows in the table. The rows are\n         created by the agent based upon the capabilities of the managed\n         PDU(s).  Each row in the table represents a receptacle in\n         the system.\n         ')
lgpPduRcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduRbEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduRcpEntryIndex"))
if mibBuilder.loadTexts: lgpPduRcpEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduRcpTable'.  This table is indexed\n             by three indexes. The 'lgpPduEntryIndex' references a PDU in\n             the 'lgpPduTable' that a given row in this table represents.\n             The 'lgpPduRbEntryIndex' together with the 'lgpPduEntryIndex'\n             specifies a row in the 'lgpPduRbTable' that the receptacle\n             belongs.  The 'lgpPduRcpEntryIndex' identifies the particular\n             receptacle within the branch.\n            ")
lgpPduRcpEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduRcpEntryIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryIndex.setDescription('This is the index that indicates the receptacle position on the\n             receptacle branch.  This along with the other two indexes on the\n             lgpPduRcpTable uniquely identify the receptacle in this table.')
lgpPduRcpEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryId.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryId.setDescription('A runtime assigned receptacle identification number.')
lgpPduRcpEntryUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryUsrLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryUsrLabel.setDescription('User assigned label for this receptacle.')
lgpPduRcpEntryUsrTag1 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryUsrTag1.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryUsrTag1.setDescription('User assigned Tag to assist in identifying or grouping this\n             receptacle within the end-users domain.')
lgpPduRcpEntryUsrTag2 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryUsrTag2.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryUsrTag2.setDescription('User assigned Tag to assist in identifying or grouping this\n             receptacle within the end-users domain.')
lgpPduRcpEntrySysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntrySysAssignLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntrySysAssignLabel.setDescription('System assigned identifier representing the receptacle. The value\n             is independent of any user assigned label or tag. The exact format\n             of this label is system dependent and is subject to change,\n             therefore, it should not be referenced for programmatic use.')
lgpPduRcpEntryPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryPosition.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPosition.setDescription('A number representing the position of the receptacle within the\n             receptacle branch.')
lgpPduRcpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 7, 8))).clone(namedValues=NamedValues(("not-specified", 0), ("nema-5-20R-20-Amp", 1), ("iec-C13-sheet-F-10-Amp", 2), ("iec-C19-sheet-J-16-Amp", 3), ("cee-7-type-E-schuko", 7), ("nema-L6-30R-30-Amp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryType.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryType.setDescription('The type or form of receptacle.  The enumerations are specified\n             in well-known industry standard terms and abbreviations.')
lgpPduRcpEntryLineSource = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("not-specified", 0), ("line-1-N", 1), ("line-2-N", 2), ("line-3-N", 3), ("line-1-line-2", 4), ("line-2-line-3", 5), ("line-3-line-1", 6), ("unknown-line-neutral", 7), ("unknown-line-line", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryLineSource.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryLineSource.setDescription('This represents the line source that is supplying power to this\n             receptacle.\n                not-specified\n                    The line source supplying power to the load for this\n                    receptacle has not been specified/configured.\n                line-1-N\n                    The load for this receptacle is supplied by\n                    a line-to-neutral configuration. (line 1 to neutral).\n                line-2-N\n                    The load for this receptacle is supplied by\n                    a line-to-neutral configuration. (line 2 to neutral).\n                line-3-N\n                    The load for this receptacle is supplied by\n                    a line-to-neutral configuration. (line 3 to neutral).\n                line-1-line-2\n                    The load for this receptacle is supplied by\n                    a line-to-line configuration (line 1 to line 2).\n                line-2-line-3\n                    The load for this receptacle is supplied by\n                    a line-to-line configuration (line 2 to line 3).\n                line-3-line-1\n                    The load for this receptacle is supplied by\n                    a line-to-line configuration (line 3 to line 1).\n                unknown-line-neutral\n                    The load for this receptacle is supplied by\n                    a line-to-neutral configuration. The system is unable to\n                    determine which lines are supporting the load.\n                unknown-line-line\n                    The load for this receptacle is supplied by\n                    a line-to-line configuration. The system is unable to\n                    determine which lines are supporting the load.\n            ')
lgpPduRcpEntryCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-specified", 0), ("no-optional-capabilities", 1), ("measurement-only", 2), ("measurement-and-control", 3), ("control-only", 4), ("current-measurement-only", 5), ("current-measurement-and-control", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryCapabilities.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryCapabilities.setDescription('Receptacle capabilities describes what an individual receptacle is\n             capable of.\n\n             no-optional-capabilities\n                 The receptacle is unable to report measurements and lacks\n                 control capabilities.\n             measurement-only\n                 The receptacle is capable of reporting multiple measurements.\n             measurement-and-control\n                 The receptacle is capable of reporting multiple measurements\n                 and controlling the state.\n             control-only\n                 The receptacle is capable of controlling the state.\n             current-measurement-only\n                 The receptacle is capable of reporting the current/amperage\n                 only.\n             current-measurement-and-control\n                 The receptacle is capable of reporting the current/amperage and\n                 has the ability to control the state.')
lgpPduRcpEntryEp = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 55), Unsigned32()).setUnits('Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEp.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEp.setDescription('Voltage being delivered to the load attached to the receptacle.\n             Alternating Current RMS Electrical Potential measurement.')
lgpPduRcpEntryEpTenths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 56), Unsigned32()).setUnits('0.1 Volts-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEpTenths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEpTenths.setDescription('Voltage being delivered to the load attached to the receptacle.\n             Alternating Current RMS Electrical Potential measurement.')
lgpPduRcpEntryEc = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 60), Unsigned32()).setUnits('0.1 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEc.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEc.setDescription('Current (amperage) being delivered to the load attached to\n             the receptacle. Electrical Current is measured in\n             Amperes RMS (Root Mean Squared).')
lgpPduRcpEntryEcHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 61), Unsigned32()).setUnits('0.01 Amp-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEcHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcHundredths.setDescription('Current (amperage) being delivered to the load attached to\n             the receptacle. Electrical Current is measured in\n             Amperes RMS (Root Mean Squared).')
lgpPduRcpEntryPwrOut = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 65), Unsigned32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryPwrOut.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPwrOut.setDescription('Real Power (watts) being delivered to the load attached to\n             the receptacle.')
lgpPduRcpEntryApOut = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 70), Unsigned32()).setUnits('Volt-Amp-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryApOut.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryApOut.setDescription('Apparent Power (volt-amps) being delivered to the load\n             attached to the receptacle.')
lgpPduRcpEntryPf = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 75), Unsigned32()).setUnits('.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryPf.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPf.setDescription('Receptacle Power Factor, which is the ratio of real power\n             to apparent power (i.e. ratio of watts to volts-amps).')
lgpPduRcpEntryFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 80), Unsigned32()).setUnits('0.1 Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryFreq.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryFreq.setDescription('The measured line frequency being delivered to the load\n             attached to the receptacle.')
lgpPduRcpEntryEnergyAccum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 85), Unsigned32()).setUnits('0.1 Kilowatt-Hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryEnergyAccum.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEnergyAccum.setDescription('Total accumulated energy, measured at the module input, since\n             the last energy reset. Writing a value of 0 (zero) to this\n             causes the accumulated energy to be reset. Writing a non-zero\n             value is invalid and shall result in a write error and the\n             total energy value remains unchanged.\n\n             If the energy has not been reset and has not wrapped,\n             then this is the total energy since installation.\n\n             This value persists across boot events.')
lgpPduRcpEntryPwrOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 90), Unsigned32()).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryPwrOnDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPwrOnDelay.setDescription('The amount of time to wait before power is applied to the\n            receptacle after a power strip is turned on or rebooted.\n            This can be used to stagger the powering of multiple\n            receptacles in order to prevent a large initial current\n            draw.')
lgpPduRcpEntryPwrState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("off", 1), ("on", 2), ("off-pending-on-delay", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryPwrState.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPwrState.setDescription('unknown\n                The current power state is unknown.\n             off\n                The current power state of the receptacle is OFF.\n             on\n                The current power state of the receptacle is ON.\n             off-pending-on-delay\n                The current power state of the receptacle is OFF.  The power\n                will be ON at the expiration of the ON delay of this\n                receptacle.')
lgpPduRcpEntryPwrUpState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("last-state", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryPwrUpState.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPwrUpState.setDescription("The 'Power Up State' defines the state to which the receptacle shall return \n\t    after a power cycle of the PDU.\n\t\n\t     on\n\t   \tThe receptacle shall be switched to the ON state after the power on delay\n                timer (lgpPduRcpEntryPwrOnDelay).\n\t     off\n\t   \tThe receptacle shall be in the OFF state upon power cycle. \n             last-state\n\t   \tThe receptacle shall be put to the previous state. Again, on state will be \n\t\teffective only after the power on delay (lgpPduRcpEntryPwrOnDelay).")
lgpPduRcpEntryControl = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("cycle-power", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryControl.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryControl.setDescription("This object represents the current and persistent (configured)\n             power state of the receptacle.  The receptacle can also be\n             controlled by writing to this object.\n             off\n                 The current and persisted (configured) power state of the\n                 receptacle is 'off'.  When writing 'off' to this object the\n                 receptacle, if ON, will be turned OFF and its persistent\n                 (configured) power state will be set to 'off'.\n             on\n                 The current and persisted (configured) power state of the\n                 receptacle is 'on'.  When writing 'on' to this object the\n                 receptacle, if 'off', will be turned 'on' and its persistent\n                 (configured) power state will be set to 'on'.\n             cycle-power\n                 The receptacle is currently in a power-cycle state. The\n                 power to the receptacle is being turned off momentarily and\n                 will then revert to being 'on'.\n                 When writing 'cycle-power' to this OBJECT if the receptacle is\n                 'on' it will be momentarily turned 'off' and then revert to the\n                 'on' state.  The receptacle's persistent (configured) power\n                 state will be left unchanged ('on').\n\n                 If the receptacle is OFF writing cycle-power has no\n                 affect on the receptacle.\n            ")
lgpPduRcpEntryControlLock = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 105), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("unlocked", 1), ("locked", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryControlLock.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryControlLock.setDescription("This object represents the locked state of the receptacle.\n\n             unknown\n                 The lock state of the receptacle is not known at this time.\n             locked\n                 If the receptacle is 'locked' then its current persisted\n                 (configured) state can not be changed.\n             unlocked\n                 If the receptacle is 'unlocked', then a user with proper\n                 permissions may change the receptacles state.")
lgpPduRcpEntryEcThrshldUnderAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 150), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldUnderAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldUnderAlarm.setDescription('The threshold at which an under current alarm is activated.  If\n             the measured current (lgpPduRbLineEntryEcLL) is equal to or below\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an under current alarm\n             is activated')
lgpPduRcpEntryEcThrshldOverWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 151), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldOverWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldOverWarn.setDescription('The threshold at which an over current warning is activated.  If\n             the measured current (lgpPduRbLineEntryEcLL) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current warning\n             is activated')
lgpPduRcpEntryEcThrshldOverAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 152), Unsigned32()).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldOverAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcThrshldOverAlarm.setDescription('The threshold at which an over current alarm is activated.  If\n             the measured current (lgpPduRbLineEntryEcLL) is equal to or over\n             this percentage of the full scale rated value\n             (lgpPduRbEntryEcRated), an over current alarm\n             is activated')
lgpPduRcpEntryEcAvailBeforeAlarmHundredths = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 159), Unsigned32()).setUnits('0.01 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEcAvailBeforeAlarmHundredths.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcAvailBeforeAlarmHundredths.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduRcpEntryEcAvailBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 160), Unsigned32()).setUnits('0.1 Amps-AC-RMS').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEcAvailBeforeAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcAvailBeforeAlarm.setDescription('The amount that the current/amperage may increase from its present\n             value before an over current alarm occurs.')
lgpPduRcpEntryEcUsedBeforeAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 161), Unsigned32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEcUsedBeforeAlarm.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcUsedBeforeAlarm.setDescription('The percent of current utilization relative to the over current\n             alarm threshold.')
lgpPduRcpEntryEcCrestFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 162), Unsigned32()).setUnits('0.01').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryEcCrestFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryEcCrestFactor.setDescription('Receptacle current crest factor, which is the peak amplitude of the\n             current waveform divided by the RMS value of the waveform.')
lgpPduRcpEntryBlinkLED = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 200), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("blinkLED", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryBlinkLED.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryBlinkLED.setDescription('Blink the receptacle LED. Writing blinkLED(2) will cause the LED\n             to blink for a predefined duration of time. Reading this object\n             will always return noAction(1).')
lgpPduRcpEntrySwOverTemperatureProtection = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 205), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntrySwOverTemperatureProtection.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntrySwOverTemperatureProtection.setDescription('The configuration parameter to enable or disable the Receptacle\n            SW Over Temperature Protection feature\n            If the feature is enabled, in case of Over Temperature Alarm condition,\n            following action will be taken on the receptacles:\n            Locked & Off - No Change\n            Unlocked & Off - No Change\n            Unlocked & On - Turn it Off.\n            Locked & On - Turn it Off and keep it Locked.\n\n            No action will be taken if the feature is disabled.')
lgpPduRcpEntryOperationCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 210), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normalOperation", 1), ("normalWithWarning", 2), ("normalWithAlarm", 3), ("abnormal", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpEntryOperationCondition.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryOperationCondition.setDescription("Receptacle Operating Condition - indicates the condition of the receptacle.\n\n             The operating condition has the following:\n\n             Normal\n                 Normal operation without any alarm or warning.\n             Alarm\n                 An Alarm condition due to over/under current.\n             Warning\n                 A Warning condition due to over/under current\n             Abnormal\n                 A condition in which the outlet is in 'Power Off State' but still drawing current.")
lgpPduRcpEntryCriticality = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 215), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("critical", 0), ("notCritical", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryCriticality.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryCriticality.setDescription('The configuration parameter can be used by the user to mark a receptacle as\n            critical or non-critical.')
lgpPduRcpEntryPostOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 220), Unsigned32()).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryPostOnDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPostOnDelay.setDescription("The 'Post On Delay' is the time interval (in seconds) that the PDU waits after\n            a command is issued to switch ON a receptacle before applying power to the receptacle\n\n            A value of zero implies that there is no delay (i.e. the receptacle is turned on\n            immediately on command issue).")
lgpPduRcpEntryPostOffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 225), Unsigned32()).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryPostOffDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryPostOffDelay.setDescription("The 'Post Off Delay' is the time interval (in seconds) that the PDU waits after\n            a command is issued to switch OFF a receptacle before removing power from the receptacle\n\n            A value of zero implies that there is no delay (i.e. the receptacle is turned off\n            immediately on command issue).")
lgpPduRcpEntryAddReceptacleToGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 230), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryAddReceptacleToGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryAddReceptacleToGroup.setDescription('This receptacle can be added to a group by writing a corresponding\n             OID to this column.  The OID must be a pointer to the \n             lgpPduRcpGroupUsrLabel from the lgpPduRcpGroupTable.\n             For example, to add this receptacle to group 1, the oid \n             .1.3.6.1.4.1.476.1.42.3.8.50.30.10.1.1 would be written to \n             this column.')
lgpPduRcpEntryRemoveReceptacleFromGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 20, 1, 235), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpEntryRemoveReceptacleFromGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpEntryRemoveReceptacleFromGroup.setDescription('This receptacle can be removed from a group by writing a corresponding\n             OID to this column.  The OID must be a pointer to the \n             lgpPduRcpGroupUsrLabel from the lgpPduRcpGroupTable.\n             For example, to remove this receptacle from group 1, the oid \n             .1.3.6.1.4.1.476.1.42.3.8.50.30.10.1.1 would be written to \n             this column.')
lgpPduRcpGroup = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30))
if mibBuilder.loadTexts: lgpPduRcpGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroup.setDescription("This sub-tree contains information about receptacle groups.\n         Receptacle groups are supported by some PDU's and allow control of \n         multiple receptacles at a time by issuing commands to an associated \n         receptacle group.")
if mibBuilder.loadTexts: lgpPduRcpGroup.setReference('The registrations for the objects in this sub-tree are\n         defined below.')
lgpPduRcpGroupTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 9), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpGroupTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupTableCount.setDescription('Number of receptacle groups (rows) in the lgpPduRcpGroupTable.')
lgpPduRcpGroupTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10), )
if mibBuilder.loadTexts: lgpPduRcpGroupTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupTable.setDescription('This table contains a list of the possible receptacle groups\n         that can be created.  The table contains a fixed number of rows, which\n         is the maximum number of receptacle groups that can be used.')
lgpPduRcpGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduRcpGroupIndex"))
if mibBuilder.loadTexts: lgpPduRcpGroupEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduRcpGroupTable'.\n             This table is indexed by lgpPduRcpGroupIndex.\n            ")
lgpPduRcpGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduRcpGroupIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupIndex.setDescription('This is an index into the table.  There will always be 64 rows,\n             each representing a separate receptacle group.\n            ')
lgpPduRcpGroupUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpGroupUsrLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupUsrLabel.setDescription('User assigned identifier for this receptacle group.')
lgpPduRcpGroupDeleteGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-action", 0), ("delete-receptacle-group", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpGroupDeleteGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDeleteGroup.setDescription('This column will delete the receptacles from the group when written to.')
lgpPduRcpGroupControlPower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("no-action", 0), ("off", 1), ("on", 2), ("cycle-power", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpGroupControlPower.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupControlPower.setDescription('This column controls the power to the group of receptacles.  The corresponding\n             operation will be performed on all receptacles that have been added to the group.            \n            ')
lgpPduRcpGroupControlLock = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no-action", 0), ("unlock", 1), ("lock", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpGroupControlLock.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupControlLock.setDescription('This column controls the locking of the group of receptacles.  The corresponding\n             operation will be performed on all receptacles that have been added to the group.            \n            ')
lgpPduRcpGroupBlinkLED = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 10, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-action", 0), ("blinkLED", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduRcpGroupBlinkLED.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupBlinkLED.setDescription("This column will blink the LED's associated with all receptacles that are part of\n             the group.            \n            ")
lgpPduRcpGroupDisplayTableCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 19), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayTableCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayTableCount.setDescription('Number of rows currently in the lgpPduRcpGroupDisplayTable.')
lgpPduRcpGroupDisplayTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 20), )
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayTable.setDescription('This table is used to display which receptacle groups are currently\n         defined and which receptacles are associated with each group.\n         The table will have 0 rows when no receptacles have been added to any receptacle\n         groups.  If a single receptacle has been added to 2 different groups, \n         there will be 2 rows in the table.\n        ')
lgpPduRcpGroupDisplayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduRcpGroupIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"))
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduRcpGroupDisplayTable'.\n             This table is indexed by two indexes. \n             The 'lgpPduRcpGroupIndex' references a receptacle group in\n             the 'lgpPduRcpGroupTable' that a given row in this table represents.\n             The 'lgpPduEntryIndex' references a PDU in the 'lgpPduTable' \n             that identifies the particular PDU receptacle list \n             within the receptacle group.\n            ")
lgpPduRcpGroupDisplayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 20, 1, 10), Unsigned32())
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayIndex.setDescription('This is an index into the table.  There can be zero or more rows\n             in this table.')
lgpPduRcpGroupDisplayGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 50, 30, 20, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPduRcpGroupDisplayGroup.setDescription('This column displays the PDU receptacle list of the specified \n             receptacle group.  The value in this column is a comma delimted string that decribes\n\t\t  the list of receptacles of a PDU that are members of the receptacle group.\n             For example, if receptacles 1 and 3 of branch A and receptacles 2 and 4 \n             of branch B are members of the receptacle group, this column \n             would show: A-1,A-3,B-2,B-4')
lgpPduAuxiliarySensors = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60))
if mibBuilder.loadTexts: lgpPduAuxiliarySensors.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxiliarySensors.setDescription('This sub-tree contains information about PDU Auxiliary Sensors.')
if mibBuilder.loadTexts: lgpPduAuxiliarySensors.setReference('The registrations for the objects in this sub-tree are\n        defined below.')
lgpPduAuxSensorCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 5), Unsigned32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorCount.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxSensorCount.setDescription('Number of auxiliary sensors in the lgpPduAuxSensorTable.')
lgpPduAuxSensorTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10), )
if mibBuilder.loadTexts: lgpPduAuxSensorTable.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTable.setDescription("This table contains a list of the PDU's Auxiliary Sensors.\n         The table contains zero, one, or more rows, depending\n         upon the number of PDUs being monitored and the number of\n         auxiliary sensors installed for each PDU.\n         The NMS cannot create or delete rows in the table. The rows are\n         created by the agent based upon the capabilities of the PDUs\n         being monitored.  Each row in the table represents an auxiliary\n         sensor in a PDU.")
lgpPduAuxSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduAuxSensorIndex"))
if mibBuilder.loadTexts: lgpPduAuxSensorEntry.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduAuxSensorTable'.\n             This table is indexed by both the 'lgpPduEntryIndex' which is\n             the sole index into the 'lgpPduTable' and the\n             'lgpPduAuxSensorIndex'which is a unique identifier for the\n             auxiliary sensor attached to the given PDU.  Taken together these\n             two indexes uniquely identify an Auxiliary Sensor within this\n             agent.")
lgpPduAuxSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduAuxSensorIndex.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorIndex.setDescription('This is the index indicating the nth element of the table.')
lgpPduAuxSensorMeasType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("not-specified", 0), ("temperature", 1), ("humidity", 2), ("temperature-and-humidity", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorMeasType.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorMeasType.setDescription('not-specified\n                The type of sensor is unknown.\n             temperature\n                The sensor in this row of the table measures temperature.\n             humidity\n                The sensor in this row of the table measures relative humidity.\n             temperature-and-humidity\n                The sensor in this row of the table measures both temperature\n                and relative humidity.')
lgpPduAuxSensorId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorId.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorId.setDescription('System assigned auxiliary sensor identification number. The value\n             assigned is product specific.')
lgpPduAuxSensorSysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorSysAssignLabel.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorSysAssignLabel.setDescription('Label assigned to the auxiliary sensor at runtime by the system.\n             The value is independent of any user assigned label or asset tag.')
lgpPduAuxSensorPositionRelative = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorPositionRelative.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorPositionRelative.setDescription("Auxiliary sensor relative position.  This is a one-based value\n             that indicates the sensor's position relative to the sensor string\n             connector.")
lgpPduAuxSensorUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorUsrLabel.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorUsrLabel.setDescription('User assigned auxiliary sensor label.')
lgpPduAuxSensorUsrTag1 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 30), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorUsrTag1.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorUsrTag1.setDescription('User assigned Tag to assist in identifying or grouping this\n             auxiliary sensor within the end-users domain.')
lgpPduAuxSensorUsrTag2 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 35), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorUsrTag2.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorUsrTag2.setDescription('User assigned Tag to assist in identifying or grouping this\n             auxiliary sensor within the end-users domain.')
lgpPduAuxSensorTempSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 40), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorTempSerialNum.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempSerialNum.setDescription("The temperature sensor's globally unique serial number assigned at\n             the time of manufacture.")
lgpPduAuxSensorHumSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 45), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorHumSerialNum.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumSerialNum.setDescription("The humidity sensor's globally unique serial number assigned at\n             the time of manufacture.")
lgpPduAuxSensorTempMeasurementDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 50), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorTempMeasurementDegF.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempMeasurementDegF.setDescription('Temperature measured at the temperature sensor reported in\n             degrees Fahrenheit.')
lgpPduAuxSensorTempThrshldUndrAlmDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 55), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrAlmDegF.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrAlmDegF.setDescription('Under temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or below this value.')
lgpPduAuxSensorTempThrshldOvrAlmDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 60), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrAlmDegF.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrAlmDegF.setDescription('Over temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxSensorTempThrshldUndrWarnDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 65), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrWarnDegF.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrWarnDegF.setDescription('Under temperature warning threshold.  A warning is activated if\n             the temperature is equal to or below this value.')
lgpPduAuxSensorTempThrshldOvrWarnDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 70), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrWarnDegF.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrWarnDegF.setDescription('Over temperature warning threshold.  A warning is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxSensorTempMeasurementDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 75), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorTempMeasurementDegC.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempMeasurementDegC.setDescription('Temperature measured at the temperature sensor reported in\n             degrees Celsius.')
lgpPduAuxSensorTempThrshldUndrAlmDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 80), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrAlmDegC.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrAlmDegC.setDescription('Under temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or below this value.')
lgpPduAuxSensorTempThrshldOvrAlmDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 85), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrAlmDegC.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrAlmDegC.setDescription('Over temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxSensorTempThrshldUndrWarnDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 90), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrWarnDegC.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldUndrWarnDegC.setDescription('Under temperature warning threshold.  A warning is activated if\n             the temperature is equal to or below this value.')
lgpPduAuxSensorTempThrshldOvrWarnDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 95), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrWarnDegC.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorTempThrshldOvrWarnDegC.setDescription('Over temperature warning threshold.  A warning is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxSensorHumMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 100), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxSensorHumMeasurement.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumMeasurement.setDescription('Relative Humidity measured at the humidity sensor.')
lgpPduAuxSensorHumThrshldUndrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 105), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldUndrAlm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldUndrAlm.setDescription('Under relative humidity alarm threshold.  An alarm is activated\n             if the relative humidity is equal to or below this value.')
lgpPduAuxSensorHumThrshldOvrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 110), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldOvrAlm.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldOvrAlm.setDescription('Over relative humidity alarm threshold.  An alarm is activated\n             if the relative humidity is equal to or above this value.')
lgpPduAuxSensorHumThrshldUndrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 115), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldUndrWarn.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldUndrWarn.setDescription('Under relative humidity warning threshold.  A warning is activated\n             if the relative humidity is equal to or below this value.')
lgpPduAuxSensorHumThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 10, 1, 120), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldOvrWarn.setStatus('deprecated')
if mibBuilder.loadTexts: lgpPduAuxSensorHumThrshldOvrWarn.setDescription('Over relative humidity warning threshold.  A warning is activated\n             if the relative humidity is equal to or above this value.')
lgpPduAuxMeasTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15), )
if mibBuilder.loadTexts: lgpPduAuxMeasTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTable.setDescription("This table contains a list of the PDU's Auxiliary Sensor Measurements.\n         The table contains zero, one, or more rows, depending\n         upon the number of PDUs being monitored, the number of auxiliary\n         sensors installed for each PDU, and the number of measurements within\n         each sensor. The NMS cannot create or delete rows in the table. The\n         rows are created by the agent based upon the capabilities of the PDUs\n         being monitored.  Each row in the table represents an auxiliary\n         sensor measurement in a PDU.")
lgpPduAuxMeasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduAuxMeasSensorIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduAuxMeasSensorMeasurementIndex"))
if mibBuilder.loadTexts: lgpPduAuxMeasEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduAuxMeasTable'.\n             This table is indexed by 'lgpPduEntryIndex' which is\n             the sole index into the 'lgpPduTable', 'lgpPduAuxSensorIndex' which\n             is a unique identifier for the auxiliary sensor attached to the\n             given PDU, and 'lgpPduAuxMeasSensorMeasurementIndex' which is the\n             measurement's index identified on the sensor. Taken together these\n             three indexes uniquely identify an Auxiliary Sensor Measurement\n             within this agent.")
lgpPduAuxMeasSensorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPduAuxMeasSensorIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasSensorIndex.setDescription('This is the index indicating the sensor the measurement is accessed\n             from.')
lgpPduAuxMeasSensorMeasurementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 5), Unsigned32())
if mibBuilder.loadTexts: lgpPduAuxMeasSensorMeasurementIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasSensorMeasurementIndex.setDescription("This is the measurement's index identified on the sensor.")
lgpPduAuxMeasType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-specified", 0), ("temperature", 1), ("humidity", 2), ("door-closure", 3), ("contact-closure", 4), ("differential-pressure", 5), ("leak-detection", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasType.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasType.setDescription('not-specified\n                The type of measurement is unknown.\n             temperature\n                The measurement in this row of the table measures temperature.\n             humidity\n                The measurement in this row of the table measures relative\n                humidity.\n             door-closure\n                The measurement in this row of the table measures the state of a\n                door.\n             contact-closure\n                The measurement in this row of the table measures the state of a\n                contact closure.\n             differential-pressure\n                The measurement in this row of the table measures differential pressure.\n             leak-detection\n                The measurement in this row of the table measures the state of a\n                leak detection sensor.')
lgpPduAuxMeasSensorSysAssignLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasSensorSysAssignLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasSensorSysAssignLabel.setDescription('Label assigned to the auxiliary sensor at runtime by the system.\n             The value is independent of any user assigned label or asset tag.')
lgpPduAuxMeasUsrLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasUsrLabel.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasUsrLabel.setDescription('User assigned auxiliary sensor measurement label.')
lgpPduAuxMeasUsrTag1 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasUsrTag1.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasUsrTag1.setDescription('User assigned Tag to assist in identifying or grouping this\n             auxiliary sensor measurement within the end-users domain.')
lgpPduAuxMeasUsrTag2 = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 30), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasUsrTag2.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasUsrTag2.setDescription('User assigned Tag to assist in identifying or grouping this\n             auxiliary sensor measurement within the end-users domain.')
lgpPduAuxMeasSensorSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 35), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasSensorSerialNum.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasSensorSerialNum.setDescription("The sensor's globally unique serial number assigned at\n             the time of manufacture.")
lgpPduAuxMeasTempDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 40), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasTempDegF.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempDegF.setDescription('Temperature measured at the temperature sensor reported in\n             degrees Fahrenheit.')
lgpPduAuxMeasTempThrshldUndrAlmDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 50), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrAlmDegF.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrAlmDegF.setDescription('Under temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or below this value.')
lgpPduAuxMeasTempThrshldOvrAlmDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 55), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrAlmDegF.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrAlmDegF.setDescription('Over temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxMeasTempThrshldUndrWarnDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 60), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrWarnDegF.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrWarnDegF.setDescription('Under temperature warning threshold.  A warning is activated if\n             the temperature is equal to or below this value.')
lgpPduAuxMeasTempThrshldOvrWarnDegF = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 65), Integer32()).setUnits('0.1 degrees Fahrenheit').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrWarnDegF.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrWarnDegF.setDescription('Over temperature warning threshold.  A warning is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxMeasTempDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 70), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasTempDegC.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempDegC.setDescription('Temperature measured at the temperature sensor reported in\n             degrees Celsius.')
lgpPduAuxMeasTempThrshldUndrAlmDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 75), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrAlmDegC.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrAlmDegC.setDescription('Under temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or below this value.')
lgpPduAuxMeasTempThrshldOvrAlmDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 80), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrAlmDegC.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrAlmDegC.setDescription('Over temperature alarm threshold.  An alarm is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxMeasTempThrshldUndrWarnDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 85), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrWarnDegC.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldUndrWarnDegC.setDescription('Under temperature warning threshold.  A warning is activated if\n             the temperature is equal to or below this value.')
lgpPduAuxMeasTempThrshldOvrWarnDegC = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 90), Integer32()).setUnits('0.1 degrees Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrWarnDegC.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasTempThrshldOvrWarnDegC.setDescription('Over temperature warning threshold.  A warning is activated if the\n             temperature is equal to or above this value.')
lgpPduAuxMeasHum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 95), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasHum.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasHum.setDescription('Relative Humidity measured at the humidity sensor.')
lgpPduAuxMeasHumThrshldUndrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 100), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldUndrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldUndrAlm.setDescription('Under relative humidity alarm threshold.  An alarm is activated\n             if the relative humidity is equal to or below this value.')
lgpPduAuxMeasHumThrshldOvrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 105), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldOvrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldOvrAlm.setDescription('Over relative humidity alarm threshold.  An alarm is activated\n             if the relative humidity is equal to or above this value.')
lgpPduAuxMeasHumThrshldUndrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 110), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldUndrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldUndrWarn.setDescription('Under relative humidity warning threshold.  A warning is activated\n             if the relative humidity is equal to or below this value.')
lgpPduAuxMeasHumThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 115), Unsigned32()).setUnits('0.1 percent Relative Humidity').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldOvrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasHumThrshldOvrWarn.setDescription('Over relative humidity warning threshold.  A warning is activated\n             if the relative humidity is equal to or above this value.')
lgpPduAuxMeasDrClosureState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("not-specified", 0), ("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasDrClosureState.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDrClosureState.setDescription('The state of a door sensor measurement.\n                not-specified\n                    The door state is unknown.\n                open\n                    The door is in the open state.\n                closed\n                    The door is in the closed state.')
lgpPduAuxMeasDrClosureConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 125), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("alarm-when-open", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasDrClosureConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDrClosureConfig.setDescription('Configure door state alarms. This object provides the ability to\n             select when a door closure measurement should cause an alarm.\n                disabled\n                    The door state will never result in alarm.\n                alarm-when-open\n                    Activate an alarm when the door state becomes open.')
lgpPduAuxMeasCntctClosureState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 130), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("not-specified", 0), ("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasCntctClosureState.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasCntctClosureState.setDescription('The state of a contact closure sensor measurement.\n                not-specified\n                    The contact closure state is unknown.\n                open\n                    The contact closure is in the open state.\n                closed\n                    The contact closure is in the closed state.')
lgpPduAuxMeasCntctClosureConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 135), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("alarm-when-open", 1), ("alarm-when-closed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasCntctClosureConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasCntctClosureConfig.setDescription('Configure contact closure state alarms. This object provides the\n             ability to select when a contact closure measurement should\n             activate an alarm.\n                disabled\n                    The contact closure state will never result in alarm.\n                alarm-when-open\n                    Activate an alarm when the contact closure state becomes\n                    open.\n                alarm-when-closed\n                    Activate an alarm when the contact closure state becomes\n                    closed.')
lgpPduAuxMeasDiffPressure = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 140), Integer32()).setUnits('0.1 Pascal').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressure.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressure.setDescription('Pressure difference measured at the differential pressure sensor.')
lgpPduAuxMeasDiffPressureThrshldUndrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 145), Integer32()).setUnits('0.1 Pascal').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldUndrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldUndrAlm.setDescription('Under differential pressure alarm threshold.  An alarm is activated\n             if the differential pressure is equal to or below this value.')
lgpPduAuxMeasDiffPressureThrshldOvrAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 150), Integer32()).setUnits('0.1 Pascal').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldOvrAlm.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldOvrAlm.setDescription('Over differential pressure alarm threshold.  An alarm is activated\n             if the differential pressure is equal to or above this value.')
lgpPduAuxMeasDiffPressureThrshldUndrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 155), Integer32()).setUnits('0.1 Pascal').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldUndrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldUndrWarn.setDescription('Under differential pressure warning threshold.  A warning is activated\n             if the differential pressure is equal to or below this value.')
lgpPduAuxMeasDiffPressureThrshldOvrWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 160), Integer32()).setUnits('0.1 Pascal').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldOvrWarn.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasDiffPressureThrshldOvrWarn.setDescription('Over differential pressure warning threshold.  A warning is activated\n             if the differential pressure is equal to or above this value.')
lgpPduAuxMeasLeakDetectState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 15, 1, 165), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("not-specified", 0), ("no-leak-detected", 1), ("leak-detected", 2), ("leak-detection-pending", 3), ("cable-fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPduAuxMeasLeakDetectState.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasLeakDetectState.setDescription('not-specified\n                The leak detection state is unknown.\n             no-leak-detected\n                No leak has been detected.\n             leak-detected\n                A leak has been detected.\n             leak-detection-pending\n                Characterization of possible leak is pending further analysis\n                based on new data received from the sensor.\n                This state may not occur at all, but if it does, it should occur\n                only for a small amount of time before transitioning to \n                no-leak-detected or leak-detected.\n             cable-fault\n                A fault in the cable has been detected (for example, a\n                disconnected cable).  The sensor will not be able to detect\n                a leak.\n            ')
lgpPduAuxMeasOrderTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 20), )
if mibBuilder.loadTexts: lgpPduAuxMeasOrderTable.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasOrderTable.setDescription("This table contains a list of the PDU's Auxiliary Sensors\n         and their respective 'location' in the lgpPduAuxMeasTable table.\n         This table contains 1 row, for potential sensor for each PDU.\n         The rows in this table are created by the agent based on the maximum\n         number of sensor's supported for each PDU.\n\n         Each row in the table represents an auxiliary sensor, identified by its\n         factory assigned serial number and its placement in the lgpPduAuxMeasTable.\n         If all serial numbers in this table are empty strings then the\n         location of the sensors in the lgpPduAuxMeasTable will default to the\n         agent's default placement algorithm.  If sensors in the\n         lgpPduAuxMeasTable and are not represented by an entry in this table then\n         the location of the unrepresented sensor(s) in the lgpPduAuxMeasTable,\n         and other display mediums, will be determined by the agent, but in no\n         case will an unrepresented sensor occupy a position reserved for a sensor\n         present in this table.  Those unrepresented sensor's display location is\n         not guaranteed to be consistent across reboots or rediscovery actions\n         on the sensor bus.  Only sensors represented in this table are guarantted\n         consistent placement as specified by their index entries (position) in\n         this table.\n\n         Note that it is possible to have entries in this table representing sensors\n         that may not exist on the given PDU at runtime. These allocated by not present\n         sensors will reduce the total number of sensors that can be displayed for\n         the given PDU.")
lgpPduAuxMeasOrderEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 20, 1), ).setIndexNames((0, "LIEBERT-GP-PDU-MIB", "lgpPduEntryIndex"), (0, "LIEBERT-GP-PDU-MIB", "lgpPduAuxSensorOrderIndex"))
if mibBuilder.loadTexts: lgpPduAuxMeasOrderEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasOrderEntry.setDescription("This entry defines the attributes to be populated in the\n             various columns of the 'lgpPduAuxMeasOrderTable'.\n             This table is indexed by 'lgpPduEntryIndex' which is\n             the sole index into the 'lgpPduTable' and 'lgpPduAuxMeasSensorIndex'\n             which is a unique identifier for the auxiliary sensor attached to the\n             given PDU. Taken together these two indexes uniquely\n             identify a Auxiliary Sensor within this agent.")
lgpPduAuxSensorOrderIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 20, 1, 5), Unsigned32())
if mibBuilder.loadTexts: lgpPduAuxSensorOrderIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxSensorOrderIndex.setDescription('Index representing the position within the sensor string on the given PDU')
lgpPduAuxMeasOrderSensorSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 8, 60, 20, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPduAuxMeasOrderSensorSerialNum.setStatus('current')
if mibBuilder.loadTexts: lgpPduAuxMeasOrderSensorSerialNum.setDescription("The sensor's globally unique serial number assigned at\n             the time of manufacture.  The sensor represented by this\n             serial number will be, if discovered, by the agent placed\n             in the lgpPduAuxMeasTable at the location specified by the\n             index entries herein.  A empty string in this object indicates\n             an open display position that can be occupied by any sensor not\n             given a specific display position in this table.")
mibBuilder.exportSymbols("LIEBERT-GP-PDU-MIB", lgpPduRbLineEntryAp=lgpPduRbLineEntryAp, lgpPduRbLineEntryEcHundredths=lgpPduRbLineEntryEcHundredths, lgpPduRbLineEntryLine=lgpPduRbLineEntryLine, lgpPduAuxMeasTempThrshldUndrAlmDegF=lgpPduAuxMeasTempThrshldUndrAlmDegF, lgpPduAuxSensorMeasType=lgpPduAuxSensorMeasType, lgpPduRbTableCount=lgpPduRbTableCount, lgpPduRbLineEntryEpLLTenths=lgpPduRbLineEntryEpLLTenths, lgpPduRbEntryEcUsedBeforeAlarm=lgpPduRbEntryEcUsedBeforeAlarm, lgpPduRcpEntryPwrOut=lgpPduRcpEntryPwrOut, lgpPduRbEntryUsrLabel=lgpPduRbEntryUsrLabel, lgpPduPsEntryApTotal=lgpPduPsEntryApTotal, lgpPduRbLineEntryEcAvailBeforeAlarmHundredths=lgpPduRbLineEntryEcAvailBeforeAlarmHundredths, lgpPduEntrySerialNumber=lgpPduEntrySerialNumber, lgpPduRcpTable=lgpPduRcpTable, lgpPduRbLineEntry=lgpPduRbLineEntry, lgpPduRcpEntryEpTenths=lgpPduRcpEntryEpTenths, lgpPduRcpEntryPwrOnDelay=lgpPduRcpEntryPwrOnDelay, lgpPduPsEntryPwrTotal=lgpPduPsEntryPwrTotal, lgpPduPsLineEntryApLN=lgpPduPsLineEntryApLN, lgpPduRcpTableCount=lgpPduRcpTableCount, lgpPduRcpGroupDisplayIndex=lgpPduRcpGroupDisplayIndex, lgpPduAuxSensorTempThrshldUndrWarnDegF=lgpPduAuxSensorTempThrshldUndrWarnDegF, lgpPduAuxMeasType=lgpPduAuxMeasType, lgpPduPsLineEntryEpLNTenths=lgpPduPsLineEntryEpLNTenths, lgpPduRcpEntryId=lgpPduRcpEntryId, lgpPduAuxMeasDrClosureState=lgpPduAuxMeasDrClosureState, lgpPduPsEntryEcNeutralThrshldOvrWarn=lgpPduPsEntryEcNeutralThrshldOvrWarn, liebertGlobalProductsPduModule=liebertGlobalProductsPduModule, lgpPduRbEntryCapabilities=lgpPduRbEntryCapabilities, lgpPduPsLineEntryEcThrshldOvrWarn=lgpPduPsLineEntryEcThrshldOvrWarn, lgpPduRbEntryEcThrshldOvrWarn=lgpPduRbEntryEcThrshldOvrWarn, lgpPduAuxSensorPositionRelative=lgpPduAuxSensorPositionRelative, lgpPduPsEntryEcInputRated=lgpPduPsEntryEcInputRated, lgpPduRcpEntry=lgpPduRcpEntry, lgpPduRcpGroupIndex=lgpPduRcpGroupIndex, lgpPduAuxSensorTable=lgpPduAuxSensorTable, lgpPduAuxSensorTempThrshldUndrAlmDegC=lgpPduAuxSensorTempThrshldUndrAlmDegC, lgpPduRcpEntryEp=lgpPduRcpEntryEp, lgpPduPsLineEntryEpLLTenths=lgpPduPsLineEntryEpLLTenths, lgpPduRcpEntryEcAvailBeforeAlarmHundredths=lgpPduRcpEntryEcAvailBeforeAlarmHundredths, lgpPduEntrySWOverCurrentProtection=lgpPduEntrySWOverCurrentProtection, lgpPduPsTable=lgpPduPsTable, lgpPduRcpEntryEnergyAccum=lgpPduRcpEntryEnergyAccum, lgpPduAuxSensorTempThrshldOvrWarnDegC=lgpPduAuxSensorTempThrshldOvrWarnDegC, lgpPduPsTableCount=lgpPduPsTableCount, lgpPduRcpGroupDisplayGroup=lgpPduRcpGroupDisplayGroup, lgpPduAuxSensorTempThrshldOvrAlmDegC=lgpPduAuxSensorTempThrshldOvrAlmDegC, lgpPduAuxSensorTempSerialNum=lgpPduAuxSensorTempSerialNum, lgpPduTableCount=lgpPduTableCount, lgpPduRbEntry=lgpPduRbEntry, lgpPduAuxMeasTempThrshldUndrWarnDegF=lgpPduAuxMeasTempThrshldUndrWarnDegF, lgpPduPsLineEntryEcAvailBeforeAlarm=lgpPduPsLineEntryEcAvailBeforeAlarm, lgpPduRcpGroupUsrLabel=lgpPduRcpGroupUsrLabel, lgpPduTable=lgpPduTable, lgpPduAuxMeasTempThrshldUndrAlmDegC=lgpPduAuxMeasTempThrshldUndrAlmDegC, lgpPduEntrySysStatus=lgpPduEntrySysStatus, lgpPduCluster=lgpPduCluster, lgpPduEntrySWOverTemperatureProtectionDelay=lgpPduEntrySWOverTemperatureProtectionDelay, lgpPduPsLineEntryEcThrshldUndrAlarm=lgpPduPsLineEntryEcThrshldUndrAlarm, lgpPduAuxMeasHumThrshldOvrWarn=lgpPduAuxMeasHumThrshldOvrWarn, lgpPduAuxMeasCntctClosureState=lgpPduAuxMeasCntctClosureState, lgpPduAuxMeasDiffPressureThrshldUndrWarn=lgpPduAuxMeasDiffPressureThrshldUndrWarn, lgpPduAuxMeasDrClosureConfig=lgpPduAuxMeasDrClosureConfig, lgpPduPsEntryUnbalancedLoadThrshldAlarm=lgpPduPsEntryUnbalancedLoadThrshldAlarm, lgpPduRbEntryEpLNTenths=lgpPduRbEntryEpLNTenths, lgpPduPsLineEntryEc=lgpPduPsLineEntryEc, lgpPduAuxMeasLeakDetectState=lgpPduAuxMeasLeakDetectState, lgpPduEntrySWOverTemperatureProtectionConfig=lgpPduEntrySWOverTemperatureProtectionConfig, lgpPduAuxSensorCount=lgpPduAuxSensorCount, lgpPduRcpEntryEcAvailBeforeAlarm=lgpPduRcpEntryEcAvailBeforeAlarm, lgpPduRcpEntryPostOffDelay=lgpPduRcpEntryPostOffDelay, lgpPduPowerSource=lgpPduPowerSource, lgpPduAuxMeasOrderTable=lgpPduAuxMeasOrderTable, lgpPduRbEntrySerialNum=lgpPduRbEntrySerialNum, lgpPduPsLineEntryPwrLL=lgpPduPsLineEntryPwrLL, lgpPduRbLineEntryEpLN=lgpPduRbLineEntryEpLN, lgpPduRbEntryId=lgpPduRbEntryId, lgpPduRbLineEntryPwr=lgpPduRbLineEntryPwr, lgpPduRcpEntryCriticality=lgpPduRcpEntryCriticality, lgpPduAuxMeasDiffPressureThrshldUndrAlm=lgpPduAuxMeasDiffPressureThrshldUndrAlm, lgpPduRbLineEntryPf=lgpPduRbLineEntryPf, lgpPduPsLineEntryPfLL=lgpPduPsLineEntryPfLL, lgpPduEntryIndex=lgpPduEntryIndex, lgpPduAuxMeasDiffPressureThrshldOvrWarn=lgpPduAuxMeasDiffPressureThrshldOvrWarn, lgpPduRcpEntryPwrUpState=lgpPduRcpEntryPwrUpState, lgpPduRcpEntryControlLock=lgpPduRcpEntryControlLock, lgpPduAuxMeasHum=lgpPduAuxMeasHum, lgpPduRbEntryModel=lgpPduRbEntryModel, lgpPduRcpEntryControl=lgpPduRcpEntryControl, lgpPduAuxMeasTempThrshldOvrAlmDegC=lgpPduAuxMeasTempThrshldOvrAlmDegC, lgpPduPsEntrySerialNum=lgpPduPsEntrySerialNum, lgpPduAuxMeasHumThrshldUndrWarn=lgpPduAuxMeasHumThrshldUndrWarn, lgpPduRcpEntryEcCrestFactor=lgpPduRcpEntryEcCrestFactor, lgpPduEntrySysAssignLabel=lgpPduEntrySysAssignLabel, lgpPduAuxSensorTempThrshldOvrWarnDegF=lgpPduAuxSensorTempThrshldOvrWarnDegF, lgpPduRbLineEntryEpLNTenths=lgpPduRbLineEntryEpLNTenths, lgpPduPsEntry=lgpPduPsEntry, lgpPduAuxSensorHumMeasurement=lgpPduAuxSensorHumMeasurement, lgpPduAuxMeasUsrTag1=lgpPduAuxMeasUsrTag1, lgpPduPsEntryPfTotal=lgpPduPsEntryPfTotal, lgpPduRcpGroupTable=lgpPduRcpGroupTable, lgpPduPsEntryEcResidualThrshldOvrAlarm=lgpPduPsEntryEcResidualThrshldOvrAlarm, lgpPduGlobalData=lgpPduGlobalData, lgpPduEntryRbCount=lgpPduEntryRbCount, lgpPduAuxMeasTempDegC=lgpPduAuxMeasTempDegC, lgpPduEntryUsrLabel=lgpPduEntryUsrLabel, lgpPduAuxSensorOrderIndex=lgpPduAuxSensorOrderIndex, lgpPduRcpEntryEcUsedBeforeAlarm=lgpPduRcpEntryEcUsedBeforeAlarm, lgpPduRbEntryFirmwareVersion=lgpPduRbEntryFirmwareVersion, lgpPduAuxMeasSensorSerialNum=lgpPduAuxMeasSensorSerialNum, lgpPduRbEntryUsrTag2=lgpPduRbEntryUsrTag2, lgpPduRcpEntryUsrTag2=lgpPduRcpEntryUsrTag2, lgpPduRcpEntryLineSource=lgpPduRcpEntryLineSource, lgpPduAuxSensorIndex=lgpPduAuxSensorIndex, lgpPduRbLineEntryEcUsedBeforeAlarm=lgpPduRbLineEntryEcUsedBeforeAlarm, lgpPduRcpGroupBlinkLED=lgpPduRcpGroupBlinkLED, lgpPduRbEntryRcpCount=lgpPduRbEntryRcpCount, lgpPduRbEntryEpLLTenths=lgpPduRbEntryEpLLTenths, lgpPduRbLineEntryId=lgpPduRbLineEntryId, lgpPduRbEntryEcHundredths=lgpPduRbEntryEcHundredths, lgpPduRbLineEntryEcThrshldUndrAlm=lgpPduRbLineEntryEcThrshldUndrAlm, lgpPduRbLineTable=lgpPduRbLineTable, lgpPduRcpEntryEcThrshldUnderAlarm=lgpPduRcpEntryEcThrshldUnderAlarm, lgpPduAuxSensorHumThrshldUndrAlm=lgpPduAuxSensorHumThrshldUndrAlm, lgpPduPsEntryModel=lgpPduPsEntryModel, lgpPduRbEntrySwOverCurrentProtection=lgpPduRbEntrySwOverCurrentProtection, lgpPduRbEntryPositionRelative=lgpPduRbEntryPositionRelative, lgpPduPsLineEntryIndex=lgpPduPsLineEntryIndex, lgpPduRcpEntryEcHundredths=lgpPduRcpEntryEcHundredths, lgpPduAuxSensorSysAssignLabel=lgpPduAuxSensorSysAssignLabel, lgpPduAuxMeasHumThrshldUndrAlm=lgpPduAuxMeasHumThrshldUndrAlm, lgpPduRcpEntryBlinkLED=lgpPduRcpEntryBlinkLED, lgpPduAuxSensorTempMeasurementDegF=lgpPduAuxSensorTempMeasurementDegF, lgpPduAuxMeasSensorIndex=lgpPduAuxMeasSensorIndex, PYSNMP_MODULE_ID=liebertGlobalProductsPduModule, lgpPduRbLineEntryEpLL=lgpPduRbLineEntryEpLL, lgpPduRcpEntryEcThrshldOverWarn=lgpPduRcpEntryEcThrshldOverWarn, lgpPduRcpGroupDeleteGroup=lgpPduRcpGroupDeleteGroup, lgpPduRcpGroupTableCount=lgpPduRcpGroupTableCount, lgpPduEntry=lgpPduEntry, lgpPduEntryId=lgpPduEntryId, lgpPduRcpGroupDisplayTable=lgpPduRcpGroupDisplayTable, lgpPduPsEntryEpInputRated=lgpPduPsEntryEpInputRated, lgpPduPsEntrySysAssignLabel=lgpPduPsEntrySysAssignLabel, lgpPduAuxSensorTempMeasurementDegC=lgpPduAuxSensorTempMeasurementDegC, lgpPduAuxSensorHumThrshldOvrWarn=lgpPduAuxSensorHumThrshldOvrWarn, lgpPduPsLineEntryEcThrshldOvrAlarm=lgpPduPsLineEntryEcThrshldOvrAlarm, lgpPduRcpEntryPwrState=lgpPduRcpEntryPwrState, lgpPduAuxMeasHumThrshldOvrAlm=lgpPduAuxMeasHumThrshldOvrAlm, lgpPduGrpSysStatus=lgpPduGrpSysStatus, lgpPduRcpEntryPosition=lgpPduRcpEntryPosition, lgpPduPsEntryWiringType=lgpPduPsEntryWiringType, lgpPduRbEntryPwr=lgpPduRbEntryPwr, lgpPduEntryUsrTag2=lgpPduEntryUsrTag2, lgpPduRbLineEntryEcThrshldOvrWarn=lgpPduRbLineEntryEcThrshldOvrWarn, lgpPduAuxSensorHumThrshldUndrWarn=lgpPduAuxSensorHumThrshldUndrWarn, lgpPduPsLineEntryPfLN=lgpPduPsLineEntryPfLN, lgpPduAuxMeasUsrLabel=lgpPduAuxMeasUsrLabel, lgpPduAuxMeasDiffPressureThrshldOvrAlm=lgpPduAuxMeasDiffPressureThrshldOvrAlm, lgpPduRcpEntrySysAssignLabel=lgpPduRcpEntrySysAssignLabel, lgpPduRbLineEntryEcThrshldOvrAlm=lgpPduRbLineEntryEcThrshldOvrAlm, lgpPduRcpEntryAddReceptacleToGroup=lgpPduRcpEntryAddReceptacleToGroup, lgpPduAuxSensorUsrTag2=lgpPduAuxSensorUsrTag2, lgpPduAuxMeasSensorSysAssignLabel=lgpPduAuxMeasSensorSysAssignLabel, lgpPduRbEntryPf=lgpPduRbEntryPf, lgpPduPsEntryFirmwareVersion=lgpPduPsEntryFirmwareVersion, lgpPduRcpEntryRemoveReceptacleFromGroup=lgpPduRcpEntryRemoveReceptacleFromGroup, lgpPduRcpEntryFreq=lgpPduRcpEntryFreq, lgpPduRbTable=lgpPduRbTable, lgpPduAuxMeasTempThrshldOvrWarnDegF=lgpPduAuxMeasTempThrshldOvrWarnDegF, lgpPduAuxSensorUsrTag1=lgpPduAuxSensorUsrTag1, lgpPduRbEntryEcAvailBeforeAlarmHundredths=lgpPduRbEntryEcAvailBeforeAlarmHundredths, lgpPduAuxMeasCntctClosureConfig=lgpPduAuxMeasCntctClosureConfig, lgpPduRcpEntryUsrLabel=lgpPduRcpEntryUsrLabel, lgpPduPsLineEntryEcUsedBeforeAlarm=lgpPduPsLineEntryEcUsedBeforeAlarm, lgpPduRcpEntryPf=lgpPduRcpEntryPf, lgpPduPsEntryIndex=lgpPduPsEntryIndex, lgpPduRbLineEntryEcAvailBeforeAlarm=lgpPduRbLineEntryEcAvailBeforeAlarm, lgpPduRcpGroup=lgpPduRcpGroup, lgpPduAuxSensorId=lgpPduAuxSensorId, lgpPduAuxSensorTempThrshldOvrAlmDegF=lgpPduAuxSensorTempThrshldOvrAlmDegF, lgpPduPsLineEntryEcAvailBeforeAlarmHundredths=lgpPduPsLineEntryEcAvailBeforeAlarmHundredths, lgpPduRcpEntryType=lgpPduRcpEntryType, lgpPduRcpGroupControlPower=lgpPduRcpGroupControlPower, lgpPduAuxSensorHumSerialNum=lgpPduAuxSensorHumSerialNum, lgpPduPsEntryEcNeutralThrshldOvrAlarm=lgpPduPsEntryEcNeutralThrshldOvrAlarm, lgpPduPsLineEntryLine=lgpPduPsLineEntryLine, lgpPduAuxMeasUsrTag2=lgpPduAuxMeasUsrTag2, lgpPduRbEntryFreqRated=lgpPduRbEntryFreqRated, lgpPduRcpGroupControlLock=lgpPduRcpGroupControlLock, lgpPduAuxSensorUsrLabel=lgpPduAuxSensorUsrLabel, lgpPduAuxMeasTable=lgpPduAuxMeasTable, lgpPduAuxMeasOrderSensorSerialNum=lgpPduAuxMeasOrderSensorSerialNum, lgpPduAuxMeasSensorMeasurementIndex=lgpPduAuxMeasSensorMeasurementIndex, lgpPduRcpEntryEcThrshldOverAlarm=lgpPduRcpEntryEcThrshldOverAlarm, lgpPduRbEntryEnergyAccum=lgpPduRbEntryEnergyAccum, lgpPduRbEntryEcThrshldOvrAlm=lgpPduRbEntryEcThrshldOvrAlm, lgpPduRbEntryLineSource=lgpPduRbEntryLineSource, lgpPduRcpGroupDisplayTableCount=lgpPduRcpGroupDisplayTableCount, lgpPduRbLineEntryEc=lgpPduRbLineEntryEc, lgpPduRbEntryEcRated=lgpPduRbEntryEcRated, lgpPduPsEntryEnergyAccum=lgpPduPsEntryEnergyAccum, lgpPduPsEntryId=lgpPduPsEntryId, lgpPduPsEntryEcNeutral=lgpPduPsEntryEcNeutral, lgpPduReceptacleBranch=lgpPduReceptacleBranch, lgpPduRbLineEntryIndex=lgpPduRbLineEntryIndex, lgpPduReceptacle=lgpPduReceptacle, lgpPduPsLineTable=lgpPduPsLineTable, lgpPduPsLineEntryEpLL=lgpPduPsLineEntryEpLL, lgpPduPsLineEntryEcHundredths=lgpPduPsLineEntryEcHundredths, lgpPduRbEntryIndex=lgpPduRbEntryIndex, lgpPduRcpGroupDisplayEntry=lgpPduRcpGroupDisplayEntry, lgpPduRbEntryUsrTag1=lgpPduRbEntryUsrTag1, lgpPduAuxMeasTempThrshldOvrWarnDegC=lgpPduAuxMeasTempThrshldOvrWarnDegC, lgpPduPsEntryFreqRated=lgpPduPsEntryFreqRated, lgpPduRbEntryEpRated=lgpPduRbEntryEpRated, lgpPduEntryPositionRelative=lgpPduEntryPositionRelative, lgpPduAuxMeasEntry=lgpPduAuxMeasEntry, lgpPduRcpEntryPostOnDelay=lgpPduRcpEntryPostOnDelay, lgpPduRcpEntryIndex=lgpPduRcpEntryIndex, lgpPduAuxMeasOrderEntry=lgpPduAuxMeasOrderEntry, lgpPduAuxSensorTempThrshldUndrAlmDegF=lgpPduAuxSensorTempThrshldUndrAlmDegF, lgpPduAuxSensorHumThrshldOvrAlm=lgpPduAuxSensorHumThrshldOvrAlm, lgpPduRcpEntryEc=lgpPduRcpEntryEc, lgpPduPsLineEntryId=lgpPduPsLineEntryId, lgpPduRbEntryReceptacleType=lgpPduRbEntryReceptacleType, lgpPduRcpEntryApOut=lgpPduRcpEntryApOut, lgpPduAuxMeasTempThrshldUndrWarnDegC=lgpPduAuxMeasTempThrshldUndrWarnDegC, lgpPduPsLineEntryEpLN=lgpPduPsLineEntryEpLN, lgpPduPsLineEntryApLL=lgpPduPsLineEntryApLL, lgpPduRbEntryAp=lgpPduRbEntryAp, lgpPduPsLineEntryPwrLN=lgpPduPsLineEntryPwrLN, lgpPduRcpEntryOperationCondition=lgpPduRcpEntryOperationCondition, lgpPduPsLineEntry=lgpPduPsLineEntry, lgpPduRcpEntrySwOverTemperatureProtection=lgpPduRcpEntrySwOverTemperatureProtection, lgpPduRcpGroupEntry=lgpPduRcpGroupEntry, lgpPduRbEntrySysAssignLabel=lgpPduRbEntrySysAssignLabel, lgpPduAuxiliarySensors=lgpPduAuxiliarySensors, lgpPduAuxSensorTempThrshldUndrWarnDegC=lgpPduAuxSensorTempThrshldUndrWarnDegC, lgpPduPsEntryEcResidual=lgpPduPsEntryEcResidual, lgpPduAuxMeasTempThrshldOvrAlmDegF=lgpPduAuxMeasTempThrshldOvrAlmDegF, lgpPduAuxMeasDiffPressure=lgpPduAuxMeasDiffPressure, lgpPduRcpEntryUsrTag1=lgpPduRcpEntryUsrTag1, lgpPduRcpEntryCapabilities=lgpPduRcpEntryCapabilities, lgpPduAuxSensorEntry=lgpPduAuxSensorEntry, lgpPduEntryUsrTag1=lgpPduEntryUsrTag1, lgpPduRbEntryEcThrshldUndrAlm=lgpPduRbEntryEcThrshldUndrAlm, lgpPduAuxMeasTempDegF=lgpPduAuxMeasTempDegF)
