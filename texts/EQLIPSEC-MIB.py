#
# PySNMP MIB module EQLIPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/equallogic/EQLIPSEC-MIB
# Produced by pysmi-1.1.12 at Tue May 28 12:11:53 2024
# On host fv-az1567-4 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
eqlGroupId, = mibBuilder.importSymbols("EQLGROUP-MIB", "eqlGroupId")
eqlMemberIndex, = mibBuilder.importSymbols("EQLMEMBER-MIB", "eqlMemberIndex")
Unsigned64, = mibBuilder.importSymbols("EQLSTORAGEPOOL-MIB", "Unsigned64")
equalLogic, = mibBuilder.importSymbols("EQUALLOGIC-SMI", "equalLogic")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, Counter64, Integer32, Bits, MibIdentifier, Counter32, IpAddress, enterprises, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "Counter64", "Integer32", "Bits", "MibIdentifier", "Counter32", "IpAddress", "enterprises", "Unsigned32", "TimeTicks")
TimeStamp, TruthValue, StorageType, DisplayString, RowPointer, TextualConvention, RowStatus, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TruthValue", "StorageType", "DisplayString", "RowPointer", "TextualConvention", "RowStatus", "DateAndTime")
eqlIpsecModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 12740, 22))
eqlIpsecModule.setRevisions(('2010-07-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: eqlIpsecModule.setRevisionsDescriptions(('Initial revision',))
if mibBuilder.loadTexts: eqlIpsecModule.setLastUpdated('201503171528Z')
if mibBuilder.loadTexts: eqlIpsecModule.setOrganization('EqualLogic Inc.')
if mibBuilder.loadTexts: eqlIpsecModule.setContactInfo('Contact: Customer Support\n         Postal:  Dell Inc\n                  300 Innovative Way, Suite 301, Nashua, NH 03062\n         Tel:     +1 603-579-9762\n         E-mail:  US-NH-CS-TechnicalSupport@dell.com\n         WEB:     www.equallogic.com')
if mibBuilder.loadTexts: eqlIpsecModule.setDescription('Equallogic Inc. group information\n\n        Copyright (c) 2002-2010 by Dell, Inc. \n        \n        All rights reserved.  This software may not be copied, disclosed, \n        transferred, or used except in accordance with a license granted \n        by Dell, Inc.  This software embodies proprietary information \n        and trade secrets of Dell, Inc. \n        ')
eqlIpsecObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 12740, 22, 1))
eqlIpsecNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 12740, 22, 2))
eqlIpsecConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 12740, 22, 3))
class SnmpAdminString(TextualConvention, OctetString):
    description = 'An octet string containing administrative\n                    information, preferably in human-readable form.'
    status = 'current'
    displayHint = 't'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 1024)

class InetPortNumber(TextualConvention, Unsigned32):
    reference = 'STD 6 (RFC 768), STD 7 (RFC 793) and RFC 2960'
    description = 'Represents a 16 bit port number of an Internet transport\n         layer protocol.  Port numbers are assigned by IANA.  A\n         current list of all assignments is available from\n         <http://www.iana.org/>.\n\n         The value zero is object-specific and must be defined as\n         part of the description of any object that uses this\n         syntax.  Examples of the usage of zero might include\n         situations where a port number is unknown, or when the\n         value zero is used as a wildcard in a filter.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IpsecAuthType(TextualConvention, Integer32):
    description = 'The IpsecAuthType is used to specify the authentication\n         type to be used with a particular peer.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("presharedkey", 1), ("certificates", 2), ("manualkey", 3))

class IpsecIdType(TextualConvention, Integer32):
    description = 'The IpsecIdType is used to specify the type of identifier\n         for a peer to be used with the ID payload.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("ipaddress", 2), ("userfqdn", 3), ("fqdn", 4), ("asn1dn", 5))

class IpsecEncType(TextualConvention, Integer32):
    description = 'The IpsecEncType is used to specify the encryption\n         algorithm to be used when manual keying is used.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("nullenc", 1), ("aes-cbc", 2), ("triple-des-cbc", 3))

eqlIpsecTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 1), )
if mibBuilder.loadTexts: eqlIpsecTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecTable.setDescription('EqualLogic-Persistent Storage IPSec global settings\n\n            This table contains global IPSec settings.')
eqlIpsecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 1, 1), ).setIndexNames((0, "EQLIPSEC-MIB", "eqlIpsecInstanceId"))
if mibBuilder.loadTexts: eqlIpsecEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecEntry.setDescription('An entry (row) containing global IPSec settings.')
eqlIpsecInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: eqlIpsecInstanceId.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecInstanceId.setDescription('This index identifies the IPSec instance. This index should always be 1.')
eqlIpsecEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eqlIpsecEnable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecEnable.setDescription('This specifies if IPSec is enabled or disbaled.\n\n           True for enabled and False for disabled.')
eqlIpsecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecRowStatus.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecRowStatus.setDescription('This object indicates the conceptual status of this row.\n\n            This object may not be set to active if the requirements\n            of the spdIpHeadFiltType object are not met.  In other\n            words, if the associated value columns needed by a\n            particular test have not been set, then attempting to\n            change this row to an active state will result in an\n            inconsistentValue error.  See the spdIpHeadFiltType\n            object description for further details.')
eqlIpsecPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2), )
if mibBuilder.loadTexts: eqlIpsecPolicyTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyTable.setDescription('EqualLogic-Persistent Storage IPSec Policy Table.\n            This table contains a list of filter definitions.')
eqlIpsecPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1), ).setIndexNames((0, "EQLIPSEC-MIB", "eqlIpsecPolicyInstanceId"))
if mibBuilder.loadTexts: eqlIpsecPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyEntry.setDescription('A definition of a particular filter.')
eqlIpsecPolicyInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: eqlIpsecPolicyInstanceId.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyInstanceId.setDescription('This index identifies the IPSec policy instance.')
eqlIpsecPolicyFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterName.setDescription('The administrative name for this filter.')
eqlIpsecPolicyFilterIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 3), InetAddressType().clone('ipv6')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterIPVersion.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterIPVersion.setDescription('The Internet Protocol version the addresses are to match\n            against.  The value of this property determines the size\n            and format of the eqlIpsecPolicyFilterAddress and\n            eqlIpsecPolicyFilterLocalAddress.')
eqlIpsecPolicyFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterAddress.setDescription('The starting address of a source address range that the\n            packet must match against for this filter to be\n            considered TRUE.\n\n            This object is only used if sourceAddress is set in\n            spdIpHeadFiltType.')
eqlIpsecPolicyFilterNetmaskLen = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterNetmaskLen.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterNetmaskLen.setDescription('The ending address of a source address range to check a\n            packet against, where the starting is specified by the\n            spdIpHeadFiltSrcAddressBegin object.  Set this column to\n            the same value as the spdIpHeadFiltSrcAddressBegin\n            column to get an exact single address match.\n\n            This object is only used if sourceAddress is set in\n            spdIpHeadFiltType.')
eqlIpsecPolicyFilterLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterLocalAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterLocalAddress.setDescription('The Local IP Address on the array to bind a policy to.\n            This option is only used when the Peer is of type manual.\n            Can be either a IPv4 or IPV6 address.')
eqlIpsecPolicyFilterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterPort.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterPort.setDescription("The low port of the port range a packet's source must\n            match against.  To match, the port number must be\n            greater than or equal to this value.\n\n            This object is only used if sourcePort is set in\n            spdIpHeadFiltType.\n\n            The value of 0 for this object is illegal.")
eqlIpsecPolicyFilterLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterLocalPort.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterLocalPort.setDescription("The low port of the port range a packet's source must\n            match against.  To match, the port number must be\n            greater than or equal to this value.\n\n            This object is only used if sourcePort is set in\n            spdIpHeadFiltType.\n\n            The value of 0 for this object is illegal.\n\n            This object specifies the local port to be used.")
eqlIpsecPolicyFilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterProtocol.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterProtocol.setDescription('The protocol number the incoming packet must match\n            against for this filter to be evaluated as true.\n\n            This object is only used if protocol is set in\n            spdIpHeadFiltType.')
eqlIpsecPolicyFilterPeerName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterPeerName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterPeerName.setDescription('This specifies the name of the peer this policy must be associated with.')
eqlIpsecPolicyFilterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ipsec", 1), ("pass", 2), ("drop", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterAction.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterAction.setDescription('The action to be taken on packets matching this rule.')
eqlIpsecPolicyFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 2, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPolicyFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPolicyFilterRowStatus.setDescription('This object indicates the conceptual status of this row.\n\n            This object may not be set to active if the requirements\n            of the spdIpHeadFiltType object are not met.  In other\n            words, if the associated value columns needed by a\n            particular test have not been set, then attempting to\n            change this row to an active state will result in an\n            inconsistentValue error.  See the spdIpHeadFiltType\n            object description for further details.')
eqlIpsecCertConfigTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3), )
if mibBuilder.loadTexts: eqlIpsecCertConfigTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertConfigTable.setDescription('EqualLogic-Dynamic IPSec certificate configuration Table.\n            This table contains the list of certificates configured.')
eqlIpsecCertConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1), ).setIndexNames((0, "EQLIPSEC-MIB", "eqlIpsecCertInstanceId"))
if mibBuilder.loadTexts: eqlIpsecCertConfigEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertConfigEntry.setDescription('A definition of a particular certificate.')
eqlIpsecCertInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: eqlIpsecCertInstanceId.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertInstanceId.setDescription('This index identifies the IPSec certificate instance.')
eqlIpsecCertName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertName.setDescription('The administrative name for this certificate.')
eqlIpsecCertFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertFileName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertFileName.setDescription('The certificate file name.')
eqlIpsecCertType = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local-cert", 1), ("root-cert", 2), ("intermediate", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertType.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertType.setDescription('The certificate type. Local cert, Root CA cert or intermediate cert.')
eqlIpsecPrivKeyFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPrivKeyFileName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPrivKeyFileName.setDescription('The private key file name.')
eqlIpsecCertPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertPassword.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertPassword.setDescription('The password to use for decrypting certificate.')
eqlIpsecCertRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertRowStatus.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertRowStatus.setDescription('This object indicates the conceptual status of this row.\n\n            This object may not be set to active if the requirements\n            of the spdIpHeadFiltType object are not met.  In other\n            words, if the associated value columns needed by a\n            particular test have not been set, then attempting to\n            change this row to an active state will result in an\n            inconsistentValue error.  See the spdIpHeadFiltType\n            object description for further details.')
eqlIpsecPeerTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4), )
if mibBuilder.loadTexts: eqlIpsecPeerTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerTable.setDescription('EqualLogic-Persistent Storage IPSec peer Table.\n            This table contains the list of peers configured.')
eqlIpsecPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1), ).setIndexNames((0, "EQLIPSEC-MIB", "eqlIpsecPeerInstanceId"))
if mibBuilder.loadTexts: eqlIpsecPeerEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerEntry.setDescription('A definition of a particular certificate.')
eqlIpsecPeerInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: eqlIpsecPeerInstanceId.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerInstanceId.setDescription('This index identifies the IPSec policy instance.')
eqlIpsecPeerName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerName.setDescription('The administrative name for this peer.')
eqlIpsecPeerAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("presharedkey", 1), ("certificates", 2), ("manualkey", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerAuthType.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerAuthType.setDescription('The authentication method used with this peer.\n\n            Pre-shared keys, certificates and manual keys are the options.')
eqlIpsecPeerPreSharedKey = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 130))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerPreSharedKey.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerPreSharedKey.setDescription('The pre-shared key to be used during authentication.\n            It is mandatory that this only contain printable ASCII\n            ASCII characters, meaning each byte must be in the range\n            of 33 to 126.')
eqlIpsecPeerCertIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("ipaddress", 2), ("userfqdn", 3), ("fqdn", 4), ("asn1dn", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eqlIpsecPeerCertIdType.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerCertIdType.setDescription('The identifier type to be used in ID payload.\n\n            Only applicable if the auth type is certificates.')
eqlIpsecPeerCertIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eqlIpsecPeerCertIdValue.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerCertIdValue.setDescription('The pre-shared key to be used during authentication.\n\n            Only applicable if the auth type is certificates.')
eqlIpsecPeerNullEnc = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerNullEnc.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerNullEnc.setDescription('This specifies if null encryption is to be used.\n\n            Only applicable if the auth type is certificates or pre-shared keys.')
eqlIpsecPeerTunnelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerTunnelMode.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerTunnelMode.setDescription('This specifies if tunnel mode is to be used with this peer.')
eqlIpsecPeerTunnelAddressIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 9), InetAddressType().clone('ipv6')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerTunnelAddressIPVersion.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerTunnelAddressIPVersion.setDescription('The Internet Protocol version the addresses are to match\n            against.  The value of this property determines the size\n            and format of the spdIpHeadFiltSrcAddressBegin,\n            spdIpHeadFiltSrcAddressEnd,\n            spdIpHeadFiltDstAddressBegin, and\n            spdIpHeadFiltDstAddressEnd objects.\n\n            Values of unknown, ipv4z, ipv6z and dns are not legal\n            values for this object.')
eqlIpsecPeerTunnelAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 10), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerTunnelAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerTunnelAddress.setDescription('The address of the tunnel remote end\n\n            This object is only used if tunnelMode is set to True.')
eqlIpsecPeerIkeV2 = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerIkeV2.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerIkeV2.setDescription('This specifies the IKE version to be used with this peer. If the peer talks\n           the other version, the IPSec session will not be established.')
eqlIpsecPeerManualKeyEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 6, 7, 11, 12, 13, 250))).clone(namedValues=NamedValues(("none", 0), ("des-cbc", 2), ("triple-des-cbc", 3), ("cast128-cbc", 6), ("blowfish-cbc", 7), ("null-enc", 11), ("aes", 12), ("aes-ctr", 13), ("skipjack", 250)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncAlg.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncAlg.setDescription('The encryption algorithm to be used.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeyEncKeyOut = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncKeyOut.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncKeyOut.setDescription('The encryption key to be used in the outbound direction.\n\n            Specified as a hex string.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeyEncKeyIn = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 14), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncKeyIn.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyEncKeyIn.setDescription('The encryption key to be used in the inbound direction.\n\n            Specified as a hex string.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeyAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("sha1", 1), ("sha256", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthAlg.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthAlg.setDescription('The authentication algorithm to be used.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeyAuthKeyOut = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthKeyOut.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthKeyOut.setDescription('The authentication key to be used in the outbound direction.\n\n            Specified as a string.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeyAuthKeyIn = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 17), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthKeyIn.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeyAuthKeyIn.setDescription('The authentication key to be used in the inbound direction.\n\n            Specified as a string.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeySpiOut = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeySpiOut.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeySpiOut.setDescription('The SPI to be used in the outbound direction.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerManualKeySpiIn = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerManualKeySpiIn.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerManualKeySpiIn.setDescription('The SPI to be used in the inbound direction.\n\n            Only applicable if the auth type is manual keys.')
eqlIpsecPeerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 4, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecPeerRowStatus.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecPeerRowStatus.setDescription('This object indicates the conceptual status of this row.\n\n            This object may not be set to active if the requirements\n            of the spdIpHeadFiltType object are not met.  In other\n            words, if the associated value columns needed by a\n            particular test have not been set, then attempting to\n            change this row to an active state will result in an\n            inconsistentValue error.  See the spdIpHeadFiltType\n            object description for further details.')
eqlIpsecCertDisplayTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5), )
if mibBuilder.loadTexts: eqlIpsecCertDisplayTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayTable.setDescription('EqualLogic-Dynamic IPSec certificate display Table.\n            This table is used to display certificate details.')
eqlIpsecCertDisplayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1), ).setIndexNames((0, "EQLIPSEC-MIB", "eqlIpsecCertInstanceId"))
if mibBuilder.loadTexts: eqlIpsecCertDisplayEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayEntry.setDescription('Contents of a particular certificate instance for display.')
eqlIpsecCertDisplayName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayName.setDescription('The administrative name for this certificate.')
eqlIpsecCertDisplayIssuedToDName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedToDName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedToDName.setDescription('Display string for the field issued to distinguished name.')
eqlIpsecCertDisplaySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplaySerialNumber.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplaySerialNumber.setDescription('Display string for the field serial number.')
eqlIpsecCertDisplayIssuedByDName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedByDName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedByDName.setDescription('Display string for the field issued by distinguished name.')
eqlIpsecCertDisplayIssuedOn = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedOn.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayIssuedOn.setDescription('Display string for the field issued on.')
eqlIpsecCertDisplayExpiresOn = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayExpiresOn.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayExpiresOn.setDescription('Display string for the field expires on.')
eqlIpsecCertDisplaySha1Fingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplaySha1Fingerprint.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplaySha1Fingerprint.setDescription('Display string for the field SHA1 finger print.')
eqlIpsecCertDisplayMd5Fingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayMd5Fingerprint.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayMd5Fingerprint.setDescription('Display string for the field MD5 finger print.')
eqlIpsecCertDisplayLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("local-cert", 1), ("root-cert", 2), ("intermediate", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayLocal.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayLocal.setDescription('Boolean that indicates if this is a localm certificate or not.')
eqlIpsecCertDisplayFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("x509", 1), ("pkcs12", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplayFormat.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplayFormat.setDescription('The certificate format. x.509 or pkcs12.')
eqlIpsecCertDisplaySubAltName = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 5, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecCertDisplaySubAltName.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecCertDisplaySubAltName.setDescription('Display string for the field MD5 finger print.')
eqlIpsecSecAssocTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6), )
if mibBuilder.loadTexts: eqlIpsecSecAssocTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocTable.setDescription('EqualLogic-Dynamic IPSec security association Table.\n            This table is used to display the security association details.')
eqlIpsecSecAssocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1), ).setIndexNames((0, "EQLGROUP-MIB", "eqlGroupId"), (0, "EQLMEMBER-MIB", "eqlMemberIndex"), (0, "EQLIPSEC-MIB", "eqlIpsecSecAssocInstanceIdHigh"), (0, "EQLIPSEC-MIB", "eqlIpsecSecAssocInstanceIdLow"))
if mibBuilder.loadTexts: eqlIpsecSecAssocEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocEntry.setDescription('Contents of a particular SA instance for display.')
eqlIpsecSecAssocInstanceIdHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 1), Unsigned32())
if mibBuilder.loadTexts: eqlIpsecSecAssocInstanceIdHigh.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocInstanceIdHigh.setDescription('This index carries the high-order 32-bit of the instance ID that identifies the IPSec security association.')
eqlIpsecSecAssocInstanceIdLow = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 2), Unsigned32())
if mibBuilder.loadTexts: eqlIpsecSecAssocInstanceIdLow.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocInstanceIdLow.setDescription('This index carries the low-order 32-bit of the instance ID that identifies the IPSec security association.')
eqlIpsecSecAssocSrcAddressIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocSrcAddressIPVersion.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocSrcAddressIPVersion.setDescription('The IP version of the source endpoint.')
eqlIpsecSecAssocSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocSrcAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocSrcAddress.setDescription('The IP address of the source endpoint.')
eqlIpsecSecAssocDstAddressIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocDstAddressIPVersion.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocDstAddressIPVersion.setDescription('The IP version of the destination endpoint.')
eqlIpsecSecAssocDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocDstAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocDstAddress.setDescription('The IP address of the destination endpoint.')
eqlIpsecSecAssocEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 6, 7, 11, 12, 13, 250))).clone(namedValues=NamedValues(("none", 0), ("des-cbc", 2), ("triple-des-cbc", 3), ("cast128-cbc", 6), ("blowfish-cbc", 7), ("null-enc", 11), ("aes", 12), ("aes-ctr", 13), ("skipjack", 250)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocEncAlg.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocEncAlg.setDescription('The encryption algorithm used.')
eqlIpsecSecAssocAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 5, 6, 7, 8, 9, 249, 250, 251, 252))).clone(namedValues=NamedValues(("none", 0), ("md5-hmac", 2), ("sha1-hmac", 3), ("sha2-256", 5), ("sha2-384", 6), ("sha2-512", 7), ("ripemd160-hmac", 8), ("aes-xcbc-mac", 9), ("md5", 249), ("sha", 250), ("null", 251), ("tcp-md5", 252)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocAuthAlg.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocAuthAlg.setDescription('The authentication algorithm used.')
eqlIpsecSecAssocSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocSpi.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocSpi.setDescription('SPI used in the security association.')
eqlIpsecSecAssocEncKey = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocEncKey.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocEncKey.setDescription('Display string for the encryption key used in the SA.')
eqlIpsecSecAssocAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocAuthKey.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocAuthKey.setDescription('Display string for the authentication key used in the SA.')
eqlIpsecSecAssocManual = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 6, 1, 12), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecSecAssocManual.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecSecAssocManual.setDescription('True means SA is from a manual key configured.')
eqlIpsecStaleSecAssocDeleteTable = MibTable((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7), )
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteTable.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteTable.setDescription('EqualLogic-Dynamic IPSec stale security association \n            delete Table. This table is used to indicate the \n            destination address and type of all security associations\n            to delete.')
eqlIpsecStaleSecAssocDeleteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7, 1), ).setIndexNames((0, "EQLGROUP-MIB", "eqlGroupId"), (0, "EQLMEMBER-MIB", "eqlMemberIndex"), (0, "EQLIPSEC-MIB", "eqlIpsecStaleSecAssocDeleteInstanceId"))
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteEntry.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteEntry.setDescription('Contents of a particular SA instance for delete.')
eqlIpsecStaleSecAssocDeleteInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteInstanceId.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteInstanceId.setDescription('This index identifies the IPSec stale SA delete instance.')
eqlIpsecStaleSecAssocDeleteDestAddressIPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteDestAddressIPVersion.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteDestAddressIPVersion.setDescription('The IP version of the destination address of the security \n            associations to delete.')
eqlIpsecStaleSecAssocDeleteDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteDestAddress.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteDestAddress.setDescription('The destination address of the security associations to delete.')
eqlIpsecStaleSecAssocDeleteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12740, 22, 1, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteRowStatus.setStatus('current')
if mibBuilder.loadTexts: eqlIpsecStaleSecAssocDeleteRowStatus.setDescription('This object indicates the conceptual status of this row.')
mibBuilder.exportSymbols("EQLIPSEC-MIB", eqlIpsecCertConfigEntry=eqlIpsecCertConfigEntry, eqlIpsecPrivKeyFileName=eqlIpsecPrivKeyFileName, eqlIpsecPolicyInstanceId=eqlIpsecPolicyInstanceId, eqlIpsecPeerNullEnc=eqlIpsecPeerNullEnc, eqlIpsecCertPassword=eqlIpsecCertPassword, eqlIpsecPolicyFilterProtocol=eqlIpsecPolicyFilterProtocol, eqlIpsecCertName=eqlIpsecCertName, eqlIpsecStaleSecAssocDeleteInstanceId=eqlIpsecStaleSecAssocDeleteInstanceId, eqlIpsecCertType=eqlIpsecCertType, eqlIpsecPolicyFilterRowStatus=eqlIpsecPolicyFilterRowStatus, eqlIpsecConformance=eqlIpsecConformance, eqlIpsecObjects=eqlIpsecObjects, eqlIpsecPolicyFilterAddress=eqlIpsecPolicyFilterAddress, eqlIpsecCertDisplayMd5Fingerprint=eqlIpsecCertDisplayMd5Fingerprint, eqlIpsecPeerTunnelAddressIPVersion=eqlIpsecPeerTunnelAddressIPVersion, eqlIpsecModule=eqlIpsecModule, eqlIpsecCertDisplayTable=eqlIpsecCertDisplayTable, eqlIpsecCertDisplayIssuedToDName=eqlIpsecCertDisplayIssuedToDName, eqlIpsecSecAssocSrcAddress=eqlIpsecSecAssocSrcAddress, eqlIpsecPeerInstanceId=eqlIpsecPeerInstanceId, eqlIpsecSecAssocAuthKey=eqlIpsecSecAssocAuthKey, eqlIpsecCertDisplayName=eqlIpsecCertDisplayName, eqlIpsecStaleSecAssocDeleteDestAddressIPVersion=eqlIpsecStaleSecAssocDeleteDestAddressIPVersion, eqlIpsecPeerManualKeyAuthAlg=eqlIpsecPeerManualKeyAuthAlg, eqlIpsecCertRowStatus=eqlIpsecCertRowStatus, eqlIpsecStaleSecAssocDeleteRowStatus=eqlIpsecStaleSecAssocDeleteRowStatus, IpsecAuthType=IpsecAuthType, eqlIpsecSecAssocInstanceIdHigh=eqlIpsecSecAssocInstanceIdHigh, eqlIpsecStaleSecAssocDeleteEntry=eqlIpsecStaleSecAssocDeleteEntry, eqlIpsecPolicyFilterNetmaskLen=eqlIpsecPolicyFilterNetmaskLen, eqlIpsecCertDisplaySerialNumber=eqlIpsecCertDisplaySerialNumber, eqlIpsecPeerManualKeyAuthKeyOut=eqlIpsecPeerManualKeyAuthKeyOut, eqlIpsecCertInstanceId=eqlIpsecCertInstanceId, eqlIpsecPolicyEntry=eqlIpsecPolicyEntry, eqlIpsecSecAssocEntry=eqlIpsecSecAssocEntry, eqlIpsecCertDisplaySha1Fingerprint=eqlIpsecCertDisplaySha1Fingerprint, eqlIpsecSecAssocAuthAlg=eqlIpsecSecAssocAuthAlg, eqlIpsecSecAssocDstAddressIPVersion=eqlIpsecSecAssocDstAddressIPVersion, eqlIpsecPolicyTable=eqlIpsecPolicyTable, eqlIpsecPolicyFilterAction=eqlIpsecPolicyFilterAction, eqlIpsecPeerEntry=eqlIpsecPeerEntry, eqlIpsecInstanceId=eqlIpsecInstanceId, eqlIpsecEnable=eqlIpsecEnable, eqlIpsecPolicyFilterLocalPort=eqlIpsecPolicyFilterLocalPort, eqlIpsecPeerManualKeyAuthKeyIn=eqlIpsecPeerManualKeyAuthKeyIn, eqlIpsecSecAssocSpi=eqlIpsecSecAssocSpi, eqlIpsecRowStatus=eqlIpsecRowStatus, eqlIpsecSecAssocInstanceIdLow=eqlIpsecSecAssocInstanceIdLow, eqlIpsecCertDisplayLocal=eqlIpsecCertDisplayLocal, eqlIpsecPeerManualKeyEncKeyOut=eqlIpsecPeerManualKeyEncKeyOut, eqlIpsecPolicyFilterPort=eqlIpsecPolicyFilterPort, eqlIpsecSecAssocEncKey=eqlIpsecSecAssocEncKey, eqlIpsecCertDisplayEntry=eqlIpsecCertDisplayEntry, InetPortNumber=InetPortNumber, eqlIpsecSecAssocEncAlg=eqlIpsecSecAssocEncAlg, eqlIpsecSecAssocDstAddress=eqlIpsecSecAssocDstAddress, eqlIpsecEntry=eqlIpsecEntry, eqlIpsecPeerPreSharedKey=eqlIpsecPeerPreSharedKey, IpsecEncType=IpsecEncType, eqlIpsecCertDisplayExpiresOn=eqlIpsecCertDisplayExpiresOn, eqlIpsecTable=eqlIpsecTable, eqlIpsecPeerCertIdType=eqlIpsecPeerCertIdType, eqlIpsecCertDisplaySubAltName=eqlIpsecCertDisplaySubAltName, eqlIpsecStaleSecAssocDeleteTable=eqlIpsecStaleSecAssocDeleteTable, PYSNMP_MODULE_ID=eqlIpsecModule, eqlIpsecPeerTunnelAddress=eqlIpsecPeerTunnelAddress, eqlIpsecPeerName=eqlIpsecPeerName, eqlIpsecPeerManualKeySpiIn=eqlIpsecPeerManualKeySpiIn, eqlIpsecCertDisplayFormat=eqlIpsecCertDisplayFormat, SnmpAdminString=SnmpAdminString, eqlIpsecPolicyFilterLocalAddress=eqlIpsecPolicyFilterLocalAddress, eqlIpsecCertConfigTable=eqlIpsecCertConfigTable, eqlIpsecPolicyFilterPeerName=eqlIpsecPolicyFilterPeerName, eqlIpsecPeerIkeV2=eqlIpsecPeerIkeV2, eqlIpsecPeerManualKeyEncAlg=eqlIpsecPeerManualKeyEncAlg, eqlIpsecPeerManualKeyEncKeyIn=eqlIpsecPeerManualKeyEncKeyIn, eqlIpsecPeerManualKeySpiOut=eqlIpsecPeerManualKeySpiOut, eqlIpsecPolicyFilterIPVersion=eqlIpsecPolicyFilterIPVersion, eqlIpsecCertFileName=eqlIpsecCertFileName, eqlIpsecSecAssocManual=eqlIpsecSecAssocManual, eqlIpsecStaleSecAssocDeleteDestAddress=eqlIpsecStaleSecAssocDeleteDestAddress, eqlIpsecPeerRowStatus=eqlIpsecPeerRowStatus, eqlIpsecPeerTable=eqlIpsecPeerTable, eqlIpsecPeerAuthType=eqlIpsecPeerAuthType, eqlIpsecPeerCertIdValue=eqlIpsecPeerCertIdValue, eqlIpsecCertDisplayIssuedByDName=eqlIpsecCertDisplayIssuedByDName, eqlIpsecSecAssocTable=eqlIpsecSecAssocTable, eqlIpsecSecAssocSrcAddressIPVersion=eqlIpsecSecAssocSrcAddressIPVersion, eqlIpsecPolicyFilterName=eqlIpsecPolicyFilterName, eqlIpsecNotifications=eqlIpsecNotifications, eqlIpsecPeerTunnelMode=eqlIpsecPeerTunnelMode, IpsecIdType=IpsecIdType, eqlIpsecCertDisplayIssuedOn=eqlIpsecCertDisplayIssuedOn)
