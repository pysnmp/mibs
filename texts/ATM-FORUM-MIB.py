#
# PySNMP MIB module ATM-FORUM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/atmforum/ATM-FORUM-MIB
# Produced by pysmi-1.1.12 at Tue Dec  3 12:22:06 2024
# On host fv-az573-178 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, ModuleIdentity, iso, MibIdentifier, Bits, enterprises, IpAddress, NotificationType, Counter64, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Integer32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ModuleIdentity", "iso", "MibIdentifier", "Bits", "enterprises", "IpAddress", "NotificationType", "Counter64", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Integer32", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1))
atmForumUni = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2))
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class AtmAddress2(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
class NetPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(13, 13), )
atmfTransmissionTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2))
atmfUnknownType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 1))
atmfSonetSTS3c = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 2))
atmfDs3 = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 3))
atmf4B5B = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 4))
atmf8B10B = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 5))
atmfMediaTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3))
atmfMediaUnknownType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 1))
atmfMediaCoaxCable = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 2))
atmfMediaSingleMode = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 3))
atmfMediaMultiMode = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 4))
atmfMediaStp = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 5))
atmfMediaUtp = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 6))
atmfTrafficDescrTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4))
atmfNoDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 1))
atmfPeakRate = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 2))
atmfNoClpNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 3))
atmfClpNoTaggingNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 4))
atmfClpTaggingNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 5))
atmfNoClpScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 6))
atmfClpNoTaggingScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 7))
atmfClpTaggingScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 8))
atmfPhysicalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 1))
atmfAtmLayerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 2))
atmfAtmStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 3))
atmfVpcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 4))
atmfVccGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 5))
atmfAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 6))
atmfNetPrefixGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 7))
atmfPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 1, 1), )
if mibBuilder.loadTexts: atmfPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortTable.setDescription("A table of physical layer status and parameter information for the \n\t\tUNI's physical interface.")
atmfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfPortIndex"))
if mibBuilder.loadTexts: atmfPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortEntry.setDescription('An entry in the table, containing information about the physical layer \n\t\tof a UNI interface.')
atmfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortIndex.setDescription('A unique value which identifies this port. The value of 0 has the \n\t\tspecial meaning of identifying the local UNI.')
atmfPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 2), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortAddress.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortAddress.setDescription('This object should not be implemented except as required for backward \n\t\tcompatibility with version 2.0 of the UNI specification. The Address Group, \n\t\tdefined as part of the separate Address Registration MIB should be used \n\t\tinstead.')
atmfPortTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortTransmissionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortTransmissionType.setDescription('The transmission type of this port. For example, for a port using the \n\t\tSonet STS-3c physical layer at 155.52 Mbs, this object would have the \n\t\tObject Identifier value: atmfSonetSTS3c.')
atmfPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMediaType.setDescription('The type of media being used on this port. For example, for a port using \n\t\tcoaxial cable, this object would have the Object Identifier value: \n\t\tatmfMediaCoaxCable.')
atmfPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("inService", 2), ("outOfService", 3), ("loopBack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortOperStatus.setDescription('The operational (i.e., actual) state of this port.\n\t\tThe ILMI should not alarm on a physical interface for when the value of this \n\t\tobject is outOfService(3). This capability is useful if equipment is to be \n\t\tdisconnected, or for troubleshooting purposes.\n\t\tA value of loopBack(4) indicates that a local loopback is in place. ')
atmfPortSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortSpecific.setDescription("This object 'points' to additional transmission and/or media specific \n\t\tinformation relating to this port. In particular, this object's value \n\t\tis the name of a specific instance of the first columnar object of a MIB \n\t\ttable with such additional information, where the specific instance is the \n\t\tone which corresponds to this port.\n\t\tFor example, for a DS3 interface, this object would contain the value, as \n\t\tdefined in RFC 1407:\n\t\t\tdsx3LineIndex.i\n\t\twhere i would be the integer value uniquely identifying the DS3 interface \n\t\tcorresponding to this port.  If no additional transmission and/or media \n\t\tspecific information is available, this object has the value { 0 0 }.")
atmfPortMyIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMyIfName.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMyIfName.setDescription('A textual name of this interface. If this systme is manageable through\n\t\tSNMP, and supports the object ifName, the value of this object must be\n\t\tidentical with that of ifName for the ifEntry of the lowest level physical\n\t\tinterface for this port. This interface must be uniquely names on this system\n\t\tto distinguish parallel links with a neighboring system. If this interface\n\t\tdoes not have a textual name, the value of this object is a zero length\n\t\tstring.')
atmfMyIpNmAddress = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMyIpNmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMyIpNmAddress.setDescription('An IP Address to which a Network Management Station can send Network\n\t\tManagement protocol, e.g. SNMP messages to UDP port 161, in order to\n\t\taccess network management information concerning the operation of the\n\t\tATM devide local to this UME.')
atmfAtmLayerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 2, 1), )
if mibBuilder.loadTexts: atmfAtmLayerTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerTable.setDescription("A table of ATM layer status and parameter information for the UNI's \n\t\tphysical interface.")
atmfAtmLayerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfAtmLayerIndex"))
if mibBuilder.loadTexts: atmfAtmLayerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerEntry.setDescription('An entry in the table, containing information about the ATM layer of a UNI \n\t\tinterface.')
atmfAtmLayerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerIndex.setDescription('The unique value which identifies the UNI port. The value of 0 has the \n\t\tspecial meaning of identifying the local UNI.')
atmfAtmLayerMaxVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setDescription('The maximum number of switched and permanent VPCs supported on this UNI.')
atmfAtmLayerMaxVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setDescription('The maximum number of switched and permanent VCCs supported on this UNI.')
atmfAtmLayerConfiguredVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setDescription('The number of permanent VPCs configured for use on this UNI.')
atmfAtmLayerConfiguredVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setDescription('The number of permanent VCCs configured for use on this UNI.')
atmfAtmLayerMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setDescription('The number of active VPI bits on this interface.')
atmfAtmLayerMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setDescription('The number of active VCI bits on this interface.')
atmfAtmLayerUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniType.setDescription('The type of the ATM UNI, either public or private.')
atmfAtmLayerUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("version2point0", 1), ("version3point0", 2), ("version3point1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setDescription("An indication of the latest version of the ATM Forum UNI Specification \n\t\tthat is supported on this UNI. If this value is not present, a version\n\t\tof the UNI earlier than 3.1 is supported. If a value greated than \n\t\tversion3point1 is persent, then UNI 3.1 communication should be attempt.\n\n\t\tIf the peer UNE's value of this object is the same as, or later than the\n\t\tlocal UME's value, then the version corresponding to the local UME's\n\t\tvalue should be attempted. Otherwise, if the peer UME's value of this \n\t\tobject is earlier, and supported locally, then the local UME should attempt \n\t\tthe version corresponding to the peer UME's value. Otherwise, compatability \n\t\tof the two UMEs cannot be assumed.")
atmfAtmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 3, 1), )
if mibBuilder.loadTexts: atmfAtmStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsTable.setDescription("A table of ATM layer statistics information for\n\t\tthe UNI's physical interface.")
atmfAtmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfAtmStatsIndex"))
if mibBuilder.loadTexts: atmfAtmStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsEntry.setDescription('An entry in the table, containing statistics for the ATM layer of a \n\t\tUNI interface.')
atmfAtmStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsIndex.setDescription('The unique value which identifies the UNI port. The value of 0 has the \n\t\tspecial meaning of identifying the local UNI.')
atmfAtmStatsReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setDescription('The accumulated number of  ATM cells received on this UNI which were \n\t\tassigned and not dropped.')
atmfAtmStatsDroppedReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setDescription('The accumulated number of ATM cells which were dropped for the reasons \n\t\tdefined in section 4.4.4.2.')
atmfAtmStatsTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setDescription('The accumulated number of assigned ATM cells which were transmitted across \n\t\tthis interface.')
atmfVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 4, 1), )
if mibBuilder.loadTexts: atmfVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTable.setDescription('A table of status and parameter information on the virtual path connections \n\t\twhich cross this UNI. These is one entry in this table for each permanent\n\t\tvirtual path connection.')
atmfVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVpcPortIndex"), (0, "ATM-FORUM-MIB", "atmfVpcVpi"))
if mibBuilder.loadTexts: atmfVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcEntry.setDescription('An entry in the table, containing information about a particular virtual path \n\t\tconnection.')
atmfVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcPortIndex.setDescription('The unique value which identifies the UNI port. The value of 0 has the \n\t\tspecial meaning of identifying the local UNI.')
atmfVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcVpi.setDescription('The VPI value of this Virtual Path Connection at the local UNI.')
atmfVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcOperStatus.setDescription('The present actual operational status of the VPC.\n\n\t\tA value of end2endUp(2) or end2endDown(3) would be used if the end-to-end \n\t\tstatus is known. If only local status information is available, a value of \n\t\tlocalUpEnd2endUnknown(4) or localDown(5) would be used.')
atmfVpcTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the transmit direction of \n\t\tthis VPC. The type may indicate none, or a type with one or more parameters. \n\t\tThese parameters are specified as a parameter vector, in the corresponding \n\t\tinstances of the objects: \n\t\tatmfVpcTransmitTrafficDescriptorParam1, \n\t\tatmfVpcTransmitTrafficDescriptorParam2, \n\t\tatmfVpcTransmitTrafficDescriptorParam3, \n\t\tatmfVpcTransmitTrafficDescriptorParam4, and \n\t\tatmfVpcTransmitTrafficDescriptorParam5.')
atmfVpcTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcTransmitTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the traffic in the receive \n\t\tdirection of this VPC. The type may indicate none, or a type with one or \n\t\tmore parameters. These parameters are specified as a parameter vector, in \n\t\tthe corresponding instances of the objects: \n\t\tatmfVpcReceiveTrafficDescriptorParam1, \n\t\tatmfVpcReceiveTrafficDescriptorParam2, \n\t\tatmfVpcReceiveTrafficDescriptorParam3, \n\t\tatmfVpcReceiveTrafficDescriptorParam4, and \n\t\tatmfVpcReceiveTrafficDescriptorParam5.')
atmfVpcReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector for this VPC, used \n\t\taccording to the value of atmfVpcReceiveTrafficDescriptorType.')
atmfVpcQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcQoSCategory.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVpcQoSCategory.setDescription('This object should not be implemented except as required for backward \n\t\tcompatibility with version 2.0 of the UNI specification.')
atmfVpcTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setDescription('The QoS Class, as defined in section 4 of  Appendix A, for the transmit \n\t\tdirection of this VPC connection at the local UNI.')
atmfVpcReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setDescription('The QoS Class, as defined in section 4 of Appendix A, for the receive \n\t\tdirection of this VPC connection at the local UNI.')
atmfVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 5, 1), )
if mibBuilder.loadTexts: atmfVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTable.setDescription('A table of status and parameter information on the virtual channel \n\t\tconnections which are visible at this UNI. There is one entry in this \n\t\ttable for each permanent virtual channel connection, including reserved \n\t\tVCC that are supported: e.g., signalling, OAM flows, and ILMI, but not \n\t\tunassigned cells.')
atmfVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfVccPortIndex"), (0, "ATM-FORUM-MIB", "atmfVccVpi"), (0, "ATM-FORUM-MIB", "atmfVccVci"))
if mibBuilder.loadTexts: atmfVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccEntry.setDescription('An entry in the table, containing information about a particular virtual \n\t\tchannel connection.')
atmfVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccPortIndex.setDescription('The unique value which identifies the UNI port. The value of 0 has the \n\t\tspecial meaning of identifying the local UNI.')
atmfVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVpi.setDescription('The VPI value of this Virtual Channel Connection at the local UNI.')
atmfVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVci.setDescription('The VCI value of this Virtual Channel Connection at the local UNI.')
atmfVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccOperStatus.setDescription('The present actual operational status of the VCC. A value of end2endUp(2) \n\t\tor end2endUp(3) is used if the end to end status is known.\n\n\t\tIf only local status is known a value of localUpEnd2endUnknown(4) or \n\t\tlocalDown(5) is used.')
atmfVccTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the transmit direction of \n\t\tthis VCC. The type may indicate none, or a type with one or more parameters. \n\t\tThese parameters are specified as a parameter vector, in the corresponding \n\t\tinstances of the objects: \n\t\tatmfVccTransmitTrafficDescriptorParam1, \n\t\tatmfVccTransmitTrafficDescriptorParam2, \n\t\tatmfVccTransmitTrafficDescriptorParam3, \n\t\tatmfVccTransmitTrafficDescriptorParam4, and \n\t\tatmfVccTransmitTrafficDescriptorParam5.')
atmfVccTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector for this VCC, used \n\t\taccording to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector for this VCC, used \n\t\taccording to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector for this VCC, used \n\t\taccording to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector for this VCC, used \n\t\taccording to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector for this VCC, used \n\t\taccording to the value of atmfVccTransmitTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the traffic in the receive \n\t\tdirection of this VCC. The type may indicate none, or a type with one or \n\t\tmore parameters. \n\t\tThese parameters are specified as a parameter vector, in the corresponding \n\t\tinstances of the objects: \n\t\tatmfVccReceiveTrafficDescriptorParam1, \n\t\tatmfVccReceiveTrafficDescriptorParam2, \n\t\tatmfVccReceiveTrafficDescriptorParam3, \n\t\tatmfVccReceiveTrafficDescriptorParam4, and \n\t\tatmfVccReceiveTrafficDescriptorParam5.')
atmfVccReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector for this VCC, used \n\t\taccording to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector for this VCC, used \n\t\taccording to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector for this VCC, used \n\t\taccording to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector for this VCC, used \n\t\taccording to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector for this VCC, used \n\t\taccording to the value of atmfVccReceiveTrafficDescriptorType.')
atmfVccQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccQoSCategory.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVccQoSCategory.setDescription('This object should not be implemented except as required for backward \n\t\tcompatibility with version 2.0 of the UNI specification.')
atmfVccTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setDescription('The QoS Class, as defined in section 4 of Appendix A, for the transmit \n\t\tdirection of this VCC connection at the local UNI.')
atmfVccReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setDescription('The QoS Class, as defined in section 4 of Appendix A, for the receive \n\t\tdirection of this VCC connection at the local UNI.')
atmfNetPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 7, 1), )
if mibBuilder.loadTexts: atmfNetPrefixTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfNetPrefixTable.setDescription('A table implemented by the UNI Management Entity on the user-side of an \n\t        ATM UNI port, containing the network-prefix(es) for ATM-layer addresses \n\t\tin effect on the user-side of the UNI.')
atmfNetPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 7, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfNetPrefixPort"), (0, "ATM-FORUM-MIB", "atmfNetPrefixPrefix"))
if mibBuilder.loadTexts: atmfNetPrefixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfNetPrefixEntry.setDescription('Information about a single network-prefix for ATM-layer addresses in\n\t\teffect on the user-side of a UNI port.  Note that the index variable\n\t\tatmfNetPrefixPrefix is a variable-length string, and as such the rule \n\t\tfor variable-length strings in section 4.1.6 of RFC 1212 applies.')
atmfNetPrefixPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: atmfNetPrefixPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmfNetPrefixPort.setDescription('A unique value which identifies the UNI port for which the network \n\t\tprefix for ATM addresses is in effect.  The value of 0 has the special \n\t\tmeaning of identifying the local UNI.')
atmfNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 7, 1, 1, 2), NetPrefix())
if mibBuilder.loadTexts: atmfNetPrefixPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: atmfNetPrefixPrefix.setDescription('The network prefix for ATM addresses which is in effect on the \n\t\tuser-side of the ATM UNI port.')
atmfNetPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfNetPrefixStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfNetPrefixStatus.setDescription('An indication of the validity of the network prefix for ATM addresses \n\t\ton the user-side of the UNI port.  To configure a new network prefix in \n\t\tthis table, the network-side must set the appropriate instance of this \n\t\tobject to the value valid(1).\n\t\tTo delete an existing network prefix in this table, the network-side\n\t\tmust set the appropriate instance of this object to the value invalid(2).\n\n\t        If circumstances occur on the user-side which cause a prefix to become \n\t\tinvalid, the user-side modifies the value of the appropriate instance of \n\t\tthis object to invalid(2).\n\n\t        Whenever the value of this object for a particular prefix becomes invalid(2), \n\t\tthe conceptual row for that prefix may be removed from the table at anytime, \n\t\teither immediately or subsequently.')
atmfAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 6, 1), )
if mibBuilder.loadTexts: atmfAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressTable.setDescription('A table implemented by the network-side of an ATM UNI port, containing the\n\t\tATM-layer addresses in effect on the user-side of the UNI.')
atmfAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1), ).setIndexNames((0, "ATM-FORUM-MIB", "atmfAddressPort"), (0, "ATM-FORUM-MIB", "atmfAddressAtmAddress"))
if mibBuilder.loadTexts: atmfAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressEntry.setDescription('Information about a single ATM-layer address in effect on the user-side \n\t\tof a UNI port.  Note that the index variable atmfAddressAtmAddress is a \n\t\tvariable-length string, and as such the rule for variable-length strings \n\t\tin section 4.1.6 of RFC 1212 applies.')
atmfAddressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: atmfAddressPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressPort.setDescription('A unique value which identifies the UNI port for which the ATM address is \n\t\tin effect.  The value of 0 has the special meaning of identifying the local \n\t\tUNI.')
atmfAddressAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 2), AtmAddress2())
if mibBuilder.loadTexts: atmfAddressAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressAtmAddress.setDescription('The ATM address which is in effect on the user-side of the ATM UNI port.')
atmfAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressStatus.setDescription('An indication of the validity of the ATM address at the user-side of\n\t\tthe UNI port.  To configure a new address in this table, the user-side \n\t\tmust set the appropriate instance of this object to the value valid(1).  \n\t\tTo delete an existing address in this able, the user-side must set the \n\t\tappropriate instance of this object to the value invalid(2).\n\n\t        If circumstances occur on the network-side which cause an address to \n\t\tbecome invalid, the network-side modifies the value of the appropriate\n\t\tinstance of this object to invalid(2).\n\n\t        Whenever the value of this object for a particular address becomes \n\t\tinvalid(2), the conceptual row for that address may be removed from the \n\t\ttable at anytime, either immediately or subsequently.')
mibBuilder.exportSymbols("ATM-FORUM-MIB", atmfVpcOperStatus=atmfVpcOperStatus, atmForumUni=atmForumUni, atmfVpcReceiveTrafficDescriptorParam3=atmfVpcReceiveTrafficDescriptorParam3, atmfAtmLayerConfiguredVCCs=atmfAtmLayerConfiguredVCCs, atmfVccTransmitTrafficDescriptorParam4=atmfVccTransmitTrafficDescriptorParam4, atmfVccGroup=atmfVccGroup, atmfVccEntry=atmfVccEntry, atmfVccReceiveTrafficDescriptorParam4=atmfVccReceiveTrafficDescriptorParam4, atmfAtmStatsGroup=atmfAtmStatsGroup, atmfUnknownType=atmfUnknownType, atmfAtmLayerMaxVciBits=atmfAtmLayerMaxVciBits, atmfVpcTransmitTrafficDescriptorParam1=atmfVpcTransmitTrafficDescriptorParam1, atmfVpcVpi=atmfVpcVpi, atmfAtmLayerMaxVpiBits=atmfAtmLayerMaxVpiBits, atmfMyIpNmAddress=atmfMyIpNmAddress, atmfAddressPort=atmfAddressPort, AtmAddress=AtmAddress, atmfAtmLayerMaxVCCs=atmfAtmLayerMaxVCCs, atmfPortEntry=atmfPortEntry, atmfVpcTable=atmfVpcTable, atmfVpcPortIndex=atmfVpcPortIndex, atmfNetPrefixPort=atmfNetPrefixPort, NetPrefix=NetPrefix, atmfTrafficDescrTypes=atmfTrafficDescrTypes, atmfVpcTransmitTrafficDescriptorParam2=atmfVpcTransmitTrafficDescriptorParam2, atmfAtmStatsIndex=atmfAtmStatsIndex, atmfVccTransmitTrafficDescriptorParam3=atmfVccTransmitTrafficDescriptorParam3, atmfVpcTransmitTrafficDescriptorParam4=atmfVpcTransmitTrafficDescriptorParam4, atmfVccOperStatus=atmfVccOperStatus, atmfAtmStatsTransmittedCells=atmfAtmStatsTransmittedCells, atmfVpcTransmitTrafficDescriptorType=atmfVpcTransmitTrafficDescriptorType, atmfPortOperStatus=atmfPortOperStatus, atmfMediaUnknownType=atmfMediaUnknownType, atmfPortIndex=atmfPortIndex, atmfVccTransmitQoSClass=atmfVccTransmitQoSClass, atmfAtmStatsReceivedCells=atmfAtmStatsReceivedCells, atmfTransmissionTypes=atmfTransmissionTypes, atmfAddressEntry=atmfAddressEntry, atmfSonetSTS3c=atmfSonetSTS3c, atmfMediaSingleMode=atmfMediaSingleMode, atmfAtmLayerGroup=atmfAtmLayerGroup, atmfVpcQoSCategory=atmfVpcQoSCategory, atmfAtmStatsDroppedReceivedCells=atmfAtmStatsDroppedReceivedCells, atmfAddressGroup=atmfAddressGroup, atmfNetPrefixEntry=atmfNetPrefixEntry, atmfVpcGroup=atmfVpcGroup, atmfVpcReceiveTrafficDescriptorParam1=atmfVpcReceiveTrafficDescriptorParam1, atmfVccReceiveTrafficDescriptorParam1=atmfVccReceiveTrafficDescriptorParam1, atmfVccTransmitTrafficDescriptorParam5=atmfVccTransmitTrafficDescriptorParam5, atmfDs3=atmfDs3, atmfVccPortIndex=atmfVccPortIndex, atmfVpcReceiveTrafficDescriptorType=atmfVpcReceiveTrafficDescriptorType, atmForumAdmin=atmForumAdmin, atmfVpcReceiveTrafficDescriptorParam5=atmfVpcReceiveTrafficDescriptorParam5, atmfAtmLayerTable=atmfAtmLayerTable, atmfAtmStatsEntry=atmfAtmStatsEntry, atmfVccTransmitTrafficDescriptorParam2=atmfVccTransmitTrafficDescriptorParam2, atmfVccVpi=atmfVccVpi, atmfClpNoTaggingNoScr=atmfClpNoTaggingNoScr, atmfVccQoSCategory=atmfVccQoSCategory, atmfNoClpScr=atmfNoClpScr, atmfAtmLayerEntry=atmfAtmLayerEntry, atmfVpcTransmitTrafficDescriptorParam3=atmfVpcTransmitTrafficDescriptorParam3, atmfPortMyIfName=atmfPortMyIfName, atmfPortAddress=atmfPortAddress, atmfPortTransmissionType=atmfPortTransmissionType, atmfVpcReceiveQoSClass=atmfVpcReceiveQoSClass, atmfVccTransmitTrafficDescriptorType=atmfVccTransmitTrafficDescriptorType, atmfMediaStp=atmfMediaStp, atmfAtmLayerIndex=atmfAtmLayerIndex, AtmAddress2=AtmAddress2, atmfNetPrefixPrefix=atmfNetPrefixPrefix, atmfNoDescriptor=atmfNoDescriptor, atmfVccVci=atmfVccVci, atmfMediaMultiMode=atmfMediaMultiMode, atmfAddressAtmAddress=atmfAddressAtmAddress, atmfVpcTransmitQoSClass=atmfVpcTransmitQoSClass, atmfClpNoTaggingScr=atmfClpNoTaggingScr, atmfVpcEntry=atmfVpcEntry, atmForum=atmForum, atmfNetPrefixTable=atmfNetPrefixTable, atmfVccReceiveTrafficDescriptorParam3=atmfVccReceiveTrafficDescriptorParam3, atmfAtmLayerConfiguredVPCs=atmfAtmLayerConfiguredVPCs, atmfPortSpecific=atmfPortSpecific, atmfVccTransmitTrafficDescriptorParam1=atmfVccTransmitTrafficDescriptorParam1, atmfMediaUtp=atmfMediaUtp, atmfPortMediaType=atmfPortMediaType, atmfNoClpNoScr=atmfNoClpNoScr, atmfClpTaggingScr=atmfClpTaggingScr, atmfAddressStatus=atmfAddressStatus, atmfNetPrefixGroup=atmfNetPrefixGroup, atmfPortTable=atmfPortTable, atmfAtmLayerUniType=atmfAtmLayerUniType, atmfVccReceiveQoSClass=atmfVccReceiveQoSClass, atmfPeakRate=atmfPeakRate, atmfAtmStatsTable=atmfAtmStatsTable, atmfAddressTable=atmfAddressTable, atmfMediaCoaxCable=atmfMediaCoaxCable, atmfClpTaggingNoScr=atmfClpTaggingNoScr, atmfVpcReceiveTrafficDescriptorParam2=atmfVpcReceiveTrafficDescriptorParam2, atmfVccReceiveTrafficDescriptorParam5=atmfVccReceiveTrafficDescriptorParam5, atmfMediaTypes=atmfMediaTypes, atmfVpcTransmitTrafficDescriptorParam5=atmfVpcTransmitTrafficDescriptorParam5, atmfPhysicalGroup=atmfPhysicalGroup, atmf8B10B=atmf8B10B, atmfVpcReceiveTrafficDescriptorParam4=atmfVpcReceiveTrafficDescriptorParam4, atmfNetPrefixStatus=atmfNetPrefixStatus, atmfAtmLayerMaxVPCs=atmfAtmLayerMaxVPCs, atmfVccTable=atmfVccTable, atmfVccReceiveTrafficDescriptorType=atmfVccReceiveTrafficDescriptorType, atmfVccReceiveTrafficDescriptorParam2=atmfVccReceiveTrafficDescriptorParam2, atmf4B5B=atmf4B5B, atmfAtmLayerUniVersion=atmfAtmLayerUniVersion)
