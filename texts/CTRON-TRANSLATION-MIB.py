#
# PySNMP MIB module CTRON-TRANSLATION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-TRANSLATION-MIB
# Produced by pysmi-1.1.8 at Wed Jun 29 15:07:36 2022
# On host fv-az180-114 platform Linux version 5.13.0-1031-azure by user runner
# Using Python version 3.10.5 (main, Jun  7 2022, 06:49:50) [GCC 9.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
MacAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "MacAddress")
ctTranslation, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctTranslation")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Gauge32, IpAddress, ObjectIdentity, Integer32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ModuleIdentity, Unsigned32, Counter64, MibIdentifier, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Gauge32", "IpAddress", "ObjectIdentity", "Integer32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ModuleIdentity", "Unsigned32", "Counter64", "MibIdentifier", "Bits", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ctTransFddiAtm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 1))
ctTransFddiEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2))
ctTransEthernetFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 3))
ctTransRifDb = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4))
ctTransBcastX = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5))
ctTransIbmLlc = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6))
ctTransSr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7))
ctTransNovellCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8))
ctTransIPCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9))
ctTransA2Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10))
ctTransOtherCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11))
ctTranslfpsCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12))
ctTransFddiAtmMtu = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("greater1518MTU", 1), ("less1518MTU", 2))).clone('greater1518MTU')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiAtmMtu.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiAtmMtu.setDescription('When written with a (1), allows SNAP frames up to 4500 bytes in\n        length to be received from the FNB and processed by the ATM SAR\n        component. When this object is written with a (1), a value \n        of (1) for the ctTransFddiAtmIPFrag object must be ignored.\n \n        When written with a (2), discards any frames received on the FNB\n        which are greater than 1518 bytes in length. A \n        value of (2) must be ignored if the frame is IP and the\n        ctTransFddiAtmIPFrag object is written with a (1).')
ctTransFddiAtmIPFrag = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiAtmIPFrag.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiAtmIPFrag.setDescription('When written with a (1), will fragment IP frames from FDDI to\n        Ethernet before the frame is processed by the ATM SAR \n        component. This object must be ignored when written with a (1) if the \n        ctTransFddiAtmMtu object is written with a (1).\n \n        When written with a (2), discards any frames received on the FNB\n        which are greater than 1518 bytes in length. A value of \n        (2) for this object must be ignored if the ctTransFddiAtmMtu\n        object is written with a (1).')
ctTransFddiEthernetIPFrag = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiEthernetIPFrag.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiEthernetIPFrag.setDescription('Enables or disables IP fragmentation from FDDI to any/all\n        Ethernet interfaces.')
ctTransFddiSnapEthernetType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernetII", 1), ("ethernetSnap", 2))).clone('ethernetII')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiSnapEthernetType.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiSnapEthernetType.setDescription('The desired frame type to be translated from FDDI to Ethernet.\n        If set to ethernetII(1) all non-IPX frames will be translated\n        to ethernetII.  If set to ethernetSnap(2), all non-IPX frames will\n        be translated to ethernet_snap.')
ctTransFddiEthernetAuto = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiEthernetAuto.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiEthernetAuto.setDescription("Enables or disables the 'Auto-Learn' Translation feature of\n        FDDI to Ethernet frames for the objects below. If enabled, \n        the device will automatically learn the frame type by source \n        address from the Ethernet interfaces. If enabled, IPX FDDI frames \n        destined to a learned source address will be translated to the \n        appropriate frame type. If the Ethernet destination address has \n        not been heard from,  therefore the frame type used is unknown, \n        the device default frame translation for that frame type will be used.")
ctTransFddiEthernetSnapIPX = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ethernetSnap", 2), ("ethernet802dot3", 3), ("ethernet802dot3Raw", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiEthernetSnapIPX.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiEthernetSnapIPX.setDescription('The desired translation of IPX FDDI SNAP frames to Ethernet.')
ctTransFddiEthernet802dot2IPX = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ethernetSnap", 2), ("ethernet802dot3", 3), ("ethernet802dot3Raw", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiEthernet802dot2IPX.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiEthernet802dot2IPX.setDescription('The desired translation of IPX FDDI 802.2 frames to Ethernet.')
ctTransFddiEthernetMACIPX = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernetII", 1), ("ethernetSnap", 2), ("ethernet802dot3", 3), ("ethernet802dot3Raw", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransFddiEthernetMACIPX.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransFddiEthernetMACIPX.setDescription('The desired translation of IPX FDDI MAC frames to Ethernet.')
ctTransEthernetFddiRAW = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fDDI802dot2", 1), ("fDDISnap", 2), ("fDDIMAC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransEthernetFddiRAW.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransEthernetFddiRAW.setDescription("The desired translation of Ethernet802.3 'RAW' frames to FDDI.\n        This is a device level object meaning Ethernet 'RAW' frames \n        to any/all FDDI interfaces.")
ctTransEthernetFddiPadVerify = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("not-supported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransEthernetFddiPadVerify.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransEthernetFddiPadVerify.setDescription('Selects 802.3 length verfication for Ethernet FDDI frame  \n        translation. \n\n        If set to Enabled(1), the device consults the 802.3 length\n        field to determine the amount of pad to removed regardless\n        of frame size. This setting will cause the device to strip\n        unnecessary pad in frames greater than 64 bytes.\n\n        If set to Disabled(2), the default value, the 802.3\n        length field is only interpreted if the frame size is\n        64 bytes. For frames greater than 64 bytes, it is assumed\n        that there is no 802.3 pad in the frame. \n\n        If set to Not-Supported(3), the device does not support this \n        feature and will only strip pad from ethernet frames that are\n        64 bytes in length.')
ctTransRifDbTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1), )
if mibBuilder.loadTexts: ctTransRifDbTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbTable.setDescription('A table containing entries of RIF Database.')
ctTransRifDbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransRifDbMacAddr"))
if mibBuilder.loadTexts: ctTransRifDbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbEntry.setDescription('This entry for ctTransRifDbTable.')
ctTransRifDbMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransRifDbMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbMacAddr.setDescription('The Mac address of a source station in Cabletron cannonical\n       format.')
ctTransRifDbSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransRifDbSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbSrcPort.setDescription('The index of the MIB-II interface that hardware address is learned\n              from.')
ctTransRifDbLength = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransRifDbLength.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbLength.setDescription('This object returns the number of bytes of routing information\n              associated with this entry.')
ctTransRifDbRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransRifDbRIF.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbRIF.setDescription('This returns the routing information associated with an entry.')
ctTransRifDbCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2), )
if mibBuilder.loadTexts: ctTransRifDbCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbCtrlTable.setDescription('A table containing entries of objects to control RIF database.')
ctTransRifDbCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransRifDbCtrlPort"))
if mibBuilder.loadTexts: ctTransRifDbCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbCtrlEntry.setDescription('This entry for ctTransRifDbCtrlTable.')
ctTransRifDbCtrlPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransRifDbCtrlPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbCtrlPort.setDescription('The MIB-II interface number of the port for which this entry\n              is administering control over the RIF cache.')
ctTransRifDbWeightState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notsupported", 1), ("shortestpath", 2), ("quickestpath", 3), ("largestmtu", 4), ("lastseen", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransRifDbWeightState.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbWeightState.setDescription("Indicates the type of RIF to be retained in the RIF database.\n              shortestPath (2) is the RIF with the least number of hops. The \n                               existing RIF will be replaced if the new RIF \n                               is shorter.\n              quickestPath (3) is the 'first seen' RIF.\n              largestMTU   (4) is the path that supports the largest frame as\n                               indicated by the LF (largest frame bits) in the\n                               routing control field (RCF).\n              lastSeen     (5) is the 'most recently seen' RIF. \n \n              The default value for this object is device specific.")
ctTransRifDbCtrlType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("explorer", 1), ("all", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransRifDbCtrlType.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbCtrlType.setDescription("Type of RIF to cache. When the explorer option (1) is selected\n              the existing RIF may be replaced only if the received frame is \n              an explorer.  When the 'all' option (2) is selected the existing \n              RIF may be replaced for any SR frame received with a valid RIF. \n\n              Some devices will use this in conjunction with the \n              ctTransRifDbWeightState option to determine which RIFs may be \n              cached.\n\n              The default for this object is product specific.")
ctTransRifDbAgingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 4, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransRifDbAgingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransRifDbAgingTimer.setDescription('The timeout period in seconds for aging out dynamically \n              learned RI Fs.\n\n              The default for this object is product specific.')
ctTransBcastXTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1), )
if mibBuilder.loadTexts: ctTransBcastXTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXTable.setDescription('A list describing the state of the broadcast conversion for each\n              interface on this device. The user will specify two broadcast\n              addresses (per interface), one for the media specific interface \n              one for the cannonical format, that the translation state machine\n              will provide conversion between. This conversion only acts upon the\n              DA of the MAC header when the specified address matches the DA.')
ctTransBcastXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransBcastXPort"))
if mibBuilder.loadTexts: ctTransBcastXEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXEntry.setDescription('A list of objects pertaining to the state of broadcast\n              conversion for each interface.')
ctTransBcastXPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransBcastXPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXPort.setDescription('The MIB-II interface number of the port for which this entry\n              is administering broadcast conversion translation.')
ctTransBcastXMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransBcastXMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXMode.setDescription('This object indicates whether the ctTransBcastXMedia and \n              ctTransBcastXCanonical objects pair are valid for this \n              interface.')
ctTransBcastXMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransBcastXMedia.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXMedia.setDescription('This object is the media specific broadcast address that this \n              interface will allow translation to/from. This conversion only\n              acts upon the DA of the MAC header when the specified address \n              matches the DA.')
ctTransBcastXCanonical = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 5, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransBcastXCanonical.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransBcastXCanonical.setDescription('This object is the cannonical broadcast address that this \n              interface will allow translation to/from. This conversion only \n              acts upon the DA of the MAC header when the specified address \n              matches the DA.')
ctTransIbmLlcTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1), )
if mibBuilder.loadTexts: ctTransIbmLlcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcTable.setDescription('A list describing the state of the\n              IBM LLC translation for each interface on this device.')
ctTransIbmLlcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransIbmLlcPort"))
if mibBuilder.loadTexts: ctTransIbmLlcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcEntry.setDescription('A list of objects pertaining to the state of IBM LLC \n              translation for each interface.')
ctTransIbmLlcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransIbmLlcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcPort.setDescription('The MIB-II interface number of the port for which this entry\n              is administering IBM LLC translation.')
ctTransIbmLlcNullMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcNullMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcNullMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC\n              based protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of 00 (Null) and where the packet originated \n              on an ethernet network will have the IBM LLC protocol field of \n              five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcSnaPathMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcSnaPathMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcSnaPathMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of 04 (SNA path control) and where the packet \n              originated on an ethernet network will have the IBM LLC protocol \n              field of five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcSnaMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcSnaMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcSnaMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of 08 (SNA) and where the packet originated \n              on an ethernet network will have the IBM LLC protocol field of \n              five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcNbMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcNbMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcNbMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of F0 (NetBIOS) and where the packet originated \n              on an ethernet network will have the IBM LLC protocol field of \n              five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcLnmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcLnmMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcLnmMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of F4 (LAN Network Manager) and where the packet \n              originated on an ethernet network will have the IBM LLC protocol \n              field of five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcDscMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcDscMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcDscMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n              When enabled(1) all frames outbound on this token ring port and \n              with an LSAP value of FC (Discovery) will and where the packet \n              originated on an ethernet network will have the IBM LLC protocol \n              field of five bytes stripped from the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcOtherMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcOtherMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcOtherMode.setDescription("IBM networks systems have a special translation called 'IBM\n              LLC Encapsulation' which is used for translating IBM LLC based \n              protocols between Token Ring and Ethernet Version 2.0 (DIXE) \n              format. This translation does not apply when going between Token \n              Ring and 802.3, since LLC SAPs are maintained. This translation \n              allows connectivity between Token stations separated by an \n              Ethernet segment in an internetwork environment. An Ethernet \n              protocol type of 80 D5 is used to indicate IBM LLC protocol \n              encapsulation.\n\n              When enabled(1) all frames meeting the following criteria:\n                      - outbound on this token ring port \n                      - with an LSAP value matching that found in \n                        ctTransIbmLlcOtherValue\n                      - where the packet originated on an ethernet network \n              will have the IBM LLC protocol field of five bytes stripped from \n              the packet.\n\n              When disabled(2) the IBM LLC protocol field is untouched on these\n              packets.\n              \n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransIbmLlcOtherValue = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIbmLlcOtherValue.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIbmLlcOtherValue.setDescription("This object allows the user to select an IBM LLC LSAP value not \n              specified above. \n\n              When ctTransIbmLlcOtherMode is enabled all frames outbound on this \n              token ring port and providing a match between this value and the \n              outbound packet's LSAP value and where the packet originated on an \n              ethernet network will have the IBM LLC protocol field of five bytes \n              stripped from the packet.")
ctTransSrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1), )
if mibBuilder.loadTexts: ctTransSrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrTable.setDescription('A table of entries describing the source route\n              configuration managed objects.')
ctTransSrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransSrPort"))
if mibBuilder.loadTexts: ctTransSrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrEntry.setDescription('A list of objects to allow the configuration of source\n              route translation information.')
ctTransSrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransSrPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrPort.setDescription('The MIB-II interface number for which this entry\n              is administering source route configuration management.')
ctTransSrIfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("srt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrIfMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrIfMode.setDescription('This object indicates the types of frames (sr,tp or both)\n              supported by endstations attached to this interface.\n              This information is used by the device to determine\n              if sr/tp translation is required. Default is product specific.\n\n              If tp (1) is selected the RIF cacheing mechanism for this port\n              will be disabled. That is, the RIF cache database will be \n              emptied and no RIFs will be learned into the database or attached \n              to outbound packets for this port.\n\n              If sr (2) or srt (3) is selected for this object then the RIFs \n              will be learned into the database according to the rules defined \n              in the object ctTransRifDbWeightState and attached as necessary \n              to outbound packets.')
ctTransSrExpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notsupported", 1), ("are", 2), ("ste", 3), ("inboundtype", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrExpMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrExpMode.setDescription("This object selects the type of explorer frame the  SR or SRT\n              interface will use, if and when an explorer frame is required. \n              This object is only applicable when ctTransSrIfMode is set to\n              sr (2) or srt (3). The requirements will depend on the device\n              being managed.\n              \n              The inboundtype option (4) is supported only on those devices with\n              the ability to 'remember' the original state of the arriving \n              explorer packet. When set for this option the device will configure \n              all outbound explorer frames for whichever type of explorer \n              (ARE or STE) it arrived as.\n\n              The default value for this object is product specific. A write of\n              notsupported (1) will have no affect.")
ctTransSrIP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("auto", 3), ("notsupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrIP.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrIP.setDescription("This object determines how the sr/tp translation of IP frames \n              of type 'broadcast', 'destination unknown', or 'destination \n              known but IP not previously seen for this end station' should \n              be translated.  This object is only applicable for SRT interfaces.\n \n              If tp (1) is selected, the frame is forwarded out the\n              SRT interface as a transparent frame.\n \n              If sr (2) is selected, the frame is forwarded out\n              the srt interface as a source route frame. If this end station\n              has never been heard from before an explorer will be launched.\n              Which explorer frame (are or ste) is dependent on the object\n              ctTransSrExplorerMode defined above.\n \n              If auto (3) is selected, the frame is forwarded out the srt\n              interface as both a transparent frame and as a source route frame.\n\n              If not supported (4) is selected then the sr/tp translation of these\n              types of IP frames will be based on the configuration of the ctTransSrOther\n              managed object.\n \n              The default value is product specific.")
ctTransSrIPX = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("auto", 3), ("notsupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrIPX.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrIPX.setDescription('This object determines how the sr/tp translation of IPX frames \n              of type `broadcast`, `destination unknown`, or `destination \n              known but IPX not previously seen for this end station` should \n              be translated.  This object is only applicable for SRT interfaces.\n \n              If tp (1) is selected, the frame is forwarded out the\n              SRT interface as a transparent frame.\n \n              If sr (2) is selected, the frame is forwarded out\n              the SRT interface as a source route frame. If this end station\n              has never been heard from before an explorer will be launched.\n              Which explorer frame (are or ste) is dependent on the object\n              ctTransSrExplorerMode defined above.\n \n              If auto (3) is selected, the frame is forwarded out the SRT\n              interface as both a transparent frame and as a source route frame.\n\n              If not supported (4) is selected then the sr/tp translation of these\n              types of IPX frames will be based on the configuration of the ctTransSrOther\n              managed object.\n \n              The default value is product specific.')
ctTransSrNetBIOS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("auto", 3), ("notsupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrNetBIOS.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrNetBIOS.setDescription('This object determines how the sr/tp translation of NetBIOS frames \n              of type `broadcast`, `destination unknown`, or `destination \n              known but NetBIOS not previously seen for this end station` should \n              be translated.  This object is only applicable for SRT interfaces.\n \n              If tp (1) is selected, the frame is forwarded out the\n              SRT interface as a transparent frame.\n \n              If sr (2) is selected, the frame is forwarded out\n              the SRT interface as a source route frame. If this end station\n              has never been heard from before an explorer will be launched.\n              Which explorer frame (ARE or STE) is dependent on the object\n              ctTransSrExplorerMode defined above.\n \n              If auto (3) is selected, the frame is forwarded out the SRT\n              interface as both a transparent frame and as a source route frame.\n\n              If not supported (4) is selected then the sr/tp translation of these\n              types of NetBIOS frames will be based on the configuration of the ctTransSrOther\n              managed object.\n \n              The default value is product specific.')
ctTransSrSNA = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("auto", 3), ("notsupported", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrSNA.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrSNA.setDescription("This object determines how the sr/tp translation of SNA frames \n              of type 'broadcast', 'destination unknown', or 'destination \n              known but SNA not previously seen for this end station' should \n              be translated.  This object is only applicable for SRT interfaces.\n \n              If tp (1) is selected, the frame is forwarded out the\n              SRT interface as a transparent frame.\n \n              If sr (2) is selected, the frame is forwarded out\n              the SRT interface as a source route frame. If this end station\n              has never been heard from before an explorer will be launched.\n              Which explorer frame (ARE or STE) is dependent on the object\n              ctTransSrExplorerMode defined above.\n \n              If auto (3) is selected, the frame is forwarded out the SRT\n              interface as both a transparent frame and as a source route frame.\n\n              If not supported (4) is selected then the sr/tp translation of these\n              types of SNA frames will be based on the configuration of the ctTransSrOther\n              managed object.\n \n              The default value is product specific.")
ctTransSrOther = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tp", 1), ("sr", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrOther.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrOther.setDescription("This object determines how the sr/tp translation of all 'other  \n              protocols' is handled. 'other protocols' includes any protocol not \n              mentioned above (i.e. IP,IPX,NetBIOS, or SNA) or any of those \n              mentioned above with the 'not supported' option selected.\n\n              This object applies to any 'other protocol' frame of type \n              'broadcast', 'destination unknown', or 'destination known but \n              'other protocol' not previously seen for this end station'.\n              This object is only applicable for SRT interfaces.\n \n              If tp (1) is selected, the frame is forwarded out the\n              SRT interface as a transparent frame.\n \n              If sr (2) is selected, the frame is forwarded out\n              the SRT interface as a source route frame. If this end station\n              has never been heard from before an explorer will be launched.\n              Which explorer frame (ARE or STE) is dependent on the object\n              ctTransSrExplorerMode defined above.\n \n              If auto (3) is selected, the frame is forwarded out the SRT\n              interface as both a transparent frame and as a source route frame.\n \n              The default value is product specific.")
ctTransSRLocalSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSRLocalSegment.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSRLocalSegment.setDescription('The segment (ring) number that uniquely identifies the\n             segment to which this interface is connected. Current\n             source routing protocols limit this value to the\n             range: 0 through 4095. (The value 0 is used by\n             some management applications for special test\n             cases.)\n \n             A value of 65535 signifies that no segment number is\n             assigned for this interface. The default value is device\n             dependent.')
ctTransSrSRLF = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSrSRLF.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSrSRLF.setDescription('The maximum size of the INFO field (LLC and\n             above) that this interface can send/receive.  It does\n             not include any MAC level (framing) octets.  The\n             value of this object is used by this device to\n             determine whether a modification of the\n             LargestFrame (LF) field of the Routing\n             Control field of the Routing Information Field is\n             necessary.\n \n             64 valid values are defined by the IEEE 802.5M SRT\n             Addendum: 516, 635, 754, 873, 993, 1112, 1231,\n             1350, 1470, 1542, 1615, 1688, 1761, 1833, 1906,\n             1979, 2052, 2345, 2638, 2932, 3225, 3518, 3812,\n             4105, 4399, 4865, 5331, 5798, 6264, 6730, 7197,\n             7663, 8130, 8539, 8949, 9358, 9768, 10178, 10587,\n             10997, 11407, 12199, 12992, 13785, 14578, 15370,\n             16163, 16956, 17749, 20730, 23711, 26693, 29674,\n             32655, 35637, 38618, 41600, 44591, 47583, 50575,\n             53567, 56559, 59551, and 65535.')
ctTransSRAutoRingNumberDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notsupported", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransSRAutoRingNumberDetect.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransSRAutoRingNumberDetect.setDescription('This object enables an interface to automatically detect \n              the source route ring number of the attached ring segment.\n              When enabled, the interface wil automatically each time at\n              open, configure its ring number with the supplied ring \n              number from the RPS, if present on the ring. Otherwise,\n              a default value is used when the interface opens.')
ctTransNovellCfgTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8, 1), )
if mibBuilder.loadTexts: ctTransNovellCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransNovellCfgTable.setDescription('A list describing the enabled/disabled state of the\n              Novell translation for each interface on this device.')
ctTransNovellCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransNovellCfgPort"))
if mibBuilder.loadTexts: ctTransNovellCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransNovellCfgEntry.setDescription('A list of objects pertaining to the state of Novell\n              translation for each interface.')
ctTransNovellCfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransNovellCfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransNovellCfgPort.setDescription('The MIB-II interface number of the port for which this entry is\n              administering Novell configuration management.')
ctTransNovellCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("enabledType2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransNovellCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransNovellCfgMode.setDescription('Enable this object indicates whether the device will reverse the\n              bit ordering of addresses in the Novell header on Novell packets.\n              Enable Type 2 indicates the device will reverse the bit ordering\n              of addresses for token ring to fddi and no translation for token\n              ring to inb in the MAC layer. Disable will not bit reverse any \n              address.  \n\n              The default of this object is enabled.')
ctTransNovellGroupMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransNovellGroupMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransNovellGroupMode.setDescription('This object allows the conversion of group and multicast \n              addresses in the MAC DA of the IPX protocol format. Conversion\n              is as follows:\n              TR(C0 00 00 80 00 00) and Canonical (FF FF FF FF FF FF).\n              TR(C0 00 40 00 00 00) and Canonical (09 00 07 FF FF FF).\n              This object is only applicable if the state of ctTransNovellCfgMode \n              is enabled. \n\n              The default value for this object is product specific. A \n              write of notsupported (3) will have no affect.')
ctTransIPCfgTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1), )
if mibBuilder.loadTexts: ctTransIPCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPCfgTable.setDescription('A list describing the enabled/disabled state of the\n              IP translation for each interface on this device.')
ctTransIPCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransIPCfgPort"))
if mibBuilder.loadTexts: ctTransIPCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPCfgEntry.setDescription('A list of objects pertaining to the state of IP\n              translation for each interface.')
ctTransIPCfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransIPCfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPCfgPort.setDescription('The MIB-II interface number of the port for which this entry\n              is administering IP configuration management.')
ctTransIPDataCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIPDataCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPDataCfgMode.setDescription('This object indicates whether the device will reverse the bit\n              ordering of addresses in the information field of IP data packets\n              received and then transmitted on this interface.  \n \n              The default of this object is enabled.')
ctTransIPArpCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIPArpCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPArpCfgMode.setDescription('This object indicates whether the device will reverse the bit\n              ordering of addresses in the information field of ARP packets\n              received and then transmitted on this interface. \n\n              The default of this object is enabled.')
ctTransIPRarpCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransIPRarpCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransIPRarpCfgMode.setDescription('This object indicates whether the device will reverse the\n              bit ordering of addresses in the information field of RARP\n              packets received and then transmitted on this interface. \n\n              The default of this object is enabled.')
ctTransA2CfgTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1), )
if mibBuilder.loadTexts: ctTransA2CfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2CfgTable.setDescription('A list describing the enabled/disabled state of the\n              Appletalk2 translation for each interface on this device.')
ctTransA2CfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransA2CfgPort"))
if mibBuilder.loadTexts: ctTransA2CfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2CfgEntry.setDescription('A list of objects pertaining to the state of Appletalk2 \n              translation for each interface.')
ctTransA2CfgPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransA2CfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2CfgPort.setDescription('The MIB-II interface number of the port for which this entry is\n              administering Appletalk2 configuration management.')
ctTransA2DataCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransA2DataCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2DataCfgMode.setDescription('This object indicates whether the device will reverse the\n              bit ordering of addresses in the information field of Appletalk2 \n              data packets received and then transmitted on this interface.  \n\n              The default of this object is enabled.')
ctTransA2ArpCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransA2ArpCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2ArpCfgMode.setDescription('This object indicates whether the device will reverse the\n              bit ordering of addresses in the information field of ARP\n              packets received and then transmitted on this interface.  \n  \n              The default of this object is enabled.')
ctTransA2McastCfgMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransA2McastCfgMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransA2McastCfgMode.setDescription('This object indicates whether the device will reverse the\n              bit ordering of addresses in the information field of \n              broadcast/multicast packets received and then transmitted on this \n              interface.  \n  \n              The default of this object is enabled.')
ctTransOtherTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1), )
if mibBuilder.loadTexts: ctTransOtherTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherTable.setDescription('A list describing processing control for subgroups of LLC frames \n              by SAP or SNAP type. This table allows the user to single out \n              selected frame type groups for special handling by the processor \n              (purely intended as a future upgrade path to add protocols that \n              are currently not supported). This list only affects inbound frames \n              and is indexed on a per port basis.')
ctTransOtherEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransOtherPort"))
if mibBuilder.loadTexts: ctTransOtherEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherEntry.setDescription('A list of objects pertaining to the processing of subgroups\n              of LLC frames by SAP or SNAP type.')
ctTransOtherPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransOtherPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherPort.setDescription('The MIB-II interface number of the port for which this entry is\n              administering  control for subgroups of LLC frames by SAP or \n              SNAP type.')
ctTransOtherUnknownSap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherUnknownSap.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherUnknownSap.setDescription('This object indicates whether any frames with an unrecognized SAP\n              will require special translation handling by the processor. A \n              recognized SAP will be specified by the user in one of the \n              previous configuration groups. \n\n              The default of this object is product specific.')
ctTransOtherUnknownSnap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherUnknownSnap.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherUnknownSnap.setDescription('This object indicates whether frames with an unrecognized SNAP\n              will require special translation handling by the processor. A \n              recognized SNAP will be specified by the user in one of the \n              previous configuration groups. \n\n              The default of this object is product specific.')
ctTransOtherSapDsap1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap1Mode.setDescription('This object enables(1) or disables (2) the special translation \n              handling of a SAP frame with a DSAP equal to  \n              ctTransOtherSapDsap1Val.\n\n              The default of this object is product specific.')
ctTransOtherSapDsap1Val = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap1Val.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap1Val.setDescription('This object allows the user to specify a DSAP value that \n              when matched will require additional translation on frames.')
ctTransOtherSapDsap2Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap2Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap2Mode.setDescription('This object enables(1) or disables (2) the special translation \n              handling of a SAP frame with a DSAP equal to  \n              ctTransOtherSapDsap2Val.\n\n              The default of this object is product specific.')
ctTransOtherSapDsap2Val = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap2Val.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap2Val.setDescription('This object allows the user to specify a DSAP value that \n              when matched will require additional translation on frames.')
ctTransOtherSapDsap3Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap3Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap3Mode.setDescription('This object enables(1) or disables (2) the special translation \n              handling of a SAP frame with a DSAP equal to  \n              ctTransOtherSapDsap3Val.\n\n              The default of this object is product specific.')
ctTransOtherSapDsap3Val = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSapDsap3Val.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSapDsap3Val.setDescription('This object allows the user to specify a DSAP value that \n              when matched will require additional translation on frames.')
ctTransOtherSnap1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSnap1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSnap1Mode.setDescription('When enabled (1) this object the value in ctTransOtherSnap1Val \n              will be compared against the protocol values of all SNAP frames \n              received on this interface. A match indicates that the current \n              frame requires special translation handling.\n\n              The default of this object is product specific.')
ctTransOtherSnap1Val = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSnap1Val.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSnap1Val.setDescription('This object allows the user to specify a SNAP value to match \n              against inbound SNAP frames for translation handling.')
ctTransOtherSnap2Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSnap2Mode.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSnap2Mode.setDescription('When enabled (1) this object the value in ctTransOtherSnap2Val \n              will be compared against the protocol values of all SNAP frames \n              received on this interface. A match indicates that the current \n              frame requires special translation handling.\n\n              The default of this object is product specific.')
ctTransOtherSnap2Val = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 11, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransOtherSnap2Val.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransOtherSnap2Val.setDescription('This object allows the user to specify a SNAP value to match \n              against inbound SNAP frames for translation handling.')
ctTransLfpsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12, 1), )
if mibBuilder.loadTexts: ctTransLfpsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransLfpsTable.setDescription('This table is for the user to configure the large frame ports\n              ability to support large frames. The Large frame port support\n              is done on a per port basis. The operation affects outbound \n              frames only.')
ctTransLfpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12, 1, 1), ).setIndexNames((0, "CTRON-TRANSLATION-MIB", "ctTransLfpsPort"))
if mibBuilder.loadTexts: ctTransLfpsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransLfpsEntry.setDescription(' A list of objects that pertain to the large frame port\n               support table.')
ctTransLfpsPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransLfpsPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransLfpsPort.setDescription('The MIB-II interface number of the port for which this entry is\n              administering  control for subgroups of LLC frames by SAP or\n              SNAP type.')
ctTransLfpsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("large", 1), ("fragment-if-possible", 2), ("small", 3), ("auto", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctTransLfpsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransLfpsAdminStatus.setDescription('When large(1) is the setting all large frames are permissable \n              out that port. fragment_if_possible(2) is used when the outport \n              wants ip frames fragmented before transmission. All other non \n              fragmentable large frames will be transmitted large. small(3)\n              requires that no large frames be transmitted out this interface.\n              If a frame can be fragmented then it can be transmitted out the \n              interface. auto(4) is a special setting that will allow a device\n              to negotiate which of the other three settings to use as the \n              operational mode. \n\n              The default of this object is product specific.')
ctTransLfpsOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 4, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("large", 1), ("fragment-if-possible", 2), ("small", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctTransLfpsOperationalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctTransLfpsOperationalStatus.setDescription('This value represents the current operational mode of the\n              interface. The operational mode should reflect what is set in\n              the ctTransLfpsAdminStatus object. The only exception is when\n              the user sellects a platform mode that is unsupported and if \n              the ctTransLfpsAdminStatus object is set to auto. If the \n              ctTransLfpsAdminStatus object is set to auto then the negotiated\n              value will be reflected, which should be one of the above valid\n              possibilities.\n\n              The default of this object is product specific.')
mibBuilder.exportSymbols("CTRON-TRANSLATION-MIB", ctTransIPCfgTable=ctTransIPCfgTable, ctTransEthernetFddiPadVerify=ctTransEthernetFddiPadVerify, ctTransSr=ctTransSr, ctTransRifDbLength=ctTransRifDbLength, ctTransIbmLlcNullMode=ctTransIbmLlcNullMode, ctTransOtherSapDsap1Val=ctTransOtherSapDsap1Val, ctTransOtherUnknownSap=ctTransOtherUnknownSap, ctTransNovellCfgEntry=ctTransNovellCfgEntry, ctTransRifDbMacAddr=ctTransRifDbMacAddr, ctTransOtherSapDsap2Mode=ctTransOtherSapDsap2Mode, ctTransSRLocalSegment=ctTransSRLocalSegment, ctTransOtherPort=ctTransOtherPort, ctTransSRAutoRingNumberDetect=ctTransSRAutoRingNumberDetect, ctTransLfpsTable=ctTransLfpsTable, ctTransLfpsEntry=ctTransLfpsEntry, ctTransSrSRLF=ctTransSrSRLF, ctTransIbmLlcDscMode=ctTransIbmLlcDscMode, ctTransLfpsPort=ctTransLfpsPort, ctTransOtherSnap1Mode=ctTransOtherSnap1Mode, ctTransOtherSapDsap3Val=ctTransOtherSapDsap3Val, ctTransNovellCfg=ctTransNovellCfg, ctTransBcastXMedia=ctTransBcastXMedia, ctTransBcastXCanonical=ctTransBcastXCanonical, ctTransFddiEthernetIPFrag=ctTransFddiEthernetIPFrag, ctTransBcastXMode=ctTransBcastXMode, ctTransSrNetBIOS=ctTransSrNetBIOS, ctTransOtherTable=ctTransOtherTable, ctTransRifDbCtrlTable=ctTransRifDbCtrlTable, ctTransOtherSnap2Mode=ctTransOtherSnap2Mode, ctTransIbmLlcSnaMode=ctTransIbmLlcSnaMode, ctTransNovellCfgTable=ctTransNovellCfgTable, ctTransRifDbCtrlEntry=ctTransRifDbCtrlEntry, ctTransA2McastCfgMode=ctTransA2McastCfgMode, ctTransIbmLlcOtherMode=ctTransIbmLlcOtherMode, ctTransFddiAtm=ctTransFddiAtm, ctTransRifDbCtrlType=ctTransRifDbCtrlType, ctTransNovellGroupMode=ctTransNovellGroupMode, ctTransOtherSnap1Val=ctTransOtherSnap1Val, ctTransFddiAtmIPFrag=ctTransFddiAtmIPFrag, ctTransA2CfgEntry=ctTransA2CfgEntry, ctTransOtherSapDsap3Mode=ctTransOtherSapDsap3Mode, ctTransIPCfgEntry=ctTransIPCfgEntry, ctTransIPArpCfgMode=ctTransIPArpCfgMode, ctTransRifDbRIF=ctTransRifDbRIF, ctTransRifDbAgingTimer=ctTransRifDbAgingTimer, ctTransIbmLlcPort=ctTransIbmLlcPort, ctTransRifDbCtrlPort=ctTransRifDbCtrlPort, ctTransOtherUnknownSnap=ctTransOtherUnknownSnap, ctTransRifDbWeightState=ctTransRifDbWeightState, ctTransOtherSnap2Val=ctTransOtherSnap2Val, ctTransNovellCfgMode=ctTransNovellCfgMode, ctTransA2DataCfgMode=ctTransA2DataCfgMode, ctTransLfpsAdminStatus=ctTransLfpsAdminStatus, ctTransOtherCfg=ctTransOtherCfg, ctTransNovellCfgPort=ctTransNovellCfgPort, ctTransA2CfgPort=ctTransA2CfgPort, ctTransFddiEthernetAuto=ctTransFddiEthernetAuto, ctTransIbmLlcNbMode=ctTransIbmLlcNbMode, ctTransBcastXTable=ctTransBcastXTable, ctTransFddiEthernetSnapIPX=ctTransFddiEthernetSnapIPX, ctTransFddiEthernet802dot2IPX=ctTransFddiEthernet802dot2IPX, ctTransSrSNA=ctTransSrSNA, ctTransFddiSnapEthernetType=ctTransFddiSnapEthernetType, ctTransSrOther=ctTransSrOther, ctTransIbmLlcOtherValue=ctTransIbmLlcOtherValue, ctTransBcastXEntry=ctTransBcastXEntry, ctTransSrExpMode=ctTransSrExpMode, ctTransLfpsOperationalStatus=ctTransLfpsOperationalStatus, ctTransSrPort=ctTransSrPort, ctTransFddiAtmMtu=ctTransFddiAtmMtu, ctTransRifDb=ctTransRifDb, ctTransOtherSapDsap1Mode=ctTransOtherSapDsap1Mode, ctTransIPDataCfgMode=ctTransIPDataCfgMode, ctTransEthernetFddi=ctTransEthernetFddi, ctTransOtherEntry=ctTransOtherEntry, ctTransFddiEthernet=ctTransFddiEthernet, ctTransIbmLlcTable=ctTransIbmLlcTable, ctTransIbmLlc=ctTransIbmLlc, ctTransBcastXPort=ctTransBcastXPort, ctTransSrEntry=ctTransSrEntry, ctTransRifDbSrcPort=ctTransRifDbSrcPort, ctTransA2ArpCfgMode=ctTransA2ArpCfgMode, ctTranslfpsCfg=ctTranslfpsCfg, ctTransIbmLlcEntry=ctTransIbmLlcEntry, ctTransIbmLlcSnaPathMode=ctTransIbmLlcSnaPathMode, ctTransOtherSapDsap2Val=ctTransOtherSapDsap2Val, ctTransEthernetFddiRAW=ctTransEthernetFddiRAW, ctTransIPCfg=ctTransIPCfg, ctTransSrIP=ctTransSrIP, ctTransIPCfgPort=ctTransIPCfgPort, ctTransSrIfMode=ctTransSrIfMode, ctTransRifDbEntry=ctTransRifDbEntry, ctTransIPRarpCfgMode=ctTransIPRarpCfgMode, ctTransSrTable=ctTransSrTable, ctTransA2Cfg=ctTransA2Cfg, ctTransIbmLlcLnmMode=ctTransIbmLlcLnmMode, ctTransFddiEthernetMACIPX=ctTransFddiEthernetMACIPX, ctTransA2CfgTable=ctTransA2CfgTable, ctTransBcastX=ctTransBcastX, ctTransRifDbTable=ctTransRifDbTable, ctTransSrIPX=ctTransSrIPX)
