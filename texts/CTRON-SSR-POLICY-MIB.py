#
# PySNMP MIB module CTRON-SSR-POLICY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-SSR-POLICY-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 08:05:50 2024
# On host fv-az1110-484 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
ssrMibs, = mibBuilder.importSymbols("CTRON-SSR-SMI-MIB", "ssrMibs")
dot1qVlanStaticEntry, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "dot1qVlanStaticEntry")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32, Gauge32, iso, Bits, ModuleIdentity, MibIdentifier, Integer32, Unsigned32, Counter64, TimeTicks, IpAddress, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32", "Gauge32", "iso", "Bits", "ModuleIdentity", "MibIdentifier", "Integer32", "Unsigned32", "Counter64", "TimeTicks", "IpAddress", "ObjectIdentity")
TruthValue, MacAddress, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "MacAddress", "DisplayString", "TextualConvention", "RowStatus")
policyMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210))
policyMIB.setRevisions(('2003-12-19 17:12', '2003-07-21 15:01', '2000-07-15 00:00', '1999-08-11 00:00', '1999-07-21 00:00', '1998-08-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: policyMIB.setRevisionsDescriptions(('Defined bit 0 of polL2Dot1qVlanStaticProtocols as reserved.', 'Revision #5. Add static VLAN protocol filtering to the polL2Group.\n          Update contact information.', 'Revision #4. Update contact information.', 'Revision #3. Define Policy Based Routing in polL4Group.', 'Revision #2. Define Layer 2 flow security objects in polL2Group.', 'Revision #1. Define Layer 3 flow objects in polL3Group.',))
if mibBuilder.loadTexts: policyMIB.setLastUpdated('200312191712Z')
if mibBuilder.loadTexts: policyMIB.setOrganization('Enterasys Networks, Inc')
if mibBuilder.loadTexts: policyMIB.setContactInfo('Postal:  Enterasys Networks\n                  50 Minuteman Rd.\n                  Andover, MA 01810-1008\n                  USA\n         Phone:   +1 978 684 1000\n         E-mail:  support@enterasys.com\n         WWW:     http://www.enterasys.com')
if mibBuilder.loadTexts: policyMIB.setDescription('This module defines a schema to control filters on a device capable\n      of Layer 3 filters also called Access Control Lists (ACLs) and at\n      layer 2. It may also be used to configure static IP routes that use\n      other IP header fields in addition to destination IP address.')
class InterfaceIndex(TextualConvention, Integer32):
    description = "A unique value, greater than zero, for each interface\n               or interface sub-layer in the managed system.  It is\n               recommended that values are assigned contiguously\n               starting from 1.  The value for each interface sub-\n               layer must remain constant at least from one re-\n               initialization of the entity's network management\n               system to the next re-initialization."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class InterfaceIndexOrZero(TextualConvention, Integer32):
    description = 'This textual convention is an extension of the\n               InterfaceIndex convention.  The latter defines a\n               greater than zero value used to identify an interface\n               or interface sub-layer in the managed system.  This\n               extension permits the additional value of zero.  the\n               value zero is object-specific and must therefore be\n               defined as part of the description of any object which\n               uses this syntax.  Examples of the usage of zero might\n               include situations where interface was unknown, or\n               when none or all interfaces need to be referenced.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class SSRPortComparator(TextualConvention, Integer32):
    description = "Comparison operator used by ACL's to permit src/dst port addresses."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("notused", 1), ("eq", 2), ("neq", 3), ("lt", 4), ("gt", 5), ("range", 6))

class SSRProtocol(TextualConvention, Integer32):
    description = 'Protocols supported by L3 ACLs.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("ip", 1), ("tcp", 2), ("udp", 3), ("icmp", 4), ("igmp", 5), ("ipx", 6), ("ipxsap", 7), ("ipxrip", 8))

class SSRsocketId(TextualConvention, Integer32):
    description = 'A TCP or UDP port or socket end point.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class SSRVlanIndex(TextualConvention, Integer32):
    description = 'An 802.1Q VLAN Identifier with same semantics as Q-BRIDGE-MIB VlanId.\n         SSR uses Vid 1 for the default VLAN. All ports by default belong to this VLAN\n         unless assigned to one or more user defined VLANs. A value of 4100 is used to match\n         all VLANs. 4094 to 4099 are reserved local VLAN ids on the SSR.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4100)

class SSRPortList(TextualConvention, OctetString):
    description = 'List of ifIndexes that make up the ports to apply a layer 2 filter to.\n          The ifIndexes are numbered sparsely starting from 1. An example string\n          might be: \n                1,2,32 \n                1,6,9,\n          Each ifIndex must represent a physical port or link aggregation aka Smart \n          Trunk ifType of propMultiplexor(54). Note ifIndexes may change across \n          system resets per RFC 2233.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class SSRFlowPolicyType(TextualConvention, Integer32):
    description = 'Type of Flow Policy. permitFlow allows matching traffic to be forwarded. denyFlow\n         causes matching traffic to be discarded.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("permitFlow", 1), ("denyFlow", 2))

class SSRFlowPolicyAction(TextualConvention, Integer32):
    description = 'When deciding when to apply policy there are three potential methods. \n         policyBeforeRouteLookup provides a way to special case normal traffic patterns \n         so that certain traffic can be routed according to policy. \n         policyAfterRouteLookup is useful when a default route does not exist and the traffic\n         to route does not match existing route tables. \n         useOnlyPolicyLookup bypasses normal route lookup altogether.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("policyBeforeRouteLookup", 1), ("policyAfterRouteLookup", 2), ("useOnlyPolicyLookup", 3))

class SSRFlowPolicyAclList(TextualConvention, OctetString):
    description = 'A blank separated list of ACL names used to match flows against from the polAclTable.\n         The keyword, everything, may be used to match all traffic. ASCII printable characters only'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 4096)

class SSRFlowNextHopList(TextualConvention, OctetString):
    description = 'A blank separated list of from one to four l4fNextHopRouter ipaddresses or\n         the keyword null. Null represents the null interface'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 4096)

class SSRFlowLoadPolicy(TextualConvention, Integer32):
    description = 'round robin evenly distributes flows among the next hops. firstAvailable \n          will make flows go to the first available next hop in the ordered list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3))
    namedValues = NamedValues(("firstAvailable", 2), ("roundRobin", 3))

polL3Group = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12))
polAclServer = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclServer.setStatus('current')
if mibBuilder.loadTexts: polAclServer.setDescription('This is true when Access Control Lists (ACLs) are defined by a \n         Policy Server else false.\n\t At boot, this value is false. After the first valid set of any \n         policy object, the value changes to true.')
polAclNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclNumber.setStatus('current')
if mibBuilder.loadTexts: polAclNumber.setDescription('The number of Layer 3 Access Control Lists defined in the SSR.')
polAclLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclLastChanged.setStatus('current')
if mibBuilder.loadTexts: polAclLastChanged.setDescription('The time the Access Control List were last changed.')
polAclTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4), )
if mibBuilder.loadTexts: polAclTable.setStatus('current')
if mibBuilder.loadTexts: polAclTable.setDescription('A list of Access Control List entries.')
polAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polAclName"), (0, "CTRON-SSR-POLICY-MIB", "polAclItem"))
if mibBuilder.loadTexts: polAclEntry.setStatus('current')
if mibBuilder.loadTexts: polAclEntry.setDescription('A record containing a Access Control List.')
polAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclName.setStatus('current')
if mibBuilder.loadTexts: polAclName.setDescription('The administratively assigned name to this static route entry.')
polAclItem = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclItem.setStatus('current')
if mibBuilder.loadTexts: polAclItem.setDescription("This row's unique identifier within a given ACL set. Member of the ACL set \n                are numbered from 1 to 256. If Item is set to 0, and rowStatus is destroy, \n                all rows for this set are destroyed.")
polAclRestriction = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclRestriction.setStatus('current')
if mibBuilder.loadTexts: polAclRestriction.setDescription('The permissions/restrictions given to this static route entry.')
polAclProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 4), SSRProtocol()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclProtocol.setStatus('current')
if mibBuilder.loadTexts: polAclProtocol.setDescription('The IETF protocol this ACL applies to.')
polAclSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclSrcIp.setStatus('current')
if mibBuilder.loadTexts: polAclSrcIp.setDescription('The source L3 IP Address this ACL applies to.')
polAclSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclSrcMask.setStatus('current')
if mibBuilder.loadTexts: polAclSrcMask.setDescription('The source L3 IP Mask this ACL Applies to.')
polAclDstIp = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclDstIp.setStatus('current')
if mibBuilder.loadTexts: polAclDstIp.setDescription('The source L3 IP Address this ACL applies to.')
polAclDstMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclDstMask.setStatus('current')
if mibBuilder.loadTexts: polAclDstMask.setDescription('The source L3 IP Mask this ACL Applies to.')
polAclTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclTOS.setStatus('current')
if mibBuilder.loadTexts: polAclTOS.setDescription('The source L3 IP Type of Service field.')
polAclSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 10), SSRsocketId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclSrcPort.setStatus('current')
if mibBuilder.loadTexts: polAclSrcPort.setDescription('The source L3 IP source port/socket ACL applies to.')
polAclDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 11), SSRsocketId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclDstPort.setStatus('current')
if mibBuilder.loadTexts: polAclDstPort.setDescription('The source L3 IP destination port/socket ACL applies to.')
polAclSrcOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 12), SSRPortComparator().clone('eq')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclSrcOperator.setStatus('current')
if mibBuilder.loadTexts: polAclSrcOperator.setDescription('polAclSrcPort is compared using this operator.')
polAclDstOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 13), SSRPortComparator().clone('eq')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclDstOperator.setStatus('current')
if mibBuilder.loadTexts: polAclDstOperator.setDescription('polAclDstPort is compared using this operator.')
polAclSrcHighRange = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclSrcHighRange.setStatus('current')
if mibBuilder.loadTexts: polAclSrcHighRange.setDescription('The high range source L3 IP port. Used\n                only when SrcOperator == range. polAclSrcPort is\n                used as the lower bounds of the range.')
polAclDstHighRange = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclDstHighRange.setStatus('current')
if mibBuilder.loadTexts: polAclDstHighRange.setDescription('The high range destination L3 IP port. Used\n                only when SrcOperator == range. polAclDstPort is \n                used as the lower bounds of the range.')
polAclAuditTrail = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclAuditTrail.setStatus('current')
if mibBuilder.loadTexts: polAclAuditTrail.setDescription('Flows matching this ACL are logged for Accounting when true.')
polAclCheckpoint = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("hourly", 1), ("daily", 2), ("weekly", 3), ("monthly", 4), ("endofcall", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclCheckpoint.setStatus('current')
if mibBuilder.loadTexts: polAclCheckpoint.setDescription('How long to keep flow at which point a checkpoint should be done.\n         A checkpoint may trigger earlier than this time should the maximum\n         batch size be reached.')
polAclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 4, 1, 18), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclRowStatus.setStatus('current')
if mibBuilder.loadTexts: polAclRowStatus.setDescription('SNMP V2 RowStatus control for this table.')
polAclServiceNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclServiceNumber.setStatus('current')
if mibBuilder.loadTexts: polAclServiceNumber.setDescription('The number of Layer 3 Access Control Lists in service in the SSR.')
polAclServiceLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclServiceLastChanged.setStatus('current')
if mibBuilder.loadTexts: polAclServiceLastChanged.setDescription('The time the ACLs in service were last changed.')
polAclServiceTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7), )
if mibBuilder.loadTexts: polAclServiceTable.setStatus('current')
if mibBuilder.loadTexts: polAclServiceTable.setDescription("A list of ACL's currently in service.")
polAclServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polAclServiceIfIndex"), (0, "CTRON-SSR-POLICY-MIB", "polAclName2"))
if mibBuilder.loadTexts: polAclServiceEntry.setStatus('current')
if mibBuilder.loadTexts: polAclServiceEntry.setDescription('A record containing a Access Control Lists applied to Interfaces.')
polAclServiceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclServiceIfIndex.setStatus('current')
if mibBuilder.loadTexts: polAclServiceIfIndex.setDescription('The ifIndex of the IP Interface the ACL is applied to. \n         An SSR IP Interface has ifType 142')
polAclName2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclName2.setStatus('current')
if mibBuilder.loadTexts: polAclName2.setDescription('The name of the ACL applied to the particular port.')
polAclServiceDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclServiceDirection.setStatus('current')
if mibBuilder.loadTexts: polAclServiceDirection.setDescription('The direction the ACL is applied to the particular port.')
polAclServiceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 7, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polAclServiceRowStatus.setStatus('current')
if mibBuilder.loadTexts: polAclServiceRowStatus.setDescription('SNMP V2 RowStatus control for this table.')
polAclRemoteAllowed = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclRemoteAllowed.setStatus('current')
if mibBuilder.loadTexts: polAclRemoteAllowed.setDescription('Remote Policy Configuration is allowed when true only \n         local (to SSR) policy may be applied.')
polAclInterfaceNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclInterfaceNumber.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceNumber.setDescription('The number of Layer 3 Interfaces in service in the SSR.')
polAclInterfaceLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclInterfaceLastChanged.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceLastChanged.setDescription('The time the Interfaces in service were last changed with regard to policy.')
polAclInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 12), )
if mibBuilder.loadTexts: polAclInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceTable.setDescription('A list of IP Interfaces in service and their policy status. Each IP Interface can be\n         defined to use local static policy or remote dynamic policy in the config.')
polAclInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 12, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polAclInterfaceIfIndex"), (0, "CTRON-SSR-POLICY-MIB", "polAclInterfaceDirection"))
if mibBuilder.loadTexts: polAclInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceEntry.setDescription('A record containing a Access Control Lists applied to Interfaces.')
polAclInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 12, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceIfIndex.setDescription('The ifIndex of the IP Interface the ACL is applied to.')
polAclInterfaceDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclInterfaceDirection.setStatus('current')
if mibBuilder.loadTexts: polAclInterfaceDirection.setDescription('The direction the ACL is applied to the particular port.')
polAclPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 12, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polAclPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: polAclPolicyStatus.setDescription('Rules for what type of management can apply ACLs to a particular interface. If set to remote,\n         then a Policy Manager via SNMP may change dynamically the ACLs applied to an interface. Note,\n         ACLs applied dynamically are not maintained across system reboot. Use local ACLs to setup the basic\n         rules then apply dynamic rules as necessary.')
polL2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16))
polL2FilterNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL2FilterNumber.setStatus('current')
if mibBuilder.loadTexts: polL2FilterNumber.setDescription('The number of Layer 3 Access Control Lists defined in the SSR.')
polL2FilterLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL2FilterLastChanged.setStatus('current')
if mibBuilder.loadTexts: polL2FilterLastChanged.setDescription('The time the Access Control List were last changed.')
polL2FilterTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3), )
if mibBuilder.loadTexts: polL2FilterTable.setStatus('current')
if mibBuilder.loadTexts: polL2FilterTable.setDescription('A list of Layer 2 filters.')
polL2FilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polL2FilterIndex"))
if mibBuilder.loadTexts: polL2FilterEntry.setStatus('current')
if mibBuilder.loadTexts: polL2FilterEntry.setDescription('An entry containing a layer 2 filter.')
polL2FilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: polL2FilterIndex.setStatus('current')
if mibBuilder.loadTexts: polL2FilterIndex.setDescription('A unique index into the table representing a single filter entry. This value \n          will remain unique and the relationship between the index and the underlying filter\n          is valid until the next reboot.')
polL2FilterDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterDesc.setStatus('current')
if mibBuilder.loadTexts: polL2FilterDesc.setDescription('A string used to describe the filter. It should contain\n          the creator IP address, and other descriptive information about the filter.\n          It is recommended that names be unique within a given filter type.\n          This object may not be modified if the associated.\n          polL2FilterStatus object is equal to active(1).')
polL2FilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("staticEntry", 1), ("addressFilter", 2), ("portAddressLock", 3), ("securePort", 4))).clone('staticEntry')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterType.setStatus('current')
if mibBuilder.loadTexts: polL2FilterType.setDescription('The types of filters, as explained below.\n\n           static-entry\n \n               Based on the restrictions and the presence of\n               source, destination MAC address they can be of \n               three types :\n\n               source-static-entry - All frames with a source\n               address equal to srcMAC, coming through any of \n               the inPorts will be allowed/disallowed to go \n               to any port that is a member of the outPorts\n               list.\n\n               destination-static-entry - All frames with a \n               destination address equal to dstMAC, coming \n               through any of the inPorts  will be allowed/\n               disallowed/forced to go to any port that is a \n               member of the outPorts list.\n\n               flow-static-entry - All frames with a source\n               address equal to srcMAC and a destination address\n               equal to dstMAC, coming through any of the inPorts \n               list will be allowed/disallowed to go to any port \n               that is a member of the outPorts list. Ports\n               must be in flow-bridging mode in order to use\n               filters with both src and dst mac specified.               \n\n           address-filter\n \n               Based on the restrictions and the presence of\n               source, destination MAC address they can be of \n               three types :\n\n               source-address-filter - All frames with a source\n               address equal to srcMAC, coming through any of \n               the inPorts will be filtered out.\n\n               destination-address-filter - All frames with a \n               destination address equal to dstMAC, coming through \n               any of the inPorts will be filtered out.\n\n               flow-filter - All frames with a source address equal \n               to srcMAC and a destination address equal to dstMAC, \n               coming through any of the inPorts list will be \n               filtered out. Ports must be in flow mode in order\n               to set a filter using both source and destination \n               address.\n\n           port-address-lock\n\n               This locks a source address to a port. It allows \n               learning of srcMAC addresses only on any of the ports\n               in inPorts. The following objects are mandatory\n               and must be set by mgmt station to activate a row:\n               polL2FilterDesc, polL2FilterSrcMacAddr, polL2FilterInPorts\n\n           secure-port\n\n               This blocks all traffic in a given direction to a port.\n               Used with static entries, it is effective in allowing only\n               certain well defined source/destination mac addresses.\n               The following objects must be set by mgmt station to\n               activate an entry:\n               polL2FilterDesc, r, polL2FilterInPorts\n\n          This object may not be modified if the associated.\n          polL2FilterStatus object is equal to active(1).')
polL2FilterRestrictions = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("allow", 1), ("disallow", 2), ("force", 3), ("none", 4), ("blockIngress", 5), ("blockEgress", 6))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterRestrictions.setStatus('current')
if mibBuilder.loadTexts: polL2FilterRestrictions.setDescription('The first 3 restrictions, allow, disallow, force apply when the filterType \n          is static-entry. When polL2FilterType is addressFilter or portAddressLock,\n          this object does not apply. For securePort, the blockIngress, blockEgress\n          values apply.\n          This object may not be modified if the associated.\n          polL2FilterStatus object is equal to active(1).')
polL2FilterSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 5), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: polL2FilterSrcMacAddr.setDescription('The source MAC address, which is present in case\n                of a Flow, that has been learned by the switch.')
polL2FilterDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 6), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterDstMacAddr.setStatus('current')
if mibBuilder.loadTexts: polL2FilterDstMacAddr.setDescription('The destination MAC address which has been learned.\n\n          This object may not be modified if the associated.\n          polL2FilterStatus object is equal to active(1).')
polL2FilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 7), SSRVlanIndex().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterVlanId.setStatus('current')
if mibBuilder.loadTexts: polL2FilterVlanId.setDescription('The VLAN the destination MAC address belongs to. The default VLAN \n        is id 1 on SSR.\n\n        This object may not be modified if the associated.\n        polL2FilterStatus object is equal to active(1).')
polL2FilterInPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 8), SSRPortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterInPorts.setStatus('current')
if mibBuilder.loadTexts: polL2FilterInPorts.setDescription('The set of Ports to which this filter applies on input.\n\n        This object may not be modified if the associated.\n        polL2FilterStatus object is equal to active(1).')
polL2FilterOutPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 9), SSRPortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterOutPorts.setStatus('current')
if mibBuilder.loadTexts: polL2FilterOutPorts.setDescription('The set of ports to which this filter applies on output.\n\n        This object may not be modified if the associated.\n        polL2FilterStatus object is equal to active(1).')
polL2FilterCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL2FilterCreationTime.setStatus('current')
if mibBuilder.loadTexts: polL2FilterCreationTime.setDescription('The value of sysUpTime when this filter was made active(1).')
polL2FilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 3, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2FilterStatus.setStatus('current')
if mibBuilder.loadTexts: polL2FilterStatus.setDescription('SMIv2 RowStatus control for this table. Use createAndWait or createAndGo\n         to create a filter, use destroy to remove an entry or notInService to \n         disengage a filter without destroying it. A row in the notReady state has\n         not had all the mandatory objects set.')
polL2Dot1qVlanStaticTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 4), )
if mibBuilder.loadTexts: polL2Dot1qVlanStaticTable.setStatus('current')
if mibBuilder.loadTexts: polL2Dot1qVlanStaticTable.setDescription('A table containing hardware specific VLAN behavior configuration\n        information for VLANs created with the dot1qVlanStaticTable.\n        Configuration information for each VLAN configured into the device by (local or\n        network) management.')
polL2Dot1qVlanStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 4, 1), )
dot1qVlanStaticEntry.registerAugmentions(("CTRON-SSR-POLICY-MIB", "polL2Dot1qVlanStaticEntry"))
polL2Dot1qVlanStaticEntry.setIndexNames(*dot1qVlanStaticEntry.getIndexNames())
if mibBuilder.loadTexts: polL2Dot1qVlanStaticEntry.setStatus('current')
if mibBuilder.loadTexts: polL2Dot1qVlanStaticEntry.setDescription('An entry containing additional hardware\n        specific objects for a dot1qVlanStaticEntry.')
polL2Dot1qVlanStaticProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 4, 1, 1), Bits().clone(namedValues=NamedValues(("reserved", 0), ("bridged-protocols", 1), ("ip", 2), ("ipx", 3), ("appletalk", 4), ("dec", 5), ("sna", 6), ("ipv6", 7))).clone(namedValues=NamedValues(("ip", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2Dot1qVlanStaticProtocols.setStatus('current')
if mibBuilder.loadTexts: polL2Dot1qVlanStaticProtocols.setDescription('Specifies the types of traffic that will be forwarded on this VLAN.  \n         Protocols not set in this definition will be filtered. The types of protocols\n         supported on this VLAN corresponds to the type option in the CLI command \n         vlan create <vlan name> <type>. If no protocols are specified, all\n         protocols are forwarded. This corresponds to the port-based CLI\n         option.\n           reserved(0) - this bit is reserved and has no defined behavior.\n           bridged-protocols(1) - this VLAN supports all bridged protocols\n           excluding IP and IPX. Includes appletalk(4), dec(5), sna(6), and\n           ipv6(7) if none of these protocols are set. If any are set, only\n           those that are set are included.\n           ip(2) - this VLAN supports IP protocol.\n           ipx(3) - this VLAN supports IPX protocol.\n           appletalk(4) - this VLAN supports Appletalk protocol.\n           dec(5) - this VLAN supports DEC protocol.\n           sna(6) - this VLAN supports SNA protocol.\n           ipv6(7) - this VLAN supports IPv6 protocol.')
polL2Dot1qVlanStaticL4Bridging = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 16, 4, 1, 2), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL2Dot1qVlanStaticL4Bridging.setStatus('current')
if mibBuilder.loadTexts: polL2Dot1qVlanStaticL4Bridging.setDescription('If this object has a value of false(2), the L4 Bridging feature is not\n         enabled on this VLAN. If this object has a value of true(1), the L4 Bridging \n         feature is enabled for this VLAN. This corresponds to the CLI command\n         vlan enable l4-bridging.')
polL4Group = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15))
polL4PolicyBasedRoutingEnabled = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4PolicyBasedRoutingEnabled.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyBasedRoutingEnabled.setDescription('The state of Policy Based Routing on this network element.')
polL4NumRouters = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NumRouters.setStatus('current')
if mibBuilder.loadTexts: polL4NumRouters.setDescription('The number of next hop routers currently available.')
polL4NextHopTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopTableLastChange.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopTableLastChange.setDescription('The value of sysUpTime when a row was last added \n         or deleted from polL4NextHopTable.')
polL4NextHopTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20), )
if mibBuilder.loadTexts: polL4NextHopTable.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopTable.setDescription('A list of next hop IP routers.')
polL4NextHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polL4NextHopRouter"))
if mibBuilder.loadTexts: polL4NextHopEntry.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopEntry.setDescription('An entry contains the status of a next hop router.')
polL4NextHopRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopRouter.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopRouter.setDescription('The IP Address of the next hop router flow will be sent to.')
polL4NextHopState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("waitingForArp", 2), ("macAcquired", 3), ("noArpReply", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopState.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopState.setDescription('The current status of the polL4NextHopRouter. \n          If no entry found when a policy route is activated, \n          then arp for the request the state will be waitingForArp(2). \n          If a reply is found the state will go to macAcquired(3) \n          else noArpReply(4). If NextHop is not local, mac is actual\n          nexthop router.')
polL4NextHopPortOfExit = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopPortOfExit.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopPortOfExit.setDescription('IfIndex of port we learned this router on or else zero if not known.')
polL4NextHopMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopMacAddress.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopMacAddress.setDescription('MAC Address of next hop router learned from ARP.')
polL4NextHopLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 20, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NextHopLastChange.setStatus('current')
if mibBuilder.loadTexts: polL4NextHopLastChange.setDescription('The value of sysUpTime when this polL4NextHopState changed.')
polL4lowControlTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 25), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowControlTableLastChange.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlTableLastChange.setDescription('The value of sysUpTime when a row was last added or deleted from polL4lowControlTable.')
polL4NumPolicies = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4NumPolicies.setStatus('current')
if mibBuilder.loadTexts: polL4NumPolicies.setDescription('The number of policies currently available.')
polL4lowControlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30), )
if mibBuilder.loadTexts: polL4lowControlTable.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlTable.setDescription('Contains Control rows that indicate which flows have been redirected. As flows\n                are aged out and recreated, these rules will enforce flow redirection policy.')
polL4lowControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1), ).setIndexNames((0, "CTRON-SSR-POLICY-MIB", "polL4PolicyName"), (0, "CTRON-SSR-POLICY-MIB", "polL4PolicySequence"), (0, "CTRON-SSR-POLICY-MIB", "polL4PolicyInstance"))
if mibBuilder.loadTexts: polL4lowControlEntry.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlEntry.setDescription('This table is an ordered collection of route policies. For SSR, this maps\n                to the command: ip-policy Name [permit|deny] acl acl-list')
polL4PolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 1), DisplayString())
if mibBuilder.loadTexts: polL4PolicyName.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyName.setDescription('A unique name for this flow policy.')
polL4PolicySequence = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: polL4PolicySequence.setStatus('current')
if mibBuilder.loadTexts: polL4PolicySequence.setDescription('The evaluation order of this object. When two objects have the same value,\n            the value of the instance value decides which is evaluated first.\n            than higher numbers.')
polL4PolicyInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: polL4PolicyInstance.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyInstance.setDescription('The sequence of this policy based route. Lower numbers have higher precedence \n            than higher numbers.')
polL4PolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 4), SSRFlowPolicyType().clone('permitFlow')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyType.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyType.setDescription('Controls if packets are forwarded or not for this policy.')
polL4PolicyAction = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 5), SSRFlowPolicyAction().clone('policyBeforeRouteLookup')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyAction.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyAction.setDescription('Define when this policy should be used during normal packet forwarding process.')
polL4PolicyMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 6), SSRFlowPolicyAclList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyMatch.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyMatch.setDescription('Up to twenty (20) separate ACLs may be defined to match for this policy.\n           This object is mandatory. Use active row from polAclTable.')
polL4PolicyNextHops = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 7), SSRFlowNextHopList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyNextHops.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyNextHops.setDescription('Up to for IpAddresses may be specified to route data to next. Load balancing\n           If more than one next hop ip address is specified, the default load balancing\n           scheme is round robin. This object is mandatory. Use objects from polL4NextHopTable.')
polL4PolicyLoading = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 8), SSRFlowLoadPolicy().clone('firstAvailable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyLoading.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyLoading.setDescription('When more than one next hop is defined and available, set loading policy here.')
polL4PolicyWatch = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4PolicyWatch.setStatus('current')
if mibBuilder.loadTexts: polL4PolicyWatch.setDescription('When True, use icmp echo to actively maintain status of next hop. This \n           is useful to prevent data sinks with static routes.')
polL4lowCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowCreationTime.setStatus('current')
if mibBuilder.loadTexts: polL4lowCreationTime.setDescription('The value of sysUpTime when policy went was created then activated.')
polL4lowActiveGates = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowActiveGates.setStatus('current')
if mibBuilder.loadTexts: polL4lowActiveGates.setDescription('The number of currently active nexthop gateways.')
polL4lowAppliedTimes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowAppliedTimes.setStatus('current')
if mibBuilder.loadTexts: polL4lowAppliedTimes.setDescription('The number of times this policy was used.')
polL4lowControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 30, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: polL4lowControlStatus.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlStatus.setDescription('Entries in active state cause a flow to remain programmed with the next hop router specified.\n\t If the next hop router goes down, the rowStatus will become inactive. New flows that match this\n         specification will assume this next hop router over any other route directive. \n         This assumes polL4PolicyBasedRouteState value is true.')
polL4GroupStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35))
polL4lowLostRouters = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowLostRouters.setStatus('current')
if mibBuilder.loadTexts: polL4lowLostRouters.setDescription('The count of times routers were disabled from NextHopTable due to lost contact.')
polL4lowControlTableActivates = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowControlTableActivates.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlTableActivates.setDescription('The count of successful activations of flow control policies made.')
polL4lowControlTableActivateFails = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowControlTableActivateFails.setStatus('current')
if mibBuilder.loadTexts: polL4lowControlTableActivateFails.setDescription('The count of unsuccessful flow control policies made.')
polL4lowArpMappingChanges = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowArpMappingChanges.setStatus('current')
if mibBuilder.loadTexts: polL4lowArpMappingChanges.setDescription('The count of mac to next hop IP address mapping changes\n           affecting policy based route tables.')
polL4lowIcmpRedirects = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowIcmpRedirects.setStatus('current')
if mibBuilder.loadTexts: polL4lowIcmpRedirects.setDescription('The count of next hop route redirects received that\n            match a policy in the polL4lowControlTable.\n           This can help to determine if bad route policies are in effect.')
polL4lowMatchAttempts = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 15, 35, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: polL4lowMatchAttempts.setStatus('current')
if mibBuilder.loadTexts: polL4lowMatchAttempts.setDescription('The count of total number of policy based flow lookups\n           made against policy based route table. ')
polConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2))
polCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 1))
polGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 2))
polComplianceV10 = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 1, 1)).setObjects(("CTRON-SSR-POLICY-MIB", "polGroupV10"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polComplianceV10 = polComplianceV10.setStatus('deprecated')
if mibBuilder.loadTexts: polComplianceV10.setDescription('The compliance statement for the policyMIB.')
polComplianceV11 = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 1, 2)).setObjects(("CTRON-SSR-POLICY-MIB", "polGroupV11"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polComplianceV11 = polComplianceV11.setStatus('deprecated')
if mibBuilder.loadTexts: polComplianceV11.setDescription('The compliance statement for the policyMIB for version 1.1.')
polComplianceV12 = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 1, 3)).setObjects(("CTRON-SSR-POLICY-MIB", "polGroupV12"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polComplianceV12 = polComplianceV12.setStatus('current')
if mibBuilder.loadTexts: polComplianceV12.setDescription('The compliance statement for the policyMIB for version 1.2.')
polComplianceV13 = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 1, 4)).setObjects(("CTRON-SSR-POLICY-MIB", "polGroupV13"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polComplianceV13 = polComplianceV13.setStatus('current')
if mibBuilder.loadTexts: polComplianceV13.setDescription('The compliance statement for the policyMIB for version 1.3.')
polGroupV10 = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 2, 1)).setObjects(("CTRON-SSR-POLICY-MIB", "polAclServer"), ("CTRON-SSR-POLICY-MIB", "polAclNumber"), ("CTRON-SSR-POLICY-MIB", "polAclLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclName"), ("CTRON-SSR-POLICY-MIB", "polAclItem"), ("CTRON-SSR-POLICY-MIB", "polAclRestriction"), ("CTRON-SSR-POLICY-MIB", "polAclProtocol"), ("CTRON-SSR-POLICY-MIB", "polAclSrcIp"), ("CTRON-SSR-POLICY-MIB", "polAclSrcMask"), ("CTRON-SSR-POLICY-MIB", "polAclDstIp"), ("CTRON-SSR-POLICY-MIB", "polAclDstMask"), ("CTRON-SSR-POLICY-MIB", "polAclTOS"), ("CTRON-SSR-POLICY-MIB", "polAclSrcPort"), ("CTRON-SSR-POLICY-MIB", "polAclDstPort"), ("CTRON-SSR-POLICY-MIB", "polAclSrcOperator"), ("CTRON-SSR-POLICY-MIB", "polAclDstOperator"), ("CTRON-SSR-POLICY-MIB", "polAclSrcHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclDstHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclAuditTrail"), ("CTRON-SSR-POLICY-MIB", "polAclCheckpoint"), ("CTRON-SSR-POLICY-MIB", "polAclRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclServiceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclServiceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclServiceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclName2"), ("CTRON-SSR-POLICY-MIB", "polAclServiceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclServiceRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclRemoteAllowed"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclPolicyStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polGroupV10 = polGroupV10.setStatus('deprecated')
if mibBuilder.loadTexts: polGroupV10.setDescription('A set of managed objects that make up version 1.0 of the SSR Flow Policy MIB.')
polGroupV11 = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 2, 2)).setObjects(("CTRON-SSR-POLICY-MIB", "polAclServer"), ("CTRON-SSR-POLICY-MIB", "polAclNumber"), ("CTRON-SSR-POLICY-MIB", "polAclLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclName"), ("CTRON-SSR-POLICY-MIB", "polAclItem"), ("CTRON-SSR-POLICY-MIB", "polAclRestriction"), ("CTRON-SSR-POLICY-MIB", "polAclProtocol"), ("CTRON-SSR-POLICY-MIB", "polAclSrcIp"), ("CTRON-SSR-POLICY-MIB", "polAclSrcMask"), ("CTRON-SSR-POLICY-MIB", "polAclDstIp"), ("CTRON-SSR-POLICY-MIB", "polAclDstMask"), ("CTRON-SSR-POLICY-MIB", "polAclTOS"), ("CTRON-SSR-POLICY-MIB", "polAclSrcPort"), ("CTRON-SSR-POLICY-MIB", "polAclDstPort"), ("CTRON-SSR-POLICY-MIB", "polAclSrcOperator"), ("CTRON-SSR-POLICY-MIB", "polAclDstOperator"), ("CTRON-SSR-POLICY-MIB", "polAclSrcHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclDstHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclAuditTrail"), ("CTRON-SSR-POLICY-MIB", "polAclCheckpoint"), ("CTRON-SSR-POLICY-MIB", "polAclRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclServiceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclServiceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclServiceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclName2"), ("CTRON-SSR-POLICY-MIB", "polAclServiceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclServiceRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclRemoteAllowed"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclPolicyStatus"), ("CTRON-SSR-POLICY-MIB", "polL2FilterLastChanged"), ("CTRON-SSR-POLICY-MIB", "polL2FilterNumber"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDesc"), ("CTRON-SSR-POLICY-MIB", "polL2FilterType"), ("CTRON-SSR-POLICY-MIB", "polL2FilterRestrictions"), ("CTRON-SSR-POLICY-MIB", "polL2FilterSrcMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDstMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterVlanId"), ("CTRON-SSR-POLICY-MIB", "polL2FilterInPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterOutPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterCreationTime"), ("CTRON-SSR-POLICY-MIB", "polL2FilterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polGroupV11 = polGroupV11.setStatus('deprecated')
if mibBuilder.loadTexts: polGroupV11.setDescription('A set of managed objects that make up version 1.1 of the SSR Flow Policy MIB.')
polGroupV12 = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 2, 3)).setObjects(("CTRON-SSR-POLICY-MIB", "polAclServer"), ("CTRON-SSR-POLICY-MIB", "polAclNumber"), ("CTRON-SSR-POLICY-MIB", "polAclLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclName"), ("CTRON-SSR-POLICY-MIB", "polAclItem"), ("CTRON-SSR-POLICY-MIB", "polAclRestriction"), ("CTRON-SSR-POLICY-MIB", "polAclProtocol"), ("CTRON-SSR-POLICY-MIB", "polAclSrcIp"), ("CTRON-SSR-POLICY-MIB", "polAclSrcMask"), ("CTRON-SSR-POLICY-MIB", "polAclDstIp"), ("CTRON-SSR-POLICY-MIB", "polAclDstMask"), ("CTRON-SSR-POLICY-MIB", "polAclTOS"), ("CTRON-SSR-POLICY-MIB", "polAclSrcPort"), ("CTRON-SSR-POLICY-MIB", "polAclDstPort"), ("CTRON-SSR-POLICY-MIB", "polAclSrcOperator"), ("CTRON-SSR-POLICY-MIB", "polAclDstOperator"), ("CTRON-SSR-POLICY-MIB", "polAclSrcHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclDstHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclAuditTrail"), ("CTRON-SSR-POLICY-MIB", "polAclCheckpoint"), ("CTRON-SSR-POLICY-MIB", "polAclRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclServiceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclServiceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclServiceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclName2"), ("CTRON-SSR-POLICY-MIB", "polAclServiceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclServiceRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclRemoteAllowed"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclPolicyStatus"), ("CTRON-SSR-POLICY-MIB", "polL2FilterLastChanged"), ("CTRON-SSR-POLICY-MIB", "polL2FilterNumber"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDesc"), ("CTRON-SSR-POLICY-MIB", "polL2FilterType"), ("CTRON-SSR-POLICY-MIB", "polL2FilterRestrictions"), ("CTRON-SSR-POLICY-MIB", "polL2FilterSrcMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDstMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterVlanId"), ("CTRON-SSR-POLICY-MIB", "polL2FilterInPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterOutPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterCreationTime"), ("CTRON-SSR-POLICY-MIB", "polL2FilterStatus"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyBasedRoutingEnabled"), ("CTRON-SSR-POLICY-MIB", "polL4NumRouters"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopTableLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopRouter"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopState"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopPortOfExit"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopMacAddress"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4NumPolicies"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyType"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyAction"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyMatch"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyNextHops"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyLoading"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyWatch"), ("CTRON-SSR-POLICY-MIB", "polL4lowCreationTime"), ("CTRON-SSR-POLICY-MIB", "polL4lowActiveGates"), ("CTRON-SSR-POLICY-MIB", "polL4lowAppliedTimes"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlStatus"), ("CTRON-SSR-POLICY-MIB", "polL4lowLostRouters"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableActivates"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableActivateFails"), ("CTRON-SSR-POLICY-MIB", "polL4lowArpMappingChanges"), ("CTRON-SSR-POLICY-MIB", "polL4lowIcmpRedirects"), ("CTRON-SSR-POLICY-MIB", "polL4lowMatchAttempts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polGroupV12 = polGroupV12.setStatus('current')
if mibBuilder.loadTexts: polGroupV12.setDescription('A set of managed objects that make up version 1.2 of the SSR Flow Policy MIB.')
polGroupV13 = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 2501, 1, 210, 2, 2, 4)).setObjects(("CTRON-SSR-POLICY-MIB", "polAclServer"), ("CTRON-SSR-POLICY-MIB", "polAclNumber"), ("CTRON-SSR-POLICY-MIB", "polAclLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclName"), ("CTRON-SSR-POLICY-MIB", "polAclItem"), ("CTRON-SSR-POLICY-MIB", "polAclRestriction"), ("CTRON-SSR-POLICY-MIB", "polAclProtocol"), ("CTRON-SSR-POLICY-MIB", "polAclSrcIp"), ("CTRON-SSR-POLICY-MIB", "polAclSrcMask"), ("CTRON-SSR-POLICY-MIB", "polAclDstIp"), ("CTRON-SSR-POLICY-MIB", "polAclDstMask"), ("CTRON-SSR-POLICY-MIB", "polAclTOS"), ("CTRON-SSR-POLICY-MIB", "polAclSrcPort"), ("CTRON-SSR-POLICY-MIB", "polAclDstPort"), ("CTRON-SSR-POLICY-MIB", "polAclSrcOperator"), ("CTRON-SSR-POLICY-MIB", "polAclDstOperator"), ("CTRON-SSR-POLICY-MIB", "polAclSrcHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclDstHighRange"), ("CTRON-SSR-POLICY-MIB", "polAclAuditTrail"), ("CTRON-SSR-POLICY-MIB", "polAclCheckpoint"), ("CTRON-SSR-POLICY-MIB", "polAclRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclServiceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclServiceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclServiceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclName2"), ("CTRON-SSR-POLICY-MIB", "polAclServiceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclServiceRowStatus"), ("CTRON-SSR-POLICY-MIB", "polAclRemoteAllowed"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceNumber"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceLastChanged"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceIfIndex"), ("CTRON-SSR-POLICY-MIB", "polAclInterfaceDirection"), ("CTRON-SSR-POLICY-MIB", "polAclPolicyStatus"), ("CTRON-SSR-POLICY-MIB", "polL2FilterLastChanged"), ("CTRON-SSR-POLICY-MIB", "polL2FilterNumber"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDesc"), ("CTRON-SSR-POLICY-MIB", "polL2FilterType"), ("CTRON-SSR-POLICY-MIB", "polL2FilterRestrictions"), ("CTRON-SSR-POLICY-MIB", "polL2FilterSrcMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterDstMacAddr"), ("CTRON-SSR-POLICY-MIB", "polL2FilterVlanId"), ("CTRON-SSR-POLICY-MIB", "polL2FilterInPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterOutPorts"), ("CTRON-SSR-POLICY-MIB", "polL2FilterCreationTime"), ("CTRON-SSR-POLICY-MIB", "polL2FilterStatus"), ("CTRON-SSR-POLICY-MIB", "polL2Dot1qVlanStaticProtocols"), ("CTRON-SSR-POLICY-MIB", "polL2Dot1qVlanStaticL4Bridging"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyBasedRoutingEnabled"), ("CTRON-SSR-POLICY-MIB", "polL4NumRouters"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopTableLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopRouter"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopState"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopPortOfExit"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopMacAddress"), ("CTRON-SSR-POLICY-MIB", "polL4NextHopLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableLastChange"), ("CTRON-SSR-POLICY-MIB", "polL4NumPolicies"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyType"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyAction"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyMatch"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyNextHops"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyLoading"), ("CTRON-SSR-POLICY-MIB", "polL4PolicyWatch"), ("CTRON-SSR-POLICY-MIB", "polL4lowCreationTime"), ("CTRON-SSR-POLICY-MIB", "polL4lowActiveGates"), ("CTRON-SSR-POLICY-MIB", "polL4lowAppliedTimes"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlStatus"), ("CTRON-SSR-POLICY-MIB", "polL4lowLostRouters"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableActivates"), ("CTRON-SSR-POLICY-MIB", "polL4lowControlTableActivateFails"), ("CTRON-SSR-POLICY-MIB", "polL4lowArpMappingChanges"), ("CTRON-SSR-POLICY-MIB", "polL4lowIcmpRedirects"), ("CTRON-SSR-POLICY-MIB", "polL4lowMatchAttempts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    polGroupV13 = polGroupV13.setStatus('current')
if mibBuilder.loadTexts: polGroupV13.setDescription('A set of managed objects that make up version 1.3 of the SSR Flow Policy MIB.')
mibBuilder.exportSymbols("CTRON-SSR-POLICY-MIB", polAclSrcOperator=polAclSrcOperator, polL2FilterEntry=polL2FilterEntry, polL4NextHopTable=polL4NextHopTable, polL4PolicyBasedRoutingEnabled=polL4PolicyBasedRoutingEnabled, polL2FilterLastChanged=polL2FilterLastChanged, SSRFlowPolicyAclList=SSRFlowPolicyAclList, InterfaceIndexOrZero=InterfaceIndexOrZero, polL4NextHopTableLastChange=polL4NextHopTableLastChange, polL4NextHopLastChange=polL4NextHopLastChange, polAclPolicyStatus=polAclPolicyStatus, polAclInterfaceDirection=polAclInterfaceDirection, polAclName=polAclName, polL4NextHopMacAddress=polL4NextHopMacAddress, SSRPortComparator=SSRPortComparator, polAclServiceTable=polAclServiceTable, polL4PolicyAction=polL4PolicyAction, polL4lowActiveGates=polL4lowActiveGates, polAclServiceNumber=polAclServiceNumber, polL4lowLostRouters=polL4lowLostRouters, polAclDstHighRange=polAclDstHighRange, polAclInterfaceTable=polAclInterfaceTable, polL4PolicyInstance=polL4PolicyInstance, polGroupV12=polGroupV12, polL4GroupStats=polL4GroupStats, polL4lowControlEntry=polL4lowControlEntry, polAclServiceLastChanged=polAclServiceLastChanged, polAclDstIp=polAclDstIp, polL4PolicyNextHops=polL4PolicyNextHops, polL2Dot1qVlanStaticEntry=polL2Dot1qVlanStaticEntry, SSRPortList=SSRPortList, polAclSrcIp=polAclSrcIp, polAclInterfaceNumber=polAclInterfaceNumber, polAclSrcMask=polAclSrcMask, polL2FilterInPorts=polL2FilterInPorts, polL4PolicyName=polL4PolicyName, polComplianceV13=polComplianceV13, polAclNumber=polAclNumber, polL4lowControlTableActivateFails=polL4lowControlTableActivateFails, polL2FilterNumber=polL2FilterNumber, polL4lowMatchAttempts=polL4lowMatchAttempts, polL2FilterDstMacAddr=polL2FilterDstMacAddr, SSRFlowLoadPolicy=SSRFlowLoadPolicy, polAclLastChanged=polAclLastChanged, polL4lowControlTableActivates=polL4lowControlTableActivates, polAclDstPort=polAclDstPort, polCompliances=polCompliances, polL4NextHopRouter=polL4NextHopRouter, polAclServer=polAclServer, polL2Dot1qVlanStaticL4Bridging=polL2Dot1qVlanStaticL4Bridging, polL2FilterVlanId=polL2FilterVlanId, policyMIB=policyMIB, polAclServiceIfIndex=polAclServiceIfIndex, polL4lowAppliedTimes=polL4lowAppliedTimes, polComplianceV11=polComplianceV11, polComplianceV10=polComplianceV10, InterfaceIndex=InterfaceIndex, polAclTOS=polAclTOS, polL4lowArpMappingChanges=polL4lowArpMappingChanges, polAclEntry=polAclEntry, polAclItem=polAclItem, SSRsocketId=SSRsocketId, polL2FilterType=polL2FilterType, polL4PolicyWatch=polL4PolicyWatch, polL2Dot1qVlanStaticTable=polL2Dot1qVlanStaticTable, polAclRestriction=polAclRestriction, polGroupV10=polGroupV10, polL2FilterOutPorts=polL2FilterOutPorts, polL4PolicyType=polL4PolicyType, polL4NextHopState=polL4NextHopState, polL2FilterTable=polL2FilterTable, polL4lowIcmpRedirects=polL4lowIcmpRedirects, polL2FilterDesc=polL2FilterDesc, polL4NumPolicies=polL4NumPolicies, PYSNMP_MODULE_ID=policyMIB, polL2Dot1qVlanStaticProtocols=polL2Dot1qVlanStaticProtocols, polL4NextHopPortOfExit=polL4NextHopPortOfExit, SSRFlowPolicyType=SSRFlowPolicyType, polAclProtocol=polAclProtocol, polL4PolicyLoading=polL4PolicyLoading, polL4Group=polL4Group, polL2Group=polL2Group, polL4lowControlTableLastChange=polL4lowControlTableLastChange, polAclCheckpoint=polAclCheckpoint, polAclInterfaceIfIndex=polAclInterfaceIfIndex, polAclServiceEntry=polAclServiceEntry, SSRProtocol=SSRProtocol, polConformance=polConformance, polL4PolicyMatch=polL4PolicyMatch, polAclServiceDirection=polAclServiceDirection, SSRVlanIndex=SSRVlanIndex, polAclSrcHighRange=polAclSrcHighRange, polGroupV13=polGroupV13, polAclDstMask=polAclDstMask, polL4lowControlStatus=polL4lowControlStatus, polL4PolicySequence=polL4PolicySequence, polGroups=polGroups, polL4lowControlTable=polL4lowControlTable, polAclRowStatus=polAclRowStatus, polL2FilterIndex=polL2FilterIndex, polGroupV11=polGroupV11, polAclName2=polAclName2, polAclInterfaceEntry=polAclInterfaceEntry, polL2FilterStatus=polL2FilterStatus, polAclTable=polAclTable, SSRFlowPolicyAction=SSRFlowPolicyAction, polL4lowCreationTime=polL4lowCreationTime, polAclSrcPort=polAclSrcPort, polComplianceV12=polComplianceV12, polAclServiceRowStatus=polAclServiceRowStatus, polAclRemoteAllowed=polAclRemoteAllowed, polAclDstOperator=polAclDstOperator, polAclAuditTrail=polAclAuditTrail, polL2FilterCreationTime=polL2FilterCreationTime, polL2FilterRestrictions=polL2FilterRestrictions, polL2FilterSrcMacAddr=polL2FilterSrcMacAddr, polL4NextHopEntry=polL4NextHopEntry, SSRFlowNextHopList=SSRFlowNextHopList, polL4NumRouters=polL4NumRouters, polAclInterfaceLastChanged=polAclInterfaceLastChanged, polL3Group=polL3Group)
