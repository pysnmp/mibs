#
# PySNMP MIB module SAF-IPRADIO (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/saf/SAF-IPRADIO
# Produced by pysmi-1.1.12 at Tue Sep 17 10:05:29 2024
# On host fv-az1427-100 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifEntry, = mibBuilder.importSymbols("IF-MIB", "ifEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, TimeTicks, NotificationType, enterprises, iso, Unsigned32, Gauge32, ModuleIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Integer32, Counter64, Counter32, ObjectIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "TimeTicks", "NotificationType", "enterprises", "iso", "Unsigned32", "Gauge32", "ModuleIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Integer32", "Counter64", "Counter32", "ObjectIdentity", "MibIdentifier")
TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "DateAndTime")
saf = MibIdentifier((1, 3, 6, 1, 4, 1, 7571))
tehnika = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100))
microwaveRadio = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1))
pointToPoint = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1))
safip = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5))
ipRadio = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1))
ipRadioCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1))
ipRadioMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 2))
ipRadioStat = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3))
ipRadioCfgGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1))
ipRadioCfgNetwork = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 2))
ipRadioStatEth = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2))
modemStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4))
product = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: product.setStatus('mandatory')
if mibBuilder.loadTexts: product.setDescription('Name of the model.')
description = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: description.setStatus('mandatory')
if mibBuilder.loadTexts: description.setDescription('Description of the model.')
hostname = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostname.setStatus('mandatory')
if mibBuilder.loadTexts: hostname.setDescription('The name of the host.')
sysDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 4), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDateAndTime.setStatus('mandatory')
if mibBuilder.loadTexts: sysDateAndTime.setDescription('Current date and time set.\n              For SET tenths of seconds ignored.')
sysTemperature = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: sysTemperature.setDescription('Unit temperature in degrees by Celsius.\n                 NB - sw before 2009.03.18 shows in *10 degrees')
license = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: license.setStatus('mandatory')
if mibBuilder.loadTexts: license.setDescription("To set license information. Read allways 'OK'.")
licenseMask = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMask.setStatus('mandatory')
if mibBuilder.loadTexts: licenseMask.setDescription('Read license mask.')
licenseUpdateStatus = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseUpdateStatus.setStatus('mandatory')
if mibBuilder.loadTexts: licenseUpdateStatus.setDescription('Status of last license update operation\n                     by setting license using snmp.')
writeConfig = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 2, 1), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: writeConfig.setStatus('mandatory')
if mibBuilder.loadTexts: writeConfig.setDescription('Write Config')
restartcpu = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 2, 2), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: restartcpu.setStatus('mandatory')
if mibBuilder.loadTexts: restartcpu.setDescription("Restart of Mng CPU. Values: \n\t\t      1 - 'cold' restart; \n\t\t\t  3 - sw")
loopbacks = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 12))).clone(namedValues=NamedValues(("error", 1), ("off", 2), ("if", 4), ("modem", 5), ("multi", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loopbacks.setStatus('mandatory')
if mibBuilder.loadTexts: loopbacks.setDescription("Set loopback for 1 minute. value error(1) is not writable.\n                     Status of loopbacks.\n\t\t\t  Values:\n\t\t\t  1 - 'error' (not writable);\n\t\t\t  2 - 'off';\n\t\t\t  3 - 'rf' (radio frequency loopback); N/A 2008.10.21\n\t\t\t  4 - 'if' (intermediate frequency loopback);\n\t\t\t  5 - 'modem' (modem loopback);\n\t\t\t  6 - 'far' (far end loopback); N/A 2008.10.21\n\t\t\t  7 - 'ethernet' (Ethernet loopback); N/A 2008.10.21\n\t\t\t  8 - 'e1t1-1' (E1/T1 channel 1 loopback); N/A from firmware 1.51\n\t\t\t  9 - 'e1t1-2' (E1/T1 channel 2 loopback); N/A from firmware 1.51\n\t\t\t  10 - 'e1t1-3' (E1/T1 channel 3 loopback); N/A from firmware 1.51\n\t\t\t  11 - 'e1t1-4' (E1/T1 channel 4 loopback);  N/A from firmware 1.51\n\t\t\t  12 - 'multi'  (E1/T1 multi - look channel tributary mask)")
loopback_tributary_mask = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 2, 4), Integer32()).setLabel("loopback-tributary-mask").setMaxAccess("readonly")
if mibBuilder.loadTexts: loopback_tributary_mask.setStatus('mandatory')
if mibBuilder.loadTexts: loopback_tributary_mask.setDescription('Loopback mask for E1/T1 channels')
localIp = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localIp.setStatus('mandatory')
if mibBuilder.loadTexts: localIp.setDescription('IPv4 Ethernet address of the local \n\t\t      unit in a number format(XXX.XXX.XXX.XXX)')
localIpMask = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: localIpMask.setDescription('IPv4 Ethernet mask of the local \n\t\t      unit in a number format (XXX.XXX.XXX.XXX)')
remoteIp = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remoteIp.setStatus('mandatory')
if mibBuilder.loadTexts: remoteIp.setDescription('IPv4 Ethernet address of the remote \n\t\t      unit in a number format (XXX.XXX.XXX.XXX).')
radioTable = MibTable((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10), )
if mibBuilder.loadTexts: radioTable.setStatus('mandatory')
if mibBuilder.loadTexts: radioTable.setDescription('Radio table.')
radioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1), ).setIndexNames((0, "SAF-IPRADIO", "radioIndex"))
if mibBuilder.loadTexts: radioEntry.setStatus('mandatory')
if mibBuilder.loadTexts: radioEntry.setDescription('Entry containing objects in radio table.')
radioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioIndex.setStatus('mandatory')
if mibBuilder.loadTexts: radioIndex.setDescription("A unique value for each radio.\n                       Its value represents UNIT:\n                       1 - for 'local';\n                       2 - for 'remote'")
radioGenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioGenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: radioGenStatus.setDescription("A General status of each radio:\n                       1 - 'OK';\n                       2 - 'error'")
radioSide = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("high", 1), ("low", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioSide.setStatus('mandatory')
if mibBuilder.loadTexts: radioSide.setDescription('Side for duplex communication.')
radioTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioTxPower.setStatus('mandatory')
if mibBuilder.loadTexts: radioTxPower.setDescription('Tx power of radio transmitter in dBm.')
radioRxLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioRxLevel.setStatus('mandatory')
if mibBuilder.loadTexts: radioRxLevel.setDescription('Received signal level in dBm.')
radioDuplexShift = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioDuplexShift.setStatus('mandatory')
if mibBuilder.loadTexts: radioDuplexShift.setDescription('Utilized duplex shift in KHz.')
radioLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: radioLoopback.setDescription('Radio loopback on/off. To set use \n\t\t\t\t\t  loopback command.')
radioTxMute = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioTxMute.setStatus('mandatory')
if mibBuilder.loadTexts: radioTxMute.setDescription("Status of 'Tx mute':\n\t\t\t\t\t  1 - Tx is muted;\n\t\t\t\t\t  2 - Tx is not muted.")
radioTxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioTxFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: radioTxFrequency.setDescription('Tx frequency in kHz.')
radioRxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioRxFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: radioRxFrequency.setDescription('Rx frequency in kHz.')
aTPCTable = MibTable((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 11), )
if mibBuilder.loadTexts: aTPCTable.setStatus('mandatory')
if mibBuilder.loadTexts: aTPCTable.setDescription('ATPC table')
aTPCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 11, 1), ).setIndexNames((0, "SAF-IPRADIO", "atpcIndex"))
if mibBuilder.loadTexts: aTPCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aTPCEntry.setDescription('Entry containing objects in ATPC table.')
atpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atpcIndex.setDescription("Its value represents UNIT\n                       1 for 'local';\n                       2 for 'remote'.")
atpcEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atpcEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: atpcEnabled.setDescription("ATPC status:\n\t\t\t         1 for 'on';\n\t\t\t\t\t 2 for 'off'.")
atpcTxPowerCorrection = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpcTxPowerCorrection.setStatus('mandatory')
if mibBuilder.loadTexts: atpcTxPowerCorrection.setDescription('ATPC Tx power correction in dBm.')
modemTable = MibTable((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12), )
if mibBuilder.loadTexts: modemTable.setStatus('mandatory')
if mibBuilder.loadTexts: modemTable.setDescription('CFIP modem table.')
modemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1), ).setIndexNames((0, "SAF-IPRADIO", "modemIndex"))
if mibBuilder.loadTexts: modemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modemEntry.setDescription('Entry containing objects in modem table.')
modemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modemIndex.setDescription('Value represents UNIT:\n                       1 for local;\n                       2 for remote.')
modemGeneralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemGeneralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: modemGeneralStatus.setDescription("A General status of each modem:\n                       1 - 'OK';\n                       2 - 'error'")
modemBandwith = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemBandwith.setStatus('mandatory')
if mibBuilder.loadTexts: modemBandwith.setDescription('Modem bandwidth set in KHz.')
modemE1T1Channels = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemE1T1Channels.setStatus('mandatory')
if mibBuilder.loadTexts: modemE1T1Channels.setDescription('Number of E1 or T1 channels set.')
modemModulation = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 40, 41, 42, 49, 50, 57, 58))).clone(namedValues=NamedValues(("qpsk", 1), ("psk8", 2), ("qam16", 3), ("qam32", 4), ("qam64", 5), ("qam128", 6), ("qam256", 7), ("qpsklimited", 8), ("wqpsk", 9), ("wpsk8", 10), ("wqam16", 11), ("wqam32", 12), ("wqam64", 13), ("wqam128", 14), ("wqam256", 15), ("acmqpsk", 17), ("acmpsk8", 18), ("acmqam16", 19), ("acmqam32", 20), ("acmqam64", 21), ("acmqam128", 22), ("acmqam256", 23), ("acmwqpsk", 25), ("acmwpsk8", 26), ("acmwqam16", 27), ("acmwqam32", 28), ("acmwqam64", 29), ("acmwqam128", 30), ("acmwqam256", 31), ("qam4", 33), ("qam8", 34), ("qam4limited", 40), ("wqam4", 41), ("wqam8", 42), ("acmqam4", 49), ("acmqam8", 50), ("acmwqam4", 57), ("acmwqam8", 58)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemModulation.setStatus('mandatory')
if mibBuilder.loadTexts: modemModulation.setDescription('Modem modulation set.\n              Modulution values are\n\t\t\t  following: QPSK - 1, 8PSK - 2, 16QAM - 3, \n\t\t\t  32QAM - 4, 64QAM - 5, 128QAM - 6,\n\t\t\t  256QAM - 7.\n\t\t\t  The combination of wide band and ACM calculates as\n\t\t\t  (modulation + 8*is_wide + 16*is_ACM).\n\t\t\t  Note: not all of listed modulations supported by hardware.\n\t\t\t  Plese check manual.')
modemTotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemTotalCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: modemTotalCapacity.setDescription('Total capacity set in Kbps.')
modemEthernetCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemEthernetCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: modemEthernetCapacity.setDescription('Ethernet capacity set in Kbps.')
modemAcqStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemAcqStatus.setStatus('mandatory')
if mibBuilder.loadTexts: modemAcqStatus.setDescription(' ')
modemLastAcqError = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("success", 1), ("erragc", 2), ("errtiming", 3), ("errfreqsweep", 4), ("errmse", 5), ("errbit", 6), ("errservice", 7), ("errblind", 8), ("errtimeout", 9), ("errstopped", 10), ("errfatal", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemLastAcqError.setStatus('mandatory')
if mibBuilder.loadTexts: modemLastAcqError.setDescription(' ')
modemRadialMSE = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemRadialMSE.setStatus('mandatory')
if mibBuilder.loadTexts: modemRadialMSE.setDescription("Radial mean square error value *10 in dB.\n                    Radial MSE is a method for estimating the \n\t\t\t\t\tsignal to noise ratio. ACM engine uses \n\t\t\t\t\tnormalized MSE, which is the inverse of SNR. \n\t\t\t\t\tIt is calculated by dividing the estimated \n\t\t\t\t\tMSE level with the energy of the received \n\t\t\t\t\tconstellation. Radial MSE peak value threshold \n\t\t\t\t\tis dependent on modulation used and LDPC \n\t\t\t\t\tcode rate.\n                    In case of QPSK it is -8 dB (-10.5 for 'wide'), \n\t\t\t\t\t16APSK - -13 dB (-18 for 'wide') and \n\t\t\t\t\t32APSK - -15.5 dB (-21.5 for 'wide'). If the \n\t\t\t\t\tvalue trespasses this threshold, BER at the \n\t\t\t\t\toutput of LDPC decoder will reach the value \n\t\t\t\t\tof 1.0e-06.")
modemInternalAGCgain = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemInternalAGCgain.setStatus('mandatory')
if mibBuilder.loadTexts: modemInternalAGCgain.setDescription(' dBm ')
modemCarrierOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemCarrierOffset.setStatus('mandatory')
if mibBuilder.loadTexts: modemCarrierOffset.setDescription('Carrier frequency offset in Hz.')
modemSymbolRateTx = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemSymbolRateTx.setStatus('mandatory')
if mibBuilder.loadTexts: modemSymbolRateTx.setDescription(' kHz ')
modemSymbolRateRx = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemSymbolRateRx.setStatus('mandatory')
if mibBuilder.loadTexts: modemSymbolRateRx.setDescription(' kHz ')
modemLDPCdecoderStress = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemLDPCdecoderStress.setStatus('mandatory')
if mibBuilder.loadTexts: modemLDPCdecoderStress.setDescription("The load of LDPC (low-density \n\t\t\t        parity-check code) decoder.\n                    The LDPC is monitored for the number \n\t\t\t\t\tof errors being corrected on the input \n\t\t\t\t\tof LDPC decoder.\n                    LDPC stress value thresholds @ BER 1.0e-06: \n\t\t\t\t\t- for standard settings ~4.0e-02; \n\t\t\t\t\t- for 'wide' option ~ 1.0e-03.\n                    As long as LDPC stress value is under the \n\t\t\t\t\tspecified thresholds, amount of errors (and \n\t\t\t\t\tBER itself) on the output of LDPC remains \n\t\t\t\t\tat zero level.")
modemACMengine = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemACMengine.setStatus('mandatory')
if mibBuilder.loadTexts: modemACMengine.setDescription("Status of ACM engine. When 'on', \n\t\t\t        value '1' is shown, when 'off' - value is '2'.")
modemACMmodulationMin = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 40, 41, 42, 49, 50, 57, 58))).clone(namedValues=NamedValues(("qpsk", 1), ("psk8", 2), ("qam16", 3), ("qam32", 4), ("qam64", 5), ("qam128", 6), ("qam256", 7), ("qpsklimited", 8), ("wqpsk", 9), ("wpsk8", 10), ("wqam16", 11), ("wqam32", 12), ("wqam64", 13), ("wqam128", 14), ("wqam256", 15), ("acmqpsk", 17), ("acmpsk8", 18), ("acmqam16", 19), ("acmqam32", 20), ("acmqam64", 21), ("acmqam128", 22), ("acmqam256", 23), ("acmwqpsk", 25), ("acmwpsk8", 26), ("acmwqam16", 27), ("acmwqam32", 28), ("acmwqam64", 29), ("acmwqam128", 30), ("acmwqam256", 31), ("qam4", 33), ("qam8", 34), ("qam4limited", 40), ("wqam4", 41), ("wqam8", 42), ("acmqam4", 49), ("acmqam8", 50), ("acmwqam4", 57), ("acmwqam8", 58)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemACMmodulationMin.setStatus('mandatory')
if mibBuilder.loadTexts: modemACMmodulationMin.setDescription('Modem modulation set.\n              Modulution values are\n\t\t\t  following: QPSK - 1, 8PSK - 2, 16QAM - 3, \n\t\t\t  32QAM - 4, 64QAM - 5, 128QAM - 6,\n\t\t\t  256QAM - 7.\n\t\t\t  The combination of wide band and ACM calculates as\n\t\t\t  (modulation + 8*is_wide + 16*is_ACM).\n\t\t\t  Note: not all of listed modulations supported by hardware.\n\t\t\t  Plese check manual.')
modemACMtotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemACMtotalCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: modemACMtotalCapacity.setDescription('Total capacity in Kbps set by ACM.')
modemACMethernetCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemACMethernetCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: modemACMethernetCapacity.setDescription('Ethernet capacity in Kbps set by ACM.')
modemStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("etsi", 1), ("ansi", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemStandard.setStatus('mandatory')
if mibBuilder.loadTexts: modemStandard.setDescription('Modem operational standard ETSI or ANSI')
modemE1T1ChannelMask = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemE1T1ChannelMask.setStatus('mandatory')
if mibBuilder.loadTexts: modemE1T1ChannelMask.setDescription('E1 or T1 channel mask 0x00 - 0x0f')
modemACMmodulationMax = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 40, 41, 42, 49, 50, 57, 58))).clone(namedValues=NamedValues(("qpsk", 1), ("psk8", 2), ("qam16", 3), ("qam32", 4), ("qam64", 5), ("qam128", 6), ("qam256", 7), ("qpsklimited", 8), ("wqpsk", 9), ("wpsk8", 10), ("wqam16", 11), ("wqam32", 12), ("wqam64", 13), ("wqam128", 14), ("wqam256", 15), ("acmqpsk", 17), ("acmpsk8", 18), ("acmqam16", 19), ("acmqam32", 20), ("acmqam64", 21), ("acmqam128", 22), ("acmqam256", 23), ("acmwqpsk", 25), ("acmwpsk8", 26), ("acmwqam16", 27), ("acmwqam32", 28), ("acmwqam64", 29), ("acmwqam128", 30), ("acmwqam256", 31), ("qam4", 33), ("qam8", 34), ("qam4limited", 40), ("wqam4", 41), ("wqam8", 42), ("acmqam4", 49), ("acmqam8", 50), ("acmwqam4", 57), ("acmwqam8", 58)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemACMmodulationMax.setStatus('mandatory')
if mibBuilder.loadTexts: modemACMmodulationMax.setDescription('Modem modulation set.\n              Modulution values are\n\t\t\t  following: QPSK - 1, 8PSK - 2, 16QAM - 3, \n\t\t\t  32QAM - 4, 64QAM - 5, 128QAM - 6,\n\t\t\t  256QAM - 7.\n\t\t\t  The combination of wide band and ACM calculates as\n\t\t\t  (modulation + 8*is_wide + 16*is_ACM).\n\t\t\t  Note: as PSK modulations are now physicaly deprecated,\n              theese are replased with QAM, so for new QAM modulations\n              there are modificatior +32.\n\t\t\t  Note: not all of listed modulations supported by hardware.\n\t\t\t  Plese check manual.')
modemRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 12, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("notReady", 3), ("undo", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modemRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: modemRowStatus.setDescription('Row status - to update written data for\n              modemBandwith,\n              modemACMmodulationMin,\n              modemACMmodulationMax,\n              modemE1T1ChannelMask. ')
vlansEnabled = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("reset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlansEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: vlansEnabled.setDescription('unit temperature *10 degrees Celsius')
vlanTable = MibTable((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14), )
if mibBuilder.loadTexts: vlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTable.setDescription('Vlan table')
vlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1), )
ifEntry.registerAugmentions(("SAF-IPRADIO", "vlanEntry"))
vlanEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: vlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanEntry.setDescription('entry containing vlan objects')
vlanNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNumber.setDescription('A unique value for each vlan. ')
vlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("management", 1), ("none", 2), ("traffic", 3), ("endpoint", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortType.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortType.setDescription('VLAN port type\n                      management, traffic or endpoint \n                       ')
vlanPortmap = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortmap.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortmap.setDescription('display port bindings\n                       bitfield 111(bin)\n                       ')
vlanFid = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanFid.setStatus('optional')
if mibBuilder.loadTexts: vlanFid.setDescription('a filtering identifier (assigned automagically)')
vlanCfgStat = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanCfgStat.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCfgStat.setDescription('enable/disable vlan # or clear row data')
vlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 1, 1, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("notReady", 3), ("undo", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vlanRowStatus.setDescription('Row status (execute configuration on active)\n                       Changing any table value sets this value into\n                       state notReady. To update row status write value\n                       active(1) into this variable.')
ethRXTruncatedFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXTruncatedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXTruncatedFrames.setDescription('Number of truncated received frames since \n\t\t             unit start or statistics reset. ')
ethRXLongEvents = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXLongEvents.setDescription('Number of frames having byte count greater \n\t\t             than MAXIMUM FRAME SIZE parameter (1518, \n\t\t\t\t\t 1536 or 1916 bytes) since unit start or \n\t\t\t\t\t statistics reset.')
ethRXVlanTagsDetected = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXVlanTagsDetected.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXVlanTagsDetected.setDescription('Number of VLAN Tags detected since unit \n\t\t             start or statistics reset.')
ethRXUnsupOpcodes = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXUnsupOpcodes.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXUnsupOpcodes.setDescription('Number of frames recognized as control frames \n\t\t             but contained an Unknown Opcode since unit \n\t\t\t\t\t start or statistics reset.')
ethRXPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXPauseFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXPauseFrames.setDescription('Number of frames received as control frames \n\t\t             with valid PAUSE opcodes since unit start or \n\t\t\t\t\t statistics reset.')
ethRXControlFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXControlFrames.setDescription('Number of frames received as control frames \n\t\t             since unit start or statistics reset.')
ethRXDribleNibbles = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXDribleNibbles.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXDribleNibbles.setDescription('Indicates that following the end of the \n\t\t             packet additional 1 to 7 bits are received. \n                     A single nibble, named the  dribble nibble, \n\t\t\t\t\t is formed but not sent to the system;')
ethRXBroadcasts = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXBroadcasts.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXBroadcasts.setDescription('Number of packets, which destination \n\t\t             address contained broadcast address, \n\t\t\t\t\t since unit start or statiistics reset.')
ethRXMulticasts = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXMulticasts.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXMulticasts.setDescription('Number of packets, which destination \n\t\t             address contained multicast address since\n                     unit start or statistics reset.')
ethRXDones = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXDones.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXDones.setDescription('Reception of packets successfully \n\t\t             completed. Number of completed packets \n\t\t\t\t\t since unit start or statistics reset.')
ethRXOutOfRangeErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXOutOfRangeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXOutOfRangeErrors.setDescription('Number of frames where Type/Length field \n\t\t             larger than 1518 (Type Field) bytes since\n                     unit start or statistics reset.')
ethRXLengthCheckerrorsErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXLengthCheckerrorsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXLengthCheckerrorsErrors.setDescription('Number of frames where frame length field \n\t\t             in the packet does not match the actual data \n\t\t\t\t\t byte length and is not a Type Field since \n\t\t\t\t\t unit start or statistics reset.')
ethRXCRCErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXCRCErrors.setDescription('Number of frames where frame CRC do not \n\t\t             match the internally generated CRC since \n                     unit start or statistics reset')
ethRXCodeErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXCodeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXCodeErrors.setDescription('Number of packets where one or more nibbles \n\t\t             are signalled as errors during reception of \n\t\t\t\t\t the packet since unit start or statistics \n\t\t\t\t\t reset.')
ethRXFalseCarrierErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXFalseCarrierErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXFalseCarrierErrors.setDescription('Indicates that following the last receive \n\t\t             statistics vector, a false carrier was \n                     detected, noted and reported with this the \n\t\t\t\t\t next receive statistics. The false carrier \n\t\t\t\t\t is not associated with this packet. False \n\t\t\t\t\t carrier is activated on the receive channel \n\t\t\t\t\t that does not result in a packet receive \n\t\t\t\t\t attempt being made;')
ethRXDvEvent = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXDvEvent.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXDvEvent.setDescription('Number of the last receive (Rx) events seen \n\t\t             being too short to be valid packets since the \n                     last unit (re)start or purification of \n\t\t\t\t\t statistics.')
ethRXPrevPktDropped = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXPrevPktDropped.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXPrevPktDropped.setDescription('Indicates that since the last receive (Rx), \n\t\t             a packet is dropped (i.e. interframe gap \n\t\t\t\t\t too small).')
ethRXByteCounterHi = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXByteCounterHi.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXByteCounterHi.setDescription('Total number of bytes received (Rx) on the \n\t\t             wire since the last unit (re)start or \n\t\t\t\t\t purification of statistics, not counting \n\t\t\t\t\t collided bytes (bits 31:0).')
ethRXByteCounterLow = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethRXByteCounterLow.setStatus('mandatory')
if mibBuilder.loadTexts: ethRXByteCounterLow.setDescription('Total number of bytes received (Rx) on the \n\t\t             wire since the last unit (re)start or \n\t\t\t\t\t purification of statistics, not counting \n\t\t\t\t\t collided bytes (bits 62:32).')
ethTXVlanTags = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXVlanTags.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXVlanTags.setDescription('Number of VLAN tagged Tx packets since the \n\t\t             last unit (re)start or purification of \n\t\t\t\t\t statistics. 32-bit counter.')
ethTXBackpresEvents = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXBackpresEvents.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXBackpresEvents.setDescription('Number of times Tx carrier-sense-method \n\t\t             backpressure was previously applied since the \n\t\t\t\t\t last unit (re)start or purification of \n\t\t\t\t\t statistics.')
ethTXPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXPauseFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXPauseFrames.setDescription('Number of frames transmitted (Tx) as control \n\t\t             frames with valid PAUSE opcodes since the last  \n                     unit (re)start or purification of statistics.')
ethTXControlFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXControlFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXControlFrames.setDescription('Number of frames transmitted (Tx) as control \n\t\t             frames since the last unit (re)start or \n                     purification of statistics.')
ethTXWireByteCounterHi = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXWireByteCounterHi.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXWireByteCounterHi.setDescription('Total number of bytes transmitted (Tx) \n\t\t             on the wire since the last unit (re)start \n\t\t\t\t\t or purification of statistics, including \n\t\t\t\t\t all bytes from collided attempts \n\t\t\t\t\t (bits 31:0).')
ethTXWireByteCounterLow = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXWireByteCounterLow.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXWireByteCounterLow.setDescription('Total number of bytes transmitted (Tx) \n\t\t             on the wire since the last unit (re)start \n\t\t\t\t\t or purification of statistics, including \n\t\t\t\t\t all bytes from collided attempts \n\t\t\t\t\t (bits 62:32).')
ethTXUnderruns = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXUnderruns.setDescription('Number of underruns occured during frame \n\t\t             transmission (Tx) since the last unit \n\t\t\t\t\t (re)start or purification of statistics.')
ethTXGiants = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXGiants.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXGiants.setDescription('Number of Tx frames having byte count \n\t\t             greater than the MAXIMUM FRAME SIZE \n                     parameter (1516, 1536 or 1916 bytes) \n\t\t\t\t\t since the last unit (re)start or \n\t\t\t\t\t purification of statistics.')
ethTXLateCollisions = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXLateCollisions.setDescription('Number of Tx collisions occurred beyond \n\t\t             the collision window (512 bit times) since \n\t\t\t\t\t the last unit (re)start or purification \n\t\t\t\t\t of statistics.')
ethTXMaxCollisions = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXMaxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXMaxCollisions.setDescription('Number of Tx packets aborted after number \n\t\t             of collisions exceeded the RETRANSMISSION \n\t\t\t\t\t MAXIMUM parameter since the last unit \n\t\t\t\t\t (re)start or purification of statistics.')
ethTXExcessiveDefers = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXExcessiveDefers.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXExcessiveDefers.setDescription('Number of Tx packets deferred in excess \n\t\t             of 6,071 nibble times in 100 Mbps mode, \n\t\t\t\t\t or 24,287 bit-times in 10 Mbps mode since \n\t\t\t\t\t the last unit (re)start or purification \n\t\t\t\t\t of statistics.')
ethTXNonExcessiveDefers = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXNonExcessiveDefers.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXNonExcessiveDefers.setDescription('Number of Tx packets deferred for at \n\t\t             least one attempt, but less than an \n\t\t\t\t\t excessive defer since the last unit \n\t\t\t\t\t (re)start or purification of statistics.')
ethTXBroadcasts = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXBroadcasts.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXBroadcasts.setDescription('Number of Tx packets since the last unit \n\t\t             (re)start or purification of statistics, \n\t\t\t\t\t which destination address contained \n\t\t\t\t\t broadcast address.')
ethTXMulticasts = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXMulticasts.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXMulticasts.setDescription('Number of Tx packets since the last unit \n\t\t             (re)start or purification of statistics, \n\t\t\t\t\t which destination address contained \n\t\t\t\t\t multicast address.')
ethTXDones = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXDones.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXDones.setDescription('Number of packets successfully transmitted \n\t\t             (Tx) since the last unit (re)start or \n\t\t\t\t\t purification of statistics.')
ethTXLengthCheckErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXLengthCheckErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXLengthCheckErrors.setDescription('Number of Tx frames since the last unit \n\t\t             (re)start or purification of statistics, \n\t\t\t\t\t where length field in the packet does not \n\t\t\t\t\t match the actual data byte length and is \n\t\t\t\t\t not a Type Field')
ethTXCRCErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXCRCErrors.setDescription('Number of Tx frames since the last unit \n\t\t             (re)start or purification of statistics, \n\t\t\t\t\t where CRC does not match the internally \n\t\t\t\t\t generated CRC.')
ethTXCollisions = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXCollisions.setDescription('Number of collisions the current packet \n\t\t             incurred during transmission (Tx) attempts. \n\t\t\t\t\t Note: Bits 19 through 16 are the collision \n\t\t\t\t\t count on any successfully transmitted packet \n\t\t\t\t\t and as such will not show the possible maximum \n                     count of 16 collisions.')
ethTXByteCounterHi = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXByteCounterHi.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXByteCounterHi.setDescription('Total count of bytes transmitted (Tx) \n\t\t             on the wire not including collided bytes \n\t\t\t\t\t (bits 31:0) since the last unit (re)start \n\t\t\t\t\t or purification of statistics.')
ethTXByteCounterLow = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTXByteCounterLow.setStatus('mandatory')
if mibBuilder.loadTexts: ethTXByteCounterLow.setDescription('Total count of bytes transmitted (Tx) \n\t\t             on the wire not including collided bytes \n\t\t\t\t\t (bits 62:32) since the last unit (re)start \n\t\t\t\t\t or purification of statistics.')
ethGFPFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGFPFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethGFPFCSErrors.setDescription('Number of generic framing procedure (GFP) \n\t\t             frames with CRC errors received by the \n\t\t\t\t\t de-encapsulation block since the last unit \n\t\t\t\t\t (re)start or purification of statistics.')
ethGFPCHECErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGFPCHECErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethGFPCHECErrors.setDescription('Number of generic framing procedure (GFP) \n\t\t             frames with CHEC errors received by the \n\t\t\t\t\t de-encapsulation block since the last unit \n\t\t\t\t\t (re)start or purification of statistics.')
ethGFPDropedFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGFPDropedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethGFPDropedFrames.setDescription('Number of generic framing procedure (GFP) \n\t\t             frames that were dropped in the de-encapsulation \n\t\t\t\t\t block since the last unit (re)start or \n\t\t\t\t\t purification of statistics.')
ethGFPDelineationErrors = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethGFPDelineationErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ethGFPDelineationErrors.setDescription("Number of 'lost of synchronization' events since \n\t\t             the last unit (re)start or purification of \n\t\t\t\t\t statistics.")
ethQOSRXQ1Frames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSRXQ1Frames.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSRXQ1Frames.setDescription('Number of frames received on Q1 since the last unit \n                    (re)start or purification of statistics.')
ethQOSRXQ1Dropped = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSRXQ1Dropped.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSRXQ1Dropped.setDescription('Number of frames dropped on Q1 since the last unit \n                    (re)start or purification of statistics.')
ethQOSRXQ2Frames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSRXQ2Frames.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSRXQ2Frames.setDescription('Number of frames received on Q2 since the last unit \n                    (re)start or purification of statistics.')
ethQOSRXQ2Dropped = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSRXQ2Dropped.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSRXQ2Dropped.setDescription('Number of frames dropped on Q2 since the last unit \n                    (re)start or purification of statistics.')
ethQOSTXFrames = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSTXFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSTXFrames.setDescription('Number of frames passed through TX FIFO since the \n                     last unit (re)start or purification of statistics.')
ethQOSTXDropped = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 2, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethQOSTXDropped.setStatus('mandatory')
if mibBuilder.loadTexts: ethQOSTXDropped.setDescription('Number of frames dropped in TX FIFO since the last \n                     unit (re)start or purification of statistics.')
e1t1StatTable = MibTable((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 3), )
if mibBuilder.loadTexts: e1t1StatTable.setStatus('mandatory')
if mibBuilder.loadTexts: e1t1StatTable.setDescription('E1 (T1) status Table.')
e1t1StatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 3, 1), )
ifEntry.registerAugmentions(("SAF-IPRADIO", "e1t1StatEntry"))
e1t1StatEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: e1t1StatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: e1t1StatEntry.setDescription('Entry containing objects in E1 (T1) table')
e1t1LOS = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1t1LOS.setStatus('mandatory')
if mibBuilder.loadTexts: e1t1LOS.setDescription('if signal loss present')
e1t1AIS = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1t1AIS.setStatus('mandatory')
if mibBuilder.loadTexts: e1t1AIS.setDescription('if AIS present')
e1t1ChannelNr = MibTableColumn((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: e1t1ChannelNr.setStatus('mandatory')
if mibBuilder.loadTexts: e1t1ChannelNr.setDescription('e1 channel number (it is not associated with interface number - ifEntry)')
modemCountTime = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemCountTime.setStatus('mandatory')
if mibBuilder.loadTexts: modemCountTime.setDescription('Count time in seconds')
modemErroredBlock = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemErroredBlock.setStatus('mandatory')
if mibBuilder.loadTexts: modemErroredBlock.setDescription('Errored block')
modemErroredSecond = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemErroredSecond.setStatus('mandatory')
if mibBuilder.loadTexts: modemErroredSecond.setDescription('Errored second')
modemSeverelyErroredSecond = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemSeverelyErroredSecond.setStatus('mandatory')
if mibBuilder.loadTexts: modemSeverelyErroredSecond.setDescription('Severely errored second')
modemBackgroundBlockErrror = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemBackgroundBlockErrror.setStatus('mandatory')
if mibBuilder.loadTexts: modemBackgroundBlockErrror.setDescription('Background Block Error')
modemTotalBlockNumber = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemTotalBlockNumber.setStatus('mandatory')
if mibBuilder.loadTexts: modemTotalBlockNumber.setDescription('Total Block Number')
modemErroredSecondRatio = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemErroredSecondRatio.setStatus('mandatory')
if mibBuilder.loadTexts: modemErroredSecondRatio.setDescription('Errored Second Ratio')
modemSeverelyErroredSecondRatio = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemSeverelyErroredSecondRatio.setStatus('mandatory')
if mibBuilder.loadTexts: modemSeverelyErroredSecondRatio.setDescription('Severely Errored Second Ratio')
modemBackgroundBlockErrorRatio = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemBackgroundBlockErrorRatio.setStatus('mandatory')
if mibBuilder.loadTexts: modemBackgroundBlockErrorRatio.setDescription('Background Block Error Ratio')
modemUptime = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemUptime.setStatus('mandatory')
if mibBuilder.loadTexts: modemUptime.setDescription('Uptime (s)')
modemUnavailtime = MibScalar((1, 3, 6, 1, 4, 1, 7571, 100, 1, 1, 5, 1, 3, 4, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modemUnavailtime.setStatus('mandatory')
if mibBuilder.loadTexts: modemUnavailtime.setDescription('Unavailtime (s)')
mibBuilder.exportSymbols("SAF-IPRADIO", modemE1T1ChannelMask=modemE1T1ChannelMask, modemTotalBlockNumber=modemTotalBlockNumber, e1t1LOS=e1t1LOS, ethTXVlanTags=ethTXVlanTags, vlanCfgStat=vlanCfgStat, aTPCTable=aTPCTable, modemSeverelyErroredSecondRatio=modemSeverelyErroredSecondRatio, localIp=localIp, microwaveRadio=microwaveRadio, radioEntry=radioEntry, atpcIndex=atpcIndex, e1t1StatEntry=e1t1StatEntry, modemCountTime=modemCountTime, vlanNumber=vlanNumber, modemACMmodulationMax=modemACMmodulationMax, ethTXByteCounterHi=ethTXByteCounterHi, ethQOSRXQ2Dropped=ethQOSRXQ2Dropped, ethTXLengthCheckErrors=ethTXLengthCheckErrors, modemGeneralStatus=modemGeneralStatus, radioTxPower=radioTxPower, vlanPortmap=vlanPortmap, licenseMask=licenseMask, modemUnavailtime=modemUnavailtime, modemLDPCdecoderStress=modemLDPCdecoderStress, ethTXBroadcasts=ethTXBroadcasts, modemEntry=modemEntry, ethQOSRXQ1Frames=ethQOSRXQ1Frames, ethRXTruncatedFrames=ethRXTruncatedFrames, ipRadioMgmt=ipRadioMgmt, ethRXCRCErrors=ethRXCRCErrors, ethTXExcessiveDefers=ethTXExcessiveDefers, modemUptime=modemUptime, modemBackgroundBlockErrorRatio=modemBackgroundBlockErrorRatio, safip=safip, atpcTxPowerCorrection=atpcTxPowerCorrection, radioIndex=radioIndex, radioTxMute=radioTxMute, vlanEntry=vlanEntry, modemErroredSecondRatio=modemErroredSecondRatio, modemAcqStatus=modemAcqStatus, ethGFPDropedFrames=ethGFPDropedFrames, licenseUpdateStatus=licenseUpdateStatus, ethTXUnderruns=ethTXUnderruns, modemE1T1Channels=modemE1T1Channels, sysDateAndTime=sysDateAndTime, modemBackgroundBlockErrror=modemBackgroundBlockErrror, radioTxFrequency=radioTxFrequency, ethQOSTXDropped=ethQOSTXDropped, modemSymbolRateRx=modemSymbolRateRx, modemTotalCapacity=modemTotalCapacity, ethRXByteCounterHi=ethRXByteCounterHi, ethTXWireByteCounterLow=ethTXWireByteCounterLow, vlansEnabled=vlansEnabled, vlanTable=vlanTable, ethQOSRXQ1Dropped=ethQOSRXQ1Dropped, ethRXOutOfRangeErrors=ethRXOutOfRangeErrors, modemStatistics=modemStatistics, remoteIp=remoteIp, ethTXPauseFrames=ethTXPauseFrames, e1t1StatTable=e1t1StatTable, ethQOSTXFrames=ethQOSTXFrames, atpcEnabled=atpcEnabled, ethTXWireByteCounterHi=ethTXWireByteCounterHi, ipRadioStat=ipRadioStat, e1t1ChannelNr=e1t1ChannelNr, ethRXByteCounterLow=ethRXByteCounterLow, license=license, ethRXUnsupOpcodes=ethRXUnsupOpcodes, ethGFPCHECErrors=ethGFPCHECErrors, modemACMmodulationMin=modemACMmodulationMin, ethGFPFCSErrors=ethGFPFCSErrors, modemLastAcqError=modemLastAcqError, ethRXCodeErrors=ethRXCodeErrors, modemACMtotalCapacity=modemACMtotalCapacity, ethRXMulticasts=ethRXMulticasts, ethRXControlFrames=ethRXControlFrames, sysTemperature=sysTemperature, ethTXDones=ethTXDones, ethRXPrevPktDropped=ethRXPrevPktDropped, radioRxFrequency=radioRxFrequency, writeConfig=writeConfig, restartcpu=restartcpu, modemBandwith=modemBandwith, ethTXControlFrames=ethTXControlFrames, radioRxLevel=radioRxLevel, ethTXCRCErrors=ethTXCRCErrors, ethTXCollisions=ethTXCollisions, vlanRowStatus=vlanRowStatus, ethTXGiants=ethTXGiants, ethRXVlanTagsDetected=ethRXVlanTagsDetected, product=product, ethTXLateCollisions=ethTXLateCollisions, modemErroredSecond=modemErroredSecond, pointToPoint=pointToPoint, ethRXPauseFrames=ethRXPauseFrames, modemStandard=modemStandard, ethRXFalseCarrierErrors=ethRXFalseCarrierErrors, modemSymbolRateTx=modemSymbolRateTx, ethRXDvEvent=ethRXDvEvent, ipRadioCfgGeneral=ipRadioCfgGeneral, aTPCEntry=aTPCEntry, saf=saf, radioTable=radioTable, modemErroredBlock=modemErroredBlock, ipRadioCfg=ipRadioCfg, modemRadialMSE=modemRadialMSE, loopback_tributary_mask=loopback_tributary_mask, hostname=hostname, description=description, modemModulation=modemModulation, modemEthernetCapacity=modemEthernetCapacity, ethRXDones=ethRXDones, modemSeverelyErroredSecond=modemSeverelyErroredSecond, radioDuplexShift=radioDuplexShift, loopbacks=loopbacks, ethGFPDelineationErrors=ethGFPDelineationErrors, radioGenStatus=radioGenStatus, ethQOSRXQ2Frames=ethQOSRXQ2Frames, ethTXMaxCollisions=ethTXMaxCollisions, ethRXLongEvents=ethRXLongEvents, modemTable=modemTable, e1t1AIS=e1t1AIS, ethRXBroadcasts=ethRXBroadcasts, ethTXMulticasts=ethTXMulticasts, ethTXBackpresEvents=ethTXBackpresEvents, tehnika=tehnika, localIpMask=localIpMask, modemACMethernetCapacity=modemACMethernetCapacity, radioSide=radioSide, modemACMengine=modemACMengine, ethTXByteCounterLow=ethTXByteCounterLow, modemInternalAGCgain=modemInternalAGCgain, ethRXDribleNibbles=ethRXDribleNibbles, modemRowStatus=modemRowStatus, ipRadio=ipRadio, vlanPortType=vlanPortType, modemCarrierOffset=modemCarrierOffset, ethTXNonExcessiveDefers=ethTXNonExcessiveDefers, ipRadioStatEth=ipRadioStatEth, ethRXLengthCheckerrorsErrors=ethRXLengthCheckerrorsErrors, modemIndex=modemIndex, radioLoopback=radioLoopback, ipRadioCfgNetwork=ipRadioCfgNetwork, vlanFid=vlanFid)
