#
# PySNMP MIB module IANA-ENTITY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/iana/IANA-ENTITY-MIB
# Produced by pysmi-1.1.8 at Tue Sep 12 06:52:34 2023
# On host fv-az442-605 platform Linux version 5.15.0-1041-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, ObjectIdentity, Gauge32, MibIdentifier, Integer32, mib_2, iso, Counter64, Unsigned32, Bits, Counter32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "ObjectIdentity", "Gauge32", "MibIdentifier", "Integer32", "mib-2", "iso", "Counter64", "Unsigned32", "Bits", "Counter32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ianaEntityMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 216))
ianaEntityMIB.setRevisions(('2015-07-16 00:00', '2015-07-16 00:00', '2013-04-05 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ianaEntityMIB.setRevisionsDescriptions(("Removed space between 'battery' and '(14)'.", 'Added storageDrive(15).', 'Initial version of this MIB as published in\n                     RFC 6933.',))
if mibBuilder.loadTexts: ianaEntityMIB.setLastUpdated('201507160000Z')
if mibBuilder.loadTexts: ianaEntityMIB.setOrganization('IANA')
if mibBuilder.loadTexts: ianaEntityMIB.setContactInfo('Internet Assigned Numbers Authority\n                  Postal: ICANN\n                           12025 Waterfront Drive, Suite 300\n                           Los Angeles, CA 90094-2536\n\n                  Phone: +1-310-301-5800\n                  EMail: iana&iana.org')
if mibBuilder.loadTexts: ianaEntityMIB.setDescription("This MIB module defines a TEXTUAL-CONVENTION that provides\n          an indication of the general hardware type of a particular\n          physical entity.\n\n          Copyright (c) 2013 IETF Trust and the persons identified as\n          authors of the code.  All rights reserved.\n\n           Redistribution and use in source and binary forms, with or\n           without modification, is permitted pursuant to, and subject\n           to the license terms contained in, the Simplified BSD\n           License set forth in Section 4.c of the IETF Trust's Legal\n           Provisions Relating to IETF Documents\n           (http://trustee.ietf.org/license-info).\n\n           The initial version of this MIB module was published in\n           RFC 6933; for full legal notices see the RFC itself.")
class IANAPhysicalClass(TextualConvention, Integer32):
    description = "An enumerated value that provides an indication of the\n           general hardware type of a particular physical entity.\n           There are no restrictions as to the number of\n           entPhysicalEntries of each entPhysicalClass, which must\n           be instantiated by an agent.\n\n           The enumeration 'other' is applicable if the physical\n           entity class is known but does not match any of the\n           supported values.\n\n           The enumeration 'unknown' is applicable if the physical\n           entity class is unknown to the agent.\n\n           The enumeration 'chassis' is applicable if the physical\n           entity class is an overall container for networking\n           equipment.  Any class of physical entity, except a stack,\n           may be contained within a chassis; a chassis may only\n           be contained within a stack.\n\n           The enumeration 'backplane' is applicable if the physical\n           entity class is some sort of device for aggregating and\n           forwarding networking traffic, such as a shared\n           backplane in a modular ethernet switch.  Note that an\n           agent may model a backplane as a single physical entity,\n           which is actually implemented as multiple discrete\n           physical components (within a chassis or stack).\n\n           The enumeration 'container' is applicable if the\n           physical entity class is capable of containing one or\n           more removable physical entities, possibly of different\n           types.  For example, each (empty or full) slot in a\n           chassis will be modeled as a container.  Note that all\n           removable physical entities should be modeled within\n           a container entity, such as field-replaceable modules,\n           fans, or power supplies.  Note that all known containers\n           should be modeled by the agent, including empty\n           containers.\n\n           The enumeration 'powerSupply' is applicable if the\n           physical entity class is a power-supplying component.\n\n           The enumeration 'fan' is applicable if the physical\n           entity class is a fan or other heat-reduction component.\n\n           The enumeration 'sensor' is applicable if the physical\n           entity class is some sort of sensor, such as a\n           temperature sensor within a router chassis.\n\n           The enumeration 'module' is applicable if the physical\n           entity class is some sort of self-contained sub-system.\n           If the enumeration 'module' is removable, then it should\n           be modeled within a container entity; otherwise, it\n           should be modeled directly within another physical\n           entity (e.g., a chassis or another module).\n\n           The enumeration 'port' is applicable if the physical\n           entity class is some sort of networking port, capable\n           of receiving and/or transmitting networking traffic.\n\n           The enumeration 'stack' is applicable if the physical\n           entity class is some sort of super-container (possibly\n           virtual) intended to group together multiple chassis\n           entities.  A stack may be realized by a 'virtual' cable,\n           a real interconnect cable attached to multiple chassis,\n           or multiple interconnect cables.  A stack should not be\n           modeled within any other physical entities, but a stack\n           may be contained within another stack.  Only chassis\n           entities should be contained within a stack.\n\n           The enumeration 'cpu' is applicable if the physical\n           entity class is some sort of central processing unit.\n\n           The enumeration 'energyObject' is applicable if the\n           physical entity is some sort of energy object, i.e.,\n           a piece of equipment that is part of or attached to\n           a communications network that is monitored, controlled,\n           or aids in the management of another device for Energy\n           Management.\n\n           The enumeration 'battery' is applicable if the physical\n           entity class is some sort of battery.\n\n           The enumeration 'storageDrive' is applicable if the \n           physical entity class is some sort of entity with data \n           storage capability as main functionality, e.g. disk drive \n           (HDD), solid state device (SSD), hybrid (SSHD), object \n           storage (OSD) or other."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("chassis", 3), ("backplane", 4), ("container", 5), ("powerSupply", 6), ("fan", 7), ("sensor", 8), ("module", 9), ("port", 10), ("stack", 11), ("cpu", 12), ("energyObject", 13), ("battery", 14), ("storageDrive", 15))

mibBuilder.exportSymbols("IANA-ENTITY-MIB", PYSNMP_MODULE_ID=ianaEntityMIB, IANAPhysicalClass=IANAPhysicalClass, ianaEntityMIB=ianaEntityMIB)
