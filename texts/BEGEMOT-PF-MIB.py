#
# PySNMP MIB module BEGEMOT-PF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/pfsense/BEGEMOT-PF-MIB
# Produced by pysmi-1.1.12 at Mon Oct  7 02:57:19 2024
# On host fv-az775-99 platform Linux version 6.8.0-1014-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
begemot, = mibBuilder.importSymbols("BEGEMOT-MIB", "begemot")
InetAddress, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, MibIdentifier, TimeTicks, Integer32, ObjectIdentity, Counter32, Gauge32, Bits, Counter64, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "MibIdentifier", "TimeTicks", "Integer32", "ObjectIdentity", "Counter32", "Gauge32", "Bits", "Counter64", "IpAddress")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
begemotPf = ModuleIdentity((1, 3, 6, 1, 4, 1, 12325, 1, 200))
begemotPf.setRevisions(('2010-03-18 00:00', '2009-12-05 00:00', '2005-01-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: begemotPf.setRevisionsDescriptions(('Modified pfTablesAddrEntry to support IPv6\n\t\taddresses - added pfTablesAddrNetType column\n\t\tand modified type of pfTablesAddrNet to\n\t\tInetAddress.', 'Added support for retrieving counters of labeled\n\t    pf filter rules via pfLabelspfLabels subtree.', 'Initial revision.',))
if mibBuilder.loadTexts: begemotPf.setLastUpdated('201003180000Z')
if mibBuilder.loadTexts: begemotPf.setOrganization('NixSys BVBA')
if mibBuilder.loadTexts: begemotPf.setContactInfo('\t\tPhilip Paeps\n\n\t     Postal:\tNixSys BVBA\n\t\t\tLouizastraat 14\n\t\t\tBE-2800 Mechelen\n\t\t\tBelgium\n\n\t     E-Mail:\tphilip@FreeBSD.org')
if mibBuilder.loadTexts: begemotPf.setDescription('The Begemot MIB for the pf packet filter.')
begemotPfObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1))
pfStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1))
pfCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2))
pfStateTable = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3))
pfSrcNodes = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4))
pfLimits = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5))
pfTimeouts = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6))
pfLogInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7))
pfInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8))
pfTables = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9))
pfAltq = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10))
pfLabels = MibIdentifier((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11))
pfStatusRunning = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusRunning.setStatus('current')
if mibBuilder.loadTexts: pfStatusRunning.setDescription('True if pf is currently enabled.')
pfStatusRuntime = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 2), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusRuntime.setStatus('current')
if mibBuilder.loadTexts: pfStatusRuntime.setDescription('Indicates how long pf has been enabled.  If pf is not currently\n\tenabled, indicates how long it has been disabled.  If pf has not\n\tbeen enabled or disabled since the system was started, the value\n\twill be 0.')
pfStatusDebug = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("urgent", 1), ("misc", 2), ("loud", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusDebug.setStatus('current')
if mibBuilder.loadTexts: pfStatusDebug.setDescription('Indicates the debug level at which pf is running.')
pfStatusHostId = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStatusHostId.setStatus('current')
if mibBuilder.loadTexts: pfStatusHostId.setDescription('The (unique) host identifier of the machine running pf.')
pfCounterMatch = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterMatch.setStatus('current')
if mibBuilder.loadTexts: pfCounterMatch.setDescription('Number of packets that matched a filter rule.')
pfCounterBadOffset = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterBadOffset.setStatus('current')
if mibBuilder.loadTexts: pfCounterBadOffset.setDescription('Number of packets with bad offset.')
pfCounterFragment = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterFragment.setStatus('current')
if mibBuilder.loadTexts: pfCounterFragment.setDescription('Number of fragmented packets.')
pfCounterShort = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterShort.setStatus('current')
if mibBuilder.loadTexts: pfCounterShort.setDescription('Number of short packets.')
pfCounterNormalize = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterNormalize.setStatus('current')
if mibBuilder.loadTexts: pfCounterNormalize.setDescription('Number of normalized packets.')
pfCounterMemDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 2, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfCounterMemDrop.setStatus('current')
if mibBuilder.loadTexts: pfCounterMemDrop.setDescription('Number of packets dropped due to memory limitations.')
pfStateTableCount = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableCount.setStatus('current')
if mibBuilder.loadTexts: pfStateTableCount.setDescription('Number of entries in the state table.')
pfStateTableSearches = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableSearches.setStatus('current')
if mibBuilder.loadTexts: pfStateTableSearches.setDescription('Number of searches against the state table.')
pfStateTableInserts = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableInserts.setStatus('current')
if mibBuilder.loadTexts: pfStateTableInserts.setDescription('Number of entries inserted into the state table.')
pfStateTableRemovals = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 3, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfStateTableRemovals.setStatus('current')
if mibBuilder.loadTexts: pfStateTableRemovals.setDescription('Number of entries removed from the state table.')
pfSrcNodesCount = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesCount.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesCount.setDescription('Number of entries in the source tracking table.')
pfSrcNodesSearches = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesSearches.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesSearches.setDescription('Number of searches against the source tracking table.')
pfSrcNodesInserts = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesInserts.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesInserts.setDescription('Number of entries inserted into the source tracking table.')
pfSrcNodesRemovals = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 4, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfSrcNodesRemovals.setStatus('current')
if mibBuilder.loadTexts: pfSrcNodesRemovals.setDescription('Number of entries removed from the source tracking table.')
pfLimitsStates = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsStates.setStatus('current')
if mibBuilder.loadTexts: pfLimitsStates.setDescription("Maximum number of 'keep state' rules in the ruleset.")
pfLimitsSrcNodes = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsSrcNodes.setStatus('current')
if mibBuilder.loadTexts: pfLimitsSrcNodes.setDescription("Maximum number of 'sticky-address' or 'source-track' rules\n\tin the ruleset.")
pfLimitsFrags = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 5, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLimitsFrags.setStatus('current')
if mibBuilder.loadTexts: pfLimitsFrags.setDescription("Maximum number of 'scrub' rules in the ruleset.")
pfTimeoutsTcpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpFirst.setDescription('State after the first packet in a connection.')
pfTimeoutsTcpOpening = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpOpening.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpOpening.setDescription('State before the destination host ever sends a packet.')
pfTimeoutsTcpEstablished = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpEstablished.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpEstablished.setDescription('The fully established state.')
pfTimeoutsTcpClosing = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpClosing.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpClosing.setDescription('State after the first FIN has been sent.')
pfTimeoutsTcpFinWait = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpFinWait.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpFinWait.setDescription('State after both FINs have been exchanged and the\n\tconnection is closed.')
pfTimeoutsTcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsTcpClosed.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsTcpClosed.setDescription('State after one endpoint sends an RST.')
pfTimeoutsUdpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpFirst.setDescription('State after the first packet.')
pfTimeoutsUdpSingle = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpSingle.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpSingle.setDescription('State if the source host sends more than one packet but\n\tthe destination host has never sent one back.')
pfTimeoutsUdpMultiple = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsUdpMultiple.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsUdpMultiple.setDescription('State if both hosts have sent packets.')
pfTimeoutsIcmpFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsIcmpFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsIcmpFirst.setDescription('State after the first packet.')
pfTimeoutsIcmpError = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsIcmpError.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsIcmpError.setDescription('State after an ICMP error came back in response to an\n\tICMP packet.')
pfTimeoutsOtherFirst = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherFirst.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherFirst.setDescription('State after the first packet.')
pfTimeoutsOtherSingle = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherSingle.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherSingle.setDescription('State if the source host sends more than one packet but\n\tthe destination host has never sent one back.')
pfTimeoutsOtherMultiple = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsOtherMultiple.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsOtherMultiple.setDescription('State if both hosts have sent packets.')
pfTimeoutsFragment = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsFragment.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsFragment.setDescription('Seconds before an unassembled fragment is expired.')
pfTimeoutsInterval = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsInterval.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsInterval.setDescription('Interval between purging expired states and fragments.')
pfTimeoutsAdaptiveStart = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsAdaptiveStart.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsAdaptiveStart.setDescription('When the number of state entries exceeds this value,\n\tadaptive scaling begins.')
pfTimeoutsAdaptiveEnd = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsAdaptiveEnd.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsAdaptiveEnd.setDescription('When reaching this number of state entries, all timeout\n\tvalues become zero, effectively purging all state entries\n\timmediately.')
pfTimeoutsSrcNode = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 6, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTimeoutsSrcNode.setStatus('current')
if mibBuilder.loadTexts: pfTimeoutsSrcNode.setDescription('Length of time to retain a source tracking entry after\n\tthe last state expires.')
pfLogInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceName.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceName.setDescription("The name of the interface configured with 'set loginterface'.\n\tIf no interface has been configured, the object will be empty.")
pfLogInterfaceIp4BytesIn = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesIn.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesIn.setDescription('Number of IPv4 bytes passed in on the loginterface.')
pfLogInterfaceIp4BytesOut = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesOut.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4BytesOut.setDescription('Number of IPv4 bytes passed out on the loginterface.')
pfLogInterfaceIp4PktsInPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInPass.setDescription('Number of IPv4 packets passed in on the loginterface.')
pfLogInterfaceIp4PktsInDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsInDrop.setDescription('Number of IPv4 packets dropped coming in on the loginterface.')
pfLogInterfaceIp4PktsOutPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutPass.setDescription('Number of IPv4 packets passed out on the loginterface.')
pfLogInterfaceIp4PktsOutDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp4PktsOutDrop.setDescription('Number of IPv4 packets dropped going out on the loginterface.')
pfLogInterfaceIp6BytesIn = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesIn.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesIn.setDescription('Number of IPv6 bytes passed in on the loginterface.')
pfLogInterfaceIp6BytesOut = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesOut.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6BytesOut.setDescription('Number of IPv6 bytes passed out on the loginterface.')
pfLogInterfaceIp6PktsInPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInPass.setDescription('Number of IPv6 packets passed in on the loginterface.')
pfLogInterfaceIp6PktsInDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsInDrop.setDescription('Number of IPv6 packets dropped coming in on the loginterface.')
pfLogInterfaceIp6PktsOutPass = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutPass.setDescription('Number of IPv6 packets passed out on the loginterface.')
pfLogInterfaceIp6PktsOutDrop = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 7, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutDrop.setStatus('current')
if mibBuilder.loadTexts: pfLogInterfaceIp6PktsOutDrop.setDescription('Number of IPv6 packets dropped going out on the loginterface.')
pfInterfacesIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfNumber.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfNumber.setDescription('The number of network interfaces on this system.')
pfInterfacesIfTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2), )
if mibBuilder.loadTexts: pfInterfacesIfTable.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfTable.setDescription('Table of network interfaces, indexed on pfInterfacesIfNumber.')
pfInterfacesIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfInterfacesIfIndex"))
if mibBuilder.loadTexts: pfInterfacesIfEntry.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfEntry.setDescription('An entry in the pfInterfacesIfTable containing information\n\tabout a particular network interface in the machine.')
pfInterfacesIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfInterfacesIfIndex.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfIndex.setDescription('A unique value, greater than zero, for each interface.')
pfInterfacesIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfDescr.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfDescr.setDescription('The name of the interface.')
pfInterfacesIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("group", 0), ("instance", 1), ("detached", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfType.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfType.setDescription('Indicates whether the interface is a group inteface, an\n\tinterface instance, or whether it has been removed or\n\tdestroyed.')
pfInterfacesIfTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 4), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfTZero.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfTZero.setDescription('Time since statistics were last reset or since the\n\tinterface was loaded.')
pfInterfacesIfRefsState = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfRefsState.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfRefsState.setDescription('The number of state and/or source track entries referencing\n\tthis interface.')
pfInterfacesIfRefsRule = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIfRefsRule.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIfRefsRule.setDescription('The number of rules referencing this interface.')
pfInterfacesIf4BytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesInPass.setDescription('The number of IPv4 bytes passed coming in on this interface.')
pfInterfacesIf4BytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesInBlock.setDescription('The number of IPv4 bytes blocked coming in on this interface.')
pfInterfacesIf4BytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutPass.setDescription('The number of IPv4 bytes passed going out on this interface.')
pfInterfacesIf4BytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4BytesOutBlock.setDescription('The number of IPv4 bytes blocked going out on this interface.')
pfInterfacesIf4PktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsInPass.setDescription('The number of IPv4 packets passed coming in on this interface.')
pfInterfacesIf4PktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsInBlock.setDescription('The number of IPv4 packets blocked coming in on this interface.')
pfInterfacesIf4PktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutPass.setDescription('The number of IPv4 packets passed going out on this interface.')
pfInterfacesIf4PktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf4PktsOutBlock.setDescription('The number of IPv4 packets blocked going out on this interface.')
pfInterfacesIf6BytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesInPass.setDescription('The number of IPv6 bytes passed coming in on this interface.')
pfInterfacesIf6BytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesInBlock.setDescription('The number of IPv6 bytes blocked coming in on this interface.')
pfInterfacesIf6BytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutPass.setDescription('The number of IPv6 bytes passed going out on this interface.')
pfInterfacesIf6BytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6BytesOutBlock.setDescription('The number of IPv6 bytes blocked going out on this interface.')
pfInterfacesIf6PktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsInPass.setDescription('The number of IPv6 packets passed coming in on this interface.')
pfInterfacesIf6PktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsInBlock.setDescription('The number of IPv6 packets blocked coming in on this interface.')
pfInterfacesIf6PktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutPass.setDescription('The number of IPv6 packets passed going out on this interface.')
pfInterfacesIf6PktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 8, 2, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfInterfacesIf6PktsOutBlock.setDescription('The number of IPv6 packets blocked going out on this interface.')
pfTablesTblNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblNumber.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblNumber.setDescription('The number of tables on this system.')
pfTablesTblTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2), )
if mibBuilder.loadTexts: pfTablesTblTable.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblTable.setDescription('Table of tables, index on pfTablesTblIndex.')
pfTablesTblEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfTablesTblIndex"))
if mibBuilder.loadTexts: pfTablesTblEntry.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEntry.setDescription('Any entry in the pfTablesTblTable containing information\n\tabout a particular table on the system.')
pfTablesTblIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfTablesTblIndex.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblIndex.setDescription('A unique value, greater than zero, for each table.')
pfTablesTblDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblDescr.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblDescr.setDescription('The name of the table.')
pfTablesTblCount = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblCount.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblCount.setDescription('The number of addresses in the table.')
pfTablesTblTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 4), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblTZero.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblTZero.setDescription('The time passed since the statistics of this table were last\n        cleared or the time since this table was loaded, whichever is\n        sooner.')
pfTablesTblRefsAnchor = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblRefsAnchor.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblRefsAnchor.setDescription('The number of anchors referencing this table.')
pfTablesTblRefsRule = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblRefsRule.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblRefsRule.setDescription('The number of rules referencing this table.')
pfTablesTblEvalMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblEvalMatch.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEvalMatch.setDescription('The number of evaluations returning a match.')
pfTablesTblEvalNoMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblEvalNoMatch.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblEvalNoMatch.setDescription('The number of evaluations not returning a match.')
pfTablesTblBytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInPass.setDescription('The number of bytes passed in matching the table.')
pfTablesTblBytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInBlock.setDescription('The number of bytes blocked coming in matching the table.')
pfTablesTblBytesInXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesInXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesInXPass.setDescription('The number of bytes statefully passed in where the state\n        entry refers to the table, but the table no longer contains\n\tthe address in question.')
pfTablesTblBytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutPass.setDescription('The number of bytes passed out matching the table.')
pfTablesTblBytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutBlock.setDescription('The number of bytes blocked going out matching the table.')
pfTablesTblBytesOutXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblBytesOutXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblBytesOutXPass.setDescription('The number of bytes statefully passed out where the state\n        entry refers to the table, but the table no longer contains\n\tthe address in question.')
pfTablesTblPktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInPass.setDescription('The number of packets passed in matching the table.')
pfTablesTblPktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInBlock.setDescription('The number of packets blocked coming in matching the table.')
pfTablesTblPktsInXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsInXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsInXPass.setDescription('The number of packets statefully passed in where the state\n        entry refers to the table, but the table no longer contains\n\tthe address in question.')
pfTablesTblPktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutPass.setDescription('The number of packets passed out matching the table.')
pfTablesTblPktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutBlock.setDescription('The number of packets blocked going out matching the table.')
pfTablesTblPktsOutXPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesTblPktsOutXPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesTblPktsOutXPass.setDescription('The number of packets statefully passed out where the state\n        entry refers to the table, but the table no longer contains\n\tthe address in question.')
pfTablesAddrTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3), )
if mibBuilder.loadTexts: pfTablesAddrTable.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrTable.setDescription('Table of addresses from every table on the system.')
pfTablesAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfTablesAddrIndex"))
if mibBuilder.loadTexts: pfTablesAddrEntry.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrEntry.setDescription('An entry in the pfTablesAddrTable containing information\n        about a particular entry in a table.')
pfTablesAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfTablesAddrIndex.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrIndex.setDescription('A unique value, greater than zero, for each address.')
pfTablesAddrNetType = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrNetType.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrNetType.setDescription('The type of address in the corresponding pfTablesAddrNet object.')
pfTablesAddrNet = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrNet.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrNet.setDescription('The IP address of this particular table entry.')
pfTablesAddrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 4), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPrefix.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPrefix.setDescription('The CIDR netmask of this particular table entry.')
pfTablesAddrTZero = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 5), TimeTicks()).setUnits('1/100th of a Second').setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrTZero.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrTZero.setDescription("The time passed since this entry's statistics were last\n\tcleared, or the time passed since this entry was loaded\n\tinto the table, whichever is sooner.")
pfTablesAddrBytesInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesInPass.setDescription('The number of inbound bytes passed as a result of this entry.')
pfTablesAddrBytesInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesInBlock.setDescription('The number of inbound bytes blocked as a result of this entry.')
pfTablesAddrBytesOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesOutPass.setDescription('The number of outbound bytes passed as a result of this entry.')
pfTablesAddrBytesOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrBytesOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrBytesOutBlock.setDescription('The number of outbound bytes blocked as a result of this entry.')
pfTablesAddrPktsInPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsInPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsInPass.setDescription('The number of inbound packets passed as a result of this entry.')
pfTablesAddrPktsInBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsInBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsInBlock.setDescription('The number of inbound packets blocked as a result of this entry.')
pfTablesAddrPktsOutPass = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsOutPass.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsOutPass.setDescription('The number of outbound packets passed as a result of this entry.')
pfTablesAddrPktsOutBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 9, 3, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfTablesAddrPktsOutBlock.setStatus('current')
if mibBuilder.loadTexts: pfTablesAddrPktsOutBlock.setDescription('The number of outbound packets blocked as a result of this\n        entry.')
pfAltqQueueNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueNumber.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueNumber.setDescription('The number of queues in the active set.')
pfAltqQueueTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2), )
if mibBuilder.loadTexts: pfAltqQueueTable.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueTable.setDescription('Table containing the rules that are active on this system.')
pfAltqQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfAltqQueueIndex"))
if mibBuilder.loadTexts: pfAltqQueueEntry.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueEntry.setDescription('An entry in the pfAltqQueueTable table.')
pfAltqQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfAltqQueueIndex.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueIndex.setDescription('A unique value, greater than zero, for each queue.')
pfAltqQueueDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueDescr.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueDescr.setDescription('The name of the queue.')
pfAltqQueueParent = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueParent.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueParent.setDescription("Name of the queue's parent if it has one.")
pfAltqQueueScheduler = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 11))).clone(namedValues=NamedValues(("cbq", 1), ("hfsc", 8), ("priq", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueScheduler.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueScheduler.setDescription('Scheduler algorithm implemented by this queue.')
pfAltqQueueBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueBandwidth.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueBandwidth.setDescription('Bandwitch assigned to this queue.')
pfAltqQueuePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueuePriority.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueuePriority.setDescription('Priority level of the queue.')
pfAltqQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 10, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfAltqQueueLimit.setStatus('current')
if mibBuilder.loadTexts: pfAltqQueueLimit.setDescription('Maximum number of packets in the queue.')
pfLabelsLblNumber = MibScalar((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblNumber.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblNumber.setDescription('The number of labeled filter rules on this system.')
pfLabelsLblTable = MibTable((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2), )
if mibBuilder.loadTexts: pfLabelsLblTable.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblTable.setDescription('Table of filter rules, index on pfLabelsLblIndex.')
pfLabelsLblEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1), ).setIndexNames((0, "BEGEMOT-PF-MIB", "pfLabelsLblIndex"))
if mibBuilder.loadTexts: pfLabelsLblEntry.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblEntry.setDescription('Any entry in the pfLabelsLblTable containing information\n\tabout a particular filter rule on the system.')
pfLabelsLblIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pfLabelsLblIndex.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblIndex.setDescription('A unique value, greater than zero, for each label.')
pfLabelsLblName = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblName.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblName.setDescription('The name of the rule label.')
pfLabelsLblEvals = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblEvals.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblEvals.setDescription('The number of rule evaluations.')
pfLabelsLblBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblBytesIn.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblBytesIn.setDescription('The number of incoming bytes matched by the rule.')
pfLabelsLblBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblBytesOut.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblBytesOut.setDescription('The number of outgoing bytes matched by the rule.')
pfLabelsLblPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblPktsIn.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblPktsIn.setDescription('The number of incoming packets matched by the rule.')
pfLabelsLblPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 12325, 1, 200, 1, 11, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pfLabelsLblPktsOut.setStatus('current')
if mibBuilder.loadTexts: pfLabelsLblPktsOut.setDescription('The number of outgoing packets matched by the rule.')
mibBuilder.exportSymbols("BEGEMOT-PF-MIB", pfTimeoutsTcpOpening=pfTimeoutsTcpOpening, pfTablesTblBytesOutPass=pfTablesTblBytesOutPass, pfTimeoutsTcpClosing=pfTimeoutsTcpClosing, pfLimits=pfLimits, pfLabelsLblBytesOut=pfLabelsLblBytesOut, pfTimeoutsUdpFirst=pfTimeoutsUdpFirst, pfTablesAddrTZero=pfTablesAddrTZero, pfInterfacesIf4PktsOutPass=pfInterfacesIf4PktsOutPass, pfTablesTblBytesInXPass=pfTablesTblBytesInXPass, pfSrcNodes=pfSrcNodes, pfLogInterfaceIp4PktsOutPass=pfLogInterfaceIp4PktsOutPass, pfTablesTblCount=pfTablesTblCount, pfSrcNodesRemovals=pfSrcNodesRemovals, pfAltq=pfAltq, pfInterfacesIfRefsState=pfInterfacesIfRefsState, pfSrcNodesSearches=pfSrcNodesSearches, pfInterfacesIf6PktsOutBlock=pfInterfacesIf6PktsOutBlock, pfStatusRunning=pfStatusRunning, pfTimeoutsAdaptiveStart=pfTimeoutsAdaptiveStart, pfTablesAddrPrefix=pfTablesAddrPrefix, pfStatusHostId=pfStatusHostId, pfTablesTblRefsAnchor=pfTablesTblRefsAnchor, pfAltqQueueParent=pfAltqQueueParent, pfInterfacesIfEntry=pfInterfacesIfEntry, PYSNMP_MODULE_ID=begemotPf, pfStatusDebug=pfStatusDebug, pfStateTableRemovals=pfStateTableRemovals, pfTablesAddrPktsInPass=pfTablesAddrPktsInPass, pfTablesTblEvalNoMatch=pfTablesTblEvalNoMatch, pfTablesTblIndex=pfTablesTblIndex, pfStateTableSearches=pfStateTableSearches, pfTablesAddrBytesInPass=pfTablesAddrBytesInPass, pfAltqQueueBandwidth=pfAltqQueueBandwidth, pfTablesTblBytesInPass=pfTablesTblBytesInPass, pfInterfacesIf6BytesInBlock=pfInterfacesIf6BytesInBlock, pfTablesAddrBytesInBlock=pfTablesAddrBytesInBlock, pfCounterBadOffset=pfCounterBadOffset, pfLogInterfaceIp6PktsInPass=pfLogInterfaceIp6PktsInPass, pfTimeoutsFragment=pfTimeoutsFragment, pfLimitsStates=pfLimitsStates, pfTablesTblPktsOutPass=pfTablesTblPktsOutPass, pfTimeoutsSrcNode=pfTimeoutsSrcNode, pfTablesTblPktsInBlock=pfTablesTblPktsInBlock, pfStateTableCount=pfStateTableCount, pfTablesTblNumber=pfTablesTblNumber, pfTablesAddrIndex=pfTablesAddrIndex, pfTimeoutsUdpMultiple=pfTimeoutsUdpMultiple, pfTablesAddrTable=pfTablesAddrTable, pfTablesTblTable=pfTablesTblTable, pfTablesTblPktsOutXPass=pfTablesTblPktsOutXPass, pfInterfacesIfDescr=pfInterfacesIfDescr, pfTablesAddrEntry=pfTablesAddrEntry, pfTablesTblEvalMatch=pfTablesTblEvalMatch, pfCounterMemDrop=pfCounterMemDrop, pfLogInterfaceIp6PktsOutDrop=pfLogInterfaceIp6PktsOutDrop, pfTablesTblTZero=pfTablesTblTZero, pfAltqQueueEntry=pfAltqQueueEntry, pfCounterNormalize=pfCounterNormalize, pfInterfacesIf6PktsOutPass=pfInterfacesIf6PktsOutPass, pfLabelsLblIndex=pfLabelsLblIndex, pfAltqQueueDescr=pfAltqQueueDescr, pfTablesAddrNetType=pfTablesAddrNetType, pfCounter=pfCounter, pfTimeoutsTcpFirst=pfTimeoutsTcpFirst, pfTimeouts=pfTimeouts, pfCounterFragment=pfCounterFragment, pfLimitsFrags=pfLimitsFrags, pfTimeoutsAdaptiveEnd=pfTimeoutsAdaptiveEnd, pfLogInterfaceIp4BytesIn=pfLogInterfaceIp4BytesIn, pfTablesTblBytesOutBlock=pfTablesTblBytesOutBlock, pfTablesAddrBytesOutPass=pfTablesAddrBytesOutPass, pfLabelsLblTable=pfLabelsLblTable, pfTablesTblPktsInXPass=pfTablesTblPktsInXPass, pfTablesAddrPktsInBlock=pfTablesAddrPktsInBlock, pfLabelsLblEntry=pfLabelsLblEntry, pfLabelsLblName=pfLabelsLblName, pfInterfacesIf4PktsInPass=pfInterfacesIf4PktsInPass, pfInterfacesIf6PktsInBlock=pfInterfacesIf6PktsInBlock, pfTimeoutsOtherSingle=pfTimeoutsOtherSingle, pfLogInterface=pfLogInterface, pfTablesTblBytesOutXPass=pfTablesTblBytesOutXPass, pfInterfacesIf4BytesInPass=pfInterfacesIf4BytesInPass, pfTimeoutsTcpEstablished=pfTimeoutsTcpEstablished, pfLabelsLblEvals=pfLabelsLblEvals, pfTimeoutsIcmpError=pfTimeoutsIcmpError, pfInterfaces=pfInterfaces, pfInterfacesIf4PktsInBlock=pfInterfacesIf4PktsInBlock, begemotPf=begemotPf, pfTablesAddrNet=pfTablesAddrNet, pfInterfacesIf4BytesOutBlock=pfInterfacesIf4BytesOutBlock, pfStateTable=pfStateTable, pfCounterShort=pfCounterShort, pfInterfacesIfTable=pfInterfacesIfTable, pfAltqQueueScheduler=pfAltqQueueScheduler, pfAltqQueuePriority=pfAltqQueuePriority, pfTimeoutsTcpClosed=pfTimeoutsTcpClosed, pfStateTableInserts=pfStateTableInserts, pfSrcNodesCount=pfSrcNodesCount, pfLogInterfaceIp6PktsOutPass=pfLogInterfaceIp6PktsOutPass, pfInterfacesIf6PktsInPass=pfInterfacesIf6PktsInPass, pfInterfacesIfRefsRule=pfInterfacesIfRefsRule, pfLogInterfaceIp4BytesOut=pfLogInterfaceIp4BytesOut, pfTablesTblPktsOutBlock=pfTablesTblPktsOutBlock, pfInterfacesIf4BytesOutPass=pfInterfacesIf4BytesOutPass, pfStatusRuntime=pfStatusRuntime, pfLabels=pfLabels, pfTablesTblPktsInPass=pfTablesTblPktsInPass, pfLogInterfaceIp6BytesIn=pfLogInterfaceIp6BytesIn, pfSrcNodesInserts=pfSrcNodesInserts, pfInterfacesIf6BytesInPass=pfInterfacesIf6BytesInPass, pfAltqQueueNumber=pfAltqQueueNumber, pfTimeoutsUdpSingle=pfTimeoutsUdpSingle, pfInterfacesIfNumber=pfInterfacesIfNumber, pfInterfacesIfIndex=pfInterfacesIfIndex, pfTablesAddrPktsOutBlock=pfTablesAddrPktsOutBlock, pfInterfacesIf6BytesOutBlock=pfInterfacesIf6BytesOutBlock, pfLabelsLblBytesIn=pfLabelsLblBytesIn, pfLabelsLblPktsIn=pfLabelsLblPktsIn, pfLogInterfaceIp6BytesOut=pfLogInterfaceIp6BytesOut, pfInterfacesIf6BytesOutPass=pfInterfacesIf6BytesOutPass, pfLabelsLblPktsOut=pfLabelsLblPktsOut, pfTablesTblEntry=pfTablesTblEntry, pfAltqQueueTable=pfAltqQueueTable, pfTablesTblDescr=pfTablesTblDescr, pfTables=pfTables, pfTimeoutsInterval=pfTimeoutsInterval, pfInterfacesIfType=pfInterfacesIfType, pfCounterMatch=pfCounterMatch, pfLogInterfaceName=pfLogInterfaceName, pfTablesAddrBytesOutBlock=pfTablesAddrBytesOutBlock, pfLogInterfaceIp4PktsOutDrop=pfLogInterfaceIp4PktsOutDrop, pfStatus=pfStatus, pfTimeoutsOtherMultiple=pfTimeoutsOtherMultiple, pfTimeoutsOtherFirst=pfTimeoutsOtherFirst, pfTimeoutsTcpFinWait=pfTimeoutsTcpFinWait, pfLabelsLblNumber=pfLabelsLblNumber, pfInterfacesIf4BytesInBlock=pfInterfacesIf4BytesInBlock, pfTimeoutsIcmpFirst=pfTimeoutsIcmpFirst, pfLimitsSrcNodes=pfLimitsSrcNodes, pfAltqQueueIndex=pfAltqQueueIndex, pfTablesTblRefsRule=pfTablesTblRefsRule, pfTablesTblBytesInBlock=pfTablesTblBytesInBlock, pfLogInterfaceIp6PktsInDrop=pfLogInterfaceIp6PktsInDrop, pfLogInterfaceIp4PktsInDrop=pfLogInterfaceIp4PktsInDrop, begemotPfObjects=begemotPfObjects, pfInterfacesIf4PktsOutBlock=pfInterfacesIf4PktsOutBlock, pfInterfacesIfTZero=pfInterfacesIfTZero, pfAltqQueueLimit=pfAltqQueueLimit, pfTablesAddrPktsOutPass=pfTablesAddrPktsOutPass, pfLogInterfaceIp4PktsInPass=pfLogInterfaceIp4PktsInPass)
