#
# PySNMP MIB module DOCS-CABLE-DEVICE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/output/asn1/DOCS-CABLE-DEVICE-MIB
# Produced by pysmi-1.1.8 at Thu Feb  9 11:56:34 2023
# On host fv-az173-80 platform Linux version 5.15.0-1031-azure by user runner
# Using Python version 3.10.9 (main, Dec  7 2022, 08:16:13) [GCC 11.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, Integer32, ObjectIdentity, MibIdentifier, mib_2, iso, IpAddress, NotificationType, Gauge32, TimeTicks, zeroDotZero, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Unsigned32, Bits, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Integer32", "ObjectIdentity", "MibIdentifier", "mib-2", "iso", "IpAddress", "NotificationType", "Gauge32", "TimeTicks", "zeroDotZero", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Unsigned32", "Bits", "ModuleIdentity")
DateAndTime, TruthValue, RowStatus, RowPointer, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TruthValue", "RowStatus", "RowPointer", "TextualConvention", "DisplayString")
docsDev = ModuleIdentity((1, 3, 6, 1, 2, 1, 69))
docsDev.setRevisions(('1999-08-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: docsDev.setRevisionsDescriptions(('Initial Version, published as RFC 2669.\n             Modified by Mike StJohns to add/revise filtering, TOS\n             support, software version information objects.',))
if mibBuilder.loadTexts: docsDev.setLastUpdated('9908190000Z')
if mibBuilder.loadTexts: docsDev.setOrganization('IETF IPCDN Working Group')
if mibBuilder.loadTexts: docsDev.setContactInfo('        Michael StJohns\n             Postal: @Home Network\n                     425 Broadway\n                     Redwood City, CA 94063\n                     U.S.A.\n             Phone:  +1 650 569 5368\n             E-mail: stjohns@corp.home.net')
if mibBuilder.loadTexts: docsDev.setDescription('This is the MIB Module for MCNS-compliant cable modems and\n             cable-modem termination systems.')
docsDevMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1))
docsDevBase = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 1))
docsDevRole = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cm", 1), ("cmtsActive", 2), ("cmtsBackup", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevRole.setStatus('current')
if mibBuilder.loadTexts: docsDevRole.setDescription("Defines the current role of this device.  cm (1) is\n             a Cable Modem, cmtsActive(2) is a Cable Modem Termination\n             System which is controlling the system of cable modems,\n             and cmtsBackup(3) is a CMTS which is currently connected,\n             but not controlling the system (not currently used).\n\n             In general, if this device is a 'cm', its role will not\n             change during operation or between reboots.  If the\n             device is a 'cmts' it may change between cmtsActive and\n             cmtsBackup and back again during normal operation.  NB:\n             At this time, the DOCSIS standards do not support the\n             concept of a backup CMTS, cmtsBackup is included for\n             completeness.")
docsDevDateTime = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevDateTime.setStatus('current')
if mibBuilder.loadTexts: docsDevDateTime.setDescription('The date and time, with optional timezone\n             information.')
docsDevResetNow = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevResetNow.setStatus('current')
if mibBuilder.loadTexts: docsDevResetNow.setDescription('Setting this object to true(1) causes the device to reset.\n             Reading this object always returns false(2).')
docsDevSerialNumber = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSerialNumber.setStatus('current')
if mibBuilder.loadTexts: docsDevSerialNumber.setDescription("The manufacturer's serial number for this device.")
docsDevSTPControl = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stEnabled", 1), ("noStFilterBpdu", 2), ("noStPassBpdu", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSTPControl.setStatus('current')
if mibBuilder.loadTexts: docsDevSTPControl.setDescription('This object controls operation of the spanning tree\n             protocol (as distinguished from transparent bridging).\n             If set to stEnabled(1) then the spanning tree protocol\n             is enabled, subject to bridging constraints. If\n             noStFilterBpdu(2), then spanning tree is not active,\n             and Bridge PDUs received are discarded.\n             If noStPassBpdu(3) then spanning tree is not active\n             and Bridge PDUs are transparently forwarded. Note that\n             a device need not implement all of these options,\n             but that noStFilterBpdu(2) is required.')
docsDevNmAccessTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 2), )
if mibBuilder.loadTexts: docsDevNmAccessTable.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessTable.setDescription('This table controls access to SNMP objects by network\n             management stations. If the table is empty, access\n             to SNMP objects is unrestricted.  This table exists only\n             on SNMPv1 or v2c agents and does not exist on SNMPv3\n             agents. See the conformance section for details.\n             Specifically, for v3 agents, the appropriate MIBs and\n             security models apply in lieu of this table.')
docsDevNmAccessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 2, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIndex"))
if mibBuilder.loadTexts: docsDevNmAccessEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessEntry.setDescription('An entry describing  access to SNMP objects by a\n             particular network management station. An entry in\n             this table is not readable unless the management station\n             has read-write permission (either implicit if the table\n             is empty, or explicit through an entry in this table.\n             Entries are ordered by docsDevNmAccessIndex.  The first\n             matching entry (e.g. matching IP address and community\n             string) is used to derive access.')
docsDevNmAccessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevNmAccessIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessIndex.setDescription('Index used to order the application of access\n             entries.')
docsDevNmAccessIp = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 2), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIp.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessIp.setDescription('The IP address (or subnet) of the network management\n             station. The address 255.255.255.255 is defined to mean\n             any NMS. If traps are enabled for this entry, then the\n             value must be the address of a specific device.')
docsDevNmAccessIpMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 3), IpAddress().clone(hexValue="ffffffff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIpMask.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessIpMask.setDescription('The IP subnet mask of the network management stations.\n             If traps are enabled for this entry, then the value must\n             be 255.255.255.255.')
docsDevNmAccessCommunity = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 4), OctetString().clone('public')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessCommunity.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessCommunity.setDescription('The community string to be matched for access by this\n             entry. If set to a zero length string then any community\n             string will match.  When read, this object SHOULD return\n             a zero length string.')
docsDevNmAccessControl = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("read", 2), ("readWrite", 3), ("roWithTraps", 4), ("rwWithTraps", 5), ("trapsOnly", 6))).clone('read')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessControl.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessControl.setDescription("Specifies the type of access allowed to this NMS. Setting\n             this object to none(1) causes the table entry to be\n             destroyed. Read(2) allows access by 'get' and 'get-next'\n             PDUs. ReadWrite(3) allows access by 'set' as well.\n             RoWithtraps(4), rwWithTraps(5), and trapsOnly(6)\n             control distribution of Trap PDUs transmitted by this\n             device.")
docsDevNmAccessInterfaces = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 6), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessInterfaces.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessInterfaces.setDescription("Specifies the set of interfaces from which requests from\n             this NMS will be accepted.\n             Each octet within the value of this object specifies a set\n             of eight interfaces, with the first octet specifying ports\n             1 through 8, the second octet specifying interfaces 9\n             through 16, etc.  Within each octet, the most significant\n             bit represents the lowest numbered interface, and the least\n             significant bit represents the highest numbered interface.\n             Thus, each interface is represented by a single bit within\n             the value of this object. If that bit has a value of '1'\n             then that interface is included in the set.\n\n             Note that entries in this table apply only to link-layer\n             interfaces (e.g., Ethernet and CATV MAC). Upstream and\n             downstream channel interfaces must not be specified.")
docsDevNmAccessStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessStatus.setDescription('Controls and reflects the status of rows in this\n             table. Rows in this table may be created by either the\n             create-and-go or create-and-wait paradigms.  There is no\n             restriction on changing values in a row of this table while\n             the row is active.')
docsDevSoftware = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 3))
docsDevSwServer = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServer.setStatus('current')
if mibBuilder.loadTexts: docsDevSwServer.setDescription('The address of the TFTP server used for software upgrades.\n             If the TFTP server is unknown, return 0.0.0.0.')
docsDevSwFilename = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwFilename.setStatus('current')
if mibBuilder.loadTexts: docsDevSwFilename.setDescription("The file name of the software image to be loaded into this\n             device. Unless set via SNMP, this is the file name\n             specified by the provisioning server that corresponds to\n             the software version that is desired for this device.\n             If unknown, the string '(unknown)' is returned.")
docsDevSwAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("upgradeFromMgt", 1), ("allowProvisioningUpgrade", 2), ("ignoreProvisioningUpgrade", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwAdminStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevSwAdminStatus.setDescription('If set to upgradeFromMgt(1), the device will initiate a\n             TFTP software image download using docsDevSwFilename.\n             After successfully receiving an image, the device will\n             set its state to ignoreProvisioningUpgrade(3) and reboot.\n             If the download process is interrupted by a reset or\n             power failure, the device will load the previous image\n             and, after re-initialization, continue to attempt loading\n             the image specified in docsDevSwFilename.\n             If set to allowProvisioningUpgrade(2), the device will\n             use the software version information supplied by the\n             provisioning server when next rebooting (this does not\n             cause a reboot).\n\n             When set to ignoreProvisioningUpgrade(3), the device\n             will disregard software image upgrade information from the\n             provisioning server.\n\n             Note that reading this object can return upgradeFromMgt(1).\n             This indicates that a software download is currently in\n             progress, and that the device will reboot after\n             successfully receiving an image.\n\n             At initial startup, this object has the default value of\n             allowProvisioningUpgrade(2).')
docsDevSwOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inProgress", 1), ("completeFromProvisioning", 2), ("completeFromMgt", 3), ("failed", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwOperStatus.setReference('DOCSIS Radio Frequency Interface Specification, Section\n             8.2, Downloading Cable Modem Operating Software.')
if mibBuilder.loadTexts: docsDevSwOperStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevSwOperStatus.setDescription('InProgress(1) indicates that a TFTP download is underway,\n             either as a result of a version mismatch at provisioning\n             or as a result of a upgradeFromMgt request.\n             CompleteFromProvisioning(2) indicates that the last\n             software upgrade was a result of version mismatch at\n             provisioning. CompleteFromMgt(3) indicates that the last\n             software upgrade was a result of setting\n             docsDevSwAdminStatus to upgradeFromMgt.\n             Failed(4) indicates that the last attempted download\n             failed, ordinarily due to TFTP timeout.')
docsDevSwCurrentVers = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwCurrentVers.setStatus('current')
if mibBuilder.loadTexts: docsDevSwCurrentVers.setDescription('The software version currently operating in this device.\n             This object should be in the syntax used by the individual\n             vendor to identify software versions.  Any CM MUST return a\n             string descriptive of the current software load.  For a\n             CMTS, this object SHOULD contain either a human readable\n             representation of the vendor specific designation of the\n             software for the chassis, or of the software for the\n             control processor. If neither of these is  applicable,\n             this MUST contain an empty string.')
docsDevServer = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 4))
docsDevServerBootState = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("operational", 1), ("disabled", 2), ("waitingForDhcpOffer", 3), ("waitingForDhcpResponse", 4), ("waitingForTimeServer", 5), ("waitingForTftp", 6), ("refusedByCmts", 7), ("forwardingDenied", 8), ("other", 9), ("unknown", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerBootState.setReference('DOCSIS Radio Frequency Interface Specification, Figure\n             7-1, CM Initialization Overview.')
if mibBuilder.loadTexts: docsDevServerBootState.setStatus('current')
if mibBuilder.loadTexts: docsDevServerBootState.setDescription('If operational(1), the device has completed loading and\n             processing of configuration parameters and the CMTS has\n             completed the Registration exchange.\n             If disabled(2) then the device was administratively\n             disabled, possibly by being refused network access in the\n             configuration file.\n             If waitingForDhcpOffer(3) then a DHCP Discover has been\n             transmitted and no offer has yet been received.\n             If waitingForDhcpResponse(4) then a DHCP Request has been\n             transmitted and no response has yet been received.\n             If waitingForTimeServer(5) then a Time Request has been\n             transmitted and no response has yet been received.\n             If waitingForTftp(6) then a request to the TFTP parameter\n             server has been made and no response received.\n             If refusedByCmts(7) then the Registration Request/Response\n             exchange with the CMTS failed.\n             If forwardingDenied(8) then the registration process\n             completed, but the network access option in the received\n             configuration file prohibits forwarding. ')
docsDevServerDhcp = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcp.setStatus('current')
if mibBuilder.loadTexts: docsDevServerDhcp.setDescription('The IP address of the DHCP server that assigned an IP\n             address to this device. Returns 0.0.0.0 if DHCP was not\n             used for IP address assignment.')
docsDevServerTime = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTime.setStatus('current')
if mibBuilder.loadTexts: docsDevServerTime.setDescription('The IP address of the Time server (RFC-868). Returns\n             0.0.0.0 if the time server IP address is unknown.')
docsDevServerTftp = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTftp.setStatus('current')
if mibBuilder.loadTexts: docsDevServerTftp.setDescription('The IP address of the TFTP server responsible for\n             downloading provisioning and configuration parameters\n             to this device. Returns 0.0.0.0 if the TFTP server\n             address is unknown.')
docsDevServerConfigFile = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigFile.setStatus('current')
if mibBuilder.loadTexts: docsDevServerConfigFile.setDescription('The name of the device configuration file read from the\n             TFTP server. Returns an empty string if the configuration\n             file name is unknown.')
docsDevEvent = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 5))
docsDevEvControl = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("resetLog", 1), ("useDefaultReporting", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvControl.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControl.setDescription('Setting this object to resetLog(1) empties the event log.\n             All data is deleted. Setting it to useDefaultReporting(2)\n             returns all event priorities to their factory-default\n             reporting. Reading this object always returns\n             useDefaultReporting(2).')
docsDevEvSyslog = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslog.setStatus('current')
if mibBuilder.loadTexts: docsDevEvSyslog.setDescription('The IP address of the Syslog server. If 0.0.0.0, syslog\n             transmission is inhibited.')
docsDevEvThrottleAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unconstrained", 1), ("maintainBelowThreshold", 2), ("stopAtThreshold", 3), ("inhibited", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleAdminStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleAdminStatus.setDescription('Controls the transmission of traps and syslog messages\n             with respect to the trap pacing threshold.\n             unconstrained(1) causes traps and syslog messages to be\n             transmitted without regard to the threshold settings.\n             maintainBelowThreshold(2) causes trap transmission and\n             syslog messages to be suppressed if the number of traps\n             would otherwise exceed the threshold.\n             stopAtThreshold(3) causes trap transmission to cease\n             at the threshold, and not resume until directed to do so.\n             inhibited(4) causes all trap transmission and syslog\n             messages to be suppressed.\n\n             A single event is always treated as a single event for\n             threshold counting. That is, an event causing both a trap\n             and a syslog message is still treated as a single event.\n\n             Writing to this object resets the thresholding state.\n\n             At initial startup, this object has a default value of\n             unconstrained(1).')
docsDevEvThrottleInhibited = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvThrottleInhibited.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleInhibited.setDescription('If true(1), trap and syslog transmission is currently\n             inhibited due to thresholds and/or the current setting of\n             docsDevEvThrottleAdminStatus. In addition, this is set to\n             true(1) if transmission is inhibited due to no\n             syslog (docsDevEvSyslog) or trap (docsDevNmAccessEntry)\n             destinations having been set.')
docsDevEvThrottleThreshold = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleThreshold.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleThreshold.setDescription('Number of trap/syslog events per docsDevEvThrottleInterval\n             to be transmitted before throttling.\n\n             A single event is always treated as a single event for\n             threshold counting. That is, an event causing both a trap\n             and a syslog message is still treated as a single event.\n\n             At initial startup, this object returns 0.')
docsDevEvThrottleInterval = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleInterval.setStatus('current')
if mibBuilder.loadTexts: docsDevEvThrottleInterval.setDescription('The interval over which the trap threshold applies.\n             At initial startup, this object has a value of 1.')
docsDevEvControlTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 5, 7), )
if mibBuilder.loadTexts: docsDevEvControlTable.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControlTable.setDescription('This table allows control of the reporting of event classes.\n        For each event priority, a combination of logging and\n        reporting mechanisms may be chosen. The mapping of event types\n        to priorities is vendor-dependent. Vendors may also choose to\n        allow the user to control that mapping through proprietary\n        means.')
docsDevEvControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevEvPriority"))
if mibBuilder.loadTexts: docsDevEvControlEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevEvControlEntry.setDescription('Allows configuration of the reporting mechanisms for a\n             particular event priority.')
docsDevEvPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8))))
if mibBuilder.loadTexts: docsDevEvPriority.setStatus('current')
if mibBuilder.loadTexts: docsDevEvPriority.setDescription('The priority level that is controlled by this\n             entry. These are ordered from most (emergency) to least\n             (debug) critical.  Each event with a CM or CMTS has a\n             particular priority level associated with it (as defined\n             by the vendor). During normal operation no event more\n             critical than notice(6) should be generated. Events between\n             warning and emergency should be generated at appropriate\n             levels of problems (e.g. emergency when the box is about to\n             crash).')
docsDevEvReporting = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1, 2), Bits().clone(namedValues=NamedValues(("local", 0), ("traps", 1), ("syslog", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvReporting.setStatus('current')
if mibBuilder.loadTexts: docsDevEvReporting.setDescription('Defines the action to be taken on occurrence of this\n             event class. Implementations may not necessarily support\n             all options for all event classes, but at minimum must\n             allow traps and syslogging to be disabled. If the\n             local(0) bit is set, then log to the internal log, if the\n             traps(1) bit is set, then generate a trap, if the\n             syslog(2) bit is set, then send a syslog message\n             (assuming the syslog address is set).')
docsDevEventTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 5, 8), )
if mibBuilder.loadTexts: docsDevEventTable.setStatus('current')
if mibBuilder.loadTexts: docsDevEventTable.setDescription('Contains a log of network and device events that may be\n             of interest in fault isolation and troubleshooting.')
docsDevEventEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevEvIndex"))
if mibBuilder.loadTexts: docsDevEventEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevEventEntry.setDescription('Describes a network or device event that may be of\n             interest in fault isolation and troubleshooting. Multiple\n             sequential identical events are represented by\n             incrementing docsDevEvCounts and setting\n             docsDevEvLastTime to the current time rather than creating\n             multiple rows.\n\n             Entries are created with the first occurrance of an event.\n             docsDevEvControl can be used to clear the table.\n             Individual events can not be deleted.')
docsDevEvIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevEvIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevEvIndex.setDescription('Provides relative ordering of the objects in the event\n             log. This object will always increase except when\n             (a) the log is reset via docsDevEvControl,\n             (b) the device reboots and does not implement non-volatile\n             storage for this log, or (c) it reaches the value 2^31.\n             The next entry for all the above cases is 1.')
docsDevEvFirstTime = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvFirstTime.setStatus('current')
if mibBuilder.loadTexts: docsDevEvFirstTime.setDescription('The time that this entry was created.')
docsDevEvLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLastTime.setStatus('current')
if mibBuilder.loadTexts: docsDevEvLastTime.setDescription('If multiple events are reported via the same entry, the\n             time that the last event for this entry occurred,\n             otherwise this should have the same value as\n             docsDevEvFirstTime. ')
docsDevEvCounts = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvCounts.setStatus('current')
if mibBuilder.loadTexts: docsDevEvCounts.setDescription('The number of consecutive event instances reported by\n             this entry.  This starts at 1 with the creation of this\n             row and increments by 1 for each subsequent duplicate\n             event.')
docsDevEvLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLevel.setStatus('current')
if mibBuilder.loadTexts: docsDevEvLevel.setDescription('The priority level of this event as defined by the\n             vendor.  These are ordered from most serious (emergency)\n             to least serious (debug).')
docsDevEvId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvId.setStatus('current')
if mibBuilder.loadTexts: docsDevEvId.setDescription('For this product, uniquely identifies the type of event\n             that is reported by this entry.')
docsDevEvText = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvText.setStatus('current')
if mibBuilder.loadTexts: docsDevEvText.setDescription('Provides a human-readable description of the event,\n             including all relevant context (interface numbers,\n             etc.).')
docsDevFilter = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 6))
docsDevFilterLLCUnmatchedAction = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterLLCUnmatchedAction.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCUnmatchedAction.setDescription('LLC (Link Level Control) filters can be defined on an\n             inclusive or exclusive basis: CMs can be configured to\n             forward only packets matching a set of layer three\n             protocols, or to drop packets matching a set of layer\n             three protocols.  Typical use of these filters is to\n             filter out possibly harmful (given the context of a large\n             metropolitan LAN) protocols.\n\n             If set to discard(1), any L2 packet which does not match at\n             least one filter in the docsDevFilterLLCTable will be\n             discarded. If set to accept(2), any L2 packet which does not\n             match at least one filter in the docsDevFilterLLCTable\n             will be accepted for further processing (e.g., bridging).\n             At initial system startup, this object returns accept(2).')
docsDevFilterLLCTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 2), )
if mibBuilder.loadTexts: docsDevFilterLLCTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCTable.setDescription('A list of filters to apply to (bridged) LLC\n             traffic. The filters in this table are applied to\n             incoming traffic on the appropriate interface(s)  prior\n             to any further processing (e.g. before handing the packet\n             off for level 3 processing, or for bridging).  The\n             specific action taken when no filter is matched is\n             controlled by docsDevFilterLLCUnmatchedAction.')
docsDevFilterLLCEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIndex"))
if mibBuilder.loadTexts: docsDevFilterLLCEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCEntry.setDescription('Describes a single filter to apply to (bridged) LLC traffic\n             received on a specified interface. ')
docsDevFilterLLCIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterLLCIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCIndex.setDescription('Index used for the identification of filters (note that LLC\n             filter order is irrelevant).')
docsDevFilterLLCStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCStatus.setDescription('Controls and reflects the status of rows in this\n             table. There is no restriction on changing any of the\n             associated columns for this row while this object is set\n             to active.')
docsDevFilterLLCIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCIfIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCIfIndex.setDescription('The entry interface to which this filter applies.\n             The value corresponds to ifIndex for either a CATV MAC\n             or another network interface. If the value is zero, the\n             filter applies to all interfaces. In Cable Modems, the\n             default value is the customer side interface. In Cable\n             Modem Termination Systems, this object has to be\n             specified to create a row in this table.')
docsDevFilterLLCProtocolType = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethertype", 1), ("dsap", 2))).clone('ethertype')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocolType.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCProtocolType.setDescription('The format of the value in docsDevFilterLLCProtocol:\n             either a two-byte Ethernet Ethertype, or a one-byte\n             802.2 SAP value. EtherType(1) also applies to SNAP-\n             encapsulated frames.')
docsDevFilterLLCProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocol.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCProtocol.setDescription('The layer three protocol for which this filter applies.\n             The protocol value format depends on\n             docsDevFilterLLCProtocolType. Note that for SNAP frames,\n             etherType filtering is performed rather than DSAP=0xAA.')
docsDevFilterLLCMatches = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterLLCMatches.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterLLCMatches.setDescription('Counts the number of times this filter was matched.')
docsDevFilterIpDefault = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterIpDefault.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDefault.setDescription('If set to discard(1), all packets not matching an IP filter\n             will be discarded. If set to accept(2), all packets not\n             matching an IP filter will be accepted for further\n             processing (e.g., bridging).\n             At initial system startup, this object returns accept(2).')
docsDevFilterIpTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 4), )
if mibBuilder.loadTexts: docsDevFilterIpTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTable.setDescription('An ordered list of filters or classifiers to apply to\n             IP traffic. Filter application is ordered by the filter\n             index, rather than by a best match algorithm (Note that\n             this implies that the filter table may have gaps in the\n             index values). Packets which match no filters will have\n             policy 0 in the docsDevFilterPolicyTable applied to them if\n             it exists. Otherwise, Packets which match no filters\n             are discarded or forwarded according to the setting of\n             docsDevFilterIpDefault.\n\n             Any IP packet can theoretically match multiple rows of\n             this table.  When considering a packet, the table is\n             scanned in row index order (e.g. filter 10 is checked\n             before filter 20).  If the packet matches that filter\n             (which means that it matches ALL criteria for that row),\n             actions appropriate to docsDevFilterIpControl and\n             docsDevFilterPolicyId are taken.  If the packet was\n             discarded processing is complete.  If\n             docsDevFilterIpContinue is set to true, the filter\n             comparison continues with the next row in the table\n             looking for additional matches.\n\n             If the packet matches no filter in the table, the packet\n             is accepted or dropped for further processing based on\n             the setting of docsDevFilterIpDefault. If the packet is\n             accepted, the actions specified by policy group 0\n             (e.g. the rows in docsDevFilterPolicyTable which have a\n             value of 0 for docsDevFilterPolicyId) are taken if that\n             policy group exists.\n\n             Logically, this table is consulted twice during the\n             processing of any IP packet - once upon its acceptance\n             from the L2 entity, and once upon its transmission to the\n             L2 entity.  In actuality, for cable modems, IP filtering\n             is generally the only IP processing done for transit\n             traffic.  This means that inbound and outbound filtering\n             can generally be done at the same time with one pass\n             through the filter table.')
docsDevFilterIpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIndex"))
if mibBuilder.loadTexts: docsDevFilterIpEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpEntry.setDescription('Describes a filter to apply to IP traffic received on a\n             specified interface.  All identity objects in this table\n             (e.g. source and destination address/mask, protocol,\n             source/dest port, TOS/mask, interface and direction) must\n             match their respective fields in the packet for any given\n             filter to match.\n\n             To create an entry in this table, docsDevFilterIpIfIndex\n             must be specified.')
docsDevFilterIpIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterIpIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpIndex.setDescription('Index used to order the application of filters.\n             The filter with the lowest index is always applied\n             first.')
docsDevFilterIpStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpStatus.setDescription('Controls and reflects the status of rows in this\n             table. Specifying only this object (with the appropriate\n             index) on a CM is sufficient to create a filter row which\n             matches all inbound packets on the ethernet interface,\n             and results in the packets being\n             discarded. docsDevFilterIpIfIndex (at least) must be\n             specified on a CMTS to create a row.  Creation of the\n             rows may be done via either create-and-wait or\n             create-and-go, but the filter is not applied until this\n             object is set to (or changes to) active. There is no\n             restriction in changing any object in a row while this\n             object is set to active.')
docsDevFilterIpControl = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("accept", 2), ("policy", 3))).clone('discard')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpControl.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpControl.setDescription('If set to discard(1), all packets matching this filter\n             will be discarded and scanning of the remainder of the\n             filter list will be aborted. If set to accept(2), all\n             packets matching this filter will be accepted for further\n             processing (e.g., bridging). If docsDevFilterIpContinue\n             is set to true, see if there are other matches, otherwise\n             done. If set to policy (3), execute the policy entries\n             matched by docsDevIpFilterPolicyId in\n             docsDevIpFilterPolicyTable.\n\n             If is docsDevFilterIpContinue is set to true, continue\n             scanning the table for other matches, otherwise done.')
docsDevFilterIpIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpIfIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpIfIndex.setDescription('The entry interface to which this filter applies. The\n             value corresponds to ifIndex for either a CATV MAC or\n             another network interface. If the value is zero, the\n             filter applies to all interfaces. Default value in Cable\n             Modems is the index of the customer-side (e.g. ethernet)\n             interface. In Cable Modem Termination Systems, this\n             object MUST be specified to create a row in this table.')
docsDevFilterIpDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2), ("both", 3))).clone('inbound')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDirection.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDirection.setDescription('Determines whether the filter is applied to inbound(1)\n             traffic, outbound(2) traffic, or traffic in both(3)\n             directions.')
docsDevFilterIpBroadcast = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpBroadcast.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpBroadcast.setDescription('If set to true(1), the filter only applies to multicast\n             and broadcast traffic. If set to false(2), the filter\n             applies to all traffic.')
docsDevFilterIpSaddr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSaddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSaddr.setDescription("The source IP address, or portion thereof, that is to be\n             matched for this filter.  The source address is first\n             masked (and'ed) against docsDevFilterIpSmask before being\n             compared  to this value.  A value of 0 for this object\n             and 0 for the mask matches all IP addresses.")
docsDevFilterIpSmask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSmask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSmask.setDescription("A bit mask that is to be applied to the source address\n             prior to matching. This mask is not necessarily the same\n             as a subnet mask, but 1's bits must be leftmost and\n             contiguous.")
docsDevFilterIpDaddr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDaddr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDaddr.setDescription("The destination IP address, or portion thereof, that is\n             to be matched for this filter. The destination address is\n             first masked (and'ed) against docsDevFilterIpDmask before\n             being compared  to this value.  A value of 0 for this\n             object and 0 for the mask matches all IP addresses.")
docsDevFilterIpDmask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDmask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDmask.setDescription("A bit mask that is to be applied to the destination\n             address prior to matching. This mask is not necessarily\n             the same as a subnet mask, but 1's bits must be leftmost\n             and contiguous.")
docsDevFilterIpProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpProtocol.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpProtocol.setDescription('The IP protocol value that is to be matched. For example:\n             icmp is 1, tcp is 6, udp is 17. A value of 256 matches\n             ANY protocol.')
docsDevFilterIpSourcePortLow = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortLow.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSourcePortLow.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the\n             inclusive lower bound of the transport-layer source port\n             range that is to be matched, otherwise it is ignored\n             during matching.')
docsDevFilterIpSourcePortHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortHigh.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpSourcePortHigh.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the\n             inclusive upper bound of the transport-layer source port\n             range that is to be matched, otherwise it is ignored\n             during matching.')
docsDevFilterIpDestPortLow = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortLow.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDestPortLow.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the\n             inclusive lower bound of the transport-layer destination\n             port range that is to be matched, otherwise it is ignored\n             during matching.')
docsDevFilterIpDestPortHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortHigh.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpDestPortHigh.setDescription('If docsDevFilterIpProtocol is udp or tcp, this is the\n             inclusive upper bound of the transport-layer destination\n             port range that is to be matched, otherwise it is ignored\n             during matching.')
docsDevFilterIpMatches = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterIpMatches.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpMatches.setDescription('Counts the number of times this filter was matched.\n             This object is initialized to 0 at boot, or at row\n             creation, and is reset only upon reboot.')
docsDevFilterIpTos = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTos.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTos.setDescription("This is the value to be matched to the packet's\n             TOS (Type of Service) value (after the TOS value\n             is AND'd with docsDevFilterIpTosMask).  A value for this\n             object of 0 and a mask of 0 matches all TOS values.")
docsDevFilterIpTosMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTosMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpTosMask.setDescription("The mask to be applied to the packet's TOS value before\n             matching.")
docsDevFilterIpContinue = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpContinue.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpContinue.setDescription('If this value is set to true, and docsDevFilterIpControl\n             is anything but discard (1), continue scanning and\n             applying policies.')
docsDevFilterIpPolicyId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpPolicyId.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterIpPolicyId.setDescription('This object points to an entry in docsDevFilterPolicyTable.\n             If docsDevFilterIpControl is set to policy (3), execute\n             all matching policies in docsDevFilterPolicyTable.\n             If no matching policy exists, treat as if\n             docsDevFilterIpControl were set to accept (1).\n             If this object is set to the value of 0, there is no\n             matching policy, and docsDevFilterPolicyTable MUST NOT be\n             consulted.')
docsDevFilterPolicyTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 5), )
if mibBuilder.loadTexts: docsDevFilterPolicyTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyTable.setDescription('A Table which maps between a policy group ID and a set of\n             policies to be applied.  All rows with the same\n             docsDevFilterPolicyId are part of the same policy group\n             and are applied in the order in which they are in this\n             table.\n\n             docsDevFilterPolicyTable exists to allow multiple policy\n             actions to be applied to any given classified packet. The\n             policy actions are applied in index order For example:\n\n             Index   ID    Type    Action\n              1      1      TOS     1\n              9      5      TOS     1\n              12     1      IPSEC   3\n\n             This says that a packet which matches a filter with\n             policy id 1, first has TOS policy 1 applied (which might\n             set the TOS bits to enable a higher priority), and next\n             has the IPSEC policy 3 applied (which may result in the\n             packet being dumped into a secure VPN to a remote\n             encryptor).\n\n             Policy ID 0 is reserved for default actions and is\n             applied only to packets which match no filters in\n             docsDevIpFilterTable.')
docsDevFilterPolicyEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyIndex"))
if mibBuilder.loadTexts: docsDevFilterPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyEntry.setDescription('An entry in the docsDevFilterPolicyTable. Entries are\n             created by Network Management. To create an entry,\n             docsDevFilterPolicyId and docsDevFilterPolicyAction\n             must be specified.')
docsDevFilterPolicyIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterPolicyIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyIndex.setDescription('Index value for the table.')
docsDevFilterPolicyId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyId.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyId.setDescription('Policy ID for this entry. A policy ID can apply to\n              multiple rows of this table, all relevant policies are\n              executed. Policy 0 (if populated) is applied to all\n              packets which do not match any of the filters. N.B. If\n              docsDevFilterIpPolicyId is set to 0, it DOES NOT match\n              policy 0 of this table. ')
docsDevFilterPolicyStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyStatus.setDescription('Object used to create an entry in this table.')
docsDevFilterPolicyPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 6), RowPointer().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyPtr.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterPolicyPtr.setDescription('This object points to a row in an applicable filter policy\n             table.  Currently, the only standard policy table is\n             docsDevFilterTosTable. Per the textual convention, this\n             object points to the first accessible object in the row.\n             E.g. to point to a row in docsDevFilterTosTable with an\n             index of 21, the value of this object would be the object\n             identifier docsDevTosStatus.21.\n\n             Vendors must adhere to the same convention when adding\n             vendor specific policy table extensions.\n\n             The default upon row creation is a null pointer which\n             results in no policy action being taken.')
docsDevFilterTosTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 6), )
if mibBuilder.loadTexts: docsDevFilterTosTable.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosTable.setDescription('Table used to describe Type of Service (TOS) bits\n             processing.\n\n             This table is an adjunct to the docsDevFilterIpTable, and\n             the docsDevFilterPolicy table.  Entries in the latter\n             table can point to specific rows in this (and other)\n             tables and cause specific actions to be taken.  This table\n             permits the manipulation of the value of the Type of\n             Service bits in the IP header of the matched packet as\n             follows:\n             Set the tosBits of the packet to\n                (tosBits & docsDevFilterTosAndMask) |\n                                                 docsDevFilterTosOrMask\n\n             This construct allows you to do a clear and set of all\n             the TOS bits in a flexible manner.')
docsDevFilterTosEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosIndex"))
if mibBuilder.loadTexts: docsDevFilterTosEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosEntry.setDescription('A TOS policy entry.')
docsDevFilterTosIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: docsDevFilterTosIndex.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosIndex.setDescription('The unique index for this row.  There are no ordering\n             requirements for this table and any valid index may be\n             specified.')
docsDevFilterTosStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosStatus.setDescription('The object used to create and delete entries in this\n             table. A row created by specifying just this object\n             results in a row which specifies no change to the TOS\n             bits.   A row may be created using either the create-and-go\n             or create-and-wait paradigms. There is no restriction on\n             the ability to change values in this row while the row is\n             active.')
docsDevFilterTosAndMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="ff")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosAndMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosAndMask.setDescription("This value is bitwise AND'd with the matched  packet's\n        TOS bits.")
docsDevFilterTosOrMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosOrMask.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterTosOrMask.setDescription("After bitwise AND'ing with the above bits, the packet's\n             TOS bits are bitwise OR'd with these bits.")
docsDevCpe = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 7))
docsDevCpeEnroll = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("any", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeEnroll.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeEnroll.setDescription('This object controls the population of docsDevFilterCpeTable.\n             If set to none, the filters must be set manually.\n             If set to any, the CM wiretaps the packets originating\n             from the ethernet and enrolls up to docsDevCpeIpMax\n             addresses based on the source IP addresses of those\n             packets. At initial system startup, default value for this\n             object is any(2).')
docsDevCpeIpMax = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeIpMax.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeIpMax.setDescription('This object controls the maximum number of CPEs allowed to\n             connect behind this device. If set to zero, any number of\n             CPEs may connect up to the maximum permitted for the device.\n             If set to -1, no filtering is done on CPE source addresses,\n             and no entries are made in the docsDevFilterCpeTable. If an\n             attempt is made to set this to a number greater than that\n             permitted for the device, it is set to that maximum.\n             At iniitial system startup, default value for this object\n             is 1.')
docsDevCpeTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 7, 3), )
if mibBuilder.loadTexts: docsDevCpeTable.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeTable.setDescription('This table lists the IP addresses seen (or permitted)  as\n             source addresses in packets originating from the customer\n             interface on this device. In addition, this table can be\n             provisioned with the specific addresses permitted for the\n             CPEs via the normal row creation mechanisms.')
docsDevCpeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1), ).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevCpeIp"))
if mibBuilder.loadTexts: docsDevCpeEntry.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeEntry.setDescription('An entry in the docsDevFilterCpeTable. There is one entry\n             for each IP CPE seen or provisioned. If docsDevCpeIpMax\n             is set to -1, this table is ignored, otherwise: Upon receipt\n             of an IP  packet from the customer interface of the CM, the\n             source IP address is checked against this table. If the\n             address is in the table, packet processing continues.\n             If the address is not in the table, but docsDevCpeEnroll\n             is set to any and the table size is less than\n             docsDevCpeIpMax, the address is added to the table and\n             packet processing continues. Otherwise, the packet is\n             dropped.\n\n             The filtering actions specified by this table occur after\n             any LLC filtering (docsDevFilterLLCTable), but prior\n             to any IP filtering (docsDevFilterIpTable,\n             docsDevNmAccessTable).')
docsDevCpeIp = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: docsDevCpeIp.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeIp.setDescription('The IP address to which this entry applies.')
docsDevCpeSource = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("manual", 2), ("learned", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevCpeSource.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeSource.setDescription('This object describes how this entry was created. If the\n             value is manual(2), this row was created by a network\n             management action (either configuration, or SNMP set).\n             If set to learned(3), then it was found via\n             looking at the source IP address of a received packet.')
docsDevCpeStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevCpeStatus.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeStatus.setDescription('Standard object to manipulate rows. To create a row in this\n             table, you only need to specify this object. Management\n             stations SHOULD use the create-and-go mechanism for\n             creating rows in this table.')
docsDevNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 2))
docsDevConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3))
docsDevGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 1))
docsDevCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 2))
docsDevBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 69, 3, 2, 1)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevBaseGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEventGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevBasicCompliance = docsDevBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: docsDevBasicCompliance.setDescription('The compliance statement for MCNS Cable Modems and\n             Cable Modem Termination Systems.')
docsDevBaseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 1)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevRole"), ("DOCS-CABLE-DEVICE-MIB", "docsDevDateTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevResetNow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSerialNumber"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSTPControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevBaseGroup = docsDevBaseGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevBaseGroup.setDescription('A collection of objects providing device status and\n             control.')
docsDevNmAccessGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 2)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIpMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessCommunity"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessInterfaces"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevNmAccessGroup = docsDevNmAccessGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevNmAccessGroup.setDescription('A collection of objects for controlling access to SNMP\n             objects.')
docsDevSoftwareGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 3)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevSwServer"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwFilename"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwAdminStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwOperStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwCurrentVers"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevSoftwareGroup = docsDevSoftwareGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevSoftwareGroup.setDescription('A collection of objects for controlling software\n             downloads.')
docsDevServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 4)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevServerBootState"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerTftp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigFile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevServerGroup = docsDevServerGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevServerGroup.setDescription('A collection of objects providing status about server\n             provisioning.')
docsDevEventGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 5)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevEvControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslog"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleAdminStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInhibited"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleThreshold"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInterval"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvReporting"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvFirstTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLastTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvCounts"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevEventGroup = docsDevEventGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevEventGroup.setDescription('A collection of objects used to control and monitor\n             events.')
docsDevFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 6)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCUnmatchedAction"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDefault"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIfIndex"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocolType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocol"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCMatches"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIfIndex"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDirection"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpBroadcast"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSaddr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSmask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDaddr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDmask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpProtocol"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortLow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortHigh"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortLow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortHigh"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpMatches"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTos"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTosMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpContinue"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpPolicyId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyPtr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosAndMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosOrMask"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevFilterGroup = docsDevFilterGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevFilterGroup.setDescription('A collection of objects to specify filters at link layer\n             and IP layer.')
docsDevCpeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 7)).setObjects(("DOCS-CABLE-DEVICE-MIB", "docsDevCpeEnroll"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeIpMax"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeSource"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    docsDevCpeGroup = docsDevCpeGroup.setStatus('current')
if mibBuilder.loadTexts: docsDevCpeGroup.setDescription('A collection of objects used to control the number\n             and specific values of IP addresses allowed for\n             associated Customer Premises Equipment (CPE).')
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", docsDevEventGroup=docsDevEventGroup, docsDevRole=docsDevRole, docsDevNmAccessCommunity=docsDevNmAccessCommunity, docsDevFilterPolicyTable=docsDevFilterPolicyTable, docsDevSwCurrentVers=docsDevSwCurrentVers, docsDevSoftware=docsDevSoftware, docsDevServerGroup=docsDevServerGroup, docsDevEvControlTable=docsDevEvControlTable, docsDevFilterIpSmask=docsDevFilterIpSmask, docsDevSwServer=docsDevSwServer, docsDevSwOperStatus=docsDevSwOperStatus, docsDevFilterIpBroadcast=docsDevFilterIpBroadcast, docsDevSwAdminStatus=docsDevSwAdminStatus, docsDevBasicCompliance=docsDevBasicCompliance, docsDevGroups=docsDevGroups, docsDevServer=docsDevServer, docsDevFilterIpDestPortHigh=docsDevFilterIpDestPortHigh, docsDevFilterLLCProtocolType=docsDevFilterLLCProtocolType, docsDevConformance=docsDevConformance, docsDevServerTftp=docsDevServerTftp, docsDevFilterPolicyIndex=docsDevFilterPolicyIndex, docsDevEvThrottleInterval=docsDevEvThrottleInterval, docsDevNmAccessEntry=docsDevNmAccessEntry, docsDevFilter=docsDevFilter, docsDevBase=docsDevBase, docsDevEventTable=docsDevEventTable, docsDevFilterTosOrMask=docsDevFilterTosOrMask, docsDevMIBObjects=docsDevMIBObjects, docsDevCpeStatus=docsDevCpeStatus, docsDevCpeIp=docsDevCpeIp, docsDevFilterTosTable=docsDevFilterTosTable, docsDevFilterIpDirection=docsDevFilterIpDirection, docsDevNmAccessInterfaces=docsDevNmAccessInterfaces, docsDevServerDhcp=docsDevServerDhcp, docsDevNmAccessIpMask=docsDevNmAccessIpMask, docsDevServerConfigFile=docsDevServerConfigFile, docsDevFilterIpTosMask=docsDevFilterIpTosMask, docsDevEvControlEntry=docsDevEvControlEntry, docsDevNotification=docsDevNotification, docsDevFilterGroup=docsDevFilterGroup, docsDevEvText=docsDevEvText, docsDevEvFirstTime=docsDevEvFirstTime, docsDevSTPControl=docsDevSTPControl, docsDevEvThrottleThreshold=docsDevEvThrottleThreshold, docsDevFilterLLCTable=docsDevFilterLLCTable, docsDevSwFilename=docsDevSwFilename, docsDevEventEntry=docsDevEventEntry, docsDevFilterIpSourcePortHigh=docsDevFilterIpSourcePortHigh, docsDevFilterIpControl=docsDevFilterIpControl, docsDevFilterLLCIndex=docsDevFilterLLCIndex, docsDevEvControl=docsDevEvControl, docsDevFilterIpStatus=docsDevFilterIpStatus, docsDevNmAccessIndex=docsDevNmAccessIndex, docsDevFilterLLCIfIndex=docsDevFilterLLCIfIndex, docsDevFilterIpDestPortLow=docsDevFilterIpDestPortLow, docsDevServerBootState=docsDevServerBootState, docsDevCpeEnroll=docsDevCpeEnroll, docsDevServerTime=docsDevServerTime, docsDevFilterPolicyId=docsDevFilterPolicyId, docsDevFilterIpMatches=docsDevFilterIpMatches, docsDevSoftwareGroup=docsDevSoftwareGroup, docsDevEvent=docsDevEvent, docsDevCpeTable=docsDevCpeTable, docsDevEvLevel=docsDevEvLevel, PYSNMP_MODULE_ID=docsDev, docsDevEvThrottleInhibited=docsDevEvThrottleInhibited, docsDevFilterTosIndex=docsDevFilterTosIndex, docsDevFilterTosStatus=docsDevFilterTosStatus, docsDevEvPriority=docsDevEvPriority, docsDevFilterLLCMatches=docsDevFilterLLCMatches, docsDev=docsDev, docsDevFilterIpDaddr=docsDevFilterIpDaddr, docsDevFilterPolicyStatus=docsDevFilterPolicyStatus, docsDevFilterTosEntry=docsDevFilterTosEntry, docsDevCompliances=docsDevCompliances, docsDevFilterLLCUnmatchedAction=docsDevFilterLLCUnmatchedAction, docsDevNmAccessTable=docsDevNmAccessTable, docsDevCpeIpMax=docsDevCpeIpMax, docsDevSerialNumber=docsDevSerialNumber, docsDevFilterIpSaddr=docsDevFilterIpSaddr, docsDevFilterPolicyPtr=docsDevFilterPolicyPtr, docsDevEvId=docsDevEvId, docsDevFilterIpIfIndex=docsDevFilterIpIfIndex, docsDevEvIndex=docsDevEvIndex, docsDevEvCounts=docsDevEvCounts, docsDevCpeGroup=docsDevCpeGroup, docsDevFilterTosAndMask=docsDevFilterTosAndMask, docsDevNmAccessControl=docsDevNmAccessControl, docsDevFilterIpProtocol=docsDevFilterIpProtocol, docsDevFilterLLCStatus=docsDevFilterLLCStatus, docsDevFilterIpDmask=docsDevFilterIpDmask, docsDevCpeEntry=docsDevCpeEntry, docsDevFilterIpTos=docsDevFilterIpTos, docsDevFilterPolicyEntry=docsDevFilterPolicyEntry, docsDevFilterIpTable=docsDevFilterIpTable, docsDevEvSyslog=docsDevEvSyslog, docsDevFilterLLCProtocol=docsDevFilterLLCProtocol, docsDevFilterLLCEntry=docsDevFilterLLCEntry, docsDevFilterIpSourcePortLow=docsDevFilterIpSourcePortLow, docsDevResetNow=docsDevResetNow, docsDevEvLastTime=docsDevEvLastTime, docsDevFilterIpIndex=docsDevFilterIpIndex, docsDevNmAccessStatus=docsDevNmAccessStatus, docsDevCpeSource=docsDevCpeSource, docsDevFilterIpContinue=docsDevFilterIpContinue, docsDevFilterIpPolicyId=docsDevFilterIpPolicyId, docsDevFilterIpDefault=docsDevFilterIpDefault, docsDevFilterIpEntry=docsDevFilterIpEntry, docsDevDateTime=docsDevDateTime, docsDevEvReporting=docsDevEvReporting, docsDevCpe=docsDevCpe, docsDevNmAccessGroup=docsDevNmAccessGroup, docsDevNmAccessIp=docsDevNmAccessIp, docsDevEvThrottleAdminStatus=docsDevEvThrottleAdminStatus, docsDevBaseGroup=docsDevBaseGroup)
