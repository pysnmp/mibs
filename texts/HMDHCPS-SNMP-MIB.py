#
# PySNMP MIB module HMDHCPS-SNMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hirschmann/hmdhcps
# Produced by pysmi-1.1.10 at Fri Nov 10 09:18:40 2023
# On host fv-az1110-165 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
hmConfiguration, = mibBuilder.importSymbols("HMPRIV-MGMT-SNMP-MIB", "hmConfiguration")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Integer32, Gauge32, TimeTicks, IpAddress, ModuleIdentity, Unsigned32, iso, NotificationType, Counter64, ObjectIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Integer32", "Gauge32", "TimeTicks", "IpAddress", "ModuleIdentity", "Unsigned32", "iso", "NotificationType", "Counter64", "ObjectIdentity", "Bits")
DisplayString, MacAddress, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "TextualConvention", "RowStatus")
hmDhcps = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 14, 16))
hmDhcps.setRevisions(('2013-04-18 12:00', '2011-12-20 12:00', '2007-10-16 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmDhcps.setRevisionsDescriptions(('Added ICMP echo probe and pool vendor option.', 'Added pools per VLAN.', 'First release in SMIv2',))
if mibBuilder.loadTexts: hmDhcps.setLastUpdated('201304181200Z')
if mibBuilder.loadTexts: hmDhcps.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmDhcps.setContactInfo('Customer Support\r\n           Postal: \r\n           Hirschmann Automation and Control GmbH\r\n           Stuttgarter Str. 45-51\r\n           72654 Neckartenzlingen\r\n           Germany\r\n           Tel: +49 7127 14 1981\r\n           Web: http://www.hicomcenter.com/\r\n           E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmDhcps.setDescription('The Hirschmann Private DHCP MIB definitions for Platform devices.')
hmDHCPServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1))
hmDHCPServerConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1))
hmDHCPServerLeaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2))
hmDHCPServerInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3))
hmDHCPServerCounterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4))
hmDHCPServerMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerMode.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMode.setDescription('Enable or disable DHCP server global.')
hmDHCPServerMaxPoolEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerMaxPoolEntries.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMaxPoolEntries.setDescription('Maximum possible entries in hmDHCPServerPoolTable.')
hmDHCPServerMaxLeaseEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerMaxLeaseEntries.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerMaxLeaseEntries.setDescription('Maximum possible entries in hmDHCPServerLeaseTable.')
hmDHCPServerAddrProbe = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerAddrProbe.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerAddrProbe.setDescription('If set to enable the DHCP server probes the allocated address\r\n      with an ICMP Echo Request before offering to the client.')
hmDHCPServerPoolTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5), )
if mibBuilder.loadTexts: hmDHCPServerPoolTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolTable.setDescription('A table containing the DHCP server pools.')
hmDHCPServerPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerPoolIndex"))
if mibBuilder.loadTexts: hmDHCPServerPoolEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolEntry.setDescription('A logical row in the hmDHCPServerPoolTable.')
hmDHCPServerPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerPoolIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolIndex.setDescription('The index of hmDHCPServerPoolTable.')
hmDHCPServerPoolStartIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerPoolStartIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolStartIpAddress.setDescription('The IPv4 address of the first address in the range.  The \r\n      value of hmDHCPServerPoolStartIpAddress MUST be less than or \r\n      equal to the value of hmDHCPServerPoolEndIpAddress.')
hmDHCPServerPoolEndIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolEndIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolEndIpAddress.setDescription('The IPv4 address of the last address in the range.  The value \r\n      of hmDHCPServerPoolEndIpAddress MUST be greater than or equal \r\n      to the value of hmDHCPServerPoolStartIpAddress.')
hmDHCPServerPoolLeaseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 4), Unsigned32().clone(86400)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolLeaseTime.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolLeaseTime.setDescription("The pools lease time in number of seconds. \r\n      A value of 4294967295 SHOULD be used for leases that \r\n      have a lease time which is 'infinite' and for BOOTP leases.")
hmDHCPServerPoolFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 5), Bits().clone(namedValues=NamedValues(("interface", 0), ("mac", 1), ("gateway", 2), ("clientid", 3), ("remoteid", 4), ("circuitid", 5), ("dynamic", 6), ("vlanid", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolFlags.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolFlags.setDescription('This object shows the parameters\r\n      that are used to lease the IP Address.')
hmDHCPServerPoolIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolIfIndex.setDescription('The index of the interface.')
hmDHCPServerPoolMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 7), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolMacAddress.setDescription('The MAC Address of the  entry\r\n      that is used to lease the IP Address.')
hmDHCPServerPoolGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolGateway.setDescription('The IPv4 address of the Gatewayinterface\r\n      that is used to lease the IP Address.')
hmDHCPServerPoolClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 9), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolClientId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolClientId.setDescription('The Client Identifier of the entry\r\n      that is used to lease the IP Address.')
hmDHCPServerPoolRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 10), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolRemoteId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolRemoteId.setDescription('The Remote Identifier of the  entry\r\n      that is used to lease the IP Address.\r\n      The Remote Identifier must be send in\r\n      Option 82 as defined in RFC 3046.')
hmDHCPServerPoolCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 11), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolCircuitId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolCircuitId.setDescription('The Cicuit Identifier of the  entry\r\n      that is used to lease the IP Address.\r\n      The Circuit Identifier must be send in\r\n      Option 82 as defined in RFC 3046.')
hmDHCPServerPoolHirschmannClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolHirschmannClient.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolHirschmannClient.setDescription('Enable or disable Hirschmann Multicast.')
hmDHCPServerPoolVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolVlanId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolVlanId.setDescription('The Vlan ID of the entry that is used\r\n      to lease the IP Address. A value of -1 \r\n      corresponds to management vlan (the default),\r\n      any other value (1-4042) represents a specific VLAN')
hmDHCPServerPoolOptionConfFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionConfFileName.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionConfFileName.setDescription('Full specified name of the configuration file\r\n      e.g. tftp://192.9.200.1/cfg/config1.sav.\r\n      An empty string zeros the SNAME and the FILE field \r\n      in the DHCP header.')
hmDHCPServerPoolOptionGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 31), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionGateway.setDescription('The IPv4 address of the Gateway.\r\n      A value of 0 disables the attachment of the\r\n      option field in the DHCP message.')
hmDHCPServerPoolOptionNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 32), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionNetmask.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionNetmask.setDescription('The subnet mask.\r\n      A value of 0 disables the attachment of the\r\n      option field in the DHCP message.')
hmDHCPServerPoolOptionWINS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 33), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionWINS.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionWINS.setDescription('The IPv4 address of the WINS Server.\r\n      A value of 0 disables the attachment of the\r\n      option field in the DHCP message.')
hmDHCPServerPoolOptionDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 34), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionDNS.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionDNS.setDescription('The IPv4 address of the DNS Server.\r\n      A value of 0 disables the attachment of the\r\n      option field in the DHCP message.')
hmDHCPServerPoolOptionHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 35), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionHostname.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionHostname.setDescription('The name of the client (Option 12).\r\n      An empty string disables the attachment of the\r\n      option field in the DHCP message.')
hmDHCPServerPoolOptionVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolOptionVendor.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolOptionVendor.setDescription('Vendor Specific Information (Option 43) as hex string.')
hmDHCPServerPoolErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 99), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerPoolErrorStatus.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolErrorStatus.setDescription('The error Code by create a new Pool.')
hmDHCPServerPoolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 1, 5, 1, 100), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDHCPServerPoolRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerPoolRowStatus.setDescription('This object indicates the status of this entry.')
hmDHCPServerLeaseTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1), )
if mibBuilder.loadTexts: hmDHCPServerLeaseTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseTable.setDescription('A table containing the DHCP server leases.')
hmDHCPServerLeaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerLeasePoolIndex"), (0, "HMDHCPS-SNMP-MIB", "hmDHCPServerLeaseIpAddress"))
if mibBuilder.loadTexts: hmDHCPServerLeaseEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseEntry.setDescription('A logical row in the hmDHCPServerLeaseTable.')
hmDHCPServerLeasePoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeasePoolIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeasePoolIndex.setDescription('The index of the hmDHCPServerPoolTable above.')
hmDHCPServerLeaseIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseIpAddress.setDescription('This is an IP address from the pool with\r\n      index hmDHCPServerLeasePoolIndex.')
hmDHCPServerLeaseState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bootp", 1), ("offering", 2), ("requesting", 3), ("bound", 4), ("renewing", 5), ("rebinding", 6), ("declined", 7), ("released", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseState.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseState.setDescription('The state of the lease.')
hmDHCPServerLeaseTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseTimeRemaining.setDescription('The remaining time of the lease configured in\r\n      hmDHCPServerPoolLeaseTime.')
hmDHCPServerLeaseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseIfIndex.setDescription('The interface index where the lease\r\n      is currently active.')
hmDHCPServerLeaseClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseClientMacAddress.setDescription('The MAC Address of the  entry\r\n      that has leased the IP Address.')
hmDHCPServerLeaseGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseGateway.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseGateway.setDescription('The IPv4 address of the Gatewayinterface\r\n      that was used to lease the IP Address.')
hmDHCPServerLeaseClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseClientId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseClientId.setDescription('The Client Identifier of the entry\r\n      that was used to lease the IP Address.')
hmDHCPServerLeaseRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseRemoteId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseRemoteId.setDescription('The Remote Identifier of the entry\r\n      that was used to lease the IP Address.')
hmDHCPServerLeaseCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseCircuitId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseCircuitId.setDescription('The Cicuit Identifier of the entry\r\n      that was used to lease the IP Address.')
hmDHCPServerLeaseStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseStartTime.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseStartTime.setDescription('Lease start Time.')
hmDHCPServerLeaseAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("release", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerLeaseAction.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseAction.setDescription('Manually release this ip address for new assignment.')
hmDHCPServerLeaseVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerLeaseVlanId.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerLeaseVlanId.setDescription('The Vlan ID of the entry that is used\r\n      to lease the IP Address. A value of -1 \r\n      corresponds to management vlan (the default),\r\n      any other value (1-4042) represents a specific VLAN')
hmDHCPServerIfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1), )
if mibBuilder.loadTexts: hmDHCPServerIfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigTable.setDescription('A table containing current configuration information\r\n      for each interface.')
hmDHCPServerIfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerIfConfigIndex"))
if mibBuilder.loadTexts: hmDHCPServerIfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigEntry.setDescription('A logical row in the hmDHCPServerIfConfigTable.')
hmDHCPServerIfConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerIfConfigIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigIndex.setDescription('The index of the interface.')
hmDHCPServerIfConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDHCPServerIfConfigMode.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerIfConfigMode.setDescription('Enable or disable DHCP server on this interface.')
hmDHCPServerCounterIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2), )
if mibBuilder.loadTexts: hmDHCPServerCounterIfTable.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfTable.setDescription('A table containing current configuration information\r\n      for each interface.')
hmDHCPServerCounterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1), ).setIndexNames((0, "HMDHCPS-SNMP-MIB", "hmDHCPServerCounterIfIndex"))
if mibBuilder.loadTexts: hmDHCPServerCounterIfEntry.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfEntry.setDescription('A logical row in the hmDHCPServerCounterIfTable.')
hmDHCPServerCounterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterIfIndex.setDescription('The index of the interface.')
hmDHCPServerCounterBootpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpRequests.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpRequests.setDescription('The number of packets received that contain a Message Type of \r\n      1 (BOOTREQUEST) in the first octet and do not contain option \r\n      number 53 (DHCP Message Type) in the options.')
hmDHCPServerCounterBootpInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpInvalids.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpInvalids.setDescription('The number of packets received that do not contain a Message \r\n      Type of 1 (BOOTREQUEST) in the first octet or are not valid \r\n      BOOTP packets (e.g., too short, invalid field in packet \r\n      header).')
hmDHCPServerCounterBootpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpReplies.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpReplies.setDescription('The number of packets sent that contain a Message Type of 2 \r\n      (BOOTREPLY) in the first octet and do not contain option \r\n      number 53 (DHCP Message Type) in the options.')
hmDHCPServerCounterBootpDroppedUnknownClients = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedUnknownClients.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedUnknownClients.setDescription('The number of BOOTP packets dropped due to the server not \r\n      recognizing or not providing service to the hardware address \r\n      received in the incoming packet.')
hmDHCPServerCounterBootpDroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterBootpDroppedNotServingSubnet.setDescription('The number of BOOTP packets dropped due to the server not \r\n      being configured or not otherwise able to serve addresses on \r\n      the subnet from which this message was received.')
hmDHCPServerCounterDhcpv4Discovers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Discovers.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Discovers.setDescription('The number of DHCPDISCOVER (option 53 with value 1) packets \r\n      received.')
hmDHCPServerCounterDhcpv4Offers = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Offers.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Offers.setDescription('The number of DHCPOFFER (option 53 with value 2) packets \r\n      sent.')
hmDHCPServerCounterDhcpv4Requests = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Requests.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Requests.setDescription('The number of DHCPREQUEST (option 53 with value 3) packets \r\n      received.')
hmDHCPServerCounterDhcpv4Declines = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Declines.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Declines.setDescription('The number of DHCPDECLINE (option 53 with value 4) packets \r\n      received.')
hmDHCPServerCounterDhcpv4Acks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Acks.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Acks.setDescription('The number of DHCPACK (option 53 with value 5) packets sent.')
hmDHCPServerCounterDhcpv4Naks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Naks.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Naks.setDescription('The number of DHCPNACK (option 53 with value 6) packets \r\n      sent.')
hmDHCPServerCounterDhcpv4Releases = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Releases.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Releases.setDescription('The number of DHCPRELEASE (option 53 with value 7) packets \r\n      received.')
hmDHCPServerCounterDhcpv4Informs = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Informs.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Informs.setDescription('The number of DHCPINFORM (option 53 with value 8) packets \r\n      received.')
hmDHCPServerCounterDhcpv4ForcedRenews = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4ForcedRenews.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4ForcedRenews.setDescription('The number of DHCPFORCERENEW (option 53 with value 9) packets \r\n      sent.')
hmDHCPServerCounterDhcpv4Invalids = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Invalids.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4Invalids.setDescription('The number of DHCP packets received whose DHCP message type \r\n      (i.e., option number 53) is not understood or handled by the \r\n      server.')
hmDHCPServerCounterDhcpv4DroppedUnknownClient = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedUnknownClient.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedUnknownClient.setDescription('The number of DHCP packets dropped due to the server not \r\n      recognizing or not providing service to the client-id and/or \r\n      hardware address received in the incoming packet.')
hmDHCPServerCounterDhcpv4DroppedNotServingSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedNotServingSubnet.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterDhcpv4DroppedNotServingSubnet.setDescription('The number of DHCP packets dropped due to the server not \r\n      being configured or not otherwise able to serve addresses on \r\n      the subnet from which this message was received.')
hmDHCPServerCounterMiscOtherDhcpServer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 16, 1, 4, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDHCPServerCounterMiscOtherDhcpServer.setStatus('current')
if mibBuilder.loadTexts: hmDHCPServerCounterMiscOtherDhcpServer.setDescription('The number of BOOTP and DHCP packets from another\r\n      DHCP server seen on this interface.')
mibBuilder.exportSymbols("HMDHCPS-SNMP-MIB", hmDHCPServerLeaseTimeRemaining=hmDHCPServerLeaseTimeRemaining, hmDHCPServerPoolOptionConfFileName=hmDHCPServerPoolOptionConfFileName, hmDHCPServerLeaseIfIndex=hmDHCPServerLeaseIfIndex, hmDHCPServerLeaseTable=hmDHCPServerLeaseTable, hmDHCPServerCounterIfIndex=hmDHCPServerCounterIfIndex, hmDHCPServerIfConfigIndex=hmDHCPServerIfConfigIndex, hmDHCPServerLeaseGroup=hmDHCPServerLeaseGroup, hmDHCPServerPoolOptionNetmask=hmDHCPServerPoolOptionNetmask, hmDHCPServerCounterBootpReplies=hmDHCPServerCounterBootpReplies, hmDHCPServerCounterDhcpv4Naks=hmDHCPServerCounterDhcpv4Naks, hmDHCPServerPoolClientId=hmDHCPServerPoolClientId, hmDHCPServerLeaseAction=hmDHCPServerLeaseAction, hmDHCPServerMode=hmDHCPServerMode, hmDHCPServerCounterGroup=hmDHCPServerCounterGroup, hmDHCPServerPoolHirschmannClient=hmDHCPServerPoolHirschmannClient, hmDHCPServerPoolOptionVendor=hmDHCPServerPoolOptionVendor, hmDHCPServerLeaseRemoteId=hmDHCPServerLeaseRemoteId, hmDHCPServerCounterIfEntry=hmDHCPServerCounterIfEntry, hmDHCPServerCounterDhcpv4Invalids=hmDHCPServerCounterDhcpv4Invalids, hmDHCPServerCounterDhcpv4ForcedRenews=hmDHCPServerCounterDhcpv4ForcedRenews, hmDHCPServerMaxPoolEntries=hmDHCPServerMaxPoolEntries, hmDHCPServerLeaseCircuitId=hmDHCPServerLeaseCircuitId, hmDHCPServerPoolOptionGateway=hmDHCPServerPoolOptionGateway, hmDHCPServerLeaseIpAddress=hmDHCPServerLeaseIpAddress, hmDHCPServerMaxLeaseEntries=hmDHCPServerMaxLeaseEntries, hmDHCPServerGroup=hmDHCPServerGroup, hmDHCPServerCounterDhcpv4Releases=hmDHCPServerCounterDhcpv4Releases, hmDHCPServerPoolGateway=hmDHCPServerPoolGateway, hmDHCPServerCounterDhcpv4Discovers=hmDHCPServerCounterDhcpv4Discovers, hmDHCPServerCounterDhcpv4Informs=hmDHCPServerCounterDhcpv4Informs, hmDHCPServerPoolEntry=hmDHCPServerPoolEntry, hmDHCPServerCounterBootpDroppedNotServingSubnet=hmDHCPServerCounterBootpDroppedNotServingSubnet, hmDHCPServerPoolOptionWINS=hmDHCPServerPoolOptionWINS, hmDHCPServerPoolLeaseTime=hmDHCPServerPoolLeaseTime, hmDHCPServerLeaseGateway=hmDHCPServerLeaseGateway, hmDHCPServerCounterDhcpv4Offers=hmDHCPServerCounterDhcpv4Offers, hmDHCPServerPoolOptionDNS=hmDHCPServerPoolOptionDNS, hmDHCPServerPoolIndex=hmDHCPServerPoolIndex, hmDHCPServerCounterDhcpv4DroppedNotServingSubnet=hmDHCPServerCounterDhcpv4DroppedNotServingSubnet, hmDHCPServerLeaseClientMacAddress=hmDHCPServerLeaseClientMacAddress, hmDHCPServerCounterIfTable=hmDHCPServerCounterIfTable, hmDHCPServerCounterDhcpv4DroppedUnknownClient=hmDHCPServerCounterDhcpv4DroppedUnknownClient, hmDHCPServerIfConfigMode=hmDHCPServerIfConfigMode, hmDHCPServerLeaseEntry=hmDHCPServerLeaseEntry, hmDHCPServerPoolErrorStatus=hmDHCPServerPoolErrorStatus, hmDHCPServerPoolFlags=hmDHCPServerPoolFlags, hmDHCPServerLeaseStartTime=hmDHCPServerLeaseStartTime, hmDHCPServerLeaseVlanId=hmDHCPServerLeaseVlanId, hmDHCPServerPoolCircuitId=hmDHCPServerPoolCircuitId, hmDHCPServerIfConfigTable=hmDHCPServerIfConfigTable, hmDHCPServerInterfaceGroup=hmDHCPServerInterfaceGroup, hmDHCPServerCounterDhcpv4Acks=hmDHCPServerCounterDhcpv4Acks, hmDHCPServerPoolStartIpAddress=hmDHCPServerPoolStartIpAddress, hmDHCPServerPoolRemoteId=hmDHCPServerPoolRemoteId, hmDHCPServerCounterBootpInvalids=hmDHCPServerCounterBootpInvalids, hmDHCPServerLeasePoolIndex=hmDHCPServerLeasePoolIndex, hmDHCPServerCounterDhcpv4Declines=hmDHCPServerCounterDhcpv4Declines, hmDHCPServerConfigGroup=hmDHCPServerConfigGroup, hmDHCPServerCounterBootpRequests=hmDHCPServerCounterBootpRequests, PYSNMP_MODULE_ID=hmDhcps, hmDHCPServerAddrProbe=hmDHCPServerAddrProbe, hmDHCPServerPoolMacAddress=hmDHCPServerPoolMacAddress, hmDHCPServerPoolTable=hmDHCPServerPoolTable, hmDHCPServerCounterDhcpv4Requests=hmDHCPServerCounterDhcpv4Requests, hmDHCPServerPoolRowStatus=hmDHCPServerPoolRowStatus, hmDHCPServerPoolIfIndex=hmDHCPServerPoolIfIndex, hmDHCPServerCounterMiscOtherDhcpServer=hmDHCPServerCounterMiscOtherDhcpServer, hmDHCPServerLeaseClientId=hmDHCPServerLeaseClientId, hmDHCPServerLeaseState=hmDHCPServerLeaseState, hmDHCPServerPoolEndIpAddress=hmDHCPServerPoolEndIpAddress, hmDHCPServerPoolOptionHostname=hmDHCPServerPoolOptionHostname, hmDHCPServerCounterBootpDroppedUnknownClients=hmDHCPServerCounterBootpDroppedUnknownClients, hmDHCPServerPoolVlanId=hmDHCPServerPoolVlanId, hmDHCPServerIfConfigEntry=hmDHCPServerIfConfigEntry, hmDhcps=hmDhcps)
