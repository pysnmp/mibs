#
# PySNMP MIB module IEEE8021-CFMD8-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/iee/IEEE8021-CFMD8-MIB
# Produced by pysmi-1.1.8 at Fri Jan 27 13:58:59 2023
# On host fv-az417-962 platform Linux version 5.15.0-1031-azure by user runner
# Using Python version 3.10.9 (main, Dec  7 2022, 08:16:13) [GCC 11.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
LldpPortId, LldpChassisId, LldpChassisIdSubtype, LldpPortIdSubtype = mibBuilder.importSymbols("LLDP-MIB", "LldpPortId", "LldpChassisId", "LldpChassisIdSubtype", "LldpPortIdSubtype")
VlanIdOrNone, VlanId = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIdOrNone", "VlanId")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
ObjectIdentity, Unsigned32, Counter32, Integer32, ModuleIdentity, Counter64, Gauge32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, MibIdentifier, TimeTicks, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Unsigned32", "Counter32", "Integer32", "ModuleIdentity", "Counter64", "Gauge32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "MibIdentifier", "TimeTicks", "iso")
TextualConvention, TimeStamp, TimeInterval, RowStatus, MacAddress, TDomain, TruthValue, DisplayString, TAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "TimeInterval", "RowStatus", "MacAddress", "TDomain", "TruthValue", "DisplayString", "TAddress")
ieee8021cfmMIB = ModuleIdentity((1, 3, 111, 2, 802, 1, 1, 8))
ieee8021cfmMIB.setRevisions(('2007-01-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ieee8021cfmMIB.setRevisionsDescriptions(('Included in IEEE P802.1ag Draft 8.',))
if mibBuilder.loadTexts: ieee8021cfmMIB.setLastUpdated('200701240000Z')
if mibBuilder.loadTexts: ieee8021cfmMIB.setOrganization('IEEE 802.1 Working Group')
if mibBuilder.loadTexts: ieee8021cfmMIB.setContactInfo('WG-URL: http://grouper.ieee.org/groups/802/1/index.html\nWG-EMail: stds-802-1@ieee.org\nContact: David Elie-Dit-Cosaque\nAlcatel North America\n3400 W. Plano Pkwy.\nPlano, TX 75075, USA\nE-mail: david.elie_dit_cosaque@alcatel.com\nContact: Norman Finn\nCisco Systems\n170 W. Tasman Drive\nSJ-03/2/2\nSan Jose, CA 95134, USA\nE-mail: nfinn@cisco.com\n')
if mibBuilder.loadTexts: ieee8021cfmMIB.setDescription('Connectivity Fault Management module for managing IEEE 802.1ag')
dot1agNotifications = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 0))
dot1agMIBObjects = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1))
dot1agCfmConformance = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2))
dot1agCfmStack = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 1))
dot1agCfmDefaultMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 2))
dot1agCfmVlan = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 3))
dot1agCfmConfigErrorList = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 4))
dot1agCfmMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 5))
dot1agCfmMa = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 6))
dot1agCfmMep = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 7))
class Dot1agCfmMaintDomainNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5, Table 21-19'
    description = 'A value that represents a type (and thereby the format)\nof a Dot1agCfmMaintDomainName. The value can be one of\nthe following:\nieeeReserved(0) Reserved for definition by IEEE 802.1\nrecommend to not use zero unless\nabsolutely needed.\nnone(1) No format specified, usually because\nthere is not (yet) a Maintenance\nDomain Name. In this case, a zero\nlength OCTET STRING for the Domain\nName field is acceptable.\ndnsLikeName(2) Domain Name like string, globally unique\ntext string derived from a DNS name.\nmacAddrAndUint(3) MAC address + 2-octet (unsigned) integer.\ncharString(4) RFC2579 DisplayString, except that the\ncharacter codes 0-31 (decimal) are not\nused.\nieeeReserved(xx) Reserved for definition by IEEE 802.1\nxx values can be [5..31] and [64..255]\nituReserved(xx) Reserved for definition by ITU-T Y.1731\nxx values range from [32..63]\nTo support future extensions, the Dot1agCfmMaintDomainNameType\ntextual convention SHOULD NOT be sub-typed in object type\ndefinitions. It MAY be sub-typed in compliance statements in\norder to require only a subset of these address types for a\ncompliant implementation.\nImplementations must ensure that Dot1agCfmMaintDomainNameType\nobjects and any dependent objects (e.g.,\nDot1agCfmMaintDomainName objects) are consistent. An\ninconsistentValue error must be generated if an attempt to\nchange an Dot1agCfmMaintDomainNameType object would, for\nexample, lead to an undefined Dot1agCfmMaintDomainName value.\nIn particular,\nDot1agCfmMaintDomainNameType/Dot1agCfmMaintDomainName pairs\nmust be changed together if the nameType changes.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("dnsLikeName", 2), ("macAddressAndUint", 3), ("charString", 4))

class Dot1agCfmMaintDomainName(TextualConvention, OctetString):
    reference = '802.1ag clause 21.6.5'
    description = "Denotes a generic Maintenance Domain Name.\nA Dot1agCfmMaintDomainName value is always interpreted within\nthe context of a Dot1agCfmMaintDomainNameType value. Every\nusage of the Dot1agCfmMaintDomainName textual convention is\nrequired to specify the Dot1agCfmMaintDomainNameType object\nthat provides the context. It is suggested that the\nDot1agCfmMaintDomainNameType object be logically registered\nbefore the object(s) that use the Dot1agCfmMaintDomainName\ntextual convention, if they appear in the same logical row.\nThe value of a Dot1agCfmMaintDomainName object must always\nbe consistent with the value of the associated\nDot1agCfmMaintDomainNameType object. Attempts to set\nan Dot1agCfmMaintDomainName object to a value inconsistent\nwith the associated Dot1agCfmMaintDomainNameType must fail\nwith an inconsistentValue error.\nWhen this textual convention is used as the syntax of an\nindex object, there may be issues with the limit of 128\nsub-identifiers specified in SMIv2, IETF STD 58. In this\ncase, the object definition MUST include a 'SIZE' clause\nto limit the number of potential instance sub-identifiers;\notherwise the applicable constraints MUST be stated in\nthe appropriate conceptual row DESCRIPTION clauses, or\nin the surrounding documentation if there is no single\nDESCRIPTION clause that is appropriate.\nA value of none(1) in the associated\nDot1agCfmMaintDomainNameType object means that no Maintenance\nDomain name is present, and the contents of the\nDot1agCfmMaintDomainName object are meaningless.\nSee the DESCRIPTION of the Dot1agCfmMaintAssocNameType\nTEXTUAL-CONVENTION for a discussion of the length limits on\nthe Maintenance Domain name and Maintenance Association name.\n"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 43)

class Dot1agCfmMaintAssocNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5.4, Table 21-20'
    description = 'A value that represents a type (and thereby the format)\nof a Dot1agCfmMaintAssocName. The value can be one of\nthe following:\nieeeReserved(0) Reserved for definition by IEEE 802.1\nrecommend to not use zero unless\nabsolutely needed.\nprimaryVid(1) Primary VLAN ID.\n12 bits represented in a 2-octet integer:\n- 4 least significant bits of the first\nbyte contains the 4 most significant\nbits of the 12 bits primary VID\n- second byte contains the 8 least\nsignificant bits of the primary VID\n0 1 2 3 4 5 6 7 8\n+-+-+-+-+-+-+-+-+\n|0 0 0 0| (MSB) |\n+-+-+-+-+-+-+-+-+\n| VID LSB |\n+-+-+-+-+-+-+-+-+\ncharString(2) RFC2579 DisplayString, except that the\ncharacter codes 0-31 (decimal) are not\nused. (1..45) octets\nunsignedInt16 (3) 2-octet integer/big endian\nrfc2865VpnId(4) RFC 2685 VPN ID\n3 octet VPN authority Organizationally\nUnique Identifier followed by 4 octet VPN\nindex identifying VPN according to the OUI:\n0 1 2 3 4 5 6 7 8\n+-+-+-+-+-+-+-+-+\n| VPN OUI (MSB) |\n+-+-+-+-+-+-+-+-+\n| VPN OUI |\n+-+-+-+-+-+-+-+-+\n| VPN OUI (LSB) |\n+-+-+-+-+-+-+-+-+\n|VPN Index (MSB)|\n+-+-+-+-+-+-+-+-+\n| VPN Index |\n+-+-+-+-+-+-+-+-+\n| VPN Index |\n+-+-+-+-+-+-+-+-+\n|VPN Index (LSB)|\n+-+-+-+-+-+-+-+-+\nieeeReserved(xx) Reserved for definition by IEEE 802.1\nxx values can be [5..31] and [64..255]\nituReserved(xx) Reserved for definition by ITU-T Y.1731\nxx values range from [32..63]\nTo support future extensions, the Dot1agCfmMaintAssocNameType\ntextual convention SHOULD NOT be sub-typed in object type\ndefinitions. It MAY be sub-typed in compliance statements in\norder to require only a subset of these address types for a\ncompliant implementation.\nImplementations must ensure that Dot1agCfmMaintAssocNameType\nobjects and any dependent objects (e.g.,\nDot1agCfmMaintAssocName objects) are consistent. An\ninconsistentValue error must be generated if an attempt to\nchange an Dot1agCfmMaintAssocNameType object would, for\nexample, lead to an undefined Dot1agCfmMaintAssocName value.\nIn particular,\nDot1agCfmMaintAssocNameType/Dot1agCfmMaintAssocName pairs\nmust be changed together if the nameType changes.\nThe Maintenance Domain name and Maintenance Association name,\nwhen put together into the CCM PDU, MUST total 48 octets or\nless. If the Dot1agCfmMaintDomainNameType object contains\nnone(1), then the Dot1agCfmMaintAssocName object MUST be\n45 octets or less in length. Otherwise, the length of\nthe Dot1agCfmMaintDomainName object plus the length of the\nDot1agCfmMaintAssocName object, added together, MUST total\nless than or equal to 44 octets.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("primaryVid", 1), ("charString", 2), ("unsignedInt16", 3), ("rfc2865VpnId", 4))

class Dot1agCfmMaintAssocName(TextualConvention, OctetString):
    reference = '802.1ag clauses 21.6.5.4, 21.6.5.5, 21.6.5.6'
    description = "Denotes a generic Maintenance Association Name. It is the\npart of the Maintenance Association Identifier which is\nunique within the Maintenance Domain Name and is appended\nto the Maintenance Domain Name to form the Maintenance\nAssociation Identifier (MAID).\nA Dot1agCfmMaintAssocName value is always interpreted within\nthe context of a Dot1agCfmMaintAssocNameType value. Every\nusage of the Dot1agCfmMaintAssocName textual convention is\nrequired to specify the Dot1agCfmMaintAssocNameType object\nthat provides the context. It is suggested that the\nDot1agCfmMaintAssocNameType object be logically registered\nbefore the object(s) that use the Dot1agCfmMaintAssocName\ntextual convention, if they appear in the same logical row.\nThe value of a Dot1agCfmMaintAssocName object must\nalways be consistent with the value of the associated\nDot1agCfmMaintAssocNameType object. Attempts to set\nan Dot1agCfmMaintAssocName object to a value inconsistent\nwith the associated Dot1agCfmMaintAssocNameType must fail\nwith an inconsistentValue error.\nWhen this textual convention is used as the syntax of an\nindex object, there may be issues with the limit of 128\nsub-identifiers specified in SMIv2, IETF STD 58. In this\ncase, the object definition MUST include a 'SIZE' clause\nto limit the number of potential instance sub-identifiers;\notherwise the applicable constraints MUST be stated in\nthe appropriate conceptual row DESCRIPTION clauses, or\nin the surrounding documentation if there is no single\nDESCRIPTION clause that is appropriate.\n"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 45)

class Dot1agCfmMDLevel(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 21.4.1'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\nHigher numbers correspond to higher Maintenance Domains,\nthose with the greatest physical reach, with the highest\nvalues for customers' CFM PDUs. Lower numbers correspond\nto lower Maintenance Domains, those with more limited\nphysical reach, with the lowest values for CFM PDUs\nprotecting single bridges or physical links.\n"
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class Dot1agCfmMDLevelOrNone(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 12.14.3.1.3:c'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\nHigher numbers correspond to higher Maintenance Domains,\nthose with the greatest physical reach, with the highest\nvalues for customers' CFM packets. Lower numbers correspond\nto lower Maintenance Domains, those with more limited\nphysical reach, with the lowest values for CFM PDUs\nprotecting single bridges or physical links.\nThe value (-1) is reserved to indicate that no MA Level has\nbeen assigned.\n"
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 7), )
class Dot1agCfmMpDirection(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.3.2:c'
    description = 'Indicates the direction in which the Maintenance\nassociation (MEP or MIP) faces on the bridge port:\ndown(1) Sends Continuity Check Messages away from the\nMAC Relay Entity.\nup(2) Sends Continuity Check Messages towards the\nMAC Relay Entity.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("down", 1), ("up", 2))

class Dot1agCfmPortStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:f, 20.19.3 and 21.5.4'
    description = 'An enumerated value from he Port Status TLV from the last CCM\nreceived from the last MEP. It indicates the ability of the\nBridge Port on which the transmitting MEP resides to pass\nordinary data, regardless of the status of the MAC\n(Table 21-10).\npsNoPortStateTLV(0) Indicates either that no CCM has been\nreceived or that no port status TLV was\npresent in the last CCM received.\npsBlocked(1) Ordinary data cannot pass freely through\nthe port on which the remote MEP resides.\nValue of enableRmepDefect is equal to\nfalse.\npsUp(2): Ordinary data can pass freely through\nthe port on which the remote MEP resides.\nValue of enableRmepDefect is equal to\ntrue.\nNOTE: A 0 value is used for psNoPortStateTLV, so that\nadditional code points can be added in a manner\nconsistent with the Dot1agCfmInterfaceStatus textual\nconvention.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("psNoPortStateTLV", 0), ("psBlocked", 1), ("psUp", 2))

class Dot1agCfmInterfaceStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:g, 20.19.4 and 21.5.5'
    description = 'An enumerated value from the Interface Status TLV from the\nlast CCM received from the last MEP. It indicates the status\nof the Interface within which the MEP transmitting the CCM\nis configured, or the next lower Interface in the Interface\nStack, if the MEP is not configured within an Interface.\nisNoInterfaceStatusTLV(0) Indicates either that no CCM has been\nreceived or that no interface status TLV\nwas present in the last CCM received.\nisUp(1) The interface is ready to pass packets.\nisDown(2) The interface cannot pass packets\nisTesting(3) The interface is in some test mode.\nisUnknown(4) The interface status cannot be determined\nfor some reason.\nisDormant(5) The interface is not in a state to pass\npackets but is in a pending state, waiting\nfor some external event.\nisNotPresent(6) Some component of the interface is missing\nisLowerLayerDown(7) The interface is down due to state of the\nlower layer interfaces\nNOTE: A 0 value is used for isNoInterfaceStatusTLV, so that\nthese code points can be kept consistent with new code\npoints added to ifOperStatus in the IF-MIB.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("isNoInterfaceStatusTLV", 0), ("isUp", 1), ("isDown", 2), ("isTesting", 3), ("isUnknown", 4), ("isDormant", 5), ("isNotPresent", 6), ("isLowerLayerDown", 7))

class Dot1agCfmHighestDefectPri(TextualConvention, Integer32):
    reference = '802.1ag clause 20.1.2, 12.14.7.7.2:c and 20.33.9'
    description = 'An enumerated value, equal to the contents of the variable\nhighestDefect (20.33.9 and Table 20-1), indicating the\nhighest-priority defect that has been present since the MEP\nFault Notification Generator State Machine was last in the\nFNG_RESET state, either:\nnone(0) no defects since FNG_RESET\ndefRDICCM(1) DefRDICCM\ndefMACstatus(2) DefMACstatus\ndefRemoteCCM(3) DefRemoteCCM\ndefErrorCCM(4) DefErrorCCM\ndefXconCCM(5) DefXconCCM\nThe value 0 is used for no defects so that additional higher\npriority values can be added, if needed, at a later time, and\nso that these values correspond with those in\nDot1agCfmLowestAlarmPri.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("defRDICCM", 1), ("defMACstatus", 2), ("defRemoteCCM", 3), ("defErrorCCM", 4), ("defXconCCM", 5))

class Dot1agCfmLowestAlarmPri(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:k and 20.9.5'
    description = 'An integer value specifying the lowest priority defect\nthat is allowed to generate a Fault Alarm (20.9.5), either:\nallDef(1) DefRDICCM, DefMACstatus, DefRemoteCCM,\nDefErrorCCM, and DefXconCCM;\nmacRemErrXcon(2) Only DefMACstatus, DefRemoteCCM,\nDefErrorCCM, and DefXconCCM (default);\nremErrXcon(3) Only DefRemoteCCM, DefErrorCCM,\nand DefXconCCM;\nerrXcon(4) Only DefErrorCCM and DefXconCCM;\nxcon(5) Only DefXconCCM; or\nnoXcon(6) No defects DefXcon or lower are to be\nreported;\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("allDef", 1), ("macRemErrXcon", 2), ("remErrXcon", 3), ("errXcon", 4), ("xcon", 5), ("noXcon", 6))

class Dot1agCfmMepId(TextualConvention, Unsigned32):
    reference = '802.1ag clauses 3.19 and 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\ninteger, unique over a given Maintenance Association,\nidentifying a specific MEP.\n'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 8191)

class Dot1agCfmMepIdOrZero(TextualConvention, Unsigned32):
    reference = '802.1ag clause 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\ninteger, unique over a given Maintenance Association,\nidentifying a specific MEP.\nThe special value 0 is allowed to indicate special cases, for\nexample that no MEPID is configured.\nWhenever an object is defined with this SYNTAX, then the\nDESCRIPTION clause of such an object MUST specify what the\nspecial value of 0 means.\n'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), )
class Dot1agCfmMhfCreation(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.5.1.3:c and 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs.\nThe valid values are:\ndefMHFnone(1) No MHFs can be created for this VID.\ndefMHFdefault(2) MHFs can be created on this VID on any\nBridge port through which this VID can\npass.\ndefMHFexplicit(3) MHFs can be created for this VID only on\nBridge ports through which this VID can\npass, and only if a MEP is created at some\nlower MD Level.\ndefMHFdefer(4) The creation of MHFs is determined by the\ncorresponding Maintenance Domain variable\n(dot1agCfmMaMhfCreation).\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3), ("defMHFdefer", 4))

class Dot1agCfmIdPermission(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.6.1.3:d and 21.5.3'
    description = 'Indicates what, if anything, is to be included in the Sender\nID TLV transmitted in CCMs, LBMs, LTMs, and LTRs. The valid\nvalues are:\nsendIdNone(1) The Sender ID TLV is not to be sent.\nsendIdChassis(2) The Chassis ID Length, Chassis ID\nSubtype, and Chassis ID fields of the\nSender ID TLV are to be sent.\nsendIdManage(3) The Management Address Length and\nManagement Address of the Sender ID TLV\nare to be sent.\nsendIdChassisManage(4) The Chassis ID Length, Chassis ID\nSubtype, Chassis ID, Management Address\nLength and Management Address fields are\nall to be sent.\nsendIdDefer(5) The contents of the Sender ID TLV are\ndetermined by the corresponding\nMaintenance Domain variable\n(dot1agCfmMaIdPermission).\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4), ("sendIdDefer", 5))

class Dot1agCfmCcmInterval(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.1.3:e, 20.8.1 and 21.6.1.3'
    description = "Indicates the interval at which CCMs are sent by a MEP.\nThe possible values are:\nintervalInvalid(0) No CCMs are sent (disabled).\ninterval300Hz(1) CCMs are sent every 3 1/3 milliseconds\n(300Hz).\ninterval10ms(2) CCMs are sent every 10 milliseconds.\ninterval100ms(3) CCMs are sent every 100 milliseconds.\ninterval1s(4) CCMs are sent every 1 second.\ninterval10s(5) CCMs are sent every 10 seconds.\ninterval1min(6) CCMs are sent every minute.\ninterval10min(7) CCMs are sent every 10 minutes.\nNote: enumerations start at zero to match the 'CCM Interval\nfield' protocol field.\n"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("intervalInvalid", 0), ("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7))

class Dot1agCfmFngState(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:f and 20.35'
    description = 'Indicates the diferent states of the MEP Fault Notification\nGenerator State Machine.\nfngReset(1) No defect has been present since the\ndot1agCfmMepFngResetTime timer\nexpired, or since the state machine\nwas last reset.\nfngDefect(2) A defect is present, but not for a\nlong enough time to be reported\n(dot1agCfmMepFngAlarmTime).\nfngReportDefect(3) A momentary state during which the\ndefect is reported by sending a\ndot1agCfmFaultAlarm notification,\nif that action is enabled.\nfngDefectReported(4) A defect is present, and some defect\nhas been reported.\nfngDefectClearing(5) No defect is present, but the\ndot1agCfmMepFngResetTime timer has\nnot yet expired.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("fngReset", 1), ("fngDefect", 2), ("fngReportDefect", 3), ("fngDefectReported", 4), ("fngDefectClearing", 5))

class Dot1agCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.5, 21.9.5, and\nTable 21-27'
    description = 'Possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class Dot1agCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.6, 21.9.8.1, and\nTable 21-30\n'
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class Dot1agCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:o, 20.36.2.10, 21.9.9.1, and\nTable 21-32'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class Dot1agCfmRemoteMepState(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.6.3:b, 20.22'
    description = 'Operational state of the remote MEP state machine. This\nstate machine monitors the reception of valid CCMs from a\nremote MEP with a specific MEPID. It uses a timer that\nexpires in 3.5 times the length of time indicated by the\ndot1agCfmMaCcmInterval object.\nrMepIdle(1) Momentary state during reset.\nrMepStart(2) The timer has not expired since the\nstate machine was reset, and no valid\nCCM has yet been received.\nrMepFailed(3) The timer has expired, both since the\nstate machine was reset, and since a\nvalid CCM was received.\nrMepOk(4) The timer has not expired since a\nvalid CCM was received.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("rMepIdle", 1), ("rMepStart", 2), ("rMepFailed", 3), ("rMepOk", 4))

class Dot1afCfmIndexIntegerNextFree(TextualConvention, Unsigned32):
    description = 'An integer which may be used as a new Index in a table.\nThe special value of 0 indicates that no more new entries can\nbe created in the relevant table.\nWhen a MIB is used for configuration, an object with this\nSYNTAX always contains a legal value (if non-zero) for an\nindex that is not currently used in the relevant table. The\nCommand Generator (Network Management Application) reads this\nvariable and uses the (non-zero) value read when creating a\nnew row with an SNMP SET. When the SET is performed, the\nCommand Responder (agent) must determine whether the value is\nindeed still unused; Two Network Management Applications may\nattempt to create a row (configuration entry) simultaneously\nand use the same value. If it is currently unused, the SET\nsucceeds and the Command Responder (agent) changes the value\nof this object, according to an implementation-specific\nalgorithm. If the value is in use, however, the SET fails.\nThe Network Management Application must then re-read this\nvariable to obtain a new usable value.\nAn OBJECT-TYPE definition using this SYNTAX MUST specify the\nrelevant table for which the object is providing this\nfunctionality.\n'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class Dot1agCfmMepDefects(TextualConvention, Bits):
    reference = '802.1ag clauses 12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q,\n12.14.7.1.3:r, and 12.14.7.1.3:s.'
    description = 'A MEP can detect and report a number of defects, and multiple\ndefects can be present at the same time. These defects are:\nbDefRDICCM(0) A remote MEP is reported the RDI bit in its\nlast CCM.\nbDefMACstatus(1) Either some remote MEP is reporting its\nInterface Status TLV as not isUp, or all remote\nMEPs are reporting a Port Status TLV that\ncontains some value other than psUp.\nbDefRemoteCCM(2) The MEP is not receiving valid CCMs from at\nleast one of the remote MEPs.\nbDefErrorCCM(3) The MEP has received at least one invalid CCM\nwhose CCM Interval has not yet timed out.\nbDefXconCCM(4) The MEP has received at least one CCM from\neither another MAID or a lower MD Level whose\nCCM Interval has not yet timed out.\n'
    status = 'current'
    namedValues = NamedValues(("bDefRDICCM", 0), ("bDefMACstatus", 1), ("bDefRemoteCCM", 2), ("bDefErrorCCM", 3), ("bDefXconCCM", 4))

class Dot1agCfmConfigErrors(TextualConvention, Bits):
    reference = '802.1ag clause 12.14.4.1.3:b and clauses 22.2.3 and 22.2.4'
    description = "While making the MIP creation evaluation described in 802.1ag\nclause 22.2.3, the management entity can encounter errors in\nthe configuration. These are possible errors that can be\nencountered:\nCFMleak(0) MA x is associated with a specific VID list,\none or more of the VIDs in MA x can pass through\nthe Bridge Port, no Down MEP is configured on\nany Bridge Port for MA x, and some other MA y,\nat a higher MD Level than MA x, and associated\nwith at least one of the VID(s) also in MA x,\ndoes have a MEP configured on the Bridge Port.\nconflictingVids(1) MA x is associated with a specific VID\nlist, an Up MEP is configured on MA x on the\nBridge Port, and some other MA y, associated\nwith at least one of the VID(s) also in MA x,\nalso has an Up MEP configured on some Bridge\nPort.\nExcessiveLevels(2) The number of different MD Levels at\nwhich MIPs are to be created on this port\nexceeds the Bridge's capabilities (see\nsubclause 22.3).\nOverlappedLevels(3) A MEP is created for one VID at one MD\nLevel, but a MEP is configured on another\nVID at that MD Level or higher, exceeding\nthe Bridge's capabilities.\n"
    status = 'current'
    namedValues = NamedValues(("cfmLeak", 0), ("conflictingVids", 1), ("excessiveLevels", 2), ("overlappedLevels", 3))

dot1agCfmStackTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1), )
if mibBuilder.loadTexts: dot1agCfmStackTable.setReference('802.1ag clauses 12.14.2')
if mibBuilder.loadTexts: dot1agCfmStackTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackTable.setDescription('There is one CFM Stack table per bridge. It permits\nthe retrieval of information about the Maintenance Points\nconfigured on any given interface.\n')
dot1agCfmStackEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmStackifIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmStackVlanIdOrNone"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmStackMdLevel"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmStackDirection"))
if mibBuilder.loadTexts: dot1agCfmStackEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackEntry.setDescription('The Stack table entry')
dot1agCfmStackifIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setReference('802.1ag clause 12.14.2.1.2:a')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setDescription('This object represents the Bridge Port or aggregated port\non which MEPs or MHFs might be configured.\nUpon a restart of the system, the system SHALL, if necessary,\nchange the value of this variable, and rearrange the\ndot1agCfmStackTable, so that it indexes the entry in the\ninterface table with the same value of ifAlias that it\nindexed before the system restart. If no such entry exists,\nthen the system SHALL delete all entries in the\ndot1agCfmStackTable with the interface index.\n')
dot1agCfmStackVlanIdOrNone = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 2), VlanIdOrNone())
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setReference('802.1ag clause 12.14.2.1.2:d')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setDescription('VLAN ID to which the MP is attached, or 0, if none.')
dot1agCfmStackMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 3), Dot1agCfmMDLevel())
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setReference('802.1ag clause 12.14.2.1.2:b')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setDescription('MD Level of the Maintenance Point.')
dot1agCfmStackDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 4), Dot1agCfmMpDirection())
if mibBuilder.loadTexts: dot1agCfmStackDirection.setReference('802.1ag clause 12.14.2.1.2:c')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setDescription('Direction in which the MP faces on the Bridge Port')
dot1agCfmStackMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setReference('802.1ag clause 12.14.2.1.3:b')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setDescription('The index of the Maintenance Domain in the dot1agCfmMdTable\nto which the MP is associated, or 0, if none.')
dot1agCfmStackMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setReference('802.1ag clause 12.14.2.1.3:c')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setDescription('The index of the MA in the dot1agCfmMaTable to which the MP\nis associated, or 0, if none.')
dot1agCfmStackMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 7), Dot1agCfmMepIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMepId.setReference('802.1ag clause 12.14.2.1.3:d')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setDescription('If an MEP is configured, the MEPID, else 0')
dot1agCfmStackMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setReference('802.1ag clause 12.14.2.1.3:e')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setDescription('MAC address of the MP.')
dot1agCfmVlanTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1), )
if mibBuilder.loadTexts: dot1agCfmVlanTable.setReference('802.1ag clauses 12.14.3.1.3:a, 12.14.3.2.2:a, 12.14.5.3.2:c,\n12.14.6.1.3:b, 22.1.5.')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setDescription('This table defines the association of VIDs into VLANs. There\nis an entry in this table for each VID that is:\na) a VID belonging to a VLAN associated with more than\none VID; and\nb) not the Primary VLAN of that VID.\nThe entry in this table contains the Primary VID of the VLAN.\nBy default, this table is empty, meaning that every VID is\nthe Primary VID of a single-VID VLAN.\nVLANs that are associated with only one VID SHOULD NOT have\nan entry in this table.\nThe writable objects in this table need to be persistent\nupon reboot or restart of a device.\n')
dot1agCfmVlanEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmVlanVid"))
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setDescription('The VLAN table entry.')
dot1agCfmVlanVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmVlanVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanVid.setDescription('This is a VLAN ID belonging to a VLAN that is associated with\nmore than one VLAN ID, and this is not the Primary VID of the\nVLAN.\n')
dot1agCfmVlanPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 2), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setDescription("This is the Primary VLAN ID of the VLAN with which this\nentry's dot1agCfmVlanVid is associated. This value must not\nequal the value of dot1agCfmVlanVid.\n")
dot1agCfmVlanRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setDescription('The status of the row.\nThe writable columns in a row can not be changed if the row\nis active. All columns must have a valid value before a row\ncan be activated.\n')
dot1agCfmDefaultMdDefLevel = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 1), Dot1agCfmMDLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setReference('802.1ag clause 12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setDescription('A value indicating the MD Level at which MHFs are to be\ncreated, and Sender ID TLV transmission by those MHFs is to\nbe controlled, for each dot1agCfmDefaultMdEntry whose\ndot1agCfmDefaultMdLevel object contains the value -1.\nAfter this initialization, this object needs to be persistent\nupon reboot or restart of a device.\n')
dot1agCfmDefaultMdDefMhfCreation = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 2), Dot1agCfmMhfCreation().clone('defMHFnone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setReference('802.1ag clause 12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setDescription('A value indicating if the Management entity can create MHFs\n(MIP Half Function) for the VID, for each\ndot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdMhfCreation\nobject contains the value defMHFdefer. Since, in this\nvariable, there is no encompassing Maintenance Domain, the\nvalue defMHFdefer takes the meaning of defMHFnone.\nAfter this initialization, this object needs to be persistent\nupon reboot or restart of a device.\n')
dot1agCfmDefaultMdDefIdPermission = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 3), Dot1agCfmIdPermission().clone('sendIdNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setReference('802.1ag clause 12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\nincluded in the Sender ID TLV (21.5.3) transmitted by MHFs\ncreated by the Default Maintenance Domain, for each\ndot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdIdPermission\nobject contains the value sendIdDefer. Since, in this\nvariable, there is no encompassing Maintenance Domain, the\nvalue sendIdDefer takes the meaning of sendIdChassisManage.\nAfter this initialization, this object needs to be persistent\nupon reboot or restart of a device.\n')
dot1agCfmDefaultMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4), )
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setReference('802.1ag clause 12.14.3')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setDescription("The Default MD Level Managed Object controls MHF creation for\nVIDs that are not attached to a specific Maintenance\nAssociation Managed Object, and Sender ID TLV transmission by\nthose MHFs.\nFor each Bridge Port, and for each VLAN ID whose data can\npass through that Bridge Port, an entry in this table is\nused by the algorithm in subclause 22.2.3 only if there is no\nentry in the Maintenance Association table defining an MA\nfor the same VLAN ID and MD Level as this table's entry, and\non which MA an Up MEP is defined. If there exists such an\nMA, that MA's objects are used by the algorithm in\nsubclause 22.2.3 in place of this table entry's objects. The\nagent maintains the value of dot1agCfmDefaultMdStatus to\nindicate whether this entry is overridden by an MA.\nWhen first initialized, the agent creates this table\nautomatically with entries for all VLAN IDs,\nwith the default values specified for each object.\nAfter this initialization, the writable objects in this\ntable need to be persistent upon reboot or restart of a\ndevice.\n")
dot1agCfmDefaultMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdPrimaryVid"))
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setDescription('The Default MD Level table entry.')
dot1agCfmDefaultMdPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setDescription("The Primary VID of the VLAN to which this entry's objects\napply")
dot1agCfmDefaultMdStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setReference('802.1ag clause 12.14.3.1.3:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setDescription("State of this Default MD Level table entry. True if there is\nno entry in the Maintenance Association table defining an MA\nfor the same VLAN ID and MD Level as this table's entry, and\non which MA an Up MEP is defined, else false.\n")
dot1agCfmDefaultMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 3), Dot1agCfmMDLevelOrNone().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setReference('802.1ag clause 12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setDescription("A value indicating the MD Level at which MHFs are to be\ncreated, and Sender ID TLV transmission by those MHFs is to\nbe controlled, for the VLAN to which this entry's objects\napply. If this object has the value -1, the MD Level for MHF\ncreation for this VLAN is controlled by\ndot1agCfmDefaultMdDefLevel.\n")
dot1agCfmDefaultMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 4), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setReference('802.1ag clause 12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setDescription('A value indicating if the Management entity can create MHFs\n(MIP Half Function) for this VID at this MD Level. If this\nobject has the value defMHFdefer, MHF creation for this VLAN\nis controlled by dot1agCfmDefaultMdDefMhfCreation.\nThe value of this variable is meaningless if the values of\ndot1agCfmDefaultMdStatus is false.\n')
dot1agCfmDefaultMdIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 5), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setReference('802.1ag clause 12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\nincluded in the Sender ID TLV (21.5.3) transmitted by MHFs\ncreated by the Default Maintenance Domain. If this object\nhas the value sendIdDefer, Sender ID TLV transmission for\nthis VLAN is controlled by dot1agCfmDefaultMdDefIdPermission.\nThe value of this variable is meaningless if the values of\ndot1agCfmDefaultMdStatus is false.\n')
dot1agCfmConfigErrorListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1), )
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setReference('802.1ag clause 12.14.4')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setDescription('The CFM Configuration Error List table provides a list of\nInterfaces and VIDs that are incorrectly configured.\n')
dot1agCfmConfigErrorListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmConfigErrorListVid"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmConfigErrorListIfIndex"))
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setDescription('The Config Error List Table entry')
dot1agCfmConfigErrorListVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setReference('802.1ag Clause 12.14.4.1.2:a')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setDescription('The VLAN ID of the VLAN with interfaces in error.')
dot1agCfmConfigErrorListIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setReference('802.1ag clause 12.14.4.1.2:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setDescription('This object is the IfIndex of the interface.\nUpon a restart of the system, the system SHALL, if necessary,\nchange the value of this variable so that it indexes the\nentry in the interface table with the same value of ifAlias\nthat it indexed before the system restart. If no such\nentry exists, then the system SHALL delete any entries in\ndot1agCfmConfigErrorListTable indexed by that\nInterfaceIndex value.\n')
dot1agCfmConfigErrorListErrorType = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 3), Dot1agCfmConfigErrors()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setReference('802.1ag clause 12.14.4.1.3:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setDescription('A vector of Boolean error conditions from 22.2.4, any of\nwhich may be true:\n0) CFMleak;\n1) ConflictingVids;\n2) ExcessiveLevels;\n3) OverlappedLevels.\n')
dot1agCfmMdTableNextIndex = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 1), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setDescription('This object contains an unused value for dot1agCfmMdIndex in\nthe dot1agCfmMdTable, or a zero to indicate that none exist.\n')
dot1agCfmMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2), )
if mibBuilder.loadTexts: dot1agCfmMdTable.setReference('802.1ag clauses 3.22 and 18.1')
if mibBuilder.loadTexts: dot1agCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTable.setDescription('The Maintenance Domain table. Each row in the table\nrepresents a different Maintenance Domain.\nA Maintenance Domain is described in 802.1ag (3.22) as the\nnetwork or the part of the network for which faults in\nconnectivity are to be managed. The boundary of a Maintenance\nDomain is defined by a set of DSAPs, each of which can become\na point of connectivity to a service instance.\n')
dot1agCfmMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"))
if mibBuilder.loadTexts: dot1agCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost\nupon reboot. It is backed up by stable storage.\n')
dot1agCfmMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMdIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdIndex.setDescription('The index to the Maintenance Domain table.\ndot1agCfmMdTableNextIndex needs to be inspected to find an\navailable index for row-creation.\nReferential integrity is required i.e. the index needs to be\npersistent upon a reboot or restart of a device. The index\ncan never be reused for other Maintenance Domain. The index\nvalue should keep increasing up to the time that they wrap\naround. This is to facilitate access control based on OID.\n')
dot1agCfmMdFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 2), Dot1agCfmMaintDomainNameType().clone('charString')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFormat.setReference('802.1ag clause 21.6.5.1')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
dot1agCfmMdName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 3), Dot1agCfmMaintDomainName().clone('DEFAULT')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdName.setReference('802.1ag clauses 3.24, 12.14.5, and 21.6.5.3')
if mibBuilder.loadTexts: dot1agCfmMdName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdName.setDescription('The Maintenance Domain name. The type/format of this object\nis determined by the value of the dot1agCfmMdNameType object.\nEach Maintenance Domain has unique name amongst all those\nused or available to a service provider or operator. It\nfacilitates easy identification of administrative\nresponsibility for each Maintenance Domain.\nClause 3.24 defines a Maintenance Domain name as the\nidentifier, unique over the domain for which CFM is to\nprotect against accidental concatenation of Service\nInstances, of a particular Maintenance Domain.\n')
dot1agCfmMdMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 4), Dot1agCfmMDLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setReference('802.1ag clause 12.14.5.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setDescription('The Maintenance Domain Level.')
dot1agCfmMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 5), Dot1agCfmMhfCreation().clone('defMHFnone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setReference('802.1ag clause 12.14.5.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setDescription('Enumerated value indicating whether the management entity can\ncreate MHFs (MIP Half Function) for this Maintenance Domain.\n')
dot1agCfmMdMhfIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 6), Dot1agCfmIdPermission().clone('sendIdNone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setReference('802.1ag clause 12.14.5.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\nincluded in the Sender ID TLV (21.5.3) transmitted by MPs\nconfigured in this Maintenance Domain. Since, in this\nvariable, there is no encompassing Maintenance Domain, the\nvalue sendIdDefer takes the meaning of sendIdChassisManage.\n')
dot1agCfmMdMaTableNextIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 7), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdMaTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMaTableNextIndex.setDescription('Value to be used as the index of the MA table entries for\nthis Maintenance Domain when the management entity wants to\ncreate a new row in the MA table.\n')
dot1agCfmMdRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setDescription('The status of the row.\nThe writable columns in a row can not be changed if the row\nis active. All columns must have a valid value before a row\ncan be activated.\n')
dot1agCfmMaTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1), )
if mibBuilder.loadTexts: dot1agCfmMaTable.setReference('802.1ag clause 18.2')
if mibBuilder.loadTexts: dot1agCfmMaTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaTable.setDescription('The Maintenance Association table. Each row in the table\nrepresents an MA. An MA is a set of MEPs, each configured\nwith a single service instance.\nCreation of a Service Instance establishes a connectionless\nassociation among the selected DSAPs. Configuring a\nMaintenance association End Point (MEP) at each of the\nDSAPs creates a Maintenance Association (MA) to monitor\nthat connectionless connectivity. The MA is identified by a\nShort MA Name that is unique within the Maintenance Domain\nand chosen to facilitate easy identification of the Service\nInstance. Together, the Maintenance Domain Name and the\nShort MA Name form the Maintenance Association Identifier\n(MAID) that is carried in CFM Messages to identify\nincorrect connectivity among Service Instances. A small\ninteger, the Maintenance association End Point Identifier\n(MEPID), identifies each MEP among those configured on a\nsingle MA (802.1ag clauses 3.17 and 18.2).\nThis table uses two indices, first index is the index of the\nMaintenance Domain table.\nThe writable objects in this table need to be persistent\nupon reboot or restart of a device.\n')
dot1agCfmMaEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaEntry.setDescription('The MA table entry.')
dot1agCfmMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMaIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaIndex.setDescription('Index of the MA table dot1agCfmMdMaTableNextIndex needs to\nbe inspected to find an available index for row-creation.\n')
dot1agCfmMaPrimaryVlanId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 2), VlanIdOrNone()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaPrimaryVlanId.setReference('802.1ag clause 12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaPrimaryVlanId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaPrimaryVlanId.setDescription('The Primary VLAN ID with which the Maintenance Association is\nassociated, or 0 if the MA is not attached to any VID. If\nthe MA is associated with more than one VID, the\ndot1agCfmVlanTable lists them.\n')
dot1agCfmMaFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 3), Dot1agCfmMaintAssocNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaFormat.setReference('802.1ag clauses 21.6.5.4')
if mibBuilder.loadTexts: dot1agCfmMaFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaFormat.setDescription('The type (and thereby format) of the Maintenance Association\nName.\n')
dot1agCfmMaName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 4), Dot1agCfmMaintAssocName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaName.setReference('802.1ag clauses 21.6.5.6, and Table 21-20')
if mibBuilder.loadTexts: dot1agCfmMaName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaName.setDescription('The Short Maintenance Association name. The type/format of\nthis object is determined by the value of the\ndot1agCfmMaNameType object.\n')
dot1agCfmMaMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 5), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setReference('802.1ag clause 12.14.6.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setDescription('Indicates if the Management entity can create MHFs (MIP Half\nFunction) for this MA.\n')
dot1agCfmMaIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 6), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaIdPermission.setReference('802.1ag clause 12.14.6.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMaIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\nincluded in the Sender ID TLV (21.5.3) transmitted by MPs\nconfigured in this MA.\n')
dot1agCfmMaCcmInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 7), Dot1agCfmCcmInterval().clone('interval1s')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setReference('802.1ag clause 12.14.6.1.3:e')
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setDescription('Interval between CCM transmissions to be used by all MEPs\nin the MA.\n')
dot1agCfmMaNumberOfVids = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNumberOfVids.setReference('802.1ag clause 12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaNumberOfVids.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNumberOfVids.setDescription('The number of VIDs associated with the MA.\n')
dot1agCfmMaRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaRowStatus.setDescription('The status of the row.\nThe writable columns in a row can not be changed if the row\nis active. All columns must have a valid value before a row\ncan be activated.\n')
dot1agCfmMaMepListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3), )
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setReference('802.1ag clause 12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setDescription('List of MEPIDs (in any bridge) that belong to the same MA.\nClause 12.14.6.1.3 specifies that a list of MEPIDs in all\nbridges in that MA, but since SNMP SMI does not allow to\nstate in a MIB that an object in a table is an array, the\ninformation has to be stored in another table with two\nindices, being the first index, the index of the table that\ncontains the list or array.\n')
dot1agCfmMaMepListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaMepListIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setDescription('The known MEPS table entry.')
dot1agCfmMaMepListIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setReference('802.1ag clause 12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setDescription('MEPID')
dot1agCfmMaMepListRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setDescription('The status of the row. Read SNMPv2-TC (RFC1903) for an\nexplanation of the possible values this object can take.\n')
dot1agCfmMepTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1), )
if mibBuilder.loadTexts: dot1agCfmMepTable.setReference('802.1ag clauses 12.14.7 and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTable.setDescription("The Maintenance Association End Point (MEP) table.\nEach row in the table represents a different MEP. A MEP is\nan actively managed CFM entity, associated with a specific\nDSAP of a Service Instance, which can generate and receive\nCFM PDUs and track any responses. It is an end point of a\nsingle Maintenance Association, and is an endpoint of a\nseparate Maintenance Entity for each of the other MEPs in\nthe same Maintenance Association (802.1ag clause 3.18).\nThis table uses three indices. The first two indices are the\nindices of the Maintenance Domain and MA tables, the reason\nbeing that a MEP is always related to an MA and Maintenance\nDomain.\nThe Transmit Loopback table. Entries in this table are\ncreated/removed at the same time than entries in the MEP\ntable are created/removed.\nThe MEP table also stores all the managed objects for sending\nLBM and LTM.\n*LBM Managed objects\nLBM Managed objects in the MEP table\nenables the management entity to initiate\ntransmission of Loopback messages. It will signal the MEP\nthat it should transmit some number of Loopback messages\nand detect the detection (or lack thereof) of the\ncorresponding Loopback messages.\nSteps to use entries in this table:\n1) Wait for dot1agCfmMepTransmitLbmStatus value to be\n'ready'. To do this do this sequence:\na. an SNMP GET for both SnmpSetSerialNo and\ndot1agCfmMepTransmitLbmStatus objects (in same SNMP\nPDU).\nb. Check if value for dot1agCfmMepTransmitLbmStatus is\n'ready'\n- if not, wait x seconds, go to step a above.\n- if yes, save the value of SnmpSetSerialNo and go\nto step 2) below\n2) Change dot1agCfmMepTransmitLbmStatus value from 'ready' to\n'notReady' to ensure no other management entity will use\nthe service. In order to not disturb a possible other NMS\ndo this by sending an SNMP SET for both SnmpSetSerialNo\nand dot1agCfmMepTransmitLbmStatus objects (in same SNMP\nPDU, and make sure SNmpSetSerialNo is the first varBind).\nFor the SnmpSetSerialNo varBind, use the value that you\nobtained in step 1)a.. This ensures that two cooperating\nNMSes will not step on each others toes.\n3) Setup the different data to be sent (number of messages,\noptional TLVs,...).\n4) Record the current values of dot1agCfmMepLbrIn,\ndot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu.\n6) Change dot1agCfmMepTransmitLbmStatus value from 'notReady'\nto 'transmit' to initiate transmission of Loopback\nmessages.\n7) Check the value of dot1agCfmMepTransmitLbmResultOK to\nfind out if the operation was successfully initiated or\nnot.\n8) Monitor the value of dot1agCfmMepTransmitLbmMessages.\nWhen it reaches 0, the last LBM has been transmitted.\nWait an additional 5 seconds to ensure that all LBRs have\nbeen returned.\n9) Compare dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder,\nand dot1agCfmMepLbrBadMsdu to their old values from step\n4, above, to get the results of the test.\n10) Change the dot1agCfmMepTransmitLbmStatus value back to\n'ready' to allow other management entities to use the\ntable.\n*LTM Managed objects\nThe LTM Managed objects in the MEP table are used in a manner\nsimilar to that described for LBM transmission, above. Upon\nsuccessfully initiating the transmission, the variables\ndot1agCfmMepTransmitLtmSeqNumber and\ndot1agCfmMepTransmitLtmEgressIdentifier return the information\nrequired to recover the results of the LTM from the\ndot1agCfmLtrTable.\n")
dot1agCfmMepEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepEntry.setDescription('The MEP table entry')
dot1agCfmMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setReference('802.1ag clauses 3.19, 19.2 and 12.14.7')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setDescription('Integer that is unique among all the MEPs in the same MA.\nOther definition is: a small integer, unique over a given\nMaintenance Association, identifying a specific Maintenance\nassociation End Point (3.19).\nMEP Identifier is also known as the MEPID.\n')
dot1agCfmMepIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setReference('802.1ag clause 12.14.7.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setDescription('This object is the interface index of the interface either a\nbridge port, or an aggregated IEEE 802.1 link within a bridge\nport, to which the MEP is attached.\nUpon a restart of the system, the system SHALL, if necessary,\nchange the value of this variable so that it indexes the\nentry in the interface table with the same value of ifAlias\nthat it indexed before the system restart. If no such\nentry exists, then the system SHALL set this variable to 0.\n')
dot1agCfmMepDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 3), Dot1agCfmMpDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepDirection.setReference('802.1ag clauses 12.14.7.1.3:c and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setDescription('The direction in which the MEP faces on the Bridge port.')
dot1agCfmMepPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setReference('802.1ag clauses 12.14.7.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setDescription("An integer indicating the Primary VID of the MEP, always\none of the VIDs assigned to the MEP's MA. The value 0\nindicates that either the Primary VID is that of the\nMEP's MA, or that the MEP's MA is associated with no VID.")
dot1agCfmMepActive = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepActive.setReference('802.1ag clauses 12.14.7.1.3:e and 20.9.1')
if mibBuilder.loadTexts: dot1agCfmMepActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepActive.setDescription('Administrative state of the MEP\nA Boolean indicating the administrative state of the MEP.\nTrue indicates that the MEP is to function normally, and\nfalse that it is to cease functioning.')
dot1agCfmMepFngState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 6), Dot1agCfmFngState().clone('fngReset')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepFngState.setReference('802.1ag clauses 12.14.7.1.3:f and 20.35')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setDescription('Current state of the MEP Fault Notification Generator\nState Machine.\n')
dot1agCfmMepCciEnabled = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setReference('802.1ag clauses 12.14.7.1.3:g and 20.10.1')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setDescription('If set to true, the MEP will generate CCM messages.')
dot1agCfmMepCcmLtmPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setReference('802.1ag clause 12.14.7.1.3:h')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setDescription('The priority value for CCMs and LTMs transmitted by the MEP.\nDefault Value in the highest priority value allowed to pass\nthrough the bridge port for any of this MEPs VIDs.\nThe management entity can obtain the default value for this\nvariable from the priority regeneration table by extracting the\nhighest priority value in this table on this MEPs bridge port.\n(1 is lowest, then 2, then 0, then 3-7).\n')
dot1agCfmMepMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setReference('802.1ag clause 12.14.7.1.3:i and 19.4')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setDescription('MAC address of the MEP.')
dot1agCfmMepLowPrDef = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 10), Dot1agCfmLowestAlarmPri().clone('macRemErrXcon')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setReference('802.1ag clause 12.14.7.1.3:k and 20.9.5 and Table 20-1')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setDescription('An integer value specifying the lowest priority defect\nthat is allowed to generate fault alarm.\n')
dot1agCfmMepFngAlarmTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 11), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(250)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setReference('802.1ag clauses 12.14.7.1.3:l and 20.33.3')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setDescription('The time that defects must be present before a Fault Alarm is\nissued (fngAlarmTime. 20.33.3) (default 2.5s).\n')
dot1agCfmMepFngResetTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 12), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setReference('802.1ag clauses 12.14.7.1.3:m and 20.33.4')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setDescription('The time that defects must be absent before re-enabling a\nFault Alarm (fngResetTime, 20.33.4) (default 10s).\n')
dot1agCfmMepHighestPrDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 13), Dot1agCfmHighestDefectPri()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setReference('802.1ag clause 12.14.7.1.3:n 20.33.9 and Table 21-1')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setDescription('The highest priority defect that has been present since the\nMEPs Fault Notification Generator State Machine was last in\nthe FNG_RESET state.\n')
dot1agCfmMepDefects = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 14), Dot1agCfmMepDefects()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDefects.setReference('.1ag clauses 12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q,\n12.14.7.1.3:r, 12.14.7.1.3:s, 20.21.3, 20.23.3, 20.33.5,\n20.33.6, 20.33.7.')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setDescription('A vector of Boolean error conditions from Table 20-1, any of\nwhich may be true:\nDefRDICCM(0)\nDefMACstatus(1)\nDefRemoteCCM(2)\nDefErrorCCM(3)\nDefXconCCM(4)\n')
dot1agCfmMepErrorCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:t and 20.21.2')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setDescription('The last-received CCM that triggered an DefErrorCCM fault.')
dot1agCfmMepXconCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:u and 20.23.2')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setDescription('The last-received CCM that triggered a DefXconCCM fault.')
dot1agCfmMepCcmSequenceErrors = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setReference('802.1ag clauses 12.14.7.1.3:v and 20.16.12')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setDescription('The total number of out-of-sequence CCMs received from all\nremote MEPs.\n')
dot1agCfmMepCciSentCcms = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setReference('802.1ag clauses 12.14.7.1.3:w and 20.10.2')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setDescription('Total number of Continuity Check messages transmitted.')
dot1agCfmMepNextLbmTransId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setReference('802.1ag clauses 12.14.7.1.3:x and 20.28.2')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setDescription('Next sequence number/transaction identifier to be sent in a\nLoopback message. This sequence number can be zero because\nit wraps around.\n')
dot1agCfmMepLbrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setReference('802.1ag clause 12.14.7.1.3:y and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
dot1agCfmMepLbrInOutOfOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setReference('802.1ag clause 12.14.7.1.3:z and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies\nreceived.\n')
dot1agCfmMepLbrBadMsdu = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setReference('802.1ag clause 12.14.7.1.3:aa 20.2.3')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setDescription('(optional) The total number of LBRs received whose\nmac_service_data_unit did not match (except for the OpCode)\nthat of the corresponding LBM (20.2.3).\n')
dot1agCfmMepLtmNextSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setReference('802.1ag clause 12.14.7.1.3:ab and 20.36.1')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setDescription('Next transaction identifier/sequence number to be sent in a\nLinktrace message. This sequence number can be zero because\nit wraps around.\n')
dot1agCfmMepUnexpLtrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setReference('802.1ag clause 12.14.7.1.3:ac 20.39.1')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setDescription('The total number of unexpected LTRs received (20.39.1).\n')
dot1agCfmMepLbrOut = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setReference('802.1ag clause 12.14.7.1.3:ad and 20.26.2')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setDescription('Total number of Loopback Replies transmitted.')
dot1agCfmMepTransmitLbmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 26), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\nthat another LBM may be transmitted.\nReset to false by the MEP Loopback Initiator State Machine.')
dot1agCfmMepTransmitLbmDestMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 27), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\ndestination MAC address.\nThis address will be used if the value of the column\ndot1agCfmMepTransmitLbmDestIsMepId is 'false'.\n")
dot1agCfmMepTransmitLbmDestMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 28), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setDescription("The Maintenance association End Point Identifier of another\nMEP in the same Maintenance Association to which the LBM is\nto be sent.\nThis address will be used if the value of the column\ndot1agCfmMepTransmitLbmDestIsMepId is 'true'.\n")
dot1agCfmMepTransmitLbmDestIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 29), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\nLoopback transmission.\nFalse indicates that unicast destination MAC address of the\ntarget MEP is used for Loopback transmission.\n')
dot1agCfmMepTransmitLbmMessages = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setReference('802.1ag clause 12.14.7.3.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setDescription('The number of Loopback messages to be transmitted.')
dot1agCfmMepTransmitLbmDataTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1500))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setReference('802.1ag clause 12.14.7.3.2:d')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setDescription('An arbitrary amount of data to be included in the Data TLV,\nif the Data TLV is selected to be sent.\n')
dot1agCfmMepTransmitLbmVlanPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setDescription('Priority. 3 bit value to be used in the VLAN tag, if present\nin the transmitted frame.\nThe default value is CCM priority.\n')
dot1agCfmMepTransmitLbmVlanDropEnable = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 33), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit value to be used in the VLAN tag, if present\nin the transmitted frame.\nFor more information about VLAN Drop Enable, please check\nIEEE 802.1ad.\n')
dot1agCfmMepTransmitLbmResultOK = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 34), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setDescription('Indicates the result of the operation:\n- true The Loopback Message(s) will be\n(or has been) sent.\n- false The Loopback Message(s) will not\nbe sent.\n')
dot1agCfmMepTransmitLbmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setDescription('The Loopback Transaction Identifier\n(dot1agCfmMepNextLbmTransId) of the first LBM (to be) sent.\nThe value returned is undefined if\ndot1agCfmMepTransmitLbmResultOK is false.\n')
dot1agCfmMepTransmitLtmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 36), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\nthat another LTM may be transmitted.\nReset to false by the MEP Linktrace Initiator State Machine.')
dot1agCfmMepTransmitLtmFlags = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 37), Bits().clone(namedValues=NamedValues(("useFDBonly", 0))).clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setReference('802.1ag clause 12.14.7.4.2:b and 20.37.1')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setDescription('The flags field for LTMs transmitted by the MEP.')
dot1agCfmMepTransmitLtmTargetMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 38), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\ndestination MAC address.\nThis address will be used if the value of the column\ndot1agCfmMepTransmitLtmTargetIsMepId is 'false'.\n")
dot1agCfmMepTransmitLtmTargetMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 39), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setDescription("An indication of the Target MAC Address Field to be\ntransmitted:\nThe Maintenance association End Point Identifier of\nanother MEP in the same Maintenance Association\nThis address will be used if the value of the column\ndot1agCfmMepTransmitLtmTargetIsMepId is 'true'.\n")
dot1agCfmMepTransmitLtmTargetIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 40), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\nLinktrace transmission.\nFalse indicates that unicast destination MAC address of the\ntarget MEP is used for Loopback transmission.\n')
dot1agCfmMepTransmitLtmTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 41), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setReference('802.1ag clause 12.14.7.4.2:d and 21.8.4')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64.\nThe TTL field indicates the number of hops remaining to the\nLTM. Decremented by 1 by each Linktrace Responder that\nhandles the LTM. The value received in the LTM is returned\nin the LTR. If 0 on input, the LTM is not transmitted to the\nnext hop.\n')
dot1agCfmMepTransmitLtmResult = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 42), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setDescription('Indicates the result of the operation:\n- true The Linktrace Message will be (or has been) sent.\n- false The Linktrace Message will not be sent')
dot1agCfmMepTransmitLtmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 43), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setDescription('The LTM Transaction Identifier\n(dot1agCfmMepLtmNextSeqNumber) of the LTM sent.\nThe value returned is undefined if\ndot1agCfmMepTransmitLtmResult is false.\n')
dot1agCfmMepTransmitLtmEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setReference('802.1ag clause 12.14.7.4.3:b and 21.8.8')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setDescription('Identifies the MEP Linktrace Initiator that is originating,\nor the Linktrace Responder that is forwarding, this LTM.\nThe low-order six octets contain a 48-bit IEEE MAC address\nunique to the system in which the MEP Linktrace Initiator\nor Linktrace Responder resides. The high-order two octets\ncontain a value sufficient to uniquely identify the MEP\nLinktrace Initiator or Linktrace Responder within that system.\nFor most Bridges, the address of any MAC attached to the\nBridge will suffice for the low-order six octets, and 0 for\nthe high-order octets. In some situations, e.g. if multiple\nvirtual Bridges utilizing emulated LANs are implemented in a\nsingle physical system, the high-order two octets can be used\nto differentiate among the transmitting entities.\nThe value returned is undefined if\ndot1agCfmMepTransmitLtmResult is false.\n')
dot1agCfmMepRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 45), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setDescription('The status of the row.\nThe writable columns in a row can not be changed if the row\nis active. All columns must have a valid value before a row\ncan be activated.\n')
dot1agCfmLtrTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2), )
if mibBuilder.loadTexts: dot1agCfmLtrTable.setReference('802.1ag clause 12.14.7.5')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setDescription('This table extends the MEP table and contains a list of\nLinktrace replies received by a specific MEP in response to\na linktrace message.\nSNMP SMI does not allow to state in a MIB that an object in\na table is an array. The solution is to take the index (or\nindices) of the first table and add one or more indices.\n')
dot1agCfmLtrEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmLtrSeqNumber"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmLtrReceiveOrder"))
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setDescription('The Linktrace Reply table entry.')
dot1agCfmLtrSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setReference('802.1ag clause 12.14.7.5.2:b')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setDescription("Transaction identifier/Sequence number returned by a previous\ntransmit linktrace message command, indicating which LTM's\nresponse is going to be returned.\n")
dot1agCfmLtrReceiveOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setReference('802.1ag clause 12.14.7.5.2:c')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR\nTransaction Identifier field value. dot1agCfmLtrReceiveOrder\nare assigned sequentially from 1, in the order that the\nLinktrace Initiator received the LTRs.\n')
dot1agCfmLtrTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setReference('802.1ag clause 12.14.7.5 and 20.36.2.2')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setDescription('TTL field value for a returned LTR.')
dot1agCfmLtrForwarded = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setReference('802.1ag clauses 12.14.7.5.3:c and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setDescription("Indicates if a LTM was forwarded by the responding MP, as\nreturned in the 'FwdYes' flag of the flags field.\n")
dot1agCfmLtrTerminalMep = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setReference('802.1ag clauses 12.14.7.5.3:d and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setDescription('A boolean value stating whether the forwarded LTM reached a\nMEP enclosing its MA, as returned in the Terminal MEP flag of\nthe Flags field.\n')
dot1agCfmLtrLastEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:e and 20.36.2.3')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setDescription('An octet field holding the Last Egress Identifier returned\nin the LTR Egress Identifier TLV of the LTR.\nThe Last Egress Identifier identifies the MEP Linktrace\nInitiator that originated, or the Linktrace Responder that\nforwarded, the LTM to which this LTR is the response. This\nis the same value as the Egress Identifier TLV of that LTM.\n')
dot1agCfmLtrNextEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:f and 20.36.2.4')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setDescription('An octet field holding the Next Egress Identifier returned\nin the LTR Egress Identifier TLV of the LTR. The Next Egress\nIdentifier Identifies the Linktrace Responder that\ntransmitted this LTR, and can forward the LTM to the next\nhop. This is the same value as the Egress Identifier TLV of\nthe forwarded LTM, if any. If the FwdYes bit of the Flags\nfield is false, the contents of this field are undefined,\ni.e. any value can be transmitted, and the field is ignored\nby the receiver.\n')
dot1agCfmLtrRelay = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 8), Dot1agCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setReference('802.1ag clauses 12.14.7.5.3:g and 20.36.2.5')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setDescription('Value returned in the Relay Action field.')
dot1agCfmLtrChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 9), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID returned\nin the Sender ID TLV of the LTR, if any. This value is\nmeaningless if the dot1agCfmLtrChassisId has a length of 0.')
dot1agCfmLtrChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 10), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setReference('802.1ag clauses 12.14.7.5.3:i and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setDescription('The Chassis ID returned in the Sender ID TLV of the LTR, if\nany. The format of this object is determined by the\nvalue of the dot1agCfmLtrChassisIdSubtype object.\n')
dot1agCfmLtrManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 11), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.5, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setDescription("The TDomain that identifies the type and format of\nthe related dot1agCfmMepDbManAddress object, used to access\nthe SNMP agent of the system transmitting the LTR. Received\nin the LTR Sender ID TLV from that system.\nTypical values will be one of (not all inclusive) list:\nsnmpUDPDomain (from SNMPv2-TM, RFC3417)\nsnmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789)\nThe value 'zeroDotZero' (from RFC2578) indicates 'no LTR\nSender ID TLV received', in which case the related object\ndot1agCfmMepDbManAddress must have a zero-length OCTET STRING\nas a value.\n")
dot1agCfmLtrManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 12), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.7, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setDescription("The TAddress that can be used to access the SNMP\nagent of the system transmitting the CCM, received in the CCM\nSender ID TLV from that system.\nIf the related object dot1agCfmLtrManAddressDomain contains\nthe value 'zeroDotZero', this object dot1agCfmLtrManAddress\nmust have a zero-length OCTET STRING as a value.\n")
dot1agCfmLtrIngress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 13), Dot1agCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setReference('802.1ag clauses 12.14.7.5.3:k and 20.36.2.6')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM.')
dot1agCfmLtrIngressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setReference('802.1ag clauses 12.14.7.5.3:l and 20.36.2.7')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field.')
dot1agCfmLtrIngressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 15), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:m and 20.36.2.8')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID.')
dot1agCfmLtrIngressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 16), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setReference('802.1ag clauses 12.14.7.5.3:n and 20.36.2.9')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by\nthe value of the dot1agCfmLtrIngressPortIdSubtype object.\n')
dot1agCfmLtrEgress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 17), Dot1agCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setReference('802.1ag clauses 12.14.7.5.3:o and 20.36.2.10')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM.')
dot1agCfmLtrEgressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setReference('802.1ag clauses 12.14.7.5.3:p and 20.36.2.11')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setDescription('MAC address returned in the egress MAC address field.')
dot1agCfmLtrEgressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 19), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:q and 20.36.2.12')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID.')
dot1agCfmLtrEgressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 20), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setReference('802.1ag clauses 12.14.7.5.3:r and 20.36.2.13')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by\nthe value of the dot1agCfmLtrEgressPortIdSubtype object.\n')
dot1agCfmLtrOrganizationSpecificTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 21), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 1500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setReference('802.1ag clauses 12.14.7.5.3:s, 21.5.2')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setDescription('All Organization specific TLVs returned in the LTR, if\nany. Includes all octets including and following the TLV\nLength field of each TLV, concatenated together.')
dot1agCfmMepDbTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3), )
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setReference('802.1ag clause 19.2.15')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setDescription('The MEP Database. A database, maintained by every MEP, that\nmaintains received information about other MEPs in the\nMaintenance Domain.\nThe SMI does not allow to state in a MIB that an object in\na table is an array. The solution is to take the index (or\nindices) of the first table and add one or more indices.\n')
dot1agCfmMepDbEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1), ).setIndexNames((0, "IEEE8021-CFMD8-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFMD8-MIB", "dot1agCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setDescription('The MEP Database table entry.')
dot1agCfmMepDbRMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setReference('802.1ag clause 12.14.7.6.2:b')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setDescription('Maintenance association End Point Identifier of a remote MEP\nwhose information from the MEP Database is to be returned.\n')
dot1agCfmMepDbRMepState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 2), Dot1agCfmRemoteMepState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setReference('802.1ag clause 12.14.7.6.3:b and 20.22')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setDescription('The operational state of the remote MEP IFF State machines.')
dot1agCfmMepDbRMepFailedOkTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setReference('802.1ag clause 12.14.7.6.3:c')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setDescription('The time (SysUpTime) at which the IFF Remote MEP state machine\nlast entered either the RMEP_FAILED or RMEP_OK state.\n')
dot1agCfmMepDbMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setReference('802.1ag clause 12.14.7.6.3:d and 20.19.7')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setDescription('The MAC address of the remote MEP.')
dot1agCfmMepDbRdi = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setReference('802.1ag clauses 12.14.7.6.3:e and 20.19.2')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setDescription('State of the RDI bit in the last received CCM (true for\nRDI=1), or false if none has been received.\n')
dot1agCfmMepDbPortStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 6), Dot1agCfmPortStatus().clone('psNoPortStateTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setReference('802.1ag clause 12.14.7.6.3:f and 20.19.3')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setDescription('An enumerated value of the Port status TLV received in the\nlast CCM from the remote MEP or the default value\npsNoPortStateTLV indicating either no CCM has been received,\nor that nor port status TLV was received in the last CCM.\n')
dot1agCfmMepDbInterfaceStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 7), Dot1agCfmInterfaceStatus().clone('isNoInterfaceStatusTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setReference('802.1ag clause 12.14.7.6.3:g and 20.19.4')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setDescription('An enumerated value of the Interface status TLV received\nin the last CCM from the remote MEP or the default value\nisNoInterfaceStatus TLV indicating either no CCM has been\nreceived, or that no interface status TLV was received in\nthe last CCM.\n')
dot1agCfmMepDbChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 8), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID received\nin the last CCM.')
dot1agCfmMepDbChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 9), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setDescription('The Chassis ID. The format of this object is determined by the\nvalue of the dot1agCfmLtrChassisIdSubtype object.\n')
dot1agCfmMepDbManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 10), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.5, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setDescription("The TDomain that identifies the type and format of\nthe related dot1agCfmMepDbManAddress object, used to access\nthe SNMP agent of the system transmitting the CCM. Received\nin the CCM Sender ID TLV from that system.\nTypical values will be one of (not all inclusive) list:\nsnmpUDPDomain (from SNMPv2-TM, RFC3417)\nsnmpIeee802Domain (from SNMP-IEEE802-TM-MIB, RFC4789)\nThe value 'zeroDotZero' (from RFC2578) indicates 'no LTR\nSender ID TLV received', in which case the related object\ndot1agCfmMepDbManAddress must have a zero-length OCTET STRING\nas a value.\n")
dot1agCfmMepDbManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 11), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.7, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setDescription("The TAddress that can be used to access the SNMP\nagent of the system transmitting the CCM, received in the CCM\nSender ID TLV from that system.\nIf the related object dot1agCfmMepDbManAddressDomain contains\nthe value 'zeroDotZero', this object dot1agCfmMepDbManAddress\nmust have a zero-length OCTET STRING as a value.\n")
dot1agCfmFaultAlarm = NotificationType((1, 3, 111, 2, 802, 1, 1, 8, 0, 1)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmMepHighestPrDefect"))
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setDescription("A MEP has a persistent defect condition. A notification\n(fault alarm) is sent to the management entity with the OID\nof the MEP that has detected the fault.\nWhenever a MEP has a persistent defect,\nit may or may not generate a Fault Alarm to warn the system\nadministrator of the problem, as controlled by the MEP\nFault Notification Generator State Machine and associated\nManaged Objects. Only the highest-priority defect, as shown\nin Table 20-1, is reported in the Fault Alarm.\nIf a defect with a higher priority is raised after a Fault\nAlarm has been issued, another Fault Alarm is issued.\nThe management entity receiving the notification can identify\nthe system from the network source address of the\nnotification, and can identify the MEP reporting the defect\nby the indices in the OID of the dot1agCfmMepHighestPrDefect\nvariable in the notification:\ndot1agCfmMdIndex - Also the index of the MEP's\nMaintenance Domain table entry\n(dot1agCfmMdTable).\ndot1agCfmMaIndex - Also an index (with the MD table index)\nof the MEP's Maintenance Association\ntable entry (dot1agCfmMaTable).\ndot1agCfmMepIdentifier - MEP Identifier and final index\ninto the MEP table (dot1agCfmMepTable).\n")
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setReference('802.1ag clause 12.14.7.7')
dot1agCfmCompliances = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 1))
dot1agCfmGroups = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 2))
dot1agCfmStackGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 1)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmStackMdIndex"), ("IEEE8021-CFMD8-MIB", "dot1agCfmStackMaIndex"), ("IEEE8021-CFMD8-MIB", "dot1agCfmStackMepId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmStackMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmStackGroup = dot1agCfmStackGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackGroup.setDescription('Objects for the Stack group.')
dot1agCfmDefaultMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 2)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdDefLevel"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdDefMhfCreation"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdDefIdPermission"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdStatus"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdLevel"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdMhfCreation"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdIdPermission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmDefaultMdGroup = dot1agCfmDefaultMdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdGroup.setDescription('Objects for the Default MD Level group.')
dot1agCfmVlanIdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 3)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmVlanPrimaryVid"), ("IEEE8021-CFMD8-MIB", "dot1agCfmVlanRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmVlanIdGroup = dot1agCfmVlanIdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmVlanIdGroup.setDescription('Objects for the VLAN ID group.')
dot1agCfmConfigErrorListGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 4)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmConfigErrorListErrorType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmConfigErrorListGroup = dot1agCfmConfigErrorListGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListGroup.setDescription('Objects for the CFM Configuration Error List Group.')
dot1agCfmMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 5)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmMdTableNextIndex"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdName"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdFormat"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdMdLevel"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdMhfCreation"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdMhfIdPermission"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdMaTableNextIndex"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMdGroup = dot1agCfmMdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdGroup.setDescription('Objects for the Maintenance Domain Group.')
dot1agCfmMaGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 6)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmMaName"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaPrimaryVlanId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaFormat"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaMhfCreation"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaIdPermission"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaCcmInterval"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaRowStatus"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaNumberOfVids"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMaGroup = dot1agCfmMaGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaGroup.setDescription('Objects for the MA group.')
dot1agCfmMepGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 7)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmMepIfIndex"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDirection"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepPrimaryVid"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepActive"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepFngState"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepCciEnabled"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepCcmLtmPriority"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepMacAddress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLowPrDef"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepFngAlarmTime"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepFngResetTime"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepHighestPrDefect"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDefects"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepErrorCcmLastFailure"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepXconCcmLastFailure"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepCcmSequenceErrors"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepCciSentCcms"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepNextLbmTransId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLbrIn"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLbrInOutOfOrder"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLbrBadMsdu"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLtmNextSeqNumber"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepUnexpLtrIn"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepLbrOut"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmStatus"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmDestMacAddress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmDestMepId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmDestIsMepId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmMessages"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmDataTlv"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmVlanPriority"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmVlanDropEnable"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmResultOK"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLbmSeqNumber"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmStatus"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmFlags"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmTargetMacAddress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmTargetMepId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmTargetIsMepId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmTtl"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmResult"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmSeqNumber"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepTransmitLtmEgressIdentifier"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepRowStatus"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrForwarded"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrRelay"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrChassisIdSubtype"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrChassisId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrManAddress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrManAddressDomain"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrIngress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrIngressMac"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrIngressPortIdSubtype"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrIngressPortId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrEgress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrEgressMac"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrEgressPortIdSubtype"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrEgressPortId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrTerminalMep"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrLastEgressIdentifier"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrNextEgressIdentifier"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrTtl"), ("IEEE8021-CFMD8-MIB", "dot1agCfmLtrOrganizationSpecificTlv"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepGroup = dot1agCfmMepGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepGroup.setDescription('Objects for the MEP group.')
dot1agCfmMepDbGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 8)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbRMepState"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbRMepFailedOkTime"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbMacAddress"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbRdi"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbPortStatusTlv"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbInterfaceStatusTlv"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbChassisIdSubtype"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbChassisId"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbManAddressDomain"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbManAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepDbGroup = dot1agCfmMepDbGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbGroup.setDescription('Objects for the MEP group.')
dot1agCfmNotificationsGroup = NotificationGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 9)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmFaultAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmNotificationsGroup = dot1agCfmNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmNotificationsGroup.setDescription('Objects for the Notifications group.')
dot1agCfmCompliance = ModuleCompliance((1, 3, 111, 2, 802, 1, 1, 8, 2, 1, 1)).setObjects(("IEEE8021-CFMD8-MIB", "dot1agCfmStackGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmDefaultMdGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmConfigErrorListGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMdGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMaGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmMepDbGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmNotificationsGroup"), ("IEEE8021-CFMD8-MIB", "dot1agCfmVlanIdGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmCompliance = dot1agCfmCompliance.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmCompliance.setDescription('The compliance statement for support of the CFM MIB module.')
mibBuilder.exportSymbols("IEEE8021-CFMD8-MIB", dot1agCfmMepTransmitLbmDestMepId=dot1agCfmMepTransmitLbmDestMepId, dot1agCfmMepTable=dot1agCfmMepTable, dot1agCfmLtrEgressPortId=dot1agCfmLtrEgressPortId, dot1agCfmMepTransmitLtmTargetMacAddress=dot1agCfmMepTransmitLtmTargetMacAddress, dot1agCfmConfigErrorList=dot1agCfmConfigErrorList, dot1agCfmVlanTable=dot1agCfmVlanTable, dot1agCfmLtrNextEgressIdentifier=dot1agCfmLtrNextEgressIdentifier, dot1agCfmMepTransmitLbmMessages=dot1agCfmMepTransmitLbmMessages, dot1agCfmMaTable=dot1agCfmMaTable, dot1agCfmMaRowStatus=dot1agCfmMaRowStatus, dot1agCfmLtrSeqNumber=dot1agCfmLtrSeqNumber, Dot1agCfmCcmInterval=Dot1agCfmCcmInterval, dot1agCfmMepFngAlarmTime=dot1agCfmMepFngAlarmTime, dot1agCfmStackTable=dot1agCfmStackTable, dot1agCfmConformance=dot1agCfmConformance, dot1agCfmMepTransmitLtmFlags=dot1agCfmMepTransmitLtmFlags, dot1agCfmMaIndex=dot1agCfmMaIndex, Dot1agCfmRelayActionFieldValue=Dot1agCfmRelayActionFieldValue, dot1agCfmMepIdentifier=dot1agCfmMepIdentifier, dot1agCfmMepMacAddress=dot1agCfmMepMacAddress, dot1agCfmStackifIndex=dot1agCfmStackifIndex, dot1agCfmConfigErrorListErrorType=dot1agCfmConfigErrorListErrorType, dot1agCfmMdMdLevel=dot1agCfmMdMdLevel, Dot1agCfmInterfaceStatus=Dot1agCfmInterfaceStatus, dot1agCfmLtrTable=dot1agCfmLtrTable, dot1agCfmStackGroup=dot1agCfmStackGroup, dot1agCfmMepCcmSequenceErrors=dot1agCfmMepCcmSequenceErrors, dot1agCfmLtrChassisId=dot1agCfmLtrChassisId, dot1agCfmMepTransmitLbmDestIsMepId=dot1agCfmMepTransmitLbmDestIsMepId, dot1agCfmMepDbInterfaceStatusTlv=dot1agCfmMepDbInterfaceStatusTlv, Dot1agCfmMpDirection=Dot1agCfmMpDirection, dot1agCfmMaGroup=dot1agCfmMaGroup, dot1agCfmDefaultMdMhfCreation=dot1agCfmDefaultMdMhfCreation, dot1agCfmMdMhfCreation=dot1agCfmMdMhfCreation, dot1agCfmMdRowStatus=dot1agCfmMdRowStatus, dot1agCfmMepTransmitLtmTtl=dot1agCfmMepTransmitLtmTtl, dot1agCfmDefaultMd=dot1agCfmDefaultMd, dot1agCfmMaNumberOfVids=dot1agCfmMaNumberOfVids, dot1agCfmMepLbrBadMsdu=dot1agCfmMepLbrBadMsdu, dot1agCfmMepFngState=dot1agCfmMepFngState, dot1agCfmMepTransmitLbmVlanPriority=dot1agCfmMepTransmitLbmVlanPriority, dot1agCfmMepGroup=dot1agCfmMepGroup, dot1agCfmDefaultMdStatus=dot1agCfmDefaultMdStatus, Dot1agCfmMaintDomainName=Dot1agCfmMaintDomainName, Dot1agCfmMaintAssocNameType=Dot1agCfmMaintAssocNameType, Dot1agCfmMhfCreation=Dot1agCfmMhfCreation, Dot1agCfmMaintAssocName=Dot1agCfmMaintAssocName, Dot1agCfmFngState=Dot1agCfmFngState, Dot1agCfmRemoteMepState=Dot1agCfmRemoteMepState, dot1agCfmNotificationsGroup=dot1agCfmNotificationsGroup, dot1agCfmMep=dot1agCfmMep, dot1agCfmVlanVid=dot1agCfmVlanVid, dot1agCfmVlanEntry=dot1agCfmVlanEntry, dot1agCfmMepCcmLtmPriority=dot1agCfmMepCcmLtmPriority, dot1agCfmMepUnexpLtrIn=dot1agCfmMepUnexpLtrIn, dot1agCfmMdMhfIdPermission=dot1agCfmMdMhfIdPermission, dot1agCfmMepDbPortStatusTlv=dot1agCfmMepDbPortStatusTlv, dot1agCfmMepErrorCcmLastFailure=dot1agCfmMepErrorCcmLastFailure, dot1agCfmLtrIngressMac=dot1agCfmLtrIngressMac, dot1agCfmVlan=dot1agCfmVlan, dot1agCfmStack=dot1agCfmStack, dot1agCfmDefaultMdDefIdPermission=dot1agCfmDefaultMdDefIdPermission, dot1agCfmLtrForwarded=dot1agCfmLtrForwarded, dot1agCfmLtrEgressPortIdSubtype=dot1agCfmLtrEgressPortIdSubtype, dot1agNotifications=dot1agNotifications, dot1agCfmMepCciEnabled=dot1agCfmMepCciEnabled, dot1agCfmMepHighestPrDefect=dot1agCfmMepHighestPrDefect, dot1agCfmStackDirection=dot1agCfmStackDirection, dot1agCfmMepDbManAddress=dot1agCfmMepDbManAddress, ieee8021cfmMIB=ieee8021cfmMIB, dot1agCfmDefaultMdGroup=dot1agCfmDefaultMdGroup, dot1agCfmMepTransmitLtmResult=dot1agCfmMepTransmitLtmResult, dot1agCfmMepDbChassisIdSubtype=dot1agCfmMepDbChassisIdSubtype, dot1agCfmMepFngResetTime=dot1agCfmMepFngResetTime, Dot1agCfmMaintDomainNameType=Dot1agCfmMaintDomainNameType, dot1agCfmConfigErrorListGroup=dot1agCfmConfigErrorListGroup, dot1agCfmVlanRowStatus=dot1agCfmVlanRowStatus, dot1agCfmMepXconCcmLastFailure=dot1agCfmMepXconCcmLastFailure, dot1agCfmStackVlanIdOrNone=dot1agCfmStackVlanIdOrNone, dot1agCfmMaMepListRowStatus=dot1agCfmMaMepListRowStatus, dot1agCfmLtrReceiveOrder=dot1agCfmLtrReceiveOrder, dot1agCfmStackEntry=dot1agCfmStackEntry, dot1agCfmMepDbEntry=dot1agCfmMepDbEntry, dot1agCfmMepTransmitLbmDataTlv=dot1agCfmMepTransmitLbmDataTlv, dot1agCfmMdMaTableNextIndex=dot1agCfmMdMaTableNextIndex, dot1agCfmFaultAlarm=dot1agCfmFaultAlarm, dot1agCfmStackMepId=dot1agCfmStackMepId, Dot1agCfmEgressActionFieldValue=Dot1agCfmEgressActionFieldValue, dot1agCfmCompliances=dot1agCfmCompliances, dot1agCfmMepEntry=dot1agCfmMepEntry, dot1agCfmLtrEgress=dot1agCfmLtrEgress, dot1agCfmMepLbrOut=dot1agCfmMepLbrOut, dot1agCfmMaMhfCreation=dot1agCfmMaMhfCreation, dot1agCfmMdTableNextIndex=dot1agCfmMdTableNextIndex, dot1agCfmLtrLastEgressIdentifier=dot1agCfmLtrLastEgressIdentifier, dot1agMIBObjects=dot1agMIBObjects, Dot1agCfmMepId=Dot1agCfmMepId, Dot1agCfmMDLevel=Dot1agCfmMDLevel, dot1agCfmMepDirection=dot1agCfmMepDirection, dot1agCfmLtrManAddress=dot1agCfmLtrManAddress, Dot1agCfmConfigErrors=Dot1agCfmConfigErrors, Dot1agCfmPortStatus=Dot1agCfmPortStatus, dot1agCfmDefaultMdLevel=dot1agCfmDefaultMdLevel, dot1agCfmLtrTtl=dot1agCfmLtrTtl, dot1agCfmMepDbGroup=dot1agCfmMepDbGroup, dot1agCfmVlanIdGroup=dot1agCfmVlanIdGroup, Dot1agCfmMDLevelOrNone=Dot1agCfmMDLevelOrNone, dot1agCfmMaPrimaryVlanId=dot1agCfmMaPrimaryVlanId, dot1agCfmMepDbMacAddress=dot1agCfmMepDbMacAddress, dot1agCfmGroups=dot1agCfmGroups, dot1agCfmMepNextLbmTransId=dot1agCfmMepNextLbmTransId, dot1agCfmMepLbrIn=dot1agCfmMepLbrIn, dot1agCfmLtrEntry=dot1agCfmLtrEntry, dot1agCfmMepDefects=dot1agCfmMepDefects, Dot1afCfmIndexIntegerNextFree=Dot1afCfmIndexIntegerNextFree, dot1agCfmMepCciSentCcms=dot1agCfmMepCciSentCcms, dot1agCfmMepTransmitLbmVlanDropEnable=dot1agCfmMepTransmitLbmVlanDropEnable, dot1agCfmStackMaIndex=dot1agCfmStackMaIndex, dot1agCfmMepIfIndex=dot1agCfmMepIfIndex, dot1agCfmLtrTerminalMep=dot1agCfmLtrTerminalMep, dot1agCfmMepActive=dot1agCfmMepActive, dot1agCfmMepRowStatus=dot1agCfmMepRowStatus, dot1agCfmConfigErrorListEntry=dot1agCfmConfigErrorListEntry, Dot1agCfmIngressActionFieldValue=Dot1agCfmIngressActionFieldValue, dot1agCfmMepDbTable=dot1agCfmMepDbTable, dot1agCfmMepDbRMepState=dot1agCfmMepDbRMepState, dot1agCfmMdIndex=dot1agCfmMdIndex, dot1agCfmLtrManAddressDomain=dot1agCfmLtrManAddressDomain, Dot1agCfmMepIdOrZero=Dot1agCfmMepIdOrZero, dot1agCfmLtrIngressPortIdSubtype=dot1agCfmLtrIngressPortIdSubtype, Dot1agCfmHighestDefectPri=Dot1agCfmHighestDefectPri, dot1agCfmConfigErrorListIfIndex=dot1agCfmConfigErrorListIfIndex, dot1agCfmMepDbRMepFailedOkTime=dot1agCfmMepDbRMepFailedOkTime, dot1agCfmStackMdLevel=dot1agCfmStackMdLevel, dot1agCfmDefaultMdEntry=dot1agCfmDefaultMdEntry, dot1agCfmLtrChassisIdSubtype=dot1agCfmLtrChassisIdSubtype, dot1agCfmMaMepListTable=dot1agCfmMaMepListTable, dot1agCfmDefaultMdTable=dot1agCfmDefaultMdTable, dot1agCfmMaMepListIdentifier=dot1agCfmMaMepListIdentifier, dot1agCfmLtrIngressPortId=dot1agCfmLtrIngressPortId, dot1agCfmMepTransmitLbmDestMacAddress=dot1agCfmMepTransmitLbmDestMacAddress, Dot1agCfmIdPermission=Dot1agCfmIdPermission, dot1agCfmMepDbRdi=dot1agCfmMepDbRdi, dot1agCfmMepDbChassisId=dot1agCfmMepDbChassisId, Dot1agCfmLowestAlarmPri=Dot1agCfmLowestAlarmPri, Dot1agCfmMepDefects=Dot1agCfmMepDefects, dot1agCfmMepTransmitLbmResultOK=dot1agCfmMepTransmitLbmResultOK, dot1agCfmDefaultMdDefMhfCreation=dot1agCfmDefaultMdDefMhfCreation, dot1agCfmMepPrimaryVid=dot1agCfmMepPrimaryVid, PYSNMP_MODULE_ID=ieee8021cfmMIB, dot1agCfmMaName=dot1agCfmMaName, dot1agCfmMdGroup=dot1agCfmMdGroup, dot1agCfmMepTransmitLtmSeqNumber=dot1agCfmMepTransmitLtmSeqNumber, dot1agCfmMepDbRMepIdentifier=dot1agCfmMepDbRMepIdentifier, dot1agCfmMd=dot1agCfmMd, dot1agCfmVlanPrimaryVid=dot1agCfmVlanPrimaryVid, dot1agCfmMdName=dot1agCfmMdName, dot1agCfmCompliance=dot1agCfmCompliance, dot1agCfmMepTransmitLtmEgressIdentifier=dot1agCfmMepTransmitLtmEgressIdentifier, dot1agCfmMa=dot1agCfmMa, dot1agCfmDefaultMdPrimaryVid=dot1agCfmDefaultMdPrimaryVid, dot1agCfmMdTable=dot1agCfmMdTable, dot1agCfmMepTransmitLbmSeqNumber=dot1agCfmMepTransmitLbmSeqNumber, dot1agCfmDefaultMdDefLevel=dot1agCfmDefaultMdDefLevel, dot1agCfmMaIdPermission=dot1agCfmMaIdPermission, dot1agCfmLtrRelay=dot1agCfmLtrRelay, dot1agCfmLtrOrganizationSpecificTlv=dot1agCfmLtrOrganizationSpecificTlv, dot1agCfmDefaultMdIdPermission=dot1agCfmDefaultMdIdPermission, dot1agCfmConfigErrorListTable=dot1agCfmConfigErrorListTable, dot1agCfmStackMacAddress=dot1agCfmStackMacAddress, dot1agCfmMdFormat=dot1agCfmMdFormat, dot1agCfmMepTransmitLtmTargetIsMepId=dot1agCfmMepTransmitLtmTargetIsMepId, dot1agCfmLtrEgressMac=dot1agCfmLtrEgressMac, dot1agCfmMepDbManAddressDomain=dot1agCfmMepDbManAddressDomain, dot1agCfmStackMdIndex=dot1agCfmStackMdIndex, dot1agCfmMaEntry=dot1agCfmMaEntry, dot1agCfmMaMepListEntry=dot1agCfmMaMepListEntry, dot1agCfmMepTransmitLbmStatus=dot1agCfmMepTransmitLbmStatus, dot1agCfmMepLbrInOutOfOrder=dot1agCfmMepLbrInOutOfOrder, dot1agCfmLtrIngress=dot1agCfmLtrIngress, dot1agCfmMaFormat=dot1agCfmMaFormat, dot1agCfmConfigErrorListVid=dot1agCfmConfigErrorListVid, dot1agCfmMepTransmitLtmTargetMepId=dot1agCfmMepTransmitLtmTargetMepId, dot1agCfmMepTransmitLtmStatus=dot1agCfmMepTransmitLtmStatus, dot1agCfmMaCcmInterval=dot1agCfmMaCcmInterval, dot1agCfmMepLowPrDef=dot1agCfmMepLowPrDef, dot1agCfmMepLtmNextSeqNumber=dot1agCfmMepLtmNextSeqNumber, dot1agCfmMdEntry=dot1agCfmMdEntry)
