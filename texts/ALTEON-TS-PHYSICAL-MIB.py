#
# PySNMP MIB module ALTEON-TS-PHYSICAL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/alteonos/ALTEON-TS-PHYSICAL-MIB
# Produced by pysmi-1.1.12 at Mon Jul  1 09:16:19 2024
# On host fv-az735-465 platform Linux version 6.5.0-1022-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
switch, = mibBuilder.importSymbols("ALTEON-ROOT-MIB", "switch")
information, agent, operCmds, stats = mibBuilder.importSymbols("ALTEON-TIGON-SWITCH-MIB", "information", "agent", "operCmds", "stats")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Bits, TimeTicks, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, ModuleIdentity, Counter64, MibIdentifier, NotificationType, ObjectIdentity, Counter32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Bits", "TimeTicks", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "ModuleIdentity", "Counter64", "MibIdentifier", "NotificationType", "ObjectIdentity", "Counter32", "Integer32")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
vlans = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4))
portmirroring = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6))
trunkgroup = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7))
spannTreeGrpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19))
agPortConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3))
mirroring = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18))
mirrPortMirr = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1))
mirrVlanMirr = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2))
portCpuStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17))
port_stats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26)).setLabel("port-stats")
port_info = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1)).setLabel("port-info")
agPortTableMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortTableMaxEnt.setStatus('mandatory')
if mibBuilder.loadTexts: agPortTableMaxEnt.setDescription('The maximum number of rows in the port configuration host table.')
agPortCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2), )
if mibBuilder.loadTexts: agPortCurCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgTable.setDescription('The table of port configuration in the current_configuration block.')
agPortCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "agPortCurCfgIndx"))
if mibBuilder.loadTexts: agPortCurCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgTableEntry.setDescription('A row in the port table in the current_configuration block.')
agPortCurCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgIndx.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgIndx.setDescription('The index of the row in port configurations table.')
agPortCurCfgPrefLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("fast-ethernet", 2), ("gigabit-ethernet", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPrefLink.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgPrefLink.setDescription('This is the preferred link.')
agPortCurCfgBackLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("fast-ethernet", 2), ("gigabit-ethernet", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgBackLink.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgBackLink.setDescription('This is the backup link.')
agPortCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgState.setDescription('This is the state of the port.')
agPortCurCfgVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgVlanTag.setDescription('This is VLAN tag state of the port')
agPortCurCfgStp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgStp.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgStp.setDescription('This object is used to turn Spanning Tree on or off for the port.')
agPortCurCfgRmon = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgRmon.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgRmon.setDescription('This object is used to turn RMON on or off on the port.')
agPortCurCfgPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPVID.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgPVID.setDescription('The default VLAN ID for the port.')
agPortCurCfgFastEthAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgFastEthAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgFastEthAutoNeg.setDescription('This object is used to turn the autonegotiation on or off\n         for fast Ethernet connection.')
agPortCurCfgFastEthSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("mbs10", 2), ("mbs100", 3), ("mbs10or100", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgFastEthSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgFastEthSpeed.setDescription('Selects the port speed for fast Ethernet connection.')
agPortCurCfgFastEthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("full-duplex", 2), ("half-duplex", 3), ("full-or-half-duplex", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgFastEthMode.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgFastEthMode.setDescription('This object is used to select port mode for fast Ethernet connection.')
agPortCurCfgFastEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgFastEthFctl.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgFastEthFctl.setDescription('Selects the port flow control for fast Ethernet connection.')
agPortCurCfgGigEthAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgGigEthAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgGigEthAutoNeg.setDescription('This object is used to turn the autonegotiation on or off\n         for gigabit Ethernet connection.')
agPortCurCfgGigEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgGigEthFctl.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgGigEthFctl.setDescription('This object is used to select port flow control for\n         gigabit Ethernet connection.')
agPortCurCfgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgPortName.setDescription('The switch port name.')
agPortCurCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgBwmContract.setDescription('The switch port Bandwidth Management contract number.')
agPortCurCfgDiscardNonIPs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgDiscardNonIPs.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgDiscardNonIPs.setDescription('Enable or disable to discard all non-IP traffic on the switch port.')
agPortCurCfgLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortCurCfgLinkTrap.setStatus('mandatory')
if mibBuilder.loadTexts: agPortCurCfgLinkTrap.setDescription("Indicates whether linkUp/linkDown traps should be\n        generated for this interface.\n\n        By default, this object should have the value\n        enabled(1) for interfaces which do not operate on\n        'top' of any other interface (as defined in the\n        ifStackTable), and disabled(2) otherwise.")
agPortNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3), )
if mibBuilder.loadTexts: agPortNewCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgTable.setDescription('The table of port configuration in the new_configuration block.')
agPortNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "agPortNewCfgIndx"))
if mibBuilder.loadTexts: agPortNewCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgTableEntry.setDescription('A row in the port configuration table in the new_configuration block.')
agPortNewCfgIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agPortNewCfgIndx.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgIndx.setDescription('The index of the row in port configurations table.')
agPortNewCfgPrefLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("fast-ethernet", 2), ("gigabit-ethernet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgPrefLink.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgPrefLink.setDescription('This is the preferred link.')
agPortNewCfgBackLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("fast-ethernet", 2), ("gigabit-ethernet", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgBackLink.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgBackLink.setDescription('This is the backup link.')
agPortNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgState.setDescription('This is the state of the port.')
agPortNewCfgVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("tagged", 2), ("untagged", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgVlanTag.setDescription('This is VLAN tag state of the port')
agPortNewCfgStp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgStp.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgStp.setDescription('This object is used to turn Spanning Tree on or off for the port.')
agPortNewCfgRmon = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgRmon.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgRmon.setDescription('This object is used to turn RMON on or off on the port.')
agPortNewCfgPVID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgPVID.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgPVID.setDescription('The default VLAN ID for the port.')
agPortNewCfgFastEthAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgFastEthAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgFastEthAutoNeg.setDescription('This object is used to turn the autonegotiation on or off\n         for fast Ethernet connection.')
agPortNewCfgFastEthSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("mbs10", 2), ("mbs100", 3), ("mbs10or100", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgFastEthSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgFastEthSpeed.setDescription('Selects the port speed for fast Ethernet connection.')
agPortNewCfgFastEthMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("full-duplex", 2), ("half-duplex", 3), ("full-or-half-duplex", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgFastEthMode.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgFastEthMode.setDescription('This object is used to select port mode for fast Ethernet connection.')
agPortNewCfgFastEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgFastEthFctl.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgFastEthFctl.setDescription('Selects the port flow control for fast Ethernet connection.')
agPortNewCfgGigEthAutoNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgGigEthAutoNeg.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgGigEthAutoNeg.setDescription('This object is used to turn the autonegotiation on or off\n         for gigabit Ethernet connection.')
agPortNewCfgGigEthFctl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgGigEthFctl.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgGigEthFctl.setDescription('This object is used to select port flow control for\n         gigabit Ethernet connection.')
agPortNewCfgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgPortName.setDescription('The switch port name.')
agPortNewCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgBwmContract.setDescription('The switch port Bandwidth Management contract number.')
agPortNewCfgDiscardNonIPs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgDiscardNonIPs.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgDiscardNonIPs.setDescription('Enable or disable to discard all non-IP traffic on the switch port.')
agPortNewCfgLinkTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 2, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agPortNewCfgLinkTrap.setStatus('mandatory')
if mibBuilder.loadTexts: agPortNewCfgLinkTrap.setDescription("Indicates whether linkUp/linkDown traps should be\n        generated for this interface.\n\n        By default, this object should have the value\n        enabled(1) for interfaces which do not operate on\n        'top' of any other interface (as defined in the\n        ifStackTable), and disabled(2) otherwise.")
vlanMaxEnt = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanMaxEnt.setStatus('mandatory')
if mibBuilder.loadTexts: vlanMaxEnt.setDescription('The maximum number of rows in the VLAN configuration table.')
vlanCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2), )
if mibBuilder.loadTexts: vlanCurCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgTable.setDescription('The table of VLAN configuration.')
vlanCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "vlanCurCfgVlanId"))
if mibBuilder.loadTexts: vlanCurCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgTableEntry.setDescription('A row in the VLAN configuration table.')
vlanCurCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgVlanId.setDescription('The VLAN identifier.')
vlanCurCfgVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgVlanName.setDescription('The VLAN name.')
vlanCurCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgPorts.setDescription('The port list in the VLAN. The ports are presented in bitmap format.\n\t in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ port 8\n             ||    ||  \n             ||    ||___ port 7\n             ||    |____ port 6\n             ||      .    .   .\n             ||_________ port 1\n             |__________ reserved\n\n         where x : 1 - The represented port belongs to the VLAN\n\t\t   0 - The represented port does not belong to the VLAN')
vlanCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgState.setDescription('Enable or disable a VLAN')
vlanCurCfgJumbo = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgJumbo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgJumbo.setDescription('Enable or Disable the Jumbo frame support for the VLAN ')
vlanCurCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgBwmContract.setDescription('Default contract number the VLAN ')
vlanCurCfgStg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanCurCfgStg.setStatus('mandatory')
if mibBuilder.loadTexts: vlanCurCfgStg.setDescription('The Spanning Tree Group for the VLAN.')
vlanNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3), )
if mibBuilder.loadTexts: vlanNewCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgTable.setDescription('The table of VLAN configuration.')
vlanNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "vlanNewCfgVlanId"))
if mibBuilder.loadTexts: vlanNewCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgTableEntry.setDescription('A row in the VLAN configuration table.')
vlanNewCfgVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanNewCfgVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgVlanId.setDescription('The VLAN identifier.')
vlanNewCfgVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgVlanName.setDescription('The VLAN name.')
vlanNewCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanNewCfgPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgPorts.setDescription('The port list in the VLAN.  The ports are presented in bitmap format.\n         in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ port 8\n             ||    ||  \n             ||    ||___ port 7\n             ||    |____ port 6\n             ||      .    .   .\n             ||_________ port 1\n             |__________ reserved\n\n         where x : 1 - The represented port belongs to the VLAN\n\t           0 - The represented port does not belong to the VLAN')
vlanNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgState.setDescription('Enable or disable a VLAN')
vlanNewCfgJumbo = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgJumbo.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgJumbo.setDescription('Enable or Disable the Jumbo frame support for the VLAN ')
vlanNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgAddPort.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgAddPort.setDescription("The port to be added to the specified VLAN.  A '0' value is \n         returned when read.")
vlanNewCfgRemovePort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgRemovePort.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgRemovePort.setDescription("The port to be removed from the specified VLAN.  A '0'\n         value is returned when read.")
vlanNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgDelete.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgDelete.setDescription('This is an action object to create or delete a VLAN.\n         other(1) is returned always when read.\n         The following values are writable: delete(2)...to delete a VLAN')
vlanNewCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgBwmContract.setDescription('Default contract number for the VLAN.')
vlanNewCfgStg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 4, 3, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanNewCfgStg.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNewCfgStg.setDescription('The Spanning Tree Group for the VLAN.')
pmCurCfgMonitoringPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgMonitoringPort.setStatus('obsolete')
if mibBuilder.loadTexts: pmCurCfgMonitoringPort.setDescription('The port number of the monitoring port.')
pmNewCfgMonitoringPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgMonitoringPort.setStatus('obsolete')
if mibBuilder.loadTexts: pmNewCfgMonitoringPort.setDescription('The port number of the monitoring port.')
pmCurCfgMirroredPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgMirroredPort.setStatus('obsolete')
if mibBuilder.loadTexts: pmCurCfgMirroredPort.setDescription('The port number of the mirrored port.')
pmNewCfgMirroredPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgMirroredPort.setStatus('obsolete')
if mibBuilder.loadTexts: pmNewCfgMirroredPort.setDescription('The port number of the mirrored port.')
pmCurCfgMonitoredTraffic = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 2), ("received", 3), ("transmitted", 4), ("both", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgMonitoredTraffic.setStatus('obsolete')
if mibBuilder.loadTexts: pmCurCfgMonitoredTraffic.setDescription('The type of traffic to be monitored with respect to the mirrored \n         port.')
pmNewCfgMonitoredTraffic = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 2), ("received", 3), ("transmitted", 4), ("both", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgMonitoredTraffic.setStatus('obsolete')
if mibBuilder.loadTexts: pmNewCfgMonitoredTraffic.setDescription('The type of traffic to be monitored with respect to the\n         mirrored port.')
pmCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgState.setStatus('obsolete')
if mibBuilder.loadTexts: pmCurCfgState.setDescription('The state of Port mirroring.')
pmNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgState.setStatus('obsolete')
if mibBuilder.loadTexts: pmNewCfgState.setDescription('The state of Port mirroring.')
pmCurCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgTimeout.setStatus('obsolete')
if mibBuilder.loadTexts: pmCurCfgTimeout.setDescription('The mirroring timeout value in seconds.')
pmNewCfgTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 6, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgTimeout.setStatus('obsolete')
if mibBuilder.loadTexts: pmNewCfgTimeout.setDescription('The mirroring timeout value in seconds.')
trunkGroupTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupTableMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupTableMaxSize.setDescription('The maximum number of entries in trunk group table.')
trunkGroupCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2), )
if mibBuilder.loadTexts: trunkGroupCurCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgTable.setDescription('The table of trunk group configuration.')
trunkGroupCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "trunkGroupCurCfgIndex"))
if mibBuilder.loadTexts: trunkGroupCurCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgTableEntry.setDescription('A row in the trunk group configuration table.')
trunkGroupCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgIndex.setDescription('The identifier of the trunk group.')
trunkGroupCurCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgPorts.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgPorts.setDescription('The port list in the trunk group. The ports are presented in \n         bitmap format.\n \n         in receiving order:\n \n             OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ port 8\n             ||    ||  \n             ||    ||___ port 7\n             ||    |____ port 6\n             ||      .    .   .\n             ||_________ port 1\n             |__________ reserved\n\n         where x : 1 - The represented port belongs to the trunk group\n                   0 - The represented port does not belong to the trunk group')
trunkGroupCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgState.setDescription('Enable or disable a trunk group.')
trunkGroupCurCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupCurCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupCurCfgBwmContract.setDescription('Default BW contract of a trunk group.')
trunkGroupNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3), )
if mibBuilder.loadTexts: trunkGroupNewCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgTable.setDescription('The table of trunk group configuration.')
trunkGroupNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "trunkGroupNewCfgIndex"))
if mibBuilder.loadTexts: trunkGroupNewCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgTableEntry.setDescription('A row in the trunk group configuration table.')
trunkGroupNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupNewCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgIndex.setDescription('The identifier of the trunk group.')
trunkGroupNewCfgPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkGroupNewCfgPorts.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgPorts.setDescription('The port list in the trunk group.  The ports are presented\n         in bitmap format.\n\n         in receiving order:\n\n             OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ port 8\n             ||    ||  \n             ||    ||___ port 7\n             ||    |____ port 6\n             ||      .    .   .\n             ||_________ port 1\n             |__________ reserved\n \n         where x : 1 - The represented port belongs to the trunk group\n                   0 - The represented port does not belong to the trunk group')
trunkGroupNewCfgAddPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkGroupNewCfgAddPort.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgAddPort.setDescription('The port to be added in the trunk group. When read, 0 is returned.')
trunkGroupNewCfgRemovePort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkGroupNewCfgRemovePort.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgRemovePort.setDescription('The port to be deleted from the trunk group. when read, 0\n\t is returned.')
trunkGroupNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkGroupNewCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgState.setDescription('Enable or disable a trunk group.')
trunkGroupNewCfgDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkGroupNewCfgDelete.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgDelete.setDescription('Setting the value to delete(2) will delete the entire\n         row. When read, other(1) is returned.')
trunkGroupNewCfgBwmContract = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 7, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trunkGroupNewCfgBwmContract.setStatus('mandatory')
if mibBuilder.loadTexts: trunkGroupNewCfgBwmContract.setDescription('Default BW contract of a trunk group.')
stgCurCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1), )
if mibBuilder.loadTexts: stgCurCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgTable.setDescription('The table of Spanning Tree Groups configuration in the current_config.')
stgCurCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "stgCurCfgIndex"))
if mibBuilder.loadTexts: stgCurCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgTableEntry.setDescription('Information about a particular Spanning Tree Group configuration.')
stgCurCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgIndex.setDescription('The identifier of a particular Spanning Tree Group.  This is also\n         index to the entLogicalTable of Entity MIB.')
stgCurCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgState.setDescription('Turn on of off Spanning Tree operation of a particular Spanning\n         Tree Group.')
stgCurCfgVlanBmap1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgVlanBmap1.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgVlanBmap1.setDescription('The vlans applied to the spanning tree group.  The vlans are \n         presented in bitmap format. This string displays vlan number\n\t from 1 to 2048.\n\n\t in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ vlan 9\n             ||    ||  \n             ||    ||___ vlan 8\n             ||    |____ vlan 7\n             ||      .    .   .\n             ||_________ vlan 2\n             |__________ vlan 1 (as index to stgCurCfgTable)\n\n         where x : 1 - The represented vlan applied to the spanning tree. \n\t\t   0 - The represented vlan not applied to the spanning tree')
stgCurCfgVlanBmap2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgVlanBmap2.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgVlanBmap2.setDescription('The vlans applied to the spanning tree group.  The vlans are \n         presented in bitmap format. This string displays vlan number\n\t from 2049 to 4096.\n\n\t in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ vlan 2057 \n             ||    ||  \n             ||    ||___ vlan 2056 \n             ||    |____ vlan 2055 \n             ||      .    .   .\n             ||_________ vlan 2050 \n             |__________ vlan 2049 (as index to stgCurCfgTable)\n\n         where x : 1 - The represented vlan applied to the spanning tree. \n\t\t   0 - The represented vlan not applied to the spanning tree')
stgNewCfgTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2), )
if mibBuilder.loadTexts: stgNewCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgTable.setDescription('The table of Spanning Tree Groups configuration in the new_config.')
stgNewCfgTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "stgNewCfgIndex"))
if mibBuilder.loadTexts: stgNewCfgTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgTableEntry.setDescription('Information about a particular Spanning Tree Group configuration.')
stgNewCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgIndex.setDescription('The identifier of a particular Spanning Tree Group.  This is also\n         index to the entLogicalTable of Entity MIB.')
stgNewCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgState.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgState.setDescription('Turn on of off Spanning Tree operation of a particular Spanning\n         Tree Group.')
stgNewCfgDefaultCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default-config", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgDefaultCfg.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgDefaultCfg.setDescription('Setting the value to default-config(1) will set the default\n         configuration as recommended by IEEE 802.1D for a particular\n         Spanning Tree Group.  default-config (1) is always returned \n\t When read, but it does not mean anything.')
stgNewCfgAddVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgAddVlan.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgAddVlan.setDescription("The vlan to be added to the specified Spanning Tree Group.  A \n         '0' value is returned when read.")
stgNewCfgRemoveVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgRemoveVlan.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgRemoveVlan.setDescription("The vlan to be removed from the specified Spanning Tree Group.\n         A '0' value is returned when read.")
stgNewCfgVlanBmap1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgVlanBmap1.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgVlanBmap1.setDescription('The vlans applied to the spanning tree group.  The vlans are \n         presented in bitmap format. This string displays vlan number\n\t from 1 to 2048.\n\n\t in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ vlan 9\n             ||    ||  \n             ||    ||___ vlan 8\n             ||    |____ vlan 7\n             ||      .    .   .\n             ||_________ vlan 2\n             |__________ vlan 1 (as index to stgCurCfgTable)\n\n         where x : 1 - The represented vlan applied to the spanning tree. \n\t\t   0 - The represented vlan not applied to the spanning tree')
stgNewCfgVlanBmap2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgVlanBmap2.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgVlanBmap2.setDescription('The vlans applied to the spanning tree group.  The vlans are \n         presented in bitmap format. This string displays vlan number\n\t from 2049 to 4096.\n\n\t in receiving order:\n\n\t     OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx ..... \n             ||    || |_ vlan 2057 \n             ||    ||  \n             ||    ||___ vlan 2056 \n             ||    |____ vlan 2055 \n             ||      .    .   .\n             ||_________ vlan 2050 \n             |__________ vlan 2049 (as index to stgCurCfgTable)\n\n         where x : 1 - The represented vlan applied to the spanning tree. \n\t\t   0 - The represented vlan not applied to the spanning tree')
stgCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 3), )
if mibBuilder.loadTexts: stgCurCfgPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgPortTable.setDescription('The table of Spanning Tree Group port configuration in the\n         current_config.')
stgCurCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "stgCurCfgStgIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "stgCurCfgPortIndex"))
if mibBuilder.loadTexts: stgCurCfgPortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgPortTableEntry.setDescription('Information about port configuration of a particular Spanning Tree\n         Group.')
stgCurCfgStgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgStgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgStgIndex.setDescription('The identifier of a particular Spanning Tree Group.  This is also\n         index to the entLogicalTable of Entity MIB.')
stgCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stgCurCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgCurCfgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: stgCurCfgPortState.setDescription('Turn on of off Spanning Tree operation of a particular port of a\n         Spanning Tree Group.')
stgNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 4), )
if mibBuilder.loadTexts: stgNewCfgPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgPortTable.setDescription('The table of Spanning Tree Group port configuration in the\n         new_config.')
stgNewCfgPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 4, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "stgNewCfgStgIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "stgNewCfgPortIndex"))
if mibBuilder.loadTexts: stgNewCfgPortTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgPortTableEntry.setDescription('Information about port configuration of a particular Spanning Tree\n         Group.')
stgNewCfgStgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgStgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgStgIndex.setDescription('The identifier of a particular Spanning Tree Group.  This is also\n         index to the entLogicalTable of Entity MIB.')
stgNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stgNewCfgPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgPortIndex.setDescription('The port identifier of a particular Spanning Tree Group.')
stgNewCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 19, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stgNewCfgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: stgNewCfgPortState.setDescription('Turn on of off Spanning Tree operation of a particular port of a\n         Spanning Tree Group.')
pmCurCfgPortMirrState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPortMirrState.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPortMirrState.setDescription('The state of port-based port mirroring.')
pmNewCfgPortMirrState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgPortMirrState.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPortMirrState.setDescription('The state of port-based port mirroring.')
pmCurCfgPortMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 3), )
if mibBuilder.loadTexts: pmCurCfgPortMonitorTable.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPortMonitorTable.setDescription('The table of monitoring ports.')
pmCurCfgPortMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "pmCurCfgPmirrMoniPortIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "pmCurCfgPmirrMirrPortIndex"))
if mibBuilder.loadTexts: pmCurCfgPortMonitorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPortMonitorEntry.setDescription('A row in the monitoring port table.')
pmCurCfgPmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrMoniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPmirrMoniPortIndex.setDescription('The monitoring port number.')
pmCurCfgPmirrMirrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrMirrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPmirrMirrPortIndex.setDescription('The mirrored port number')
pmCurCfgPmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgPmirrDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgPmirrDirection.setDescription('The type of traffic to be monitored with respect to the\n         mirrored port.')
pmNewCfgPortMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4), )
if mibBuilder.loadTexts: pmNewCfgPortMonitorTable.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPortMonitorTable.setDescription('The table of monitoring ports.')
pmNewCfgPortMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "pmNewCfgPmirrMoniPortIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "pmNewCfgPmirrMirrPortIndex"))
if mibBuilder.loadTexts: pmNewCfgPortMonitorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPortMonitorEntry.setDescription('A row in the monitoring port table.')
pmNewCfgPmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgPmirrMoniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPmirrMoniPortIndex.setDescription('The monitoring port number.')
pmNewCfgPmirrMirrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgPmirrMirrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPmirrMirrPortIndex.setDescription('The mirrored port number')
pmNewCfgPmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgPmirrDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPmirrDirection.setDescription('The type of traffic to be monitored with respect to the\n         mirrored port.')
pmNewCfgPmirrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgPmirrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgPmirrDelete.setDescription('Setting the value to delete(2) will delete the entire\n         row. When read, other(1) is returned.')
pmCurCfgVlanMirrState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgVlanMirrState.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVlanMirrState.setDescription('The state of vlan-based port mirroring.')
pmNewCfgVlanMirrState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgVlanMirrState.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVlanMirrState.setDescription('The state of vlan-based port mirroring.')
pmCurCfgVlanMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 3), )
if mibBuilder.loadTexts: pmCurCfgVlanMonitorTable.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVlanMonitorTable.setDescription('The table of vlan based port mirroring.')
pmCurCfgVlanMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 3, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "pmCurCfgVmirrMoniPortIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "pmCurCfgVmirrMirrVlanIndex"))
if mibBuilder.loadTexts: pmCurCfgVlanMonitorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVlanMonitorEntry.setDescription('A row in the monitoring vlan table.')
pmCurCfgVmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgVmirrMoniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVmirrMoniPortIndex.setDescription('The monitoring port number.')
pmCurCfgVmirrMirrVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgVmirrMirrVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVmirrMirrVlanIndex.setDescription('The mirrored vlan number')
pmCurCfgVmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmCurCfgVmirrDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pmCurCfgVmirrDirection.setDescription('The type of traffic to be monitored with respect to the\n         mirrored vlan.')
pmNewCfgVlanMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4), )
if mibBuilder.loadTexts: pmNewCfgVlanMonitorTable.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVlanMonitorTable.setDescription('The table of vlan-based port mirroring.')
pmNewCfgVlanMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "pmNewCfgVmirrMoniPortIndex"), (0, "ALTEON-TS-PHYSICAL-MIB", "pmNewCfgVmirrMirrVlanIndex"))
if mibBuilder.loadTexts: pmNewCfgVlanMonitorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVlanMonitorEntry.setDescription('A row in the monitoring vlan table.')
pmNewCfgVmirrMoniPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgVmirrMoniPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVmirrMoniPortIndex.setDescription('The monitoring port number.')
pmNewCfgVmirrMirrVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmNewCfgVmirrMirrVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVmirrMirrVlanIndex.setDescription('The mirrored vlan number')
pmNewCfgVmirrDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgVmirrDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVmirrDirection.setDescription('The type of traffic to be monitored with respect to the\n         mirrored vlan.')
pmNewCfgVmirrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 18, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmNewCfgVmirrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: pmNewCfgVmirrDelete.setDescription('Setting the value to delete(2) will delete the entire\n         row. When read, other(1) is returned.')
portCpuStatsUtilTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1), )
if mibBuilder.loadTexts: portCpuStatsUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuStatsUtilTable.setDescription('The table of port CPU utilization.')
portCpuStatsUtilTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "portCpuStatsUtilIndx"))
if mibBuilder.loadTexts: portCpuStatsUtilTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuStatsUtilTableEntry.setDescription('A row in the port CPU utilization table.')
portCpuStatsUtilIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuStatsUtilIndx.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuStatsUtilIndx.setDescription('The port index.')
portCpuAStatsUtil1Second = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuAStatsUtil1Second.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuAStatsUtil1Second.setDescription('The utilization of port CPU A over 1 second. It shows the percentage.')
portCpuBStatsUtil1Second = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuBStatsUtil1Second.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuBStatsUtil1Second.setDescription('The utilization of port CPU B over 1 second. It shows the percentage.')
portCpuAStatsUtil4Seconds = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuAStatsUtil4Seconds.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuAStatsUtil4Seconds.setDescription('The utilization of port CPU A over 4 seconds.\n         It shows the percentage.')
portCpuBStatsUtil4Seconds = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuBStatsUtil4Seconds.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuBStatsUtil4Seconds.setDescription('The utilization of port CPU B over 4 seconds.\n         It shows the percentage.')
portCpuAStatsUtil64Seconds = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuAStatsUtil64Seconds.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuAStatsUtil64Seconds.setDescription('The utilization of port CPU A over 64 seconds.\n\t It shows the percentage.')
portCpuBStatsUtil64Seconds = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 17, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCpuBStatsUtil64Seconds.setStatus('mandatory')
if mibBuilder.loadTexts: portCpuBStatsUtil64Seconds.setDescription('The utilization of port CPU B over 64 seconds.\n\t It shows the percentage.')
portInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1), )
if mibBuilder.loadTexts: portInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoTable.setDescription('The table of port information.')
portInfoTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "portInfoIndx"))
if mibBuilder.loadTexts: portInfoTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoTableEntry.setDescription('A row in the port information table.')
portInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoIndx.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoIndx.setDescription('The port index.')
portInfoSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("mbs10", 2), ("mbs100", 3), ("mbs1000", 4), ("any", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoSpeed.setDescription('The current operational speed of the port.')
portInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("full-duplex", 2), ("half-duplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoMode.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoMode.setDescription('The current operational mode of the port.')
portInfoFlowCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("transmit", 2), ("receive", 3), ("both", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoFlowCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoFlowCtrl.setDescription('The current operational flow control of the port.')
portInfoLink = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3), ("inoperative", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoLink.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoLink.setDescription('The current operational link status of the port.')
portInfoPhyIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfDescr.setDescription('A textual string containing information about the\n\t    interface.  This string should include the name of\n\t    the manufacturer, the product name and the version\n\t    of the hardware interface.')
portInfoPhyIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet-csmacd", 6), ("iso88023-csmacd", 7), ("iso88024-tokenBus", 8), ("iso88025-tokenRing", 9), ("iso88026-man", 10), ("starLan", 11), ("proteon-10Mbit", 12), ("proteon-80Mbit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("ds1", 18), ("e1", 19), ("basicISDN", 20), ("primaryISDN", 21), ("propPointToPointSerial", 22), ("ppp", 23), ("softwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfType.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfType.setDescription("The type of interface, distinguished according to\n\t    the physical/link protocol(s) immediately `below'\n\t    the network layer in the protocol stack.")
portInfoPhyIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfMtu.setDescription('The size of the largest datagram which can be\n\t    sent/received on the interface, specified in\n\t    octets.  For interfaces that are used for\n\t    transmitting network datagrams, this is the size\n\t    of the largest network datagram that can be sent\n\t    on the interface.')
portInfoPhyIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 9), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfPhysAddress.setDescription("The interface's address at the protocol layer\n\t    immediately `below' the network layer in the\n\t    protocol stack.  For interfaces which do not have\n\t    such an address (e.g., a serial line), this object\n\t    should contain an octet string of zero length.")
portInfoPhyIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfOperStatus.setDescription('The current operational state of the interface.\n\t    The testing(3) state indicates that no operational\n\t    packets can be passed.')
portInfoPhyIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 9, 1, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portInfoPhyIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: portInfoPhyIfLastChange.setDescription('The value of sysUpTime at the time the interface\n\t    entered its current operational state.  If the\n\t    current state was entered prior to the last re-\n\t    initialization of the local network management\n\t    subsystem, then this object contains a zero\n\t    value.')
portStatsTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1), )
if mibBuilder.loadTexts: portStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsTable.setDescription('The table of port statistics.')
portStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1), ).setIndexNames((0, "ALTEON-TS-PHYSICAL-MIB", "portStatsIndx"))
if mibBuilder.loadTexts: portStatsTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsTableEntry.setDescription('A row in the port stats table.')
portStatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsIndx.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsIndx.setDescription('The port index.')
portStatsPhyIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInOctets.setDescription('The total number of octets received on the\n\t    interface, including framing characters.')
portStatsPhyIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInUcastPkts.setDescription('The number of subnetwork-unicast packets\n\t    delivered to a higher-layer protocol.')
portStatsPhyIfInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInNUcastPkts.setDescription('The number of non-unicast (i.e., subnetwork-\n\t    broadcast or subnetwork-multicast) packets\n\t    delivered to a higher-layer protocol.')
portStatsPhyIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInDiscards.setDescription('The number of inbound packets which were chosen\n\t    to be discarded even though no errors had been\n\t    detected to prevent their being deliverable to a\n\t    higher-layer protocol.  One possible reason for\n\t    discarding such a packet could be to free up\n\t    buffer space.')
portStatsPhyIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInErrors.setDescription('The number of inbound packets that contained\n\t    errors preventing them from being deliverable to a\n\t    higher-layer protocol.')
portStatsPhyIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInUnknownProtos.setDescription('The number of packets received via the interface\n\t    which were discarded because of an unknown or\n\t    unsupported protocol.')
portStatsPhyIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutOctets.setDescription('The total number of octets transmitted out of the\n\t    interface, including framing characters.')
portStatsPhyIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutUcastPkts.setDescription('The total number of packets that higher-level\n\t    protocols requested be transmitted to a\n\t    subnetwork-unicast address, including those that\n\t    were discarded or not sent.')
portStatsPhyIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutNUcastPkts.setDescription('The total number of packets that higher-level\n\t    protocols requested be transmitted to a non-\n\t    unicast (i.e., a subnetwork-broadcast or\n\t    subnetwork-multicast) address, including those\n\t    that were discarded or not sent.')
portStatsPhyIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutDiscards.setDescription('The number of outbound packets which were chosen\n\t    to be discarded even though no errors had been\n\t    detected to prevent their being transmitted.  One\n\t    possible reason for discarding such a packet could\n\t    be to free up buffer space.')
portStatsPhyIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutErrors.setDescription('The number of outbound packets that could not be\n\t    transmitted because of errors.')
portStatsPhyIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutQLen.setDescription('The length of the output packet queue (in\n\t    packets).')
portStatsPhyIfInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfInBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfInBroadcastPkts.setDescription('The number of packets, delivered by this sub-layer to\n            a higher (sub-)layer, which were addressed to a\n            broadcast address at this sub-layer.')
portStatsPhyIfOutBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 1, 8, 26, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatsPhyIfOutBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portStatsPhyIfOutBroadcastPkts.setDescription('The total number of packets that higher-level\n            protocols requested be transmitted, and which were\n            addressed to a broadcast address at this sub-layer,\n            including those that were discarded or not sent.')
mirrOper = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3))
mirrOperMonitoringPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrOperMonitoringPort.setStatus('mandatory')
if mibBuilder.loadTexts: mirrOperMonitoringPort.setDescription('The switch port where the mirrored traffic are sent to.  A zero\n         value indicates this field has not been configured.')
mirrOperMirroredPort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrOperMirroredPort.setStatus('mandatory')
if mibBuilder.loadTexts: mirrOperMirroredPort.setDescription('The switch port where the egress traffic to be mirrored.  A zero\n         value indicates this field has not been configured.')
mirrOperType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("in", 2), ("out", 3), ("both", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrOperType.setStatus('mandatory')
if mibBuilder.loadTexts: mirrOperType.setDescription('Type of packets to be sent to the monitor port.\n         in = packets received at the mirrored port\n         out = packets sent from the mirrored port\n         both = packets sent and received by the mirrored port\n        ')
mirrOperTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrOperTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mirrOperTimeout.setDescription('The duration in seconds for activating the mirroring rule.  Zero\n         means forever.')
mirrOperState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 1, 14, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrOperState.setStatus('mandatory')
if mibBuilder.loadTexts: mirrOperState.setDescription('Enable or disable port mirroring.')
mibBuilder.exportSymbols("ALTEON-TS-PHYSICAL-MIB", agPortNewCfgGigEthAutoNeg=agPortNewCfgGigEthAutoNeg, vlans=vlans, trunkGroupNewCfgTableEntry=trunkGroupNewCfgTableEntry, stgNewCfgTableEntry=stgNewCfgTableEntry, portCpuStatsUtilTable=portCpuStatsUtilTable, agPortCurCfgGigEthFctl=agPortCurCfgGigEthFctl, port_info=port_info, agPortCurCfgPortName=agPortCurCfgPortName, agPortNewCfgBackLink=agPortNewCfgBackLink, agPortNewCfgIndx=agPortNewCfgIndx, trunkGroupCurCfgBwmContract=trunkGroupCurCfgBwmContract, pmNewCfgPortMirrState=pmNewCfgPortMirrState, stgNewCfgPortTable=stgNewCfgPortTable, portStatsTableEntry=portStatsTableEntry, portStatsIndx=portStatsIndx, portStatsPhyIfInNUcastPkts=portStatsPhyIfInNUcastPkts, pmCurCfgVmirrDirection=pmCurCfgVmirrDirection, portStatsPhyIfInBroadcastPkts=portStatsPhyIfInBroadcastPkts, pmNewCfgVmirrDelete=pmNewCfgVmirrDelete, agPortCurCfgPrefLink=agPortCurCfgPrefLink, portStatsPhyIfOutBroadcastPkts=portStatsPhyIfOutBroadcastPkts, agPortCurCfgStp=agPortCurCfgStp, agPortCurCfgRmon=agPortCurCfgRmon, agPortCurCfgFastEthSpeed=agPortCurCfgFastEthSpeed, stgNewCfgState=stgNewCfgState, stgCurCfgTable=stgCurCfgTable, vlanNewCfgBwmContract=vlanNewCfgBwmContract, agPortNewCfgVlanTag=agPortNewCfgVlanTag, pmNewCfgVmirrDirection=pmNewCfgVmirrDirection, stgNewCfgTable=stgNewCfgTable, vlanNewCfgRemovePort=vlanNewCfgRemovePort, pmNewCfgPmirrMirrPortIndex=pmNewCfgPmirrMirrPortIndex, port_stats=port_stats, vlanMaxEnt=vlanMaxEnt, trunkGroupNewCfgTable=trunkGroupNewCfgTable, agPortNewCfgFastEthSpeed=agPortNewCfgFastEthSpeed, mirroring=mirroring, portInfoTableEntry=portInfoTableEntry, mirrOperType=mirrOperType, stgNewCfgAddVlan=stgNewCfgAddVlan, portCpuBStatsUtil64Seconds=portCpuBStatsUtil64Seconds, portStatsPhyIfInUnknownProtos=portStatsPhyIfInUnknownProtos, agPortCurCfgTableEntry=agPortCurCfgTableEntry, pmNewCfgMirroredPort=pmNewCfgMirroredPort, pmCurCfgVmirrMirrVlanIndex=pmCurCfgVmirrMirrVlanIndex, agPortCurCfgLinkTrap=agPortCurCfgLinkTrap, stgCurCfgVlanBmap1=stgCurCfgVlanBmap1, stgNewCfgPortIndex=stgNewCfgPortIndex, vlanCurCfgTable=vlanCurCfgTable, pmCurCfgVlanMonitorTable=pmCurCfgVlanMonitorTable, portInfoPhyIfPhysAddress=portInfoPhyIfPhysAddress, agPortNewCfgPVID=agPortNewCfgPVID, mirrOperMonitoringPort=mirrOperMonitoringPort, portInfoIndx=portInfoIndx, trunkGroupNewCfgRemovePort=trunkGroupNewCfgRemovePort, pmNewCfgVlanMonitorEntry=pmNewCfgVlanMonitorEntry, agPortCurCfgVlanTag=agPortCurCfgVlanTag, agPortNewCfgPortName=agPortNewCfgPortName, stgNewCfgPortState=stgNewCfgPortState, portCpuAStatsUtil64Seconds=portCpuAStatsUtil64Seconds, spannTreeGrpCfg=spannTreeGrpCfg, stgCurCfgStgIndex=stgCurCfgStgIndex, agPortNewCfgRmon=agPortNewCfgRmon, pmNewCfgPortMonitorEntry=pmNewCfgPortMonitorEntry, stgNewCfgPortTableEntry=stgNewCfgPortTableEntry, stgCurCfgPortTable=stgCurCfgPortTable, stgNewCfgRemoveVlan=stgNewCfgRemoveVlan, portCpuBStatsUtil4Seconds=portCpuBStatsUtil4Seconds, mirrVlanMirr=mirrVlanMirr, vlanNewCfgDelete=vlanNewCfgDelete, pmNewCfgVlanMirrState=pmNewCfgVlanMirrState, portStatsPhyIfInErrors=portStatsPhyIfInErrors, vlanCurCfgJumbo=vlanCurCfgJumbo, portCpuBStatsUtil1Second=portCpuBStatsUtil1Second, agPortCurCfgIndx=agPortCurCfgIndx, portStatsPhyIfInUcastPkts=portStatsPhyIfInUcastPkts, vlanNewCfgAddPort=vlanNewCfgAddPort, vlanNewCfgPorts=vlanNewCfgPorts, trunkGroupNewCfgPorts=trunkGroupNewCfgPorts, pmNewCfgState=pmNewCfgState, agPortCurCfgState=agPortCurCfgState, portStatsPhyIfOutOctets=portStatsPhyIfOutOctets, stgCurCfgState=stgCurCfgState, portStatsPhyIfInDiscards=portStatsPhyIfInDiscards, agPortCurCfgFastEthMode=agPortCurCfgFastEthMode, vlanNewCfgTable=vlanNewCfgTable, stgCurCfgTableEntry=stgCurCfgTableEntry, pmCurCfgPortMonitorTable=pmCurCfgPortMonitorTable, pmCurCfgMonitoringPort=pmCurCfgMonitoringPort, vlanCurCfgStg=vlanCurCfgStg, portCpuAStatsUtil1Second=portCpuAStatsUtil1Second, vlanCurCfgState=vlanCurCfgState, trunkGroupCurCfgTable=trunkGroupCurCfgTable, pmCurCfgPmirrDirection=pmCurCfgPmirrDirection, vlanNewCfgStg=vlanNewCfgStg, vlanNewCfgState=vlanNewCfgState, portStatsPhyIfOutUcastPkts=portStatsPhyIfOutUcastPkts, trunkGroupTableMaxSize=trunkGroupTableMaxSize, pmCurCfgVlanMirrState=pmCurCfgVlanMirrState, pmCurCfgMirroredPort=pmCurCfgMirroredPort, trunkGroupNewCfgBwmContract=trunkGroupNewCfgBwmContract, portInfoPhyIfOperStatus=portInfoPhyIfOperStatus, agPortNewCfgPrefLink=agPortNewCfgPrefLink, trunkGroupCurCfgPorts=trunkGroupCurCfgPorts, trunkGroupNewCfgIndex=trunkGroupNewCfgIndex, vlanNewCfgVlanId=vlanNewCfgVlanId, trunkGroupCurCfgState=trunkGroupCurCfgState, mirrOper=mirrOper, pmCurCfgPmirrMoniPortIndex=pmCurCfgPmirrMoniPortIndex, stgCurCfgPortState=stgCurCfgPortState, portInfoFlowCtrl=portInfoFlowCtrl, stgNewCfgVlanBmap1=stgNewCfgVlanBmap1, vlanCurCfgTableEntry=vlanCurCfgTableEntry, agPortNewCfgBwmContract=agPortNewCfgBwmContract, portCpuStatsUtilIndx=portCpuStatsUtilIndx, portInfoLink=portInfoLink, pmCurCfgVmirrMoniPortIndex=pmCurCfgVmirrMoniPortIndex, trunkGroupNewCfgState=trunkGroupNewCfgState, vlanNewCfgTableEntry=vlanNewCfgTableEntry, agPortNewCfgLinkTrap=agPortNewCfgLinkTrap, agPortCurCfgBwmContract=agPortCurCfgBwmContract, portmirroring=portmirroring, portInfoPhyIfType=portInfoPhyIfType, portInfoPhyIfLastChange=portInfoPhyIfLastChange, mirrOperMirroredPort=mirrOperMirroredPort, vlanCurCfgPorts=vlanCurCfgPorts, pmNewCfgPmirrMoniPortIndex=pmNewCfgPmirrMoniPortIndex, pmCurCfgState=pmCurCfgState, pmNewCfgVmirrMoniPortIndex=pmNewCfgVmirrMoniPortIndex, portStatsPhyIfInOctets=portStatsPhyIfInOctets, agPortNewCfgStp=agPortNewCfgStp, agPortNewCfgState=agPortNewCfgState, stgCurCfgPortIndex=stgCurCfgPortIndex, pmNewCfgPmirrDelete=pmNewCfgPmirrDelete, agPortCurCfgFastEthFctl=agPortCurCfgFastEthFctl, agPortCurCfgBackLink=agPortCurCfgBackLink, stgNewCfgVlanBmap2=stgNewCfgVlanBmap2, agPortNewCfgTableEntry=agPortNewCfgTableEntry, vlanCurCfgBwmContract=vlanCurCfgBwmContract, agPortNewCfgFastEthAutoNeg=agPortNewCfgFastEthAutoNeg, agPortCurCfgFastEthAutoNeg=agPortCurCfgFastEthAutoNeg, vlanCurCfgVlanName=vlanCurCfgVlanName, pmNewCfgVlanMonitorTable=pmNewCfgVlanMonitorTable, pmCurCfgPortMirrState=pmCurCfgPortMirrState, trunkGroupCurCfgTableEntry=trunkGroupCurCfgTableEntry, mirrOperState=mirrOperState, portStatsTable=portStatsTable, stgCurCfgIndex=stgCurCfgIndex, stgCurCfgVlanBmap2=stgCurCfgVlanBmap2, pmNewCfgVmirrMirrVlanIndex=pmNewCfgVmirrMirrVlanIndex, portInfoSpeed=portInfoSpeed, pmCurCfgPmirrMirrPortIndex=pmCurCfgPmirrMirrPortIndex, vlanNewCfgJumbo=vlanNewCfgJumbo, pmCurCfgTimeout=pmCurCfgTimeout, trunkGroupCurCfgIndex=trunkGroupCurCfgIndex, agPortCurCfgGigEthAutoNeg=agPortCurCfgGigEthAutoNeg, pmNewCfgPortMonitorTable=pmNewCfgPortMonitorTable, portStatsPhyIfOutErrors=portStatsPhyIfOutErrors, portStatsPhyIfOutNUcastPkts=portStatsPhyIfOutNUcastPkts, portInfoPhyIfDescr=portInfoPhyIfDescr, agPortCurCfgTable=agPortCurCfgTable, mirrOperTimeout=mirrOperTimeout, portInfoMode=portInfoMode, pmNewCfgPmirrDirection=pmNewCfgPmirrDirection, portInfoPhyIfMtu=portInfoPhyIfMtu, portCpuAStatsUtil4Seconds=portCpuAStatsUtil4Seconds, vlanCurCfgVlanId=vlanCurCfgVlanId, pmCurCfgMonitoredTraffic=pmCurCfgMonitoredTraffic, pmNewCfgMonitoredTraffic=pmNewCfgMonitoredTraffic, agPortNewCfgFastEthFctl=agPortNewCfgFastEthFctl, portInfoTable=portInfoTable, stgCurCfgPortTableEntry=stgCurCfgPortTableEntry, portStatsPhyIfOutDiscards=portStatsPhyIfOutDiscards, agPortNewCfgGigEthFctl=agPortNewCfgGigEthFctl, trunkGroupNewCfgDelete=trunkGroupNewCfgDelete, agPortNewCfgFastEthMode=agPortNewCfgFastEthMode, mirrPortMirr=mirrPortMirr, agPortNewCfgDiscardNonIPs=agPortNewCfgDiscardNonIPs, vlanNewCfgVlanName=vlanNewCfgVlanName, portCpuStatsUtilTableEntry=portCpuStatsUtilTableEntry, pmNewCfgMonitoringPort=pmNewCfgMonitoringPort, pmCurCfgPortMonitorEntry=pmCurCfgPortMonitorEntry, stgNewCfgDefaultCfg=stgNewCfgDefaultCfg, agPortCurCfgDiscardNonIPs=agPortCurCfgDiscardNonIPs, portCpuStats=portCpuStats, agPortTableMaxEnt=agPortTableMaxEnt, agPortConfig=agPortConfig, agPortNewCfgTable=agPortNewCfgTable, trunkgroup=trunkgroup, stgNewCfgIndex=stgNewCfgIndex, portStatsPhyIfOutQLen=portStatsPhyIfOutQLen, pmNewCfgTimeout=pmNewCfgTimeout, stgNewCfgStgIndex=stgNewCfgStgIndex, pmCurCfgVlanMonitorEntry=pmCurCfgVlanMonitorEntry, trunkGroupNewCfgAddPort=trunkGroupNewCfgAddPort, agPortCurCfgPVID=agPortCurCfgPVID)
