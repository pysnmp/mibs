#
# PySNMP MIB module HIRSCHMANN-MMP4-ROUTING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hirschmann/hmPlatform4Routing.mib
# Produced by pysmi-1.1.12 at Tue Dec  3 09:43:13 2024
# On host fv-az566-8 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
hmPlatform4, = mibBuilder.importSymbols("HIRSCHMANN-MMP4-BASICL2-MIB", "hmPlatform4")
ospfVirtIfEntry, ospfIfEntry = mibBuilder.importSymbols("OSPF-MIB", "ospfVirtIfEntry", "ospfIfEntry")
rip2IfConfEntry, = mibBuilder.importSymbols("RIPv2-MIB", "rip2IfConfEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, MibIdentifier, Unsigned32, iso, IpAddress, ObjectIdentity, TimeTicks, ModuleIdentity, Counter64, Gauge32, Counter32, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "MibIdentifier", "Unsigned32", "iso", "IpAddress", "ObjectIdentity", "TimeTicks", "ModuleIdentity", "Counter64", "Gauge32", "Counter32", "Bits")
RowStatus, TruthValue, MacAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TruthValue", "MacAddress", "DisplayString", "TextualConvention")
hmPlatform4Routing = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 15, 2))
hmPlatform4Routing.setRevisions(('2005-08-18 12:00', '2003-04-02 17:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmPlatform4Routing.setRevisionsDescriptions(('Revisions made for new release.', 'Updated for release',))
if mibBuilder.loadTexts: hmPlatform4Routing.setLastUpdated('200508181200Z')
if mibBuilder.loadTexts: hmPlatform4Routing.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmPlatform4Routing.setContactInfo('Customer Support\r\n           Postal: \r\n           Hirschmann Automation and Control GmbH\r\n           Stuttgarter Str. 45-51\r\n           72654 Neckartenzlingen\r\n           Germany\r\n           Tel: +49 7127 14 1981\r\n           Web: http://www.hicomcenter.com/\r\n           E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmPlatform4Routing.setDescription('The Hirschmann Private Platform4 Routing MIB definitions for Platform devices.')
hmAgentSwitchArpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 1))
hmAgentSwitchArpAgeoutTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 21600)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpAgeoutTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpAgeoutTime.setDescription('Configures the ARP entry ageout time in seconds.\r\n                     Allowable range: 15-21600')
hmAgentSwitchArpResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpResponseTime.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpResponseTime.setDescription('Configures the ARP request response timeout in seconds.\r\n                     Allowable range: 1-10')
hmAgentSwitchArpMaxRetries = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpMaxRetries.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpMaxRetries.setDescription('Configures the ARP count of maximum request for retries.\r\n                     Allowable range: 0-10')
hmAgentSwitchArpCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpCacheSize.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpCacheSize.setDescription('Configures the ARP maximum number of entries in the cache.\r\n\t\t     Allowable range is platform-specific.')
hmAgentSwitchArpDynamicRenew = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpDynamicRenew.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpDynamicRenew.setDescription('This indicates the current setting of ARP dynamic renew mode. ')
hmAgentSwitchArpTotalEntryCountCurrent = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpTotalEntryCountCurrent.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpTotalEntryCountCurrent.setDescription('Current number of entries in the ARP cache.')
hmAgentSwitchArpTotalEntryCountPeak = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpTotalEntryCountPeak.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpTotalEntryCountPeak.setDescription('Peak number of entries recorded in the ARP cache over\r\n\t\t     time.  This value is restarted whenever the ARP cache\r\n\t\t     size is changed.')
hmAgentSwitchArpStaticEntryCountCurrent = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpStaticEntryCountCurrent.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpStaticEntryCountCurrent.setDescription('Current number of configured static ARP entries.')
hmAgentSwitchArpStaticEntryCountMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpStaticEntryCountMax.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpStaticEntryCountMax.setDescription('Maximum number of configurable static ARP entries.')
hmAgentSwitchArpTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10), )
if mibBuilder.loadTexts: hmAgentSwitchArpTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpTable.setDescription('This table augments the MIB-II ipNetToMediaTable by providing\r\n                     per-interface ARP entry information.')
hmAgentSwitchArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchArpIpAddress"))
if mibBuilder.loadTexts: hmAgentSwitchArpEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpEntry.setDescription('The entry of the hmAgentSwitchArpTable.')
hmAgentSwitchArpAge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpAge.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpAge.setDescription('This defines the time (in seconds) since the ARP entry \r\n\t\t     was last refreshed.  This value is 0 for ARP entries of\r\n\t\t     type local(1) or static(3), since these entries are \r\n\t\t     not subject to aging.')
hmAgentSwitchArpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpIpAddress.setDescription('The IP Address assigned to each interface.')
hmAgentSwitchArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentSwitchArpMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpMacAddress.setDescription('The hardware MAX Address that each interface maps to.')
hmAgentSwitchArpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpInterface.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpInterface.setDescription('The Associated IfIndex which identified the ARP Entry.')
hmAgentSwitchArpType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 1), ("gateway", 2), ("static", 3), ("dynamic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchArpType.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpType.setDescription('The type of ARP entry.')
hmAgentSwitchArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 10, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpStatus.setDescription('The status of this ARP entry.  Setting this object destroy will remove the entry.')
hmAgentSwitchArpSparseLearn = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchArpSparseLearn.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchArpSparseLearn.setDescription('This indicates the current setting of ARP sparse learn mode. ')
hmAgentSwitchIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 2))
hmAgentSwitchIpRoutingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRoutingMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRoutingMode.setDescription('Administratively enables/disables routing on the switch.')
hmAgentSwitchIpVRRPMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpVRRPMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVRRPMode.setDescription('Administratively enables/disables VRRP on the switch.')
hmAgentSwitchIpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3), )
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceTable.setDescription('The hmAgentSwitchIpInterfaceTable.')
hmAgentSwitchIpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpInterfaceIfIndex"))
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceEntry.setDescription('The entry of the hmAgentSwitchIpInterfaceTable.')
hmAgentSwitchIpInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceIfIndex.setDescription('The IfIndex associated with this instance.')
hmAgentSwitchIpInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceIpAddress.setDescription('The IpAddress assigned to this interface.  When setting this value,\r\n                     the value of hmAgentSwitchIpInterfaceNetMask must be set at the same time.')
hmAgentSwitchIpInterfaceNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceNetMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceNetMask.setDescription('The NetMask assigned to this interface.  When setting this value, the \r\n                     value of hmAgentSwitchIpInterfaceIpAddress must be set at the same time.')
hmAgentSwitchIpInterfaceClearIp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceClearIp.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceClearIp.setDescription("Sets the interface's primary IpAddress and NetMask back to 0.0.0.0.\r\n                     The primary ip address can be removed if and only if there are no\r\n                     configured secondary addresses.")
hmAgentSwitchIpInterfaceRoutingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceRoutingMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceRoutingMode.setDescription('Enables or disables routing for this interface.')
hmAgentSwitchIpInterfaceProxyARPMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceProxyARPMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceProxyARPMode.setDescription('Enables or disables Proxy ARP for this interface.')
hmAgentSwitchIpInterfaceMtuValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(68, 9000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceMtuValue.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceMtuValue.setDescription('Configures the MTU value for this interface.  If the value returned is 0\r\n                     this interface is not enabled for routing.  It is not valid to set this\r\n                     value to 0 if routing is enabled.')
hmAgentSwitchIpInterfaceSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceSlotNum.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceSlotNum.setDescription('The Slot Number associated with this instance.')
hmAgentSwitchIpInterfacePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfacePortNum.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfacePortNum.setDescription('The Port Number associated with this instance.')
hmAgentSwitchIpInterfaceNetdirectedBCMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceNetdirectedBCMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpInterfaceNetdirectedBCMode.setDescription('Enables or disables netdirected broadcasts for this interface.')
hmAgentSwitchIpRouterDiscoveryTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4), )
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryTable.setDescription('There is no global administrative flag for router discovery.  The global\r\n                     routing flag (hmAgentSwitchIpRoutingMode) will be used for this purpose.  If routing\r\n                     is disabled, router discovery is disabled as well.')
hmAgentSwitchIpRouterDiscoveryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpRouterDiscoveryIfIndex"))
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryEntry.setDescription('The entry of the hmAgentSwitchIpRouterDiscoveryTable.')
hmAgentSwitchIpRouterDiscoveryIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryIfIndex.setDescription('Interface Number to configure Router Discovery on.')
hmAgentSwitchIpRouterDiscoveryAdvertiseMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertiseMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertiseMode.setDescription('Enable or disable router discovery on the interface.')
hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval.setDescription('Maximum time allowed between sending router advertisements \r\n                     from the interface.')
hmAgentSwitchIpRouterDiscoveryMinAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1800)).clone(450)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryMinAdvertisementInterval.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryMinAdvertisementInterval.setDescription('Minimum time allowed between sending router advertisements from the interface.\r\n                     \r\n                     This value must be less than or equal to \r\n                     hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval.')
hmAgentSwitchIpRouterDiscoveryAdvertisementLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 9000)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertisementLifetime.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertisementLifetime.setDescription('Value of lifetime field of router advertsisement sent from \r\n                     the interface.\r\n                     \r\n                     This value must be greater than or equal to \r\n                     hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval.')
hmAgentSwitchIpRouterDiscoveryPreferenceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryPreferenceLevel.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryPreferenceLevel.setDescription('Preferability of the address as a default router address,\r\n                     related to other addresses on the same subnet.  This is defined\r\n                     as the larger the number, the higher the preference.')
hmAgentSwitchIpRouterDiscoveryAdvertisementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 4, 1, 7), IpAddress().clone(hexValue="E0000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertisementAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouterDiscoveryAdvertisementAddress.setDescription('Address used when sending router advertisements from the interface.')
hmAgentSwitchIpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 5), )
if mibBuilder.loadTexts: hmAgentSwitchIpVlanTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanTable.setDescription('The hmAgentSwitchIpVlanTable.')
hmAgentSwitchIpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 5, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpVlanId"))
if mibBuilder.loadTexts: hmAgentSwitchIpVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanEntry.setDescription('A Static VLAN for which routing can be enabled/disabled.')
hmAgentSwitchIpVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpVlanId.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanId.setDescription("The Vlan's Id.")
hmAgentSwitchIpVlanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpVlanIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanIfIndex.setDescription('The IfIndex associated with this VLAN.')
hmAgentSwitchIpVlanRoutingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 5, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentSwitchIpVlanRoutingStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanRoutingStatus.setDescription('Status of Routing mode per Vlan.\r\n                     active(1)       - Vlan is enabled for routing\r\n                     createAndGo(4)  - Adds Vlan entry for routing\r\n                     destroy(6)      - Removes Vlan from routing')
hmAgentSwitchSecondaryAddressTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 6), )
if mibBuilder.loadTexts: hmAgentSwitchSecondaryAddressTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchSecondaryAddressTable.setDescription('Contains a list of secondary IP Addresses associated with an interface.')
hmAgentSwitchSecondaryAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 6, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpInterfaceIfIndex"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchSecondaryIpAddress"))
if mibBuilder.loadTexts: hmAgentSwitchSecondaryAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchSecondaryAddressEntry.setDescription('A secondary IP Address for a given interface.  This IP Address must not \r\n                     conflict with the IP Address configured in the hmAgentSwitchIpInterfaceTable.')
hmAgentSwitchSecondaryIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 6, 1, 1), IpAddress())
if mibBuilder.loadTexts: hmAgentSwitchSecondaryIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchSecondaryIpAddress.setDescription('The Secondary IP Address assigned to this interface.')
hmAgentSwitchSecondaryNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 6, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentSwitchSecondaryNetMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchSecondaryNetMask.setDescription('The Secondary Net Mask assigned to this interface.  This value must be\r\n                     set during creation, and can not be changed.')
hmAgentSwitchSecondaryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentSwitchSecondaryStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchSecondaryStatus.setDescription('Creates a new entry in the Secondary Address table.\r\n                     Allowed values are:\r\n                     \r\n                     createAndGo(4)  - Creates an entry in this table, associating the address\r\n                                       with a given interface.  The hmAgentSwitchSecondaryNetMask\r\n                                       object must be set during creation.\r\n                                        \r\n                     destroy(6)      - Removes the associated address from the interface.')
hmAgentSwitchIpRoutePreferenceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 7), )
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceTable.setDescription('This table contains the MIB objects required to configure \r\n                      the preferences/ administrative distances for the various\r\n                      routing protocols:')
hmAgentSwitchIpRoutePreferenceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 7, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpRoutePreferenceSource"))
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceEntry.setDescription('The entry of the hmAgentSwitchIpRoutePreferenceTable.')
hmAgentSwitchIpRoutePreferenceSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("connected", 1), ("static", 2), ("ospf-intra", 3), ("ospf-inter", 4), ("ospf-ext-t1", 5), ("ospf-ext-t2", 6), ("rip", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceSource.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceSource.setDescription('Routing protocol for which this entry belongs')
hmAgentSwitchIpRoutePreferenceValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceValue.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRoutePreferenceValue.setDescription('Adminstrative distance for this routing protocol.')
hmAgentSwitchIpRouteStaticTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8), )
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticTable.setDescription('......')
hmAgentSwitchIpRouteStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpRouteStaticDestination"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpRouteStaticDestinationMask"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentSwitchIpRouteStaticNextHop"))
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticEntry.setDescription('The entry of the hmAgentSwitchIpRouteStaticTable.')
hmAgentSwitchIpRouteStaticDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 1), IpAddress())
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticDestination.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticDestination.setDescription('.....')
hmAgentSwitchIpRouteStaticDestinationMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 2), IpAddress())
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticDestinationMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticDestinationMask.setDescription('.....')
hmAgentSwitchIpRouteStaticNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 3), IpAddress())
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticNextHop.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticNextHop.setDescription('.....')
hmAgentSwitchIpRouteStaticPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticPreference.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticPreference.setDescription('.....')
hmAgentSwitchIpRouteStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticStatus.setDescription('.....')
hmAgentSwitchIpRouteStaticTrackId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticTrackId.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpRouteStaticTrackId.setDescription('The trackId of the object that should be tracked by this nexthop.\r\n                     If the object goes down, the nexthop is removed from the routing table,\r\n                     it is added again if the object goes up. A value of zero means no tracking')
hmAgentSwitchIpVlanSingleMacMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpVlanSingleMacMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpVlanSingleMacMode.setDescription('If enabled, all vlan routing interfaces use the same MAC address.')
hmAgentSwitchIpTableSizesGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101))
hmAgentSwitchIpTableSizeArp = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeArp.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeArp.setDescription('Sets the maximum size of the ARP table for routing')
hmAgentSwitchIpTableSizeUCRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeUCRoutes.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeUCRoutes.setDescription('Sets the size of the unicast route table')
hmAgentSwitchIpTableSizeMCRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeMCRoutes.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpTableSizeMCRoutes.setDescription('Sets the size of the multicast route table')
hmAgentSwitchIpCurrentTableSizeArp = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeArp.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeArp.setDescription('The current size of the ARP table for routing')
hmAgentSwitchIpCurrentTableSizeUCRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeUCRoutes.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeUCRoutes.setDescription('The current size of the unicast route table')
hmAgentSwitchIpCurrentTableSizeMCRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 2, 101, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeMCRoutes.setStatus('current')
if mibBuilder.loadTexts: hmAgentSwitchIpCurrentTableSizeMCRoutes.setDescription('The current size of the multicast route table')
hmAgentRouterRipConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 3))
hmAgentRouterRipAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipAdminState.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipAdminState.setDescription('Sets the administrative mode of RIP in the router.')
hmAgentRouterRipSplitHorizonMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("poisonReverse", 3))).clone('simple')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipSplitHorizonMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipSplitHorizonMode.setDescription('Sets the RIP split horizon operating mode in the router.\r\n\t\t      A value of none(1) means split horizon processing is\r\n\t\t      disabled.  When set to simple(2), the simple split \r\n\t\t      horizon technique is used.  When set to poisonReverse(3),\r\n\t\t      the split horizon with poison reverse technique is used.\r\n\t\t      The default split horizon mode is simple(2).')
hmAgentRouterRipAutoSummaryMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipAutoSummaryMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipAutoSummaryMode.setDescription('Sets the RIP auto summarization mode in the router.\r\n\t\t      A value of enable(1) means that routes advertized by\r\n\t\t      this RIP router are combined, or summarized, whenever\r\n\t\t      possible into aggregates. When set to disable(2),\r\n\t\t      routes are not aggregated in RIP updates generated\r\n\t\t      by this router.  The default auto summary mode is \r\n\t\t      enable(1).')
hmAgentRouterRipHostRoutesAcceptMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipHostRoutesAcceptMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipHostRoutesAcceptMode.setDescription('Sets the RIP host route acceptance mode in the router.\r\n\t\t      A value of enable(1) means that host routes advertized\r\n\t\t      to this RIP router will be accepted (learned) into its\r\n\t\t      routing table.  When set to disable(2), host routes \r\n\t\t      advertized in RIP updates from neighboring routers\r\n\t\t      are ignored.  The default host routes accept mode is\r\n\t\t      enable(1).')
hmAgentRouterRipDefaultMetric = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipDefaultMetric.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipDefaultMetric.setDescription('Default metric of redistributed routes, when RIP redistributes \r\n                from other protocols.')
hmAgentRouterRipDefaultMetricConfigured = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipDefaultMetricConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipDefaultMetricConfigured.setDescription('Flag to determine whether RIP default-metric is configured or not.')
hmAgentRouterRipDefaultInfoOriginate = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipDefaultInfoOriginate.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipDefaultInfoOriginate.setDescription('Flag to determine, whether RIP can advertise a default-route learned\r\n                from another protocol.')
hmAgentRipRouteRedistTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8), )
if mibBuilder.loadTexts: hmAgentRipRouteRedistTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistTable.setDescription('This table contains the MIB objects required to configure \r\n                      route-redistribution for RIP. Here, RIP is the Destination\r\n                      protocol and the source protocols can be any of : BGP, OSPF,\r\n                      Static, Connected.')
hmAgentRipRouteRedistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentRipRouteRedistSource"))
if mibBuilder.loadTexts: hmAgentRipRouteRedistEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistEntry.setDescription('The entry of the hmAgentRipRouteRedistTable.')
hmAgentRipRouteRedistSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("connected", 1), ("static", 2), ("ospf", 3), ("bgp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRipRouteRedistSource.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistSource.setDescription('Source route, from which RIP can redistribute routes.\r\n                      This object also acts as the identifier for  the \r\n                      RIP redistribution Table entry.')
hmAgentRipRouteRedistMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMode.setDescription('User enabels/disables route-redistribution for a particular source\r\n                      protocol.')
hmAgentRipRouteRedistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMetric.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMetric.setDescription('Metric used for redistributing a particular source protocol route\r\n                      into RIP.')
hmAgentRipRouteRedistMetricConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMetricConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMetricConfigured.setDescription('Flag to determine whether RIP redistribute-metric is configured or not.')
hmAgentRipRouteRedistMatchInternal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchInternal.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchInternal.setDescription('If this flag is true, RIP redistributes OSPF internal routes.\r\n                      It will be non-applicable, when source protocol is other than ospf.')
hmAgentRipRouteRedistMatchExternal1 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchExternal1.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchExternal1.setDescription('If this flag is true, RIP redistributes OSPF External1 routes.\r\n                      It will be non-applicable, when source protocol is other than ospf.')
hmAgentRipRouteRedistMatchExternal2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchExternal2.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchExternal2.setDescription('If this flag is true, RIP redistributes OSPF External2 routes.\r\n                      It will be non-applicable, when source protocol is other than ospf.')
hmAgentRipRouteRedistMatchNSSAExternal1 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchNSSAExternal1.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchNSSAExternal1.setDescription('If this flag is true, RIP redistributes OSPF NSSA-External1 routes.\r\n                      It will be non-applicable, when source protocol is other than ospf.')
hmAgentRipRouteRedistMatchNSSAExternal2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchNSSAExternal2.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistMatchNSSAExternal2.setDescription('If this flag is true, RIP redistributes OSPF NSSA-External2 routes.\r\n                      It will be non-applicable, when source protocol is other than ospf.')
hmAgentRipRouteRedistDistList = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistDistList.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistDistList.setDescription('Access-list number of the access-list, which filters routes received\r\n                      from a source-protocol.')
hmAgentRipRouteRedistDistListConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 8, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRipRouteRedistDistListConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentRipRouteRedistDistListConfigured.setDescription('Flag to determine whether Access-list is configured or not.')
hmAgentRip2IfConfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 9), )
if mibBuilder.loadTexts: hmAgentRip2IfConfTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2IfConfTable.setDescription('A list of subnets which require separate\r\n           configuration in RIP.  Augments rip2IfConfTable\r\n\t   in the RIPv2-MIB.')
hmAgentRip2IfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 9, 1), )
rip2IfConfEntry.registerAugmentions(("HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentRip2IfConfEntry"))
hmAgentRip2IfConfEntry.setIndexNames(*rip2IfConfEntry.getIndexNames())
if mibBuilder.loadTexts: hmAgentRip2IfConfEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2IfConfEntry.setDescription('A Single Routing Domain in a single Subnet.\r\n\t   Augments rip2IfConfEntry in RIPv2-MIB.')
hmAgentRip2IfConfAuthKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentRip2IfConfAuthKeyId.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2IfConfAuthKeyId.setDescription('The identifier for the authentication key used\r\n           on this interface.  This field is only meaningful \r\n           when the RIPv2-MIB rip2IfConfAuthType is md5(3); \r\n\t   otherwise, the value is not used.')
hmAgentRip2InterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10), )
if mibBuilder.loadTexts: hmAgentRip2InterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceTable.setDescription('The hmAgentRip2InterfaceTable.')
hmAgentRip2InterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentRip2InterfaceIfIndex"))
if mibBuilder.loadTexts: hmAgentRip2InterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceEntry.setDescription('The entry of the hmAgentRip2InterfaceTable.')
hmAgentRip2InterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRip2InterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceIfIndex.setDescription('The IfIndex associated with this instance.')
hmAgentRip2InterfaceAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAuthentication", 1), ("simplePassword", 2), ("md5", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthType.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthType.setDescription('The type of Authentication used on this interface.')
hmAgentRip2InterfaceAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthKey.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthKey.setDescription('The value to be used as the Authentication Key\r\n                      whenever the corresponding instance of\r\n                      hmAgentRip2InterfaceAuthType has a value other than\r\n                      noAuthentication.  A modification of the corresponding\r\n                      instance of hmAgentRip2InterfaceAuthType does not modify\r\n                      the hmAgentRip2InterfaceAuthKey value.  If a string shorter\r\n                      than 16 octets is supplied, it will be left-\r\n                      justified and padded to 16 octets, on the right,\r\n                      with nulls (0x00).\r\n\r\n                      Reading this object always results in an  OCTET\r\n                      STRING of length zero; authentication may not\r\n                      be bypassed by reading the MIB object.')
hmAgentRip2InterfaceAuthKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthKeyId.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceAuthKeyId.setDescription('The identifier for the authentication key used\r\n                      on this interface.  This field is only meaningful \r\n                      when the hmAgentRip2InterfaceAuthType is md5(3); \r\n\t                  otherwise, the value is not used.')
hmAgentRip2InterfaceSendVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceSendVersion.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceSendVersion.setDescription('What the router sends on this interface.\r\n           ripVersion1 implies sending RIP updates compliant\r\n           with  RFC  1058.   rip1Compatible implies\r\n           broadcasting RIP-2 updates using RFC 1058 route\r\n           subsumption rules.  ripVersion2 implies\r\n           multicasting RIP-2 updates.')
hmAgentRip2InterfaceReceiveVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3), ("doNotReceive", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceReceiveVersion.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceReceiveVersion.setDescription('This indicates which version of RIP updates\r\n           are to be accepted.  Note that rip2 and\r\n           rip1OrRip2 implies reception of multicast\r\n           packets.')
hmAgentRip2InterfaceAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRip2InterfaceAdminState.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2InterfaceAdminState.setDescription('Enables/disables RIP on the interface')
hmAgentRip2RcvBadPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRip2RcvBadPackets.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2RcvBadPackets.setDescription('......')
hmAgentRip2RcvBadRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRip2RcvBadRoutes.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2RcvBadRoutes.setDescription('....')
hmAgentRip2SentUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentRip2SentUpdates.setStatus('current')
if mibBuilder.loadTexts: hmAgentRip2SentUpdates.setDescription('....')
hmAgentRouterRipUpdateTimerInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 3, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterRipUpdateTimerInterval.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterRipUpdateTimerInterval.setDescription('Sets the RIP update timer interval in the router.\r\n\t\t      This is the time in seconds between two full routing table\r\n\t\t      update packets.')
hmAgentRouterOspfConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 4))
hmAgentOspfDefaultMetric = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultMetric.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultMetric.setDescription('Default metric of redistributed routes, when OSPF redistributes \r\n                from other protocols.')
hmAgentOspfDefaultMetricConfigured = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultMetricConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultMetricConfigured.setDescription('Flag to determine whether OSPF default-metric is configured or not.')
hmAgentOspfDefaultInfoOriginate = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginate.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginate.setDescription('Flag to determine, whether OSPF can advertise a default-route learned\r\n                from another protocol.')
hmAgentOspfDefaultInfoOriginateAlways = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateAlways.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateAlways.setDescription("When this flag is true, the router advertises 0.0.0.0/0.0.0.0 always.\r\n                Without this option, OSPF will only advertise 0.0.0.0/0.0.0.0 if the\r\n                router's forwarding table contains a default route.")
hmAgentOspfDefaultInfoOriginateMetric = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetric.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetric.setDescription('Metric of the default route,which OSPF advertises when learned from\r\n                other protocol.')
hmAgentOspfDefaultInfoOriginateMetricConfigured = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetricConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetricConfigured.setDescription('Flag to determine whether OSPF default-info originate metric \r\n                      is configured or not.')
hmAgentOspfDefaultInfoOriginateMetricType = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("externalType1", 1), ("externalType2", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetricType.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfDefaultInfoOriginateMetricType.setDescription('Metric Type of the default route,which OSPF advertises when learned from\r\n                other protocol. It can be 1(external type 1) or 2(external type 2).')
hmAgentOspfRouteRedistTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8), )
if mibBuilder.loadTexts: hmAgentOspfRouteRedistTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistTable.setDescription('This table contains the MIB objects required to configure \r\n                      route-redistribution for OSPF. Here, OSPF is the Destination\r\n                      protocol and the source protocols can be any of : BGP, RIP,\r\n                      Static, Connected.')
hmAgentOspfRouteRedistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentOspfRouteRedistSource"))
if mibBuilder.loadTexts: hmAgentOspfRouteRedistEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistEntry.setDescription('The entry of the hmAgentOspfRouteRedistTable.')
hmAgentOspfRouteRedistSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("connected", 1), ("static", 2), ("rip", 3), ("bgp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistSource.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistSource.setDescription('Source protocol, from which OSPF can redistribute routes.\r\n                      This object also acts as the identifier for  the \r\n                      OSPF redistribution Table entry.')
hmAgentOspfRouteRedistMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMode.setDescription('User enabels/disables route-redistribution for a particular source\r\n                      protocol.')
hmAgentOspfRouteRedistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetric.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetric.setDescription('Metric used for redistributing a particular source protocol route\r\n                      into OSPF.')
hmAgentOspfRouteRedistMetricConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetricConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetricConfigured.setDescription('Flag to determine whether OSPF redistribute-metric is configured or not.')
hmAgentOspfRouteRedistMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("externalType1", 1), ("externalType2", 2))).clone('externalType2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetricType.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistMetricType.setDescription('Metric Type of routes,which OSPF redistributes from other source protocols.\r\n                      It can be 1(external type 1) or 2(external type 2).')
hmAgentOspfRouteRedistTag = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistTag.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistTag.setDescription('It specifies the tag field in routes redistributed by OSPF.')
hmAgentOspfRouteRedistSubnets = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistSubnets.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistSubnets.setDescription('If this value is false, then OSPF will not redistribute subnetted routes.')
hmAgentOspfRouteRedistDistList = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 199))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistDistList.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistDistList.setDescription('Access-list number of the access-list, which filters routes received\r\n                      from a source-protocol.')
hmAgentOspfRouteRedistDistListConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 8, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfRouteRedistDistListConfigured.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfRouteRedistDistListConfigured.setDescription('Flag to determine whether Access-list is configured or not.')
hmAgentOspfIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 9), )
if mibBuilder.loadTexts: hmAgentOspfIfTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfIfTable.setDescription('The OSPF Interface Table describes the  inter-\r\n           faces from the viewpoint of OSPF.  Augments \r\n\t   ospfIfTable from the OSPF-MIB.')
hmAgentOspfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 9, 1), )
ospfIfEntry.registerAugmentions(("HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentOspfIfEntry"))
hmAgentOspfIfEntry.setIndexNames(*ospfIfEntry.getIndexNames())
if mibBuilder.loadTexts: hmAgentOspfIfEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfIfEntry.setDescription('The OSPF Interface Entry describes one  inter-\r\n           face from the viewpoint of OSPF.  Augments\r\n\t   ospfIfEntry in OSPF-MIB.')
hmAgentOspfIfAuthKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentOspfIfAuthKeyId.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfIfAuthKeyId.setDescription('The identifier for the authentication key used\r\n           on this interface.  This field is only meaningful \r\n           when the OSPF-MIB ospfIfAuthType is md5(2); \r\n\t   otherwise, the value is not used.')
hmAgentOspfIfIpMtuIgnoreFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentOspfIfIpMtuIgnoreFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfIfIpMtuIgnoreFlag.setDescription('Configures the IP MTU Ignore Flag value for this OSPF interface.')
hmAgentOspfVirtIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 10), )
if mibBuilder.loadTexts: hmAgentOspfVirtIfTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfVirtIfTable.setDescription("Information about this router's virtual inter-\r\n           faces.  Augments ospfVirtIfTable from the OSPF-MIB.")
hmAgentOspfVirtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 10, 1), )
ospfVirtIfEntry.registerAugmentions(("HIRSCHMANN-MMP4-ROUTING-MIB", "hmAgentOspfVirtIfEntry"))
hmAgentOspfVirtIfEntry.setIndexNames(*ospfVirtIfEntry.getIndexNames())
if mibBuilder.loadTexts: hmAgentOspfVirtIfEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfVirtIfEntry.setDescription('Information about a single Virtual Interface.\r\n\t   Augments ospfVirtIfEntry in OSPF-MIB.')
hmAgentOspfVirtIfAuthKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmAgentOspfVirtIfAuthKeyId.setStatus('current')
if mibBuilder.loadTexts: hmAgentOspfVirtIfAuthKeyId.setDescription('The identifier for the authentication key used\r\n           on this virtual interface.  This field is only meaningful \r\n           when the OSPF-MIB ospfVirtIfAuthType is md5(2); \r\n\t   otherwise, the value is not used.')
hmAgentRouterOspfRFC1583CompatibilityMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterOspfRFC1583CompatibilityMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterOspfRFC1583CompatibilityMode.setDescription("From RFC2328: \r\n            Controls the preference rules used in Section 16.4 when\r\n            choosing among multiple AS-external-LSAs advertising the\r\n            same destination. When set to 'enabled', the preference\r\n            rules remain those specified by RFC 1583 ([Ref9]). When set\r\n            to 'disabled', the preference rules are those stated in\r\n\r\n            Section 16.4.1, which prevent routing loops when AS-\r\n            external-LSAs for the same destination have been originated\r\n            from different areas. Set to 'enabled' by default.\r\n\r\n            In order to minimize the chance of routing loops, all OSPF\r\n            routers in an OSPF routing domain should have\r\n            RFC1583Compatibility set identically. When there are routers\r\n            present that have not been updated with the functionality\r\n            specified in Section 16.4.1 of this memo, all routers should\r\n            have RFC1583Compatibility set to 'enabled'. Otherwise, all\r\n            routers should have RFC1583Compatibility set to 'disabled',\r\n            preventing all routing loops.")
hmAgentSnmpTrapFlagsConfigGroupLayer3 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 5))
hmAgentSnmpVRRPNewMasterTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpVRRPNewMasterTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpVRRPNewMasterTrapFlag.setDescription('This flag enables the sending of VRRP new master notification\r\n                     traps.')
hmAgentSnmpVRRPAuthFailureTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpVRRPAuthFailureTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpVRRPAuthFailureTrapFlag.setDescription('This flag enables the sending of VRRP authentication failure\r\n                     notification traps.')
hmAgentECMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 7))
hmAgentECMPOspfMaxPaths = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 7, 1), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentECMPOspfMaxPaths.setStatus('current')
if mibBuilder.loadTexts: hmAgentECMPOspfMaxPaths.setDescription('It sets the number of paths that OSPF can report for a given destination \r\n         where maxpaths is platform-dependent.')
hmAgentRouterVrrpConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 8))
hmAgentRouterVrrpAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 2, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentRouterVrrpAdminState.setStatus('current')
if mibBuilder.loadTexts: hmAgentRouterVrrpAdminState.setDescription('Sets the administrative mode of VRRP in the router.')
hmVrrpExtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 2, 9))
hmVrrpTrackingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1), )
if mibBuilder.loadTexts: hmVrrpTrackingTable.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackingTable.setDescription('This table contains variables to define\r\n                                an entry in the VRRP Tracking database.')
hmVrrpTrackingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpTrackIfIndex"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpTrackVrid"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpTrackId"))
if mibBuilder.loadTexts: hmVrrpTrackingEntry.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackingEntry.setDescription('The entry of the hmVrrpTrackingTable.')
hmVrrpTrackIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: hmVrrpTrackIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackIfIndex.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe interface number of the virtual router')
hmVrrpTrackVrid = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: hmVrrpTrackVrid.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackVrid.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe virtual router id for this virtual router')
hmVrrpTrackId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 3), Integer32())
if mibBuilder.loadTexts: hmVrrpTrackId.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackId.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe id of the object being tracked')
hmVrrpTrackDecrement = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 253))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpTrackDecrement.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackDecrement.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe value by wich the current priority of the virtual router\r\n\t\t\t\t\t\t\t\tis decremented when the tracked object goes DOWN.')
hmVrrpTrackOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpTrackOperStatus.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackOperStatus.setDescription('Shows if the tracked object is currently UP od DOWN')
hmVrrpTrackRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmVrrpTrackRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmVrrpTrackRowStatus.setDescription('DURABLE: { 1:all }\r\n                Defines the status of a vrrp tracking database entry.\r\n                Set to createAndGo(4) to create a new row.\r\n                Set to destroy(6) to delete an entry.\r\n                Reads as active(1) if the tracked object exists and is trackable,\r\n                notReady(3) otherwise.')
hmVrrpExtTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2), )
if mibBuilder.loadTexts: hmVrrpExtTable.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtTable.setDescription('This table contains variables to define\r\n                                an entry in the VRRP enhancements database.')
hmVrrpExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpExtIfIndex"), (0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpExtVrid"))
if mibBuilder.loadTexts: hmVrrpExtEntry.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtEntry.setDescription('The entry of the hmVrrpExtTable.')
hmVrrpExtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: hmVrrpExtIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtIfIndex.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe interface number of the virtual router')
hmVrrpExtVrid = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: hmVrrpExtVrid.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtVrid.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe virtual router id for this virtual router')
hmVrrpExtDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtDomainId.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtDomainId.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe domain this virtual router is a member of. If set to\r\n\t\t\t\t\t\t\t\t0, the virtual router is not a member of any domain.')
hmVrrpExtDomainRole = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("member", 2), ("supervisor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtDomainRole.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtDomainRole.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe role of this virtual router in its domain. This is none(1) if\r\n\t\t\t\t\t\t\t\tthe virtual router is not member of a domain, supervisor(3) if it\r\n\t\t\t\t\t\t\t\tis the supervisor of its domain, member(2) otherwise.')
hmVrrpExtDomainStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noError", 1), ("noSupervisor", 2), ("supervisorDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpExtDomainStatus.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtDomainStatus.setDescription('Shows if the domain configuration is correct for this virtual router')
hmVrrpExtAdvertAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtAdvertAddress.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtAdvertAddress.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe IP address advertisements of the virtual router are sent to')
hmVrrpExtAdvertTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 255000))).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtAdvertTimer.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtAdvertTimer.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThis is used to set the interval between advertisements in\r\n\t\t\t\t\t\t\t\tmilliseconds. This accesses the same value as\r\n\t\t\t\t\t\t\t\tvrrpOperAdvertisementInterval.')
hmVrrpExtOperPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpExtOperPriority.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtOperPriority.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe current operating priority of the virtual router. This can be\r\n\t\t\t\t\t\t\t\tdifferent from the configured priority if tracked objects are down.\r\n\t\t\t\t\t\t\t\tFor domain members this is the priority of the supervisor of that\r\n\t\t\t\t\t\t\t\tDomain.')
hmVrrpExtNotifyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtNotifyAddress.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtNotifyAddress.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tThe IP address notifications of the virtual router are sent to')
hmVrrpExtNotifyLinkdown = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtNotifyLinkdown.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtNotifyLinkdown.setDescription("DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tEnables or disables sending of notification messages if the\r\n\t\t\t\t\t\t\t\tvirtual router's interface goes down.")
hmVrrpExtPreemptionDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpExtPreemptionDelay.setStatus('current')
if mibBuilder.loadTexts: hmVrrpExtPreemptionDelay.setDescription('DURABLE: { 1:all }\r\n\t\t\t\t\t\t\t\tTime (in seconds) after startup of the virtual router by which the\r\n\t\t\t\t\t\t\t\tpreemption of a Master with a lower priority is delayed.')
hmVrrpDomainTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3), )
if mibBuilder.loadTexts: hmVrrpDomainTable.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainTable.setDescription('This table contains variables to define\r\n                                an entry in the VRRP domain database.')
hmVrrpDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-ROUTING-MIB", "hmVrrpDomainId"))
if mibBuilder.loadTexts: hmVrrpDomainEntry.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainEntry.setDescription('')
hmVrrpDomainId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)))
if mibBuilder.loadTexts: hmVrrpDomainId.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainId.setDescription('The domain ID.')
hmVrrpDomainMemberSendAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmVrrpDomainMemberSendAdv.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainMemberSendAdv.setDescription('DURABLE: { 1:all }\r\n                \t\t\t\tDetermines if the members of this domain send advertisement packets.\r\n                \t\t\t\tIf set to disabled(2), only the supervisor of the domain sends packets.')
hmVrrpDomainStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noError", 1), ("noSupervisor", 2), ("supervisorDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpDomainStatus.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainStatus.setDescription('Shows if the configuration of the domain is complete.')
hmVrrpDomainSupervisorIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpDomainSupervisorIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainSupervisorIfIndex.setDescription('The interface number of the supervisor of the domain')
hmVrrpDomainSupervisorVrid = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpDomainSupervisorVrid.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainSupervisorVrid.setDescription('The virtual router id of the supervisor of the domain')
hmVrrpDomainOperPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpDomainOperPriority.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainOperPriority.setDescription('The current operating priority of the domain. This can be\r\n\t\t\t\t\t\t\t\tdifferent from the configured priority if tracked objects are down.\r\n\t\t\t\t\t\t\t\tFor domain members this is the priority of the supervisor of that\r\n\t\t\t\t\t\t\t\tDomain if the supervisor is configured and up.')
hmVrrpDomainSupervisorOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 2, 9, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initialize", 1), ("backup", 2), ("master", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmVrrpDomainSupervisorOperState.setStatus('current')
if mibBuilder.loadTexts: hmVrrpDomainSupervisorOperState.setDescription('Shows the current operational state of the domain supervisor.')
mibBuilder.exportSymbols("HIRSCHMANN-MMP4-ROUTING-MIB", hmVrrpExtGroup=hmVrrpExtGroup, hmAgentSwitchIpRouteStaticPreference=hmAgentSwitchIpRouteStaticPreference, hmAgentRouterRipDefaultMetricConfigured=hmAgentRouterRipDefaultMetricConfigured, hmAgentOspfDefaultInfoOriginateMetricConfigured=hmAgentOspfDefaultInfoOriginateMetricConfigured, hmAgentRouterVrrpAdminState=hmAgentRouterVrrpAdminState, hmVrrpTrackId=hmVrrpTrackId, hmVrrpTrackOperStatus=hmVrrpTrackOperStatus, hmAgentSwitchIpVlanSingleMacMode=hmAgentSwitchIpVlanSingleMacMode, hmVrrpExtOperPriority=hmVrrpExtOperPriority, hmAgentSwitchIpInterfaceIfIndex=hmAgentSwitchIpInterfaceIfIndex, hmAgentRouterRipDefaultInfoOriginate=hmAgentRouterRipDefaultInfoOriginate, hmAgentRip2InterfaceAuthKeyId=hmAgentRip2InterfaceAuthKeyId, hmVrrpDomainStatus=hmVrrpDomainStatus, hmAgentSwitchIpTableSizesGroup=hmAgentSwitchIpTableSizesGroup, hmAgentSwitchIpVlanIfIndex=hmAgentSwitchIpVlanIfIndex, hmAgentSwitchArpAgeoutTime=hmAgentSwitchArpAgeoutTime, hmAgentSwitchArpType=hmAgentSwitchArpType, hmVrrpExtVrid=hmVrrpExtVrid, hmVrrpTrackDecrement=hmVrrpTrackDecrement, hmAgentSwitchIpRouterDiscoveryAdvertisementLifetime=hmAgentSwitchIpRouterDiscoveryAdvertisementLifetime, hmAgentSwitchIpRouteStaticDestinationMask=hmAgentSwitchIpRouteStaticDestinationMask, hmAgentSwitchArpDynamicRenew=hmAgentSwitchArpDynamicRenew, hmVrrpExtIfIndex=hmVrrpExtIfIndex, hmAgentRipRouteRedistTable=hmAgentRipRouteRedistTable, hmAgentRouterRipDefaultMetric=hmAgentRouterRipDefaultMetric, hmAgentSwitchIpInterfaceNetdirectedBCMode=hmAgentSwitchIpInterfaceNetdirectedBCMode, hmAgentRouterOspfConfigGroup=hmAgentRouterOspfConfigGroup, hmAgentRip2RcvBadRoutes=hmAgentRip2RcvBadRoutes, hmAgentSnmpVRRPNewMasterTrapFlag=hmAgentSnmpVRRPNewMasterTrapFlag, hmAgentSwitchIpRoutingMode=hmAgentSwitchIpRoutingMode, hmAgentRip2InterfaceAuthKey=hmAgentRip2InterfaceAuthKey, hmAgentRip2RcvBadPackets=hmAgentRip2RcvBadPackets, hmAgentOspfVirtIfEntry=hmAgentOspfVirtIfEntry, hmVrrpExtTable=hmVrrpExtTable, hmAgentOspfIfEntry=hmAgentOspfIfEntry, hmAgentRipRouteRedistMatchExternal2=hmAgentRipRouteRedistMatchExternal2, hmAgentSwitchIpVlanId=hmAgentSwitchIpVlanId, hmAgentSwitchArpTotalEntryCountCurrent=hmAgentSwitchArpTotalEntryCountCurrent, hmAgentSwitchIpInterfaceMtuValue=hmAgentSwitchIpInterfaceMtuValue, hmAgentRip2InterfaceEntry=hmAgentRip2InterfaceEntry, hmAgentSnmpVRRPAuthFailureTrapFlag=hmAgentSnmpVRRPAuthFailureTrapFlag, hmAgentSwitchArpMaxRetries=hmAgentSwitchArpMaxRetries, hmAgentSwitchIpRoutePreferenceSource=hmAgentSwitchIpRoutePreferenceSource, hmAgentSwitchIpCurrentTableSizeUCRoutes=hmAgentSwitchIpCurrentTableSizeUCRoutes, hmAgentRouterOspfRFC1583CompatibilityMode=hmAgentRouterOspfRFC1583CompatibilityMode, hmAgentRip2InterfaceReceiveVersion=hmAgentRip2InterfaceReceiveVersion, hmAgentRip2SentUpdates=hmAgentRip2SentUpdates, hmVrrpExtDomainStatus=hmVrrpExtDomainStatus, hmAgentRip2IfConfTable=hmAgentRip2IfConfTable, hmAgentRipRouteRedistMode=hmAgentRipRouteRedistMode, hmAgentRouterRipAdminState=hmAgentRouterRipAdminState, hmAgentSwitchSecondaryAddressTable=hmAgentSwitchSecondaryAddressTable, hmAgentSwitchIpRouteStaticEntry=hmAgentSwitchIpRouteStaticEntry, hmAgentSwitchIpInterfaceClearIp=hmAgentSwitchIpInterfaceClearIp, hmAgentSwitchIpRoutePreferenceTable=hmAgentSwitchIpRoutePreferenceTable, hmVrrpExtAdvertTimer=hmVrrpExtAdvertTimer, hmAgentRouterRipConfigGroup=hmAgentRouterRipConfigGroup, hmAgentRouterRipSplitHorizonMode=hmAgentRouterRipSplitHorizonMode, hmAgentRouterRipAutoSummaryMode=hmAgentRouterRipAutoSummaryMode, hmAgentSwitchIpInterfaceEntry=hmAgentSwitchIpInterfaceEntry, hmVrrpTrackingEntry=hmVrrpTrackingEntry, hmAgentSwitchIpRoutePreferenceValue=hmAgentSwitchIpRoutePreferenceValue, hmAgentRipRouteRedistMetricConfigured=hmAgentRipRouteRedistMetricConfigured, hmAgentSwitchArpIpAddress=hmAgentSwitchArpIpAddress, hmVrrpExtDomainId=hmVrrpExtDomainId, hmAgentSwitchIpVRRPMode=hmAgentSwitchIpVRRPMode, hmAgentSwitchIpRouteStaticNextHop=hmAgentSwitchIpRouteStaticNextHop, hmAgentRouterVrrpConfigGroup=hmAgentRouterVrrpConfigGroup, hmAgentSwitchArpStaticEntryCountMax=hmAgentSwitchArpStaticEntryCountMax, hmVrrpDomainSupervisorVrid=hmVrrpDomainSupervisorVrid, hmAgentOspfIfTable=hmAgentOspfIfTable, hmAgentOspfDefaultInfoOriginateAlways=hmAgentOspfDefaultInfoOriginateAlways, hmAgentSwitchArpGroup=hmAgentSwitchArpGroup, hmAgentSwitchSecondaryIpAddress=hmAgentSwitchSecondaryIpAddress, hmAgentOspfVirtIfAuthKeyId=hmAgentOspfVirtIfAuthKeyId, hmAgentSwitchArpSparseLearn=hmAgentSwitchArpSparseLearn, hmAgentSwitchIpInterfacePortNum=hmAgentSwitchIpInterfacePortNum, hmAgentSwitchIpRoutePreferenceEntry=hmAgentSwitchIpRoutePreferenceEntry, hmAgentSwitchSecondaryNetMask=hmAgentSwitchSecondaryNetMask, hmVrrpDomainEntry=hmVrrpDomainEntry, hmAgentSwitchArpTable=hmAgentSwitchArpTable, hmAgentRip2IfConfAuthKeyId=hmAgentRip2IfConfAuthKeyId, hmAgentSwitchIpTableSizeMCRoutes=hmAgentSwitchIpTableSizeMCRoutes, hmAgentRip2InterfaceAuthType=hmAgentRip2InterfaceAuthType, hmAgentOspfDefaultInfoOriginateMetric=hmAgentOspfDefaultInfoOriginateMetric, hmAgentOspfDefaultMetricConfigured=hmAgentOspfDefaultMetricConfigured, hmAgentRip2InterfaceAdminState=hmAgentRip2InterfaceAdminState, hmAgentSwitchArpTotalEntryCountPeak=hmAgentSwitchArpTotalEntryCountPeak, hmVrrpExtNotifyLinkdown=hmVrrpExtNotifyLinkdown, hmAgentOspfRouteRedistTag=hmAgentOspfRouteRedistTag, hmAgentSwitchIpCurrentTableSizeArp=hmAgentSwitchIpCurrentTableSizeArp, hmVrrpDomainId=hmVrrpDomainId, hmAgentSwitchIpInterfaceIpAddress=hmAgentSwitchIpInterfaceIpAddress, hmAgentSwitchSecondaryAddressEntry=hmAgentSwitchSecondaryAddressEntry, hmVrrpDomainMemberSendAdv=hmVrrpDomainMemberSendAdv, hmAgentOspfRouteRedistSubnets=hmAgentOspfRouteRedistSubnets, hmAgentSwitchIpInterfaceSlotNum=hmAgentSwitchIpInterfaceSlotNum, hmAgentOspfRouteRedistSource=hmAgentOspfRouteRedistSource, hmAgentSwitchIpRouterDiscoveryAdvertiseMode=hmAgentSwitchIpRouterDiscoveryAdvertiseMode, hmPlatform4Routing=hmPlatform4Routing, hmAgentRipRouteRedistMatchExternal1=hmAgentRipRouteRedistMatchExternal1, hmAgentOspfRouteRedistMetricType=hmAgentOspfRouteRedistMetricType, hmVrrpDomainOperPriority=hmVrrpDomainOperPriority, hmAgentOspfIfIpMtuIgnoreFlag=hmAgentOspfIfIpMtuIgnoreFlag, hmAgentSwitchArpMacAddress=hmAgentSwitchArpMacAddress, hmAgentRip2InterfaceTable=hmAgentRip2InterfaceTable, hmAgentSwitchIpRouterDiscoveryAdvertisementAddress=hmAgentSwitchIpRouterDiscoveryAdvertisementAddress, hmAgentSwitchIpVlanEntry=hmAgentSwitchIpVlanEntry, hmAgentRipRouteRedistMatchInternal=hmAgentRipRouteRedistMatchInternal, hmVrrpTrackRowStatus=hmVrrpTrackRowStatus, hmAgentSwitchArpCacheSize=hmAgentSwitchArpCacheSize, hmAgentSwitchIpInterfaceProxyARPMode=hmAgentSwitchIpInterfaceProxyARPMode, hmAgentSwitchArpAge=hmAgentSwitchArpAge, hmAgentOspfRouteRedistMetricConfigured=hmAgentOspfRouteRedistMetricConfigured, hmAgentSwitchArpStatus=hmAgentSwitchArpStatus, hmAgentRipRouteRedistMatchNSSAExternal1=hmAgentRipRouteRedistMatchNSSAExternal1, hmAgentRouterRipUpdateTimerInterval=hmAgentRouterRipUpdateTimerInterval, hmVrrpDomainSupervisorIfIndex=hmVrrpDomainSupervisorIfIndex, hmAgentOspfRouteRedistDistListConfigured=hmAgentOspfRouteRedistDistListConfigured, hmAgentSwitchIpRouteStaticTrackId=hmAgentSwitchIpRouteStaticTrackId, hmVrrpTrackingTable=hmVrrpTrackingTable, hmAgentSwitchIpRouterDiscoveryEntry=hmAgentSwitchIpRouterDiscoveryEntry, hmAgentSwitchArpEntry=hmAgentSwitchArpEntry, hmAgentSwitchIpRouteStaticStatus=hmAgentSwitchIpRouteStaticStatus, hmAgentSwitchIpRouteStaticDestination=hmAgentSwitchIpRouteStaticDestination, hmAgentRip2InterfaceIfIndex=hmAgentRip2InterfaceIfIndex, hmVrrpExtPreemptionDelay=hmVrrpExtPreemptionDelay, hmVrrpTrackVrid=hmVrrpTrackVrid, hmVrrpExtNotifyAddress=hmVrrpExtNotifyAddress, hmAgentOspfDefaultInfoOriginateMetricType=hmAgentOspfDefaultInfoOriginateMetricType, hmAgentRouterRipHostRoutesAcceptMode=hmAgentRouterRipHostRoutesAcceptMode, hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval=hmAgentSwitchIpRouterDiscoveryMaxAdvertisementInterval, hmAgentRipRouteRedistMatchNSSAExternal2=hmAgentRipRouteRedistMatchNSSAExternal2, hmAgentSwitchArpStaticEntryCountCurrent=hmAgentSwitchArpStaticEntryCountCurrent, hmAgentSwitchIpRouteStaticTable=hmAgentSwitchIpRouteStaticTable, hmAgentOspfIfAuthKeyId=hmAgentOspfIfAuthKeyId, hmAgentSwitchSecondaryStatus=hmAgentSwitchSecondaryStatus, hmAgentSwitchIpInterfaceTable=hmAgentSwitchIpInterfaceTable, hmAgentRipRouteRedistMetric=hmAgentRipRouteRedistMetric, hmAgentOspfRouteRedistTable=hmAgentOspfRouteRedistTable, PYSNMP_MODULE_ID=hmPlatform4Routing, hmAgentRipRouteRedistDistList=hmAgentRipRouteRedistDistList, hmAgentOspfRouteRedistMetric=hmAgentOspfRouteRedistMetric, hmAgentOspfRouteRedistDistList=hmAgentOspfRouteRedistDistList, hmAgentSwitchArpResponseTime=hmAgentSwitchArpResponseTime, hmAgentSnmpTrapFlagsConfigGroupLayer3=hmAgentSnmpTrapFlagsConfigGroupLayer3, hmAgentOspfDefaultInfoOriginate=hmAgentOspfDefaultInfoOriginate, hmAgentRip2IfConfEntry=hmAgentRip2IfConfEntry, hmAgentSwitchIpRouterDiscoveryMinAdvertisementInterval=hmAgentSwitchIpRouterDiscoveryMinAdvertisementInterval, hmAgentSwitchIpRouterDiscoveryPreferenceLevel=hmAgentSwitchIpRouterDiscoveryPreferenceLevel, hmAgentSwitchIpTableSizeUCRoutes=hmAgentSwitchIpTableSizeUCRoutes, hmAgentRipRouteRedistSource=hmAgentRipRouteRedistSource, hmAgentRipRouteRedistDistListConfigured=hmAgentRipRouteRedistDistListConfigured, hmAgentSwitchIpInterfaceRoutingMode=hmAgentSwitchIpInterfaceRoutingMode, hmAgentSwitchIpCurrentTableSizeMCRoutes=hmAgentSwitchIpCurrentTableSizeMCRoutes, hmAgentSwitchIpVlanRoutingStatus=hmAgentSwitchIpVlanRoutingStatus, hmAgentOspfDefaultMetric=hmAgentOspfDefaultMetric, hmVrrpExtEntry=hmVrrpExtEntry, hmAgentSwitchArpInterface=hmAgentSwitchArpInterface, hmVrrpDomainSupervisorOperState=hmVrrpDomainSupervisorOperState, hmAgentECMPOspfMaxPaths=hmAgentECMPOspfMaxPaths, hmAgentRip2InterfaceSendVersion=hmAgentRip2InterfaceSendVersion, hmVrrpExtAdvertAddress=hmVrrpExtAdvertAddress, hmAgentSwitchIpRouterDiscoveryTable=hmAgentSwitchIpRouterDiscoveryTable, hmAgentSwitchIpInterfaceNetMask=hmAgentSwitchIpInterfaceNetMask, hmAgentOspfRouteRedistEntry=hmAgentOspfRouteRedistEntry, hmVrrpDomainTable=hmVrrpDomainTable, hmAgentOspfVirtIfTable=hmAgentOspfVirtIfTable, hmAgentSwitchIpRouterDiscoveryIfIndex=hmAgentSwitchIpRouterDiscoveryIfIndex, hmVrrpTrackIfIndex=hmVrrpTrackIfIndex, hmAgentSwitchIpVlanTable=hmAgentSwitchIpVlanTable, hmAgentSwitchIpGroup=hmAgentSwitchIpGroup, hmAgentSwitchIpTableSizeArp=hmAgentSwitchIpTableSizeArp, hmAgentRipRouteRedistEntry=hmAgentRipRouteRedistEntry, hmVrrpExtDomainRole=hmVrrpExtDomainRole, hmAgentOspfRouteRedistMode=hmAgentOspfRouteRedistMode, hmAgentECMPGroup=hmAgentECMPGroup)
