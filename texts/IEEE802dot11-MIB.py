#
# PySNMP MIB module IEEE802dot11-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/iee/IEEE802dot11-MIB
# Produced by pysmi-1.1.12 at Fri Jul 19 12:36:29 2024
# On host fv-az1766-821 platform Linux version 6.5.0-1023-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, ModuleIdentity, Counter64, Counter32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Bits, IpAddress, MibIdentifier, NotificationType, ObjectIdentity, Integer32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ModuleIdentity", "Counter64", "Counter32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Bits", "IpAddress", "MibIdentifier", "NotificationType", "ObjectIdentity", "Integer32", "Unsigned32")
TextualConvention, MacAddress, TruthValue, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "TruthValue", "DisplayString", "RowStatus")
member_body = MibIdentifier((1, 2)).setLabel("member-body")
us = MibIdentifier((1, 2, 840))
ieee802dot11 = ModuleIdentity((1, 2, 840, 10036))
if mibBuilder.loadTexts: ieee802dot11.setLastUpdated('0208300000Z')
if mibBuilder.loadTexts: ieee802dot11.setOrganization('IEEE 802.11')
if mibBuilder.loadTexts: ieee802dot11.setContactInfo("WG E-mail: stds-802-11@ieee.org\n\n                Chair: Stuart J. Kerry\n                Postal: Philips Semiconductors, Inc.\n                       1109 McKay Drive\n                       M/S 48 SJ\n                       San Jose, CA 95130-1706  USA\n                  Tel: +1 408 474 7356\n                  Fax: +1 408 474 7247\n               E-mail: stuart.kerry@philips.com\n\n               Editor: Bob O'Hara\n               Postal: Informed Technology, Inc.\n                       1750 Nantucket Circle, Suite 138\n                       Santa Clara, CA 95054 USA\n                  Tel: +1 408 986 9596\n                  Fax: +1 408 727 2654\n               E-mail: bob@informed-technology.com")
if mibBuilder.loadTexts: ieee802dot11.setDescription('The MIB module for IEEE 802.11 entities.\n        iso(1).member-body(2).us(840).ieee802dot11(10036)')
dot11smt = MibIdentifier((1, 2, 840, 10036, 1))
dot11mac = MibIdentifier((1, 2, 840, 10036, 2))
dot11res = MibIdentifier((1, 2, 840, 10036, 3))
dot11resAttribute = MibIdentifier((1, 2, 840, 10036, 3, 1))
dot11phy = MibIdentifier((1, 2, 840, 10036, 4))
class WEPKeytype(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(5, 5)
    fixedLength = 5

dot11StationConfigTable = MibTable((1, 2, 840, 10036, 1, 1), )
if mibBuilder.loadTexts: dot11StationConfigTable.setStatus('current')
if mibBuilder.loadTexts: dot11StationConfigTable.setDescription('Station Configuration attributes.  In tablular form to\n            allow for multiple instances on an agent.')
dot11StationConfigEntry = MibTableRow((1, 2, 840, 10036, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11StationConfigEntry.setStatus('current')
if mibBuilder.loadTexts: dot11StationConfigEntry.setDescription('An entry in the dot11StationConfigTable.  It is\n            possible for there to be multiple IEEE 802.11 interfaces\n            on one agent, each with its unique MAC address. The\n            relationship between an IEEE 802.11 interface and an\n            interface in the context of the Internet-standard MIB is\n            one-to-one.  As such, the value of an ifIndex object\n            instance can be directly used to identify corresponding\n            instances of the objects defined herein.  \n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11StationID = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 1), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11StationID.setStatus('deprecated')
if mibBuilder.loadTexts: dot11StationID.setDescription("The purpose of dot11StationID is to allow a manager to \n            identify a station for its own purposes.  This attribute\n            provides for that eventuality while keeping the true MAC\n            address independent.  Its syntax is MAC address, and the\n            default value is the station's assigned, unique \n            MAC address.")
dot11MediumOccupancyLimit = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MediumOccupancyLimit.setStatus('current')
if mibBuilder.loadTexts: dot11MediumOccupancyLimit.setDescription('This attribute shall indicate the maximum amount of time,\n            in TU, that a point coordinator (PC) may control the usage \n            of the wireless medium (WM) without relinquishing control \n            for long enough to allow at least one instance of DCF access \n            to the medium.  The default value of this attribute shall \n            be 100, and the maximum value shall be 1000.')
dot11CFPollable = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11CFPollable.setStatus('current')
if mibBuilder.loadTexts: dot11CFPollable.setDescription('When this attribute is true, it shall indicate that \n\t        the STA is able to respond to a CF-Poll with a data frame \n\t        within a SIFS time. This attribute shall be false if \n\t        the STA is not able to respond to a CF-Poll with a data \n\t        frame within a SIFS time.')
dot11CFPPeriod = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CFPPeriod.setStatus('current')
if mibBuilder.loadTexts: dot11CFPPeriod.setDescription('The attribute shall describe the number of DTIM intervals\n            between the start of CFPs.  It is modified by\n            MLME-START.request primitive.')
dot11CFPMaxDuration = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CFPMaxDuration.setStatus('current')
if mibBuilder.loadTexts: dot11CFPMaxDuration.setDescription('The attribute shall describe the maximum duration of \n\t        the CFP in TU that may be generated by the PCF. It is \n\t        modified by MLME-START.request primitive.')
dot11AuthenticationResponseTimeOut = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11AuthenticationResponseTimeOut.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationResponseTimeOut.setDescription('This attribute shall specify the number of time units (TUs)\n             that a responding STA should wait for the next frame in the\n            authentication sequence.')
dot11PrivacyOptionImplemented = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11PrivacyOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: dot11PrivacyOptionImplemented.setDescription('This attribute, when true, shall indicate that the IEEE\n            802.11 WEP option is implemented.  The default value of\n            this attribute shall be false.')
dot11PowerManagementMode = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("powersave", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11PowerManagementMode.setStatus('current')
if mibBuilder.loadTexts: dot11PowerManagementMode.setDescription('This attribute shall specify the power management\n\t\t\tmode of the STA. When set to active, it shall \n\t\t\tindicate that the station is not in power-save \n\t\t\t(PS) mode. When set to powersave, it shall indicate\n\t\t\t that the station is in power-save mode. The power \n\t\t\tmanagement mode is transmitted in all frames \n\t\t\taccording to the rules in  7.1.3.1.7.')
dot11DesiredSSID = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11DesiredSSID.setStatus('current')
if mibBuilder.loadTexts: dot11DesiredSSID.setDescription('This attribute reflects the Service Set ID (SSID)\n\t\t\tused in the DesiredSSID parameter of the most recent\n\t\t\tMLME_Scan.request.  This value may be modified\n\t\t\tby an external management entity and used by the\n\t\t\tlocal SME to make decisions about the Scanning \n\t\t\tprocess.')
dot11DesiredBSSType = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("infrastructure", 1), ("independent", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11DesiredBSSType.setStatus('current')
if mibBuilder.loadTexts: dot11DesiredBSSType.setDescription('This attribute shall specify the type of BSS the\n\t\t\tstation shall use when scanning for a BSS with \n\t\t\twhich to synchronize. This value is used to filter \n\t\t\tProbe Response frames and Beacons. When set to \n\t\t\tinfrastructure, the station shall only synchronize \n\t\t\twith a BSS whose Capability Information field has \n\t\t\tthe ESS subfield set to 1. When set to independent, \n\t\t\tthe station shall only synchronize with a BSS whose \n\t\t\tCapability Information field has the IBSS subfield \n\t\t\tset to 1. When set to any, the station may \n\t\t\tsynchronize to either type of BSS.')
dot11OperationalRateSet = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11OperationalRateSet.setStatus('current')
if mibBuilder.loadTexts: dot11OperationalRateSet.setDescription('This attribute shall specify the set of data \n\t\t\trates at which the station may transmit data.  \n\t\t\tEach octet contains a value representing a rate.  \n\t\t\tEach rate shall be within the range from 2 to 127,\n\t\t\tcorresponding to data rates in increments of\n\t\t\t500 kbit/s from 1 Mbit/s to 63.5 Mbit/s, and shall \n\t\t\tbe supported (as indicated in the supported rates\n\t\t\ttable) for receiving data. This value is reported in\n\t\t\ttransmitted Beacon, Probe Request, Probe Response,\n\t\t\tAssociation Request, Association Response,\n\t\t\tReassociation Request, and Reassociation Response\n\t\t\tframes, and is used to determine whether a BSS\n\t\t\twith which the station desires to synchronize is\n\t\t\tsuitable. It is also used when starting a BSS,\n\t\t\tas specified in  10.3.')
dot11BeaconPeriod = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11BeaconPeriod.setStatus('current')
if mibBuilder.loadTexts: dot11BeaconPeriod.setDescription('This attribute shall specify the number of TUs that \n\t\t\ta station shall use for scheduling Beacon \n\t\t\ttransmissions. This value is transmitted in Beacon \n\t\t\tand Probe Response frames.')
dot11DTIMPeriod = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11DTIMPeriod.setStatus('current')
if mibBuilder.loadTexts: dot11DTIMPeriod.setDescription('This attribute shall specify the number of beacon\n\t\t\tintervals that shall elapse between transmission of\n\t\t\tBeacons frames containing a TIM element whose DTIM\n\t\t\tCount field is 0. This value is transmitted in\n\t\t\tthe DTIM Period field of Beacon frames.')
dot11AssociationResponseTimeOut = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11AssociationResponseTimeOut.setStatus('current')
if mibBuilder.loadTexts: dot11AssociationResponseTimeOut.setDescription('This attribute shall specify the number of TU that a\n\t\t\trequesting STA should wait for a response to a\n\t\t\ttransmitted association-request MMPDU.')
dot11DisassociateReason = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11DisassociateReason.setReference('IEEE Std 802.11-2002, 7.3.1.7')
if mibBuilder.loadTexts: dot11DisassociateReason.setStatus('current')
if mibBuilder.loadTexts: dot11DisassociateReason.setDescription('This attribute holds the most recently\n\t\t\ttransmitted Reason Code in a Disassociation\n\t\t\tframe.  If no Disassociation frame has been\n\t\t\ttransmitted, the value of this attribute shall\n\t\t\tbe 0.')
dot11DisassociateStation = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 16), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11DisassociateStation.setStatus('current')
if mibBuilder.loadTexts: dot11DisassociateStation.setDescription('This attribute holds the MAC address from the\n\t\t\tAddress 1 field of the most recently transmitted\n\t\t\tDisassociation frame.  If no Disassociation\n\t\t\tframe has been transmitted, the value of this\n\t\t\tattribute shall be 0.')
dot11DeauthenticateReason = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11DeauthenticateReason.setReference('IEEE Std 802.11-2002, 7.3.1.7')
if mibBuilder.loadTexts: dot11DeauthenticateReason.setStatus('current')
if mibBuilder.loadTexts: dot11DeauthenticateReason.setDescription('This attribute holds the most recently\n\t\t\ttransmitted Reason Code in a Deauthentication\n\t\t\tframe.  If no Deauthentication frame has been\n\t\t\ttransmitted, the value of this attribute shall\n\t\t\tbe 0.')
dot11DeauthenticateStation = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11DeauthenticateStation.setStatus('current')
if mibBuilder.loadTexts: dot11DeauthenticateStation.setDescription('This attribute holds the MAC address from the\n\t\t\tAddress 1 field of the most recently transmitted\n\t\t\tDeauthentication frame.  If no Deauthentication\n\t\t\tframe has been transmitted, the value of this\n\t\t\tattribute shall be 0.')
dot11AuthenticateFailStatus = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11AuthenticateFailStatus.setReference('IEEE Std 802.11-2002, 7.3.1.9')
if mibBuilder.loadTexts: dot11AuthenticateFailStatus.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticateFailStatus.setDescription('This attribute holds the most recently\n\t\t\ttransmitted Status Code in a failed\n\t\t\tAuthentication frame.  If no failed\n\t\t\tAuthentication frame has been transmitted, the\n\t\t\tvalue of this attribute shall be 0.')
dot11AuthenticateFailStation = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 20), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11AuthenticateFailStation.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticateFailStation.setDescription('This attribute holds the MAC address from the\n\t\t\tAddress 1 field of the most recently transmitted\n\t\t\tfailed Authentication frame.  If no failed\n\t\t\tAuthentication frame has been transmitted, the\n\t\t\tvalue of this attribute shall be 0.')
dot11MultiDomainCapabilityImplemented = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MultiDomainCapabilityImplemented.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityImplemented.setDescription('This attribute, when TRUE, indicates that the \n\t\t\tstation implementation is capable of supporting \n\t\t\tmultiple regulatory domains.  The capability is \n\t\t\tdisabled, otherwise.  The default value of this \n\t\t\tattribute is FALSE.')
dot11MultiDomainCapabilityEnabled = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MultiDomainCapabilityEnabled.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityEnabled.setDescription('This attribute, when TRUE, indicates that the \n\t\t\tcapability of the station to operate in multiple \n\t\t\tregulatory domains is enabled.  The capability is \n\t\t\tdisabled, otherwise.  The default value of this \n\t\t\tattribute is FALSE.')
dot11CountryString = MibTableColumn((1, 2, 840, 10036, 1, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11CountryString.setStatus('current')
if mibBuilder.loadTexts: dot11CountryString.setDescription("This attribute identifies the country in which the \n\t\t\tstation is operating. The first two octets of this \n\t\t\tstring is the two character country code as described \n\t\t\tin document ISO/IEC 3166-1.  The third octet shall \n\t\t\tbe one of the following:\n\n\t\t\t1. an ASCII space character, if the regulations under \n\t\t\twhich the station is operating encompass all \n\t\t\tenvironments in the country,\n\n\t\t\t2. an ASCII 'O' character, if the regulations under \n\t\t\twhich the station is operating are for an Outdoor \n\t\t\tenvironment only, or\n\n\t\t\t3. an ASCII 'I' character, if the regulations under \n\t\t\twhich the station is operating are for an Indoor \n\t\t\tenvironment only.")
dot11AuthenticationAlgorithmsTable = MibTable((1, 2, 840, 10036, 1, 2), )
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsTable.setReference('IEEE Std 802.11-2002, 7.3.1.1')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsTable.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsTable.setDescription('This (conceptual) table of attributes shall be a set of\n            all the authentication algorithms supported by the\n            stations.  The following are the default values and the\n            associated algorithm:\n                Value = 1: Open System\n                Value = 2: Shared Key')
dot11AuthenticationAlgorithmsEntry = MibTableRow((1, 2, 840, 10036, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11AuthenticationAlgorithmsIndex"))
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsEntry.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsEntry.setDescription('An Entry (conceptual row) in the Authentication\n            Algorithms Table.  \n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11AuthenticationAlgorithmsIndex = MibTableColumn((1, 2, 840, 10036, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsIndex.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the Authentication Algorithms Table.')
dot11AuthenticationAlgorithm = MibTableColumn((1, 2, 840, 10036, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("openSystem", 1), ("sharedKey", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11AuthenticationAlgorithm.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithm.setDescription('This attribute shall be a set of all the authentication\n\t        algorithms supported by the STAs. The following are the\n\t        default values and the associated algorithm.  \n\t\t        Value = 1: Open System \n\t\t        Value = 2: Shared Key')
dot11AuthenticationAlgorithmsEnable = MibTableColumn((1, 2, 840, 10036, 1, 2, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsEnable.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticationAlgorithmsEnable.setDescription('This attribute, when true at a station, shall enable the acceptance \n\t        of the authentication algorithm described in the corresponding table \n\t        entry in authentication frames received by the station that have odd \n\t        authentication sequence numbers.  The default value of this attribute \n\t        shall be 1 for the Open System table entry and 2 for all other table \n\t        entries.')
dot11WEPDefaultKeysTable = MibTable((1, 2, 840, 10036, 1, 3), )
if mibBuilder.loadTexts: dot11WEPDefaultKeysTable.setReference('IEEE Std 802.11-2002, 8.3.2')
if mibBuilder.loadTexts: dot11WEPDefaultKeysTable.setStatus('current')
if mibBuilder.loadTexts: dot11WEPDefaultKeysTable.setDescription('Conceptual table for WEP default keys.  This table shall\n            contain the four WEP default secret key values\n            corresponding to the four possible KeyID values.  The WEP\n            default secret keys are logically WRITE-ONLY.  Attempts to\n            read the entries in this table shall return unsuccessful\n            status and values of null or zero.  The default value of\n            each WEP default key shall be null.')
dot11WEPDefaultKeysEntry = MibTableRow((1, 2, 840, 10036, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11WEPDefaultKeyIndex"))
if mibBuilder.loadTexts: dot11WEPDefaultKeysEntry.setStatus('current')
if mibBuilder.loadTexts: dot11WEPDefaultKeysEntry.setDescription('An Entry (conceptual row) in the WEP Default Keys Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11WEPDefaultKeyIndex = MibTableColumn((1, 2, 840, 10036, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: dot11WEPDefaultKeyIndex.setStatus('current')
if mibBuilder.loadTexts: dot11WEPDefaultKeyIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the WEP Default Keys Table.\n           The value of this variable is equal to the WEPDefaultKeyID + 1')
dot11WEPDefaultKeyValue = MibTableColumn((1, 2, 840, 10036, 1, 3, 1, 2), WEPKeytype()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11WEPDefaultKeyValue.setStatus('current')
if mibBuilder.loadTexts: dot11WEPDefaultKeyValue.setDescription('A WEP default secret key value.')
dot11WEPKeyMappingsTable = MibTable((1, 2, 840, 10036, 1, 4), )
if mibBuilder.loadTexts: dot11WEPKeyMappingsTable.setReference('IEEE Std 802.11-2002, 8.3.2')
if mibBuilder.loadTexts: dot11WEPKeyMappingsTable.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingsTable.setDescription('Conceptual table for WEP Key Mappings.  The MIB supports\n            the ability to share a separate WEP key for each RA/TA\n            pair.  The Key Mappings Table contains zero or one entry\n            for each MAC address and contains two fields for each\n            entry: WEPOn and the corresponding WEP key.  The WEP key\n            mappings are logically WRITE-ONLY.  Attempts to read the\n            entries in this table shall return unsuccessful status and\n            values of null or zero.  The default value for all WEPOn\n            fields is false.')
dot11WEPKeyMappingsEntry = MibTableRow((1, 2, 840, 10036, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11WEPKeyMappingIndex"))
if mibBuilder.loadTexts: dot11WEPKeyMappingsEntry.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingsEntry.setDescription('An Entry (conceptual row) in the WEP Key Mappings Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11WEPKeyMappingIndex = MibTableColumn((1, 2, 840, 10036, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11WEPKeyMappingIndex.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the WEP Key Mappings Table.')
dot11WEPKeyMappingAddress = MibTableColumn((1, 2, 840, 10036, 1, 4, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11WEPKeyMappingAddress.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingAddress.setDescription('The MAC address of the STA for which the values from this\n            key mapping entry are to be used.')
dot11WEPKeyMappingWEPOn = MibTableColumn((1, 2, 840, 10036, 1, 4, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11WEPKeyMappingWEPOn.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingWEPOn.setDescription('Boolean as to whether WEP is to be used when communicating\n            with the dot11WEPKeyMappingAddress STA.')
dot11WEPKeyMappingValue = MibTableColumn((1, 2, 840, 10036, 1, 4, 1, 4), WEPKeytype()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11WEPKeyMappingValue.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingValue.setDescription('A WEP secret key value.')
dot11WEPKeyMappingStatus = MibTableColumn((1, 2, 840, 10036, 1, 4, 1, 5), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11WEPKeyMappingStatus.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingStatus.setDescription('The status column used for creating, modifying, and\n            deleting instances of the columnar objects in the WEP key\n            mapping Table.')
dot11PrivacyTable = MibTable((1, 2, 840, 10036, 1, 5), )
if mibBuilder.loadTexts: dot11PrivacyTable.setStatus('current')
if mibBuilder.loadTexts: dot11PrivacyTable.setDescription('Group containing attributes concerned with IEEE 802.11\n            Privacy.  Created as a table to allow multiple\n            instantiations on an agent.')
dot11PrivacyEntry = MibTableRow((1, 2, 840, 10036, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PrivacyEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PrivacyEntry.setDescription('An entry in the dot11PrivacyTable Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11PrivacyInvoked = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11PrivacyInvoked.setStatus('current')
if mibBuilder.loadTexts: dot11PrivacyInvoked.setDescription('When this attribute is true, it shall indicate that the IEEE\n\t        802.11 WEP mechanism is used for transmitting frames of type\n\t        Data. The default value of this attribute shall be false.')
dot11WEPDefaultKeyID = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11WEPDefaultKeyID.setReference('IEEE Std 802.11-2002, 8.3.2')
if mibBuilder.loadTexts: dot11WEPDefaultKeyID.setStatus('current')
if mibBuilder.loadTexts: dot11WEPDefaultKeyID.setDescription('This attribute shall indicate the use of the first,\n            second, third, or fourth element of the WEPDefaultKeys\n            array when set to values of zero, one, two, or three.  The\n            default value of this attribute shall be 0.')
dot11WEPKeyMappingLength = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11WEPKeyMappingLength.setReference('IEEE Std 802.11-2002, 8.3.2')
if mibBuilder.loadTexts: dot11WEPKeyMappingLength.setStatus('current')
if mibBuilder.loadTexts: dot11WEPKeyMappingLength.setDescription('The maximum number of tuples that dot11WEPKeyMappings can hold.')
dot11ExcludeUnencrypted = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11ExcludeUnencrypted.setStatus('current')
if mibBuilder.loadTexts: dot11ExcludeUnencrypted.setDescription('When this attribute is true, the STA shall not indicate at\n\t        the MAC service interface received MSDUs that have the WEP\n\t        subfield of the Frame Control field equal to zero. When this\n\t        attribute is false, the STA may accept MSDUs that have the WEP\n\t        subfield of the Frame Control field equal to zero. The default\n\t        value of this attribute shall be false.')
dot11WEPICVErrorCount = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11WEPICVErrorCount.setStatus('current')
if mibBuilder.loadTexts: dot11WEPICVErrorCount.setDescription('This counter shall increment when a frame is received with the\n            WEP subfield of the Frame Control field set to one and the value\n            of the ICV as received in the frame does not match the ICV value\n            that is calculated for the contents of the received frame.')
dot11WEPExcludedCount = MibTableColumn((1, 2, 840, 10036, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11WEPExcludedCount.setStatus('current')
if mibBuilder.loadTexts: dot11WEPExcludedCount.setDescription('This counter shall increment when a frame is received with the\n            WEP subfield of the Frame Control field set to zero and the value\n            of dot11ExcludeUnencrypted causes that frame to be discarded.')
dot11SMTnotification = MibIdentifier((1, 2, 840, 10036, 1, 6))
dot11Disassociate = NotificationType((1, 2, 840, 10036, 1, 6, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("IEEE802dot11-MIB", "dot11DisassociateReason"), ("IEEE802dot11-MIB", "dot11DisassociateStation"))
if mibBuilder.loadTexts: dot11Disassociate.setStatus('current')
if mibBuilder.loadTexts: dot11Disassociate.setDescription('The disassociate notification shall be sent when the STA\n\t        sends a Disassociation frame. The value of the notification\n\t        shall include the MAC address of the MAC to which the Disassociation\n\t        frame was sent and the reason for the disassociation.\n\n  \t        ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11Deauthenticate = NotificationType((1, 2, 840, 10036, 1, 6, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("IEEE802dot11-MIB", "dot11DeauthenticateReason"), ("IEEE802dot11-MIB", "dot11DeauthenticateStation"))
if mibBuilder.loadTexts: dot11Deauthenticate.setStatus('current')
if mibBuilder.loadTexts: dot11Deauthenticate.setDescription('The deauthenticate notification shall be sent when the STA\n\t        sends a Deauthentication frame. The value of the notification\n\t        shall include the MAC address of the MAC to which the Deauthentication\n\t        frame was sent and the reason for the deauthentication.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11AuthenticateFail = NotificationType((1, 2, 840, 10036, 1, 6, 0, 3)).setObjects(("IF-MIB", "ifIndex"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStatus"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStation"))
if mibBuilder.loadTexts: dot11AuthenticateFail.setStatus('current')
if mibBuilder.loadTexts: dot11AuthenticateFail.setDescription("The authenticate failure notification shall be sent when the STA\n\t        sends an Authentication frame with a status code other than \n\t        'successful'. The value of the notification\n\t        shall include the MAC address of the MAC to which the Authentication\n\t        frame was sent and the reason for the authentication failure.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.")
dot11MultiDomainCapabilityTable = MibTable((1, 2, 840, 10036, 1, 7), )
if mibBuilder.loadTexts: dot11MultiDomainCapabilityTable.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityTable.setDescription('This (conceptual) table of attributes for \n\t\t\tcross-domain mobility.')
dot11MultiDomainCapabilityEntry = MibTableRow((1, 2, 840, 10036, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11MultiDomainCapabilityIndex"))
if mibBuilder.loadTexts: dot11MultiDomainCapabilityEntry.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityEntry.setDescription('An entry (conceptual row) in the Multiple Domain \n                        Capability Table.\n\n\t\t\tIfIndex - Each IEEE 802.11 interface is represented \n\t\t\tby an ifEntry. Interface tables in this MIB are \n\t\t\tindexed by ifIndex.')
dot11MultiDomainCapabilityIndex = MibTableColumn((1, 2, 840, 10036, 1, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11MultiDomainCapabilityIndex.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityIndex.setDescription('The auxiliary variable used to identify instances of \n\t\t\tthe columnar objects in the Multi Domain Capability Table.')
dot11FirstChannelNumber = MibTableColumn((1, 2, 840, 10036, 1, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11FirstChannelNumber.setStatus('current')
if mibBuilder.loadTexts: dot11FirstChannelNumber.setDescription('This attribute shall indicate the value of the lowest \n\t\t\tchannel number in the subband for the associated domain \n\t\t\tcountry string. The default value of this attribute \n\t\t\tshall be zero.')
dot11NumberofChannels = MibTableColumn((1, 2, 840, 10036, 1, 7, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11NumberofChannels.setStatus('current')
if mibBuilder.loadTexts: dot11NumberofChannels.setDescription('This attribute shall indicate the value of the total \n\t\t\tnumber of channels allowed in the subband for the \n\t\t\tassociated domain country string. The default value of \n\t\t\tthis attribute shall be zero.')
dot11MaximumTransmitPowerLevel = MibTableColumn((1, 2, 840, 10036, 1, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MaximumTransmitPowerLevel.setStatus('current')
if mibBuilder.loadTexts: dot11MaximumTransmitPowerLevel.setDescription('This attribute shall indicate the maximum transmit power, \n\t\t\tin dBm, allowed in the subband for the associated domain \n\t\t\tcountry string. The default value of this attribute shall \n\t\t\tbe zero.')
dot11OperationTable = MibTable((1, 2, 840, 10036, 2, 1), )
if mibBuilder.loadTexts: dot11OperationTable.setStatus('current')
if mibBuilder.loadTexts: dot11OperationTable.setDescription('Group contains MAC attributes pertaining to the operation\n            of the MAC.  This has been implemented as a table in order\n            to allow for multiple instantiations on an agent.')
dot11OperationEntry = MibTableRow((1, 2, 840, 10036, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11OperationEntry.setStatus('current')
if mibBuilder.loadTexts: dot11OperationEntry.setDescription('An entry in the dot11OperationEntry Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11MACAddress = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11MACAddress.setStatus('current')
if mibBuilder.loadTexts: dot11MACAddress.setDescription('Unique MAC Address assigned to the STA.')
dot11RTSThreshold = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2347))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11RTSThreshold.setStatus('current')
if mibBuilder.loadTexts: dot11RTSThreshold.setDescription('This attribute shall indicate the number of octets in an MPDU,\n\t        below which an RTS/CTS handshake shall not be performed. An\n\t        RTS/CTS handshake shall be performed at the beginning of any\n\t        frame exchange sequence where the MPDU is of type Data or\n\t        Management, the MPDU has an individual address in the Address1\n\t        field, and the length of the MPDU is greater than\n\t        this threshold. (For additional details, refer to Table 21 in\n\t        9.7.) Setting this attribute to be larger than the maximum\n\t        MSDU size shall have the effect of turning off the RTS/CTS\n\t        handshake for frames of Data or Management type transmitted by\n\t        this STA. Setting this attribute to zero shall have the effect\n\t        of turning on the RTS/CTS handshake for all frames of Data or\n\t        Management type transmitted by this STA. The default value of\n\t        this attribute shall be 2347.')
dot11ShortRetryLimit = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11ShortRetryLimit.setStatus('current')
if mibBuilder.loadTexts: dot11ShortRetryLimit.setDescription('This attribute shall indicate the maximum number of\n\t        transmission attempts of a frame, the length of which is less\n\t        than or equal to dot11RTSThreshold, that shall be made before a\n\t        failure condition is indicated. The default value of this\n\t        attribute shall be 7.')
dot11LongRetryLimit = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11LongRetryLimit.setStatus('current')
if mibBuilder.loadTexts: dot11LongRetryLimit.setDescription('This attribute shall indicate the maximum number of\n\t        transmission attempts of a frame, the length of which is\n\t        greater than dot11RTSThreshold, that shall be made before a\n\t        failure condition is indicated. The default value of this\n\t        attribute shall be 4.')
dot11FragmentationThreshold = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 2346))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11FragmentationThreshold.setStatus('current')
if mibBuilder.loadTexts: dot11FragmentationThreshold.setDescription('This attribute shall specify the current maximum size, in\n\t        octets, of the MPDU that may be delivered to the PHY. An MSDU\n\t        shall be broken into fragments if its size exceeds the value\n\t        of this attribute after adding MAC headers and trailers. An MSDU\n\t        or MMPDU shall be fragmented when the resulting frame has an\n\t        individual address in the Address1 field, and the length of the\n\t        frame is larger than this threshold. The default value for this\n\t        attribute shall be the lesser of 2346 or the aMPDUMaxLength of\n\t        the attached PHY and shall never exceed the lesser of 2346 or\n\t        the  aMPDUMaxLength of the attached PHY. The value of this\n\t        attribute shall never be less than 256. ')
dot11MaxTransmitMSDULifetime = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MaxTransmitMSDULifetime.setStatus('current')
if mibBuilder.loadTexts: dot11MaxTransmitMSDULifetime.setDescription('The MaxTransmitMSDULifetime shall be the elapsed time in TU,\n\t        after the initial transmission of an MSDU, after which further\n\t        attempts to transmit the MSDU shall be terminated. The default\n\t        value of this attribute shall be 512.')
dot11MaxReceiveLifetime = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11MaxReceiveLifetime.setStatus('current')
if mibBuilder.loadTexts: dot11MaxReceiveLifetime.setDescription('The MaxReceiveLifetime shall be the elapsed time in TU,\n            after the initial reception of a fragmented MMPDU or MSDU,\n            after which further attempts to reassemble the MMPDU or\n            MSDU shall be terminated. The default value shall be\n            512.')
dot11ManufacturerID = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ManufacturerID.setStatus('current')
if mibBuilder.loadTexts: dot11ManufacturerID.setDescription("The ManufacturerID shall include, at a minimum, the name\n            of the manufacturer.  It may include additional\n            information at the manufacturer's discretion.  The default\n            value of this attribute shall be null.")
dot11ProductID = MibTableColumn((1, 2, 840, 10036, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ProductID.setStatus('current')
if mibBuilder.loadTexts: dot11ProductID.setDescription("The ProductID shall include, at a minimum, an identifier\n            that is unique to the manufacturer.  It may include\n            additional information at the manufacturer's discretion.\n            The default value of this attribute shall be null.")
dot11CountersTable = MibTable((1, 2, 840, 10036, 2, 2), )
if mibBuilder.loadTexts: dot11CountersTable.setStatus('current')
if mibBuilder.loadTexts: dot11CountersTable.setDescription('Group containing attributes that are MAC counters.\n            Implemented as a table to allow for multiple\n            instantiations on an agent.')
dot11CountersEntry = MibTableRow((1, 2, 840, 10036, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11CountersEntry.setStatus('current')
if mibBuilder.loadTexts: dot11CountersEntry.setDescription('An entry in the dot11CountersEntry Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11TransmittedFragmentCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TransmittedFragmentCount.setStatus('current')
if mibBuilder.loadTexts: dot11TransmittedFragmentCount.setDescription('This counter shall be incremented for an acknowledged MPDU\n            with an individual address in the address 1 field or an MPDU\n            with a multicast address in the address 1 field of type Data\n            or Management.')
dot11MulticastTransmittedFrameCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11MulticastTransmittedFrameCount.setStatus('current')
if mibBuilder.loadTexts: dot11MulticastTransmittedFrameCount.setDescription('This counter shall increment only when the multicast bit\n            is set in the destination MAC address of a successfully\n            transmitted MSDU.  When operating as a STA in an ESS, where\n            these frames are directed to the AP, this implies having\n            received an acknowledgment to all associated MPDUs.')
dot11FailedCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11FailedCount.setStatus('current')
if mibBuilder.loadTexts: dot11FailedCount.setDescription('This counter shall increment when an MSDU is not transmitted\n\t        successfully due to the number of transmit attempts exceeding\n\t        either the  dot11ShortRetryLimit or dot11LongRetryLimit.')
dot11RetryCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11RetryCount.setStatus('current')
if mibBuilder.loadTexts: dot11RetryCount.setDescription('This counter shall increment when an MSDU is successfully\n            transmitted after one or more retransmissions.')
dot11MultipleRetryCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11MultipleRetryCount.setStatus('current')
if mibBuilder.loadTexts: dot11MultipleRetryCount.setDescription('This counter shall increment when an MSDU is successfully\n            transmitted after more than one retransmission.')
dot11FrameDuplicateCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11FrameDuplicateCount.setStatus('current')
if mibBuilder.loadTexts: dot11FrameDuplicateCount.setDescription('This counter shall increment when a frame is received\n            that the Sequence Control field indicates is a\n            duplicate.')
dot11RTSSuccessCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11RTSSuccessCount.setStatus('current')
if mibBuilder.loadTexts: dot11RTSSuccessCount.setDescription('This counter shall increment when a CTS is received in\n            response to an RTS.')
dot11RTSFailureCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11RTSFailureCount.setStatus('current')
if mibBuilder.loadTexts: dot11RTSFailureCount.setDescription('This counter shall increment when a CTS is not received in\n\t        response to an RTS.')
dot11ACKFailureCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ACKFailureCount.setStatus('current')
if mibBuilder.loadTexts: dot11ACKFailureCount.setDescription('This counter shall increment when an ACK is not received\n            when expected.')
dot11ReceivedFragmentCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ReceivedFragmentCount.setStatus('current')
if mibBuilder.loadTexts: dot11ReceivedFragmentCount.setDescription('This counter shall be incremented for each successfully\n            received MPDU of type Data or Management.')
dot11MulticastReceivedFrameCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11MulticastReceivedFrameCount.setStatus('current')
if mibBuilder.loadTexts: dot11MulticastReceivedFrameCount.setDescription('This counter shall increment when a MSDU is received\n            with the multicast bit set in the destination\n            MAC address.')
dot11FCSErrorCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11FCSErrorCount.setStatus('current')
if mibBuilder.loadTexts: dot11FCSErrorCount.setDescription('This counter shall increment when an FCS error is\n            detected in a received MPDU.')
dot11TransmittedFrameCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TransmittedFrameCount.setStatus('current')
if mibBuilder.loadTexts: dot11TransmittedFrameCount.setDescription('This counter shall increment for each successfully transmitted MSDU.')
dot11WEPUndecryptableCount = MibTableColumn((1, 2, 840, 10036, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11WEPUndecryptableCount.setStatus('current')
if mibBuilder.loadTexts: dot11WEPUndecryptableCount.setDescription("This counter shall increment when a frame is received with\n\t        the WEP subfield of the Frame Control field set to one and the\n\t        WEPOn value for the key mapped to the TA's MAC address\n\t        indicates that the frame should not have been encrypted or\n\t        that frame is discarded due to the receiving STA not\n\t        implementing the privacy option.")
dot11GroupAddressesTable = MibTable((1, 2, 840, 10036, 2, 3), )
if mibBuilder.loadTexts: dot11GroupAddressesTable.setStatus('current')
if mibBuilder.loadTexts: dot11GroupAddressesTable.setDescription('A conceptual table containing a set of MAC addresses\n            identifying the multicast addresses for which this STA\n            will receive frames.  The default value of this attribute\n            shall be null.')
dot11GroupAddressesEntry = MibTableRow((1, 2, 840, 10036, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11GroupAddressesIndex"))
if mibBuilder.loadTexts: dot11GroupAddressesEntry.setStatus('current')
if mibBuilder.loadTexts: dot11GroupAddressesEntry.setDescription('An Entry (conceptual row) in the Group Addresses Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11GroupAddressesIndex = MibTableColumn((1, 2, 840, 10036, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11GroupAddressesIndex.setStatus('current')
if mibBuilder.loadTexts: dot11GroupAddressesIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the Group Addresses Table.')
dot11Address = MibTableColumn((1, 2, 840, 10036, 2, 3, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11Address.setStatus('current')
if mibBuilder.loadTexts: dot11Address.setDescription('MAC address identifying a multicast addresses\n            from which this STA will receive frames.')
dot11GroupAddressesStatus = MibTableColumn((1, 2, 840, 10036, 2, 3, 1, 3), RowStatus().clone('active')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot11GroupAddressesStatus.setStatus('current')
if mibBuilder.loadTexts: dot11GroupAddressesStatus.setDescription('The status column used for creating, modifying, and\n            deleting instances of the columnar objects in the Group\n            Addresses Table.')
dot11ResourceTypeIDName = MibScalar((1, 2, 840, 10036, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone('RTID')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ResourceTypeIDName.setReference('IEEE Std 802.1F-1993,  A.7')
if mibBuilder.loadTexts: dot11ResourceTypeIDName.setStatus('current')
if mibBuilder.loadTexts: dot11ResourceTypeIDName.setDescription('Contains the name of the Resource Type ID managed object.\n            The attribute is read-only and always contains the value\n            RTID.  This attribute value shall not be used as a naming\n            attribute for any other managed object class.')
dot11ResourceInfoTable = MibTable((1, 2, 840, 10036, 3, 1, 2), )
if mibBuilder.loadTexts: dot11ResourceInfoTable.setReference('IEEE Std 802.1F-1993,  A.7')
if mibBuilder.loadTexts: dot11ResourceInfoTable.setStatus('current')
if mibBuilder.loadTexts: dot11ResourceInfoTable.setDescription('Provides a means of indicating, in data readable from a\n            managed object, information that identifies the source of\n            the implementation.')
dot11ResourceInfoEntry = MibTableRow((1, 2, 840, 10036, 3, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11ResourceInfoEntry.setStatus('current')
if mibBuilder.loadTexts: dot11ResourceInfoEntry.setDescription('An entry in the dot11ResourceInfo Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11manufacturerOUI = MibTableColumn((1, 2, 840, 10036, 3, 1, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11manufacturerOUI.setStatus('current')
if mibBuilder.loadTexts: dot11manufacturerOUI.setDescription('Takes the value of an organizationally unique identifier.')
dot11manufacturerName = MibTableColumn((1, 2, 840, 10036, 3, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11manufacturerName.setStatus('current')
if mibBuilder.loadTexts: dot11manufacturerName.setDescription('A printable string used to identify the manufacturer of the\n            resource.  Maximum string length is 128 octets.')
dot11manufacturerProductName = MibTableColumn((1, 2, 840, 10036, 3, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11manufacturerProductName.setStatus('current')
if mibBuilder.loadTexts: dot11manufacturerProductName.setDescription("A printable string used to identify the manufacturer's product\n            name of the resource.  Maximum string length is 128 octets.")
dot11manufacturerProductVersion = MibTableColumn((1, 2, 840, 10036, 3, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11manufacturerProductVersion.setStatus('current')
if mibBuilder.loadTexts: dot11manufacturerProductVersion.setDescription("Printable string used to identify the manufacturer's product\n            version of the resource.  Maximum string length is 128 octets.")
dot11PhyOperationTable = MibTable((1, 2, 840, 10036, 4, 1), )
if mibBuilder.loadTexts: dot11PhyOperationTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOperationTable.setDescription('PHY level attributes concerned with\n\t        operation.  Implemented as a table indexed on\n\n\t        ifIndex to allow for multiple instantiations on an\n\t        Agent.')
dot11PhyOperationEntry = MibTableRow((1, 2, 840, 10036, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyOperationEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOperationEntry.setDescription('An entry in the dot11PhyOperation Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11PHYType = MibTableColumn((1, 2, 840, 10036, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("fhss", 1), ("dsss", 2), ("irbaseband", 3), ("ofdm", 4), ("hrdsss", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11PHYType.setStatus('current')
if mibBuilder.loadTexts: dot11PHYType.setDescription('This is an 8-bit integer value that identifies the PHY type\n\t        supported by the attached PLCP and PMD. Currently defined\n\t        values and their corresponding PHY types are:\n\t\n\t        FHSS 2.4 GHz = 01 , DSSS 2.4 GHz = 02, IR Baseband = 03,\n\t\t\tOFDM 5GHz = 04, HRDSSS = 05')
dot11CurrentRegDomain = MibTableColumn((1, 2, 840, 10036, 4, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentRegDomain.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentRegDomain.setDescription('The current regulatory domain this instance of the PMD is\n            supporting.  This object corresponds to one of the\n            RegDomains listed in dot11RegDomainsSupported.')
dot11TempType = MibTableColumn((1, 2, 840, 10036, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tempType1", 1), ("tempType2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TempType.setStatus('current')
if mibBuilder.loadTexts: dot11TempType.setDescription("There are different operating temperature requirements\n\t        dependent on the anticipated environmental conditions. This\n\t        attribute describes the current PHY's operating temperature\n\t        range capability. Currently defined values and their\n\t        corresponding temperature ranges are:\n\n\t        Type 1 = X'01'-Commercial range of 0 to 40 degrees C,\n\n\t        Type 2 = X'02'-Industrial range of -30 to 70 degrees C.")
dot11PhyAntennaTable = MibTable((1, 2, 840, 10036, 4, 2), )
if mibBuilder.loadTexts: dot11PhyAntennaTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyAntennaTable.setDescription('Group of attributes for PhyAntenna.  Implemented as a\n            table indexed on ifIndex to allow for multiple instances on\n            an agent.')
dot11PhyAntennaEntry = MibTableRow((1, 2, 840, 10036, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyAntennaEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyAntennaEntry.setDescription('An entry in the dot11PhyAntenna Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11CurrentTxAntenna = MibTableColumn((1, 2, 840, 10036, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentTxAntenna.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentTxAntenna.setDescription('The current antenna being used to transmit.  This value\n\t        is one of the values appearing in dot11SupportedTxAntenna. This \n\t        may be used by a management agent to control which antenna is \n\t        used for transmission. ')
dot11DiversitySupport = MibTableColumn((1, 2, 840, 10036, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fixedlist", 1), ("notsupported", 2), ("dynamic", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11DiversitySupport.setStatus('current')
if mibBuilder.loadTexts: dot11DiversitySupport.setDescription("This implementation's support for diversity, encoded as:\n\n\t        X'01'-diversity is available and is performed over the fixed\n\t            list of antennas defined in dot11DiversitySelectionRx.\n\n\t        X'02'-diversity is not supported.\n\n\t        X'03'-diversity is supported and control of diversity is also\n\t            available, in which case the attribute \n\t            dot11DiversitySelectionRx can be dynamically modified by the\n\t            LME.")
dot11CurrentRxAntenna = MibTableColumn((1, 2, 840, 10036, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentRxAntenna.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentRxAntenna.setDescription('The current antenna being used to receive, if the dot11 \n\t\t\tDiversitySupport indicates that diversity is not supported.  \n\t\t\tThe selected antenna shall be one of the antennae marked \n\t\t\tfor receive in the dot11AntennasListTable.')
dot11PhyTxPowerTable = MibTable((1, 2, 840, 10036, 4, 3), )
if mibBuilder.loadTexts: dot11PhyTxPowerTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyTxPowerTable.setDescription('Group of attributes for dot11PhyTxPowerTable.  Implemented\n            as a table indexed on STA ID to allow for multiple\n            instances on an Agent.')
dot11PhyTxPowerEntry = MibTableRow((1, 2, 840, 10036, 4, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyTxPowerEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyTxPowerEntry.setDescription('An entry in the dot11PhyTxPower Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11NumberSupportedPowerLevels = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11NumberSupportedPowerLevels.setStatus('current')
if mibBuilder.loadTexts: dot11NumberSupportedPowerLevels.setDescription('The number of power levels supported by the PMD.\n            This attribute can have a value of 1 to 8.')
dot11TxPowerLevel1 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel1.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel1.setDescription('The transmit output power for LEVEL1 in mW.\n            This is also the default power level.')
dot11TxPowerLevel2 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel2.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel2.setDescription('The transmit output power for LEVEL2 in mW.')
dot11TxPowerLevel3 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel3.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel3.setDescription('The transmit output power for LEVEL3 in mW.')
dot11TxPowerLevel4 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel4.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel4.setDescription('The transmit output power for LEVEL4 in mW.')
dot11TxPowerLevel5 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel5.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel5.setDescription('The transmit output power for LEVEL5 in mW.')
dot11TxPowerLevel6 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel6.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel6.setDescription('The transmit output power for LEVEL6 in mW.')
dot11TxPowerLevel7 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel7.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel7.setDescription('The transmit output power for LEVEL7 in mW.')
dot11TxPowerLevel8 = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11TxPowerLevel8.setStatus('current')
if mibBuilder.loadTexts: dot11TxPowerLevel8.setDescription('The transmit output power for LEVEL8 in mW.')
dot11CurrentTxPowerLevel = MibTableColumn((1, 2, 840, 10036, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentTxPowerLevel.setDescription('The TxPowerLevel N currently being used to transmit data.\n            Some PHYs also use this value to determine the receiver\n            sensitivity requirements for CCA.')
dot11PhyFHSSTable = MibTable((1, 2, 840, 10036, 4, 4), )
if mibBuilder.loadTexts: dot11PhyFHSSTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyFHSSTable.setDescription('Group of attributes for dot11PhyFHSSTable.  Implemented as a\n            table indexed on STA ID to allow for multiple instances on\n            an Agent.')
dot11PhyFHSSEntry = MibTableRow((1, 2, 840, 10036, 4, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyFHSSEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyFHSSEntry.setDescription('An entry in the dot11PhyFHSS Table.\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11HopTime = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(224, 224))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11HopTime.setStatus('current')
if mibBuilder.loadTexts: dot11HopTime.setDescription('The time in microseconds for the PMD to change from\n            channel 2 to channel 80.')
dot11CurrentChannelNumber = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentChannelNumber.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentChannelNumber.setDescription('The current channel number of the frequency output by the RF\n        \tsynthesizer.')
dot11MaxDwellTime = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11MaxDwellTime.setStatus('current')
if mibBuilder.loadTexts: dot11MaxDwellTime.setDescription('The maximum time in TU that the transmitter\n            is permitted to operate on a single channel.')
dot11CurrentDwellTime = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentDwellTime.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentDwellTime.setDescription('The current time in TU that the transmitter shall operate\n            on a single channel, as set by the MAC.  Default is 19 TU.')
dot11CurrentSet = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentSet.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentSet.setDescription('The current set of patterns the PLME \n\t    is using to determine the hopping sequence. ')
dot11CurrentPattern = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentPattern.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentPattern.setDescription('The current pattern the PLME is\n            using to determine the hop sequence.')
dot11CurrentIndex = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentIndex.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentIndex.setDescription('The current index value the PLME is using to determine\n            the CurrentChannelNumber.')
dot11EHCCPrimeRadix = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11EHCCPrimeRadix.setStatus('current')
if mibBuilder.loadTexts: dot11EHCCPrimeRadix.setDescription('This attribute indicates the value to be \n\t\t\tused as the prime radix (N) in the HCC and \n\t\t\tEHCC algorithms.')
dot11EHCCNumberofChannelsFamilyIndex = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11EHCCNumberofChannelsFamilyIndex.setStatus('current')
if mibBuilder.loadTexts: dot11EHCCNumberofChannelsFamilyIndex.setDescription('This attribute indicates the value to be \n\t\t\tused as the maximum for the family index (a) \n\t\t\tin the HCC and EHCC algorithms. The value of \n\t\t\tthis field shall not be less than the prime \n\t\t\tradix minus 3 (N - 3). The valid range of \n\t\t\tallowed values is (N - 1), (N - 2), and (N - 3).')
dot11EHCCCapabilityImplemented = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11EHCCCapabilityImplemented.setStatus('current')
if mibBuilder.loadTexts: dot11EHCCCapabilityImplemented.setDescription('This attribute, when TRUE, indicates that the \n\t\t\tstation implementation is capable of generating \n\t\t\tthe HCC or EHCC algorithms for determining Hopping \n\t\t\tpatterns.  The capability is disabled, otherwise.  \n\t\t\tThe default value of this attribute is FALSE.')
dot11EHCCCapabilityEnabled = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11EHCCCapabilityEnabled.setStatus('current')
if mibBuilder.loadTexts: dot11EHCCCapabilityEnabled.setDescription('This attribute, when TRUE, indicates that the \n\t\t\tcapability of the station to operate using the HCC \n\t\t\tor EHCC algorithms for determining Hopping Patterns \n\t\t\tis enabled.  The capability is disabled, otherwise.  \n\t\t\tThe default value of this attribute is FALSE.')
dot11HopAlgorithmAdopted = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("crnt", 1), ("hopindex", 2), ("hcc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11HopAlgorithmAdopted.setStatus('current')
if mibBuilder.loadTexts: dot11HopAlgorithmAdopted.setDescription('This attribute, indicates which of the algorithms \n\t\t\twill be used to generate the Hopping Patterns. \n\t\t\tValid values are: \n\t\n\t\t\t1 - hopping patterns as defined in clause 14 \n\t\t\t2 - hop index method (with or without table)\n\t\t\t3 - HCC/EHCC method')
dot11RandomTableFlag = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11RandomTableFlag.setStatus('current')
if mibBuilder.loadTexts: dot11RandomTableFlag.setDescription('This attribute, indicates that a Random Table is \n\t\t\tpresent when the value is True. When the value is \n\t\t\tFalse it indicates that a Random Table is not \n\t\t\tpresent and that the hop index method is to be \n\t\t\tused to determine the hopping sequence. The default \n\t\t\tvalue of this attribute is True.')
dot11NumberofHoppingSets = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11NumberofHoppingSets.setStatus('current')
if mibBuilder.loadTexts: dot11NumberofHoppingSets.setDescription('The Number of Sets field indicates the total \n\t\t\tnumber of sets within the hopping patterns.')
dot11HopModulus = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11HopModulus.setStatus('current')
if mibBuilder.loadTexts: dot11HopModulus.setDescription('The number of allowed channels for the hopping \n\t\t\tset. This is defined by the governing regulatory \n\t\t\tagency for the country code of the country \n\t\t\tin which this device is operating.')
dot11HopOffset = MibTableColumn((1, 2, 840, 10036, 4, 4, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11HopOffset.setStatus('current')
if mibBuilder.loadTexts: dot11HopOffset.setDescription('The next position in the hopping set.')
dot11PhyDSSSTable = MibTable((1, 2, 840, 10036, 4, 5), )
if mibBuilder.loadTexts: dot11PhyDSSSTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyDSSSTable.setDescription('Entry of attributes for dot11PhyDSSSEntry.  Implemented as a\n            table indexed on ifIndex allow for multiple instances on\n            an Agent.')
dot11PhyDSSSEntry = MibTableRow((1, 2, 840, 10036, 4, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyDSSSEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyDSSSEntry.setDescription('An entry in the dot11PhyDSSSEntry Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11CurrentChannel = MibTableColumn((1, 2, 840, 10036, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentChannel.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentChannel.setDescription('The current operating frequency channel of the DSSS\n            PHY. Valid channel numbers are as defined in 15.4.6.2')
dot11CCAModeSupported = MibTableColumn((1, 2, 840, 10036, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11CCAModeSupported.setStatus('current')
if mibBuilder.loadTexts: dot11CCAModeSupported.setDescription('dot11CCAModeSupported is a bit-significant value,\n\t  \trepresenting all of the CCA modes supported by the PHY.\n\t\tValid values are:\n\n            \t   energy detect only (ED_ONLY) = 01,\n\t\t   carrier sense only (CS_ONLY) = 02,\n\t\t   carrier sense and energy detect (ED_and_CS)= 04\n\t\t   or the logical sum of any of these values.  This\n\t\t   attribute shall not be used to indicate the CCA modes\n\t\t   supported by a higher rate extension PHY.  Rather, the\n\t\t   dot11HRCCAModeSupported attribute shall be used to\n\t\t   indicate the CCA modes of the higher rate extension PHY.')
dot11CurrentCCAMode = MibTableColumn((1, 2, 840, 10036, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("edonly", 1), ("csonly", 2), ("edandcs", 4), ("cswithtimer", 8), ("hrcsanded", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentCCAMode.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentCCAMode.setDescription('The current CCA method in operation.   Valid values are:\n                energy detect only (edonly) = 01,\n                carrier sense only (csonly) = 02,\n                carrier sense and energy detect (edandcs)= 04\n                carrier sense with timer (cswithtimer)= 08\n                high rate carrier sense and energy detect (hrcsanded)=16.')
dot11EDThreshold = MibTableColumn((1, 2, 840, 10036, 4, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11EDThreshold.setStatus('current')
if mibBuilder.loadTexts: dot11EDThreshold.setDescription('The current Energy Detect Threshold being used by the DSSS PHY.')
dot11PhyIRTable = MibTable((1, 2, 840, 10036, 4, 6), )
if mibBuilder.loadTexts: dot11PhyIRTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyIRTable.setDescription('Group of attributes for dot11PhyIRTable.  Implemented as a\n            table indexed on ifIndex to allow for multiple instances on\n            an Agent.')
dot11PhyIREntry = MibTableRow((1, 2, 840, 10036, 4, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyIREntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyIREntry.setDescription('An entry in the dot11PhyIR Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11CCAWatchdogTimerMax = MibTableColumn((1, 2, 840, 10036, 4, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CCAWatchdogTimerMax.setStatus('current')
if mibBuilder.loadTexts: dot11CCAWatchdogTimerMax.setDescription('This parameter, together with CCAWatchdogCountMax,\n            determines when energy detected in the channel can be\n            ignored.')
dot11CCAWatchdogCountMax = MibTableColumn((1, 2, 840, 10036, 4, 6, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CCAWatchdogCountMax.setStatus('current')
if mibBuilder.loadTexts: dot11CCAWatchdogCountMax.setDescription('This parameter, together with CCAWatchdogTimerMax,\n            determines when energy detected in the channel can be\n            ignored.')
dot11CCAWatchdogTimerMin = MibTableColumn((1, 2, 840, 10036, 4, 6, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CCAWatchdogTimerMin.setStatus('current')
if mibBuilder.loadTexts: dot11CCAWatchdogTimerMin.setDescription('The minimum value to which CCAWatchdogTimerMax can be\n            set.')
dot11CCAWatchdogCountMin = MibTableColumn((1, 2, 840, 10036, 4, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CCAWatchdogCountMin.setStatus('current')
if mibBuilder.loadTexts: dot11CCAWatchdogCountMin.setDescription('The minimum value to which CCAWatchdogCount can be set.')
dot11RegDomainsSupportedTable = MibTable((1, 2, 840, 10036, 4, 7), )
if mibBuilder.loadTexts: dot11RegDomainsSupportedTable.setStatus('current')
if mibBuilder.loadTexts: dot11RegDomainsSupportedTable.setDescription("There are different operational requirements dependent on\n            the regulatory domain.  This attribute list describes the\n            regulatory domains the PLCP and PMD support in this\n            implementation.  Currently defined values and their\n            corresponding Regulatory Domains are:\n\n            FCC (USA) = X'10', DOC (Canada) = X'20', ETSI (most of\n            Europe) = X'30', Spain = X'31', France = X'32', MKK\n            (Japan) = X'40', Others = X'00' ")
dot11RegDomainsSupportedEntry = MibTableRow((1, 2, 840, 10036, 4, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11RegDomainsSupportedIndex"))
if mibBuilder.loadTexts: dot11RegDomainsSupportedEntry.setStatus('current')
if mibBuilder.loadTexts: dot11RegDomainsSupportedEntry.setDescription('An entry in the dot11RegDomainsSupportedTable.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11RegDomainsSupportedIndex = MibTableColumn((1, 2, 840, 10036, 4, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11RegDomainsSupportedIndex.setStatus('current')
if mibBuilder.loadTexts: dot11RegDomainsSupportedIndex.setDescription('The auxiliary variable used to identify instances\n            of the columnar objects in the RegDomainsSupport Table.')
dot11RegDomainsSupportedValue = MibTableColumn((1, 2, 840, 10036, 4, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 48, 49, 50, 64))).clone(namedValues=NamedValues(("fcc", 16), ("doc", 32), ("etsi", 48), ("spain", 49), ("france", 50), ("mkk", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11RegDomainsSupportedValue.setStatus('current')
if mibBuilder.loadTexts: dot11RegDomainsSupportedValue.setDescription("There are different operational requirements dependent on\n            the regulatory domain.  This attribute list describes the\n            regulatory domains the PLCP and PMD support in this\n            implementation.  Currently defined values and their\n            corresponding Regulatory Domains are:\n\n            FCC (USA) = X'10', DOC (Canada) = X'20', ETSI (most of\n            Europe) = X'30', Spain = X'31', France = X'32', MKK\n            (Japan) = X'40' ")
dot11AntennasListTable = MibTable((1, 2, 840, 10036, 4, 8), )
if mibBuilder.loadTexts: dot11AntennasListTable.setStatus('current')
if mibBuilder.loadTexts: dot11AntennasListTable.setDescription('This table represents the list of antennae.  An antenna can be \n\t\tmarked to be capable of transmitting, receiving, and/or for \n\t\tparticipation in receive diversity.  Each entry in this table \n\t\trepresents a single antenna with its properties.  The maximum \n\t\tnumber of antennae that can be contained in this table is 255.')
dot11AntennasListEntry = MibTableRow((1, 2, 840, 10036, 4, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11AntennaListIndex"))
if mibBuilder.loadTexts: dot11AntennasListEntry.setStatus('current')
if mibBuilder.loadTexts: dot11AntennasListEntry.setDescription('An entry in the dot11AntennasListTable, representing the properties \n            of a single antenna.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11AntennaListIndex = MibTableColumn((1, 2, 840, 10036, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dot11AntennaListIndex.setStatus('current')
if mibBuilder.loadTexts: dot11AntennaListIndex.setDescription('The unique index of an antenna which is used to identify the columnar \n            objects in the dot11AntennasList Table.')
dot11SupportedTxAntenna = MibTableColumn((1, 2, 840, 10036, 4, 8, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11SupportedTxAntenna.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedTxAntenna.setDescription('When true, this object indicates that the antenna represented by \n            dot11AntennaIndex can be used as a transmit antenna.')
dot11SupportedRxAntenna = MibTableColumn((1, 2, 840, 10036, 4, 8, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11SupportedRxAntenna.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedRxAntenna.setDescription('When true, this object indicates that the antenna represented by the \n            dot11AntennaIndex xan be used as a receive antenna.')
dot11DiversitySelectionRx = MibTableColumn((1, 2, 840, 10036, 4, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11DiversitySelectionRx.setStatus('current')
if mibBuilder.loadTexts: dot11DiversitySelectionRx.setDescription('When true, this object indicates that the antenna represented by \n            dot11AntennaIndex can be used for receive diversity.  This object \n            may only be true if the antenna can be used as a receive antenna, \n            as indicated by dot11SupportedRxAntenna.')
dot11SupportedDataRatesTxTable = MibTable((1, 2, 840, 10036, 4, 9), )
if mibBuilder.loadTexts: dot11SupportedDataRatesTxTable.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesTxTable.setDescription("The Transmit bit rates supported by the PLCP and PMD,\n            represented by a count from X'02-X'7f, corresponding to data\n            rates in increments of 500kbit/s from 1 Mbit/s to 63.5 Mbit/s subject\n            to limitations of each individual PHY.")
dot11SupportedDataRatesTxEntry = MibTableRow((1, 2, 840, 10036, 4, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11SupportedDataRatesTxIndex"))
if mibBuilder.loadTexts: dot11SupportedDataRatesTxEntry.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesTxEntry.setDescription('An Entry (conceptual row) in the dot11SupportedDataRatesTx\n            Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11SupportedDataRatesTxIndex = MibTableColumn((1, 2, 840, 10036, 4, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: dot11SupportedDataRatesTxIndex.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesTxIndex.setDescription('Index object which identifies which data rate to access.\n            Range is 1..8.')
dot11SupportedDataRatesTxValue = MibTableColumn((1, 2, 840, 10036, 4, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11SupportedDataRatesTxValue.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesTxValue.setDescription("The Transmit bit rates supported by the PLCP and PMD,\n            represented by a count from X'02-X'7f, corresponding to data\n            rates in increments of 500kbit/s from 1 Mbit/s to 63.5 Mbit/s subject\n            to limitations of each individual PHY.")
dot11SupportedDataRatesRxTable = MibTable((1, 2, 840, 10036, 4, 10), )
if mibBuilder.loadTexts: dot11SupportedDataRatesRxTable.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesRxTable.setDescription("The receive bit rates supported by the PLCP and PMD,\n            represented by a count from X'002-X'7f, corresponding to data\n            rates in increments of 500kbit/s from 1 Mbit/s to 63.5 Mbit/s.")
dot11SupportedDataRatesRxEntry = MibTableRow((1, 2, 840, 10036, 4, 10, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11SupportedDataRatesRxIndex"))
if mibBuilder.loadTexts: dot11SupportedDataRatesRxEntry.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesRxEntry.setDescription('An Entry (conceptual row) in the dot11SupportedDataRatesRx Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry.  Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11SupportedDataRatesRxIndex = MibTableColumn((1, 2, 840, 10036, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: dot11SupportedDataRatesRxIndex.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesRxIndex.setDescription('Index object which identifies which data rate to access.\n            Range is 1..8.')
dot11SupportedDataRatesRxValue = MibTableColumn((1, 2, 840, 10036, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11SupportedDataRatesRxValue.setStatus('current')
if mibBuilder.loadTexts: dot11SupportedDataRatesRxValue.setDescription("The receive bit rates supported by the PLCP and PMD,\n            represented by a count from X'02-X'7f, corresponding to data\n            rates in increments of 500kbit/s from 1 Mbit/s to 63.5 Mbit/s.")
dot11PhyOFDMTable = MibTable((1, 2, 840, 10036, 4, 11), )
if mibBuilder.loadTexts: dot11PhyOFDMTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOFDMTable.setDescription('Group of attributes for dot11PhyOFDMTable. Implemented as a\n            table indexed on ifindex to allow for multiple instances on\n            an Agent.')
dot11PhyOFDMEntry = MibTableRow((1, 2, 840, 10036, 4, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyOFDMEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOFDMEntry.setDescription('An entry in the dot11PhyOFDM Table.\n\n            ifIndex - Each IEEE 802.11 interface is represented by an\n            ifEntry. Interface tables in this MIB module are indexed\n            by ifIndex.')
dot11CurrentFrequency = MibTableColumn((1, 2, 840, 10036, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11CurrentFrequency.setStatus('current')
if mibBuilder.loadTexts: dot11CurrentFrequency.setDescription('The number of the current operating frequency channel of the OFDM PHY.')
dot11TIThreshold = MibTableColumn((1, 2, 840, 10036, 4, 11, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11TIThreshold.setStatus('current')
if mibBuilder.loadTexts: dot11TIThreshold.setDescription('The Threshold being used to detect a busy medium (frequency).\n            CCA shall report a busy medium upon detecting the RSSI above \n\t    this threshold.')
dot11FrequencyBandsSupported = MibTableColumn((1, 2, 840, 10036, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11FrequencyBandsSupported.setStatus('current')
if mibBuilder.loadTexts: dot11FrequencyBandsSupported.setDescription('The capability of the OFDM PHY implementation to operate in \n\t    the three U-NII bands. Coded as an integer value of a three \n\t    bit field as follows:\n                bit 0 .. capable of operating in the lower (5.15-5.25 GHz)\n\t\tU-NII band\n                bit 1 .. capable of operating in the middle (5.25-5.35 GHz) \n\t\tU-NII band\n                bit 2 .. capable of operating in the upper (5.725-5.825 GHz) \n\t\tU-NII band\n            For example, for an implementation capable of operating in the \n\t    lower and mid bands this attribute would take the value 3.')
dot11PhyHRDSSSTable = MibTable((1, 2, 840, 10036, 4, 12), )
if mibBuilder.loadTexts: dot11PhyHRDSSSTable.setStatus('current')
if mibBuilder.loadTexts: dot11PhyHRDSSSTable.setDescription('Entry of attributes for dot11PhyHRDSSSEntry.\n\t\t\tImplemented as a table indexed on ifIndex to allow for\n\t\t\tmultiple instances on an Agent.')
dot11PhyHRDSSSEntry = MibTableRow((1, 2, 840, 10036, 4, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dot11PhyHRDSSSEntry.setStatus('current')
if mibBuilder.loadTexts: dot11PhyHRDSSSEntry.setDescription('An entry in the dot11PhyHRDSSSEntry Table.\n\n\t\t\tifIndex - Each IEEE 802.11 interface is represented by an\n\t\t\tifEntry. Interface tables in this MIB module are indexed\n\t\t\tby ifIndex.')
dot11ShortPreambleOptionImplemented = MibTableColumn((1, 2, 840, 10036, 4, 12, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ShortPreambleOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: dot11ShortPreambleOptionImplemented.setDescription('This attribute, when true, shall indicate that the\n\t\t\tshort preamble option as defined in subclause 18.2.2.2\n\t\t\tis implemented.  The default value of this attribute\n\t\t\tshall be false.')
dot11PBCCOptionImplemented = MibTableColumn((1, 2, 840, 10036, 4, 12, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11PBCCOptionImplemented.setStatus('current')
if mibBuilder.loadTexts: dot11PBCCOptionImplemented.setDescription('This attribute, when true, shall indicate that the PBCC\n\t\t\tmodulation option as defined in subclause 18.4.6.6 is\n\t\t\timplemented.  The default value of this attribute shall\n\t\t\tbe false.')
dot11ChannelAgilityPresent = MibTableColumn((1, 2, 840, 10036, 4, 12, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ChannelAgilityPresent.setStatus('current')
if mibBuilder.loadTexts: dot11ChannelAgilityPresent.setDescription('This attribute indicates that the PHY is capable of\n\t\t\tchannel agility.')
dot11ChannelAgilityEnabled = MibTableColumn((1, 2, 840, 10036, 4, 12, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11ChannelAgilityEnabled.setStatus('current')
if mibBuilder.loadTexts: dot11ChannelAgilityEnabled.setDescription('This attribute indicates that the PHY channel agility\n\t\t\tfunctionality is enabled.')
dot11HRCCAModeSupported = MibTableColumn((1, 2, 840, 10036, 4, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot11HRCCAModeSupported.setStatus('current')
if mibBuilder.loadTexts: dot11HRCCAModeSupported.setDescription('dot11HRCCAModeSupported is a bit-significant value,\n\t\t\trepresenting all of the CCA modes supported by the PHY.\n\t\t\tValid values are:\n\t\t\t    energy detect only (ED_ONLY) = 01,\n\t\t\t    carrier sense only (CS_ONLY) = 02,\n\t\t\t    carrier sense and energy detect (ED_and_CS)= 04,\n\t\t\t    carrier sense with timer (CS_and_Timer)= 08,\n\t\t\t    high rate carrier sense and energy detect \n\t\t\t    (HRCS_and_ED)= 16\n\t\t\t    or the logical sum of any of these values.  In \n\t\t\t    the high rate extension PHY, this attribute shall \n\t\t\t    be used in preference to the dot11CCAModeSupported \n\t\t\t    attribute.')
dot11HoppingPatternTable = MibTable((1, 2, 840, 10036, 4, 13), )
if mibBuilder.loadTexts: dot11HoppingPatternTable.setStatus('current')
if mibBuilder.loadTexts: dot11HoppingPatternTable.setDescription('The (conceptual) table of attributes necessary for \n\t\t\ta frequency hopping implementation to be able to \n\t\t\tcreate the hopping sequences necessary to operate \n\t\t\tin the subband for the associated domain country string.')
dot11HoppingPatternEntry = MibTableRow((1, 2, 840, 10036, 4, 13, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IEEE802dot11-MIB", "dot11HoppingPatternIndex"))
if mibBuilder.loadTexts: dot11HoppingPatternEntry.setStatus('current')
if mibBuilder.loadTexts: dot11HoppingPatternEntry.setDescription('An entry (conceptual row) in the Hopping Pattern Table \n\t\t\tthat indicates the random hopping sequence to be followed. \n\n\t\t\tIfIndex - Each IEEE 802.11 interface is represented \n\t\t\tby an ifEntry. Interface tables in this MIB are indexed \n\t\t\tby ifIndex.')
dot11HoppingPatternIndex = MibTableColumn((1, 2, 840, 10036, 4, 13, 1, 1), Integer32())
if mibBuilder.loadTexts: dot11HoppingPatternIndex.setStatus('current')
if mibBuilder.loadTexts: dot11HoppingPatternIndex.setDescription('The auxiliary variable used to identify instances of \n\t\t\tthe columnar objects in the Hopping Pattern Table.')
dot11RandomTableFieldNumber = MibTableColumn((1, 2, 840, 10036, 4, 13, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot11RandomTableFieldNumber.setStatus('current')
if mibBuilder.loadTexts: dot11RandomTableFieldNumber.setDescription('This attribute shall indicate the value of the \n\t\t\tstarting channel number in the hopping sequence of \n\t\t\tthe subband for the associated domain country string. \n\t\t\tThe default value of this attribute shall be zero.')
dot11Conformance = MibIdentifier((1, 2, 840, 10036, 5))
dot11Groups = MibIdentifier((1, 2, 840, 10036, 5, 1))
dot11Compliances = MibIdentifier((1, 2, 840, 10036, 5, 2))
dot11Compliance = ModuleCompliance((1, 2, 840, 10036, 5, 2, 1)).setObjects(("IEEE802dot11-MIB", "dot11SMTbase2"), ("IEEE802dot11-MIB", "dot11MACbase"), ("IEEE802dot11-MIB", "dot11CountersGroup"), ("IEEE802dot11-MIB", "dot11SmtAuthenticationAlgorithms"), ("IEEE802dot11-MIB", "dot11ResourceTypeID"), ("IEEE802dot11-MIB", "dot11PhyOperationComplianceGroup"), ("IEEE802dot11-MIB", "dot11PhyDSSSComplianceGroup"), ("IEEE802dot11-MIB", "dot11PhyIRComplianceGroup"), ("IEEE802dot11-MIB", "dot11PhyFHSSComplianceGroup"), ("IEEE802dot11-MIB", "dot11PhyOFDMComplianceGroup"), ("IEEE802dot11-MIB", "dot11PhyHRDSSSComplianceGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11Compliance = dot11Compliance.setStatus('current')
if mibBuilder.loadTexts: dot11Compliance.setDescription('The compliance statement for SNMPv2 entities\n            that implement the IEEE 802.11 MIB.')
dot11SMTbase = ObjectGroup((1, 2, 840, 10036, 5, 1, 1)).setObjects(("IEEE802dot11-MIB", "dot11StationID"), ("IEEE802dot11-MIB", "dot11MediumOccupancyLimit"), ("IEEE802dot11-MIB", "dot11CFPollable"), ("IEEE802dot11-MIB", "dot11CFPPeriod"), ("IEEE802dot11-MIB", "dot11CFPMaxDuration"), ("IEEE802dot11-MIB", "dot11AuthenticationResponseTimeOut"), ("IEEE802dot11-MIB", "dot11PrivacyOptionImplemented"), ("IEEE802dot11-MIB", "dot11PowerManagementMode"), ("IEEE802dot11-MIB", "dot11DesiredSSID"), ("IEEE802dot11-MIB", "dot11DesiredBSSType"), ("IEEE802dot11-MIB", "dot11OperationalRateSet"), ("IEEE802dot11-MIB", "dot11BeaconPeriod"), ("IEEE802dot11-MIB", "dot11DTIMPeriod"), ("IEEE802dot11-MIB", "dot11AssociationResponseTimeOut"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11SMTbase = dot11SMTbase.setStatus('deprecated')
if mibBuilder.loadTexts: dot11SMTbase.setDescription('The SMT object class provides the necessary support at the\n         \tSTA to manage the processes in the STA such that the STA may\n         \twork cooperatively as a part of an IEEE 802.11 network.')
dot11SMTprivacy = ObjectGroup((1, 2, 840, 10036, 5, 1, 2)).setObjects(("IEEE802dot11-MIB", "dot11PrivacyInvoked"), ("IEEE802dot11-MIB", "dot11WEPKeyMappingLength"), ("IEEE802dot11-MIB", "dot11ExcludeUnencrypted"), ("IEEE802dot11-MIB", "dot11WEPICVErrorCount"), ("IEEE802dot11-MIB", "dot11WEPExcludedCount"), ("IEEE802dot11-MIB", "dot11WEPDefaultKeyID"), ("IEEE802dot11-MIB", "dot11WEPDefaultKeyValue"), ("IEEE802dot11-MIB", "dot11WEPKeyMappingWEPOn"), ("IEEE802dot11-MIB", "dot11WEPKeyMappingValue"), ("IEEE802dot11-MIB", "dot11WEPKeyMappingAddress"), ("IEEE802dot11-MIB", "dot11WEPKeyMappingStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11SMTprivacy = dot11SMTprivacy.setStatus('current')
if mibBuilder.loadTexts: dot11SMTprivacy.setDescription('The SMTPrivacy package is a set of attributes that shall be\n            present if WEP is implemented in the STA.')
dot11MACbase = ObjectGroup((1, 2, 840, 10036, 5, 1, 3)).setObjects(("IEEE802dot11-MIB", "dot11MACAddress"), ("IEEE802dot11-MIB", "dot11Address"), ("IEEE802dot11-MIB", "dot11GroupAddressesStatus"), ("IEEE802dot11-MIB", "dot11RTSThreshold"), ("IEEE802dot11-MIB", "dot11ShortRetryLimit"), ("IEEE802dot11-MIB", "dot11LongRetryLimit"), ("IEEE802dot11-MIB", "dot11FragmentationThreshold"), ("IEEE802dot11-MIB", "dot11MaxTransmitMSDULifetime"), ("IEEE802dot11-MIB", "dot11MaxReceiveLifetime"), ("IEEE802dot11-MIB", "dot11ManufacturerID"), ("IEEE802dot11-MIB", "dot11ProductID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11MACbase = dot11MACbase.setStatus('current')
if mibBuilder.loadTexts: dot11MACbase.setDescription('The MAC object class provides the necessary support for the\n         \taccess control, generation, and verification of frame check\n         \tsequences (FCSs), and proper delivery of valid data to upper\n         \tlayers.')
dot11MACStatistics = ObjectGroup((1, 2, 840, 10036, 5, 1, 4)).setObjects(("IEEE802dot11-MIB", "dot11RetryCount"), ("IEEE802dot11-MIB", "dot11MultipleRetryCount"), ("IEEE802dot11-MIB", "dot11RTSSuccessCount"), ("IEEE802dot11-MIB", "dot11RTSFailureCount"), ("IEEE802dot11-MIB", "dot11ACKFailureCount"), ("IEEE802dot11-MIB", "dot11FrameDuplicateCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11MACStatistics = dot11MACStatistics.setStatus('current')
if mibBuilder.loadTexts: dot11MACStatistics.setDescription('The MACStatistics package provides extended statistical\n            information on the operation of the MAC.  This \n            package is completely optional.')
dot11ResourceTypeID = ObjectGroup((1, 2, 840, 10036, 5, 1, 5)).setObjects(("IEEE802dot11-MIB", "dot11ResourceTypeIDName"), ("IEEE802dot11-MIB", "dot11manufacturerOUI"), ("IEEE802dot11-MIB", "dot11manufacturerName"), ("IEEE802dot11-MIB", "dot11manufacturerProductName"), ("IEEE802dot11-MIB", "dot11manufacturerProductVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11ResourceTypeID = dot11ResourceTypeID.setStatus('current')
if mibBuilder.loadTexts: dot11ResourceTypeID.setDescription('Attributes used to identify a STA, its manufacturer,\n            and various product names and versions.')
dot11SmtAuthenticationAlgorithms = ObjectGroup((1, 2, 840, 10036, 5, 1, 6)).setObjects(("IEEE802dot11-MIB", "dot11AuthenticationAlgorithm"), ("IEEE802dot11-MIB", "dot11AuthenticationAlgorithmsEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11SmtAuthenticationAlgorithms = dot11SmtAuthenticationAlgorithms.setStatus('current')
if mibBuilder.loadTexts: dot11SmtAuthenticationAlgorithms.setDescription('Authentication Algorithm Table.')
dot11PhyOperationComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 7)).setObjects(("IEEE802dot11-MIB", "dot11PHYType"), ("IEEE802dot11-MIB", "dot11CurrentRegDomain"), ("IEEE802dot11-MIB", "dot11TempType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyOperationComplianceGroup = dot11PhyOperationComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOperationComplianceGroup.setDescription('PHY layer operations attributes.')
dot11PhyAntennaComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 8)).setObjects(("IEEE802dot11-MIB", "dot11CurrentTxAntenna"), ("IEEE802dot11-MIB", "dot11DiversitySupport"), ("IEEE802dot11-MIB", "dot11CurrentRxAntenna"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyAntennaComplianceGroup = dot11PhyAntennaComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyAntennaComplianceGroup.setDescription('Attributes for Data Rates for IEEE 802.11.')
dot11PhyTxPowerComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 9)).setObjects(("IEEE802dot11-MIB", "dot11NumberSupportedPowerLevels"), ("IEEE802dot11-MIB", "dot11TxPowerLevel1"), ("IEEE802dot11-MIB", "dot11TxPowerLevel2"), ("IEEE802dot11-MIB", "dot11TxPowerLevel3"), ("IEEE802dot11-MIB", "dot11TxPowerLevel4"), ("IEEE802dot11-MIB", "dot11TxPowerLevel5"), ("IEEE802dot11-MIB", "dot11TxPowerLevel6"), ("IEEE802dot11-MIB", "dot11TxPowerLevel7"), ("IEEE802dot11-MIB", "dot11TxPowerLevel8"), ("IEEE802dot11-MIB", "dot11CurrentTxPowerLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyTxPowerComplianceGroup = dot11PhyTxPowerComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyTxPowerComplianceGroup.setDescription('Attributes for Control and Management of transmit power.')
dot11PhyFHSSComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 10)).setObjects(("IEEE802dot11-MIB", "dot11HopTime"), ("IEEE802dot11-MIB", "dot11CurrentChannelNumber"), ("IEEE802dot11-MIB", "dot11MaxDwellTime"), ("IEEE802dot11-MIB", "dot11CurrentDwellTime"), ("IEEE802dot11-MIB", "dot11CurrentSet"), ("IEEE802dot11-MIB", "dot11CurrentPattern"), ("IEEE802dot11-MIB", "dot11CurrentIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyFHSSComplianceGroup = dot11PhyFHSSComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyFHSSComplianceGroup.setDescription('Attributes that configure the Frequency Hopping for IEEE\n            802.11.')
dot11PhyDSSSComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 11)).setObjects(("IEEE802dot11-MIB", "dot11CurrentChannel"), ("IEEE802dot11-MIB", "dot11CCAModeSupported"), ("IEEE802dot11-MIB", "dot11CurrentCCAMode"), ("IEEE802dot11-MIB", "dot11EDThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyDSSSComplianceGroup = dot11PhyDSSSComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyDSSSComplianceGroup.setDescription('Attributes that configure the DSSS for IEEE 802.11.')
dot11PhyIRComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 12)).setObjects(("IEEE802dot11-MIB", "dot11CCAWatchdogTimerMax"), ("IEEE802dot11-MIB", "dot11CCAWatchdogCountMax"), ("IEEE802dot11-MIB", "dot11CCAWatchdogTimerMin"), ("IEEE802dot11-MIB", "dot11CCAWatchdogCountMin"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyIRComplianceGroup = dot11PhyIRComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyIRComplianceGroup.setDescription('Attributes that configure the baseband IR for IEEE 802.11.')
dot11PhyRegDomainsSupportGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 13)).setObjects(("IEEE802dot11-MIB", "dot11RegDomainsSupportedValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyRegDomainsSupportGroup = dot11PhyRegDomainsSupportGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyRegDomainsSupportGroup.setDescription('Attributes that specify the supported Regulation Domains.')
dot11PhyAntennasListGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 14)).setObjects(("IEEE802dot11-MIB", "dot11SupportedTxAntenna"), ("IEEE802dot11-MIB", "dot11SupportedRxAntenna"), ("IEEE802dot11-MIB", "dot11DiversitySelectionRx"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyAntennasListGroup = dot11PhyAntennasListGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyAntennasListGroup.setDescription('Attributes that specify the supported Regulation Domains.')
dot11PhyRateGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 15)).setObjects(("IEEE802dot11-MIB", "dot11SupportedDataRatesTxValue"), ("IEEE802dot11-MIB", "dot11SupportedDataRatesRxValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyRateGroup = dot11PhyRateGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyRateGroup.setDescription('Attributes for Data Rates for IEEE 802.11.')
dot11CountersGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 16)).setObjects(("IEEE802dot11-MIB", "dot11TransmittedFragmentCount"), ("IEEE802dot11-MIB", "dot11MulticastTransmittedFrameCount"), ("IEEE802dot11-MIB", "dot11FailedCount"), ("IEEE802dot11-MIB", "dot11ReceivedFragmentCount"), ("IEEE802dot11-MIB", "dot11MulticastReceivedFrameCount"), ("IEEE802dot11-MIB", "dot11FCSErrorCount"), ("IEEE802dot11-MIB", "dot11WEPUndecryptableCount"), ("IEEE802dot11-MIB", "dot11TransmittedFrameCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11CountersGroup = dot11CountersGroup.setStatus('current')
if mibBuilder.loadTexts: dot11CountersGroup.setDescription('Attributes from the dot11CountersGroup that are not described\n            in the dot11MACStatistics group.  These objects are\n            mandatory.')
dot11NotificationGroup = NotificationGroup((1, 2, 840, 10036, 5, 1, 17)).setObjects(("IEEE802dot11-MIB", "dot11Disassociate"), ("IEEE802dot11-MIB", "dot11Deauthenticate"), ("IEEE802dot11-MIB", "dot11AuthenticateFail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11NotificationGroup = dot11NotificationGroup.setStatus('current')
if mibBuilder.loadTexts: dot11NotificationGroup.setDescription('IEEE 802.11 notifications')
dot11SMTbase2 = ObjectGroup((1, 2, 840, 10036, 5, 1, 18)).setObjects(("IEEE802dot11-MIB", "dot11MediumOccupancyLimit"), ("IEEE802dot11-MIB", "dot11CFPollable"), ("IEEE802dot11-MIB", "dot11CFPPeriod"), ("IEEE802dot11-MIB", "dot11CFPMaxDuration"), ("IEEE802dot11-MIB", "dot11AuthenticationResponseTimeOut"), ("IEEE802dot11-MIB", "dot11PrivacyOptionImplemented"), ("IEEE802dot11-MIB", "dot11PowerManagementMode"), ("IEEE802dot11-MIB", "dot11DesiredSSID"), ("IEEE802dot11-MIB", "dot11DesiredBSSType"), ("IEEE802dot11-MIB", "dot11OperationalRateSet"), ("IEEE802dot11-MIB", "dot11BeaconPeriod"), ("IEEE802dot11-MIB", "dot11DTIMPeriod"), ("IEEE802dot11-MIB", "dot11AssociationResponseTimeOut"), ("IEEE802dot11-MIB", "dot11DisassociateReason"), ("IEEE802dot11-MIB", "dot11DisassociateStation"), ("IEEE802dot11-MIB", "dot11DeauthenticateReason"), ("IEEE802dot11-MIB", "dot11DeauthenticateStation"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStatus"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11SMTbase2 = dot11SMTbase2.setStatus('current')
if mibBuilder.loadTexts: dot11SMTbase2.setDescription('The SMTbase2 object class provides the necessary support at the\n         \tSTA to manage the processes in the STA such that the STA may\n         \twork cooperatively as a part of an IEEE 802.11 network.')
dot11PhyOFDMComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 19)).setObjects(("IEEE802dot11-MIB", "dot11CurrentFrequency"), ("IEEE802dot11-MIB", "dot11TIThreshold"), ("IEEE802dot11-MIB", "dot11FrequencyBandsSupported"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyOFDMComplianceGroup = dot11PhyOFDMComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyOFDMComplianceGroup.setDescription('Attributes that configure the OFDM for IEEE 802.11.')
dot11SMTbase3 = ObjectGroup((1, 2, 840, 10036, 5, 1, 20)).setObjects(("IEEE802dot11-MIB", "dot11MediumOccupancyLimit"), ("IEEE802dot11-MIB", "dot11CFPollable"), ("IEEE802dot11-MIB", "dot11CFPPeriod"), ("IEEE802dot11-MIB", "dot11CFPMaxDuration"), ("IEEE802dot11-MIB", "dot11AuthenticationResponseTimeOut"), ("IEEE802dot11-MIB", "dot11PrivacyOptionImplemented"), ("IEEE802dot11-MIB", "dot11PowerManagementMode"), ("IEEE802dot11-MIB", "dot11DesiredSSID"), ("IEEE802dot11-MIB", "dot11DesiredBSSType"), ("IEEE802dot11-MIB", "dot11OperationalRateSet"), ("IEEE802dot11-MIB", "dot11BeaconPeriod"), ("IEEE802dot11-MIB", "dot11DTIMPeriod"), ("IEEE802dot11-MIB", "dot11AssociationResponseTimeOut"), ("IEEE802dot11-MIB", "dot11DisassociateReason"), ("IEEE802dot11-MIB", "dot11DisassociateStation"), ("IEEE802dot11-MIB", "dot11DeauthenticateReason"), ("IEEE802dot11-MIB", "dot11DeauthenticateStation"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStatus"), ("IEEE802dot11-MIB", "dot11AuthenticateFailStation"), ("IEEE802dot11-MIB", "dot11MultiDomainCapabilityImplemented"), ("IEEE802dot11-MIB", "dot11MultiDomainCapabilityEnabled"), ("IEEE802dot11-MIB", "dot11CountryString"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11SMTbase3 = dot11SMTbase3.setStatus('current')
if mibBuilder.loadTexts: dot11SMTbase3.setDescription('The SMTbase3 object class provides the necessary support at the\n\t\tSTA to manage the processes in the STA such that the STA may\n\t\twork cooperatively as a part of an IEEE 802.11 network, when the STA\n\t\tis capable of multi-domain operation. This object group should be\n\t\timplemented when the multi-domain capability option is implemented.')
dot11MultiDomainCapabilityGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 21)).setObjects(("IEEE802dot11-MIB", "dot11FirstChannelNumber"), ("IEEE802dot11-MIB", "dot11NumberofChannels"), ("IEEE802dot11-MIB", "dot11MaximumTransmitPowerLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11MultiDomainCapabilityGroup = dot11MultiDomainCapabilityGroup.setStatus('current')
if mibBuilder.loadTexts: dot11MultiDomainCapabilityGroup.setDescription('The dot11MultiDomainCapabilityGroup object class provides \n\t\t\tthe objects necessary to manage the channels usable by a STA, \n\t\t\twhen the multi-domain capability option is implemented.')
dot11PhyFHSSComplianceGroup2 = ObjectGroup((1, 2, 840, 10036, 5, 1, 22)).setObjects(("IEEE802dot11-MIB", "dot11HopTime"), ("IEEE802dot11-MIB", "dot11CurrentChannelNumber"), ("IEEE802dot11-MIB", "dot11MaxDwellTime"), ("IEEE802dot11-MIB", "dot11CurrentDwellTime"), ("IEEE802dot11-MIB", "dot11CurrentSet"), ("IEEE802dot11-MIB", "dot11CurrentPattern"), ("IEEE802dot11-MIB", "dot11CurrentIndex"), ("IEEE802dot11-MIB", "dot11EHCCPrimeRadix"), ("IEEE802dot11-MIB", "dot11EHCCNumberofChannelsFamilyIndex"), ("IEEE802dot11-MIB", "dot11EHCCCapabilityImplemented"), ("IEEE802dot11-MIB", "dot11EHCCCapabilityEnabled"), ("IEEE802dot11-MIB", "dot11HopAlgorithmAdopted"), ("IEEE802dot11-MIB", "dot11RandomTableFlag"), ("IEEE802dot11-MIB", "dot11NumberofHoppingSets"), ("IEEE802dot11-MIB", "dot11HopModulus"), ("IEEE802dot11-MIB", "dot11HopOffset"), ("IEEE802dot11-MIB", "dot11RandomTableFieldNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyFHSSComplianceGroup2 = dot11PhyFHSSComplianceGroup2.setStatus('current')
if mibBuilder.loadTexts: dot11PhyFHSSComplianceGroup2.setDescription('Attributes that configure the Frequency Hopping for IEEE\n            802.11 when multi-domain capability option is implemented.')
dot11PhyHRDSSSComplianceGroup = ObjectGroup((1, 2, 840, 10036, 5, 1, 23)).setObjects(("IEEE802dot11-MIB", "dot11CurrentChannel"), ("IEEE802dot11-MIB", "dot11CCAModeSupported"), ("IEEE802dot11-MIB", "dot11CurrentCCAMode"), ("IEEE802dot11-MIB", "dot11EDThreshold"), ("IEEE802dot11-MIB", "dot11ShortPreambleOptionImplemented"), ("IEEE802dot11-MIB", "dot11PBCCOptionImplemented"), ("IEEE802dot11-MIB", "dot11ChannelAgilityPresent"), ("IEEE802dot11-MIB", "dot11ChannelAgilityEnabled"), ("IEEE802dot11-MIB", "dot11HRCCAModeSupported"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot11PhyHRDSSSComplianceGroup = dot11PhyHRDSSSComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: dot11PhyHRDSSSComplianceGroup.setDescription('Attributes that configure the HRDSSS for IEEE 802.11.')
mibBuilder.exportSymbols("IEEE802dot11-MIB", dot11MACAddress=dot11MACAddress, dot11CountersTable=dot11CountersTable, dot11HRCCAModeSupported=dot11HRCCAModeSupported, dot11MACStatistics=dot11MACStatistics, dot11smt=dot11smt, dot11resAttribute=dot11resAttribute, dot11RetryCount=dot11RetryCount, dot11PowerManagementMode=dot11PowerManagementMode, dot11CurrentChannel=dot11CurrentChannel, dot11ExcludeUnencrypted=dot11ExcludeUnencrypted, dot11manufacturerOUI=dot11manufacturerOUI, dot11FragmentationThreshold=dot11FragmentationThreshold, dot11PrivacyOptionImplemented=dot11PrivacyOptionImplemented, dot11SupportedDataRatesTxEntry=dot11SupportedDataRatesTxEntry, dot11WEPDefaultKeysEntry=dot11WEPDefaultKeysEntry, dot11SupportedDataRatesRxIndex=dot11SupportedDataRatesRxIndex, dot11SMTbase3=dot11SMTbase3, dot11ResourceTypeID=dot11ResourceTypeID, dot11ManufacturerID=dot11ManufacturerID, dot11CurrentTxAntenna=dot11CurrentTxAntenna, dot11CountersGroup=dot11CountersGroup, dot11SmtAuthenticationAlgorithms=dot11SmtAuthenticationAlgorithms, dot11WEPUndecryptableCount=dot11WEPUndecryptableCount, dot11Address=dot11Address, dot11MultiDomainCapabilityIndex=dot11MultiDomainCapabilityIndex, dot11WEPDefaultKeysTable=dot11WEPDefaultKeysTable, dot11PrivacyEntry=dot11PrivacyEntry, dot11PhyOperationComplianceGroup=dot11PhyOperationComplianceGroup, dot11EHCCCapabilityEnabled=dot11EHCCCapabilityEnabled, dot11phy=dot11phy, dot11CurrentRxAntenna=dot11CurrentRxAntenna, dot11SupportedDataRatesTxIndex=dot11SupportedDataRatesTxIndex, dot11PhyIRComplianceGroup=dot11PhyIRComplianceGroup, dot11PhyOperationEntry=dot11PhyOperationEntry, dot11EHCCNumberofChannelsFamilyIndex=dot11EHCCNumberofChannelsFamilyIndex, dot11WEPDefaultKeyValue=dot11WEPDefaultKeyValue, dot11PhyFHSSComplianceGroup2=dot11PhyFHSSComplianceGroup2, dot11TxPowerLevel8=dot11TxPowerLevel8, dot11WEPKeyMappingAddress=dot11WEPKeyMappingAddress, dot11NotificationGroup=dot11NotificationGroup, dot11SMTbase=dot11SMTbase, dot11TxPowerLevel5=dot11TxPowerLevel5, dot11NumberofChannels=dot11NumberofChannels, dot11FrequencyBandsSupported=dot11FrequencyBandsSupported, dot11PhyFHSSComplianceGroup=dot11PhyFHSSComplianceGroup, dot11MultiDomainCapabilityImplemented=dot11MultiDomainCapabilityImplemented, dot11DisassociateStation=dot11DisassociateStation, dot11CFPollable=dot11CFPollable, dot11RTSThreshold=dot11RTSThreshold, dot11WEPKeyMappingsEntry=dot11WEPKeyMappingsEntry, dot11AntennasListTable=dot11AntennasListTable, dot11TxPowerLevel2=dot11TxPowerLevel2, dot11CurrentDwellTime=dot11CurrentDwellTime, dot11ResourceInfoTable=dot11ResourceInfoTable, dot11HoppingPatternEntry=dot11HoppingPatternEntry, dot11PhyAntennaComplianceGroup=dot11PhyAntennaComplianceGroup, us=us, dot11WEPICVErrorCount=dot11WEPICVErrorCount, dot11DTIMPeriod=dot11DTIMPeriod, dot11TempType=dot11TempType, dot11GroupAddressesTable=dot11GroupAddressesTable, dot11PhyFHSSTable=dot11PhyFHSSTable, dot11EHCCPrimeRadix=dot11EHCCPrimeRadix, dot11MultipleRetryCount=dot11MultipleRetryCount, dot11PhyTxPowerComplianceGroup=dot11PhyTxPowerComplianceGroup, dot11OperationTable=dot11OperationTable, dot11PhyAntennaTable=dot11PhyAntennaTable, dot11HoppingPatternIndex=dot11HoppingPatternIndex, dot11CurrentIndex=dot11CurrentIndex, dot11AntennasListEntry=dot11AntennasListEntry, dot11DiversitySelectionRx=dot11DiversitySelectionRx, dot11PhyAntennasListGroup=dot11PhyAntennasListGroup, dot11PhyFHSSEntry=dot11PhyFHSSEntry, dot11MultiDomainCapabilityEnabled=dot11MultiDomainCapabilityEnabled, dot11ShortRetryLimit=dot11ShortRetryLimit, dot11AssociationResponseTimeOut=dot11AssociationResponseTimeOut, dot11PHYType=dot11PHYType, dot11DeauthenticateStation=dot11DeauthenticateStation, dot11CCAWatchdogTimerMin=dot11CCAWatchdogTimerMin, dot11WEPDefaultKeyIndex=dot11WEPDefaultKeyIndex, dot11MulticastTransmittedFrameCount=dot11MulticastTransmittedFrameCount, dot11WEPKeyMappingWEPOn=dot11WEPKeyMappingWEPOn, dot11MaximumTransmitPowerLevel=dot11MaximumTransmitPowerLevel, dot11PhyTxPowerEntry=dot11PhyTxPowerEntry, dot11PhyDSSSEntry=dot11PhyDSSSEntry, dot11AuthenticationAlgorithmsEntry=dot11AuthenticationAlgorithmsEntry, dot11SMTnotification=dot11SMTnotification, dot11CFPMaxDuration=dot11CFPMaxDuration, dot11AuthenticationAlgorithmsEnable=dot11AuthenticationAlgorithmsEnable, dot11EHCCCapabilityImplemented=dot11EHCCCapabilityImplemented, dot11Conformance=dot11Conformance, dot11RegDomainsSupportedTable=dot11RegDomainsSupportedTable, dot11PBCCOptionImplemented=dot11PBCCOptionImplemented, dot11CountersEntry=dot11CountersEntry, dot11manufacturerProductName=dot11manufacturerProductName, dot11ShortPreambleOptionImplemented=dot11ShortPreambleOptionImplemented, dot11mac=dot11mac, dot11CurrentTxPowerLevel=dot11CurrentTxPowerLevel, WEPKeytype=WEPKeytype, dot11PhyAntennaEntry=dot11PhyAntennaEntry, dot11PhyHRDSSSEntry=dot11PhyHRDSSSEntry, dot11CCAWatchdogCountMin=dot11CCAWatchdogCountMin, dot11TIThreshold=dot11TIThreshold, ieee802dot11=ieee802dot11, dot11PhyDSSSTable=dot11PhyDSSSTable, dot11CurrentFrequency=dot11CurrentFrequency, dot11AuthenticateFailStatus=dot11AuthenticateFailStatus, dot11PrivacyInvoked=dot11PrivacyInvoked, dot11Compliances=dot11Compliances, dot11Groups=dot11Groups, dot11CCAWatchdogCountMax=dot11CCAWatchdogCountMax, dot11CCAModeSupported=dot11CCAModeSupported, dot11StationConfigEntry=dot11StationConfigEntry, dot11CurrentSet=dot11CurrentSet, dot11MultiDomainCapabilityEntry=dot11MultiDomainCapabilityEntry, dot11PhyTxPowerTable=dot11PhyTxPowerTable, dot11PhyHRDSSSTable=dot11PhyHRDSSSTable, dot11MultiDomainCapabilityTable=dot11MultiDomainCapabilityTable, dot11DeauthenticateReason=dot11DeauthenticateReason, dot11ChannelAgilityEnabled=dot11ChannelAgilityEnabled, dot11SMTprivacy=dot11SMTprivacy, dot11SupportedDataRatesRxValue=dot11SupportedDataRatesRxValue, dot11HopOffset=dot11HopOffset, dot11ResourceInfoEntry=dot11ResourceInfoEntry, dot11AuthenticationAlgorithm=dot11AuthenticationAlgorithm, dot11HopAlgorithmAdopted=dot11HopAlgorithmAdopted, dot11PhyIRTable=dot11PhyIRTable, dot11SupportedDataRatesRxEntry=dot11SupportedDataRatesRxEntry, dot11AuthenticateFail=dot11AuthenticateFail, dot11TxPowerLevel4=dot11TxPowerLevel4, dot11AntennaListIndex=dot11AntennaListIndex, dot11OperationEntry=dot11OperationEntry, dot11RegDomainsSupportedEntry=dot11RegDomainsSupportedEntry, dot11PrivacyTable=dot11PrivacyTable, dot11TxPowerLevel1=dot11TxPowerLevel1, dot11RegDomainsSupportedIndex=dot11RegDomainsSupportedIndex, dot11MaxDwellTime=dot11MaxDwellTime, dot11HoppingPatternTable=dot11HoppingPatternTable, dot11MACbase=dot11MACbase, dot11WEPKeyMappingIndex=dot11WEPKeyMappingIndex, dot11AuthenticationAlgorithmsIndex=dot11AuthenticationAlgorithmsIndex, dot11FrameDuplicateCount=dot11FrameDuplicateCount, dot11RTSFailureCount=dot11RTSFailureCount, dot11GroupAddressesStatus=dot11GroupAddressesStatus, dot11PhyOFDMTable=dot11PhyOFDMTable, dot11ReceivedFragmentCount=dot11ReceivedFragmentCount, dot11MulticastReceivedFrameCount=dot11MulticastReceivedFrameCount, dot11RTSSuccessCount=dot11RTSSuccessCount, dot11LongRetryLimit=dot11LongRetryLimit, dot11NumberofHoppingSets=dot11NumberofHoppingSets, dot11CurrentRegDomain=dot11CurrentRegDomain, dot11StationConfigTable=dot11StationConfigTable, dot11DesiredSSID=dot11DesiredSSID, dot11manufacturerProductVersion=dot11manufacturerProductVersion, dot11CCAWatchdogTimerMax=dot11CCAWatchdogTimerMax, dot11CurrentChannelNumber=dot11CurrentChannelNumber, dot11WEPKeyMappingsTable=dot11WEPKeyMappingsTable, dot11WEPDefaultKeyID=dot11WEPDefaultKeyID, dot11RegDomainsSupportedValue=dot11RegDomainsSupportedValue, dot11DisassociateReason=dot11DisassociateReason, dot11HopModulus=dot11HopModulus, dot11DesiredBSSType=dot11DesiredBSSType, dot11Compliance=dot11Compliance, dot11SupportedRxAntenna=dot11SupportedRxAntenna, dot11MediumOccupancyLimit=dot11MediumOccupancyLimit, dot11SupportedDataRatesTxValue=dot11SupportedDataRatesTxValue, dot11AuthenticationAlgorithmsTable=dot11AuthenticationAlgorithmsTable, dot11FirstChannelNumber=dot11FirstChannelNumber, dot11TransmittedFrameCount=dot11TransmittedFrameCount, dot11GroupAddressesIndex=dot11GroupAddressesIndex, dot11PhyDSSSComplianceGroup=dot11PhyDSSSComplianceGroup, dot11CurrentCCAMode=dot11CurrentCCAMode, dot11AuthenticateFailStation=dot11AuthenticateFailStation, dot11StationID=dot11StationID, dot11BeaconPeriod=dot11BeaconPeriod, dot11WEPKeyMappingStatus=dot11WEPKeyMappingStatus, dot11HopTime=dot11HopTime, dot11SMTbase2=dot11SMTbase2, dot11GroupAddressesEntry=dot11GroupAddressesEntry, dot11PhyOperationTable=dot11PhyOperationTable, dot11manufacturerName=dot11manufacturerName, dot11Disassociate=dot11Disassociate, dot11TxPowerLevel7=dot11TxPowerLevel7, dot11AuthenticationResponseTimeOut=dot11AuthenticationResponseTimeOut, dot11ProductID=dot11ProductID, dot11SupportedTxAntenna=dot11SupportedTxAntenna, dot11ResourceTypeIDName=dot11ResourceTypeIDName, dot11WEPKeyMappingLength=dot11WEPKeyMappingLength, dot11PhyIREntry=dot11PhyIREntry, dot11ChannelAgilityPresent=dot11ChannelAgilityPresent, dot11WEPKeyMappingValue=dot11WEPKeyMappingValue, dot11FCSErrorCount=dot11FCSErrorCount, dot11res=dot11res, dot11SupportedDataRatesTxTable=dot11SupportedDataRatesTxTable, dot11TxPowerLevel3=dot11TxPowerLevel3, dot11CurrentPattern=dot11CurrentPattern, dot11PhyRateGroup=dot11PhyRateGroup, dot11Deauthenticate=dot11Deauthenticate, dot11RandomTableFlag=dot11RandomTableFlag, dot11RandomTableFieldNumber=dot11RandomTableFieldNumber, dot11MultiDomainCapabilityGroup=dot11MultiDomainCapabilityGroup, dot11MaxTransmitMSDULifetime=dot11MaxTransmitMSDULifetime, dot11PhyHRDSSSComplianceGroup=dot11PhyHRDSSSComplianceGroup, dot11NumberSupportedPowerLevels=dot11NumberSupportedPowerLevels, dot11WEPExcludedCount=dot11WEPExcludedCount, dot11PhyOFDMEntry=dot11PhyOFDMEntry, dot11SupportedDataRatesRxTable=dot11SupportedDataRatesRxTable, PYSNMP_MODULE_ID=ieee802dot11, dot11PhyRegDomainsSupportGroup=dot11PhyRegDomainsSupportGroup, dot11CFPPeriod=dot11CFPPeriod, dot11FailedCount=dot11FailedCount, dot11PhyOFDMComplianceGroup=dot11PhyOFDMComplianceGroup, dot11DiversitySupport=dot11DiversitySupport, dot11TransmittedFragmentCount=dot11TransmittedFragmentCount, dot11CountryString=dot11CountryString, dot11TxPowerLevel6=dot11TxPowerLevel6, dot11OperationalRateSet=dot11OperationalRateSet, dot11ACKFailureCount=dot11ACKFailureCount, dot11EDThreshold=dot11EDThreshold, dot11MaxReceiveLifetime=dot11MaxReceiveLifetime, member_body=member_body)
