#
# PySNMP MIB module WHISP-SM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/cambium/WHISP-SM-MIB
# Produced by pysmi-1.1.8 at Mon Feb  7 15:45:35 2022
# On host fv-az77-513 platform Linux version 5.11.0-1028-azure by user runner
# Using Python version 3.10.2 (main, Jan 16 2022, 11:55:27) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
iso, Counter64, ModuleIdentity, IpAddress, Counter32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, NotificationType, Gauge32, Bits, MibIdentifier, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter64", "ModuleIdentity", "IpAddress", "Counter32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "NotificationType", "Gauge32", "Bits", "MibIdentifier", "ObjectIdentity", "TimeTicks")
TextualConvention, DisplayString, MacAddress, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress", "PhysAddress")
dhcpRfPublicIp, whispBoxEsn = mibBuilder.importSymbols("WHISP-BOX-MIBV2-MIB", "dhcpRfPublicIp", "whispBoxEsn")
whispModules, whispAps, whispSm, whispBox = mibBuilder.importSymbols("WHISP-GLOBAL-REG-MIB", "whispModules", "whispAps", "whispSm", "whispBox")
WhispLUID, WhispMACAddress = mibBuilder.importSymbols("WHISP-TCV2-MIB", "WhispLUID", "WhispMACAddress")
whispSmMibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 161, 19, 1, 1, 13))
if mibBuilder.loadTexts: whispSmMibModule.setLastUpdated('200304150000Z')
if mibBuilder.loadTexts: whispSmMibModule.setOrganization('Cambium Networks')
if mibBuilder.loadTexts: whispSmMibModule.setContactInfo('Cambium Networks Support\n        email: support@cambiumnetworks.com')
if mibBuilder.loadTexts: whispSmMibModule.setDescription('This module contains MIB definitions for Subscriber Modem.')
whispSmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1))
whispSmSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7))
whispSmStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2))
whispSmGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 3))
whispSmEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4))
whispSmDfsEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 1))
whispSmSpAnEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 2))
whispSmDHCPClientEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 3))
whispSmControls = MibIdentifier((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 8))
rfScanList = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfScanList.setStatus('current')
if mibBuilder.loadTexts: rfScanList.setDescription('RF scan list string.\n            The frequencies vary by product and region.\n            If the frequency list is too long an SNMP error will be returned. If this occurs please refer to \n            OID rfScanListTable, which will allow user to enter the full range of available frequencies.\n            String length is limited to SNMP buffer size, so while all frequencies may be set, not all may be retrieved.\n            Special settings:\n            0:  none.\n            all: All frequencies in the band(s) supported by the radio will be selected.\n            all49, all51, all52: Available only for 450i 5 GHz wideband radio.\n            all54, all57: Available only for 450 and 450i 5 GHz radios.\n            When doing a set, separate values with comma with no white space between values.')
powerUpMode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("operational", 0), ("aim", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: powerUpMode.setStatus('current')
if mibBuilder.loadTexts: powerUpMode.setDescription('SM Power Up Mode With No 802.3 Link.\n            0 - Power up in Operational mode.\n            1 - Power up in Aim mode.')
lanIpSm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanIpSm.setStatus('current')
if mibBuilder.loadTexts: lanIpSm.setDescription('LAN IP.')
lanMaskSm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lanMaskSm.setStatus('current')
if mibBuilder.loadTexts: lanMaskSm.setDescription('LAN subnet mask.')
defaultGwSm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultGwSm.setStatus('current')
if mibBuilder.loadTexts: defaultGwSm.setDescription('Default gateway.')
networkAccess = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("localIP", 0), ("publicIP", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: networkAccess.setStatus('current')
if mibBuilder.loadTexts: networkAccess.setDescription('Network accessibility. Public or local IP.\n            For multipoint only.')
authKeySm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authKeySm.setStatus('current')
if mibBuilder.loadTexts: authKeySm.setDescription('Authentication key. It should be equal or less than 32\n            characters long.')
enable8023link = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enable8023link.setStatus('deprecated')
if mibBuilder.loadTexts: enable8023link.setDescription('To enable or disable 802.3 link. For SMs only.  Deprecated: Use enable8023linkBox instead.')
authKeyOption = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("useDefault", 0), ("useKeySet", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authKeyOption.setStatus('current')
if mibBuilder.loadTexts: authKeyOption.setDescription('This option is for SMs only. Backhaul timing slave always\n            uses the set key.\n            0 - Use default key.\n            1 - Use set key.')
timingPulseGated = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timingPulseGated.setStatus('current')
if mibBuilder.loadTexts: timingPulseGated.setDescription('0 - Disable (Always propagate the frame timing pulse).\n            1 - Enable (If SM out of sync then dont propagate the frame timing pulse).')
naptPrivateIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptPrivateIP.setStatus('current')
if mibBuilder.loadTexts: naptPrivateIP.setDescription('NAPT private IP address. Only the first three bytes can be\n            changed when NAPT is enabled.')
naptPrivateSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptPrivateSubnetMask.setStatus('current')
if mibBuilder.loadTexts: naptPrivateSubnetMask.setDescription('NAPT private subnet mask. Only the last byte can be\n            changed when NAPT is enabled. The address will always be:\n            255.255.255.x.')
naptPublicIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptPublicIP.setStatus('current')
if mibBuilder.loadTexts: naptPublicIP.setDescription('IP Address of NAPT Public Interface. The variable is available\n            only when NAPT is enabled.')
naptPublicSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptPublicSubnetMask.setStatus('current')
if mibBuilder.loadTexts: naptPublicSubnetMask.setDescription('Subnet mask for NAPT Public Interface. The variable is available\n            only when NAPT is enabled.')
naptPublicGatewayIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptPublicGatewayIP.setStatus('current')
if mibBuilder.loadTexts: naptPublicGatewayIP.setDescription('IP Address of NAPT Public Interface Gateway. The variable is available\n            only when NAPT is enabled.')
naptRFPublicIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptRFPublicIP.setStatus('current')
if mibBuilder.loadTexts: naptRFPublicIP.setDescription('IP Address of RF Public Interface. The variable is available\n            only when NAPT is enabled.')
naptRFPublicSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptRFPublicSubnetMask.setStatus('current')
if mibBuilder.loadTexts: naptRFPublicSubnetMask.setDescription('Subnet mask of RF Public Interface. The variable is available\n            only when NAPT is enabled.')
naptRFPublicGateway = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptRFPublicGateway.setStatus('current')
if mibBuilder.loadTexts: naptRFPublicGateway.setDescription('IP Address of RF Public Interface Gateway. The variable is\n            available only when NAPT is enabled.')
naptEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptEnable.setStatus('current')
if mibBuilder.loadTexts: naptEnable.setDescription('To enable or disable NAPT. For multipoint only.\n            1=Enable NAPT, 0=Disable NAPT.')
arpCacheTimeout = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpCacheTimeout.setStatus('current')
if mibBuilder.loadTexts: arpCacheTimeout.setDescription('ARP cache time out in unit of minutes. For multipoint only.\n            Range from 1-30.')
tcpGarbageCollectTmout = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tcpGarbageCollectTmout.setStatus('current')
if mibBuilder.loadTexts: tcpGarbageCollectTmout.setDescription('Units of minutes for TCP garbage collection. For multipoint only.\n            Range 4-1440.')
udpGarbageCollectTmout = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: udpGarbageCollectTmout.setStatus('current')
if mibBuilder.loadTexts: udpGarbageCollectTmout.setDescription('Units of minutes for UDP garbage collection. For multipoint only.\n            Range 1-1440.')
dhcpClientEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpClientEnable.setStatus('obsolete')
if mibBuilder.loadTexts: dhcpClientEnable.setDescription("To enable or disable DHCP client. For multipoint SM's\n            with NAPT enabled.")
dhcpServerEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpServerEnable.setStatus('current')
if mibBuilder.loadTexts: dhcpServerEnable.setDescription("To enable or disable DHCP server. For multipoint SM's\n            with NAPT enabled.")
dhcpServerLeaseTime = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpServerLeaseTime.setStatus('current')
if mibBuilder.loadTexts: dhcpServerLeaseTime.setDescription("Units of days for DHCP server lease time. For multipoint\n            SM's with NAPT enabled. Range from 1-30.")
dhcpIPStart = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 26), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpIPStart.setStatus('current')
if mibBuilder.loadTexts: dhcpIPStart.setDescription('The last byte will be set for the starting IP that\n            our DHCP server gives away. The first 3 bytes of the\n            starting IP are the same as those of NAPT private IP')
dnsAutomatic = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("manually", 0), ("automatically", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsAutomatic.setStatus('current')
if mibBuilder.loadTexts: dnsAutomatic.setDescription('To have DHCP Server obtain DNS information automatically or manually.')
prefferedDNSIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prefferedDNSIP.setStatus('current')
if mibBuilder.loadTexts: prefferedDNSIP.setDescription('The preferred DNS IP when we are configured for static DNS\n            (Not used when configured for automatic DNS).')
alternateDNSIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 29), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alternateDNSIP.setStatus('current')
if mibBuilder.loadTexts: alternateDNSIP.setDescription('The alternate DNS IP when we are configured for static DNS\n            (Not used when configured for automatic DNS).')
dmzIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 30), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmzIP.setStatus('current')
if mibBuilder.loadTexts: dmzIP.setDescription('Only the last byte of DMZ Host IP will be set.\n            The first 3 bytes of DMZ IP are the same as those of\n            NAPT private IP.')
dmzEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dmzEnable.setStatus('current')
if mibBuilder.loadTexts: dmzEnable.setDescription('To enable or disable DMZ host functionality.')
dhcpNumIPsToLease = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpNumIPsToLease.setStatus('current')
if mibBuilder.loadTexts: dhcpNumIPsToLease.setDescription('Number of IP addresses that our DHCP server can give away.')
pppoeFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeFilter.setStatus('obsolete')
if mibBuilder.loadTexts: pppoeFilter.setDescription('To set PPPoE packet filter when NAT is disabled.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
smbFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smbFilter.setStatus('obsolete')
if mibBuilder.loadTexts: smbFilter.setDescription('To set SMB packet filter when NAT is disabled.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
snmpFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpFilter.setStatus('obsolete')
if mibBuilder.loadTexts: snmpFilter.setDescription('To set SNMP packet filter when NAT is disabled.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userP1Filter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userP1Filter.setStatus('obsolete')
if mibBuilder.loadTexts: userP1Filter.setDescription('To set user defined port 1 packet filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userP2Filter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userP2Filter.setStatus('obsolete')
if mibBuilder.loadTexts: userP2Filter.setDescription('To set user defined port 2 packet filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userP3Filter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userP3Filter.setStatus('obsolete')
if mibBuilder.loadTexts: userP3Filter.setDescription('To set user defined port 3 packet filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
allOtherIpFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allOtherIpFilter.setStatus('obsolete')
if mibBuilder.loadTexts: allOtherIpFilter.setDescription('To set all other IPv4 packet filter when NAT\n            is disabled.\n                Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
upLinkBCastFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upLinkBCastFilter.setStatus('obsolete')
if mibBuilder.loadTexts: upLinkBCastFilter.setDescription('This variable is currently obsolete.')
arpFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpFilter.setStatus('obsolete')
if mibBuilder.loadTexts: arpFilter.setDescription('To set ARP packet filter when NAT is disabled.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
allOthersFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allOthersFilter.setStatus('obsolete')
if mibBuilder.loadTexts: allOthersFilter.setDescription('To set all other packet filter when NAT is disabled.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userDefinedPort1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 43), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userDefinedPort1.setStatus('obsolete')
if mibBuilder.loadTexts: userDefinedPort1.setDescription('An integer value of number one user defined port. Range:0-65535\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port1TCPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1TCPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port1TCPFilter.setDescription('To set user defined port 1 TCP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port1UDPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1UDPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port1UDPFilter.setDescription('To set user defined port 1 UDP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userDefinedPort2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userDefinedPort2.setStatus('obsolete')
if mibBuilder.loadTexts: userDefinedPort2.setDescription('An integer value of number two user defined port. Range:0-65535\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port2TCPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port2TCPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port2TCPFilter.setDescription('To set user defined port 2 TCP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port2UDPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port2UDPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port2UDPFilter.setDescription('To set user defined port 2 UDP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
userDefinedPort3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 49), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userDefinedPort3.setStatus('obsolete')
if mibBuilder.loadTexts: userDefinedPort3.setDescription('An integer value of number three user defined port. Range:0-65535\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port3TCPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port3TCPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port3TCPFilter.setDescription('To set user defined port 3 TCP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
port3UDPFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port3UDPFilter.setStatus('obsolete')
if mibBuilder.loadTexts: port3UDPFilter.setDescription('To set user defined port 3 UDP traffic filter.\n                            Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
bootpcFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpcFilter.setStatus('obsolete')
if mibBuilder.loadTexts: bootpcFilter.setDescription('To set bootp client sourced packets filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
bootpsFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpsFilter.setStatus('obsolete')
if mibBuilder.loadTexts: bootpsFilter.setDescription('To set bootp server sourced packets filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
ip4MultFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip4MultFilter.setStatus('obsolete')
if mibBuilder.loadTexts: ip4MultFilter.setDescription('To set IPv4 MultiCast packets filter when\n            NAT is disabled.\n               Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
ingressVID = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 55), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressVID.setStatus('current')
if mibBuilder.loadTexts: ingressVID.setDescription('Untagged ingress VID.')
lowPriorityUplinkCIR = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 56), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lowPriorityUplinkCIR.setStatus('current')
if mibBuilder.loadTexts: lowPriorityUplinkCIR.setDescription('Low priority uplink CIR.')
lowPriorityDownlinkCIR = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 57), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lowPriorityDownlinkCIR.setStatus('current')
if mibBuilder.loadTexts: lowPriorityDownlinkCIR.setDescription('Low priority downlink CIR.')
hiPriorityChannel = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hiPriorityChannel.setStatus('current')
if mibBuilder.loadTexts: hiPriorityChannel.setDescription('To enable or disable high priority channel.')
hiPriorityUplinkCIR = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 59), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hiPriorityUplinkCIR.setStatus('current')
if mibBuilder.loadTexts: hiPriorityUplinkCIR.setDescription('High priority uplink CIR.')
hiPriorityDownlinkCIR = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 60), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hiPriorityDownlinkCIR.setStatus('current')
if mibBuilder.loadTexts: hiPriorityDownlinkCIR.setDescription('High priority downlink CIR.')
smRateAdapt = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("onex", 0), ("onextwox", 1), ("onextwoxthreex", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRateAdapt.setStatus('obsolete')
if mibBuilder.loadTexts: smRateAdapt.setDescription('Rate adaptation parameter. 0: no rate adaptation. 1: 1x and 2x adaptation. 2: 1x,2x and 3x adaptation.')
upLnkDataRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 62), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upLnkDataRate.setStatus('current')
if mibBuilder.loadTexts: upLnkDataRate.setDescription('Sustained uplink bandwidth cap.')
upLnkLimit = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 63), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upLnkLimit.setStatus('current')
if mibBuilder.loadTexts: upLnkLimit.setDescription('Burst uplink bandwidth cap.')
dwnLnkDataRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 64), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dwnLnkDataRate.setStatus('current')
if mibBuilder.loadTexts: dwnLnkDataRate.setDescription('Sustained downlink bandwidth cap.')
dwnLnkLimit = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 65), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dwnLnkLimit.setStatus('current')
if mibBuilder.loadTexts: dwnLnkLimit.setDescription('Burst downlink bandwidth cap.')
dfsConfig = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dfsConfig.setStatus('obsolete')
if mibBuilder.loadTexts: dfsConfig.setDescription('To configure proper regions for Dynamic Frequency Shifting. For 5.2/5.4/5.7 GHz radios.')
ethAccessFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAccessFilterEnable.setStatus('obsolete')
if mibBuilder.loadTexts: ethAccessFilterEnable.setDescription('To enable or disable Ethernet Port access filtering to SM Management Functions.\n            (0) - Ethernet access to SM Management allowed.\n            (1) - Ethernet access to SM Management blocked.')
ipAccessFilterEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAccessFilterEnable.setStatus('current')
if mibBuilder.loadTexts: ipAccessFilterEnable.setDescription('To enable or disable IP access filtering to Management functions.\n            (0) - IP access will be allowed from all addresses.\n            (1) - IP access will be controlled using allowedIPAccess1-3 entries.')
allowedIPAccess1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 69), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccess1.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccess1.setDescription('Allow access to SM Management from this IP.\n            0 is default setting to allow from all IPs.')
allowedIPAccess2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 70), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccess2.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccess2.setDescription('Allow access to SM Management from this IP.\n            0 is default setting to allow from all IPs.')
allowedIPAccess3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 71), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccess3.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccess3.setDescription('Allow access to SM Management from this IP.\n            0 is default setting to allow from all IPs.')
rfDhcpState = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfDhcpState.setStatus('current')
if mibBuilder.loadTexts: rfDhcpState.setDescription('To enable or disable RF Interface DHCP feature.')
bCastMIR = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bCastMIR.setStatus('current')
if mibBuilder.loadTexts: bCastMIR.setDescription('To enable and set Broadcast/ Multicast MIR feature. Use value of 0 to disable. \n                        Units are as per bCastMIRUnits variable. Set the units first and then set this value.')
bhsReReg = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bhsReReg.setStatus('obsolete')
if mibBuilder.loadTexts: bhsReReg.setDescription('Allows BHS re-registration every 24 hours. Enable allows re-registration and Disable does not.  24 Hour Encryption Refresh.')
smLEDModeFlag = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("legacy", 0), ("revised", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smLEDModeFlag.setStatus('current')
if mibBuilder.loadTexts: smLEDModeFlag.setDescription('To set LED Panel Operation to Revised Mode(1) or to Legacy Mode(0)')
ethAccessEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAccessEnable.setStatus('current')
if mibBuilder.loadTexts: ethAccessEnable.setDescription('To enable or disable Ethernet Port access to SM Management Functions.\n            (1) - Ethernet access to SM Management allowed.\n            (0) - Ethernet access to SM Management blocked.')
pppoeEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeEnable.setStatus('current')
if mibBuilder.loadTexts: pppoeEnable.setDescription('Enable or disable PPPoE on the SM.  NAT MUST be enabled prior and Translation Bridging MUST be DISABLED on the AP.')
pppoeAuthenticationType = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("chap-pap", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeAuthenticationType.setStatus('current')
if mibBuilder.loadTexts: pppoeAuthenticationType.setDescription('Set the PPPoE Authentication Type to either None or CHAP/pap')
pppoeAccessConcentrator = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 79), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeAccessConcentrator.setStatus('current')
if mibBuilder.loadTexts: pppoeAccessConcentrator.setDescription('Set the PPPoE Access Concentrator Name.  Less than or equal to 32 characters')
pppoeServiceName = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 80), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeServiceName.setStatus('current')
if mibBuilder.loadTexts: pppoeServiceName.setDescription('Set the PPPoE Service Name.  Less than or equal to 32 characters')
pppoeUserName = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 81), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeUserName.setStatus('current')
if mibBuilder.loadTexts: pppoeUserName.setDescription('Set the PPPoE Username.  Less than or equal to 32 characters')
pppoePassword = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 82), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoePassword.setStatus('current')
if mibBuilder.loadTexts: pppoePassword.setDescription('Set the PPPoE Password.  Less than or equal to 32 characters')
pppoeTCPMSSClampEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeTCPMSSClampEnable.setStatus('current')
if mibBuilder.loadTexts: pppoeTCPMSSClampEnable.setDescription('Enable or disable TCP MSS Clamping.  Enabling this will cause the SM to edit the TCP MSS in TCP SYN and SYN-ACK packets.\n            \t\t\tThis will allow for a workaround for MTU issues so that the TCP session will only go up to the clamped MSS.  If you are\n            \t\t\tusing PMTUD reliably, this should not be needed.')
pppoeMTUOverrideEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeMTUOverrideEnable.setStatus('current')
if mibBuilder.loadTexts: pppoeMTUOverrideEnable.setDescription("Enable the overriding of the PPP link's MTU.  Normally, the PPP link will set the MTU to the MRU of the\n            \t\t\tPPPoE Server, but this may be overridden.  If the MRU of the PPPoE server is smaller than the desired MTU,\n            \t\t\tthe smaller MTU will be used.")
pppoeMTUOverrideValue = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 85), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1492))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeMTUOverrideValue.setStatus('current')
if mibBuilder.loadTexts: pppoeMTUOverrideValue.setDescription("Enable the overriding of the PPP link's MTU.  Normally, the PPP link will set the MTU to the MRU of the\n            \t\t\tPPPoE Server, but this may be overridden.  If the MRU of the PPPoE server is smaller than the desired MTU,\n            \t\t\tthe smaller MTU will be used.  Max MTU of a PPPoE link is 1492.")
pppoeTimerType = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("keepAlive", 1), ("idleTimeout", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeTimerType.setStatus('current')
if mibBuilder.loadTexts: pppoeTimerType.setDescription('Set the PPPoE Timer type.  Can be a Keep Alive timer where the link will be checked periodically and\n            \t\t\tautomatically redialed if the link is down.  Also could be an Idle Timeout where the link will\n            \t\t\tbe automatically dropped after an idle period and redialed if user data is present. Keep Alive timers\n            \t\t\tare in seconds while Idle Timeout timers are in minutes.')
pppoeTimeoutPeriod = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 87), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeTimeoutPeriod.setStatus('current')
if mibBuilder.loadTexts: pppoeTimeoutPeriod.setDescription('The Timeout Period.  The use of this depends on the Timer Type.  If the Timer Type is KeepAlive, then\n            \t\t\tthe timeout period is in seconds.  If the Timer Type is Idle Timeout, then the timeout period is in minutes.\n            \t\t\tMinimum values are 20 seconds for KeepAlive timer, and 5 minutes for Idle Timeout.')
timedSpectrumAnalysisDuration = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 88), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timedSpectrumAnalysisDuration.setStatus('deprecated')
if mibBuilder.loadTexts: timedSpectrumAnalysisDuration.setDescription('As of release 13.0.2 this value is depricated. Please use the OID in whispBoxConfig.\n                            Value in seconds for a timed spectrum analysis. Range is 10-1000 seconds.')
spectrumAnalysisOnBoot = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spectrumAnalysisOnBoot.setStatus('current')
if mibBuilder.loadTexts: spectrumAnalysisOnBoot.setDescription('To enable or disable Spectrum Analysis on boot up for one scan through the band.\n\t\t\t\t\t\t\t(0) - Disabled\n                            (1) - Enabled')
spectrumAnalysisAction = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("stopSpectrumAnalysis", 0), ("startTimedSpectrumAnalysis", 1), ("startContinuousSpectrumAnalysis", 2), ("idleNoSpectrumAnalysis", 3), ("idleCompleteSpectrumAnalysis", 4), ("inProgressTimedSpectrumAnalysis", 5), ("inProgressContinuousSpectrumAnalysis", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spectrumAnalysisAction.setStatus('deprecated')
if mibBuilder.loadTexts: spectrumAnalysisAction.setDescription('As of release 13.0.2, this OID has been deprecated. Please use the OID in whispBoxConfig.\n                            Start or stop timed or continuous Spectrum Analysis and also give status.\n                            (0) - Stop Spectrum Analysis\n                            (1) - Start Timed Spectrum Analysis\n                            (2) - Start Continuous Spectrum Analysis\n                            (3) - Idle, no Spectrum Analysis results.\n                            (4) - Idle, Spectrum Analysis results available.\n                            (5) - Timed or Remote Spectrum Analysis in progress.\n                            (6) - Continuous Spectrum Analysis in progress.\n\n                            Note: Continuous mode has a max of 24 hours.')
pppoeConnectOD = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("connectOnDemand", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeConnectOD.setStatus('current')
if mibBuilder.loadTexts: pppoeConnectOD.setDescription('Force a manual PPPoE connection attempt.')
pppoeDisconnectOD = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("disconnectOnDemand", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoeDisconnectOD.setStatus('current')
if mibBuilder.loadTexts: pppoeDisconnectOD.setDescription('Force a manual PPPoE disconnection.')
smAntennaType = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("integrated", 0), ("external", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smAntennaType.setStatus('obsolete')
if mibBuilder.loadTexts: smAntennaType.setDescription('Deprecated. See whispBoxStatus.antType for antenna type information.')
natConnectionType = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 94), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("staticIP", 0), ("dhcp", 1), ("pppoe", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natConnectionType.setStatus('current')
if mibBuilder.loadTexts: natConnectionType.setDescription('To configure the SM NAT connection type.  Options are Static IP, DHCP, or PPPoE.')
wanPingReplyEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanPingReplyEnable.setStatus('current')
if mibBuilder.loadTexts: wanPingReplyEnable.setDescription('Allow Ping replies from SM WAN interface.  Applies to both NAT and PPPoE WAN interfaces.')
packetFilterDirection = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upstream", 1), ("downstream", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: packetFilterDirection.setStatus('obsolete')
if mibBuilder.loadTexts: packetFilterDirection.setDescription('To packet filter direction when NAT is disabled.  Upstream is default.\n                                 Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
colorCode2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 97), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode2.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode2.setDescription('Second Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority2.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority2.setDescription('Priority setting for the second color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 99), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode3.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode3.setDescription('Third Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority3.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority3.setDescription('Priority setting for the third color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode4 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 101), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode4.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode4.setDescription('Fourth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority4 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 102), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority4.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority4.setDescription('Priority setting for the fourth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode5 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 103), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode5.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode5.setDescription('Fifth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority5 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority5.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority5.setDescription('Priority setting for the fifth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode6 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 105), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode6.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode6.setDescription('Sixth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority6 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 106), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority6.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority6.setDescription('Priority setting for the sixth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode7 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 107), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode7.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode7.setDescription('Seventh Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority7 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority7.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority7.setDescription('Priority setting for the seventh color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode8 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 109), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode8.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode8.setDescription('Eighth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority8 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority8.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority8.setDescription('Priority setting for the eighth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode9 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 111), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode9.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode9.setDescription('Ninth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority9 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 112), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority9.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority9.setDescription('Priority setting for the ninth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
colorCode10 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 113), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCode10.setStatus('deprecated')
if mibBuilder.loadTexts: colorCode10.setDescription('Tenth Color code. The variable is deprecated.  See additionalColorCode in whispSmConfig.')
colorCodepriority10 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 114), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 0))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3), ("disable", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: colorCodepriority10.setStatus('deprecated')
if mibBuilder.loadTexts: colorCodepriority10.setDescription('Priority setting for the tenth color code. The variable is deprecated.\n                        \tSee additionalColorCodePriority in whispSmConfig.')
natDNSProxyEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 115), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natDNSProxyEnable.setStatus('current')
if mibBuilder.loadTexts: natDNSProxyEnable.setDescription('If enabled, the SM will advertise itself as the DNS server when it sends out DHCP client leases and forward DNS queries automatically.\n                        \tIf disabled, the SM will forward on upstream DNS server information when it sends out DHCP client leases.')
allIpv4Filter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 116), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filterOff", 0), ("filterOn", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allIpv4Filter.setStatus('obsolete')
if mibBuilder.loadTexts: allIpv4Filter.setDescription('To set all IPv4 packet filter when NAT\n            is disabled.  Enabling this will automatically enable all of the known IP filters (SMB, SNMP, Bootp,\n            IPv4 Mcast, User Defined Ports, and All Other IPv4).\n                  Obsolete - Use corresponding OID in whipsBoxConfig MIB.')
spectrumAnalysisDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 117), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("averaging", 0), ("instantaneous", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spectrumAnalysisDisplay.setStatus('current')
if mibBuilder.loadTexts: spectrumAnalysisDisplay.setDescription('The display for Spectrum Analyzer:\n                            (0) - Averaging over entire period\n                            (1) - Instantaneous showing the last reading')
syslogSMXmitSetting = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 118), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("obtain-from-AP", 0), ("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogSMXmitSetting.setStatus('deprecated')
if mibBuilder.loadTexts: syslogSMXmitSetting.setDescription('Obtains Syslog transmit configuration from AP/BHM if set to 0, overrides if 1 or 2. Transmits syslog data to Syslog server if enabled(1), stops if disabled (2).')
syslogServerApPreferred = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 119), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("use-local", 0), ("use-AP-preferred", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServerApPreferred.setStatus('current')
if mibBuilder.loadTexts: syslogServerApPreferred.setDescription('Uses Syslog server configuration from AP/BHM if enabled and available,\n\t\t             otherwise uses local configuration.')
syslogMinLevelApPreferred = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("use-local", 0), ("use-AP-preferred", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogMinLevelApPreferred.setStatus('current')
if mibBuilder.loadTexts: syslogMinLevelApPreferred.setDescription('Uses Syslog minimum transmit level configuration from AP/BHM if available,\n                 otherwise uses local configuration.')
syslogSMXmitControl = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("obtain-from-AP-default-disabled", 0), ("obtain-from-AP-default-enabled", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogSMXmitControl.setStatus('current')
if mibBuilder.loadTexts: syslogSMXmitControl.setDescription('Obtains Syslog transmit configuration from AP/BHM if available, or specifies the local transmit state.')
eapPeerAAAServerCommonName = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 126), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eapPeerAAAServerCommonName.setStatus('current')
if mibBuilder.loadTexts: eapPeerAAAServerCommonName.setDescription('THIS OID IS CURRENTLY UNUSED: EAP Peer Server Common Name')
rfScanListBandFilter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 127), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 9))).clone(namedValues=NamedValues(("band5400", 8), ("band5700", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfScanListBandFilter.setStatus('obsolete')
if mibBuilder.loadTexts: rfScanListBandFilter.setDescription('This element is obsolete.')
upLnkMaxBurstDataRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 128), Integer32()).setUnits('Kilobits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: upLnkMaxBurstDataRate.setStatus('current')
if mibBuilder.loadTexts: upLnkMaxBurstDataRate.setDescription('Maximum burst uplink rate.')
dwnLnkMaxBurstDataRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 129), Integer32()).setUnits('Kilobits/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dwnLnkMaxBurstDataRate.setStatus('current')
if mibBuilder.loadTexts: dwnLnkMaxBurstDataRate.setDescription('Maximum burst downlink rate.')
cyclicPrefixScan = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 130), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cyclicPrefixScan.setStatus('current')
if mibBuilder.loadTexts: cyclicPrefixScan.setDescription('Cyclic Prefix value for frequency scanning used by MIMO SMs only.\n                        When setting use a comma delimited list of cyclic prefixes with no spaces.  For example: 1/8,1/16')
bandwidthScan = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 131), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bandwidthScan.setStatus('current')
if mibBuilder.loadTexts: bandwidthScan.setDescription('Bandwidth values for frequency scanning used by MIMO SMs only.\n                            When setting use a comma delimited list of bandwidths.\n                            For example: 10, 20')
apSelection = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 132), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("powerLevel", 1), ("optimizeForThroughput", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apSelection.setStatus('current')
if mibBuilder.loadTexts: apSelection.setDescription("This OID affects what AP to attempt to register to when Canopy SMs scan see more than one AP that are valid in it's configuration.\n                            (0) - Default, Canopy radios after scanning select the best AP that will optimize for estimated throughput.\n                            (1) - Select the AP with the best receive power level.\n                            Note this is only if multiple APs fit the current scan configuration, and will be overriden by color codes, RADIUS, etc.")
radioBandscanConfig = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 133), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("instant", 0), ("delayed", 1), ("apply", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: radioBandscanConfig.setStatus('current')
if mibBuilder.loadTexts: radioBandscanConfig.setDescription('Used to determine when frequency, cyclic prefix and bandwidth settings take effect for\n                        band scanning MIMO SMs.\n                        0 - Instant\n                        1 - Delayed\n                        2 - Apply changes')
forcepoweradjust = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 134), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: forcepoweradjust.setStatus('current')
if mibBuilder.loadTexts: forcepoweradjust.setDescription('This will force a multipoint SM to initiate an asynchronous power adjust sequence.\n                        \tThis is done automatically every 2 minutes.')
clearBerrResults = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 135), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearBerrResults.setStatus('current')
if mibBuilder.loadTexts: clearBerrResults.setDescription('This will clear the BER results.')
berrautoupdateflag = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 136), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berrautoupdateflag.setStatus('current')
if mibBuilder.loadTexts: berrautoupdateflag.setDescription('This indicates if the once a second BERR updating of counters is enabled.  1 = enabled 0 = disabled')
testSMBER = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 137), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: testSMBER.setStatus('current')
if mibBuilder.loadTexts: testSMBER.setDescription('0 - Disable (Return the SM to a normal operation state).\n            1 - Enable (Set SM into a BER test state).')
allowedIPAccessNMLength1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 138), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccessNMLength1.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccessNMLength1.setDescription('Length of the network mask to apply to the AllowedIPAddress when assessing if access is allowed')
allowedIPAccessNMLength2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 139), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccessNMLength2.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccessNMLength2.setDescription('Length of the network mask to apply to the AllowedIPAddress when assessing if access is allowed')
allowedIPAccessNMLength3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 140), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedIPAccessNMLength3.setStatus('current')
if mibBuilder.loadTexts: allowedIPAccessNMLength3.setDescription('Length of the network mask to apply to the AllowedIPAddress when assessing if access is allowed')
naptRemoteManage = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 141), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("enable-standalone", 1), ("enable-wan", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: naptRemoteManage.setStatus('current')
if mibBuilder.loadTexts: naptRemoteManage.setDescription('To enable or disable Remote Management. For multipoint only.\n            0=Disable Remote Management,\n            1=Enable - Standalone Config,\n            2=Enable - Use WAN Interface.')
spectrumAnalysisScanBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 142), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("bandwidth5MHz", 0), ("bandwidth10MHz", 1), ("bandwidth20MHz", 2), ("bandwidth7MHz", 3), ("bandwidth15MHz", 4), ("bandwidth30MHz", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spectrumAnalysisScanBandwidth.setStatus('current')
if mibBuilder.loadTexts: spectrumAnalysisScanBandwidth.setDescription('Scanning Bandwidth used for the Spectrum Analyzer.  Only available on PMP 450.')
berDeModSelect = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 143), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("qpsk", 0), ("qam-16", 1), ("qam-64", 2), ("qam-256", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berDeModSelect.setStatus('current')
if mibBuilder.loadTexts: berDeModSelect.setDescription('The BER demodulation level the SM is set. 0 for QPSK, 1 for 16-QAM, 2 for 64-QAM, and 3 for 256-QAM.')
multicastVCRcvRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 144), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: multicastVCRcvRate.setStatus('current')
if mibBuilder.loadTexts: multicastVCRcvRate.setDescription('Multicast VC Receive Rate')
pmp430ApRegistrationOptions = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 145), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pmp430", 1), ("pmp450", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pmp430ApRegistrationOptions.setStatus('deprecated')
if mibBuilder.loadTexts: pmp430ApRegistrationOptions.setDescription('Deprecated.  The 430 SM only supports PMP 450\n                          interoperability mode.')
switchRadioModeAndReboot = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 146), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("finishedReboot", 0), ("switchRadioModeAndReboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: switchRadioModeAndReboot.setStatus('obsolete')
if mibBuilder.loadTexts: switchRadioModeAndReboot.setDescription('As of 14.2, the 430 SM no longer supports multiple \n                            radio modes. It only support 450 interoperability \n                            mode.')
natTslTableSize = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 147), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natTslTableSize.setStatus('current')
if mibBuilder.loadTexts: natTslTableSize.setDescription('NAT Translation Table Size.\n            \t\t\t\t\tRange 1024-8192.')
ingressVIDPriority = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 148), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressVIDPriority.setStatus('current')
if mibBuilder.loadTexts: ingressVIDPriority.setDescription('ingress VID VLAN Priority.')
ingressVIDPriorityMode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 149), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("promote-IP-priority", 0), ("define-priority", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressVIDPriorityMode.setStatus('current')
if mibBuilder.loadTexts: ingressVIDPriorityMode.setDescription('ingress VID VLAN Priority Mode.')
providerVIDPriority = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 150), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: providerVIDPriority.setStatus('current')
if mibBuilder.loadTexts: providerVIDPriority.setDescription('Provider VID VLAN Priority.')
providerVIDPriorityMode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 151), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("promote-IP-priority", 0), ("define-priority", 1), ("copy-inner-tag-priority", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: providerVIDPriorityMode.setStatus('current')
if mibBuilder.loadTexts: providerVIDPriorityMode.setDescription('Provider VID VLAN Priority Mode.')
additionalColorCode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 152), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: additionalColorCode.setStatus('current')
if mibBuilder.loadTexts: additionalColorCode.setDescription('Add an additional color code. Setting  additionalColorCode and \n                        additionalColorCodePriority adds an entry.')
additionalColorCodePriority = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 153), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: additionalColorCodePriority.setStatus('current')
if mibBuilder.loadTexts: additionalColorCodePriority.setDescription('Add an additional color code priority. Setting  additionalColorCode and \n                        additionalColorCodePriority adds an entry.')
deleteAdditionalColorCode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 154), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deleteAdditionalColorCode.setStatus('current')
if mibBuilder.loadTexts: deleteAdditionalColorCode.setDescription('Delete an additional color code.')
bCastMIRUnits = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 155), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("kbps", 0), ("pps", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bCastMIRUnits.setStatus('current')
if mibBuilder.loadTexts: bCastMIRUnits.setDescription('Units of Broadcast/ Multicast MIR value. Set units first and then bCastMIR')
txPowerControl = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 157), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txPowerControl.setStatus('current')
if mibBuilder.loadTexts: txPowerControl.setDescription('Enable/Disable Automatic control of SM TX power.\n                            Engineering use only.')
bridgeTableSize = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 158), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTableSize.setStatus('current')
if mibBuilder.loadTexts: bridgeTableSize.setDescription('Bridge Table Size : 4 -- 4096.')
bridgeTableRestrict = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 159), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bridgeTableRestrict.setStatus('current')
if mibBuilder.loadTexts: bridgeTableRestrict.setDescription('Restrict forwarding packets from hosts for which MAC address is not in the bridge table.')
maxTxPowerEnable = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 160), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxTxPowerEnable.setStatus('current')
if mibBuilder.loadTexts: maxTxPowerEnable.setDescription("Enable Max Tx Power configuration.\n                            This is used with OID maxTxPower to set the max transmit power.\n                            This might be required in certain regions and frequency bands.\n                            See User Guide for more information.\n                            Enabling this will not allow a radio to transmit above its EIRP limit.\n                            The AP's Transmit Power Control may still adjust the Tx power down.\n                            SM only.")
maxTxPower = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 161), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-30, 27))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: maxTxPower.setStatus('current')
if mibBuilder.loadTexts: maxTxPower.setDescription("This OID is controled by OID maxTxPowerEnable.\n                            This might be required in certain regions and frequency bands.\n                            See user guide for more information.\n                            Setting this will not allow a radio to transmit above its EIRP limit.\n                            The AP's Transmit Power Control may still adjust the Tx power down.\n                            SM only.")
rfScanListTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 156), )
if mibBuilder.loadTexts: rfScanListTable.setStatus('current')
if mibBuilder.loadTexts: rfScanListTable.setDescription('The list of configured scanning frequencies on the SM or BHS.')
rfScanListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 156, 1), ).setIndexNames((0, "WHISP-SM-MIB", "rfScanListFrequency"))
if mibBuilder.loadTexts: rfScanListEntry.setStatus('current')
if mibBuilder.loadTexts: rfScanListEntry.setDescription('Entry of configured scanning frequencies on the SM or BHS.')
rfScanListFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 1, 156, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfScanListFrequency.setStatus('current')
if mibBuilder.loadTexts: rfScanListFrequency.setDescription('RF scan list.\n            The frequencies vary by product and region.')
numAuthCerts = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: numAuthCerts.setStatus('current')
if mibBuilder.loadTexts: numAuthCerts.setDescription('can have a max value of 2')
authenticationEnforce = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("aaa", 1), ("presharedkey", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authenticationEnforce.setStatus('current')
if mibBuilder.loadTexts: authenticationEnforce.setDescription('enforce SM to register with specifed Auth Enabled AP')
phase1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("eapttls", 0), ("eapMSChapV2", 1), ("eappeap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phase1.setStatus('current')
if mibBuilder.loadTexts: phase1.setDescription('Select the outer method for EAP Authentication.\n            \t\t\tNote: PEAP is not supported for MPC860 platform.')
phase2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pap", 0), ("chap", 1), ("mschapv2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phase2.setStatus('current')
if mibBuilder.loadTexts: phase2.setDescription('Select the outer method for EAP Authentication')
authOuterId = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 253))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authOuterId.setStatus('current')
if mibBuilder.loadTexts: authOuterId.setDescription('EAP Peer Username')
authPassword = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authPassword.setStatus('current')
if mibBuilder.loadTexts: authPassword.setDescription('EAP Peer password')
authUsername = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authUsername.setStatus('current')
if mibBuilder.loadTexts: authUsername.setDescription('EAP Peer Identity')
useRealm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useRealm.setStatus('current')
if mibBuilder.loadTexts: useRealm.setDescription('Enable or disable the use of realm option.')
realm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: realm.setStatus('current')
if mibBuilder.loadTexts: realm.setDescription('EAP Peer Realm')
certTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1), )
if mibBuilder.loadTexts: certTable.setStatus('current')
if mibBuilder.loadTexts: certTable.setDescription('The table of CA Certificates on SM.')
certEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1, 1), ).setIndexNames((0, "WHISP-SM-MIB", "certIndex"))
if mibBuilder.loadTexts: certEntry.setStatus('current')
if mibBuilder.loadTexts: certEntry.setDescription('Entry of Certifcates.')
certIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: certIndex.setStatus('current')
if mibBuilder.loadTexts: certIndex.setDescription('User information table index.')
cert = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cert.setStatus('current')
if mibBuilder.loadTexts: cert.setDescription('0: Inactive 1: Active')
action = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noop", 0), ("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: action.setStatus('current')
if mibBuilder.loadTexts: action.setDescription('0: No Operation 1: Delete Certificate')
certificateDN = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 7, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: certificateDN.setStatus('current')
if mibBuilder.loadTexts: certificateDN.setDescription('Distinguished Name of Certificate 2')
sessionStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionStatus.setStatus('current')
if mibBuilder.loadTexts: sessionStatus.setDescription('SM registered or not.')
rssi = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rssi.setStatus('current')
if mibBuilder.loadTexts: rssi.setDescription('Radio signal strength index.  FSK only.')
jitter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jitter.setStatus('current')
if mibBuilder.loadTexts: jitter.setDescription('A measure of multipath interference.  Applicable to FSK radios only.')
airDelay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: airDelay.setStatus('current')
if mibBuilder.loadTexts: airDelay.setDescription('Round trip delay in bits.')
radioSlicingSm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioSlicingSm.setStatus('obsolete')
if mibBuilder.loadTexts: radioSlicingSm.setDescription('This variable is deprecated.')
radioTxGainSm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioTxGainSm.setStatus('current')
if mibBuilder.loadTexts: radioTxGainSm.setDescription('Radio transmission gain setting.  Applicable to FSK radios only.')
calibrationStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: calibrationStatus.setStatus('deprecated')
if mibBuilder.loadTexts: calibrationStatus.setDescription('Varible deprecated. Please use calibrationStatusBox.')
radioDbm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioDbm.setStatus('current')
if mibBuilder.loadTexts: radioDbm.setDescription('Rx Power level.\n\t\t\t\t\t\t  For MIMO this is the combined power of the horizontal and vertical paths.')
registeredToAp = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: registeredToAp.setStatus('current')
if mibBuilder.loadTexts: registeredToAp.setDescription('AP MAC address that the SM registered to.')
dhcpCip = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpCip.setStatus('current')
if mibBuilder.loadTexts: dhcpCip.setDescription('Assigned IP address to DHCP client.')
dhcpSip = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSip.setStatus('current')
if mibBuilder.loadTexts: dhcpSip.setDescription('Public DHCP server IP.')
dhcpClientLease = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientLease.setStatus('current')
if mibBuilder.loadTexts: dhcpClientLease.setDescription('DHCP client lease time.')
dhcpCSMask = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpCSMask.setStatus('current')
if mibBuilder.loadTexts: dhcpCSMask.setDescription('Public DHCP server subnet mask.')
dhcpDfltRterIP = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpDfltRterIP.setStatus('current')
if mibBuilder.loadTexts: dhcpDfltRterIP.setDescription('Public default router IP address.')
dhcpcdns1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpcdns1.setStatus('current')
if mibBuilder.loadTexts: dhcpcdns1.setDescription('Primary public domain name server.')
dhcpcdns2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpcdns2.setStatus('current')
if mibBuilder.loadTexts: dhcpcdns2.setDescription('Secondary public domain name server.')
dhcpcdns3 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpcdns3.setStatus('current')
if mibBuilder.loadTexts: dhcpcdns3.setDescription('Third public domain name server.')
dhcpDomName = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpDomName.setStatus('current')
if mibBuilder.loadTexts: dhcpDomName.setDescription('Public domain name server.')
adaptRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adaptRate.setStatus('current')
if mibBuilder.loadTexts: adaptRate.setDescription('VC adapt rate.')
radioDbmInt = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioDbmInt.setStatus('current')
if mibBuilder.loadTexts: radioDbmInt.setDescription('Radio power level(integer).\n                            For MIMO radios this is the combined power of the horiztontal and vertical paths.')
dfsStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsStatus.setStatus('current')
if mibBuilder.loadTexts: dfsStatus.setDescription('Dynamic frequency shifting status. For DFS Radio only.')
radioTxPwr = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioTxPwr.setStatus('current')
if mibBuilder.loadTexts: radioTxPwr.setDescription('Tx Power level. Valid for FSK and OFDM SMs.')
activeRegion = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 24), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeRegion.setStatus('current')
if mibBuilder.loadTexts: activeRegion.setDescription('The active region of the radio.')
snmpBerLevel = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 6, 8))).clone(namedValues=NamedValues(("twoLevelOrMimoQPSK", 2), ("fourLevelOrMimo16QAM", 4), ("mimo64QAM", 6), ("mimo256QAM", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpBerLevel.setStatus('current')
if mibBuilder.loadTexts: snmpBerLevel.setDescription('BER level.\n\t\t\t\t\t\t  For PMP 450 systems: 2=MIMO QPSK, 4=MIMO 16-QAM, 6=MIMO64-QAM, 8=256-QAM\n\t\t\t\t\t\t  For non PMP 450: 2=2 level BER, 4=4 level BER.')
nbBitsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbBitsRcvd.setStatus('current')
if mibBuilder.loadTexts: nbBitsRcvd.setDescription('Number of BER bits received (non MIMO platforms only).')
nbPriBitsErr = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbPriBitsErr.setStatus('current')
if mibBuilder.loadTexts: nbPriBitsErr.setDescription('Number of Primary bit errors (non MIMO platforms only).')
nbSndBitsErr = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbSndBitsErr.setStatus('current')
if mibBuilder.loadTexts: nbSndBitsErr.setDescription('Number of secondary bit errors (non MIMO platforms only).')
primaryBER = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: primaryBER.setStatus('obsolete')
if mibBuilder.loadTexts: primaryBER.setDescription('Obsoleted, invalid type to represent this data. Measured Primary Bit Error Rate.')
secondaryBER = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondaryBER.setStatus('obsolete')
if mibBuilder.loadTexts: secondaryBER.setDescription('Obsoleted, invalid type to represent this data. Measured Secondary Bit Error Rate.')
totalBER = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBER.setStatus('obsolete')
if mibBuilder.loadTexts: totalBER.setDescription('Obsoleted, invalid type to represent this data. Measured Total Bit Error Rate.')
minRSSI = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minRSSI.setStatus('current')
if mibBuilder.loadTexts: minRSSI.setDescription('Measured Min. RSSI. Applicable to FSK radios only.')
maxRSSI = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRSSI.setStatus('current')
if mibBuilder.loadTexts: maxRSSI.setDescription('Measured Max. RSSI. Applicable to FSK radios only.')
minJitter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 34), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: minJitter.setStatus('current')
if mibBuilder.loadTexts: minJitter.setDescription('Measured Min. Jitter. Applicable to FSK radios only.')
maxJitter = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 35), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxJitter.setStatus('current')
if mibBuilder.loadTexts: maxJitter.setDescription('Measured Max. Jitter. Applicable to FSK radios only.')
smSessionTimer = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 36), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smSessionTimer.setStatus('current')
if mibBuilder.loadTexts: smSessionTimer.setDescription('SM current session timer.')
pppoeSessionStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 37), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeSessionStatus.setStatus('current')
if mibBuilder.loadTexts: pppoeSessionStatus.setDescription('Current PPPoE Session Status')
pppoeSessionID = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeSessionID.setStatus('current')
if mibBuilder.loadTexts: pppoeSessionID.setDescription('Current PPPoE Session ID')
pppoeIPCPAddress = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 39), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeIPCPAddress.setStatus('current')
if mibBuilder.loadTexts: pppoeIPCPAddress.setDescription('Current PPPoE IPCP IP Address')
pppoeMTUOverrideEn = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeMTUOverrideEn.setStatus('current')
if mibBuilder.loadTexts: pppoeMTUOverrideEn.setDescription('Current PPPoE MTU Override Setting')
pppoeMTUValue = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeMTUValue.setStatus('current')
if mibBuilder.loadTexts: pppoeMTUValue.setDescription('Current PPPoE MTU Value')
pppoeTimerTypeValue = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("keepAlive", 1), ("idleTimeout", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeTimerTypeValue.setStatus('current')
if mibBuilder.loadTexts: pppoeTimerTypeValue.setDescription('Current PPPoE Timer Type.  0 is disabled, 1 is Keep Alive timer, and 2 is Idle Timeout timer.')
pppoeTimeoutValue = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeTimeoutValue.setStatus('current')
if mibBuilder.loadTexts: pppoeTimeoutValue.setDescription('Current PPPoE Timeout Period.  The use of this depends on the Timer Type.  If the Timer Type is KeepAlive, then\n            \t\t\tthe timeout period is in seconds.  If the Timer Type is Idle Timeout, then the timeout period is in minutes.')
pppoeDNSServer1 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 44), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeDNSServer1.setStatus('current')
if mibBuilder.loadTexts: pppoeDNSServer1.setDescription('PPPoE DNS Server 1')
pppoeDNSServer2 = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 45), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeDNSServer2.setStatus('current')
if mibBuilder.loadTexts: pppoeDNSServer2.setDescription('PPPoE DNS Server 2')
pppoeControlBytesSent = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeControlBytesSent.setStatus('current')
if mibBuilder.loadTexts: pppoeControlBytesSent.setDescription('PPPoE Control Bytes Sent')
pppoeControlBytesReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeControlBytesReceived.setStatus('current')
if mibBuilder.loadTexts: pppoeControlBytesReceived.setDescription('PPPoE Control Bytes Received')
pppoeDataBytesSent = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeDataBytesSent.setStatus('current')
if mibBuilder.loadTexts: pppoeDataBytesSent.setDescription('PPPoE Data Bytes Sent')
pppoeDataBytesReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeDataBytesReceived.setStatus('current')
if mibBuilder.loadTexts: pppoeDataBytesReceived.setDescription('PPPoE Data Bytes Received')
pppoeEnabledStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeEnabledStatus.setStatus('current')
if mibBuilder.loadTexts: pppoeEnabledStatus.setDescription('PPPoE Enabled')
pppoeTCPMSSClampEnableStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeTCPMSSClampEnableStatus.setStatus('current')
if mibBuilder.loadTexts: pppoeTCPMSSClampEnableStatus.setDescription('PPPoE TCP MSS Clamping Enable')
pppoeACNameStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 52), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeACNameStatus.setStatus('current')
if mibBuilder.loadTexts: pppoeACNameStatus.setDescription('Current PPPoE Access Concentrator In Use')
pppoeSvcNameStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 53), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeSvcNameStatus.setStatus('current')
if mibBuilder.loadTexts: pppoeSvcNameStatus.setDescription('Current PPPoE Service Name In Use')
pppoeSessUptime = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 54), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeSessUptime.setStatus('current')
if mibBuilder.loadTexts: pppoeSessUptime.setDescription('Uptime of current PPPoE Session in ticks')
primaryBERDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 55), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: primaryBERDisplay.setStatus('current')
if mibBuilder.loadTexts: primaryBERDisplay.setDescription('Measured Primary Bit Error Rate.\n\t\t\t\t\t\t  Non MIMO platforms only.')
secondaryBERDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 56), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondaryBERDisplay.setStatus('current')
if mibBuilder.loadTexts: secondaryBERDisplay.setDescription('Measured Secondary Bit Error Rate.\n\t\t\t\t\t\t  FSK platforms only.')
totalBERDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 57), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBERDisplay.setStatus('current')
if mibBuilder.loadTexts: totalBERDisplay.setDescription('Measured Total Bit Error Rate.\n                            For MIMO this is combined both paths.')
minRadioDbm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minRadioDbm.setStatus('current')
if mibBuilder.loadTexts: minRadioDbm.setDescription('Maximum receive power of beacon in dBm.\n                            For MIMO radios, this is only available in the vertical path.')
maxRadioDbm = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 59), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRadioDbm.setStatus('current')
if mibBuilder.loadTexts: maxRadioDbm.setDescription('Maximum receive power in dBm (rounded to nearest integer).')
pppoeSessIdleTime = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 60), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoeSessIdleTime.setStatus('current')
if mibBuilder.loadTexts: pppoeSessIdleTime.setDescription('Idle Time of current PPPoE Session in ticks')
radioDbmAvg = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioDbmAvg.setStatus('current')
if mibBuilder.loadTexts: radioDbmAvg.setDescription("Average Receive Power of the AP's beacon in dBm.\n                            OFDM Radios only.\n                            For MIMO this is only the verical path, as the beacon is not transmitted on horizontal.")
zoltarFPGAFreqOffset = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zoltarFPGAFreqOffset.setStatus('current')
if mibBuilder.loadTexts: zoltarFPGAFreqOffset.setDescription('FPGA peek of 70001088')
zoltarSWFreqOffset = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: zoltarSWFreqOffset.setStatus('current')
if mibBuilder.loadTexts: zoltarSWFreqOffset.setDescription('FPGA peek of 7000108C')
airDelayns = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 64), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: airDelayns.setStatus('current')
if mibBuilder.loadTexts: airDelayns.setDescription('Round trip delay in nanoseconds.')
currentColorCode = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentColorCode.setStatus('current')
if mibBuilder.loadTexts: currentColorCode.setDescription('The current Color Code of the Registered AP/BHM. A value of -1 is return when the device is not registered.')
currentColorCodePri = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentColorCodePri.setStatus('current')
if mibBuilder.loadTexts: currentColorCodePri.setDescription('The current priority of the Registered color code')
currentChanFreq = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 67), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentChanFreq.setStatus('current')
if mibBuilder.loadTexts: currentChanFreq.setDescription('The Current Channel Frequency of the AP/BHM when in session.')
linkQualityBeacon = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 68), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityBeacon.setStatus('current')
if mibBuilder.loadTexts: linkQualityBeacon.setDescription('Engineering only.\n                        Link Quality for incoming beacons.\n                        For Gen II OFDM radios and forward.\n                        For PMP 450 and forward this is vertical path.')
dhcpServerPktXmt = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 72), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServerPktXmt.setStatus('current')
if mibBuilder.loadTexts: dhcpServerPktXmt.setDescription('Number of packets transmitted by SM DHCP Server')
dhcpServerPktRcv = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 73), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServerPktRcv.setStatus('current')
if mibBuilder.loadTexts: dhcpServerPktRcv.setDescription('Number of packets received by SM DHCP Server')
dhcpServerPktToss = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 74), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpServerPktToss.setStatus('current')
if mibBuilder.loadTexts: dhcpServerPktToss.setDescription('Number of packets tossed by SM DHCP Server')
receiveFragmentsModulationPercentage = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 86), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveFragmentsModulationPercentage.setStatus('current')
if mibBuilder.loadTexts: receiveFragmentsModulationPercentage.setDescription('Engineering use only.\n                            The percentage of recent fragments received at which modulation.\n                            For Gen II OFDM only and forward.')
fragmentsReceived1XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 87), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived1XVertical.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived1XVertical.setDescription('Engineering use only.\n                            Number of fragments received in 1x modulation.\n                            For GenII OFDM only and forward.\n                            For MIMO this is the vertical path.')
fragmentsReceived2XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 88), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived2XVertical.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived2XVertical.setDescription('Engineering use only.\n                                Number of fragments received in 2x modulation.\n                                For GenII OFDM only and forward.\n                                For MIMO this is the vertical path.')
fragmentsReceived3XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 89), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived3XVertical.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived3XVertical.setDescription('Engineering use only.\n                                Number of fragments received in 3x modulation.\n                                For GenII OFDM only and forward.\n                                For MIMO this is the vertical path.')
fragmentsReceived4XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 90), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived4XVertical.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived4XVertical.setDescription('Engineering use only.\n                                Number of fragments received in 4x modulation.\n                                For GenII OFDM only and forward.\n                                For MIMO this is the vertical path.')
linkQualityData1XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 91), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData1XVertical.setStatus('current')
if mibBuilder.loadTexts: linkQualityData1XVertical.setDescription('Engineering use only.\n                            Link Quality for the data VC for QPSK modulation (1X).\n                            For Gen II OFDM radios and forward only.\n                            For MIMO this is the vertical path.')
linkQualityData2XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 92), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData2XVertical.setStatus('current')
if mibBuilder.loadTexts: linkQualityData2XVertical.setDescription('Engineering use only.\n                            Link Quality for the data VC for 16-QAM modulation (2X).\n                            For Gen II OFDM radios and forward only.\n                            For MIMO this is the vertical path.')
linkQualityData3XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 93), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData3XVertical.setStatus('current')
if mibBuilder.loadTexts: linkQualityData3XVertical.setDescription('Engineering use only.\n                            Link Quality for the data VC for 64-QAM modulation (3X).\n                            For Gen II OFDM radios and forward only.\n                            For MIMO this is the vertical path.')
linkQualityData4XVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 94), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData4XVertical.setStatus('current')
if mibBuilder.loadTexts: linkQualityData4XVertical.setDescription('Engineering use only.\n                            Link Quality for the data VC for 256-QAM modulation (4X).\n                            For Gen II OFDM radios and forward only.\n                            For MIMO this is the vertical path.')
signalToNoiseRatioSMVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 95), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalToNoiseRatioSMVertical.setStatus('current')
if mibBuilder.loadTexts: signalToNoiseRatioSMVertical.setDescription('An estimated signal to noise ratio based on the last received data.\n                                For GenII OFDM only and forward.\n                                For MIMO this is the vertical antenna.\n                                Will return zero if Signal to Noise Ratio Calculation is disabled.')
rfStatTxSuppressionCount = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 96), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rfStatTxSuppressionCount.setStatus('current')
if mibBuilder.loadTexts: rfStatTxSuppressionCount.setDescription('RF Scheduler Stats DFS TX Suppression Count')
bridgecbUplinkCreditRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 97), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbUplinkCreditRate.setStatus('current')
if mibBuilder.loadTexts: bridgecbUplinkCreditRate.setDescription('Sustained uplink data rate.')
bridgecbUplinkCreditLimit = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 98), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbUplinkCreditLimit.setStatus('current')
if mibBuilder.loadTexts: bridgecbUplinkCreditLimit.setDescription('Uplink Burst Allocation.')
bridgecbDownlinkCreditRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 99), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbDownlinkCreditRate.setStatus('current')
if mibBuilder.loadTexts: bridgecbDownlinkCreditRate.setDescription('Sustained uplink data rate.')
bridgecbDownlinkCreditLimit = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 100), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbDownlinkCreditLimit.setStatus('current')
if mibBuilder.loadTexts: bridgecbDownlinkCreditLimit.setDescription('Uplink Burst Allocation.')
mimoQpskBerDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 101), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimoQpskBerDisplay.setStatus('current')
if mibBuilder.loadTexts: mimoQpskBerDisplay.setDescription('QPSK BER statistics.\n                            MIMO platforms only.')
mimo16QamBerDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 102), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimo16QamBerDisplay.setStatus('current')
if mibBuilder.loadTexts: mimo16QamBerDisplay.setDescription('16-QAM BER statistics\n                            MIMO platforms only.\n                            Engineering use only.')
mimo64QamBerDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 103), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimo64QamBerDisplay.setStatus('current')
if mibBuilder.loadTexts: mimo64QamBerDisplay.setDescription('64-QAM BER statistics\n                            MIMO platforms only.\n                            Engineering use only.')
mimo256QamBerDisplay = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 104), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimo256QamBerDisplay.setStatus('current')
if mibBuilder.loadTexts: mimo256QamBerDisplay.setDescription('256-QAM BER statistics\n                            MIMO platforms only.\n                            Engineering use only.')
mimoBerRcvModulationType = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 105), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimoBerRcvModulationType.setStatus('current')
if mibBuilder.loadTexts: mimoBerRcvModulationType.setDescription('Receive modulation type.\n                            MIMO platforms only.')
signalToNoiseRatioSMHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 106), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalToNoiseRatioSMHorizontal.setStatus('current')
if mibBuilder.loadTexts: signalToNoiseRatioSMHorizontal.setDescription('An estimated signal to noise ratio based on the last received data for horizontal antenna.\n                                MIMO radios only.\n                                Will return zero if Signal to Noise Ratio Calculation is disabled.\n                                When operating in MIMO-A will return 0.')
maxRadioDbmDeprecated = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 107), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRadioDbmDeprecated.setStatus('deprecated')
if mibBuilder.loadTexts: maxRadioDbmDeprecated.setDescription('This OID was inadvertently moved in 12.0.2.  Please use maxRadioDbm.  This OID is deprecated\n                             and kept for backwards compatibility.')
signalStrengthRatio = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 108), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalStrengthRatio.setStatus('current')
if mibBuilder.loadTexts: signalStrengthRatio.setDescription('Signal Strength Ratio in dB is the power received by the vertical antenna input (dB) -\n                                power received by the horizontal antenna input (dB).\n                                MIMO radios only.')
fragmentsReceived1XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 109), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived1XHorizontal.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived1XHorizontal.setDescription('Engineering use only.\n                            Number of fragments received in 1x modulation.\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
fragmentsReceived2XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 110), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived2XHorizontal.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived2XHorizontal.setDescription('Engineering use only.\n                            Number of fragments received in 2x modulation.\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
fragmentsReceived3XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 111), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived3XHorizontal.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived3XHorizontal.setDescription('Engineering use only.\n                            Number of fragments received in 3x modulation.\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
fragmentsReceived4XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 112), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fragmentsReceived4XHorizontal.setStatus('current')
if mibBuilder.loadTexts: fragmentsReceived4XHorizontal.setDescription('Engineering use only.\n                            Number of fragments received in 4x modulation.\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
linkQualityData1XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 113), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData1XHorizontal.setStatus('current')
if mibBuilder.loadTexts: linkQualityData1XHorizontal.setDescription('Engineering use only.\n                            Link Quality for the data VC for QPSK modulation (1X).\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
linkQualityData2XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 114), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData2XHorizontal.setStatus('current')
if mibBuilder.loadTexts: linkQualityData2XHorizontal.setDescription('Engineering use only.\n                            Link Quality for the data VC for 16-QAM modulation (2X).\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
linkQualityData3XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 115), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData3XHorizontal.setStatus('current')
if mibBuilder.loadTexts: linkQualityData3XHorizontal.setDescription('Engineering use only.\n                            Link Quality for the data VC for 64-QAM modulation (3X).\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
linkQualityData4XHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 116), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkQualityData4XHorizontal.setStatus('current')
if mibBuilder.loadTexts: linkQualityData4XHorizontal.setDescription('Engineering use only.\n                            Link Quality for the data VC for 256-QAM modulation (4X).\n                            For MIMO radios only.\n                            For MIMO this is the horizontal path.\n                            Fragments received in MIMO-A will only be counted on vertical.')
radioDbmHorizontal = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 117), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioDbmHorizontal.setStatus('current')
if mibBuilder.loadTexts: radioDbmHorizontal.setDescription('Receive power level of the horizontal antenna in dBm.\n                                MIMO radios only.')
radioDbmVertical = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 118), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioDbmVertical.setStatus('current')
if mibBuilder.loadTexts: radioDbmVertical.setDescription('Receive power level of the vertical antenna in dBm.\n                                MIMO radios only.')
bridgecbDownlinkMaxBurstBitRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 119), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbDownlinkMaxBurstBitRate.setStatus('current')
if mibBuilder.loadTexts: bridgecbDownlinkMaxBurstBitRate.setDescription('Maximum burst downlink rate.')
bridgecbUplinkMaxBurstBitRate = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 120), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgecbUplinkMaxBurstBitRate.setStatus('current')
if mibBuilder.loadTexts: bridgecbUplinkMaxBurstBitRate.setDescription('Maximum burst uplink Rate.')
currentCyclicPrefix = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 121), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("one-quarter", 0), ("one-eighth", 1), ("one-sixteenth", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentCyclicPrefix.setStatus('current')
if mibBuilder.loadTexts: currentCyclicPrefix.setDescription('The Current Cyclic Prefix of the AP/BHM when in session.')
currentBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 122), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("bandwidth5mhz", 1), ("bandwidth7MHz", 2), ("bandwidth10mhz", 3), ("bandwidth15mhz", 4), ("bandwidth20mhz", 5), ("bandwidth30mhz", 6), ("bandwidth40MHz", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentBandwidth.setStatus('current')
if mibBuilder.loadTexts: currentBandwidth.setDescription('The Current Bandwidth of the AP/BHM when in session.')
berPwrRxFPGAPathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 123), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berPwrRxFPGAPathA.setStatus('current')
if mibBuilder.loadTexts: berPwrRxFPGAPathA.setDescription('BER power level on FPGA Rx Path A of SM.  Engineering Use Only.')
berPwrRxFPGAPathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 124), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: berPwrRxFPGAPathB.setStatus('current')
if mibBuilder.loadTexts: berPwrRxFPGAPathB.setDescription('BER power level on FPGA Rx Path B of SM.  Engineering Use Only.')
rawBERPwrRxPathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 125), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rawBERPwrRxPathA.setStatus('current')
if mibBuilder.loadTexts: rawBERPwrRxPathA.setDescription('Raw unadjusted BER power level on FPGA Rx Path A of SM.  Engineering Use Only.')
rawBERPwrRxPathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 126), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rawBERPwrRxPathB.setStatus('current')
if mibBuilder.loadTexts: rawBERPwrRxPathB.setDescription('Raw unadjusted BER power level on FPGA Rx Path B of SM.  Engineering Use Only.')
radioModeStatus = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 127), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("pmp430", 1), ("pmp450Interoperability", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioModeStatus.setStatus('deprecated')
if mibBuilder.loadTexts: radioModeStatus.setDescription('The current radio mode that SM is operating in.\n                        PMP 430 SMs only.\n                        As of 14.2, the 430 SM only supports PMP 450\n                        interoperability mode, so this will only return\n                        pmp450Interoperability.')
adaptRateLowPri = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 128), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6, 8))).clone(namedValues=NamedValues(("noSession", 0), ("rate1X", 1), ("rate2X", 2), ("rete3X", 3), ("rate4X", 4), ("rate6X", 6), ("rate8X", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adaptRateLowPri.setStatus('current')
if mibBuilder.loadTexts: adaptRateLowPri.setDescription('The current transmitting rate of the low priority VC.\n                            0 : SM is not in session\n                            1 : 1X QPSK SISO\n                            2 : 2X 16-QAM SISO or QPSK MIMO\n                            3 : 3X 64-QAM SISO\n                            4 : 4X 256-QAM SISO or 16-QAM MIMO\n                            6 : 6X 64-QAM MIMO\n                            8 : 8X 256-QAM MIMO')
adaptRateHighPri = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 129), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 3, 4, 6, 8))).clone(namedValues=NamedValues(("noHighPriorityChannel", -1), ("noSession", 0), ("rate1X", 1), ("rate2X", 2), ("rete3X", 3), ("rate4X", 4), ("rate6X", 6), ("rate8X", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adaptRateHighPri.setStatus('current')
if mibBuilder.loadTexts: adaptRateHighPri.setDescription('The current transmitting rate of the high priority VC.\n                            -1 : High Priority Channel not configured\n                            0 : SM is not in session\n                            1 : 1X QPSK SISO\n                            2 : 2X 16-QAM SISO or QPSK MIMO\n                            3 : 3X 64-QAM SISO\n                            4 : 4X 256-QAM SISO or 16-QAM MIMO\n                            6 : 6X 64-QAM MIMO\n                            8 : 8X 256-QAM MIMO')
bitErrorsQSPKpathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 130), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrorsQSPKpathA.setStatus('current')
if mibBuilder.loadTexts: bitErrorsQSPKpathA.setDescription('Number of bit errors received from BER packet at QPSK path A.\n                            Valid MIMO platforms only.')
bitErrorsQSPKpathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 131), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrorsQSPKpathB.setStatus('current')
if mibBuilder.loadTexts: bitErrorsQSPKpathB.setDescription('Number of bit errors received from BER packet at QPSK path B.\n                            Valid MIMO platforms only.')
bitErrors16QAMpathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 132), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors16QAMpathA.setStatus('current')
if mibBuilder.loadTexts: bitErrors16QAMpathA.setDescription('Number of bit errors received from BER packet at 16-QAM path A.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitErrors16QAMpathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 133), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors16QAMpathB.setStatus('current')
if mibBuilder.loadTexts: bitErrors16QAMpathB.setDescription('Number of bit errors received from BER packet at 16-QAM path B.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitErrors64QAMpathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 134), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors64QAMpathA.setStatus('current')
if mibBuilder.loadTexts: bitErrors64QAMpathA.setDescription('Number of bit errors received from BER packet at 64-QAM path A.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitErrors64QAMpathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 135), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors64QAMpathB.setStatus('current')
if mibBuilder.loadTexts: bitErrors64QAMpathB.setDescription('Number of bit errors received from BER packet at 64-QAM path B.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitErrors256QAMpathA = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 136), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors256QAMpathA.setStatus('current')
if mibBuilder.loadTexts: bitErrors256QAMpathA.setDescription('Number of bit errors received from BER packet at 256-QAM path A.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitErrors256QAMpathB = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 137), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitErrors256QAMpathB.setStatus('current')
if mibBuilder.loadTexts: bitErrors256QAMpathB.setDescription('Number of bit errors received from BER packet at 256-QAM path B.\n                            Valid MIMO platforms only.\n                            Engineering use only.')
bitsReceivedPerPathModulation = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 138), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitsReceivedPerPathModulation.setStatus('current')
if mibBuilder.loadTexts: bitsReceivedPerPathModulation.setDescription('Number of bit received from BER.\n                            To calculate Bit Error Rate, take bit errors at a modulation and path and divide by this OID.\n                            To get combined BER add errors and divide by this multiplied by each path and modulation.\n                            i.e. MIMO QPSK combined BER = ((errors on path A) + (errors on path B))/(bits recieved per path modulation * 2)\n                            Valid MIMO platforms only.')
beaconsPercentReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 139), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: beaconsPercentReceived.setStatus('current')
if mibBuilder.loadTexts: beaconsPercentReceived.setDescription('The current percentage of beacons that the SM/BHS successfully receiving.')
mapsPercentReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 140), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mapsPercentReceived.setStatus('current')
if mibBuilder.loadTexts: mapsPercentReceived.setDescription('PMP 450 only.\n                            The current percentage of scheduling maps that the SM/BHS successfully receiving.')
natTslTableEntries = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 141), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natTslTableEntries.setStatus('current')
if mibBuilder.loadTexts: natTslTableEntries.setDescription('Number of Entries in NAT Translation Table.')
maxReceivePower = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 142), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxReceivePower.setStatus('current')
if mibBuilder.loadTexts: maxReceivePower.setDescription('Maximum receive power level for this session.\n            \t\t\t\t\tMIMO radios only.')
beaconsPercentMinReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 143), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: beaconsPercentMinReceived.setStatus('current')
if mibBuilder.loadTexts: beaconsPercentMinReceived.setDescription('The percentage of the least number of beacons that the SM/BHS successfully received in a 16 second window for the last 15 minutes. This will be updated only once in 15 minutes.')
beaconsPercentMaxReceived = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 144), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: beaconsPercentMaxReceived.setStatus('current')
if mibBuilder.loadTexts: beaconsPercentMaxReceived.setDescription('The percentage of the maximum number of beacons that the SM/BHS successfully received in a 16 second window for the last 15 minutes. This will be updated only once in 15 minutes.')
beaconsPercentReceivedSnapshot = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 145), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: beaconsPercentReceivedSnapshot.setStatus('current')
if mibBuilder.loadTexts: beaconsPercentReceivedSnapshot.setDescription('The percentage of beacons that the SM/BHS successfully received for the last 15 minutes. This will be updated only once in 15 minutes.')
smSectorID = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 146), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smSectorID.setStatus('current')
if mibBuilder.loadTexts: smSectorID.setDescription('The current Sector ID of the Registered AP/BHM. \n                 \t\t\tA value of -1 is return when the device is not registered or AP/BHM does not support Sector ID.')
scanCycleCount = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 147), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: scanCycleCount.setStatus('current')
if mibBuilder.loadTexts: scanCycleCount.setDescription('The number of scan cycles.  This increments after the SM completes scanning every configured frequency and channel bandwidth.')
bridgeCbErrStatBridgeDropCount = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 148), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bridgeCbErrStatBridgeDropCount.setStatus('current')
if mibBuilder.loadTexts: bridgeCbErrStatBridgeDropCount.setDescription('Packet drop count for hosts with MAC address not in bridge table')
dhcpServerTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 19), )
if mibBuilder.loadTexts: dhcpServerTable.setStatus('current')
if mibBuilder.loadTexts: dhcpServerTable.setDescription('The table of DHCP server hosts.')
dhcpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 19, 1), ).setIndexNames((0, "WHISP-SM-MIB", "hostIp"))
if mibBuilder.loadTexts: dhcpServerEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpServerEntry.setDescription('Entry of DHCP server hosts.')
hostIp = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 19, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIp.setStatus('current')
if mibBuilder.loadTexts: hostIp.setDescription('DHCP server IP address.')
hostMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 19, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostMacAddress.setStatus('current')
if mibBuilder.loadTexts: hostMacAddress.setDescription('Private host MAC address.')
hostLease = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 2, 19, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostLease.setStatus('current')
if mibBuilder.loadTexts: hostLease.setDescription('Lease time assigned by DHCP server host.')
whispSmConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 3, 1)).setObjects(("WHISP-SM-MIB", "rfScanListBandFilter"), ("WHISP-SM-MIB", "rfScanList"), ("WHISP-SM-MIB", "powerUpMode"), ("WHISP-SM-MIB", "lanIpSm"), ("WHISP-SM-MIB", "lanMaskSm"), ("WHISP-SM-MIB", "defaultGwSm"), ("WHISP-SM-MIB", "networkAccess"), ("WHISP-SM-MIB", "authKeySm"), ("WHISP-SM-MIB", "enable8023link"), ("WHISP-SM-MIB", "authKeyOption"), ("WHISP-SM-MIB", "timingPulseGated"), ("WHISP-SM-MIB", "naptPrivateIP"), ("WHISP-SM-MIB", "naptPrivateSubnetMask"), ("WHISP-SM-MIB", "naptPublicIP"), ("WHISP-SM-MIB", "naptPublicSubnetMask"), ("WHISP-SM-MIB", "naptPublicGatewayIP"), ("WHISP-SM-MIB", "naptRFPublicIP"), ("WHISP-SM-MIB", "naptRFPublicSubnetMask"), ("WHISP-SM-MIB", "naptRFPublicGateway"), ("WHISP-SM-MIB", "naptEnable"), ("WHISP-SM-MIB", "arpCacheTimeout"), ("WHISP-SM-MIB", "tcpGarbageCollectTmout"), ("WHISP-SM-MIB", "udpGarbageCollectTmout"), ("WHISP-SM-MIB", "natTslTableSize"), ("WHISP-SM-MIB", "dhcpClientEnable"), ("WHISP-SM-MIB", "dhcpServerEnable"), ("WHISP-SM-MIB", "dhcpServerLeaseTime"), ("WHISP-SM-MIB", "dhcpIPStart"), ("WHISP-SM-MIB", "dnsAutomatic"), ("WHISP-SM-MIB", "prefferedDNSIP"), ("WHISP-SM-MIB", "alternateDNSIP"), ("WHISP-SM-MIB", "natDNSProxyEnable"), ("WHISP-SM-MIB", "spectrumAnalysisDisplay"), ("WHISP-SM-MIB", "dmzIP"), ("WHISP-SM-MIB", "dmzEnable"), ("WHISP-SM-MIB", "dhcpNumIPsToLease"), ("WHISP-SM-MIB", "pppoeFilter"), ("WHISP-SM-MIB", "smbFilter"), ("WHISP-SM-MIB", "snmpFilter"), ("WHISP-SM-MIB", "userP1Filter"), ("WHISP-SM-MIB", "userP2Filter"), ("WHISP-SM-MIB", "userP3Filter"), ("WHISP-SM-MIB", "allOtherIpFilter"), ("WHISP-SM-MIB", "allIpv4Filter"), ("WHISP-SM-MIB", "upLinkBCastFilter"), ("WHISP-SM-MIB", "arpFilter"), ("WHISP-SM-MIB", "allOthersFilter"), ("WHISP-SM-MIB", "userDefinedPort1"), ("WHISP-SM-MIB", "port1TCPFilter"), ("WHISP-SM-MIB", "port1UDPFilter"), ("WHISP-SM-MIB", "userDefinedPort2"), ("WHISP-SM-MIB", "port2TCPFilter"), ("WHISP-SM-MIB", "port2UDPFilter"), ("WHISP-SM-MIB", "userDefinedPort3"), ("WHISP-SM-MIB", "port3TCPFilter"), ("WHISP-SM-MIB", "port3UDPFilter"), ("WHISP-SM-MIB", "bootpcFilter"), ("WHISP-SM-MIB", "bootpsFilter"), ("WHISP-SM-MIB", "ip4MultFilter"), ("WHISP-SM-MIB", "ingressVID"), ("WHISP-SM-MIB", "ingressVIDPriority"), ("WHISP-SM-MIB", "ingressVIDPriorityMode"), ("WHISP-SM-MIB", "providerVIDPriority"), ("WHISP-SM-MIB", "providerVIDPriorityMode"), ("WHISP-SM-MIB", "lowPriorityUplinkCIR"), ("WHISP-SM-MIB", "lowPriorityDownlinkCIR"), ("WHISP-SM-MIB", "hiPriorityChannel"), ("WHISP-SM-MIB", "hiPriorityUplinkCIR"), ("WHISP-SM-MIB", "hiPriorityDownlinkCIR"), ("WHISP-SM-MIB", "smRateAdapt"), ("WHISP-SM-MIB", "upLnkMaxBurstDataRate"), ("WHISP-SM-MIB", "upLnkDataRate"), ("WHISP-SM-MIB", "upLnkLimit"), ("WHISP-SM-MIB", "dwnLnkMaxBurstDataRate"), ("WHISP-SM-MIB", "cyclicPrefixScan"), ("WHISP-SM-MIB", "bandwidthScan"), ("WHISP-SM-MIB", "apSelection"), ("WHISP-SM-MIB", "radioBandscanConfig"), ("WHISP-SM-MIB", "forcepoweradjust"), ("WHISP-SM-MIB", "clearBerrResults"), ("WHISP-SM-MIB", "berrautoupdateflag"), ("WHISP-SM-MIB", "testSMBER"), ("WHISP-SM-MIB", "dwnLnkDataRate"), ("WHISP-SM-MIB", "dwnLnkLimit"), ("WHISP-SM-MIB", "dfsConfig"), ("WHISP-SM-MIB", "ethAccessFilterEnable"), ("WHISP-SM-MIB", "ipAccessFilterEnable"), ("WHISP-SM-MIB", "allowedIPAccess1"), ("WHISP-SM-MIB", "allowedIPAccess2"), ("WHISP-SM-MIB", "allowedIPAccess3"), ("WHISP-SM-MIB", "allowedIPAccessNMLength1"), ("WHISP-SM-MIB", "allowedIPAccessNMLength2"), ("WHISP-SM-MIB", "allowedIPAccessNMLength3"), ("WHISP-SM-MIB", "rfDhcpState"), ("WHISP-SM-MIB", "bCastMIR"), ("WHISP-SM-MIB", "bhsReReg"), ("WHISP-SM-MIB", "smLEDModeFlag"), ("WHISP-SM-MIB", "ethAccessEnable"), ("WHISP-SM-MIB", "pppoeEnable"), ("WHISP-SM-MIB", "pppoeAuthenticationType"), ("WHISP-SM-MIB", "pppoeAccessConcentrator"), ("WHISP-SM-MIB", "pppoeServiceName"), ("WHISP-SM-MIB", "pppoeUserName"), ("WHISP-SM-MIB", "pppoePassword"), ("WHISP-SM-MIB", "pppoeTCPMSSClampEnable"), ("WHISP-SM-MIB", "pppoeMTUOverrideEnable"), ("WHISP-SM-MIB", "pppoeMTUOverrideValue"), ("WHISP-SM-MIB", "pppoeTimerType"), ("WHISP-SM-MIB", "pppoeTimeoutPeriod"), ("WHISP-SM-MIB", "timedSpectrumAnalysisDuration"), ("WHISP-SM-MIB", "spectrumAnalysisScanBandwidth"), ("WHISP-SM-MIB", "spectrumAnalysisOnBoot"), ("WHISP-SM-MIB", "spectrumAnalysisAction"), ("WHISP-SM-MIB", "pppoeConnectOD"), ("WHISP-SM-MIB", "pppoeDisconnectOD"), ("WHISP-SM-MIB", "smAntennaType"), ("WHISP-SM-MIB", "natConnectionType"), ("WHISP-SM-MIB", "wanPingReplyEnable"), ("WHISP-SM-MIB", "packetFilterDirection"), ("WHISP-SM-MIB", "colorCode2"), ("WHISP-SM-MIB", "colorCodepriority2"), ("WHISP-SM-MIB", "colorCode3"), ("WHISP-SM-MIB", "colorCodepriority3"), ("WHISP-SM-MIB", "colorCode4"), ("WHISP-SM-MIB", "colorCodepriority4"), ("WHISP-SM-MIB", "colorCode5"), ("WHISP-SM-MIB", "colorCodepriority5"), ("WHISP-SM-MIB", "colorCode6"), ("WHISP-SM-MIB", "colorCodepriority6"), ("WHISP-SM-MIB", "colorCode7"), ("WHISP-SM-MIB", "colorCodepriority7"), ("WHISP-SM-MIB", "colorCode8"), ("WHISP-SM-MIB", "colorCodepriority8"), ("WHISP-SM-MIB", "colorCode9"), ("WHISP-SM-MIB", "colorCodepriority9"), ("WHISP-SM-MIB", "colorCode10"), ("WHISP-SM-MIB", "colorCodepriority10"), ("WHISP-SM-MIB", "additionalColorCode"), ("WHISP-SM-MIB", "additionalColorCodePriority"), ("WHISP-SM-MIB", "deleteAdditionalColorCode"), ("WHISP-SM-MIB", "bridgeTableSize"), ("WHISP-SM-MIB", "bridgeTableRestrict"), ("WHISP-SM-MIB", "berDeModSelect"), ("WHISP-SM-MIB", "multicastVCRcvRate"), ("WHISP-SM-MIB", "syslogServerApPreferred"), ("WHISP-SM-MIB", "syslogMinLevelApPreferred"), ("WHISP-SM-MIB", "syslogSMXmitSetting"), ("WHISP-SM-MIB", "syslogSMXmitControl"), ("WHISP-SM-MIB", "bCastMIRUnits"), ("WHISP-SM-MIB", "naptRemoteManage"), ("WHISP-SM-MIB", "maxTxPowerEnable"), ("WHISP-SM-MIB", "maxTxPower"), ("WHISP-SM-MIB", "txPowerControl"), ("WHISP-SM-MIB", "eapPeerAAAServerCommonName"), ("WHISP-SM-MIB", "pmp430ApRegistrationOptions"), ("WHISP-SM-MIB", "switchRadioModeAndReboot"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    whispSmConfigGroup = whispSmConfigGroup.setStatus('current')
if mibBuilder.loadTexts: whispSmConfigGroup.setDescription('Canopy Subscriber Module configuration group.')
whispSmStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 3, 2)).setObjects(("WHISP-SM-MIB", "natTslTableEntries"), ("WHISP-SM-MIB", "sessionStatus"), ("WHISP-SM-MIB", "rssi"), ("WHISP-SM-MIB", "jitter"), ("WHISP-SM-MIB", "airDelay"), ("WHISP-SM-MIB", "radioSlicingSm"), ("WHISP-SM-MIB", "radioTxGainSm"), ("WHISP-SM-MIB", "calibrationStatus"), ("WHISP-SM-MIB", "radioDbm"), ("WHISP-SM-MIB", "registeredToAp"), ("WHISP-SM-MIB", "dhcpCip"), ("WHISP-SM-MIB", "dhcpSip"), ("WHISP-SM-MIB", "dhcpClientLease"), ("WHISP-SM-MIB", "dhcpCSMask"), ("WHISP-SM-MIB", "dhcpDfltRterIP"), ("WHISP-SM-MIB", "dhcpcdns1"), ("WHISP-SM-MIB", "dhcpcdns2"), ("WHISP-SM-MIB", "dhcpcdns3"), ("WHISP-SM-MIB", "dhcpDomName"), ("WHISP-SM-MIB", "adaptRate"), ("WHISP-SM-MIB", "adaptRateLowPri"), ("WHISP-SM-MIB", "adaptRateHighPri"), ("WHISP-SM-MIB", "bitErrorsQSPKpathA"), ("WHISP-SM-MIB", "bitErrorsQSPKpathB"), ("WHISP-SM-MIB", "bitErrors16QAMpathA"), ("WHISP-SM-MIB", "bitErrors16QAMpathB"), ("WHISP-SM-MIB", "bitErrors64QAMpathA"), ("WHISP-SM-MIB", "bitErrors64QAMpathB"), ("WHISP-SM-MIB", "bitErrors256QAMpathA"), ("WHISP-SM-MIB", "bitErrors256QAMpathB"), ("WHISP-SM-MIB", "bitsReceivedPerPathModulation"), ("WHISP-SM-MIB", "radioDbmInt"), ("WHISP-SM-MIB", "dfsStatus"), ("WHISP-SM-MIB", "radioTxPwr"), ("WHISP-SM-MIB", "activeRegion"), ("WHISP-SM-MIB", "snmpBerLevel"), ("WHISP-SM-MIB", "nbBitsRcvd"), ("WHISP-SM-MIB", "nbPriBitsErr"), ("WHISP-SM-MIB", "nbSndBitsErr"), ("WHISP-SM-MIB", "primaryBER"), ("WHISP-SM-MIB", "secondaryBER"), ("WHISP-SM-MIB", "totalBER"), ("WHISP-SM-MIB", "minRSSI"), ("WHISP-SM-MIB", "maxRSSI"), ("WHISP-SM-MIB", "minJitter"), ("WHISP-SM-MIB", "maxJitter"), ("WHISP-SM-MIB", "smSessionTimer"), ("WHISP-SM-MIB", "pppoeSessionStatus"), ("WHISP-SM-MIB", "pppoeSessionID"), ("WHISP-SM-MIB", "pppoeIPCPAddress"), ("WHISP-SM-MIB", "pppoeMTUOverrideEn"), ("WHISP-SM-MIB", "pppoeMTUValue"), ("WHISP-SM-MIB", "pppoeTimerTypeValue"), ("WHISP-SM-MIB", "pppoeTimeoutValue"), ("WHISP-SM-MIB", "pppoeDNSServer1"), ("WHISP-SM-MIB", "pppoeDNSServer2"), ("WHISP-SM-MIB", "pppoeControlBytesSent"), ("WHISP-SM-MIB", "pppoeControlBytesReceived"), ("WHISP-SM-MIB", "pppoeDataBytesSent"), ("WHISP-SM-MIB", "pppoeDataBytesReceived"), ("WHISP-SM-MIB", "pppoeEnabledStatus"), ("WHISP-SM-MIB", "pppoeTCPMSSClampEnableStatus"), ("WHISP-SM-MIB", "pppoeACNameStatus"), ("WHISP-SM-MIB", "pppoeSvcNameStatus"), ("WHISP-SM-MIB", "pppoeSessUptime"), ("WHISP-SM-MIB", "primaryBERDisplay"), ("WHISP-SM-MIB", "secondaryBERDisplay"), ("WHISP-SM-MIB", "totalBERDisplay"), ("WHISP-SM-MIB", "mimoQpskBerDisplay"), ("WHISP-SM-MIB", "mimo16QamBerDisplay"), ("WHISP-SM-MIB", "mimo64QamBerDisplay"), ("WHISP-SM-MIB", "mimo256QamBerDisplay"), ("WHISP-SM-MIB", "mimoBerRcvModulationType"), ("WHISP-SM-MIB", "minRadioDbm"), ("WHISP-SM-MIB", "maxRadioDbm"), ("WHISP-SM-MIB", "maxRadioDbmDeprecated"), ("WHISP-SM-MIB", "pppoeSessIdleTime"), ("WHISP-SM-MIB", "radioDbmAvg"), ("WHISP-SM-MIB", "zoltarFPGAFreqOffset"), ("WHISP-SM-MIB", "zoltarSWFreqOffset"), ("WHISP-SM-MIB", "airDelayns"), ("WHISP-SM-MIB", "smSectorID"), ("WHISP-SM-MIB", "scanCycleCount"), ("WHISP-SM-MIB", "currentColorCode"), ("WHISP-SM-MIB", "currentColorCodePri"), ("WHISP-SM-MIB", "currentChanFreq"), ("WHISP-SM-MIB", "linkQualityBeacon"), ("WHISP-SM-MIB", "currentCyclicPrefix"), ("WHISP-SM-MIB", "currentBandwidth"), ("WHISP-SM-MIB", "berPwrRxFPGAPathA"), ("WHISP-SM-MIB", "berPwrRxFPGAPathB"), ("WHISP-SM-MIB", "rawBERPwrRxPathA"), ("WHISP-SM-MIB", "rawBERPwrRxPathB"), ("WHISP-SM-MIB", "linkQualityData1XVertical"), ("WHISP-SM-MIB", "linkQualityData2XVertical"), ("WHISP-SM-MIB", "linkQualityData3XVertical"), ("WHISP-SM-MIB", "linkQualityData4XVertical"), ("WHISP-SM-MIB", "linkQualityData1XHorizontal"), ("WHISP-SM-MIB", "linkQualityData2XHorizontal"), ("WHISP-SM-MIB", "linkQualityData3XHorizontal"), ("WHISP-SM-MIB", "linkQualityData4XHorizontal"), ("WHISP-SM-MIB", "signalToNoiseRatioSMVertical"), ("WHISP-SM-MIB", "signalToNoiseRatioSMHorizontal"), ("WHISP-SM-MIB", "signalStrengthRatio"), ("WHISP-SM-MIB", "radioDbmHorizontal"), ("WHISP-SM-MIB", "radioDbmVertical"), ("WHISP-SM-MIB", "rfStatTxSuppressionCount"), ("WHISP-SM-MIB", "receiveFragmentsModulationPercentage"), ("WHISP-SM-MIB", "fragmentsReceived1XVertical"), ("WHISP-SM-MIB", "fragmentsReceived2XVertical"), ("WHISP-SM-MIB", "fragmentsReceived3XVertical"), ("WHISP-SM-MIB", "fragmentsReceived4XVertical"), ("WHISP-SM-MIB", "fragmentsReceived1XHorizontal"), ("WHISP-SM-MIB", "fragmentsReceived2XHorizontal"), ("WHISP-SM-MIB", "fragmentsReceived3XHorizontal"), ("WHISP-SM-MIB", "fragmentsReceived4XHorizontal"), ("WHISP-SM-MIB", "beaconsPercentReceived"), ("WHISP-SM-MIB", "mapsPercentReceived"), ("WHISP-SM-MIB", "beaconsPercentMinReceived"), ("WHISP-SM-MIB", "beaconsPercentMaxReceived"), ("WHISP-SM-MIB", "beaconsPercentReceivedSnapshot"), ("WHISP-SM-MIB", "maxReceivePower"), ("WHISP-SM-MIB", "bridgecbUplinkCreditRate"), ("WHISP-SM-MIB", "bridgecbUplinkCreditLimit"), ("WHISP-SM-MIB", "bridgecbDownlinkCreditRate"), ("WHISP-SM-MIB", "bridgecbDownlinkCreditLimit"), ("WHISP-SM-MIB", "bridgecbDownlinkMaxBurstBitRate"), ("WHISP-SM-MIB", "bridgecbUplinkMaxBurstBitRate"), ("WHISP-SM-MIB", "bridgeCbErrStatBridgeDropCount"), ("WHISP-SM-MIB", "radioModeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    whispSmStatusGroup = whispSmStatusGroup.setStatus('current')
if mibBuilder.loadTexts: whispSmStatusGroup.setDescription('Canopy Subscriber Module status group.')
whispSmNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 3, 3)).setObjects(("WHISP-SM-MIB", "enterSpectrumAnalysis"), ("WHISP-SM-MIB", "availableSpectrumAnalysis"), ("WHISP-SM-MIB", "whispRadarDetected"), ("WHISP-SM-MIB", "whispRadarEnd"), ("WHISP-SM-MIB", "smNatWanDHCPClientEvent"), ("WHISP-SM-MIB", "smNatRFPubDHCPClientEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    whispSmNotifGroup = whispSmNotifGroup.setStatus('current')
if mibBuilder.loadTexts: whispSmNotifGroup.setDescription('WHiSP SMs notification group.')
whispMappingTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 3, 4)).setObjects(("WHISP-SM-MIB", "tableIndex"), ("WHISP-SM-MIB", "protocol"), ("WHISP-SM-MIB", "port"), ("WHISP-SM-MIB", "localIp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    whispMappingTableGroup = whispMappingTableGroup.setStatus('current')
if mibBuilder.loadTexts: whispMappingTableGroup.setDescription('Canopy SM NAT port mapping Table group.')
whispRadarDetected = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 1, 1)).setObjects(("WHISP-SM-MIB", "dfsStatus"), ("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: whispRadarDetected.setStatus('current')
if mibBuilder.loadTexts: whispRadarDetected.setDescription('Radar detected transmit stopped.')
whispRadarEnd = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 1, 2)).setObjects(("WHISP-SM-MIB", "dfsStatus"), ("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: whispRadarEnd.setStatus('current')
if mibBuilder.loadTexts: whispRadarEnd.setDescription('Radar ended back to normal transmit.')
enterSpectrumAnalysis = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 2, 1)).setObjects(("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: enterSpectrumAnalysis.setStatus('current')
if mibBuilder.loadTexts: enterSpectrumAnalysis.setDescription('Entering spectrum analysis.\n                            physAddress - MAC address of the SM')
availableSpectrumAnalysis = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 2, 2)).setObjects(("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: availableSpectrumAnalysis.setStatus('current')
if mibBuilder.loadTexts: availableSpectrumAnalysis.setDescription('Spectrum analysis is complete, SM is re-registered with AP and results are available.\n                            physAddress - MAC address of the SM')
smNatWanDHCPClientEvent = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 3, 1)).setObjects(("WHISP-SM-MIB", "dhcpCip"), ("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: smNatWanDHCPClientEvent.setStatus('current')
if mibBuilder.loadTexts: smNatWanDHCPClientEvent.setDescription('NAT WAN DHCP Client has received a new address via DHCP.')
smNatRFPubDHCPClientEvent = NotificationType((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 4, 3, 2)).setObjects(("WHISP-BOX-MIBV2-MIB", "dhcpRfPublicIp"), ("WHISP-BOX-MIBV2-MIB", "whispBoxEsn"))
if mibBuilder.loadTexts: smNatRFPubDHCPClientEvent.setStatus('current')
if mibBuilder.loadTexts: smNatRFPubDHCPClientEvent.setDescription('NAT RF Public DHCP Client has received a new address via DHCP.')
clearLinkStats = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 8, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearLinkStats.setStatus('current')
if mibBuilder.loadTexts: clearLinkStats.setDescription('Setting this to a nonzero value will clear the link stats.')
rescan = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rescan.setStatus('current')
if mibBuilder.loadTexts: rescan.setDescription('Setting this to a nonzero value will start the rescan.\n                        Warning: If currently connected, this will cause the SM/BHS to drop session')
apEvalControl = MibScalar((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 8, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apEvalControl.setStatus('current')
if mibBuilder.loadTexts: apEvalControl.setDescription('Setting this to 0 will clear the AP Evaluation Data.')
whispMappingTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5), )
if mibBuilder.loadTexts: whispMappingTable.setStatus('current')
if mibBuilder.loadTexts: whispMappingTable.setDescription('NAT port mapping information table.')
whispMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5, 1), ).setIndexNames((0, "WHISP-SM-MIB", "tableIndex"))
if mibBuilder.loadTexts: whispMappingEntry.setStatus('current')
if mibBuilder.loadTexts: whispMappingEntry.setDescription('Mapping table entry.')
tableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tableIndex.setStatus('current')
if mibBuilder.loadTexts: tableIndex.setDescription('User information table index.')
protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protocol.setStatus('current')
if mibBuilder.loadTexts: protocol.setDescription('Protocol type: 0:both UDP and TCP, 1:UDP, 2:TCP.')
port = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port.setStatus('current')
if mibBuilder.loadTexts: port.setDescription('Application port number. e.g. 23=telnet, 21=ftp etc. Should be a positive integer.')
localIp = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 5, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localIp.setStatus('current')
if mibBuilder.loadTexts: localIp.setDescription('IP of local host to which the incoming packet mapped to an application should be forwarded.')
whispSmTranslationTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6), )
if mibBuilder.loadTexts: whispSmTranslationTable.setStatus('current')
if mibBuilder.loadTexts: whispSmTranslationTable.setDescription('Translation Table.')
whispSmTranslationTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6, 1), ).setIndexNames((0, "WHISP-SM-MIB", "whispTranslationTableIndex"))
if mibBuilder.loadTexts: whispSmTranslationTableEntry.setStatus('current')
if mibBuilder.loadTexts: whispSmTranslationTableEntry.setDescription('Translation Table Entry.')
whispTranslationTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: whispTranslationTableIndex.setStatus('current')
if mibBuilder.loadTexts: whispTranslationTableIndex.setDescription('Index into translation table.')
whispTranslationTableMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: whispTranslationTableMacAddr.setStatus('current')
if mibBuilder.loadTexts: whispTranslationTableMacAddr.setDescription('MAC Address of the registered entity.')
whispTranslationTableIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: whispTranslationTableIpAddr.setStatus('current')
if mibBuilder.loadTexts: whispTranslationTableIpAddr.setDescription('Ip Address of the registered entity.')
whispTranslationTableAge = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: whispTranslationTableAge.setStatus('current')
if mibBuilder.loadTexts: whispTranslationTableAge.setDescription('Age of the registered entity.')
whispSmColorCodeTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 9), )
if mibBuilder.loadTexts: whispSmColorCodeTable.setStatus('current')
if mibBuilder.loadTexts: whispSmColorCodeTable.setDescription('Additional color code Table.')
whispSmColorCodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 9, 1), ).setIndexNames((0, "WHISP-SM-MIB", "entryColorCode"))
if mibBuilder.loadTexts: whispSmColorCodeEntry.setStatus('current')
if mibBuilder.loadTexts: whispSmColorCodeEntry.setDescription('Additional Color code Entry.')
entryColorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: entryColorCode.setStatus('current')
if mibBuilder.loadTexts: entryColorCode.setDescription('color code.')
entryColorCodePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: entryColorCodePriority.setStatus('current')
if mibBuilder.loadTexts: entryColorCodePriority.setDescription('color code priority.')
whispSmAPEvalTable = MibTable((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10), )
if mibBuilder.loadTexts: whispSmAPEvalTable.setStatus('current')
if mibBuilder.loadTexts: whispSmAPEvalTable.setDescription('AP Eval List.')
whispSmAPEvalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1), ).setIndexNames((0, "WHISP-SM-MIB", "evalIndex"))
if mibBuilder.loadTexts: whispSmAPEvalEntry.setStatus('current')
if mibBuilder.loadTexts: whispSmAPEvalEntry.setDescription('Evaluation of AP and BHM Entries')
evalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalIndex.setStatus('current')
if mibBuilder.loadTexts: evalIndex.setDescription('Index of the radio seen in the scan')
evalFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalFrequency.setStatus('current')
if mibBuilder.loadTexts: evalFrequency.setDescription('Transmit Frequency in KHz')
evalChannelBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("bandwidth3Point5MHz", 0), ("bandwidth5MHz", 1), ("bandwidth7MHz", 2), ("bandwidth10MHz", 3), ("bandwidth15MHz", 4), ("bandwidth20MHz", 5), ("bandwidth30MHz", 6), ("bandwidth40MHz", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalChannelBandwidth.setStatus('current')
if mibBuilder.loadTexts: evalChannelBandwidth.setDescription('Channel Bandwidth')
evalCyclicPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("one-quarter", 0), ("one-eighth", 1), ("one-sixteenth", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalCyclicPrefix.setStatus('current')
if mibBuilder.loadTexts: evalCyclicPrefix.setDescription('Cyclic Prefix value, for OFDM Radios only.')
evalESN = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalESN.setStatus('current')
if mibBuilder.loadTexts: evalESN.setDescription('Radio ESN')
evalRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalRegion.setStatus('current')
if mibBuilder.loadTexts: evalRegion.setDescription('Region')
evalBeaconReceivePowerCombined = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalBeaconReceivePowerCombined.setStatus('current')
if mibBuilder.loadTexts: evalBeaconReceivePowerCombined.setDescription('Beacon Receive Power Combined in dBm(rounded to nearest integer)')
evalBeaconReceivePowerH = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalBeaconReceivePowerH.setStatus('current')
if mibBuilder.loadTexts: evalBeaconReceivePowerH.setDescription('Beacon Receive Power in dBm(rounded to nearest integer) for Path H(MIMO Radios only)')
evalBeaconReceivePowerV = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalBeaconReceivePowerV.setStatus('current')
if mibBuilder.loadTexts: evalBeaconReceivePowerV.setDescription('Beacon Receive Power in dBm(rounded to nearest integer) for Path V(MIMO Radios only)')
evalFECEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalFECEnable.setStatus('current')
if mibBuilder.loadTexts: evalFECEnable.setDescription('Forward Error Correction Enabled Status.\n\t\t\t\t\t\t\tNote, this is always enabled on 450 and forward.')
evalType = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("multipoint", 0), ("point-to-point", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalType.setStatus('current')
if mibBuilder.loadTexts: evalType.setDescription('Radio Type (Point-to-Point or Multipoint)')
evalAvail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalAvail.setStatus('current')
if mibBuilder.loadTexts: evalAvail.setDescription("Returns True if seen on the previous SM's scan")
evalAge = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalAge.setStatus('current')
if mibBuilder.loadTexts: evalAge.setDescription('Number of minutes since index was last seen')
evalLockout = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalLockout.setStatus('current')
if mibBuilder.loadTexts: evalLockout.setDescription('Number of minutes radio is currently locked out')
evalRegFail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalRegFail.setStatus('current')
if mibBuilder.loadTexts: evalRegFail.setDescription('Registration Fail Count')
evalRange = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalRange.setStatus('current')
if mibBuilder.loadTexts: evalRange.setDescription('Range in feet')
evalMaxRange = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalMaxRange.setStatus('current')
if mibBuilder.loadTexts: evalMaxRange.setDescription('Max Range is in miles')
evalTxBER = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalTxBER.setStatus('current')
if mibBuilder.loadTexts: evalTxBER.setDescription('Radio is transmitting Bit Error Rate symbol or not\n\t\t\t\t\t\t\tNote: This is always enabled on 450 and forward')
evalEBCast = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalEBCast.setStatus('current')
if mibBuilder.loadTexts: evalEBCast.setDescription('Broadcast Encryption status')
evalSessionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalSessionCount.setStatus('current')
if mibBuilder.loadTexts: evalSessionCount.setDescription('Session Count')
evalNoLuid = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalNoLuid.setStatus('current')
if mibBuilder.loadTexts: evalNoLuid.setDescription('Number of times the registration request has been rejected due to No Luid')
evalOutOfRange = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalOutOfRange.setStatus('current')
if mibBuilder.loadTexts: evalOutOfRange.setDescription('Number of times the registration request has been rejected due to out of range')
evalAuthFail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalAuthFail.setStatus('current')
if mibBuilder.loadTexts: evalAuthFail.setDescription('Number of times the registration request has been rejected due to authentication failure')
evalEncryptFail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalEncryptFail.setStatus('current')
if mibBuilder.loadTexts: evalEncryptFail.setDescription('Number of times the registration request has been rejected due to encrypt fail')
evalReScanReq = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalReScanReq.setStatus('current')
if mibBuilder.loadTexts: evalReScanReq.setDescription('Rescan request count')
evalLimitReached = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalLimitReached.setStatus('current')
if mibBuilder.loadTexts: evalLimitReached.setDescription('Number of times failed when trying to register with an limited AP maxed out')
evalNoVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalNoVCs.setStatus('current')
if mibBuilder.loadTexts: evalNoVCs.setDescription('Number of times the registration request has been rejected due to No VCs')
evalVCReserveFail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalVCReserveFail.setStatus('current')
if mibBuilder.loadTexts: evalVCReserveFail.setDescription('Number of times the registration request has been rejected due to VC reserve fail')
evalVCActFail = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalVCActFail.setStatus('current')
if mibBuilder.loadTexts: evalVCActFail.setDescription('Number of times the registration request has been rejected due to VC activate fail')
evalTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalTxPower.setStatus('current')
if mibBuilder.loadTexts: evalTxPower.setDescription('Transmit Power in dBm')
evalReceiveTargetLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalReceiveTargetLevel.setStatus('current')
if mibBuilder.loadTexts: evalReceiveTargetLevel.setDescription('Receive Target Level(in dBm)(PMP only)')
evalColorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalColorCode.setStatus('current')
if mibBuilder.loadTexts: evalColorCode.setDescription('Color Code')
evalBeaconVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalBeaconVersion.setStatus('current')
if mibBuilder.loadTexts: evalBeaconVersion.setDescription('Beacon Version')
evalSectorUserCount = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalSectorUserCount.setStatus('current')
if mibBuilder.loadTexts: evalSectorUserCount.setDescription('Sector User Count(AP only)')
evalSyncSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("generate-sync", 0), ("gps-sync", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalSyncSrc.setStatus('current')
if mibBuilder.loadTexts: evalSyncSrc.setDescription('Sync Source(PMP only)')
evalNumULSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalNumULSlots.setStatus('current')
if mibBuilder.loadTexts: evalNumULSlots.setDescription('Number of uplink slots')
evalNumDLSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalNumDLSlots.setStatus('current')
if mibBuilder.loadTexts: evalNumDLSlots.setDescription('Number of downlink slots')
evalNumULContSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalNumULContSlots.setStatus('current')
if mibBuilder.loadTexts: evalNumULContSlots.setDescription('Number of uplink contention slots(PMP only)')
evalICC = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalICC.setStatus('current')
if mibBuilder.loadTexts: evalICC.setDescription('Instalaton Color Code(PMP only)')
evalAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalAuthentication.setStatus('current')
if mibBuilder.loadTexts: evalAuthentication.setDescription('Authentication Setting(PMP only)')
evalSMPPPoE = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("not-supported", 0), ("suported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalSMPPPoE.setStatus('current')
if mibBuilder.loadTexts: evalSMPPPoE.setDescription('SM PPPoE status(PMP only)')
evalPToPVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("not-supported", 0), ("suported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalPToPVLAN.setStatus('current')
if mibBuilder.loadTexts: evalPToPVLAN.setDescription('PToP VLAN')
evalFramePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 161, 19, 3, 2, 10, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("twoPointFiveMs", 0), ("fiveMs", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evalFramePeriod.setStatus('current')
if mibBuilder.loadTexts: evalFramePeriod.setDescription('Frame Period')
mibBuilder.exportSymbols("WHISP-SM-MIB", certificateDN=certificateDN, hiPriorityUplinkCIR=hiPriorityUplinkCIR, whispTranslationTableIpAddr=whispTranslationTableIpAddr, syslogSMXmitControl=syslogSMXmitControl, dwnLnkLimit=dwnLnkLimit, dhcpClientEnable=dhcpClientEnable, evalFECEnable=evalFECEnable, dhcpIPStart=dhcpIPStart, dnsAutomatic=dnsAutomatic, whispRadarEnd=whispRadarEnd, naptPrivateIP=naptPrivateIP, dhcpcdns2=dhcpcdns2, txPowerControl=txPowerControl, linkQualityData1XVertical=linkQualityData1XVertical, cyclicPrefixScan=cyclicPrefixScan, naptRFPublicSubnetMask=naptRFPublicSubnetMask, naptPublicGatewayIP=naptPublicGatewayIP, evalMaxRange=evalMaxRange, allowedIPAccess1=allowedIPAccess1, calibrationStatus=calibrationStatus, currentColorCode=currentColorCode, userP1Filter=userP1Filter, mimoQpskBerDisplay=mimoQpskBerDisplay, apEvalControl=apEvalControl, currentColorCodePri=currentColorCodePri, rssi=rssi, evalRange=evalRange, rfScanList=rfScanList, fragmentsReceived3XHorizontal=fragmentsReceived3XHorizontal, bandwidthScan=bandwidthScan, enable8023link=enable8023link, nbBitsRcvd=nbBitsRcvd, linkQualityData3XVertical=linkQualityData3XVertical, naptRemoteManage=naptRemoteManage, spectrumAnalysisAction=spectrumAnalysisAction, whispSmNotifGroup=whispSmNotifGroup, ethAccessEnable=ethAccessEnable, smNatWanDHCPClientEvent=smNatWanDHCPClientEvent, authOuterId=authOuterId, lanMaskSm=lanMaskSm, localIp=localIp, dhcpDfltRterIP=dhcpDfltRterIP, bitErrorsQSPKpathA=bitErrorsQSPKpathA, upLnkLimit=upLnkLimit, deleteAdditionalColorCode=deleteAdditionalColorCode, smSectorID=smSectorID, evalNoLuid=evalNoLuid, hiPriorityChannel=hiPriorityChannel, pppoeEnabledStatus=pppoeEnabledStatus, pmp430ApRegistrationOptions=pmp430ApRegistrationOptions, tableIndex=tableIndex, timedSpectrumAnalysisDuration=timedSpectrumAnalysisDuration, registeredToAp=registeredToAp, rfScanListBandFilter=rfScanListBandFilter, port3UDPFilter=port3UDPFilter, spectrumAnalysisDisplay=spectrumAnalysisDisplay, currentCyclicPrefix=currentCyclicPrefix, naptPublicSubnetMask=naptPublicSubnetMask, pppoeSvcNameStatus=pppoeSvcNameStatus, clearBerrResults=clearBerrResults, rfStatTxSuppressionCount=rfStatTxSuppressionCount, whispSmConfigGroup=whispSmConfigGroup, enterSpectrumAnalysis=enterSpectrumAnalysis, lowPriorityUplinkCIR=lowPriorityUplinkCIR, colorCode6=colorCode6, signalToNoiseRatioSMVertical=signalToNoiseRatioSMVertical, evalNumULContSlots=evalNumULContSlots, dhcpServerLeaseTime=dhcpServerLeaseTime, pppoeFilter=pppoeFilter, authenticationEnforce=authenticationEnforce, colorCode8=colorCode8, whispSmControls=whispSmControls, realm=realm, pppoeMTUOverrideValue=pppoeMTUOverrideValue, pppoeSessionStatus=pppoeSessionStatus, bitErrors16QAMpathB=bitErrors16QAMpathB, allowedIPAccessNMLength3=allowedIPAccessNMLength3, colorCodepriority8=colorCodepriority8, ip4MultFilter=ip4MultFilter, maxJitter=maxJitter, bridgecbDownlinkCreditRate=bridgecbDownlinkCreditRate, linkQualityData2XHorizontal=linkQualityData2XHorizontal, maxRadioDbm=maxRadioDbm, allowedIPAccess3=allowedIPAccess3, whispSmTranslationTable=whispSmTranslationTable, bridgeCbErrStatBridgeDropCount=bridgeCbErrStatBridgeDropCount, currentBandwidth=currentBandwidth, pppoeIPCPAddress=pppoeIPCPAddress, scanCycleCount=scanCycleCount, smAntennaType=smAntennaType, evalEBCast=evalEBCast, fragmentsReceived2XHorizontal=fragmentsReceived2XHorizontal, radioModeStatus=radioModeStatus, whispSmDfsEvent=whispSmDfsEvent, hostLease=hostLease, userP3Filter=userP3Filter, evalAuthentication=evalAuthentication, certEntry=certEntry, defaultGwSm=defaultGwSm, radioDbmHorizontal=radioDbmHorizontal, whispSmDHCPClientEvent=whispSmDHCPClientEvent, whispSmStatus=whispSmStatus, arpFilter=arpFilter, syslogMinLevelApPreferred=syslogMinLevelApPreferred, radioDbm=radioDbm, natConnectionType=natConnectionType, bridgecbUplinkMaxBurstBitRate=bridgecbUplinkMaxBurstBitRate, pppoeServiceName=pppoeServiceName, pppoeACNameStatus=pppoeACNameStatus, minRadioDbm=minRadioDbm, PYSNMP_MODULE_ID=whispSmMibModule, dmzEnable=dmzEnable, rfScanListEntry=rfScanListEntry, bhsReReg=bhsReReg, ingressVIDPriority=ingressVIDPriority, pppoeDNSServer2=pppoeDNSServer2, prefferedDNSIP=prefferedDNSIP, dfsConfig=dfsConfig, evalNoVCs=evalNoVCs, wanPingReplyEnable=wanPingReplyEnable, userDefinedPort3=userDefinedPort3, evalChannelBandwidth=evalChannelBandwidth, udpGarbageCollectTmout=udpGarbageCollectTmout, evalRegion=evalRegion, linkQualityData2XVertical=linkQualityData2XVertical, rescan=rescan, bridgeTableSize=bridgeTableSize, secondaryBER=secondaryBER, radioDbmAvg=radioDbmAvg, bridgeTableRestrict=bridgeTableRestrict, pppoeUserName=pppoeUserName, ingressVID=ingressVID, natTslTableSize=natTslTableSize, totalBERDisplay=totalBERDisplay, mimoBerRcvModulationType=mimoBerRcvModulationType, signalToNoiseRatioSMHorizontal=signalToNoiseRatioSMHorizontal, lanIpSm=lanIpSm, whispTranslationTableMacAddr=whispTranslationTableMacAddr, evalAvail=evalAvail, ipAccessFilterEnable=ipAccessFilterEnable, userDefinedPort2=userDefinedPort2, evalFramePeriod=evalFramePeriod, switchRadioModeAndReboot=switchRadioModeAndReboot, pppoeTCPMSSClampEnable=pppoeTCPMSSClampEnable, availableSpectrumAnalysis=availableSpectrumAnalysis, evalSMPPPoE=evalSMPPPoE, adaptRate=adaptRate, mimo16QamBerDisplay=mimo16QamBerDisplay, bridgecbDownlinkMaxBurstBitRate=bridgecbDownlinkMaxBurstBitRate, dhcpDomName=dhcpDomName, entryColorCode=entryColorCode, colorCodepriority9=colorCodepriority9, pppoeTimerType=pppoeTimerType, dhcpSip=dhcpSip, certIndex=certIndex, dhcpServerTable=dhcpServerTable, dhcpCSMask=dhcpCSMask, allOtherIpFilter=allOtherIpFilter, allowedIPAccessNMLength2=allowedIPAccessNMLength2, pppoeTimeoutValue=pppoeTimeoutValue, additionalColorCode=additionalColorCode, whispMappingTable=whispMappingTable, nbPriBitsErr=nbPriBitsErr, airDelayns=airDelayns, lowPriorityDownlinkCIR=lowPriorityDownlinkCIR, beaconsPercentReceived=beaconsPercentReceived, evalVCReserveFail=evalVCReserveFail, dhcpServerEntry=dhcpServerEntry, colorCode4=colorCode4, naptEnable=naptEnable, whispMappingEntry=whispMappingEntry, linkQualityData1XHorizontal=linkQualityData1XHorizontal, totalBER=totalBER, beaconsPercentMinReceived=beaconsPercentMinReceived, linkQualityData4XHorizontal=linkQualityData4XHorizontal, whispSmStatusGroup=whispSmStatusGroup, snmpBerLevel=snmpBerLevel, bitErrors256QAMpathB=bitErrors256QAMpathB, zoltarFPGAFreqOffset=zoltarFPGAFreqOffset, colorCodepriority10=colorCodepriority10, tcpGarbageCollectTmout=tcpGarbageCollectTmout, mimo64QamBerDisplay=mimo64QamBerDisplay, whispSmGroups=whispSmGroups, evalReScanReq=evalReScanReq, currentChanFreq=currentChanFreq, rfDhcpState=rfDhcpState, colorCode9=colorCode9, adaptRateHighPri=adaptRateHighPri, allowedIPAccessNMLength1=allowedIPAccessNMLength1, whispMappingTableGroup=whispMappingTableGroup, receiveFragmentsModulationPercentage=receiveFragmentsModulationPercentage, whispSmColorCodeTable=whispSmColorCodeTable, beaconsPercentReceivedSnapshot=beaconsPercentReceivedSnapshot, dmzIP=dmzIP, userP2Filter=userP2Filter, dhcpServerEnable=dhcpServerEnable, colorCodepriority4=colorCodepriority4, upLnkMaxBurstDataRate=upLnkMaxBurstDataRate, evalTxPower=evalTxPower, evalPToPVLAN=evalPToPVLAN, multicastVCRcvRate=multicastVCRcvRate, numAuthCerts=numAuthCerts, networkAccess=networkAccess, colorCode2=colorCode2, evalAuthFail=evalAuthFail, whispSmSpAnEvent=whispSmSpAnEvent, pppoeSessionID=pppoeSessionID, ethAccessFilterEnable=ethAccessFilterEnable, bridgecbUplinkCreditRate=bridgecbUplinkCreditRate, syslogSMXmitSetting=syslogSMXmitSetting, authUsername=authUsername, secondaryBERDisplay=secondaryBERDisplay, port1TCPFilter=port1TCPFilter, apSelection=apSelection, bridgecbDownlinkCreditLimit=bridgecbDownlinkCreditLimit, fragmentsReceived3XVertical=fragmentsReceived3XVertical, pppoeSessIdleTime=pppoeSessIdleTime, authKeyOption=authKeyOption, pppoeDataBytesSent=pppoeDataBytesSent, sessionStatus=sessionStatus, radioTxPwr=radioTxPwr, hostIp=hostIp, primaryBER=primaryBER, whispTranslationTableAge=whispTranslationTableAge, fragmentsReceived4XVertical=fragmentsReceived4XVertical, pppoeDNSServer1=pppoeDNSServer1, bitErrorsQSPKpathB=bitErrorsQSPKpathB, useRealm=useRealm, fragmentsReceived1XHorizontal=fragmentsReceived1XHorizontal, whispTranslationTableIndex=whispTranslationTableIndex, evalNumULSlots=evalNumULSlots, evalICC=evalICC, smSessionTimer=smSessionTimer, dwnLnkMaxBurstDataRate=dwnLnkMaxBurstDataRate, pppoeDisconnectOD=pppoeDisconnectOD, whispSmConfig=whispSmConfig, smRateAdapt=smRateAdapt, allIpv4Filter=allIpv4Filter, zoltarSWFreqOffset=zoltarSWFreqOffset, colorCode10=colorCode10, pppoeControlBytesSent=pppoeControlBytesSent, bootpsFilter=bootpsFilter, evalSessionCount=evalSessionCount, primaryBERDisplay=primaryBERDisplay, whispSmColorCodeEntry=whispSmColorCodeEntry, hiPriorityDownlinkCIR=hiPriorityDownlinkCIR, evalLimitReached=evalLimitReached, radioDbmInt=radioDbmInt, colorCode7=colorCode7, testSMBER=testSMBER, port3TCPFilter=port3TCPFilter, evalTxBER=evalTxBER, activeRegion=activeRegion, smLEDModeFlag=smLEDModeFlag)
mibBuilder.exportSymbols("WHISP-SM-MIB", snmpFilter=snmpFilter, colorCode5=colorCode5, evalNumDLSlots=evalNumDLSlots, phase2=phase2, allOthersFilter=allOthersFilter, bCastMIR=bCastMIR, radioDbmVertical=radioDbmVertical, authKeySm=authKeySm, evalRegFail=evalRegFail, fragmentsReceived1XVertical=fragmentsReceived1XVertical, ingressVIDPriorityMode=ingressVIDPriorityMode, signalStrengthRatio=signalStrengthRatio, whispSmSecurity=whispSmSecurity, nbSndBitsErr=nbSndBitsErr, pppoeConnectOD=pppoeConnectOD, smNatRFPubDHCPClientEvent=smNatRFPubDHCPClientEvent, forcepoweradjust=forcepoweradjust, pppoeTimerTypeValue=pppoeTimerTypeValue, rawBERPwrRxPathA=rawBERPwrRxPathA, linkQualityBeacon=linkQualityBeacon, fragmentsReceived4XHorizontal=fragmentsReceived4XHorizontal, evalReceiveTargetLevel=evalReceiveTargetLevel, berrautoupdateflag=berrautoupdateflag, evalColorCode=evalColorCode, pppoeSessUptime=pppoeSessUptime, port1UDPFilter=port1UDPFilter, rfScanListFrequency=rfScanListFrequency, pppoeMTUOverrideEnable=pppoeMTUOverrideEnable, port2UDPFilter=port2UDPFilter, colorCodepriority2=colorCodepriority2, userDefinedPort1=userDefinedPort1, evalBeaconReceivePowerCombined=evalBeaconReceivePowerCombined, evalEncryptFail=evalEncryptFail, syslogServerApPreferred=syslogServerApPreferred, smbFilter=smbFilter, minJitter=minJitter, evalESN=evalESN, rawBERPwrRxPathB=rawBERPwrRxPathB, adaptRateLowPri=adaptRateLowPri, pppoeMTUValue=pppoeMTUValue, linkQualityData4XVertical=linkQualityData4XVertical, bootpcFilter=bootpcFilter, radioBandscanConfig=radioBandscanConfig, radioTxGainSm=radioTxGainSm, colorCodepriority5=colorCodepriority5, beaconsPercentMaxReceived=beaconsPercentMaxReceived, dhcpNumIPsToLease=dhcpNumIPsToLease, pppoePassword=pppoePassword, evalSectorUserCount=evalSectorUserCount, naptRFPublicGateway=naptRFPublicGateway, certTable=certTable, dhcpCip=dhcpCip, entryColorCodePriority=entryColorCodePriority, bitErrors64QAMpathA=bitErrors64QAMpathA, colorCodepriority3=colorCodepriority3, naptPrivateSubnetMask=naptPrivateSubnetMask, providerVIDPriorityMode=providerVIDPriorityMode, evalVCActFail=evalVCActFail, evalLockout=evalLockout, natDNSProxyEnable=natDNSProxyEnable, clearLinkStats=clearLinkStats, arpCacheTimeout=arpCacheTimeout, maxTxPower=maxTxPower, pppoeTCPMSSClampEnableStatus=pppoeTCPMSSClampEnableStatus, whispSmTranslationTableEntry=whispSmTranslationTableEntry, dfsStatus=dfsStatus, pppoeDataBytesReceived=pppoeDataBytesReceived, berPwrRxFPGAPathA=berPwrRxFPGAPathA, maxTxPowerEnable=maxTxPowerEnable, eapPeerAAAServerCommonName=eapPeerAAAServerCommonName, evalBeaconVersion=evalBeaconVersion, evalBeaconReceivePowerV=evalBeaconReceivePowerV, evalFrequency=evalFrequency, evalSyncSrc=evalSyncSrc, evalIndex=evalIndex, additionalColorCodePriority=additionalColorCodePriority, pppoeControlBytesReceived=pppoeControlBytesReceived, naptRFPublicIP=naptRFPublicIP, upLnkDataRate=upLnkDataRate, evalType=evalType, mimo256QamBerDisplay=mimo256QamBerDisplay, colorCode3=colorCode3, cert=cert, evalOutOfRange=evalOutOfRange, dhcpServerPktToss=dhcpServerPktToss, packetFilterDirection=packetFilterDirection, bCastMIRUnits=bCastMIRUnits, rfScanListTable=rfScanListTable, dhcpcdns3=dhcpcdns3, whispSmEvent=whispSmEvent, maxRadioDbmDeprecated=maxRadioDbmDeprecated, allowedIPAccess2=allowedIPAccess2, fragmentsReceived2XVertical=fragmentsReceived2XVertical, mapsPercentReceived=mapsPercentReceived, port=port, powerUpMode=powerUpMode, dhcpServerPktRcv=dhcpServerPktRcv, minRSSI=minRSSI, radioSlicingSm=radioSlicingSm, whispSmAPEvalEntry=whispSmAPEvalEntry, natTslTableEntries=natTslTableEntries, dhcpServerPktXmt=dhcpServerPktXmt, hostMacAddress=hostMacAddress, evalBeaconReceivePowerH=evalBeaconReceivePowerH, spectrumAnalysisScanBandwidth=spectrumAnalysisScanBandwidth, jitter=jitter, providerVIDPriority=providerVIDPriority, authPassword=authPassword, timingPulseGated=timingPulseGated, alternateDNSIP=alternateDNSIP, pppoeAccessConcentrator=pppoeAccessConcentrator, whispSmMibModule=whispSmMibModule, dhcpClientLease=dhcpClientLease, pppoeEnable=pppoeEnable, maxReceivePower=maxReceivePower, berPwrRxFPGAPathB=berPwrRxFPGAPathB, evalCyclicPrefix=evalCyclicPrefix, bitsReceivedPerPathModulation=bitsReceivedPerPathModulation, maxRSSI=maxRSSI, bitErrors16QAMpathA=bitErrors16QAMpathA, protocol=protocol, colorCodepriority7=colorCodepriority7, phase1=phase1, bitErrors64QAMpathB=bitErrors64QAMpathB, upLinkBCastFilter=upLinkBCastFilter, pppoeAuthenticationType=pppoeAuthenticationType, evalAge=evalAge, berDeModSelect=berDeModSelect, whispSmAPEvalTable=whispSmAPEvalTable, dwnLnkDataRate=dwnLnkDataRate, airDelay=airDelay, naptPublicIP=naptPublicIP, colorCodepriority6=colorCodepriority6, pppoeMTUOverrideEn=pppoeMTUOverrideEn, port2TCPFilter=port2TCPFilter, spectrumAnalysisOnBoot=spectrumAnalysisOnBoot, bridgecbUplinkCreditLimit=bridgecbUplinkCreditLimit, dhcpcdns1=dhcpcdns1, linkQualityData3XHorizontal=linkQualityData3XHorizontal, whispRadarDetected=whispRadarDetected, action=action, bitErrors256QAMpathA=bitErrors256QAMpathA, pppoeTimeoutPeriod=pppoeTimeoutPeriod)
