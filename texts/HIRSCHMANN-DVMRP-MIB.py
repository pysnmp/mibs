#
# PySNMP MIB module HIRSCHMANN-DVMRP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hirschmann/hmDVMRP.mib
# Produced by pysmi-1.1.8 at Thu Apr 27 09:24:42 2023
# On host fv-az590-874 platform Linux version 5.15.0-1036-azure by user runner
# Using Python version 3.10.11 (main, Apr  6 2023, 07:59:08) [GCC 11.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
hmPlatform4Multicast, = mibBuilder.importSymbols("HIRSCHMANN-MULTICAST-MIB", "hmPlatform4Multicast")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ObjectIdentity, IpAddress, TimeTicks, iso, MibIdentifier, Bits, Integer32, Unsigned32, Counter64, NotificationType, ModuleIdentity, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "TimeTicks", "iso", "MibIdentifier", "Bits", "Integer32", "Unsigned32", "Counter64", "NotificationType", "ModuleIdentity", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
hmDVMRPMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 15, 4, 100))
hmDVMRPMIB.setRevisions(('2010-04-12 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmDVMRPMIB.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hmDVMRPMIB.setLastUpdated('201004121200Z')
if mibBuilder.loadTexts: hmDVMRPMIB.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmDVMRPMIB.setContactInfo('Customer Support\r\n           Postal: \r\n           Hirschmann Automation and Control GmbH\r\n           Stuttgarter Str. 45-51\r\n           72654 Neckartenzlingen\r\n           Germany\r\n           Tel: +49 7127 14 1981\r\n           Web: http://www.hicomcenter.com/\r\n           E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmDVMRPMIB.setDescription('The Hirschmann Private DVMRP MIB definitions for Platform devices.')
hmDVMRPMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1))
hmDVMRP = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1))
hmDVMRPScalar = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1))
hmDVMRPVersionString = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPVersionString.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPVersionString.setDescription("The router's DVMRP version information.  Similar to\r\n            sysDescr in MIB-II, this is a free-form field which can be\r\n            used to display vendor-specific information.")
hmDVMRPGenerationId = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPGenerationId.setStatus('obsolete')
if mibBuilder.loadTexts: hmDVMRPGenerationId.setDescription('The generation identifier for the routing process.  This is\r\n            used by neighboring routers to detect whether the DVMRP\r\n            routing table should be resent.')
hmDVMRPNumRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNumRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNumRoutes.setDescription('The number of entries in the routing table.  This can be\r\n            used to monitor the routing table size to detect illegal\r\n            advertisements of unicast routes.')
hmDVMRPReachableRoutes = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPReachableRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPReachableRoutes.setDescription('The number of entries in the routing table with non\r\n            infinite metrics.  This can be used to detect network\r\n            partitions by observing the ratio of reachable routes to\r\n            total routes.')
hmDVMRPUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDVMRPUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPUpdateInterval.setDescription('The interval at which the dvmrp route updates (reports)\r\n             are sent.')
hmDVMRPPruneLifetime = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 64800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDVMRPPruneLifetime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneLifetime.setDescription('The time a prune message sent from this router will be valid.')
hmDVMRPInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2), )
if mibBuilder.loadTexts: hmDVMRPInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceTable.setDescription("The (conceptual) table listing the router's multicast-\r\n            capable interfaces.")
hmDVMRPInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1), ).setIndexNames((0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceIfIndex"))
if mibBuilder.loadTexts: hmDVMRPInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceEntry.setDescription('An entry (conceptual row) in the hmDVMRPInterfaceTable.  This\r\n            row augments ipMRouteInterfaceEntry in the IP Multicast MIB,\r\n            where the threshold object resides.')
hmDVMRPInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hmDVMRPInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceIfIndex.setDescription('The ifIndex value of the interface for which DVMRP is\r\n            enabled.')
hmDVMRPInterfaceLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPInterfaceLocalAddress.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceLocalAddress.setDescription('The IP address this system will use as a source address on\r\n            this interface.  On unnumbered interfaces, it must be the\r\n            same value as hmDVMRPInterfaceLocalAddress for some interface\r\n            on the system.')
hmDVMRPInterfaceMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDVMRPInterfaceMetric.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceMetric.setDescription('The distance metric for this interface which is used to\r\n            calculate distance vectors.')
hmDVMRPInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDVMRPInterfaceStatus.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceStatus.setDescription('The status of this entry.  Creating the entry enables DVMRP\r\n            on the interface; destroying the entry disables DVMRP on the interface.')
hmDVMRPInterfaceRcvBadPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPInterfaceRcvBadPkts.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceRcvBadPkts.setDescription('The number of DVMRP messages received on the interface by\r\n            the DVMRP process which were subsequently discarded as\r\n            invalid (e.g. invalid packet format, or a route report from\r\n            an unknown neighbor).')
hmDVMRPInterfaceRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPInterfaceRcvBadRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceRcvBadRoutes.setDescription('The number of routes, in valid DVMRP packets, which were\r\n            ignored because the entry was invalid.')
hmDVMRPInterfaceSentRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPInterfaceSentRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceSentRoutes.setDescription('The number of routes, in DVMRP Report packets, which have\r\n            been sent on this interface.  Together with\r\n            hmDVMRPNeighborRcvRoutes at a peer, this object is useful for\r\n            detecting routes being lost.')
hmDVMRPInterfaceInterfaceKey = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 8), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDVMRPInterfaceInterfaceKey.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceInterfaceKey.setDescription('The (shared) key for authenticating neighbors on this\r\n            interface.  This object is intended solely for the purpose\r\n            of setting the interface key, and MUST be accessible only\r\n            via requests using both authentication and privacy.  The\r\n            agent MAY report an empty string in response to get, get-\r\n            next, get-bulk requests.')
hmDVMRPInterfaceInterfaceKeyVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmDVMRPInterfaceInterfaceKeyVersion.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceInterfaceKeyVersion.setDescription('The highest version number of all known interface keys for\r\n            this interface used for authenticating neighbors.')
hmDVMRPInterfaceGenerationId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 2, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPInterfaceGenerationId.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceGenerationId.setDescription('The generation identifier for the routing process.  This is\r\n            used by neighboring routers to detect whether the DVMRP\r\n            routing table should be resent.')
hmDVMRPNeighborTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3), )
if mibBuilder.loadTexts: hmDVMRPNeighborTable.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborTable.setDescription("The (conceptual) table listing the router's DVMRP\r\n            neighbors, as discovered by receiving DVMRP messages.")
hmDVMRPNeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1), ).setIndexNames((0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborIfIndex"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborAddress"))
if mibBuilder.loadTexts: hmDVMRPNeighborEntry.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborEntry.setDescription('An entry (conceptual row) in the hmDVMRPNeighborTable.')
hmDVMRPNeighborIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: hmDVMRPNeighborIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborIfIndex.setDescription('The value of ifIndex for the virtual interface used to\r\n            reach this DVMRP neighbor.')
hmDVMRPNeighborAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 2), IpAddress())
if mibBuilder.loadTexts: hmDVMRPNeighborAddress.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborAddress.setDescription('The IP address of the DVMRP neighbor for which this entry\r\n            contains information.')
hmDVMRPNeighborUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborUpTime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborUpTime.setDescription('The time since this DVMRP neighbor (last) became a neighbor\r\n            of the local router.')
hmDVMRPNeighborExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborExpiryTime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborExpiryTime.setDescription('The minimum time remaining before this DVMRP neighbor will\r\n            be aged out.')
hmDVMRPNeighborGenerationId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborGenerationId.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborGenerationId.setDescription("The neighboring router's generation identifier.")
hmDVMRPNeighborMajorVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborMajorVersion.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborMajorVersion.setDescription("The neighboring router's major DVMRP version number.")
hmDVMRPNeighborMinorVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborMinorVersion.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborMinorVersion.setDescription("The neighboring router's minor DVMRP version number.")
hmDVMRPNeighborCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 8), Bits().clone(namedValues=NamedValues(("leaf", 0), ("prune", 1), ("generationID", 2), ("mtrace", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborCapabilities.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborCapabilities.setDescription("This object describes the neighboring router's\r\n            capabilities.  The leaf bit indicates that the neighbor has\r\n            only one interface with neighbors.  The prune bit indicates\r\n            that the neighbor supports pruning.  The generationID bit\r\n            indicates that the neighbor sends its generationID in Probe\r\n            messages.  The mtrace bit indicates that the neighbor can\r\n            handle mtrace requests.")
hmDVMRPNeighborRcvRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborRcvRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborRcvRoutes.setDescription('The total number of routes received in valid DVMRP packets\r\n            received from this neighbor.  This can be used to diagnose\r\n            problems such as unicast route injection, as well as giving\r\n            an indication of the level of DVMRP route exchange\r\n            activity.')
hmDVMRPNeighborRcvBadPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborRcvBadPkts.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborRcvBadPkts.setDescription('The number of packet received from this neighbor which were\r\n            discarded as invalid.')
hmDVMRPNeighborRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborRcvBadRoutes.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborRcvBadRoutes.setDescription('The number of routes, in valid DVMRP packets received from\r\n            this neighbor, which were ignored because the entry was\r\n            invalid.')
hmDVMRPNeighborState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("oneway", 1), ("active", 2), ("ignoring", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPNeighborState.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborState.setDescription('State of the neighbor adjacency.')
hmDVMRPRouteTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4), )
if mibBuilder.loadTexts: hmDVMRPRouteTable.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteTable.setDescription('The table of routes learned through DVMRP route exchange.')
hmDVMRPRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1), ).setIndexNames((0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteSource"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteSourceMask"))
if mibBuilder.loadTexts: hmDVMRPRouteEntry.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteEntry.setDescription('An entry (conceptual row) containing the multicast routing\r\n            information used by DVMRP in place of the unicast routing\r\n            information.')
hmDVMRPRouteSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 1), IpAddress())
if mibBuilder.loadTexts: hmDVMRPRouteSource.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteSource.setDescription('The network address which when combined with the\r\n            corresponding value of hmDVMRPRouteSourceMask identifies the\r\n            sources for which this entry contains multicast routing\r\n            information.')
hmDVMRPRouteSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 2), IpAddress())
if mibBuilder.loadTexts: hmDVMRPRouteSourceMask.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteSourceMask.setDescription('The network mask which when combined with the corresponding\r\n            value of hmDVMRPRouteSource identifies the sources for which\r\n            this entry contains multicast routing information.')
hmDVMRPRouteUpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteUpstreamNeighbor.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteUpstreamNeighbor.setDescription('The address of the upstream neighbor (e.g., RPF neighbor)\r\n            from which IP datagrams from these sources are received.')
hmDVMRPRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteIfIndex.setDescription('The value of ifIndex for the interface on which IP\r\n            datagrams sent by these sources are received.  A value of 0\r\n            typically means the route is an aggregate for which no next-\r\n            hop interface exists.')
hmDVMRPRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteMetric.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteMetric.setDescription('The distance in hops to the source subnet.')
hmDVMRPRouteExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteExpiryTime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteExpiryTime.setDescription('The minimum amount of time remaining before this entry will\r\n            be aged out.')
hmDVMRPRouteUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 4, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteUpTime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteUpTime.setDescription('The time since the route represented by this entry was\r\n            learned by the router.')
hmDVMRPRouteNextHopTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5), )
if mibBuilder.loadTexts: hmDVMRPRouteNextHopTable.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopTable.setDescription('The (conceptual) table containing information on the next\r\n            hops on outgoing interfaces for routing IP multicast\r\n            datagrams.')
hmDVMRPRouteNextHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5, 1), ).setIndexNames((0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteNextHopSource"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteNextHopSourceMask"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteNextHopIfIndex"))
if mibBuilder.loadTexts: hmDVMRPRouteNextHopEntry.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopEntry.setDescription('An entry (conceptual row) in the list of next hops on\r\n            outgoing interfaces to which IP multicast datagrams from\r\n            particular sources are routed.')
hmDVMRPRouteNextHopSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5, 1, 1), IpAddress())
if mibBuilder.loadTexts: hmDVMRPRouteNextHopSource.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopSource.setDescription('The network address which when combined with the\r\n            corresponding value of hmDVMRPRouteNextHopSourceMask\r\n            identifies the sources for which this entry specifies a next\r\n            hop on an outgoing interface.')
hmDVMRPRouteNextHopSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5, 1, 2), IpAddress())
if mibBuilder.loadTexts: hmDVMRPRouteNextHopSourceMask.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopSourceMask.setDescription('The network mask which when combined with the corresponding\r\n            value of hmDVMRPRouteNextHopSource identifies the sources for\r\n            which this entry specifies a next hop on an outgoing\r\n            interface.')
hmDVMRPRouteNextHopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5, 1, 3), InterfaceIndex())
if mibBuilder.loadTexts: hmDVMRPRouteNextHopIfIndex.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopIfIndex.setDescription('The ifIndex value of the interface for the outgoing\r\n            interface for this next hop.')
hmDVMRPRouteNextHopType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("leaf", 1), ("branch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPRouteNextHopType.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRouteNextHopType.setDescription('Type is leaf if no downstream dependent neighbors exist on\r\n            the outgoing virtual interface.  Otherwise, type is branch.')
hmDVMRPPruneTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6), )
if mibBuilder.loadTexts: hmDVMRPPruneTable.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneTable.setDescription("The (conceptual) table listing the router's upstream prune\r\n            state.")
hmDVMRPPruneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6, 1), ).setIndexNames((0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPPruneGroup"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPPruneSource"), (0, "HIRSCHMANN-DVMRP-MIB", "hmDVMRPPruneSourceMask"))
if mibBuilder.loadTexts: hmDVMRPPruneEntry.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneEntry.setDescription('An entry (conceptual row) in the hmDVMRPPruneTable.')
hmDVMRPPruneGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6, 1, 1), IpAddress())
if mibBuilder.loadTexts: hmDVMRPPruneGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneGroup.setDescription('The group address which has been pruned.')
hmDVMRPPruneSource = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6, 1, 2), IpAddress())
if mibBuilder.loadTexts: hmDVMRPPruneSource.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneSource.setDescription('The address of the source or source network which has been\r\n            pruned.')
hmDVMRPPruneSourceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6, 1, 3), IpAddress())
if mibBuilder.loadTexts: hmDVMRPPruneSourceMask.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneSourceMask.setDescription("The address of the source or source network which has been\r\n            pruned.  The mask must either be all 1's, or else\r\n            hmDVMRPPruneSource and hmDVMRPPruneSourceMask must match\r\n            hmDVMRPRouteSource and hmDVMRPRouteSourceMask for some entry in\r\n            the hmDVMRPRouteTable.")
hmDVMRPPruneExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 6, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDVMRPPruneExpiryTime.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPPruneExpiryTime.setDescription("The amount of time remaining before this prune should\r\n            expire at the upstream neighbor.  This value should be the\r\n            minimum of the default prune lifetime and the remaining\r\n            prune lifetimes of the local router's downstream neighbors,\r\n            if any.")
hmDVMRPTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 7))
hmDVMRPNeighborLoss = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 7, 1)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceLocalAddress"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborState"))
if mibBuilder.loadTexts: hmDVMRPNeighborLoss.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborLoss.setDescription('A hmDVMRPNeighborLoss trap signifies the loss of a 2-way\r\n            adjacency with a neighbor.  This trap should be generated\r\n            when the neighbor state changes from active to one-way,\r\n            ignoring, or down.  The trap should be generated only if the\r\n            router has no other neighbors on the same interface with a\r\n            lower IP address than itself.')
hmDVMRPNeighborNotPruning = NotificationType((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 1, 1, 7, 2)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceLocalAddress"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborCapabilities"))
if mibBuilder.loadTexts: hmDVMRPNeighborNotPruning.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborNotPruning.setDescription('A hmDVMRPNeighborNotPruning trap signifies that a non-pruning\r\n            neighbor has been detected (in an implementation-dependent\r\n            manner).  This trap should be generated at most once per\r\n            generation ID of the neighbor.  For example, it should be\r\n            generated at the time a neighbor is first heard from if the\r\n            prune bit is not set in its capabilities.  It should also be\r\n            generated if the local system has the ability to tell that a\r\n            neighbor which sets the the prune bit in its capabilities is\r\n            not pruning any branches over an extended period of time.\r\n            The trap should be generated only if the router has no other\r\n            neighbors on the same interface with a lower IP address than\r\n            itself.')
hmDVMRPMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2))
hmDVMRPMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 1))
hmDVMRPMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2))
hmDVMRPMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 1, 1)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPGeneralGroup"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceGroup"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborGroup"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRoutingGroup"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPTreeGroup"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPSecurityGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPMIBCompliance = hmDVMRPMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPMIBCompliance.setDescription('The compliance statement for the DVMRP MIB.')
hmDVMRPGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 2)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPVersionString"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPGenerationId"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNumRoutes"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPReachableRoutes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPGeneralGroup = hmDVMRPGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPGeneralGroup.setDescription('A collection of objects used to describe general DVMRP\r\n            configuration information.')
hmDVMRPInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 3)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceLocalAddress"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceMetric"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceStatus"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceRcvBadPkts"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceRcvBadRoutes"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceSentRoutes"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceGenerationId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPInterfaceGroup = hmDVMRPInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPInterfaceGroup.setDescription('A collection of objects used to describe DVMRP interface\r\n            configuration and statistics.')
hmDVMRPNeighborGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 4)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborUpTime"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborExpiryTime"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborGenerationId"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborMajorVersion"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborMinorVersion"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborCapabilities"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborRcvRoutes"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborRcvBadPkts"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborRcvBadRoutes"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPNeighborGroup = hmDVMRPNeighborGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNeighborGroup.setDescription('A collection of objects used to describe DVMRP peer\r\n            configuration and statistics.')
hmDVMRPRoutingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 5)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteUpstreamNeighbor"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteIfIndex"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteMetric"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteExpiryTime"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteUpTime"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPRouteNextHopType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPRoutingGroup = hmDVMRPRoutingGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPRoutingGroup.setDescription('A collection of objects used to store the DVMRP routing\r\n            table.')
hmDVMRPSecurityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 6)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceInterfaceKey"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPInterfaceInterfaceKeyVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPSecurityGroup = hmDVMRPSecurityGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPSecurityGroup.setDescription('A collection of objects used to store information related\r\n            to DVMRP security.')
hmDVMRPTreeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 7)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPPruneExpiryTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPTreeGroup = hmDVMRPTreeGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPTreeGroup.setDescription('A collection of objects used to store information related\r\n            to DVMRP prune state.')
hmDVMRPNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 248, 15, 4, 100, 2, 2, 8)).setObjects(("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborLoss"), ("HIRSCHMANN-DVMRP-MIB", "hmDVMRPNeighborNotPruning"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hmDVMRPNotificationGroup = hmDVMRPNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hmDVMRPNotificationGroup.setDescription('A collection of notifications for signaling important DVMRP\r\n            events.')
mibBuilder.exportSymbols("HIRSCHMANN-DVMRP-MIB", hmDVMRPInterfaceRcvBadRoutes=hmDVMRPInterfaceRcvBadRoutes, hmDVMRPInterfaceMetric=hmDVMRPInterfaceMetric, hmDVMRPInterfaceRcvBadPkts=hmDVMRPInterfaceRcvBadPkts, hmDVMRPRouteIfIndex=hmDVMRPRouteIfIndex, hmDVMRPGenerationId=hmDVMRPGenerationId, hmDVMRPNeighborRcvBadPkts=hmDVMRPNeighborRcvBadPkts, hmDVMRPRouteEntry=hmDVMRPRouteEntry, hmDVMRPRouteTable=hmDVMRPRouteTable, hmDVMRPRouteNextHopSource=hmDVMRPRouteNextHopSource, hmDVMRPNotificationGroup=hmDVMRPNotificationGroup, hmDVMRPMIBCompliances=hmDVMRPMIBCompliances, hmDVMRPInterfaceGroup=hmDVMRPInterfaceGroup, hmDVMRPPruneSource=hmDVMRPPruneSource, hmDVMRPNeighborTable=hmDVMRPNeighborTable, hmDVMRPInterfaceLocalAddress=hmDVMRPInterfaceLocalAddress, hmDVMRPGeneralGroup=hmDVMRPGeneralGroup, hmDVMRPInterfaceEntry=hmDVMRPInterfaceEntry, hmDVMRPNeighborRcvBadRoutes=hmDVMRPNeighborRcvBadRoutes, hmDVMRPNeighborNotPruning=hmDVMRPNeighborNotPruning, hmDVMRPMIBObjects=hmDVMRPMIBObjects, hmDVMRPVersionString=hmDVMRPVersionString, hmDVMRPRouteSource=hmDVMRPRouteSource, hmDVMRPPruneGroup=hmDVMRPPruneGroup, hmDVMRPNeighborRcvRoutes=hmDVMRPNeighborRcvRoutes, hmDVMRPNeighborCapabilities=hmDVMRPNeighborCapabilities, hmDVMRPNeighborGenerationId=hmDVMRPNeighborGenerationId, hmDVMRPInterfaceInterfaceKey=hmDVMRPInterfaceInterfaceKey, hmDVMRPMIB=hmDVMRPMIB, hmDVMRPInterfaceTable=hmDVMRPInterfaceTable, hmDVMRPInterfaceSentRoutes=hmDVMRPInterfaceSentRoutes, hmDVMRPRouteUpstreamNeighbor=hmDVMRPRouteUpstreamNeighbor, hmDVMRPRouteUpTime=hmDVMRPRouteUpTime, hmDVMRPPruneEntry=hmDVMRPPruneEntry, hmDVMRPPruneExpiryTime=hmDVMRPPruneExpiryTime, hmDVMRPRouteNextHopType=hmDVMRPRouteNextHopType, hmDVMRPNeighborLoss=hmDVMRPNeighborLoss, hmDVMRPMIBConformance=hmDVMRPMIBConformance, hmDVMRPInterfaceGenerationId=hmDVMRPInterfaceGenerationId, hmDVMRPRouteSourceMask=hmDVMRPRouteSourceMask, hmDVMRPNeighborGroup=hmDVMRPNeighborGroup, hmDVMRPPruneSourceMask=hmDVMRPPruneSourceMask, hmDVMRPNeighborIfIndex=hmDVMRPNeighborIfIndex, hmDVMRPMIBGroups=hmDVMRPMIBGroups, hmDVMRPRouteNextHopSourceMask=hmDVMRPRouteNextHopSourceMask, hmDVMRPPruneLifetime=hmDVMRPPruneLifetime, hmDVMRPInterfaceIfIndex=hmDVMRPInterfaceIfIndex, hmDVMRPNeighborAddress=hmDVMRPNeighborAddress, hmDVMRPSecurityGroup=hmDVMRPSecurityGroup, hmDVMRPRouteNextHopIfIndex=hmDVMRPRouteNextHopIfIndex, hmDVMRPInterfaceStatus=hmDVMRPInterfaceStatus, hmDVMRPRouteNextHopTable=hmDVMRPRouteNextHopTable, hmDVMRPNeighborUpTime=hmDVMRPNeighborUpTime, hmDVMRPRouteNextHopEntry=hmDVMRPRouteNextHopEntry, hmDVMRPNeighborMajorVersion=hmDVMRPNeighborMajorVersion, hmDVMRPPruneTable=hmDVMRPPruneTable, hmDVMRPScalar=hmDVMRPScalar, hmDVMRPNeighborMinorVersion=hmDVMRPNeighborMinorVersion, hmDVMRPMIBCompliance=hmDVMRPMIBCompliance, hmDVMRPTraps=hmDVMRPTraps, hmDVMRPInterfaceInterfaceKeyVersion=hmDVMRPInterfaceInterfaceKeyVersion, hmDVMRPNeighborExpiryTime=hmDVMRPNeighborExpiryTime, hmDVMRPUpdateInterval=hmDVMRPUpdateInterval, hmDVMRPNeighborState=hmDVMRPNeighborState, hmDVMRPRouteMetric=hmDVMRPRouteMetric, hmDVMRPRouteExpiryTime=hmDVMRPRouteExpiryTime, hmDVMRPTreeGroup=hmDVMRPTreeGroup, hmDVMRPNeighborEntry=hmDVMRPNeighborEntry, PYSNMP_MODULE_ID=hmDVMRPMIB, hmDVMRPRoutingGroup=hmDVMRPRoutingGroup, hmDVMRP=hmDVMRP, hmDVMRPReachableRoutes=hmDVMRPReachableRoutes, hmDVMRPNumRoutes=hmDVMRPNumRoutes)
