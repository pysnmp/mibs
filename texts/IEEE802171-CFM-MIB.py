#
# PySNMP MIB module IEEE802171-CFM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/IEEE802171-CFM-MIB
# Produced by pysmi-1.1.3 at Wed Dec  1 16:51:33 2021
# On host fv-az36-754 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
LldpPortIdSubtype, LldpChassisIdSubtype, LldpManAddress, LldpChassisId, LldpPortId = mibBuilder.importSymbols("LLDP-MIB", "LldpPortIdSubtype", "LldpChassisIdSubtype", "LldpManAddress", "LldpChassisId", "LldpPortId")
VlanId, VlanIdOrNone = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "VlanIdOrNone")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Unsigned32, Gauge32, ObjectIdentity, zeroDotZero, ModuleIdentity, Counter32, NotificationType, Bits, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, MibIdentifier, Integer32, Counter64, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "ObjectIdentity", "zeroDotZero", "ModuleIdentity", "Counter32", "NotificationType", "Bits", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "MibIdentifier", "Integer32", "Counter64", "iso")
TextualConvention, MacAddress, DisplayString, TimeInterval, TimeStamp, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString", "TimeInterval", "TimeStamp", "TruthValue", "RowStatus")
TransportAddress, TransportDomain = mibBuilder.importSymbols("TRANSPORT-ADDRESS-MIB", "TransportAddress", "TransportDomain")
ieee8021cfmMIB = ModuleIdentity((1, 0, 8802, 1, 1, 3))
ieee8021cfmMIB.setRevisions(('2006-11-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ieee8021cfmMIB.setRevisionsDescriptions(('Included in IEEE P802.1ag Draft 7.',))
if mibBuilder.loadTexts: ieee8021cfmMIB.setLastUpdated('200611040000Z')
if mibBuilder.loadTexts: ieee8021cfmMIB.setOrganization('IEEE 802.1 Working Group')
if mibBuilder.loadTexts: ieee8021cfmMIB.setContactInfo('WG-URL:   http://grouper.ieee.org/groups/802/1/index.html\n        WG-EMail: stds-802-1@ieee.org \n\n        Contact:  David Elie-Dit-Cosaque\n\n                  Alcatel North America\n                  3400 W. Plano Pkwy.\n                  Plano, TX 75075, USA\n\n        E-mail:   david.elie_dit_cosaque@alcatel.com\n       ')
if mibBuilder.loadTexts: ieee8021cfmMIB.setDescription('Conectivity Fault Management module for managing IEEE 802.1ag')
dot1agNotifications = MibIdentifier((1, 0, 8802, 1, 1, 3, 0))
dot1agMIBObjects = MibIdentifier((1, 0, 8802, 1, 1, 3, 1))
dot1agCfmStack = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 1))
dot1agCfmDefaultMdLevel = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 2))
dot1agCfmConfigErrorList = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 3))
dot1agCfmMd = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 4))
dot1agCfmMa = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 5))
dot1agCfmMep = MibIdentifier((1, 0, 8802, 1, 1, 3, 1, 6))
class Dot1agCfmMaintDomainNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5, Table 21-19'
    description = 'A value that represents a type (and thereby the format)\n        of a Dot1agCfmMaintDomainName.  The value can be one of\n        the following:\n\n\n        ieeeReserved(0)   Reserved for definition by IEEE 802.1\n                          recommend to not use zero unless\n                          absolutely needed.\n        none(1)           No format specified, usually because\n                          there is not (yet) a Maintenenace\n                          Domain Name. In this case, a zero\n                          length OCTET STRING for the Domain\n                          Name field is acceptable.\n        dnsLikeName(2)    Domain Name like string, globally unique\n                          text string derived from a DNS name.\n        macAddrAndUint(3) MAC address + 2-octet (unsigned) integer.\n        charString(4)     RFC2579 DisplayString, except that the\n                          character codes 0-31 (decimal) are not\n                          used.\n        ieeeReserved(xx)  Reserved for definition by IEEE 802.1\n                          xx values can be [5..31] and [64..255]\n        ituReserved(xx)   Reserved for definition by  ITU-T Y.1731\n                          xx values range from [32..63]\n\n        To support future extensions, the Dot1agCfmMaintDomainNameType\n        textual convention SHOULD NOT be sub-typed in object type\n        definitions.  It MAY be sub-typed in compliance statements in\n        order to require only a subset of these address types for a\n        compliant implementation.\n\n        Implementations must ensure that Dot1agCfmMaintDomainNameType\n        objects and any dependent objects (e.g.,\n        Dot1agCfmMaintDomainName objects) are consistent.  An\n        inconsistentValue error must be generated if an attempt to\n        change an Dot1agCfmMaintDomainNameType object would, for\n        example, lead to an undefined Dot1agCfmMaintDomainName value.\n        In particular,\n        Dot1agCfmMaintDomainNameType/Dot1agCfmMaintDomainName pairs\n        must be changed together if the nameType changes.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("dnsLikeName", 2), ("macAddressAndUint", 3), ("charString", 4))

class Dot1agCfmMaintDomainName(TextualConvention, OctetString):
    reference = '802.1ag clause 21.6.5'
    description = "Denotes a generic Maintenance Domain Name.\n\n        A Dot1agCfmMaintDomainName value is always interpreted within\n        the context of a Dot1agCfmMaintDomainNameType value.  Every\n        usage of the Dot1agCfmMaintDomainName textual convention is\n        required to specify the Dot1agCfmMaintDomainNameType object\n        that provides the context.  It is suggested that the\n        Dot1agCfmMaintDomainNameType object be logically registered\n        before the object(s) that use the Dot1agCfmMaintDomainName\n        textual convention, if they appear in the same logical row.\n\n        The value of a Dot1agCfmMaintDomainName object must always\n        be consistent with the value of the associated\n        Dot1agCfmMaintDomainNameType object. Attempts to set\n        an Dot1agCfmMaintDomainName object to a value inconsistent\n        with the associated Dot1agCfmMaintDomainNameType must fail\n        with an inconsistentValue error.\n\n        When this textual convention is used as the syntax of an\n        index object, there may be issues with the limit of 128\n        sub-identifiers specified in SMIv2, IETF STD 58.  In this\n        case, the object definition MUST include a 'SIZE' clause\n        to limit the number of potential instance sub-identifiers;\n        otherwise the applicable constraints MUST be stated in\n        the appropriate conceptual row DESCRIPTION clauses, or\n        in the surrounding documentation if there is no single\n        DESCRIPTION clause that is appropriate.\n\n        A value of none(1) in the associated\n        Dot1agCfmMaintDomainNameType object means that no Maintenance\n        Domain name is present, and the contents of the\n        Dot1agCfmMaintDomainName object are meaningless.\n\n        See the DESCRIPTION of the Dot1agCfmMaintAssocNameType\n        TEXTUAL-CONVENTION for a discussion of the length limits on\n        the Maintenance Domain name and Maintenance Association name.\n       "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 43)

class Dot1agCfmMaintAssocNameType(TextualConvention, Integer32):
    reference = '802.1ag clause 21.6.5.4, Table 21-20'
    description = 'A value that represents a type (and thereby the format)\n        of a Dot1agCfmMaintAssocName.  The value can be one of\n        the following:\n\n\n        ieeeReserved(0)   Reserved for definition by IEEE 802.1\n                          recommend to not use zero unless\n                          absolutely needed.\n        primaryVid(1)     Primary VLAN ID.\n                          12 bits represented in a 2-octet integer:\n                          - 4 least significant bits of the first\n                            byte contains the 4 most significant \n                            bits of the 12 bits primary VID\n                          - second byte contains the 8 least\n                            significant bits of the primary VID\n\n                                 0 1 2 3 4 5 6 7 8\n                                 +-+-+-+-+-+-+-+-+\n                                 |0 0 0 0| (MSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VID   LSB    |\n                                 +-+-+-+-+-+-+-+-+\n\n        charString(2)     RFC2579 DisplayString, except that the\n                          character codes 0-31 (decimal) are not\n                          used. (1..47)octets\n        unsignedInt16 (3) 2-octet integer/big endian\n        rfc2865VpnId(4)   RFC 2685 VPN ID\n                          3 octet VPN authority Organizationally\n                          Unique Identifier followed by 4 octet VPN\n                          index identifying VPN according to the OUI:\n\n                                 0 1 2 3 4 5 6 7 8\n                                 +-+-+-+-+-+-+-+-+\n                                 | VPN OUI (MSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |   VPN OUI     |\n                                 +-+-+-+-+-+-+-+-+\n                                 | VPN OUI (LSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |VPN Index (MSB)|\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VPN Index    |\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VPN Index    |\n                                 +-+-+-+-+-+-+-+-+\n                                 |VPN Index (LSB)|\n                                 +-+-+-+-+-+-+-+-+\n\n        ieeeReserved(xx)  Reserved for definition by IEEE 802.1\n                          xx values can be [5..31] and [64..255]\n        ituReserved(xx)   Reserved for definition by  ITU-T Y.1731\n                          xx values range from [32..63]\n\n        To support future extensions, the Dot1agCfmMaintAssocNameType\n        textual convention SHOULD NOT be sub-typed in object type\n        definitions.  It MAY be sub-typed in compliance statements in\n        order to require only a subset of these address types for a\n        compliant implementation.\n\n        Implementations must ensure that Dot1agCfmMaintAssocNameType\n        objects and any dependent objects (e.g.,\n        Dot1agCfmMaintAssocName objects) are consistent.  An\n        inconsistentValue error must be generated if an attempt to\n        change an Dot1agCfmMaintAssocNameType object would, for\n        example, lead to an undefined Dot1agCfmMaintAssocName value.\n        In particular,\n        Dot1agCfmMaintAssocNameType/Dot1agCfmMaintAssocName pairs\n        must be changed together if the nameType changes.\n\n        The Mainteanance Domain name and Maintenance Assication name,\n        when put together into the CCM PDU, MUST total 48 octets or\n        less.  If the Dot1agCfmMaintDomainNameType object contains\n        none(1), then the Dot1agCfmMaintAssocName object MUST be\n        45 octets or less in length.  Otherwise, the length of\n        the Dot1agCfmMaintDomainName object plus the length of the\n        Dot1agCfmMaintAssocName object, added together, MUST total\n        less than or equal to 44 octets.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("primaryVid", 1), ("charString", 2), ("unsignedInt16", 3), ("rfc2865VpnId", 4))

class Dot1agCfmMaintAssocName(TextualConvention, OctetString):
    reference = '802.1ag clauses 21.6.5.4, 21.6.5.5, 21.6.5.6'
    description = "Denotes a generic Maintenance Association Name. It is the\n        part of the Maintenance Association Identifier which is\n        unique within the Maintenance Domain Name and is appended\n        to the Maintenance Domain Name to form the Maintenance\n        Association Identifier (MAID).\n\n        A Dot1agCfmMaintAssocName value is always interpreted within\n        the context of a Dot1agCfmMaintAssocNameType value.  Every\n        usage of the Dot1agCfmMaintAssocName textual convention is\n        required to specify the Dot1agCfmMaintAssocNameType object\n        that provides the context.  It is suggested that the\n        Dot1agCfmMaintAssocNameType object be logically registered\n        before the object(s) that use the Dot1agCfmMaintAssocName\n        textual convention, if they appear in the same logical row.\n\n        The value of a Dot1agCfmMaintAssocName object must \n        always be consistent with the value of the associated\n        Dot1agCfmMaintAssocNameType object. Attempts to set\n        an Dot1agCfmMaintAssocName object to a value inconsistent\n        with the associated Dot1agCfmMaintAssocNameType must fail\n        with an inconsistentValue error.\n\n        When this textual convention is used as the syntax of an\n        index object, there may be issues with the limit of 128\n        sub-identifiers specified in SMIv2, IETF STD 58.  In this\n        case, the object definition MUST include a 'SIZE' clause\n        to limit the number of potential instance sub-identifiers;\n        otherwise the applicable constraints MUST be stated in\n        the appropriate conceptual row DESCRIPTION clauses, or\n        in the surrounding documentation if there is no single\n        DESCRIPTION clause that is appropriate.\n       "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 45)

class Dot1agCfmMaintenanceDomainLevel(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 21.4.1'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\n        Higher numbers correspond to higher Maintenance Domains,\n        those with the greatest physical reach, with the highest\n        values for customers' CFM packets.  Lower numbers correspond\n        to lower Maintenance Domains, those with more limited\n        physical reach, with the lowest values for single bridges or\n        physical links.\n\n        The value (-1) is reserved to indicate that no MA Level has\n        been assigned.\n       "
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 7), )
class Dot1agCfmMpDirection(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.3.2:c'
    description = 'Indicates the direction in which the Maintenance\n        association (MEP or MIP) faces on the bridge port:\n\n        down(1)    Sends Continuity Check Messages away from the\n                   MAC Relay Entity.\n        up(2)      Sends Continuity Check Messages towards the\n                   MAC Relay Entity.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("down", 1), ("up", 2))

class Dot1agCfmPortStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:f, 20.19.3 and 21.5.4'
    description = 'An enumerated value from he Port Status TLV from the last CCM\n        received from the last MEP. It indicates the ability of the\n        Bridge Port on which the transmitting MEP resides to pass\n        ordinary data, regardless of the status of the MAC\n        (Table 21-10).\n\n        psNoPortStateTLV(0) Indicates either that no CCM has been\n                            received or that no port status TLV was\n                            present in the last CCM received.\n\n        psBlocked(1)        Ordinary data cannot pass freely through\n                            the port on which the remote MEP resides.\n                            Value of enableRmepDefect is equal to\n                            false.\n\n        psUp(2):            Ordinary data can pass freely through\n                            the port on which the remote MEP resides.\n                            Value of enableRmepDefect is equal to\n                            true.\n\n        NOTE: A 0 value is used for psNoPortStateTLV, so that\n              additional code points can be added in a manner\n              consistent with the Dot1agCfmInterfaceStatus textual\n              convention.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("psNoPortStateTLV", 0), ("psBlocked", 1), ("psUp", 2))

class Dot1agCfmInterfaceStatus(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.6.3:g, 20.19.4 and 21.5.5'
    description = 'An enumerated value from the Interface Status TLV from the \n        last CCM received from the last MEP. It indicates the status\n        of the Interface within which the MEP transmitting the CCM\n        is configuredr, or the next lower Interface in the Interface\n        Stack, if the MEP is not configured within an Interface.\n\n    isNoInterfaceSatatusTLV(0)  Indicates either that no CCM has been\n                          received or that no interface status TLV\n                          was present in the last CCM received.\n\n    isUp(1)               The interface is ready to pass packets.\n\n    isDown(2)             The interface cannot pass packets\n\n    isTesting(3)          The interface is in some test mode.\n   \n    isUnknown(4)          The interface status cannot be determined\n                          for some reason.\n\n    isDormant(5)          The interface is not in a state to pass\n                          packets but is in a pending state, waiting\n                          for some external event.\n    \n    isNotPresent(6)       Some component of the interface is missing\n    \n    isLowerLayerDown(7)   The interface is down due to state of the\n                          lower layer interfaces\n\n        NOTE: A 0 value is used for isNoInterfaceSatatusTLV, so that\n              these code points can be kept consistent with new code\n              points added to ifOperStatus in the IF-MIB.\n\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("isNoInterfaceSatatusTLV", 0), ("isUp", 1), ("isDown", 2), ("isTesting", 3), ("isUnknown", 4), ("isDormant", 5), ("isNotPresent", 6), ("isLowerLayerDown", 7))

class Dot1agCfmHighestDefectPri(TextualConvention, Integer32):
    reference = '802.1ag clause 20.1.2, 12.14.7.7.2:c and 20.33.9'
    description = 'An enumerated value, equal to the contents of the variable\n        highestDefect (20.33.9 and Table 20-1), indicating the\n        highest-priority defect that has been present since the MEP\n        Fault Notification Generator State Machine was last in the \n        FNG_RESET state, either:\n\n        none(1)           no defects since FNG_RESET\n        defRDICCM(2)      DefRDICCM\n        defMACstatus(3)   DefMACstatus\n        defRemoteCCM(4)   DefRemoteCCM\n        defErrorCCM(5)    DefErrorCCM\n        defXconCCM(6)     DefXconCCM\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 1), ("defRDICCM", 2), ("defMACstatus", 3), ("defRemoteCCM", 4), ("defErrorCCM", 5), ("defXconCCM", 6))

class Dot1agCfmLowestAlarmPri(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:k and 20.9.5'
    description = 'An integer value specifying the lowest priority defect\n        that is allowed to generate a Fault Alarm (20.9.5), either:\n\n        allDef(1)           DefRDICCM, DefMACstatus, DefRemoteCCM,\n                            DefErrorCCM, and DefXconCCM;\n        macRemErrXcon(2)    Only DefMACstatus, DefRemoteCCM,\n                            DefErrorCCM, and DefXconCCM (default);\n        remErrXcon(3)       Only DefRemoteCCM, DefErrorCCM,\n                            and DefXconCCM;\n        errXcon(4)          Only DefErrorCCM and DefXconCCM;\n        xcon(5)             Only DefXconCCM; or\n        noDef(6)            No defects are to be reported;\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("allDef", 1), ("macRemErrXcon", 2), ("remErrXcon", 3), ("errXcon", 4), ("xcon", 5), ("noDef", 6))

class Dot1agCfmMepId(TextualConvention, Unsigned32):
    reference = '802.1ag clauses 3.19 and 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n        integer, unique over a given Maintenance Association,\n        identifying a specific MEP.\n       '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 8191)

class Dot1agCfmMepIdOrZero(TextualConvention, Unsigned32):
    reference = '802.1ag clause 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n        integer, unique over a given Maintenance Association,\n        identifying a specific MEP.\n \n        The special value 0 is allowed to indicate special cases, for\n        example that no MEPID is configured in a given Maintenance\n        Assosiation point.\n\n        Whenever an object is defined with this SYNTAX, then the\n        DESCRIPTION clause of such an object MUST specify what the\n        special value of 0 means.\n       '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), )
class Dot1agCfmMhfCreation(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.5.1.3:c and 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs.\n        The valid values are:\n\n        defMHFnone(1)      No MHFs can be created for this VID.\n        defMHFdefault(2)   MHFs can be created on this VID on any\n                           Bridge port through which this VID can\n                           pass.\n        defMHFexplicit(3)  MHFs can be created for this VID only on\n                           Bridge ports through which this VID can\n                           pass, and only if a MEP is created at some\n                           lower MA Level.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))

class Dot1agCfmCcmInterval(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.1.3:d, 20.8.1 and 21.6.1.3'
    description = "Indicates the interval at which CCMs are sent by a MEP.\n        The possible values are:\n        intervalInvalid(0) No CCMs are sent (disabled).\n        interval300Hz(1)   CCMs are sent every 3 1/3 milliseconds\n                           (300Hz).\n        interval10ms(2)    CCMs are sent every 10 milliseconds.\n        interval100ms(3)   CCMs are sent every 100 milliseconds.\n        interval1s(4)      CCMs are sent every 1 second.\n        interval10s(5)     CCMs are sent every 10 seconds.\n        interval1min(6)    CCMs are sent every minute.\n        interval10min(7)   CCMs are sent every 10 minutes.\n\n        Note: enumerations start at zero to match the 'CCM Interval\n              field' protocol field.\n       "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("intervalInvalid", 0), ("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7))

class Dot1agCfmFngState(TextualConvention, Integer32):
    reference = '802.1ag clause 12.14.7.1.3:f and 20.35'
    description = 'Indicates the diferent states of the MEP Fault Notification\n        Generator State Machine.\n\n        fngReset(1)            No defect has been present since the\n                               dot1agCfmMepFngResetTime timer\n                               expired, or since the state machine\n                               was last reset.\n\n        fngDefect(2)           A defect is present, but not for a\n                               long enough time to be reported \n                               (dot1agCfmMepFngAlarmTime).\n\n        fngReportDefect(3)     A momentary state during which the\n                               defect is reported by sending a\n                               dot1agCfmFaultAlarm notification,\n                               if that action is enabled.\n\n        fngDefectReported(4)   A defect is present, and some defect\n                               has been reported.\n\n        fngDefectClearing(5)   No defect is present, but the\n                               dot1agCfmMepFngResetTime timer has\n                               not yet expired.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("fngReset", 1), ("fngDefect", 2), ("fngReportDefect", 3), ("fngDefectReported", 4), ("fngDefectClearing", 5))

class Dot1agCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.5, 21.9.5, and\n        Table 21-27'
    description = 'Possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class Dot1agCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.6, 21.9.8.1, and\n        Table 21-30\n       '
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class Dot1agCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:o, 20.36.2.10, 21.9.9.1, and\n        Table 21-32'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class Dot1agCfmRemoteMepState(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.6.3:b, 20.22'
    description = 'Operational state of the remote MEP state machine.  This\n        state machine motitors the reception of valid CCMs from a\n        remote MEP with a specific MEPID.  It uses a timer that\n        expires in 3.5 times the lengh of time indicated by the\n        dot1agCfmMaCcmInterval object.\n\n        rMepIdle(1)            Momentary state during reset.\n\n        rMepStart(2)           The timer has not expired since the\n                               state machine was reset, and no valid\n                               CCM has yet been received.\n\n        rMepFailed(3)          The timer has expired, both since the\n                               state machine was reset, and since a\n                               valid CCM was received.\n\n        rMepOk(4)              The timer has not expired since a\n                               valid CCM was received.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("rMepIdle", 1), ("rMepStart", 2), ("rMepFailed", 3), ("rMepOk", 4))

class Dot1afCfmIndexIntegerNextFree(TextualConvention, Unsigned32):
    description = 'An integer which may be used as a new Index in a table.\n\n       The special value of 0 indicates that no more new entries can\n       be created in the relevant table.\n\n       When a MIB is used for configuration, an object with this\n       SYNTAX always contains a legal value (if non-zero) for an\n       index that is not currently used in the relevant table. The\n       Command Generator (Network Management Application) reads this\n       variable and uses the (non-zero) value read when creating a\n       new row with an SNMP SET.  When the SET is performed, the\n       Command Responder (agent) must determine whether the value is\n       indeed still unused; Two Network Management Applications may\n       attempt to create a row (configuration entry) simultaneously\n       and use the same value. If it is currently unused, the SET\n       succeeds and the Command Responder (agent) changes the value\n       of this object, according to an implementation-specific\n       algorithm.  If the value is in use, however, the SET fails.\n       The Network Management Application must then re-read this\n       variable to obtain a new usable value.\n\n       An OBJECT-TYPE definition using this SYNTAX MUST specify the\n       relevant table for which the object is providing this\n       functionality.\n      '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class Dot1agCfmConfigErrors(TextualConvention, Bits):
    reference = '802.1ag clause 12.14.4.1.3:b and clauses 22.2.3 and 22.2.4'
    description = "While making the MIP creation evaluation described in 802.1ag\n        clause 22.2.3, the management entity can encounter errors in\n        the configuration. These are possible errors that can be\n        encountered:\n\n        CFMleak(0)   MA x is associated with a specific VID list,\n                     one or more of the VIDs in MA x can pass through\n                     the Bridge Port, no Down MEP is configured on\n                     any Bridge Port for MA x, and some other MA y,\n                     at a higher MD Level than MA x, and associated\n                     with at least one of the VID(s) also in MA x,\n                     does have a MEP configured on the Bridge Port.\n\n        conflictingVids(1)  MA x is associated with a specific VID\n                     list, an Up MEP is configured on MA x on the\n                     Bridge Port, and some other MA y, associated\n                     with at least one of the VID(s) also in MA x,\n                     also has an Up MEP configured on some Bridge\n                     Port.\n\n        ExcessiveLevels(2)  The number of different MD Levels at\n                     which MIPs are to be created on this port\n                     exceeds the Bridge's capabilities (see\n                     subclause 22.3).\n\n        OverlappedLevels(3) A MEP is created for one VID at one MD\n                     Level, but a MEP is configured on another\n                     VID at that MD Level or higher, exceeding\n                     the Bridge's capabilities.\n       "
    status = 'current'
    namedValues = NamedValues(("cfmLeak", 0), ("conflictingVids", 1), ("excessiveLevels", 2), ("overlappedLevels", 3))

dot1agCfmStackTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 1, 1), )
if mibBuilder.loadTexts: dot1agCfmStackTable.setReference('802.1ag clauses 12.14.2')
if mibBuilder.loadTexts: dot1agCfmStackTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackTable.setDescription('There is one CFM Stack Managed object  per bridge. It permits\n        the retrieval of information about the maintenance Points\n        configured on any given interface.\n       ')
dot1agCfmStackEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 1, 1, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmStackifIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmStackDirection"))
if mibBuilder.loadTexts: dot1agCfmStackEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackEntry.setDescription('The Stack table entry')
dot1agCfmStackifIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setReference('802.1ag clause 12.14.2.1.2:a')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setDescription('This object represents the  Bridge Port or aggregated port\n        on which MEPs or MHFs might be configured.\n       ')
dot1agCfmStackDirection = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 1, 1, 1, 2), Dot1agCfmMpDirection())
if mibBuilder.loadTexts: dot1agCfmStackDirection.setReference('802.1ag clause 12.14.2.1.2:c')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setDescription('Direction in which the MP faces on the Bridge Port')
dot1agCfmStackMepId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 1, 1, 1, 3), Dot1agCfmMepIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMepId.setReference('802.1ag clause 12.14.2.1.2:d')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setDescription('If an MEP is configured, the MEPID, else 0')
dot1agCfmStackMacAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 1, 1, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setReference('802.1ag clause 12.14.2.1.3:e')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setDescription('MAC address of the MP.')
dot1agCfmDefaultMdLevelTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 2, 1), )
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelTable.setReference('802.1ag clause 12.14.3')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelTable.setDescription('The Default MD Level Managed Object controls MHF creation for\n        VIDs that are not attached to a specific Maintenance\n        Association Managed Object.\n\n       The writable objects in this table need to be persistent upon reboot\n       or restart of a device.\n       ')
dot1agCfmDefaultMdLevelEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 2, 1, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmDefaultMdLevelIndex"))
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelEntry.setDescription('The Default MD Level table entry.')
dot1agCfmDefaultMdLevelIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelIndex.setDescription('The index to the default MD Level table')
dot1agCfmDefaultMdLevelVid = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 2, 1, 1, 2), VlanIdOrNone()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelVid.setReference('802.1ag clause 12.14.3.1.3:a')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelVid.setDescription('This is a VLAN ID monitored by MA.')
dot1agCfmDefaultMdLevelMhfCreation = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 2, 1, 1, 3), Dot1agCfmMhfCreation().clone('defMHFnone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelMhfCreation.setReference('802.1ag clause 12.14.3.1.3:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelMhfCreation.setDescription('A value indicating if the Management entity can create MHFs\n        (MIP Half Function) for this VID.\n       ')
dot1agCfmDefaultMdLevelLevel = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 2, 1, 1, 4), Dot1agCfmMaintenanceDomainLevel().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelLevel.setReference('802.1ag clause 12.14.3.1.3:c')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelLevel.setDescription('The MD Level at which MHFs are to be created, or -1 if\n        defMHFnone.\n       ')
dot1agCfmConfigErrorListTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 3, 1), )
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setReference('802.1ag clause 12.14.4')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setDescription('The CFM Configuration Error List table provides a list of\n        Interfaces and VIDs that are incorrectly configured.\n       ')
dot1agCfmConfigErrorListEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 3, 1, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmConfigErrorListVid"), (0, "IEEE802171-CFM-MIB", "dot1agCfmConfigErrorListIfIndex"))
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setDescription('The Config Error List Table  entry')
dot1agCfmConfigErrorListVid = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 3, 1, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setReference('802.1ag Clause 12.14.4.1.2:a')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setDescription('The vlan ID of the vlan with errored interfaces.')
dot1agCfmConfigErrorListIfIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 3, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setReference('802.1ag clause 12.14.4.1.2:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setDescription('This object is the IfIndex of the interface.')
dot1agCfmConfigErrorListErrorType = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 3, 1, 1, 3), Dot1agCfmConfigErrors()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setReference('802.1ag clause 12.14.4.1.3:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setDescription('A vector of Boolean error conditions from 22.2.4, any of\n        which may be true:\n\n        1) CFMleak;\n        2) ConflictingVids;\n        3) ExcessiveLevels;\n        4) OverlappedLevels.\n       ')
dot1agCfmMdTableNextIndex = MibScalar((1, 0, 8802, 1, 1, 3, 1, 4, 1), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setDescription('This object contains an unused value for dot1agCfmMdIndex in\n        the dot1agCfmMdTable, or a zero to indicate that none exist.\n       ')
dot1agCfmMdTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 4, 2), )
if mibBuilder.loadTexts: dot1agCfmMdTable.setReference('802.1ag clauses 3.22 and 18.1')
if mibBuilder.loadTexts: dot1agCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTable.setDescription('The MaintenanceDomain table. Each row in the table represents\n        a different maintenance domain.\n\n        A Maintenace domain is described in 802.1ag (3.22) as the\n        network or the part of the network for which faults in\n        connectivity are to be managed. The boundary of a Maintenance\n        Domain is defined by a set of DSAPs, each of which can become\n        a point of connectivity to a service instance.\n       ')
dot1agCfmMdEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"))
if mibBuilder.loadTexts: dot1agCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost\n        upon reboot. It is backed up by stable storage.\n       ')
dot1agCfmMdIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMdIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdIndex.setDescription('The index to the maintenance domain table.\n\n        dot1agCfmMdTableNextIndex needs to be inspected to find an\n        available index for row-creation.\n\n        Referential integrity is required i.e. the index needs to be\n        persistent upon a reboot or restart of a device.  The index\n        can never be reused for other maintenance domain.  The index\n        value should keep increasing up to the time that they wrap\n        around. This is to facilitate access control based on OID.\n       ')
dot1agCfmMdFormat = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 2), Dot1agCfmMaintDomainNameType().clone('charString')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFormat.setReference('802.1ag clause 21.6.5.1')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
dot1agCfmMdName = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 3), Dot1agCfmMaintDomainName().clone('DEFAULT')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdName.setReference('802.1ag clauses 3.24, 12.14.5, and 21.6.5.3')
if mibBuilder.loadTexts: dot1agCfmMdName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdName.setDescription('The Maintenance Domain name. The type/format of this object\n        is determined by the value of the dot1agCfmMdNameType object.\n          \n        Each Maintenance Domain has unique name amongst all those\n        used or available to a service provider or operator.  It\n        facilitates easy identification of administrative\n        responsibility for each Maintenance Domain.\n\n        Clause 3.24 defines a Maintenance Domain name as the\n        identifier, unique over the domain for which CFM is to\n        protect against accidental concatenation of Service\n        Instances, of a particular Maintenance Domain.\n       ')
dot1agCfmMdLevel = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 4), Dot1agCfmMaintenanceDomainLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdLevel.setReference('802.1ag clause 12.14.5.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdLevel.setDescription('The Maintenance Domain Level.')
dot1agCfmMdMhfCreation = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 5), Dot1agCfmMhfCreation().clone('defMHFnone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setReference('802.1ag clause 12.14.5.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setDescription('Enumerated value indicating whether the management entity can\n        create MHFs (MIP Half Function) for this Maintenance Domain.\n       ')
dot1agCfmMdFaultAlarmDestDomain = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 6), TransportDomain().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFaultAlarmDestDomain.setReference('802.1ag clause 12.14.5.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMdFaultAlarmDestDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFaultAlarmDestDomain.setDescription("The transportDomain for the address to which Fault Alarms\n        are to be transmitted.\n\n        Typical values will be one of (not all inclusive) list:\n\n           transportDomainUdpIpv4  (from TRANSPORT-ADDRESS-MIB)\n           transportDomainUdpIpv6  (from TRANSPORT-ADDRESS-MIB)\n           snmpIeee802Domain       (from SNMP-IEEE802-TM-MIB)\n\n        The value 'zeroDotZero' indicates 'Fault Alarms are not to\n        be transmitted', in which case the related object of SYNTAX\n        TransportAddress must have a zero-length OCTET STRING as\n        a value.\n       ")
dot1agCfmMdFaulAlarmDestAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 7), TransportAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFaulAlarmDestAddress.setReference('802.1ag clause 12.14.5.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMdFaulAlarmDestAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFaulAlarmDestAddress.setDescription("The transportAddress to which Fault Alarms are to be\n        transmitted to. The type/format of this object is determined\n        by the value of the dot1agCfmMdFaultAlarmDestDomain.\n\n        If the dot1agCfmMdFaultAlarmDestDomain object has a value of\n        'zeroDotZero' (indicating 'Fault Alarms are not to be\n        transmitted') then this object should have a value of a\n        zero-length OCTET STRING. \n       ")
dot1agCfmMdRowStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 4, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns must have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMaTableNextIndex = MibScalar((1, 0, 8802, 1, 1, 3, 1, 5, 1), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMaTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaTableNextIndex.setDescription('Value to be used as the index of the MA table when the\n        management entity wants to create a new row in the table.\n       ')
dot1agCfmMaTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 5, 3), )
if mibBuilder.loadTexts: dot1agCfmMaTable.setReference('802.1ag clause 18.2')
if mibBuilder.loadTexts: dot1agCfmMaTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaTable.setDescription('The Maintenance Association table.  Each row in the table\n        represents an MA.  An MA is a set of MEPs, each configured\n        with a single service instance.\n\n        Creation of a Service Instance establishes a connectionless\n        association among the selected DSAPs.  Configuring a\n        Maintenance association End Point (MEP) at each of the\n        DSAPs creates a Maintenance Association (MA) to monitor\n        that connectionless connectivity.  The MA is identified by a\n        Short MA Name that is unique within the Maintenance Domain\n        and chosen to facilitate easy identification of the Service\n        Instance.  Together, the Maintenance Domain Name and the\n        Short MA Name form the Maintenance Association Identifier\n        (MAID) that is carried in CFM Messages to identify\n        incorrect connectivity among Service Instances.  A small\n        integer, the Maintenance association End Point Identifier\n        (MEPID), identifies each MEP among those configured on a\n        single MA (802.1ag clauses 3.17 and 18.2).\n\n        This table uses two indices, first index is the index of the\n        Maintenance Domain table.\n\n       The writable objects in this table need to be persistent\n       upon reboot or restart of a device.\n\n       ')
dot1agCfmMaEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaEntry.setDescription('The MA table entry.')
dot1agCfmMaIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 4094), ValueRangeConstraint(16777217, 4294967295), )))
if mibBuilder.loadTexts: dot1agCfmMaIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaIndex.setDescription('Index of the MA table dot1agCfmMaTableNextIndex needs to\n        be inspected to find an available index for row-creation\n                1..4094       -> describes an MA entry associated\n                                 with a VID\n         16777217..4294967295 -> describes an MA entry not associated\n                                 with any VID\n       ')
dot1agCfmMaFormat = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 2), Dot1agCfmMaintAssocNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaFormat.setReference('802.1ag clauses 21.6.5.4')
if mibBuilder.loadTexts: dot1agCfmMaFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaFormat.setDescription('The type (and thereby format) of the Maintenance Association\n        Name.\n       ')
dot1agCfmMaName = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 3), Dot1agCfmMaintAssocName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaName.setReference('802.1ag clauses 21.6.5.6, and Table 21-20')
if mibBuilder.loadTexts: dot1agCfmMaName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaName.setDescription('The Short Maintenance Association name. The type/format of\n        this object is determined by the value of the\n        dot1agCfmMaNameType object.\n       ')
dot1agCfmMaMhfCreation = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 4), Dot1agCfmMhfCreation().clone('defMHFnone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setReference('802.1ag clause 12.14.6.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMhfCreation.setDescription('Indicates if the Management entity can create MHFs (MIP Half\n        Function) for this MA.\n       ')
dot1agCfmMaCcmInterval = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 5), Dot1agCfmCcmInterval().clone('interval1s')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setReference('802.1ag clause 12.14.6.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaCcmInterval.setDescription('Interval between CCM transmissions to be used by all MEPs\n        in the MA.\n       ')
dot1agCfmMaFaultAlarmDestDomain = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 6), TransportDomain().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaFaultAlarmDestDomain.setReference('802.1ag clause 12.14.6.1.3:e')
if mibBuilder.loadTexts: dot1agCfmMaFaultAlarmDestDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaFaultAlarmDestDomain.setDescription("The transportDomain for the address to which Fault Alarms\n        are to be transmitted.\n\n        Typical values will be one of (not all inclusive) list:\n\n            transportDomainUdpIpv4  (from TRANSPORT-ADDRESS-MIB)\n            transportDomainUdpIpv6  (from TRANSPORT-ADDRESS-MIB)\n            snmpIeee802Domain       (from SNMP-IEEE802-TM-MIB)\n          \n        The value 'zeroDotZero' indicates 'Fault Alarms are not to\n        be transmitted', in which case the related object of SYNTAX \n        transportAddress must have a zero-length OCTET STRING as\n        a value.\n       ")
dot1agCfmMaFaulAlarmDestAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 7), TransportAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaFaulAlarmDestAddress.setReference('802.1ag clause 12.14.6.1.3:e')
if mibBuilder.loadTexts: dot1agCfmMaFaulAlarmDestAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaFaulAlarmDestAddress.setDescription("The transportAddress to which Fault Alarms are to be\n        transmitted to. The type/format of this object is determined\n        by the value of the dot1agCfmMaFaultAlarmDestDomain.\n\n        If the dot1agCfmMaFaultAlarmDestDomain object has a value of\n        'zeroDotZero' (indicating 'Fault Alarms are not to be\n        transmitted') then this object should have a value of a\n        zero-length OCTET STRING. \n       ")
dot1agCfmMaMoreThanOneVid = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 8), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMoreThanOneVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMoreThanOneVid.setDescription('True indicate that the MA is associated with more that one\n        VID.  False indicates that the MA is associated with only one\n        VID or no VID.  This value should be false for MAs with an\n        index greater than 16777216.\n       ')
dot1agCfmMaRowStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 3, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns must have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMaVlanTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 5, 4), )
if mibBuilder.loadTexts: dot1agCfmMaVlanTable.setReference('802.1ag clause 12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaVlanTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaVlanTable.setDescription('If an MA is associated with multiple VIDs, then this table\n        contains all the VIDs associated with the MA other than the\n        primary VID.\n\n       The writable objects in this table need to be persistent\n       upon reboot or restart of a device.\n       ')
dot1agCfmMaVlanEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 5, 4, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaVlanVid"))
if mibBuilder.loadTexts: dot1agCfmMaVlanEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaVlanEntry.setDescription('The Maintenance Association VLAN table entry.')
dot1agCfmMaVlanVid = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 4, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmMaVlanVid.setReference('802.1ag clause 12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaVlanVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaVlanVid.setDescription('This is a VLAN ID of the vlan monitored by the MA.  VID 0\n        means that the MA is not associated with any VLAN.\n       ')
dot1agCfmMaVlanRowStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaVlanRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns must have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMaMepListTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 5, 8), )
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setReference('802.1ag clause 12.14.6.1.3:f')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setDescription('List of MEPIDs (in any bridge) that belong to the same MA.\n \n        Clause 12.14.6.1.3 specifies that a list of MEPIDs in all\n        bridges in that MA, but since SNMP SMI does not allow to\n        state in a MIB that an object in a table is an array, the \n        information has to be stored in another table with two\n        indices, being the first index, the index of the table that \n        contains the list or array.\n       ')
dot1agCfmMaMepListEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 5, 8, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaMepListIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setDescription('The known MEPS table entry.')
dot1agCfmMaMepListIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 8, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setReference('802.1ag clause 12.14.6.1.3:f')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setDescription('MEPID')
dot1agCfmMaMepListRowStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 5, 8, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setDescription('The status of the row. Read SNMPv2-TC (RFC1903) for an\n        explanation of the possible values this object can take.\n       ')
dot1agCfmMepTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 6, 1), )
if mibBuilder.loadTexts: dot1agCfmMepTable.setReference('802.1ag clauses 12.14.7 and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTable.setDescription("The Maintenance Association End Point (MEP) table.\n\n        Each row in the table represents a different MEP.  A MEP is\n        an actively managed CFM entity, associated with a specific\n        DSAP of a Service Instance, which can generate and receive\n        CFM PDUs and track any responses.  It is an end point of a\n        single Maintenance Association, and is an endpoint of a\n        separate Maintenance Entity for each of the other MEPs in\n        the same Maintenance Association (802.1ag clause 3.18).\n\n        This table uses three indices. The first two indices are the\n        indices of the Maintenance Domain and MA tables, the reason\n        being that a MEP is always related to an MA and Maintenance\n        Domain.\n\n        The Transmit Loopback table.  Entries in this table are\n        created/removed at the same time than entries in the MEP\n        table are created/removed.\n\n        The MEP table also stores all the managed objects for sending\n        LBM and LTM.\n\n        *LBM Managed objects\n\n        LBM Managed objects in the MEP table \n        enables the management entity to initiate\n        transmission of Loopback messages.  It will signal the MEP\n        that it should transmit some number of Loopback messages\n        and detect the detection (or lack thereof) of the\n        corresponding Loopback messages.\n \n        Steps to use entries in this table:\n\n        1) Wait for dot1agCfmMepTransmitLbmStatus value to be\n           'ready'.  To do this do this sequence:\n           a. an SNMP GET for both SnmpSetSerialNo and\n              dot1agCfmMepTransmitLbmStatus objects (in same SNMP\n              PDU).\n           b. Check if value for dot1agCfmMepTransmitLbmStatus is\n              'ready'\n              - if not, wait x seconds, goto step a above.\n              - if yes, save the value of SnmpSetSerialNo and go\n                to step 2) below\n        2) Change dot1agCfmMepTransmitLbmStatus value from 'ready' to\n           'notReady' to ensure no other management entity will use\n           the service. In order to not disturb a possible other NMS\n           do this by sending an SNMP SET for both SnmpSetSerialNo \n           and dot1agCfmMepTransmitLbmStatus objects (in same SNMP\n           PDU,  and make sure SNmpSetSerialNo is the first varBind).\n           For the SnmpSetSerialNo varBind, use the value that you\n           obtained in step 1)a.. This ensures that two cooperating\n           NMSes will not step on each others toes.\n        3) Setup the different data to be sent (number of messages,\n           optional TLVs,...).\n        4) Record the current values of dot1agCfmMepLbrIn,\n           dot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu.\n        6) Change dot1agCfmMepTransmitLbmStatus value from 'notReady'\n           to 'transmit' to initiate transmission of Loopback\n           messages.\n        7) Check the value of dot1agCfmMepTransmitLbmResultOK to\n           find out if the operation was sucessfully initiated or\n           not.\n        8) Monitor the value of dot1agCfmMepTransmitLbmMessages.\n           When it reaches 0, the last LBM has been transmitted.\n           Wait an additional 5 seconds to ensure that all LBRs have\n           been returned.\n        9) Compare dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder,\n           and dot1agCfmMepLbrBadMsdu to their old values from step\n           4, above, to get the results of the test.\n       10) Change the dot1agCfmMepTransmitLbmStatus value back to\n           'ready' to allow other management entities to use the\n           table.\n\n        *LTM Managed objects\n        The LTM Managed objects in the MEP table are used in a manner\n        similar to that described for LBM transmission, above.  Upon\n        successfully initiating the transmission, the variables\n        dot1agCfmMepTransmitLtmSeqNumber and\n        dot1agCfmMepTransmitLtmEgressIdentifier return the information\n        required to recover the results of the LTM from the\n        dot1agCfmLtrTable.\n       ")
dot1agCfmMepEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepEntry.setDescription('The MEP table entry')
dot1agCfmMepIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setReference('802.1ag clauses 3.19, 19.2 and 12.14.7')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setDescription('Integer that is unique among all the MEPs in the same MA.\n        Other definition is: a small integer, unique over a given\n        Maintenance Association, identifying a specific Maintenance\n        association End Point (3.19).\n\n        MEP Identifier is also known as the MEPID.\n       ')
dot1agCfmMepIfIndex = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setReference('802.1ag clause 12.14.7.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setDescription('This object is the interface index of the interface eiter a\n        bridge port, or an aggregated IEEE 802.1 link within a bridge\n        port, to which the MEP is attached.\n       ')
dot1agCfmMepDirection = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 3), Dot1agCfmMpDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepDirection.setReference('802.1ag clauses 12.14.7.1.3:c and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setDescription('The direction in which the MEP faces on the Bridge port.')
dot1agCfmMepPrimaryVid = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setReference('802.1ag clauses 12.14.7.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setDescription("An integer indicating the Primary VID of the MEP, always\n        one of the VIDs assigned to the MEP's MA.  The value 0\n        indicates that either the Primary VID is that of the\n        MEP's MA, or that the MEP's MA is associated with no VID.")
dot1agCfmMepActive = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepActive.setReference('802.1ag clauses 12.14.7.1.3:e and 20.9.1')
if mibBuilder.loadTexts: dot1agCfmMepActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepActive.setDescription('Administrative state of the MEP\n\n        A Boolean indicating the administrative state of the MEP.\n\n        True indicates that the MEP is to function normally, and\n        false that it is to cease functioning.')
dot1agCfmMepFngState = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 6), Dot1agCfmFngState().clone('fngReset')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepFngState.setReference('802.1ag clauses 12.14.7.1.3:f and 20.35')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setDescription('Current state of the MEP Fault Notification Generator\n        State Machine.\n       ')
dot1agCfmMepCciEnabled = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setReference('802.1ag clauses 12.14.7.1.3:g and 20.10.1')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setDescription('If set to true, the MEP will generate CCM messages.')
dot1agCfmMepCcmLtmPriority = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setReference('802.1ag clause 12.14.7.1.3:h')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setDescription('The priority value for CCMs and LTMs transmitted by the MEP.\n        Default Value in the highest priority value allowed to pass\n        through the bridge port for any of this MEPs VIDs.\n        The management entity can obtain the default valuefor this \n        variable from the priority regeneration table by extracting the \n        highest priority value in this table on this MEPs bridge port.\n        (1 is lowest, then 2, then 0, then 3-7).\n       ')
dot1agCfmMepMacAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setReference('802.1ag clause 12.14.7.1.3:i and 19.4')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setDescription('MAC address of the MEP.')
dot1agCfmMepFaultAlarmDestDomain = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 10), TransportDomain().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFaultAlarmDestDomain.setReference('802.1ag clause 12.14.7.1.3:j')
if mibBuilder.loadTexts: dot1agCfmMepFaultAlarmDestDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFaultAlarmDestDomain.setDescription("The transportDomain for the address to which Fault Alarms\n        are to be transmitted. \n\n        Typical values will be one of (not all inclusive) list:\n\n            transportDomainUdpIpv4  (from TRANSPORT-ADDRESS-MIB)\n            transportDomainUdpIpv6  (from TRANSPORT-ADDRESS-MIB)\n            snmpIeee802Domain       (from SNMP-IEEE802-TM-MIB)\n          \n        The value 'zeroDotZero' indicates 'Fault Alarms are not to\n        be transmitted', in which case the related object of SYNTAX \n        transportAddress must have a zero-length OCTET STRING as\n        a value.\n       ")
dot1agCfmMepFaulAlarmDestAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 11), TransportAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFaulAlarmDestAddress.setReference('802.1ag clause 12.14.7.1.3:j')
if mibBuilder.loadTexts: dot1agCfmMepFaulAlarmDestAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFaulAlarmDestAddress.setDescription("The transportAddress to which Fault Alarms (12.14.7.7) are\n        to be transmitted to.  The type/format of this object is\n        determined by the value of dot1agCfmMepFaultAlarmDestDomain.\n\n        If the dot1agCfmMepFaultAlarmDestDomain object has a value of\n        'zeroDotZero' (indicating 'Fault Alarms are not specified')\n        then this object should have a value of a zero-length OCTET\n        STRING.\n\n        If 'Fault Alarms are not specified', the address used is\n        that from the Maintenance Association managed object\n        (12.14.6.1.3:e).\n       ")
dot1agCfmMepLowPrDef = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 12), Dot1agCfmLowestAlarmPri().clone('macRemErrXcon')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setReference('802.1ag clause 12.14.7.1.3:k and 20.9.5 and Table 20-1')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setDescription('An integer value specifying the lowest priority defect \n        that is allowed to generate fault alarm.\n       ')
dot1agCfmMepFngAlarmTime = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 13), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(250)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setReference('802.1ag clauses 12.14.7.1.3:l and 20.33.3')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setDescription('The time that defects must be present before a Fault Alarm is\n        issued (fngAlarmTime. 20.33.3) (default 2.5s).\n       ')
dot1agCfmMepFngResetTime = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 14), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setReference('802.1ag clauses 12.14.7.1.3:m and 20.33.4')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setDescription('The time that defects must be absent before re-enabling a\n        Fault Alarm (fngResetTime, 20.33.4) (default 10s).\n       ')
dot1agCfmMepHighestPrDefect = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 15), Dot1agCfmHighestDefectPri()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setReference('802.1ag clause 12.14.7.1.3:n  20.33.9 and Table 21-1')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setDescription('The highest priority defect that has been present since the\n        MEPs Fault Notification Generator State Machine was last in\n        the FNG_RESET state.\n       ')
dot1agCfmMepSomeRdiDefect = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepSomeRdiDefect.setReference('802.1ag clauses 12.14.7.1.3:o and 20.33.7')
if mibBuilder.loadTexts: dot1agCfmMepSomeRdiDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepSomeRdiDefect.setDescription("A Boolean flag indicating that some other MEP in this MEP's MA\n        is transmitting the RDI bit.\n       ")
dot1agCfmMepErrMacStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrMacStatus.setReference('802.1ag clause 12.14.7.1.3:p  20.33.6')
if mibBuilder.loadTexts: dot1agCfmMepErrMacStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrMacStatus.setDescription('A Boolean flag (someMACstatusDefect, 20.33.6) indicating that\n        a Port Status TLV (21.5.4) or Interface Status TLV (21.5.5)\n        is indicating an error condition (can trigger DefMACstatus).\n       ')
dot1agCfmMepSomeRMepCcmDefect = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepSomeRMepCcmDefect.setReference('802.1ag clauses 12.14.7.1.3:q and 20.33.5')
if mibBuilder.loadTexts: dot1agCfmMepSomeRMepCcmDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepSomeRMepCcmDefect.setDescription('A Boolean flag indicating that CCMs are not being received\n        from at least one of the configured remote MEPs.\n       ')
dot1agCfmMepErrorCcmDefect = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmDefect.setReference('802.1ag clauses 12.14.7.1.3:r and 20.21.3')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmDefect.setDescription("A Boolean flag indicating that a stream of erroneous CCMs\n        is being received from some MEP in this MEP's MA.\n       ")
dot1agCfmMepXconCcmDefect = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepXconCcmDefect.setReference('802.1ag clauses 12.14.7.1.3:s and 20.23.3')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmDefect.setDescription('A Boolean flag indicating that a stream of CCMs is being\n        received from a MEP that may be in some other MA.\n       ')
dot1agCfmMepErrorCcmLastFailure = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:t and 20.21.2')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setDescription('The last-received CCM that triggered an DefErrorCCM fault.')
dot1agCfmMepXconCcmLastFailure = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:u and 20.23.2')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setDescription('The last-received CCM that triggered a DefXconCCM fault.')
dot1agCfmMepRCcmSequenceErrors = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepRCcmSequenceErrors.setReference('802.1ag clauses 12.14.7.1.3:v and 20.19.7')
if mibBuilder.loadTexts: dot1agCfmMepRCcmSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepRCcmSequenceErrors.setDescription('The total number of out-of-sequence CCMs received from all\n        remote MEPs.\n       ')
dot1agCfmMepCciSentCcms = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setReference('802.1ag clauses 12.14.7.1.3:w and 20.10.2')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setDescription('Total number of Continuity Check messages transmitted.')
dot1agCfmMepNextLbmTransId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setReference('802.1ag clauses 12.14.7.1.3:x and 20.28.2')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setDescription('Next sequence number/transaction identifier to be sent in a\n        Loopback message. This sequence number can be zero because\n        it wraps around.\n       ')
dot1agCfmMepLbrIn = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setReference('802.1ag clause 12.14.7.1.3:y and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
dot1agCfmMepLbrInOutOfOrder = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setReference('802.1ag clause 12.14.7.1.3:z and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies\n        received.\n       ')
dot1agCfmMepLbrBadMsdu = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setReference('802.1ag clause 12.14.7.1.3:aa  20.2.3')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setDescription('(optional) The total number of LBRs received whose\n        mac_service_data_unit did not match (except for the OpCode)\n        that of the corresponding LBM (20.2.3).\n       ')
dot1agCfmMepLtmNextSeqNumber = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setReference('802.1ag clause 12.14.7.1.3:ab and 20.36.1')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setDescription('Next transaction identifier/sequence number to be sent in a\n        Linktrace message. This sequence number can be zero because\n        it wraps around.\n       ')
dot1agCfmMepUnexpLtrIn = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setReference('802.1ag clause 12.14.7.1.3:ac  20.39.1')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setDescription('The total number of unexpected LTRs received (20.39.1).\n       ')
dot1agCfmMepLbrOut = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setReference('802.1ag clause 12.14.7.1.3:ad ans 20.26.2')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setDescription('Total number of Loopback Replies transmitted.')
dot1agCfmMepTransmitLbmStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 32), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n       that another LBM may be transmitted. \n       Reset to false by the MEP Loopback Initiator State Machine.')
dot1agCfmMepTransmitLbmDestMacAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 33), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n        destination MAC address.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLbmDestIsMepId is 'false'.\n       ")
dot1agCfmMepTransmitLbmDestMepId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 34), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setDescription("The Maintenance association End Point Identifier of another\n        MEP in the same Maintenance Association to which the LBM is\n        to be sent.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLbmDestIsMepId is 'true'.\n       ")
dot1agCfmMepTransmitLbmDestIsMepId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 35), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setReference('802.1ag clause 12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setDescription('True indicates that MepID of the target MEP is used for\n        Loopback transmission.\n        False indicates that unicast destination MAC address of the\n        target MEP is used for Loopback transmission.\n       ')
dot1agCfmMepTransmitLbmMessages = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setReference('802.1ag clause 12.14.7.3.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setDescription('The number of Loopback messages to be transmitted.')
dot1agCfmMepTransmitLbmDataTlv = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1500))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setReference('802.1ag clause 12.14.7.3.2:d')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setDescription('An arbitrary amount of data to be included in the Data TLV,\n        if the Data TLV is selected to be sent.\n       ')
dot1agCfmMepTransmitLbmVlanPriority = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setDescription('Priority. 3 bit value to be used in the VLAN tag, if present\n        in the transmitted frame.\n\n        The default value is CCM priority.\n       ')
dot1agCfmMepTransmitLbmVlanDropEnable = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 39), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setReference('802.1ag clause 12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit value to be used in the VLAN tag, if present\n        in the transmitted frame.\n\n        For more information about VLAN Drop Enable, please check\n        IEEE 802.1ad.\n       ')
dot1agCfmMepTransmitLbmResultOK = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 40), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setDescription('Indicates the result of the operation:\n\n        - true       The Loopback Message(s) will be\n                     (or hasbeen) sent.\n        - false      The Loopback Message(s) will not\n                     be sent.\n       ')
dot1agCfmMepTransmitLbmSeqNumber = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 41), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setReference('802.1ag clause 12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setDescription('The Loopback Transaction Identifier\n       (dot1agCfmMepNextLbmTransId) of the first LBM (to be) sent.\n        The value returned is undefined if\n        dot1agCfmMepTransmitLbmResultOK is false.\n       ')
dot1agCfmMepTransmitLtmStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 42), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n       that another LTM may be transmitted. \n       Reset to false by the MEP Linktrace Initiator State Machine.')
dot1agCfmMepTransmitLtmFlags = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 43), Bits().clone(namedValues=NamedValues(("useFDBonly", 0))).clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setReference('802.1ag clause 12.14.7.4.2:b and 20.37.1')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setDescription('The flags field for LTMs transmitted by the MEP.')
dot1agCfmMepTransmitLtmTargetMacAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 44), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n        destination MAC address.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLtmTargetIsMepId is 'false'.\n       ")
dot1agCfmMepTransmitLtmTargetMepId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 45), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setDescription("An indication of the Target MAC Address Field to be\n        transmitted:\n        The Maintenance association End Point Identifier of\n        another MEP in the same Maintenance Association\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLtmTargetIsMepId is 'true'.\n       ")
dot1agCfmMepTransmitLtmTargetIsMepId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 46), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setReference('802.1ag clause 12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setDescription('True indicates that MepID of the target MEP is used for\n        Linktrace transmission.\n        False indicates that unicast destination MAC address of the\n        target MEP is used for Loopback transmission.\n       ')
dot1agCfmMepTransmitLtmTtl = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 47), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setReference('802.1ag clause 12.14.7.4.2:d and 21.8.4')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64.\n        The TTL field indicates the number of hops remaining to the\n        LTM.  Decremented by 1 by each Linktrace Responder that\n        handles the LTM.  The decremented value is returned in the\n        LTR.  If 0 on input, the LTM is discarded.  If 0 on output,\n        the LTM is not transmitted to the next hop.\n       ')
dot1agCfmMepTransmitLtmResult = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 48), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setDescription('Indicates the result of the operation:\n\n        - true    The Linktrace Message will be (or has been) sent.\n        - false   The Linktrace Message will not be sent')
dot1agCfmMepTransmitLtmSeqNumber = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 49), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setReference('802.1ag clause 12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setDescription('The LTM Transaction Identifier\n        (dot1agCfmMepLtmNextSeqNumber) of the LTM sent.\n        The value returned is undefined if\n        dot1agCfmMepTransmitLtmResult is false.\n       ')
dot1agCfmMepTransmitLtmEgressIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 50), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setReference('802.1ag clause 12.14.7.4.3:b and 21.8.8')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setDescription('Identifies the MEP Linktrace Initiator that is originating,\n        or the Linktrace Responder that is forwarding, this LTM.\n        The low-order six octets contain a 48-bit IEEE MAC address\n        unique to the system in which the MEP Linktrace Initiator\n        or Linktrace Responder resides.  The high-order two octets\n        contain a value sufficient to uniquely identify the MEP\n        Linktrace Initiator or Linktrace Responder within that system.\n\n        For most Bridges, the address of any MAC attached to the\n        Bridge will suffice for the low-order six octets, and 0 for\n        the high-order octets.  In some situations, e.g. if multiple\n        virtual Bridges utilizing emulated LANs are implemented in a\n        single physical system, the high-order two octets can be used\n        to differentiate among the transmitting entities.\n\n        The value returned is undefined if\n        dot1agCfmMepTransmitLtmResult is false.\n       ')
dot1agCfmMepRowStatus = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 1, 1, 51), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns must have a valid value before a row\n        can be activated.\n       ')
dot1agCfmLtrTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 6, 2), )
if mibBuilder.loadTexts: dot1agCfmLtrTable.setReference('802.1ag clause 12.14.7.5')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setDescription('This table extends the MEP table and contains a list of\n        Linktrace replies received by a specific MEP in response to\n        a linktrace message.\n\n        SNMP SMI does not allow to state in a MIB that an object in\n        a table is an array.  The solution is to take the index (or\n        indices) of the first table and add one or more indices.\n       ')
dot1agCfmLtrEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE802171-CFM-MIB", "dot1agCfmLtrSeqNumber"), (0, "IEEE802171-CFM-MIB", "dot1agCfmLtrReceiveOrder"))
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setDescription('The LinktraceReply table entry.')
dot1agCfmLtrSeqNumber = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setReference('802.1ag clause 12.14.7.5.2:b')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setDescription("Transaction identifier/Sequence number returned by a previous\n        transmit linktrace message command, indicating which LTM's\n        response is going to be returned.\n       ")
dot1agCfmLtrReceiveOrder = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setReference('802.1ag clause 12.14.7.5.2:c')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR\n        Transaction Identifier field value.  dot1agCfmLtrReceiveOrder\n        are assigned sequentially from 1, in the order that the\n        Linktrace Initiator received the LTRs.\n       ')
dot1agCfmLtrTtl = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setReference('802.1ag clause 12.14.7.5 and 20.36.2.2')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setDescription('TTL field value for a returned LTR.')
dot1agCfmLtrForwarded = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setReference('802.1ag clauses 12.14.7.5.3:c and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setDescription("Indicates if a LTM was forwarded by the repsonding MP, as\n        returned ind the 'FwdYes' flag of the flags field.\n       ")
dot1agCfmLtrTerminalMep = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setReference('802.1ag clauses 12.14.7.5.3:d and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setDescription('A boolean value stating whether the forwarded LTM reached a\n        MEP enclosing its MA, as returned in the Terminal MEP flag of\n        the Flags field.\n       ')
dot1agCfmLtrLastEgressIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:e and 20.36.2.3')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setDescription('An octet field holding the Last Egress Identifier returned in\n        the LTR.\n        The Last Egress Identifier identifies the MEP Linktrace \n        Initiator that originated, or the Linktrace Responder that \n        forwarded, the LTM to which this LTR is the response.  This\n        is the same value as the Egress Identifier field of that LTM.\n       ')
dot1agCfmLtrNextEgressIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:f and 20.36.2.4')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setDescription('An octet field holding the Next Egress Identifier returned in\n        the LTR.\n        The Next Egress Identifier Identifies the Linktrace Responder\n        that transmitted this LTR, and can forward the LTM to the next\n        hop.  This is the same value as the Egress Identifier of the \n        forwarded LTM, if any. If the FwdYes bit of the Flags field is\n        false, the contents of this field are undefined, i.e. any value\n        can be transmitted, and the field is ignored by the receiver.\n       ')
dot1agCfmLtrRelay = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 8), Dot1agCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setReference('802.1ag clauses 12.14.7.5.3:g and 20.36.2.5')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setDescription('Value returned in the Relay Action field.')
dot1agCfmLtrChassisIdSubtype = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 9), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID returned\n        in the Sender ID TLV of the LTR, if any.  This value is\n        meaningless if the dot1agCfmLtrChassisId has a length of 0.')
dot1agCfmLtrChassisId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 10), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setReference('802.1ag clauses 12.14.7.5.3:i and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setDescription('The Chassis ID returned in the Sender ID TLV of the LTR, if\n        any. The format of this object is determined by the\n        value of the dot1agCfmLtrChassisIdSubtype object.\n       ')
dot1agCfmLtrManAddressType = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 11), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddressType.setReference('802.1ag clauses 12.14.7.5.3:j and 21.5.3.5')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressType.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressType.setDescription('Management Address subtype of the bridge transmitting the\n        LTR, if returned in a Sender ID TLV.  The value is\n        meaningless if the dot1agCfmLtrManAddress has a length of 0.\n       ')
dot1agCfmLtrManAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 12), LldpManAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setReference('802.1ag clauses 12.14.7.5.3:j and 21.5.3.5')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setDescription('Management Address information of the bridge transmitting\n        the LTR, if returned in the Sender ID TLV.\n \n        Some limitation to the size of the TLVs carrying a Manaement\n        Address is needed, as there is no bound on the lengths of\n        AddressFamilyNumbers.  31 octets, the maximum length of\n        LldpManAddress,  is long enough for currently deployed\n        systems.  This MIB module assumes that SNMP (IETF STD 62) is\n        used along with the Management Address to access the\n        management database.\n      ')
dot1agCfmLtrIngress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 13), Dot1agCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setReference('802.1ag clauses 12.14.7.5.3:k and 20.36.2.6')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM.')
dot1agCfmLtrIngressMac = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setReference('802.1ag clauses 12.14.7.5.3:l and 20.36.2.7')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field.')
dot1agCfmLtrIngressPortIdSubtype = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 15), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:m and 20.36.2.8')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID.')
dot1agCfmLtrIngressPortId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 16), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setReference('802.1ag clauses 12.14.7.5.3:n and 20.36.2.9')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by\n        the value of the dot1agCfmLtrIngressPortIdSubtype object.\n       ')
dot1agCfmLtrEgress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 17), Dot1agCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setReference('802.1ag clauses 12.14.7.5.3:o and 20.36.2.10')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM.')
dot1agCfmLtrEgressMac = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setReference('802.1ag clauses 12.14.7.5.3:p and 20.36.2.11')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setDescription('MAC address returned in the egress MAC address field.')
dot1agCfmLtrEgressPortIdSubtype = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 19), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:q and 20.36.2.12')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID.')
dot1agCfmLtrEgressPortId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 20), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setReference('802.1ag clauses 12.14.7.5.3:r and 20.36.2.13')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by\n        the value of the dot1agCfmLtrEgressPortIdSubtype object.\n       ')
dot1agCfmLtrOrganizationSpecificTlv = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 2, 1, 21), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 1500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setReference('802.1ag clauses 12.14.7.5.3:s, 21.5.2')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setDescription('All Organization specific TLVs returned in the LTR, if\n        any.  Includes all octets including and following the TLV\n        Length field of each TLV, concatenated together.')
dot1agCfmMepDbTable = MibTable((1, 0, 8802, 1, 1, 3, 1, 6, 3), )
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setReference('802.1ag clause 19.2.15')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setDescription('The MEP Database. A database, maintained by every MEP, that\n        maintains received information about other MEPs in the\n        Maintenance Domain.\n\n        SNMP SMI does not allow to stat in a MIB that an object in\n        a table is an array. The solution is to take the index (or\n        indices) of the first table and add one or more indices.\n       ')
dot1agCfmMepDbEntry = MibTableRow((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1), ).setIndexNames((0, "IEEE802171-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE802171-CFM-MIB", "dot1agCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setDescription('The MEP Database table entry.')
dot1agCfmMepDbRMepIdentifier = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setReference('802.1ag clause 12.14.7.6.2:b')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setDescription('Maintenance association End Point Identifier of a remote MEP\n        whose information from the MEP Database is to be returned.\n       ')
dot1agCfmMepDbRMepState = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 2), Dot1agCfmRemoteMepState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setReference('802.1ag clause 12.14.7.6.3:b and 20.22')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setDescription('The operational state of the remote MEP IFF State machines.')
dot1agCfmMepDbRMepFailedOkTime = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setReference('802.1ag clause 12.14.7.6.3:c')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setDescription('The time (SysUpTime) at which the IFF Remote MEP state machine\n        last entered either the RMEP_FAILED or RMEP_OK state.\n       ')
dot1agCfmMepDbMacAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setReference('802.1ag clause 12.14.7.6.3:d and 20.19.8')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setDescription('The MAC address of the remote MEP.')
dot1agCfmMepDbRdi = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setReference('802.1ag clauses 12.14.7.6.3:e and 20.19.2')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setDescription('State of the RDI bit in the last received CCM (true for\n        RDI=1), or false if none has been received.\n       ')
dot1agCfmMepDbPortStatusTlv = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 6), Dot1agCfmPortStatus().clone('psNoPortStateTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setReference('802.1ag clause 12.14.7.6.3:f and 20.19.3')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setDescription('An enumerated value of the Port status TLV received in the\n        last CCM from the remote MEP or the default value\n        psNoPortStateTLV indicating either no CCM has been received,\n        or that nor port status TLV was received in the last CCM.\n       ')
dot1agCfmMepDbInterfaceStatusTlv = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 7), Dot1agCfmInterfaceStatus().clone('isNoInterfaceSatatusTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setReference('802.1ag clause 12.14.7.6.3:g and 20.19.4')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setDescription('An enumerated value of the Interface status TLV received\n        in the last CCM from the remote MEP or the default value\n        isNoInterfaceStatus TLV indicating either no CCM has been\n        received, or that no interface status TLV was received in\n        the last CCM.\n       ')
dot1agCfmMepDbChassisIdSubtype = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 8), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID received\n        in the last CCM.')
dot1agCfmMepDbChassisId = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 9), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setDescription('The Chassis ID. The format of this object is determined by the\n        value of the dot1agCfmLtrChassisIdSubtype object.\n       ')
dot1agCfmMepDbManAddressType = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 10), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressType.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.5')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressType.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressType.setDescription('Management Address subtype of the bridge transmitting the\n        CCM.\n       ')
dot1agCfmMepDbManAddress = MibTableColumn((1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 11), LldpManAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.5')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setDescription('Management Address information of the bridge transmitting\n        the CCM.\n \n        Some limitation to the size of the TLVs carrying a Manaement\n        Address is needed, as there is no bound on the lengths of\n        AddressFamilyNumbers.  31 octets, the maximum length of\n        LldpManAddress,  is long enough for currently deployed\n        systems.  This MIB module assumes that SNMP (IETF STD 62) is\n        used along with the Management Address to access the\n        management database.\n       ')
dot1agCfmFaultAlarm = NotificationType((1, 0, 8802, 1, 1, 3, 0, 1)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmMepHighestPrDefect"))
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setDescription('A MEP has a persistent defect condition. A notification\n        (fault alarm) is sent to the management entity with the OID\n        of the MEP that has detected the fault.\n\n        Whenever a MEP has a persistent defect,\n        it may or may not generate a Fault Alarm to warn the system\n        administrator of the problem, as controlled by the MEP\n        Fault Notification Generator State Machine and associated\n        Managed Objects. Only the highest-priority defect, as shown\n        in Table 20-1, is reported in the Fault Alarm.\n\n        The management entity receiving the notification can identify\n        the system from the network source address of the\n        notification, and can identify the MEP reporting the defect\n        by the indices in the OID of the dot1agCfmMepHighestPrDefect\n        variable in the notification.\n       ')
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setReference('802.1ag clause 12.14.7.7')
dot1agCfmConformance = MibIdentifier((1, 0, 8802, 1, 1, 3, 2))
dot1agCfmCompliances = MibIdentifier((1, 0, 8802, 1, 1, 3, 2, 1))
dot1agCfmGroups = MibIdentifier((1, 0, 8802, 1, 1, 3, 2, 2))
dot1agCfmStackGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 1)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmStackMepId"), ("IEEE802171-CFM-MIB", "dot1agCfmStackMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmStackGroup = dot1agCfmStackGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmStackGroup.setDescription('Objects for the Stack group.')
dot1agCfmDefaultMdLevelGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 2)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmDefaultMdLevelMhfCreation"), ("IEEE802171-CFM-MIB", "dot1agCfmDefaultMdLevelLevel"), ("IEEE802171-CFM-MIB", "dot1agCfmDefaultMdLevelVid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmDefaultMdLevelGroup = dot1agCfmDefaultMdLevelGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevelGroup.setDescription('Objects for the Default MD Level group.')
dot1agCfmConfigErrorListGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 3)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmConfigErrorListErrorType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmConfigErrorListGroup = dot1agCfmConfigErrorListGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListGroup.setDescription('Objects for the Cfm Configuration Error List Group.')
dot1agCfmMdGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 4)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmMdTableNextIndex"), ("IEEE802171-CFM-MIB", "dot1agCfmMdName"), ("IEEE802171-CFM-MIB", "dot1agCfmMdFormat"), ("IEEE802171-CFM-MIB", "dot1agCfmMdLevel"), ("IEEE802171-CFM-MIB", "dot1agCfmMdMhfCreation"), ("IEEE802171-CFM-MIB", "dot1agCfmMdFaultAlarmDestDomain"), ("IEEE802171-CFM-MIB", "dot1agCfmMdFaulAlarmDestAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMdRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMdGroup = dot1agCfmMdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdGroup.setDescription('Objects for the Maintenance Domain Group.')
dot1agCfmMaGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 5)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmMaTableNextIndex"), ("IEEE802171-CFM-MIB", "dot1agCfmMaName"), ("IEEE802171-CFM-MIB", "dot1agCfmMaFormat"), ("IEEE802171-CFM-MIB", "dot1agCfmMaMhfCreation"), ("IEEE802171-CFM-MIB", "dot1agCfmMaCcmInterval"), ("IEEE802171-CFM-MIB", "dot1agCfmMaRowStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmMaVlanRowStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmMaFaultAlarmDestDomain"), ("IEEE802171-CFM-MIB", "dot1agCfmMaFaulAlarmDestAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMaMoreThanOneVid"), ("IEEE802171-CFM-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMaGroup = dot1agCfmMaGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaGroup.setDescription('Objects for the MA group.')
dot1agCfmMepGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 6)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmMepIfIndex"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDirection"), ("IEEE802171-CFM-MIB", "dot1agCfmMepPrimaryVid"), ("IEEE802171-CFM-MIB", "dot1agCfmMepActive"), ("IEEE802171-CFM-MIB", "dot1agCfmMepFngState"), ("IEEE802171-CFM-MIB", "dot1agCfmMepCciEnabled"), ("IEEE802171-CFM-MIB", "dot1agCfmMepCcmLtmPriority"), ("IEEE802171-CFM-MIB", "dot1agCfmMepMacAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepFaultAlarmDestDomain"), ("IEEE802171-CFM-MIB", "dot1agCfmMepFaulAlarmDestAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLowPrDef"), ("IEEE802171-CFM-MIB", "dot1agCfmMepFngAlarmTime"), ("IEEE802171-CFM-MIB", "dot1agCfmMepFngResetTime"), ("IEEE802171-CFM-MIB", "dot1agCfmMepHighestPrDefect"), ("IEEE802171-CFM-MIB", "dot1agCfmMepSomeRdiDefect"), ("IEEE802171-CFM-MIB", "dot1agCfmMepErrMacStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmMepSomeRMepCcmDefect"), ("IEEE802171-CFM-MIB", "dot1agCfmMepErrorCcmDefect"), ("IEEE802171-CFM-MIB", "dot1agCfmMepXconCcmDefect"), ("IEEE802171-CFM-MIB", "dot1agCfmMepErrorCcmLastFailure"), ("IEEE802171-CFM-MIB", "dot1agCfmMepXconCcmLastFailure"), ("IEEE802171-CFM-MIB", "dot1agCfmMepRCcmSequenceErrors"), ("IEEE802171-CFM-MIB", "dot1agCfmMepCciSentCcms"), ("IEEE802171-CFM-MIB", "dot1agCfmMepNextLbmTransId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLbrIn"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLbrInOutOfOrder"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLbrBadMsdu"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLtmNextSeqNumber"), ("IEEE802171-CFM-MIB", "dot1agCfmMepUnexpLtrIn"), ("IEEE802171-CFM-MIB", "dot1agCfmMepLbrOut"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmDestMacAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmDestMepId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmDestIsMepId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmMessages"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmDataTlv"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmVlanPriority"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmVlanDropEnable"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmResultOK"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLbmSeqNumber"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmFlags"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMacAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMepId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmTargetIsMepId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmTtl"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmResult"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmSeqNumber"), ("IEEE802171-CFM-MIB", "dot1agCfmMepTransmitLtmEgressIdentifier"), ("IEEE802171-CFM-MIB", "dot1agCfmMepRowStatus"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrForwarded"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrRelay"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrChassisIdSubtype"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrChassisId"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrManAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrManAddressType"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrIngress"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrIngressMac"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrIngressPortIdSubtype"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrIngressPortId"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrEgress"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrEgressMac"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrEgressPortIdSubtype"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrEgressPortId"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrTerminalMep"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrLastEgressIdentifier"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrNextEgressIdentifier"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrTtl"), ("IEEE802171-CFM-MIB", "dot1agCfmLtrOrganizationSpecificTlv"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepGroup = dot1agCfmMepGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepGroup.setDescription('Objects for the MEP group.')
dot1agCfmMepDbGroup = ObjectGroup((1, 0, 8802, 1, 1, 3, 2, 2, 7)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmMepDbRMepState"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbRMepFailedOkTime"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbMacAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbRdi"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbPortStatusTlv"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbInterfaceStatusTlv"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbChassisIdSubtype"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbChassisId"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbManAddress"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbManAddressType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepDbGroup = dot1agCfmMepDbGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbGroup.setDescription('Objects for the MEP group.')
dot1agCfmNotificationsGroup = NotificationGroup((1, 0, 8802, 1, 1, 3, 2, 2, 8)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmFaultAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmNotificationsGroup = dot1agCfmNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmNotificationsGroup.setDescription('Objects for the Notifications group.')
dot1agCfmCompliance = ModuleCompliance((1, 0, 8802, 1, 1, 3, 2, 1, 1)).setObjects(("IEEE802171-CFM-MIB", "dot1agCfmStackGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmDefaultMdLevelGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmConfigErrorListGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmMdGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmMaGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmMepGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmMepDbGroup"), ("IEEE802171-CFM-MIB", "dot1agCfmNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmCompliance = dot1agCfmCompliance.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmCompliance.setDescription('The compliance statement for support of the CFM MIB module.')
mibBuilder.exportSymbols("IEEE802171-CFM-MIB", dot1agCfmLtrTable=dot1agCfmLtrTable, Dot1agCfmMepIdOrZero=Dot1agCfmMepIdOrZero, dot1agCfmMaMepListTable=dot1agCfmMaMepListTable, dot1agCfmMepDbRdi=dot1agCfmMepDbRdi, dot1agCfmMepDbManAddressType=dot1agCfmMepDbManAddressType, dot1agCfmStackifIndex=dot1agCfmStackifIndex, Dot1agCfmIngressActionFieldValue=Dot1agCfmIngressActionFieldValue, dot1agCfmLtrManAddressType=dot1agCfmLtrManAddressType, dot1agCfmMepCcmLtmPriority=dot1agCfmMepCcmLtmPriority, dot1agCfmLtrEgress=dot1agCfmLtrEgress, dot1agCfmMepMacAddress=dot1agCfmMepMacAddress, dot1agCfmMepLowPrDef=dot1agCfmMepLowPrDef, dot1agCfmMaTableNextIndex=dot1agCfmMaTableNextIndex, dot1agCfmLtrEgressMac=dot1agCfmLtrEgressMac, dot1agCfmMaEntry=dot1agCfmMaEntry, dot1agCfmLtrChassisId=dot1agCfmLtrChassisId, dot1agCfmMa=dot1agCfmMa, dot1agCfmFaultAlarm=dot1agCfmFaultAlarm, dot1agCfmMepSomeRdiDefect=dot1agCfmMepSomeRdiDefect, dot1agCfmMepCciEnabled=dot1agCfmMepCciEnabled, dot1agCfmMepXconCcmLastFailure=dot1agCfmMepXconCcmLastFailure, dot1agCfmMaFaultAlarmDestDomain=dot1agCfmMaFaultAlarmDestDomain, PYSNMP_MODULE_ID=ieee8021cfmMIB, dot1agCfmDefaultMdLevelTable=dot1agCfmDefaultMdLevelTable, dot1agCfmMepDbMacAddress=dot1agCfmMepDbMacAddress, dot1agCfmMepTable=dot1agCfmMepTable, dot1agCfmConfigErrorList=dot1agCfmConfigErrorList, dot1agCfmMepTransmitLbmResultOK=dot1agCfmMepTransmitLbmResultOK, dot1agCfmMepRCcmSequenceErrors=dot1agCfmMepRCcmSequenceErrors, dot1agCfmMep=dot1agCfmMep, dot1agCfmMdFaulAlarmDestAddress=dot1agCfmMdFaulAlarmDestAddress, dot1agCfmStackGroup=dot1agCfmStackGroup, dot1agCfmMaVlanRowStatus=dot1agCfmMaVlanRowStatus, dot1agCfmMepDbRMepIdentifier=dot1agCfmMepDbRMepIdentifier, dot1agCfmMaMoreThanOneVid=dot1agCfmMaMoreThanOneVid, dot1agCfmLtrEgressPortId=dot1agCfmLtrEgressPortId, dot1agCfmMepTransmitLtmEgressIdentifier=dot1agCfmMepTransmitLtmEgressIdentifier, Dot1agCfmMpDirection=Dot1agCfmMpDirection, dot1agCfmConfigErrorListIfIndex=dot1agCfmConfigErrorListIfIndex, dot1agCfmMepNextLbmTransId=dot1agCfmMepNextLbmTransId, dot1agCfmMepUnexpLtrIn=dot1agCfmMepUnexpLtrIn, Dot1agCfmFngState=Dot1agCfmFngState, dot1agCfmMaFaulAlarmDestAddress=dot1agCfmMaFaulAlarmDestAddress, dot1agCfmMepEntry=dot1agCfmMepEntry, Dot1agCfmPortStatus=Dot1agCfmPortStatus, dot1agCfmMepDbTable=dot1agCfmMepDbTable, dot1agCfmLtrManAddress=dot1agCfmLtrManAddress, dot1agCfmMaMepListRowStatus=dot1agCfmMaMepListRowStatus, dot1agCfmLtrTtl=dot1agCfmLtrTtl, dot1agCfmStackTable=dot1agCfmStackTable, dot1agCfmCompliances=dot1agCfmCompliances, dot1agCfmLtrIngressPortId=dot1agCfmLtrIngressPortId, dot1agNotifications=dot1agNotifications, dot1agCfmMdFormat=dot1agCfmMdFormat, dot1agCfmMepTransmitLbmVlanPriority=dot1agCfmMepTransmitLbmVlanPriority, dot1agCfmMepIfIndex=dot1agCfmMepIfIndex, dot1agCfmMepDbChassisId=dot1agCfmMepDbChassisId, dot1agCfmMaVlanTable=dot1agCfmMaVlanTable, dot1agCfmMepTransmitLbmDestMacAddress=dot1agCfmMepTransmitLbmDestMacAddress, dot1agCfmMepTransmitLtmSeqNumber=dot1agCfmMepTransmitLtmSeqNumber, dot1agCfmMepLbrInOutOfOrder=dot1agCfmMepLbrInOutOfOrder, Dot1agCfmRemoteMepState=Dot1agCfmRemoteMepState, dot1agCfmMaRowStatus=dot1agCfmMaRowStatus, dot1agCfmMepDbPortStatusTlv=dot1agCfmMepDbPortStatusTlv, dot1agCfmLtrOrganizationSpecificTlv=dot1agCfmLtrOrganizationSpecificTlv, dot1agCfmDefaultMdLevel=dot1agCfmDefaultMdLevel, Dot1agCfmConfigErrors=Dot1agCfmConfigErrors, dot1agCfmMepActive=dot1agCfmMepActive, dot1agCfmMepTransmitLtmFlags=dot1agCfmMepTransmitLtmFlags, dot1agCfmMepDbInterfaceStatusTlv=dot1agCfmMepDbInterfaceStatusTlv, dot1agCfmMepGroup=dot1agCfmMepGroup, dot1agCfmMepLbrIn=dot1agCfmMepLbrIn, dot1agCfmMepTransmitLbmMessages=dot1agCfmMepTransmitLbmMessages, dot1agCfmMepLtmNextSeqNumber=dot1agCfmMepLtmNextSeqNumber, dot1agCfmConfigErrorListEntry=dot1agCfmConfigErrorListEntry, dot1agCfmLtrNextEgressIdentifier=dot1agCfmLtrNextEgressIdentifier, dot1agCfmStackEntry=dot1agCfmStackEntry, dot1agCfmMaMhfCreation=dot1agCfmMaMhfCreation, dot1agCfmConfigErrorListTable=dot1agCfmConfigErrorListTable, dot1agCfmLtrIngress=dot1agCfmLtrIngress, dot1agCfmStackMacAddress=dot1agCfmStackMacAddress, dot1agCfmMepSomeRMepCcmDefect=dot1agCfmMepSomeRMepCcmDefect, Dot1agCfmHighestDefectPri=Dot1agCfmHighestDefectPri, dot1agCfmMepErrMacStatus=dot1agCfmMepErrMacStatus, dot1agCfmMd=dot1agCfmMd, dot1agCfmMaMepListEntry=dot1agCfmMaMepListEntry, dot1agCfmMaVlanEntry=dot1agCfmMaVlanEntry, dot1agCfmMaCcmInterval=dot1agCfmMaCcmInterval, dot1agCfmMepTransmitLtmResult=dot1agCfmMepTransmitLtmResult, Dot1agCfmMaintenanceDomainLevel=Dot1agCfmMaintenanceDomainLevel, dot1agCfmLtrForwarded=dot1agCfmLtrForwarded, dot1agCfmMdGroup=dot1agCfmMdGroup, dot1agCfmMepFaulAlarmDestAddress=dot1agCfmMepFaulAlarmDestAddress, dot1agCfmLtrRelay=dot1agCfmLtrRelay, dot1agCfmLtrReceiveOrder=dot1agCfmLtrReceiveOrder, dot1agCfmConformance=dot1agCfmConformance, dot1agCfmMepFngAlarmTime=dot1agCfmMepFngAlarmTime, dot1agCfmMepCciSentCcms=dot1agCfmMepCciSentCcms, dot1agCfmConfigErrorListVid=dot1agCfmConfigErrorListVid, dot1agCfmGroups=dot1agCfmGroups, dot1agCfmDefaultMdLevelVid=dot1agCfmDefaultMdLevelVid, dot1agCfmConfigErrorListGroup=dot1agCfmConfigErrorListGroup, Dot1agCfmCcmInterval=Dot1agCfmCcmInterval, dot1agCfmMepTransmitLbmStatus=dot1agCfmMepTransmitLbmStatus, dot1agCfmMaFormat=dot1agCfmMaFormat, dot1agCfmMepDbRMepState=dot1agCfmMepDbRMepState, dot1agCfmMaGroup=dot1agCfmMaGroup, dot1agCfmMdTableNextIndex=dot1agCfmMdTableNextIndex, Dot1agCfmMhfCreation=Dot1agCfmMhfCreation, dot1agCfmMdFaultAlarmDestDomain=dot1agCfmMdFaultAlarmDestDomain, dot1agCfmMepDbEntry=dot1agCfmMepDbEntry, Dot1agCfmInterfaceStatus=Dot1agCfmInterfaceStatus, dot1agCfmNotificationsGroup=dot1agCfmNotificationsGroup, dot1agCfmConfigErrorListErrorType=dot1agCfmConfigErrorListErrorType, dot1agCfmMepPrimaryVid=dot1agCfmMepPrimaryVid, dot1agCfmMaName=dot1agCfmMaName, dot1agCfmMepFaultAlarmDestDomain=dot1agCfmMepFaultAlarmDestDomain, dot1agCfmLtrTerminalMep=dot1agCfmLtrTerminalMep, dot1agCfmMaVlanVid=dot1agCfmMaVlanVid, dot1agCfmStackMepId=dot1agCfmStackMepId, dot1agCfmMepTransmitLbmSeqNumber=dot1agCfmMepTransmitLbmSeqNumber, dot1agCfmMepLbrBadMsdu=dot1agCfmMepLbrBadMsdu, Dot1agCfmMaintDomainNameType=Dot1agCfmMaintDomainNameType, dot1agCfmMaIndex=dot1agCfmMaIndex, dot1agCfmMepTransmitLtmStatus=dot1agCfmMepTransmitLtmStatus, dot1agCfmMepDbManAddress=dot1agCfmMepDbManAddress, Dot1agCfmLowestAlarmPri=Dot1agCfmLowestAlarmPri, dot1agCfmDefaultMdLevelEntry=dot1agCfmDefaultMdLevelEntry, dot1agCfmMdEntry=dot1agCfmMdEntry, dot1agCfmDefaultMdLevelMhfCreation=dot1agCfmDefaultMdLevelMhfCreation, dot1agCfmMepRowStatus=dot1agCfmMepRowStatus, dot1agCfmMepTransmitLtmTargetIsMepId=dot1agCfmMepTransmitLtmTargetIsMepId, dot1agCfmLtrIngressPortIdSubtype=dot1agCfmLtrIngressPortIdSubtype, dot1agCfmMepFngResetTime=dot1agCfmMepFngResetTime, Dot1agCfmEgressActionFieldValue=Dot1agCfmEgressActionFieldValue, dot1agCfmMepDirection=dot1agCfmMepDirection, dot1agCfmMepTransmitLtmTargetMepId=dot1agCfmMepTransmitLtmTargetMepId, dot1agCfmMdLevel=dot1agCfmMdLevel, dot1agCfmMepLbrOut=dot1agCfmMepLbrOut, dot1agCfmMepDbChassisIdSubtype=dot1agCfmMepDbChassisIdSubtype, dot1agCfmMepErrorCcmDefect=dot1agCfmMepErrorCcmDefect, dot1agCfmMepTransmitLtmTtl=dot1agCfmMepTransmitLtmTtl, dot1agCfmMepTransmitLbmDestMepId=dot1agCfmMepTransmitLbmDestMepId, Dot1afCfmIndexIntegerNextFree=Dot1afCfmIndexIntegerNextFree, Dot1agCfmMepId=Dot1agCfmMepId, dot1agCfmMepIdentifier=dot1agCfmMepIdentifier, dot1agCfmMdMhfCreation=dot1agCfmMdMhfCreation, dot1agCfmDefaultMdLevelGroup=dot1agCfmDefaultMdLevelGroup, ieee8021cfmMIB=ieee8021cfmMIB, dot1agCfmLtrEntry=dot1agCfmLtrEntry, dot1agCfmMdName=dot1agCfmMdName, dot1agCfmLtrEgressPortIdSubtype=dot1agCfmLtrEgressPortIdSubtype, dot1agCfmCompliance=dot1agCfmCompliance, dot1agCfmLtrLastEgressIdentifier=dot1agCfmLtrLastEgressIdentifier, dot1agCfmMepTransmitLbmDestIsMepId=dot1agCfmMepTransmitLbmDestIsMepId, dot1agCfmStack=dot1agCfmStack, Dot1agCfmMaintAssocNameType=Dot1agCfmMaintAssocNameType, dot1agMIBObjects=dot1agMIBObjects, dot1agCfmMdRowStatus=dot1agCfmMdRowStatus, dot1agCfmMepTransmitLtmTargetMacAddress=dot1agCfmMepTransmitLtmTargetMacAddress, dot1agCfmLtrSeqNumber=dot1agCfmLtrSeqNumber, dot1agCfmDefaultMdLevelLevel=dot1agCfmDefaultMdLevelLevel, dot1agCfmMepDbRMepFailedOkTime=dot1agCfmMepDbRMepFailedOkTime, Dot1agCfmRelayActionFieldValue=Dot1agCfmRelayActionFieldValue, dot1agCfmLtrChassisIdSubtype=dot1agCfmLtrChassisIdSubtype, dot1agCfmStackDirection=dot1agCfmStackDirection, dot1agCfmMepHighestPrDefect=dot1agCfmMepHighestPrDefect, Dot1agCfmMaintAssocName=Dot1agCfmMaintAssocName, dot1agCfmMepErrorCcmLastFailure=dot1agCfmMepErrorCcmLastFailure, Dot1agCfmMaintDomainName=Dot1agCfmMaintDomainName, dot1agCfmMepTransmitLbmDataTlv=dot1agCfmMepTransmitLbmDataTlv, dot1agCfmMaMepListIdentifier=dot1agCfmMaMepListIdentifier, dot1agCfmMepTransmitLbmVlanDropEnable=dot1agCfmMepTransmitLbmVlanDropEnable, dot1agCfmMepDbGroup=dot1agCfmMepDbGroup, dot1agCfmMaTable=dot1agCfmMaTable, dot1agCfmMdIndex=dot1agCfmMdIndex, dot1agCfmDefaultMdLevelIndex=dot1agCfmDefaultMdLevelIndex, dot1agCfmMdTable=dot1agCfmMdTable, dot1agCfmMepFngState=dot1agCfmMepFngState, dot1agCfmLtrIngressMac=dot1agCfmLtrIngressMac, dot1agCfmMepXconCcmDefect=dot1agCfmMepXconCcmDefect)
