#
# PySNMP MIB module LLDP-EXT-DCBX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/iee/LLDP-EXT-DCBX-MIB
# Produced by pysmi-1.1.12 at Fri Jul 19 09:34:10 2024
# On host fv-az1499-371 platform Linux version 6.5.0-1023-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
LldpPortNumber, lldpExtensions = mibBuilder.importSymbols("LLDP-MIB", "LldpPortNumber", "lldpExtensions")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Bits, ObjectIdentity, Unsigned32, Counter64, Gauge32, ModuleIdentity, iso, Counter32, TimeTicks, MibIdentifier, IpAddress, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "Unsigned32", "Counter64", "Gauge32", "ModuleIdentity", "iso", "Counter32", "TimeTicks", "MibIdentifier", "IpAddress", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
lldpXdcbxMIB = ModuleIdentity((1, 0, 8802, 1, 1, 2, 1, 5, 6945))
if mibBuilder.loadTexts: lldpXdcbxMIB.setLastUpdated('200811200000Z')
if mibBuilder.loadTexts: lldpXdcbxMIB.setOrganization('IEEE ??? Working Group')
if mibBuilder.loadTexts: lldpXdcbxMIB.setContactInfo('WG-URL: ???\n             WG-EMail: ???\n\n             Contact: Robert Cowart\n              Postal: IBM\n                      6303 Barfield Road NE\n                      Atlanta, GA 30328-4233\n                      USA\n                 Tel: +1-404-935-6841\n              E-mail: rcowart@us.ibm.com\n\n             Contact: Nagaraj Govindaiah\n              Postal: EMULEX\n                      2560 N First St. Ste.300\n                      San Jose, CA 95131\n                      USA\n                 Tel: +1-408-904-4150\n              E-mail: nagaraj.govindaiah@emulex.com')
if mibBuilder.loadTexts: lldpXdcbxMIB.setDescription("The LLDP Management Information Base extension module for\n            DCB Capability Exchage Protocol (DCBX).\n\n            In order to assure the uniqueness of the LLDP-MIB,\n            lldpXdcbxMIB is branched from lldpExtensions using OUI value\n            as the node.  An OUI/'company_id' is a 24 bit globally unique\n            assigned number referenced by various standards.")
class LldpXdcbxPriority(TextualConvention, Integer32):
    description = 'IEEE 802.1p Priorities.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class LldpXdcbxPriorityGroup(TextualConvention, Integer32):
    description = 'DCB Priority Groups.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("priorityGroupId0", 0), ("priorityGroupId1", 1), ("priorityGroupId2", 2), ("priorityGroupId3", 3), ("priorityGroupId4", 4), ("priorityGroupId5", 5), ("priorityGroupId6", 6), ("priorityGroupId7", 7), ("reserved8", 8), ("reserved9", 9), ("reserved10", 10), ("reserved11", 11), ("reserved12", 12), ("reserved13", 13), ("reserved14", 14), ("noBandwidthLimit", 15))

class LldpXdcbxFeatureType(TextualConvention, Integer32):
    description = 'Type code of the DCB Feature. Following is a list of defined types:\n\n         2  Priority Groups\n         3  Priority Flow Control\n         4 - Application Protocol'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4))
    namedValues = NamedValues(("priorityGroup", 2), ("priorityFlowControl", 3), ("applicationProtocol", 4))

class LldpXdcbxFeatureSubType(TextualConvention, Integer32):
    description = 'LLDP DCBX Feature Sub Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class LldpXdcbxVersion(TextualConvention, Integer32):
    description = 'LLDP DCBX Version.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class LldpXdcbxTC(TextualConvention, Integer32):
    description = 'Traffic Classes Supported.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class LldpXdcbxPgBw(TextualConvention, Integer32):
    description = 'Priority Group Bandwidth Range.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 100)

class LldpXdcbxTCPFC(TextualConvention, Integer32):
    description = 'Number of TCs that can simultaneously support PFC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 8)

class LldpXdcbxTCPeer(TextualConvention, Integer32):
    description = 'Private Extension: Number of TCs that supported on the peer.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 8)

class LldpXdcbxAppProtos(TextualConvention, Integer32):
    description = 'Number of Application Protocols (TLVs) supported.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 15)

class LldpXdcbxSF(TextualConvention, Integer32):
    description = 'Selector Field to specify Application Protocol ID Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("l2EtherType", 0), ("socketNumber", 1), ("reserved2", 2), ("reserved3", 3))

lldpXdcbxNotifications = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0))
lldpXdcbxObjects = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1))
lldpXdcbxFeatures = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2))
lldpXdcbxPortTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1), )
if mibBuilder.loadTexts: lldpXdcbxPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortTable.setDescription('A list of all ports capable of supporting DCBX.')
lldpXdcbxPortEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortEntry.setDescription('An entry containing DCBX control parameters for a particular port.')
lldpXdcbxPortNumber = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxPortNumber.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortNumber.setDescription("Each port contained in the chassis (that is known to the LLDP agent)\n         is uniquely identified by a port number.\n\n         A port number has no mandatory relationship to an InterfaceIndex\n         object (of the interfaces MIB, IETF RFC 2863). If the LLDP agent is a\n         IEEE 802.1D, IEEE 802.1Q bridge, the LldpPortNumber will have the same\n         value as the dot1dBasePort object (defined in IETF RFC 1493)\n         associated corresponding bridge port. If the system hosting LLDP agent\n         is not an IEEE 802.1D or an IEEE 802.1Q bridge, the LldpPortNumber\n         will have the same value as the corresponding interface's\n         InterfaceIndex object.\n\n         Port numbers should be in the range of 1 and 4096 since a particular\n         port is also represented by the corresponding port number bit in\n         LldpPortList.")
lldpXdcbxPortEnable = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxPortEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortEnable.setDescription('A device capable of any DCB feature must have DCBX enabled by default\n         with an option for DCBX to be administratively disabled.')
lldpXdcbxPortVersionOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 3), LldpXdcbxVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxPortVersionOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortVersionOper.setDescription('Operating version of the DCBX protocol. The system adjusts as needed\n         to operate at the highest version supported by both link partners.')
lldpXdcbxPortVersionMax = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 4), LldpXdcbxVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxPortVersionMax.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortVersionMax.setDescription('Highest DCBX protocol version supported by the system. Version numbers\n         start at zero. The DCBX protocol must be backward compatible with all\n         previous versions.')
lldpXdcbxPortSeqNo = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxPortSeqNo.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortSeqNo.setDescription('A value that changes each time an exchanged parameter in one or more\n         of the DCB feature TLVs changes.')
lldpXdcbxPortAckNo = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxPortAckNo.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPortAckNo.setDescription('The SeqNo value from the most recent peer DCBX TLV that has been\n         handled. This acknowledges to the peer that a specific SeqNo has\n         been received.')
lldpXdcbxFeatTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1), )
if mibBuilder.loadTexts: lldpXdcbxFeatTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatTable.setDescription('A list of DCBX features configured on this system.')
lldpXdcbxFeatEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatType"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatSubType"))
if mibBuilder.loadTexts: lldpXdcbxFeatEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatEntry.setDescription('A entry containing DCBX feature parameters which are common to all\n         features.')
lldpXdcbxFeatType = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 1), LldpXdcbxFeatureType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatType.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatType.setDescription('Type code of the DCB Feature. Following is a list of defined types:\n\n         2  Priority Groups\n         3  Priority Flow Control\n         4  Application Protocol')
lldpXdcbxFeatSubType = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 2), LldpXdcbxFeatureSubType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatSubType.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatSubType.setDescription('Some Feature TLVs may define subtypes that are specific to that\n         feature. When subtypes are not defined by a specific  feature, subtype\n         field should be set to zero.\n\n         In general, the Type and SubType, taken together, identify a unique\n         feature that is managed by an instance of the DCB Feature State\n         Machine.')
lldpXdcbxFeatVersionOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 3), LldpXdcbxVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatVersionOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatVersionOper.setDescription('Operating version of the feature. The system adjusts to operate at the\n         highest version supported by both link partners.')
lldpXdcbxFeatVersionMax = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 4), LldpXdcbxVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatVersionMax.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatVersionMax.setDescription('Highest feature version supported by the system. Version numbers start\n         at zero. The feature must be backward compatible for all previous\n         versions.')
lldpXdcbxFeatEnable = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatEnable.setDescription('Locally administered parameter that indicates whether the DCB feature\n         is enabled or not.')
lldpXdcbxFeatWilling = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatWilling.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatWilling.setDescription('Locally administered parameter that indicates whether this feature\n         accepts its configuration from the peer or not. When set to TRUE, the\n         system uses the DesiredCfg supplied by a not Willing peer as the\n         OperCfg. A system set to Willing must be capable of accepting any\n         valid DesiredCfg for the feature from the peer.\n\n         If both local and remote systems have the same value for the Willing\n         flag, then the local DesiredCfg is used and the operational outcome of\n         the exchange is determined by the Compatible method of the feature.')
lldpXdcbxFeatError = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatError.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatError.setDescription('Indicates that an error has occurred during the configuration exchange\n         with the peer. Error is set TRUE when the OperCfg and OperMode of a\n         feature cannot be set as the protocol requires. Error is also set to\n         TRUE when the Compatible method for the feature fails. The Feature\n         turns OperMode to FALSE if either the local or remote Error flag is\n         set to TRUE.\n\n         Duplicate TLVs for the same Type/SubType or the DCBX Control TLV also\n         causes Error to be set to TRUE.')
lldpXdcbxFeatAdvertise = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAdvertise.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAdvertise.setDescription('Locally administered parameter that indicates whether this feature is\n         exchanged in the DCBX TLV. When Advertise is False, received TLVs for\n         this feature are ignored.')
lldpXdcbxFeatOperMode = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatOperMode.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatOperMode.setDescription('Operational state of the feature.')
lldpXdcbxFeatSyncd = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatSyncd.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatSyncd.setDescription('Indicates whether the current DesiredCfg has been received by the\n         peer.')
lldpXdcbxFeatSeqNo = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatSeqNo.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatSeqNo.setDescription('When Syncd is False, this indicates the value that SeqNo must\n         become equal to before Syncd can become True.')
lldpXdcbxFeatPeerWilling = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPeerWilling.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPeerWilling.setDescription('The Willing state of the peer as received in a DCBX TLV from the\n         peer.')
lldpXdcbxFeatLocalParameterChange = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatLocalParameterChange.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatLocalParameterChange.setDescription('Indicates that a configurable DCB Feature TLV field or state variable\n         has been modified on the local system.')
lldpXdcbxFeatPeerEnable = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPeerEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPeerEnable.setDescription('Private Extension: The Feature Enable state of the peer as received in a DCBX TLV from the\n         peer.')
lldpXdcbxFeatPeerError = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPeerError.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPeerError.setDescription('Private Extension: The Feature Error state of the peer as received in a DCBX TLV from the\n         peer.')
lldpXdcbxFeatPeerAdvertise = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPeerAdvertise.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPeerAdvertise.setDescription('Private Extension: The Feature Advertisment state of the peer as received in a DCBX TLV from the\n         peer.')
lldpXdcbxFeatPeerTC = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 1, 1, 17), LldpXdcbxTCPeer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPeerTC.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPeerTC.setDescription('Private Extension: Number of TCs that supported on the peer.\n         Relevan for PG and PFC features. If not relevant (as for App feat), will be set to 0.')
lldpXdcbxFeatPg = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2))
lldpXdcbxFeatPgNumTCsSupported = MibScalar((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 1), LldpXdcbxTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPgNumTCsSupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgNumTCsSupported.setDescription('Number of TCs supported by device.\n         Number of Priority Groups supported by a device can not be more than\n         number of TCs supported.')
lldpXdcbxFeatPgPrioAllocTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2), )
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocTable.setDescription('A list of priorities and the their priority group assignment or\n         declaration of no bandwidth limit.')
lldpXdcbxFeatPgPrioAllocEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatPgPrioAllocPrioId"))
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocEntry.setDescription('An entry for a priority which allows the priority to be assigned to a\n         priority group, or declared with no bandwidth limit.')
lldpXdcbxFeatPgPrioAllocPrioId = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2, 1, 1), LldpXdcbxPriority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPrioId.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPrioId.setDescription('The priority which is to be assigned to a priority group, or defined\n         with no bandwidth limit.')
lldpXdcbxFeatPgPrioAllocPgIdDesired = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2, 1, 2), LldpXdcbxPriorityGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdDesired.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdDesired.setDescription('The locally configured priority group value assigned to this\n         priority.')
lldpXdcbxFeatPgPrioAllocPgIdOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2, 1, 3), LldpXdcbxPriorityGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdOper.setDescription("The operating priority group value assigned to this priority.\n\n         NOTE: This value may be different than the locally desired value\n         depending on whether or not this feature is 'willing' to accept the\n         peer's desired configuration. The operating configuration MUST match\n         either the locally desired configuration or the peer's desired\n         configuration if the feature is operational.")
lldpXdcbxFeatPgPrioAllocPgIdPeer = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 2, 1, 4), LldpXdcbxPriorityGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdPeer.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgPrioAllocPgIdPeer.setDescription('The priority group value that the peer desires to assign to this\n         priority.')
lldpXdcbxFeatPgBwAllocTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3), )
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocTable.setDescription('A list of priority group bandwidth allocations.')
lldpXdcbxFeatPgBwAllocEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatPgBwAllocPgId"))
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocEntry.setDescription('An entry for a priority group bandwidth allocation.')
lldpXdcbxFeatPgBwAllocPgId = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3, 1, 1), LldpXdcbxPriorityGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocPgId.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocPgId.setDescription('The priority group for which bandwidth is allocated in this table.')
lldpXdcbxFeatPgBwAllocBwDesired = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3, 1, 2), LldpXdcbxPgBw()).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwDesired.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwDesired.setDescription('The locally configured bandwidth allocated to this priority group.')
lldpXdcbxFeatPgBwAllocBwOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3, 1, 3), LldpXdcbxPgBw()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwOper.setDescription("The operating bandwidth allocated to this priority group.\n\n         NOTE: This value may be different than the locally desired value\n         depending on whether or not this feature is 'willing' to accept the\n         peer's desired configuration. The operating configuration MUST match\n         either the locally desired configuration or the peer's desired\n         configuration if the feature is operational.")
lldpXdcbxFeatPgBwAllocBwPeer = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 2, 3, 1, 4), LldpXdcbxPgBw()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwPeer.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPgBwAllocBwPeer.setDescription('The bandwidth allocation that the peer desires to assign to this\n         priority group.')
lldpXdcbxFeatPfc = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3))
lldpXdcbxFeatPfcNumTCPFCSupported = MibScalar((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 1), LldpXdcbxTCPFC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPfcNumTCPFCSupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcNumTCPFCSupported.setDescription('Number of TCs that can simultaneously support PFC.')
lldpXdcbxFeatPfcTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2), )
if mibBuilder.loadTexts: lldpXdcbxFeatPfcTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcTable.setDescription('A list of priority flow control configurations for each priority.')
lldpXdcbxFeatPfcEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatPfcPriority"))
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEntry.setDescription('An entry for configuring priority flow control for each priority.')
lldpXdcbxFeatPfcPriority = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2, 1, 1), LldpXdcbxPriority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPfcPriority.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcPriority.setDescription('The priority for which priority flow control is being configured.')
lldpXdcbxFeatPfcEnableDesired = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnableDesired.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnableDesired.setDescription('The locally configured status of priority flow control for this\n         priority.\n\n         0: Disabled\n         1: Enabled\n\n         PFC Enabled means that flow control in both directions (Rx and Tx) is\n         enabled.')
lldpXdcbxFeatPfcEnableOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnableOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnableOper.setDescription("The operating status of priority flow control for this priority.\n\n         NOTE: This value may be different than the locally desired value\n         depending on whether or not this feature is 'willing' to accept the\n         peer's desired configuration. The operating configuration MUST match\n         either the locally desired configuration or the peer's desired\n         configuration if the feature is operational.")
lldpXdcbxFeatPfcEnablePeer = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 3, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnablePeer.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatPfcEnablePeer.setDescription('The priority flow control status that the peer desires to assign to\n         this priority.')
lldpXdcbxFeatAppProto = MibIdentifier((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4))
lldpXdcbxFeatAppProtoTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1), )
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoTable.setDescription('A list of Application Protocol configurations.')
lldpXdcbxFeatAppProtoEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatAppProtoIndex"))
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEntry.setDescription('An entry for configuring Application Protocol ID.')
lldpXdcbxFeatAppProtoIndex = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1, 1, 1), LldpXdcbxAppProtos()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoIndex.setDescription('The index of the Application Protocol being configured in a list of\n         Application Protocols.')
lldpXdcbxFeatAppProtoSF = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1, 1, 2), LldpXdcbxSF()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoSF.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoSF.setDescription('The value of the Selector Field for this application protocol.')
lldpXdcbxFeatAppProtoOUI = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoOUI.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoOUI.setDescription('The value of the Application Protocol OUI for this application\n         protocol.')
lldpXdcbxFeatAppProtoId = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoId.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoId.setDescription('The value of the Application Protocol ID for this application\n         protocol.')
lldpXdcbxFeatAppProtoPrioTable = MibTable((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2), )
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPrioTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPrioTable.setDescription('A list of priority configurations for each application protocol.')
lldpXdcbxFeatAppProtoPrioEntry = MibTableRow((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2, 1), ).setIndexNames((0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatAppProtoIndex"), (0, "LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatAppProtoPriority"))
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPrioEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPrioEntry.setDescription('An entry for selecting priorities for the Application Protocol.')
lldpXdcbxFeatAppProtoPriority = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2, 1, 1), LldpXdcbxPriority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPriority.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoPriority.setDescription('The priority for which Application Protocol is being configured.')
lldpXdcbxFeatAppProtoEnableDesired = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnableDesired.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnableDesired.setDescription('The locally configured status of Application Protocol for this\n         priority.\n\n         0: Disabled\n         1: Enabled')
lldpXdcbxFeatAppProtoEnableOper = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnableOper.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnableOper.setDescription("The operating status of Application Protocol for this priority.\n\n         NOTE: This value may be different than the locally desired value\n         depending on whether or not this feature is 'willing' to accept the\n         peer's desired configuration. The operating configuration MUST match\n         either the locally desired configuration or the peer's desired\n         configuration if the feature is operational.")
lldpXdcbxFeatAppProtoEnablePeer = MibTableColumn((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 2, 4, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnablePeer.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxFeatAppProtoEnablePeer.setDescription('The Application Protocol status that the peer desires to assign to\n         this priority.')
lldpXdcbxMiscControlError = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 1)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxMiscControlError.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxMiscControlError.setDescription('This trap is sent whenever an error occurs with DCBX control and there\n         is no other trap defined for the specific error condition.')
lldpXdcbxMiscFeatureError = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 2)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatError"))
if mibBuilder.loadTexts: lldpXdcbxMiscFeatureError.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxMiscFeatureError.setDescription('This trap is sent whenever lldpXdcbxFeatError is true and there is no\n         other trap defined for the specific error condition.')
lldpXdcbxMultiplePeers = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 3)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxMultiplePeers.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxMultiplePeers.setDescription("This trap is sent when multiple LLDP neighbors are detected on the\n         same port.\n\n         DCBX is expected to operate over a point to point link. If multiple\n         LLDP neighbors are detected, then DCBX behaves as if the peer's DCBX\n         TLVs are not present until the multiple LLDP neighbor condition is no\n         longer present. An LLDP neighbor is identified by its logical MAC\n         Service Access Identifier (MSAP). The logical MSAP is a concatenation\n         of the chassis ID and port ID values transmitted in the LLDPDU.")
lldpXdcbxLldpTxDisabled = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 4)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxLldpTxDisabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxLldpTxDisabled.setDescription("This trap is sent when the LLDP transmit has been disabled.\n\n         LLDP gives administrator control to enable/disable the protocol\n         independently on the Rx side and Tx side. Since DCBX is an\n         acknowledged protocol which uses LLDP, for the protocol to operate\n         correctly both LLDP Rx and Tx must be enabled on the interface on\n         which DCBX runs. The behavior of DCBX is as follows with respect to\n         LLDP Rx/Tx admin state controls:\n\n         - If either of Rx or Tx is in disable state, DCBX is disabled on the\n           interface. Neither the control nor feature state machines should\n           run. The LLDP PDU's that are generated from this interface do not\n           have any DCBX TLVs. If the peer sends DCBX TLVs they should be\n           ignored as far as the DCBX state machines are concerned.\n\n         - When DCBX is currently running and LLDP TX is disabled, then\n           according to the LLDP specification, a shutdown LLDPDU is sent. When\n           the peer receives this PDU, DCBX is determined to be disabled on the\n           peer. This is equivalent to DCBX TLV TTL expired in the Control\n           State machine and Rx.Feature.present() = FALSE in the Feature state\n           machine. If for some reason this frame is lost, then DCBX depends on\n           standard rxInfoTTL expiry of the peer's LLDP TLV's.\n\n         - When DCBX is currently running and LLDP Rx is disabled, then all\n           DCBX TLV's including the control TLV should be withdrawn from the\n           LLDP PDUs that the interface generates. The peer's behavior should\n           be the same as discussed in the previous case.")
lldpXdcbxLldpRxDisabled = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 5)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxLldpRxDisabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxLldpRxDisabled.setDescription("This trap is sent when the LLDP receive has been disabled.\n\n         LLDP gives administrator control to enable/disable the protocol\n         independently on the Rx side and Tx side. Since DCBX is an\n         acknowledged protocol which uses LLDP, for the protocol to operate\n         correctly both LLDP Rx and Tx must be enabled on the interface on\n         which DCBX runs. The behavior of DCBX is as follows with respect to\n         LLDP Rx/Tx admin state controls:\n\n         - If either of Rx or Tx is in disable state, DCBX is disabled on the\n           interface. Neither the control nor feature state machines should\n           run. The LLDP PDU's that are generated from this interface do not\n           have any DCBX TLVs. If the peer sends DCBX TLVs they should be\n           ignored as far as the DCBX state machines are concerned.\n\n         - When DCBX is currently running and LLDP TX is disabled, then\n           according to the LLDP specification, a shutdown LLDPDU is sent. When\n           the peer receives this PDU, DCBX is determined to be disabled on the\n           peer. This is equivalent to DCBX TLV TTL expired in the Control\n           State machine and Rx.Feature.present() = FALSE in the Feature state\n           machine. If for some reason this frame is lost, then DCBX depends on\n           standard rxInfoTTL expiry of the peer's LLDP TLV's.\n\n         - When DCBX is currently running and LLDP Rx is disabled, then all\n           DCBX TLV's including the control TLV should be withdrawn from the\n           LLDP PDUs that the interface generates. The peer's behavior should\n           be the same as discussed in the previous case.")
lldpXdcbxDupControlTlv = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 6)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxDupControlTlv.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxDupControlTlv.setDescription('This trap is sent when a duplicate control Sub-TLV is detected.\n\n         The DCBX Control Sub-TLV and the set of Feature Sub-TLVs can be\n         arranged in any order within the DCBX TLV.  Duplicate Sub-TLVs (such\n         as more than one Sub-TLV for the same feature) are not allowed.\n         A duplicate DCBX Control TLV causes an error for all features.')
lldpXdcbxDupFeatureTlv = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 7)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatType"))
if mibBuilder.loadTexts: lldpXdcbxDupFeatureTlv.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxDupFeatureTlv.setDescription("This trap is sent when a duplicate feature Sub-TLV is detected.\n\n         The DCBX Control Sub-TLV and the set of Feature Sub-TLVs can be\n         arranged in any order within the DCBX TLV.  Duplicate Sub-TLV's (such\n         as more than one Sub-TLV for the same feature) are not allowed.\n         Duplicates are handled as a configuration error for the feature.")
lldpXdcbxPeerNoFeat = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 8)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxFeatType"))
if mibBuilder.loadTexts: lldpXdcbxPeerNoFeat.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPeerNoFeat.setDescription("This trap is sent when a feature is not supported on by a peer.\n\n         This condition can occur when a device does not support a feature (not\n         really an error) or if the feature's Advertise flag is off (possible\n         configuration error).")
lldpXdcbxPeerNoResp = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 9)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxPeerNoResp.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPeerNoResp.setDescription('This trap is sent when the peer has stopped responding as evidenced by\n         an LLDP timeout event.')
lldpXdcbxPeerConfigMismatch = NotificationType((1, 0, 8802, 1, 1, 2, 1, 5, 6945, 0, 10)).setObjects(("LLDP-EXT-DCBX-MIB", "lldpXdcbxPortNumber"))
if mibBuilder.loadTexts: lldpXdcbxPeerConfigMismatch.setStatus('current')
if mibBuilder.loadTexts: lldpXdcbxPeerConfigMismatch.setDescription('This trap is sent when the configuration received from peer results\n         into partial or complete mismatch.')
mibBuilder.exportSymbols("LLDP-EXT-DCBX-MIB", lldpXdcbxMIB=lldpXdcbxMIB, lldpXdcbxMiscFeatureError=lldpXdcbxMiscFeatureError, LldpXdcbxTC=LldpXdcbxTC, lldpXdcbxFeatAppProtoEnableDesired=lldpXdcbxFeatAppProtoEnableDesired, lldpXdcbxFeatPgNumTCsSupported=lldpXdcbxFeatPgNumTCsSupported, lldpXdcbxPortEntry=lldpXdcbxPortEntry, lldpXdcbxDupControlTlv=lldpXdcbxDupControlTlv, lldpXdcbxPortVersionMax=lldpXdcbxPortVersionMax, lldpXdcbxFeatPeerError=lldpXdcbxFeatPeerError, lldpXdcbxFeatAdvertise=lldpXdcbxFeatAdvertise, lldpXdcbxFeatPfcEnablePeer=lldpXdcbxFeatPfcEnablePeer, lldpXdcbxFeatPeerTC=lldpXdcbxFeatPeerTC, lldpXdcbxFeatAppProto=lldpXdcbxFeatAppProto, lldpXdcbxFeatures=lldpXdcbxFeatures, lldpXdcbxFeatVersionOper=lldpXdcbxFeatVersionOper, lldpXdcbxPortTable=lldpXdcbxPortTable, lldpXdcbxFeatLocalParameterChange=lldpXdcbxFeatLocalParameterChange, lldpXdcbxFeatPgPrioAllocPrioId=lldpXdcbxFeatPgPrioAllocPrioId, lldpXdcbxFeatOperMode=lldpXdcbxFeatOperMode, lldpXdcbxFeatAppProtoIndex=lldpXdcbxFeatAppProtoIndex, lldpXdcbxFeatPeerWilling=lldpXdcbxFeatPeerWilling, lldpXdcbxDupFeatureTlv=lldpXdcbxDupFeatureTlv, lldpXdcbxPortNumber=lldpXdcbxPortNumber, lldpXdcbxFeatPfcNumTCPFCSupported=lldpXdcbxFeatPfcNumTCPFCSupported, lldpXdcbxPortSeqNo=lldpXdcbxPortSeqNo, lldpXdcbxFeatPfcTable=lldpXdcbxFeatPfcTable, lldpXdcbxFeatPgBwAllocTable=lldpXdcbxFeatPgBwAllocTable, lldpXdcbxFeatPgPrioAllocPgIdDesired=lldpXdcbxFeatPgPrioAllocPgIdDesired, lldpXdcbxFeatPgPrioAllocPgIdPeer=lldpXdcbxFeatPgPrioAllocPgIdPeer, lldpXdcbxFeatAppProtoEnablePeer=lldpXdcbxFeatAppProtoEnablePeer, LldpXdcbxTCPeer=LldpXdcbxTCPeer, lldpXdcbxFeatAppProtoPriority=lldpXdcbxFeatAppProtoPriority, lldpXdcbxFeatSyncd=lldpXdcbxFeatSyncd, lldpXdcbxPortVersionOper=lldpXdcbxPortVersionOper, lldpXdcbxObjects=lldpXdcbxObjects, LldpXdcbxPgBw=LldpXdcbxPgBw, LldpXdcbxFeatureType=LldpXdcbxFeatureType, lldpXdcbxFeatSeqNo=lldpXdcbxFeatSeqNo, lldpXdcbxFeatPgBwAllocPgId=lldpXdcbxFeatPgBwAllocPgId, lldpXdcbxFeatEntry=lldpXdcbxFeatEntry, lldpXdcbxFeatPfcPriority=lldpXdcbxFeatPfcPriority, lldpXdcbxFeatPgBwAllocBwPeer=lldpXdcbxFeatPgBwAllocBwPeer, lldpXdcbxFeatPfcEnableDesired=lldpXdcbxFeatPfcEnableDesired, PYSNMP_MODULE_ID=lldpXdcbxMIB, lldpXdcbxFeatSubType=lldpXdcbxFeatSubType, lldpXdcbxFeatTable=lldpXdcbxFeatTable, lldpXdcbxFeatPgBwAllocEntry=lldpXdcbxFeatPgBwAllocEntry, lldpXdcbxFeatPg=lldpXdcbxFeatPg, LldpXdcbxAppProtos=LldpXdcbxAppProtos, lldpXdcbxFeatPgBwAllocBwOper=lldpXdcbxFeatPgBwAllocBwOper, LldpXdcbxVersion=LldpXdcbxVersion, lldpXdcbxPeerNoResp=lldpXdcbxPeerNoResp, lldpXdcbxFeatPfcEntry=lldpXdcbxFeatPfcEntry, lldpXdcbxFeatPgPrioAllocTable=lldpXdcbxFeatPgPrioAllocTable, lldpXdcbxMultiplePeers=lldpXdcbxMultiplePeers, lldpXdcbxFeatAppProtoSF=lldpXdcbxFeatAppProtoSF, lldpXdcbxFeatPgPrioAllocPgIdOper=lldpXdcbxFeatPgPrioAllocPgIdOper, lldpXdcbxFeatVersionMax=lldpXdcbxFeatVersionMax, lldpXdcbxFeatAppProtoId=lldpXdcbxFeatAppProtoId, lldpXdcbxFeatPgPrioAllocEntry=lldpXdcbxFeatPgPrioAllocEntry, lldpXdcbxFeatPeerEnable=lldpXdcbxFeatPeerEnable, lldpXdcbxPeerConfigMismatch=lldpXdcbxPeerConfigMismatch, lldpXdcbxFeatAppProtoOUI=lldpXdcbxFeatAppProtoOUI, lldpXdcbxFeatAppProtoTable=lldpXdcbxFeatAppProtoTable, LldpXdcbxTCPFC=LldpXdcbxTCPFC, lldpXdcbxFeatPfcEnableOper=lldpXdcbxFeatPfcEnableOper, lldpXdcbxNotifications=lldpXdcbxNotifications, lldpXdcbxMiscControlError=lldpXdcbxMiscControlError, lldpXdcbxFeatPgBwAllocBwDesired=lldpXdcbxFeatPgBwAllocBwDesired, lldpXdcbxFeatAppProtoEnableOper=lldpXdcbxFeatAppProtoEnableOper, lldpXdcbxFeatAppProtoPrioTable=lldpXdcbxFeatAppProtoPrioTable, lldpXdcbxPeerNoFeat=lldpXdcbxPeerNoFeat, lldpXdcbxFeatType=lldpXdcbxFeatType, lldpXdcbxLldpRxDisabled=lldpXdcbxLldpRxDisabled, LldpXdcbxPriority=LldpXdcbxPriority, LldpXdcbxPriorityGroup=LldpXdcbxPriorityGroup, LldpXdcbxSF=LldpXdcbxSF, lldpXdcbxFeatWilling=lldpXdcbxFeatWilling, lldpXdcbxFeatAppProtoPrioEntry=lldpXdcbxFeatAppProtoPrioEntry, lldpXdcbxPortAckNo=lldpXdcbxPortAckNo, lldpXdcbxPortEnable=lldpXdcbxPortEnable, lldpXdcbxFeatEnable=lldpXdcbxFeatEnable, lldpXdcbxFeatAppProtoEntry=lldpXdcbxFeatAppProtoEntry, lldpXdcbxLldpTxDisabled=lldpXdcbxLldpTxDisabled, lldpXdcbxFeatPeerAdvertise=lldpXdcbxFeatPeerAdvertise, LldpXdcbxFeatureSubType=LldpXdcbxFeatureSubType, lldpXdcbxFeatPfc=lldpXdcbxFeatPfc, lldpXdcbxFeatError=lldpXdcbxFeatError)
