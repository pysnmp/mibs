#
# PySNMP MIB module HIRSCHMANN-MMP4-QOS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hirschmann/hmPlatform4Qos.mib
# Produced by pysmi-1.1.12 at Mon Jun  3 11:59:12 2024
# On host fv-az1385-213 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
hmPlatform4, = mibBuilder.importSymbols("HIRSCHMANN-MMP4-BASICL2-MIB", "hmPlatform4")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, iso, Counter32, IpAddress, TimeTicks, ObjectIdentity, Integer32, NotificationType, Unsigned32, MibIdentifier, Bits, Counter64, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "iso", "Counter32", "IpAddress", "TimeTicks", "ObjectIdentity", "Integer32", "NotificationType", "Unsigned32", "MibIdentifier", "Bits", "Counter64", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, RowStatus, DisplayString, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "DisplayString", "MacAddress", "TextualConvention")
hmPlatform4QOS = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 15, 3))
hmPlatform4QOS.setRevisions(('2005-08-18 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmPlatform4QOS.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: hmPlatform4QOS.setLastUpdated('200508181200Z')
if mibBuilder.loadTexts: hmPlatform4QOS.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmPlatform4QOS.setContactInfo('Customer Support\r\n           Postal: \r\n           Hirschmann Automation and Control GmbH\r\n           Stuttgarter Str. 45-51\r\n           72654 Neckartenzlingen\r\n           Germany\r\n           Tel: +49 7127 14 1981\r\n           Web: http://www.hicomcenter.com/\r\n           E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmPlatform4QOS.setDescription('The Hirschmann Private Platform4 QoS MIB definitions for Platform devices.')
hmAgentQOSACL = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 3, 2))
hmAgentQOSCOS = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 3, 3))
class EtypeValue(TextualConvention, Unsigned32):
    description = 'Ethertype value of a packet.  The allowed value is 0x0600 to 0xFFFF.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1536, 65535)

class PercentByFives(TextualConvention, Unsigned32):
    description = 'An unsigned integer representing a value expressed \r\n                     as a percentage with five percent increments.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 5), ValueRangeConstraint(10, 10), ValueRangeConstraint(15, 15), ValueRangeConstraint(20, 20), ValueRangeConstraint(25, 25), ValueRangeConstraint(30, 30), ValueRangeConstraint(35, 35), ValueRangeConstraint(40, 40), ValueRangeConstraint(45, 45), ValueRangeConstraint(50, 50), ValueRangeConstraint(55, 55), ValueRangeConstraint(60, 60), ValueRangeConstraint(65, 65), ValueRangeConstraint(70, 70), ValueRangeConstraint(75, 75), ValueRangeConstraint(80, 80), ValueRangeConstraint(85, 85), ValueRangeConstraint(90, 90), ValueRangeConstraint(95, 95), ValueRangeConstraint(100, 100), )
class Sixteenths(TextualConvention, Unsigned32):
    description = 'An unsigned integer representing the numerator of a \r\n                     value expressing a fraction in terms of sixteenths \r\n                     (0/16, 1/16, 2/16, up to 16/16).'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 16)

aclTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 1), )
if mibBuilder.loadTexts: aclTable.setStatus('current')
if mibBuilder.loadTexts: aclTable.setDescription('A table of ACL instances.')
aclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIndex"))
if mibBuilder.loadTexts: aclEntry.setStatus('current')
if mibBuilder.loadTexts: aclEntry.setDescription('The entry of the aclTable.')
aclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: aclIndex.setStatus('current')
if mibBuilder.loadTexts: aclIndex.setDescription('The IP ACL table index this instance is associated with.')
aclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclStatus.setStatus('current')
if mibBuilder.loadTexts: aclStatus.setDescription('Status of this instance.  Entries can not be deleted until all rows in \r\n                     the aclIfTable and aclRuleTable with corresponding values of aclIndex \r\n                     have been deleted.\r\n                     \r\n                     active(1)      - this ACL instance is active\r\n                     createAndGo(4) - set to this value to create an instance\r\n                     destroy(6)     - set to this value to delete an instance')
aclIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8), )
if mibBuilder.loadTexts: aclIfTable.setStatus('current')
if mibBuilder.loadTexts: aclIfTable.setDescription('A table of ACL interface instances per direction.')
aclIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIfIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIfDirection"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIfSequence"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIfAclType"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIfAclId"))
if mibBuilder.loadTexts: aclIfEntry.setStatus('current')
if mibBuilder.loadTexts: aclIfEntry.setDescription('The entry of the aclIfTable.')
aclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 1), Integer32())
if mibBuilder.loadTexts: aclIfIndex.setStatus('current')
if mibBuilder.loadTexts: aclIfIndex.setDescription('The interface to which this ACL instance applies.')
aclIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: aclIfDirection.setStatus('current')
if mibBuilder.loadTexts: aclIfDirection.setDescription('The interface direction to which this ACL instance applies.')
aclIfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: aclIfSequence.setStatus('current')
if mibBuilder.loadTexts: aclIfSequence.setDescription('The relative evaluation sequence of this ACL for this\r\n                      interface and direction.  When multiple ACLs are allowed \r\n                      for a given interface and direction, the sequence number \r\n                      determines the order in which the list of ACLs are evaluated,\r\n                      with lower sequence numbers given higher precedence.  The\r\n                      sequence number value is arbitrary, but must be a unique\r\n                      non-zero value for a given interface and direction.\r\n                       \r\n                      Setting this object to an existing sequence number \r\n                      value for a given interface and direction causes the \r\n                      ACL corresponding to that value to be replaced with\r\n                      this ACL.')
aclIfAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2))))
if mibBuilder.loadTexts: aclIfAclType.setStatus('current')
if mibBuilder.loadTexts: aclIfAclType.setDescription('The type of this ACL, which is used to interpret the \r\n                      aclIfId object value.  Each type of ACL uses its own\r\n                      numbering scheme for identification (see aclIfId object\r\n                      for details).\r\n\r\n                      The aclIfId object must be specified along with this \r\n                      object.')
aclIfAclId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 5), Integer32())
if mibBuilder.loadTexts: aclIfAclId.setStatus('current')
if mibBuilder.loadTexts: aclIfAclId.setDescription('The ACL identifier value, which is interpreted based on\r\n                      the aclIfType object.\r\n\r\n                      For the IP ACLs, the actual ACL number is its identifier\r\n                      as follows:  IP standard ranges from 1-99, while \r\n                      IP extended ranges from 100-199. Here, aclIfAclId represents \r\n                      aclIndex. \r\n\r\n                      The MAC ACLs use an internally-generated index value\r\n                      that is assigned when the ACL is created.Here, aclIfAclId \r\n                      represents aclMacIndex.\r\n\r\n                      The aclIfType object must be specified along with\r\n                      this object.')
aclIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclIfStatus.setStatus('current')
if mibBuilder.loadTexts: aclIfStatus.setDescription('Status of this instance.\r\n                     \r\n                     active(1)      - this ACL interface instance is active\r\n                     createAndGo(4) - set to this value to assign an ACL to an interface and direction\r\n                     destroy(6)     - set to this value to remove an ACL from an interface and direction')
aclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4), )
if mibBuilder.loadTexts: aclRuleTable.setStatus('current')
if mibBuilder.loadTexts: aclRuleTable.setDescription('A table of IP ACL Rule instances.')
aclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "aclIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclRuleIndex"))
if mibBuilder.loadTexts: aclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: aclRuleEntry.setDescription('A table of IP ACL Classification Rules')
aclRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: aclRuleIndex.setStatus('current')
if mibBuilder.loadTexts: aclRuleIndex.setDescription('The index of this rule instance within an IP ACL.')
aclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2))).clone('deny')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleAction.setStatus('current')
if mibBuilder.loadTexts: aclRuleAction.setDescription('The type of action this rule should perform.')
aclRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: aclRuleProtocol.setDescription('icmp - 1\r\n                      igmp - 2\r\n                      ip - 4\r\n                      tcp - 6\r\n                      udp - 17\r\n                      All values from 1 to 255 are valid.')
aclRuleSrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleSrcIpAddress.setStatus('current')
if mibBuilder.loadTexts: aclRuleSrcIpAddress.setDescription('The Source IP Address used in the ACL Classification.')
aclRuleSrcIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleSrcIpMask.setStatus('current')
if mibBuilder.loadTexts: aclRuleSrcIpMask.setDescription("The Source IP Mask used in the ACL Classification.\r\n         This mask is expressed using wild-card notation,which\r\n         is the 1's compliment of traditional  Subnet Masks.\r\n         Here, the 'Don't care bits' are represented by binary 1's and \r\n         'Do care bits' are represented by binary 0's. ")
aclRuleSrcL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleSrcL4Port.setStatus('current')
if mibBuilder.loadTexts: aclRuleSrcL4Port.setDescription('The Source Port Number (Layer 4) used in the ACL Classification.')
aclRuleSrcL4PortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleSrcL4PortRangeStart.setStatus('current')
if mibBuilder.loadTexts: aclRuleSrcL4PortRangeStart.setDescription('The Source Port Number(Layer 4) range start.')
aclRuleSrcL4PortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleSrcL4PortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: aclRuleSrcL4PortRangeEnd.setDescription('The Source Port Number(Layer 4) range end.')
aclRuleDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 9), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleDestIpAddress.setStatus('current')
if mibBuilder.loadTexts: aclRuleDestIpAddress.setDescription('The Destination IP Address used in the ACL Classification.')
aclRuleDestIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 10), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleDestIpMask.setStatus('current')
if mibBuilder.loadTexts: aclRuleDestIpMask.setDescription("The Destination  IP Mask used in the ACL Classification.\r\n         This mask is expressed using wild-card notation,which\r\n         is   the 1's compliment of traditional  Subnet Masks.\r\n         Here, the 'Don't care bits' are represented by binary 1's and \r\n         'Do care bits' are represented by binary 0's. ")
aclRuleDestL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleDestL4Port.setStatus('current')
if mibBuilder.loadTexts: aclRuleDestL4Port.setDescription('The Destination Port (Layer 4) used in ACl classification.')
aclRuleDestL4PortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleDestL4PortRangeStart.setStatus('current')
if mibBuilder.loadTexts: aclRuleDestL4PortRangeStart.setDescription('The Destination Port (Layer 4) starting range used in ACL classification.')
aclRuleDestL4PortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleDestL4PortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: aclRuleDestL4PortRangeEnd.setDescription('The Destination Port (Layer 4) ending range used in ACL classification.')
aclRuleIPDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleIPDSCP.setStatus('current')
if mibBuilder.loadTexts: aclRuleIPDSCP.setDescription('The Differentiated Services Code Point value.')
aclRuleIpPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleIpPrecedence.setStatus('current')
if mibBuilder.loadTexts: aclRuleIpPrecedence.setDescription('The Type of Service (TOS) IP Precedence value.')
aclRuleIpTosBits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleIpTosBits.setStatus('current')
if mibBuilder.loadTexts: aclRuleIpTosBits.setDescription('The Type of Service (TOS) Bits value.')
aclRuleIpTosMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleIpTosMask.setStatus('current')
if mibBuilder.loadTexts: aclRuleIpTosMask.setDescription('The Type of Service (TOS) Mask value.')
aclRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleStatus.setStatus('current')
if mibBuilder.loadTexts: aclRuleStatus.setDescription('Status of this instance.\r\n                     \r\n                     active(1)      - this ACL Rule is active\r\n                     createAndGo(4) - set to this value to create an instance\r\n                     destroy(6)     - set to this value to delete an instance')
aclRuleAssignQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 19), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleAssignQueueId.setStatus('current')
if mibBuilder.loadTexts: aclRuleAssignQueueId.setDescription('Queue identifier to which all inbound packets matching this \r\n                      ACL rule are directed.  This object defaults to the standard\r\n                      queue assignment for user priority 0 traffic per the IEEE 802.1D\r\n                      specification based on the number of assignable queues in the \r\n                      system:\r\n                         1-3 queues:  0\r\n                         4-7 queues:  1\r\n                           8 queues:  2\r\n                      This default assignment is static and is not influenced by\r\n                      other system configuration changes.')
aclRuleRedirectIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 20), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleRedirectIntf.setStatus('current')
if mibBuilder.loadTexts: aclRuleRedirectIntf.setDescription('A non-zero value indicates the external ifIndex to which all \r\n                      inbound packets matching this ACL rule are directed.  A \r\n                      value of zero means packet redirection is not in effect, which\r\n                      is the default value of this object.')
aclRuleMatchEvery = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 4, 1, 21), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclRuleMatchEvery.setStatus('current')
if mibBuilder.loadTexts: aclRuleMatchEvery.setDescription('Flag to indicate that the acl rule is defined to match on every IP packet, \r\n                      regardless of content.')
aclMacIndexNextFree = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclMacIndexNextFree.setStatus('current')
if mibBuilder.loadTexts: aclMacIndexNextFree.setDescription('This object contains an unused value for the aclMacIndex\r\n                      to be used when creating a new MAC ACL.  A value of zero\r\n                      zero indicates the ACL table is full.')
aclMacTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 6), )
if mibBuilder.loadTexts: aclMacTable.setStatus('current')
if mibBuilder.loadTexts: aclMacTable.setDescription('A table of MAC ACL instances.')
aclMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 6, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "aclMacIndex"))
if mibBuilder.loadTexts: aclMacEntry.setStatus('current')
if mibBuilder.loadTexts: aclMacEntry.setDescription('The entry of the aclMacTable.')
aclMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: aclMacIndex.setStatus('current')
if mibBuilder.loadTexts: aclMacIndex.setDescription('The MAC ACL table index this instance is associated with.\r\n                      When creating a new MAC ACL, refer to the aclMacIndexNextFree\r\n                      object to determine the next available aclMacIndex to use.')
aclMacName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacName.setStatus('current')
if mibBuilder.loadTexts: aclMacName.setDescription('The name of this MAC ACL entry, which must consist of\r\n                      1 to 31 alphanumeric characters and uniquely identify\r\n                      this MAC ACL.  An existing MAC ACL can be renamed by\r\n                      setting this object to a new name.\r\n\r\n                      This object must be set to complete a new MAC ACL \r\n                      row instance.')
aclMacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacStatus.setStatus('current')
if mibBuilder.loadTexts: aclMacStatus.setDescription('Status of this instance.  ACL MAC entries can not be deleted until all rows in \r\n                     the aclIfTable and aclRuleTable with corresponding values of aclMacIndex \r\n                     have been deleted.\r\n                     \r\n                     active(1)      - this ACL instance is active\r\n                     createAndGo(4) - set to this value to create an instance\r\n                     destroy(6)     - set to this value to delete an instance\r\n\r\n                     The aclMacName object must be set to complete this row instance.')
aclMacRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7), )
if mibBuilder.loadTexts: aclMacRuleTable.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleTable.setDescription('A table of layer 2 MAC ACL Rule instances.')
aclMacRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "aclMacIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "aclMacRuleIndex"))
if mibBuilder.loadTexts: aclMacRuleEntry.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleEntry.setDescription('A table of layer 2 MAC ACL Classification Rules')
aclMacRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: aclMacRuleIndex.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleIndex.setDescription('The index of this rule instance within an MAC ACL.')
aclMacRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2))).clone('deny')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleAction.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleAction.setDescription('The type of action this MAC ACL rule should perform.')
aclMacRuleCos = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleCos.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleCos.setDescription('The Class of Service (COS) used in the MAC ACL Classification.\r\n\r\n                      This is the three-bit user priority field in the 802.1Q tag \r\n                      header of a tagged Ethernet frame. For frames containing a \r\n                      double VLAN tag, this field is located in the first/outer tag.')
aclMacRuleCos2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleCos2.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleCos2.setDescription('The Secondary Class of Service (COS2) used in the MAC ACL Classification.\r\n\r\n                      This is the three-bit user priority field in the second/inner 802.1Q \r\n                      tag header of a double VLAN tagged Ethernet frame.')
aclMacRuleDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 5), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleDestMacAddr.setDescription('The Destination MAC address used in the MAC ACL Classification.')
aclMacRuleDestMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 6), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleDestMacMask.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleDestMacMask.setDescription('The Destination MAC address mask used in the MAC ACL Classification. \r\n\r\n                      This mask value identifies the portion of the aclMacRuleDestMacAddr\r\n                      that is compared against a packet. A non-contiguous mask value is \r\n                      permitted.')
aclMacRuleEtypeKey = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("custom", 1), ("appletalk", 2), ("arp", 3), ("ibmsna", 4), ("ipv4", 5), ("ipv6", 6), ("ipx", 7), ("mplsmcast", 8), ("mplsucast", 9), ("netbios", 10), ("novell", 11), ("pppoe", 12), ("rarp", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleEtypeKey.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleEtypeKey.setDescription('The Ethertype keyword used in the MAC ACL Classification.\r\n\r\n                      A keyword of custom(1) requires that the aclMacRuleEtypeValue\r\n                      object also be set.')
aclMacRuleEtypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 8), EtypeValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleEtypeValue.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleEtypeValue.setDescription('The Ethertype custom value used in the MAC ACL Classification.\r\n\r\n                      This object is only valid if the aclMacRuleEtypeKey is set to \r\n                      custom(1).  The allowed value for this object is 0x0600 to 0xFFFF\r\n\t\t      (1536 to 65535).')
aclMacRuleSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 9), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleSrcMacAddr.setDescription('The Source MAC address used in the MAC ACL Classification.')
aclMacRuleSrcMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 10), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleSrcMacMask.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleSrcMacMask.setDescription('The Source MAC address mask used in the MAC ACL Classification. \r\n\r\n                      This mask value identifies the portion of the aclMacRuleSrcMacAddr\r\n                      that is compared against a packet. A non-contiguous mask value is \r\n                      permitted.')
aclMacRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanId.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanId.setDescription('The VLAN ID value used in the MAC ACL Classification.\r\n\r\n                      The VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the 802.1Q tag header of a tagged Ethernet frame.  This is \r\n                      contained in the first/outer tag of a double VLAN tagged frame.')
aclMacRuleVlanIdRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanIdRangeStart.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanIdRangeStart.setDescription('The VLAN ID range start value used in the MAC ACL Classification.\r\n\t\t      Setting this value greater than the current aclMacRuleVlanIdRangeEnd\r\n\t\t      changes the VLAN ID range end to the same value as the range start.\r\n\r\n                      The VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the 802.1Q tag header of a tagged Ethernet frame.  This is \r\n                      contained in the first/outer tag of a double VLAN tagged frame.')
aclMacRuleVlanIdRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanIdRangeEnd.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanIdRangeEnd.setDescription('The VLAN ID range end value used in the MAC ACL Classification.\r\n\t\t      Setting this value less than the current aclMacRuleVlanIdRangeStart\r\n\t\t      changes the VLAN ID range start to the same value as the range end.\r\n\r\n                      The VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the 802.1Q tag header of a tagged Ethernet frame.  This is \r\n                      contained in the first/outer tag of a double VLAN tagged frame.')
aclMacRuleVlanId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanId2.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanId2.setDescription('The Secondary VLAN ID value used in the MAC ACL Classification.\r\n\r\n                      The Secondary VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet \r\n                      frame.')
aclMacRuleVlanId2RangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanId2RangeStart.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanId2RangeStart.setDescription('The Secondary VLAN ID range start value used in the MAC ACL Classification.\r\n\t\t      Setting this value greater than the current aclMacRuleVlanId2RangeEnd\r\n\t\t      changes the Secondary VLAN ID range end to the same value as the range start.\r\n\r\n                      The Secondary VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet \r\n                      frame.')
aclMacRuleVlanId2RangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleVlanId2RangeEnd.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleVlanId2RangeEnd.setDescription('The Secondary VLAN ID range end value used in the MAC ACL Classification.\r\n\t\t      Setting this value less than the current aclMacRuleVlanId2RangeStart\r\n\t\t      changes the Secondary VLAN ID range start to the same value as the range end.\r\n\r\n                      The Secondary VLAN ID field is defined as the 12-bit VLAN identifier\r\n                      in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet \r\n                      frame.')
aclMacRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleStatus.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleStatus.setDescription('Status of this instance.\r\n                     \r\n                     active(1)      - this ACL Rule is active\r\n                     createAndGo(4) - set to this value to create an instance\r\n                     destroy(6)     - set to this value to delete an instance')
aclMacRuleAssignQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 18), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleAssignQueueId.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleAssignQueueId.setDescription('Queue identifier to which all inbound packets matching this \r\n                      MAC ACL rule are directed.  This object defaults to the standard\r\n                      queue assignment for user priority 0 traffic per the IEEE 802.1D\r\n                      specification based on the number of assignable queues in the \r\n                      system:\r\n                         1-3 queues:  0\r\n                         4-7 queues:  1\r\n                           8 queues:  2\r\n                      This default assignment is static and is not influenced by\r\n                      other system configuration changes.')
aclMacRuleRedirectIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 19), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleRedirectIntf.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleRedirectIntf.setDescription('A non-zero value indicates the external ifIndex to which all \r\n                      inbound packets matching this MAC ACL rule are directed.  A\r\n                      value of zero means packet redirection is not in effect, which\r\n                      is the default value of this object.')
aclMacRuleMatchEvery = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 2, 7, 1, 20), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclMacRuleMatchEvery.setStatus('current')
if mibBuilder.loadTexts: aclMacRuleMatchEvery.setDescription('Flag to indicate that the MAC acl rule is defined to match all packets, \r\n                      regardless of Ethertype.')
hmAgentCosMapCfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1))
hmAgentCosMapIpPrecTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 1), )
if mibBuilder.loadTexts: hmAgentCosMapIpPrecTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpPrecTable.setDescription('A table mapping evaluated IP precedence to Traffic \r\n                     Class for a specific physical port.  Traffic class \r\n                     is a number in the range \r\n                     (0..(dot1dPortNumTrafficClasses-1)).')
hmAgentCosMapIpPrecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 1, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosMapIpPrecIntfIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosMapIpPrecValue"))
if mibBuilder.loadTexts: hmAgentCosMapIpPrecEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpPrecEntry.setDescription('IP Precedence to Traffic Class mapping for a port.')
hmAgentCosMapIpPrecIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 1, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hmAgentCosMapIpPrecIntfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpPrecIntfIndex.setDescription('This is a unique index for an entry in the  \r\n                     hmAgentCosMapIpPrecTable.  A non-zero value indicates  \r\n                     the ifIndex for the corresponding interface entry  \r\n                     in the ifTable.  A value of zero represents global\r\n                     configuration, which in turn causes all interface\r\n\t\t     entries to be updated for a set operation, or \r\n\t\t     reflects the most recent global setting for a get\r\n\t\t     operation.')
hmAgentCosMapIpPrecValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: hmAgentCosMapIpPrecValue.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpPrecValue.setDescription('The IP precedence value contained in the received \r\n                     frame.  This value is only indicated in IP packets, \r\n                     but is independent of both media-type and frame \r\n                     tagging.\r\n                      \r\n                     Non-IP packets are handled in accordance with the \r\n                     dot1dPortDefaultUserPriority value of the ingress \r\n                     port.')
hmAgentCosMapIpPrecTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosMapIpPrecTrafficClass.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpPrecTrafficClass.setDescription('Traffic class priority queue the received frame is \r\n                     mapped to.  This represents the actual configuration \r\n                     setting the port is using.')
hmAgentCosMapIpDscpTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 2), )
if mibBuilder.loadTexts: hmAgentCosMapIpDscpTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpDscpTable.setDescription('A table mapping evaluated IP DSCP to Traffic Class \r\n                     for a specific physical port.  Traffic class is a \r\n                     number in the range \r\n                     (0..(dot1dPortNumTrafficClasses-1)).')
hmAgentCosMapIpDscpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 2, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosMapIpDscpIntfIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosMapIpDscpValue"))
if mibBuilder.loadTexts: hmAgentCosMapIpDscpEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpDscpEntry.setDescription('IP DSCP to Traffic Class mapping for a port.')
hmAgentCosMapIpDscpIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 2, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hmAgentCosMapIpDscpIntfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpDscpIntfIndex.setDescription('This is a unique index for an entry in the  \r\n                     hmAgentCosMapIpDscpTable.  A non-zero value indicates  \r\n                     the ifIndex for the corresponding interface entry  \r\n                     in the ifTable.  A value of zero represents global\r\n                     configuration, which in turn causes all interface\r\n\t\t     entries to be updated for a set operation, or \r\n\t\t     reflects the most recent global setting for a get\r\n\t\t     operation.')
hmAgentCosMapIpDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: hmAgentCosMapIpDscpValue.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpDscpValue.setDescription('The IP DSCP value contained in the received frame.  \r\n                     This value is only indicated in IP packets, but is \r\n                     independent of both media-type and frame tagging.\r\n                     \r\n                     Non-IP packets are handled in accordance with the \r\n                     dot1dPortDefaultUserPriority value of the ingress \r\n                     port.')
hmAgentCosMapIpDscpTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosMapIpDscpTrafficClass.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIpDscpTrafficClass.setDescription('Traffic class priority queue the received frame is \r\n                     mapped to.')
hmAgentCosMapIntfTrustTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 3), )
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustTable.setDescription('Specifies the interface trust mode of operation for \r\n                     a port.  The trust mode setting determines which COS \r\n                     mapping table is used for directing ingress packets \r\n                     to a Traffic Class.')
hmAgentCosMapIntfTrustEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosMapIntfTrustIntfIndex"))
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustEntry.setDescription('COS interface trust mode.')
hmAgentCosMapIntfTrustIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustIntfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustIntfIndex.setDescription('This is a unique index for an entry in the  \r\n                     hmAgentCosMapIntfTrustTable.  A non-zero value indicates  \r\n                     the ifIndex for the corresponding interface entry  \r\n                     in the ifTable.  A value of zero represents global\r\n                     configuration, which in turn causes all interface\r\n\t\t     entries to be updated for a set operation, or \r\n\t\t     reflects the most recent global setting for a get\r\n\t\t     operation.')
hmAgentCosMapIntfTrustMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("untrusted", 1), ("trustDot1p", 2), ("trustIpPrecedence", 3), ("trustIpDscp", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapIntfTrustMode.setDescription('The class of service trust mode of an interface.  \r\n                     When set to a trusted mode, the appropriate COS \r\n                     mapping table is used as follows:\r\n                       \r\n                         trustDot1p(2) : dot1dTrafficClassTable\r\n                         trustIpPrecedence(3): hmAgentCosMapIpPrecTable\r\n                         trustIpDscp(4): hmAgentCosMapIpDscpTable \r\n                       \r\n                     For an untrusted(1) interface, packets are handled in \r\n                     accordance with the dot1dPortDefaultUserPriority value \r\n                     of the ingress port.')
hmAgentCosMapUntrustedTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCosMapUntrustedTrafficClass.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosMapUntrustedTrafficClass.setDescription('The traffic class (i.e. hardware queue) to which all\r\n                     untrusted traffic is assigned.  This includes all \r\n                     traffic when the hmAgentCosMapIntfTrustMode is set to \r\n\t\t     untrusted(1), or just non-IP packets when in \r\n\t\t     trustIpPrecedence(3) or trustIpDscp(4) modes.\r\n\r\n                     This is a read-only object that reflects the current setting\r\n\t\t     of the dot1dPortDefaultUserPriority object as mapped \r\n\t\t     to a traffic class through the dot1dTrafficClassEntry.')
hmAgentCosQueueCfgGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2))
hmAgentCosQueueNumQueuesPerPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCosQueueNumQueuesPerPort.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueNumQueuesPerPort.setDescription('The number of configurable COS queues per port  \r\n                     supported by the hardware device.')
hmAgentCosQueueNumDropPrecedenceLevels = MibScalar((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentCosQueueNumDropPrecedenceLevels.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueNumDropPrecedenceLevels.setDescription('The number of distinct drop precedence levels per \r\n                     queue supported by the hardware device.  These levels \r\n                     are typically used when configuring the queue \r\n                     management tail drop and WRED parameters.')
hmAgentCosQueueControlTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3), )
if mibBuilder.loadTexts: hmAgentCosQueueControlTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueControlTable.setDescription('Table of class-of-service queue configuration \r\n                     controls for the specified interface.')
hmAgentCosQueueControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosQueueIntfIndex"))
if mibBuilder.loadTexts: hmAgentCosQueueControlEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueControlEntry.setDescription('Provides a general control mechanism that affects \r\n                     all queues on a given interface.')
hmAgentCosQueueIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: hmAgentCosQueueIntfIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueIntfIndex.setDescription('This is a unique index for an entry in the  \r\n                     hmAgentCosQueueControlTable, hmAgentCosQueueTable,\r\n\t\t     or hmAgentCosQueueMgmtTable.  A non-zero value indicates  \r\n                     the ifIndex for the corresponding interface entry  \r\n                     in the ifTable.  A value of zero represents global\r\n                     configuration, which in turn causes all interface\r\n\t\t     entries to be updated for a set operation, or \r\n\t\t     reflects the most recent global setting for a get\r\n\t\t     operation.')
hmAgentCosQueueIntfShapingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueIntfShapingRate.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueIntfShapingRate.setDescription('Maximum bandwidth allowed for this interface as a \r\n                     whole, typically used to shape the outbound \r\n                     transmission rate. The value is specified in terms \r\n                     of percentage of overall link speed for the port in \r\n                     1% increments.  A value of 0 means there is no \r\n                     maximum bandwidth limit in effect and that the \r\n                     interface is allowed to transmit up to its maximum \r\n                     line rate (i.e., work conserving method).  \r\n                     The default value is 0.\r\n                     \r\n                     When set to a non-zero value, the interface is \r\n                     restricted to using at most the bandwidth specified \r\n                     in this object for the outbound transmission rate \r\n                     (i.e., non-work-conserving method).  This bandwidth \r\n                     value is independent of any per-queue maximum \r\n                     bandwidth value(s) in effect for the interface, as \r\n                     specified in the hmAgentCosQueueMaxBandwidth ohject, \r\n                     and should be considered as a second-level \r\n                     transmission rate control mechanism that regulates \r\n                     the output of the entire interface regardless of \r\n                     which queues originate the outbound traffic.')
hmAgentCosQueueMgmtTypeIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("taildrop", 1), ("wred", 2))).clone('taildrop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueMgmtTypeIntf.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueMgmtTypeIntf.setDescription('The management technique used for all queues on this \r\n                     interface.  If taildrop(1), then all new packets \r\n                     presented to the queues are dropped based on some \r\n                     maximum threshold value(s). If wred(2), then an \r\n                     active queue management scheme is employed whereby \r\n                     packet drop precedence is considered during times of \r\n                     queue congestion using WRED parameters.   The \r\n                     necessary queue management parameters are specified \r\n                     in the hmAgentCosQueueMgmtTable for the corresponding \r\n                     hmAgentCosQueueIntfIndex value.  The default for this\r\n                     object is taildrop(1).\r\n                     \r\n                     Implementations that support this object but do not \r\n                     support weighted RED must return taildrop(1) for this \r\n                     value and must not allow a value of wred(2) to be set.')
hmAgentCosQueueWredDecayExponent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueWredDecayExponent.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueWredDecayExponent.setDescription('The decay exponent value used with the weighted \r\n                     random early discard (WRED) algorithm to determine \r\n                     how quickly the average queue length calculation \r\n                     reacts to the current length of the queue.  A higher \r\n                     value produces a slower response, meaning previously \r\n                     sampled queue length values are factored into the \r\n                     calculation for a longer period of time.  The default \r\n                     value is 9.\r\n                     \r\n                     Use caution when changing this value from its \r\n                     default.  If set too low, short traffic bursts can \r\n                     cause WRED to drop too many packets.  If set too \r\n                     high, WRED might not detect queue congestion in a \r\n                     timely manner and becomes ineffective.  The default \r\n                     value should be sufficient for most users.\r\n                     \r\n                     This object value is only used when the \r\n                     hmAgentCosQueueMgmtType is set to wred(2) and is \r\n                     otherwise ignored.')
hmAgentCosQueueDefaultsRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueDefaultsRestore.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueDefaultsRestore.setDescription('Causes the default values to be restored for all COS \r\n                     queue objects defined for this interface.  This \r\n                     includes objects in the following tables:  \r\n                           hmAgentCosQueueTable\r\n                           hmAgentCosQueueMgmtTable\r\n                           \r\n                      This object always reads as disable(2). This object may \r\n                      only be set to enable(1), which immediately causes the \r\n                      default value restoration action as described above. \r\n                      In essence, this models a momentary-style push button \r\n                      switch that triggers a restoration of the original \r\n                      default values for all affected objects.')
hmAgentCosQueueTable = MibTable((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4), )
if mibBuilder.loadTexts: hmAgentCosQueueTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueTable.setDescription('Table of class-of-service queue configuration \r\n                     parameters for the specified interface.')
hmAgentCosQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1), ).setIndexNames((0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosQueueIntfIndex"), (0, "HIRSCHMANN-MMP4-QOS-MIB", "hmAgentCosQueueIndex"))
if mibBuilder.loadTexts: hmAgentCosQueueEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueEntry.setDescription("Each entry describes a single class-of-service (COS) \r\n                     queue for a given Interface Index. The number of \r\n                     configurable COS queues for an interface vary based \r\n\t\t     on device capabilities.\r\n\r\n                     All objects defined for this table entry contain a \r\n                     default value corresponding to a typical, \r\n                     non-preferential treatment of packets traversing the \r\n                     interface's COS queues.")
hmAgentCosQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: hmAgentCosQueueIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueIndex.setDescription('The COS queue index, numbered 0 to (n-1), where n is \r\n                     the total number of configurable interface queues for \r\n                     the device as indicated by hmAgentCosQueueNumQueuesPerPort.\r\n                     In general, a higher numbered queue index is used to \r\n                     support higher priority traffic, although actual \r\n                     operation may be altered via configuration through \r\n                     this table.')
hmAgentCosQueueSchedulerType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("weighted", 2))).clone('weighted')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueSchedulerType.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueSchedulerType.setDescription('The type of scheduling used for this queue.  If \r\n                     strict(1), then all traffic placed on this queue is \r\n                     transmitted before any queue with a lower precedence \r\n                     (lower hmAgentCosQueueIndex).  A weighted(2) scheme \r\n                     gives this queue service relative to other weighted \r\n                     queues based on their relative hmAgentCosQueueMinBandwidth \r\n\t\t     object values.  The default is weighted(2).')
hmAgentCosQueueMinBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueMinBandwidth.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueMinBandwidth.setDescription('Minimum guaranteed bandwidth allotted to this queue. \r\n                     The value is specified in terms of percentage of \r\n                     overall link speed for the port in 1% increments.  A \r\n                     value of 0 means there is no guaranteed minimum \r\n                     bandwidth in effect (best-effort service).  \r\n                     The default value is 0.\r\n                     \r\n                     The sum of all hmAgentCosQueueMinBandwidth object \r\n                     values for the queues on the same interface must not \r\n                     exceed 100%.\r\n                     \r\n                     If the hmAgentCosQueueMaxBandwidth corresponding to the \r\n                     same hmAgentCosQueueIndex on this interface is \r\n                     currently set to a non-zero value, then setting this \r\n                     object to a value greater than \r\n                     hmAgentCosQueueMaxBandwidth automatically updates \r\n                     hmAgentCosQueueMaxBandwidth to the same value to \r\n                     maintain a proper relationship between the minimum \r\n                     and maximum queue bandwidth specification.\r\n                     \r\n                     The value of this object is ignored when \r\n                     hmAgentCosQueueSchedulerType is set to strict(1).')
hmAgentCosQueueMaxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueMaxBandwidth.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueMaxBandwidth.setDescription('Maximum bandwidth allowed for this queue, typically \r\n                     used to shape the outbound transmission rate. The \r\n                     value is specified in terms of percentage of overall \r\n                     link speed for the port in 1% increments.  A value \r\n                     of 0 means there is no maximum bandwidth limit in \r\n                     effect and that the queue is allowed to use any \r\n                     available excess bandwidth (i.e., work conserving \r\n                     method).  The default value is 0.\r\n                     \r\n                     When set to a non-zero value, the queue is restricted \r\n                     to using at most the bandwidth specified in this \r\n                     object for the outbound transmission rate (i.e., \r\n                     non-work-conserving method).  Any non-zero value set \r\n                     for this object must be equal to or greater than the \r\n                     value of hmAgentCosQueueMinBandwidth for the same \r\n                     hmAgentCosQueueIndex on this interface.')
hmAgentCosQueueMgmtType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 15, 3, 3, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("taildrop", 1), ("wred", 2))).clone('taildrop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCosQueueMgmtType.setStatus('current')
if mibBuilder.loadTexts: hmAgentCosQueueMgmtType.setDescription('The queue depth management technique used when \r\n                     per-queue specification is supported.  If \r\n                     taildrop(1), then all new packets presented to the \r\n                     queue are dropped based on some maximum threshold \r\n                     value(s). If wred(2), then an active queue management \r\n                     scheme is employed whereby packet drop precedence is \r\n                     considered during times of queue congestion using \r\n                     WRED parameters.   The necessary queue management \r\n                     parameters are specified in the \r\n                     hmAgentCosQueueMgmtEntry for the corresponding \r\n\t\t     hmAgentCosQueueIntfIndex and hmAgentCosQueueIndex values.\r\n\t\t     The default for this object is taildrop(1).\r\n                     \r\n                     Implementations that do not support weighted RED must \r\n                     return taildrop(1) for this value and must not allow \r\n                     a value of wred(2) to be set.')
mibBuilder.exportSymbols("HIRSCHMANN-MMP4-QOS-MIB", aclMacIndexNextFree=aclMacIndexNextFree, hmAgentCosQueueControlTable=hmAgentCosQueueControlTable, aclRuleSrcIpMask=aclRuleSrcIpMask, aclRuleAssignQueueId=aclRuleAssignQueueId, PYSNMP_MODULE_ID=hmPlatform4QOS, hmAgentCosMapIpDscpIntfIndex=hmAgentCosMapIpDscpIntfIndex, hmAgentCosMapUntrustedTrafficClass=hmAgentCosMapUntrustedTrafficClass, hmPlatform4QOS=hmPlatform4QOS, aclRuleDestL4PortRangeEnd=aclRuleDestL4PortRangeEnd, aclRuleEntry=aclRuleEntry, aclIfTable=aclIfTable, Sixteenths=Sixteenths, aclRuleDestL4PortRangeStart=aclRuleDestL4PortRangeStart, aclMacRuleSrcMacMask=aclMacRuleSrcMacMask, aclRuleDestL4Port=aclRuleDestL4Port, aclIfEntry=aclIfEntry, aclTable=aclTable, aclMacRuleDestMacMask=aclMacRuleDestMacMask, aclRuleAction=aclRuleAction, hmAgentCosQueueEntry=hmAgentCosQueueEntry, aclIndex=aclIndex, aclRuleIpTosMask=aclRuleIpTosMask, aclMacRuleEntry=aclMacRuleEntry, hmAgentCosQueueIntfIndex=hmAgentCosQueueIntfIndex, aclMacRuleCos=aclMacRuleCos, aclRuleIpPrecedence=aclRuleIpPrecedence, hmAgentCosQueueCfgGroup=hmAgentCosQueueCfgGroup, hmAgentCosMapIntfTrustTable=hmAgentCosMapIntfTrustTable, hmAgentCosMapIntfTrustEntry=hmAgentCosMapIntfTrustEntry, aclRuleDestIpMask=aclRuleDestIpMask, aclRuleRedirectIntf=aclRuleRedirectIntf, aclMacIndex=aclMacIndex, hmAgentCosQueueIntfShapingRate=hmAgentCosQueueIntfShapingRate, hmAgentCosQueueNumQueuesPerPort=hmAgentCosQueueNumQueuesPerPort, aclIfAclType=aclIfAclType, aclIfAclId=aclIfAclId, hmAgentCosMapIpPrecTable=hmAgentCosMapIpPrecTable, hmAgentCosMapIpDscpTable=hmAgentCosMapIpDscpTable, hmAgentCosQueueDefaultsRestore=hmAgentCosQueueDefaultsRestore, hmAgentCosQueueMgmtType=hmAgentCosQueueMgmtType, hmAgentCosMapIpPrecValue=hmAgentCosMapIpPrecValue, hmAgentCosQueueWredDecayExponent=hmAgentCosQueueWredDecayExponent, hmAgentCosQueueNumDropPrecedenceLevels=hmAgentCosQueueNumDropPrecedenceLevels, aclRuleIpTosBits=aclRuleIpTosBits, aclMacRuleRedirectIntf=aclMacRuleRedirectIntf, hmAgentQOSCOS=hmAgentQOSCOS, aclIfDirection=aclIfDirection, hmAgentCosQueueMaxBandwidth=hmAgentCosQueueMaxBandwidth, aclRuleProtocol=aclRuleProtocol, aclMacRuleEtypeValue=aclMacRuleEtypeValue, hmAgentCosMapIntfTrustMode=hmAgentCosMapIntfTrustMode, aclMacName=aclMacName, aclMacTable=aclMacTable, aclRuleIPDSCP=aclRuleIPDSCP, aclMacRuleCos2=aclMacRuleCos2, aclMacRuleVlanIdRangeEnd=aclMacRuleVlanIdRangeEnd, aclMacRuleVlanId=aclMacRuleVlanId, aclMacEntry=aclMacEntry, hmAgentCosMapCfgGroup=hmAgentCosMapCfgGroup, hmAgentCosMapIpPrecIntfIndex=hmAgentCosMapIpPrecIntfIndex, aclMacRuleVlanId2RangeEnd=aclMacRuleVlanId2RangeEnd, aclMacRuleSrcMacAddr=aclMacRuleSrcMacAddr, aclStatus=aclStatus, aclMacRuleAction=aclMacRuleAction, hmAgentCosQueueIndex=hmAgentCosQueueIndex, aclMacRuleEtypeKey=aclMacRuleEtypeKey, hmAgentCosMapIpDscpEntry=hmAgentCosMapIpDscpEntry, aclRuleSrcL4PortRangeEnd=aclRuleSrcL4PortRangeEnd, hmAgentCosMapIntfTrustIntfIndex=hmAgentCosMapIntfTrustIntfIndex, aclMacRuleStatus=aclMacRuleStatus, hmAgentCosQueueTable=hmAgentCosQueueTable, aclMacRuleVlanId2RangeStart=aclMacRuleVlanId2RangeStart, EtypeValue=EtypeValue, aclMacRuleTable=aclMacRuleTable, PercentByFives=PercentByFives, aclIfIndex=aclIfIndex, aclRuleTable=aclRuleTable, aclRuleSrcIpAddress=aclRuleSrcIpAddress, hmAgentCosMapIpDscpTrafficClass=hmAgentCosMapIpDscpTrafficClass, aclMacRuleIndex=aclMacRuleIndex, aclMacRuleVlanIdRangeStart=aclMacRuleVlanIdRangeStart, aclMacRuleMatchEvery=aclMacRuleMatchEvery, aclRuleMatchEvery=aclRuleMatchEvery, hmAgentCosQueueMgmtTypeIntf=hmAgentCosQueueMgmtTypeIntf, hmAgentCosQueueSchedulerType=hmAgentCosQueueSchedulerType, aclRuleSrcL4PortRangeStart=aclRuleSrcL4PortRangeStart, hmAgentCosMapIpDscpValue=hmAgentCosMapIpDscpValue, aclMacRuleAssignQueueId=aclMacRuleAssignQueueId, aclMacRuleDestMacAddr=aclMacRuleDestMacAddr, aclMacStatus=aclMacStatus, aclRuleStatus=aclRuleStatus, aclEntry=aclEntry, hmAgentCosQueueMinBandwidth=hmAgentCosQueueMinBandwidth, hmAgentCosQueueControlEntry=hmAgentCosQueueControlEntry, hmAgentQOSACL=hmAgentQOSACL, hmAgentCosMapIpPrecTrafficClass=hmAgentCosMapIpPrecTrafficClass, aclRuleDestIpAddress=aclRuleDestIpAddress, aclIfStatus=aclIfStatus, hmAgentCosMapIpPrecEntry=hmAgentCosMapIpPrecEntry, aclMacRuleVlanId2=aclMacRuleVlanId2, aclIfSequence=aclIfSequence, aclRuleIndex=aclRuleIndex, aclRuleSrcL4Port=aclRuleSrcL4Port)
