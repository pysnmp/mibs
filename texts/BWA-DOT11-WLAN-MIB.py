#
# PySNMP MIB module BWA-DOT11-WLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/alvarion/BWA-DOT11-WLAN-MIB
# Produced by pysmi-1.1.12 at Tue Dec  3 12:31:40 2024
# On host fv-az658-333 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Counter32, Counter64, ObjectIdentity, ModuleIdentity, IpAddress, Unsigned32, TimeTicks, enterprises, MibIdentifier, iso, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "ObjectIdentity", "ModuleIdentity", "IpAddress", "Unsigned32", "TimeTicks", "enterprises", "MibIdentifier", "iso", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
bwa = MibIdentifier((1, 3, 6, 1, 4, 1, 12394))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1))
bwaVLMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 12394, 1, 1))
bwaVLMib.setRevisions(('1907-08-14 11:46',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bwaVLMib.setRevisionsDescriptions(('Version 4.5',))
if mibBuilder.loadTexts: bwaVLMib.setLastUpdated('0708141146Z')
if mibBuilder.loadTexts: bwaVLMib.setOrganization('BWA Products')
if mibBuilder.loadTexts: bwaVLMib.setContactInfo('Contact Man\n                         Postal: BWA Products\n\t\t\t             Street Number ZipCode\n\t\t\t             Country\n\t\t                 Tel:    000-0-0000000\n\t\t                 Fax:    000-0-0000000\n\t\t                 E-mail: E-mail')
if mibBuilder.loadTexts: bwaVLMib.setDescription('BWA VL products, BWA 4900, BWA-PtP')
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class DisplayString(OctetString):
    pass

bwaOID = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4))
bwaVLOID = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1))
bwaVLAU = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 1))
bwaVLSU = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 2))
bwaVLAU_BS = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 4)).setLabel("bwaVLAU-BS")
bwaVLAU_SA = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 5)).setLabel("bwaVLAU-SA")
bwaVLAUS_BS = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 6)).setLabel("bwaVLAUS-BS")
bwaVLAUS_SA = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 7)).setLabel("bwaVLAUS-SA")
bwaVLAU_EZ = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 8)).setLabel("bwaVLAU-EZ")
bwaVLSU_6_1D = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 11)).setLabel("bwaVLSU-6-1D")
bwaVLSU_6_BD = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 12)).setLabel("bwaVLSU-6-BD")
bwaVLSU_24_BD = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 13)).setLabel("bwaVLSU-24-BD")
bwaVLSU_BD = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 14)).setLabel("bwaVLSU-BD")
bwaVLSU_54_BD = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 15)).setLabel("bwaVLSU-54-BD")
bwaVLSU_3_1D = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 16)).setLabel("bwaVLSU-3-1D")
bwaVLSU_3_4D = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 17)).setLabel("bwaVLSU-3-4D")
bwaVLSU_I = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 18)).setLabel("bwaVLSU-I")
ptp_BU_B14 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 21)).setLabel("ptp-BU-B14")
ptp_BU_B28 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 22)).setLabel("ptp-BU-B28")
ptp_BU_B100 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 23)).setLabel("ptp-BU-B100")
ptp_RB_B14 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 31)).setLabel("ptp-RB-B14")
ptp_RB_B28 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 32)).setLabel("ptp-RB-B28")
ptp_RB_B100 = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 33)).setLabel("ptp-RB-B100")
bwa4900_AU_BS = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 41)).setLabel("bwa4900-AU-BS")
bwa4900_AU_SA = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 42)).setLabel("bwa4900-AU-SA")
bwa4900_SU_BD = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 51)).setLabel("bwa4900-SU-BD")
bwaVLProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3))
bwaVLSysInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1))
bwaVLUnitHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnitHwVersion.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitHwVersion.setDescription('Applicable to all units.  \n             Hardware platform version.')
bwaVLRunningSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunningSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunningSoftwareVersion.setDescription('Applicable to all units.  \n             Running software version.')
bwaVLRunningFrom = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mainVersion", 1), ("shadowVersion", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunningFrom.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunningFrom.setDescription('Applicable to all units.  \n             The memory (main or shadow) from which the current version is \n             running from.')
bwaVLMainVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMainVersionNumber.setStatus('current')
if mibBuilder.loadTexts: bwaVLMainVersionNumber.setDescription('Applicable to all units.  \n             Main software version number.')
bwaVLMainVersionFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMainVersionFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLMainVersionFileName.setDescription('Applicable to all units.  \n             Main software version file name.')
bwaVLShadowVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLShadowVersionNumber.setStatus('current')
if mibBuilder.loadTexts: bwaVLShadowVersionNumber.setDescription('Applicable to all units.  \n             Shadow software version number.')
bwaVLShadowVersionFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLShadowVersionFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLShadowVersionFileName.setDescription('Applicable to all units.  \n             Shadow software version file name.')
bwaVLUnitMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnitMacAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitMacAddress.setDescription('Applicable to all units.  \n             Unit hardware MAC address.')
bwaVLUnitType = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("auBS", 1), ("auSA", 2), ("su-6-1D", 3), ("su-6-BD", 4), ("su-24-BD", 5), ("bu-B14", 6), ("bu-B28", 7), ("rb-B14", 8), ("rb-B28", 9), ("su-BD", 10), ("su-54-BD", 11), ("su-3-1D", 12), ("su-3-4D", 13), ("ausBS", 14), ("ausSA", 15), ("auBS4900", 16), ("auSA4900", 17), ("su4900", 18), ("bu-B100", 19), ("rb-B100", 20), ("su-I", 21), ("au-E", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnitType.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitType.setDescription('Applicable to all units.  \n             auBS     (1) : AU-BS (modular access unit). \n             auSA     (2) : AU-SA (stand-alone access unit).\n             su-6-1D  (3) : SU-6-1D (subscriber unit supporting 6 Mbps)\n             su-6-BD  (4) : SU-6-BD (subscriber unit supporting 6 Mbps).\n             su-24-BD (5) : SU-24-BD (subscriber unit supporting 24 Mbps).\n\t\t\t bu-B14   (6) : BU-B14 (PtP Base Unit supporting 14 Mbps).\n\t\t\t bu-B28   (7) : BU-B28 (PtP Base Unit supporting 28 Mbps).\n\t\t\t rb-B14   (8) : RB-B14 (PtP Remote Bridge supporting 14 Mbps).\n\t\t\t rb-B28   (9) : RB-B28 (PtP Remote Bridge supporting 28 Mbps).\n\t\t\t su-BD   (10) : SU-BD (subscriber unit).\n\t\t\t su-54-BD(11) : SU-54-BD (subscriber unit supporting 54 Mbps).\n             su-3-1D (12) : SU-3-1D (subscriber unit supporting 3 Mbps).\n             su-3-4D (13) : SU-3-4D (subscriber unit supporting 3 Mbps).\n             ausBS   (14) : AUS-BS (modular access unit supporting maxim 8 or 25 \n                            (via licensing) subscribers and allowing association \n                            only with SU-3 or SU-6).\n             ausSA   (15) : AUS-SA (stand-alone access unit supporting maxim 8 or 25 \n                            (via licensing)subscribers and allowing association only \n                            with SU-3 or SU-6 ).\n             auBS4900(16) : AU-BS-4900 (BWA 4900 modular access unit)\n             auSA4900(17) : AU-SA-4900 (BWA 4900 stand alone access unit)\n             suBD4900(18) : SU-BD-4900 (BWA 4900 subscriber unit)\n             bu-B100 (19) : BU-B100 (PtP Base Unit unlimited throughput)\n             rb-B100 (20) : BU-B100 (PtP Remote Bridge unlimited throughput) \n             su-I    (21) : SU-I\n             au-E    (22) : AU-E')
bwaVLAssociatedAU = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 10), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAssociatedAU.setStatus('current')
if mibBuilder.loadTexts: bwaVLAssociatedAU.setDescription('Applicable to SU/RB only.  \n             Associated AU/BU MAC address.')
bwaVLNumOfAssociationsSinceLastReset = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNumOfAssociationsSinceLastReset.setStatus('current')
if mibBuilder.loadTexts: bwaVLNumOfAssociationsSinceLastReset.setDescription('Applicable to all units.  \n             The number of associations since last reset, including \n             duplicate associations (re-associations).')
bwaVLCurrentNumOfAssociations = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentNumOfAssociations.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentNumOfAssociations.setDescription('Applicable to AU only.  \n             Not applicable to BWA-PtP products.\n             The number of SUs currently associated with the AU.\n             BWA-PtP products return 65535.')
bwaVLUnitBootVersion = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnitBootVersion.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitBootVersion.setDescription('Applicable to all units.  \n             Boot version.')
bwaVLRadioBand = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("band-5-8GHz", 1), ("band-5-4GHz", 2), ("band-4-9GHz", 3), ("band-5-2GHz", 4), ("band-2-4GHz", 5), ("band-5-3GHz", 6), ("band-4-9GHzJapan", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRadioBand.setStatus('current')
if mibBuilder.loadTexts: bwaVLRadioBand.setDescription("Applicable to all units.  \n             The unit's radio band.")
bwaVLCurrentEthernetPortState = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("halfDuplexAnd10Mbps", 1), ("fullDuplexAnd10Mbps", 2), ("halfDuplexAnd100Mbps", 3), ("fullDuplexAnd100Mbps", 4), ("linkDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentEthernetPortState.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentEthernetPortState.setDescription('Applicable to all units.  \n             The current Ethernet port state.')
bwaVLTimeSinceLastReset = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTimeSinceLastReset.setStatus('current')
if mibBuilder.loadTexts: bwaVLTimeSinceLastReset.setDescription('Applicable to all units.  \n             The elapsed time since last reset.')
bwaVLCountryDependentParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18))
bwaVLCountryCode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCountryCode.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryCode.setDescription('Applicable to all units.\n             The country code and country name or country group name \n             that is supported by the unit.')
bwaVLCountryDependentParamsTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2), )
if mibBuilder.loadTexts: bwaVLCountryDependentParamsTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryDependentParamsTable.setDescription('Applicable to all units. A table of country dependent parameters.')
bwaVLCountryDependentParameterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLCountryDependentParameterTableIdx"))
if mibBuilder.loadTexts: bwaVLCountryDependentParameterEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryDependentParameterEntry.setDescription('Applicable to all units. \n             An entry in the Country Dependent Parameters table.')
bwaVLCountryDependentParameterTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCountryDependentParameterTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryDependentParameterTableIdx.setDescription('Applicable to all units. \n             The sub-band ID of the entry in the Country Dependent \n             Parameters table. Serves also as index for the table entry.')
bwaVLCountryDependentParameterFrequencies = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCountryDependentParameterFrequencies.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryDependentParameterFrequencies.setDescription('Applicable to all units. \n             The frequencies included in the applicable sub-band entry.')
bwaVLAllowedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAllowedBandwidth.setStatus('current')
if mibBuilder.loadTexts: bwaVLAllowedBandwidth.setDescription('Applicable to all units. \n             The bandwidth when using the applicable the sub-band.')
bwaVLRegulationMaxTxPowerAtAntennaPort = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRegulationMaxTxPowerAtAntennaPort.setStatus('current')
if mibBuilder.loadTexts: bwaVLRegulationMaxTxPowerAtAntennaPort.setDescription('Applicable to all units. \n             The maximum allowed Tx power when using the applicable sub-band.\n             A RegulationMaxTxPowerAtAntennaPort of 255, means no limit')
bwaVLRegulationMaxEIRP = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRegulationMaxEIRP.setStatus('current')
if mibBuilder.loadTexts: bwaVLRegulationMaxEIRP.setDescription('Applicable to all units.\n             The maximum Tx EIRP \n             when using the applicable sub-band.\n             A Regulation Max EIRP of 0, means no limit.')
bwaVLMinModulationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7), ("level8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMinModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinModulationLevel.setDescription('Applicable to all units. \n             The minimum supported modulation level.')
bwaVLMaxModulationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7), ("level8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaxModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxModulationLevel.setDescription('Applicable to all units. \n             The maximum supported modulation level.')
bwaVLBurstModeSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLBurstModeSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLBurstModeSupport.setDescription('Applicable to all units. \n             The supported Burst Mode Option.')
bwaVLMaximumBurstDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaximumBurstDuration.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumBurstDuration.setDescription('Applicable to all units. \n             Applicable only if Burst Mode Option is supported. \n             The maximum supported burst duration.')
bwaVLDfsSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDfsSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLDfsSupport.setDescription('Applicable to AU/BU only. \n             The supported Dfs Option.')
bwaVLMinimumHwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("hwRevisionA", 1), ("hwRevisionB", 2), ("hwRevisionC", 3), ("hwRevisionD", 4), ("hwRevisionE", 5), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMinimumHwRevision.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinimumHwRevision.setDescription('Applicable to all units. \n             The Minimum HW Revision needed to support the country code.')
bwaVLAuthenticationEncryptionSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAuthenticationEncryptionSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLAuthenticationEncryptionSupport.setDescription('Applicable to all units.\n             The supported Authentication Encryption Option.')
bwaVLDataEncryptionSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDataEncryptionSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLDataEncryptionSupport.setDescription('Applicable to all units.\n             The supported Data Encryption Option.')
bwaVLAESEncryptionSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 18, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAESEncryptionSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLAESEncryptionSupport.setDescription('Applicable to all units.\n             The supported AES Encryption Option.')
bwaVLAntennaGainChange = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAntennaGainChange.setStatus('current')
if mibBuilder.loadTexts: bwaVLAntennaGainChange.setDescription('Applicable to all units.  \n             Indicates whether the Antenna Gain parameter is changeable or fixed.')
bwaVLAteTestResults = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("pass", 1), ("fail", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAteTestResults.setStatus('current')
if mibBuilder.loadTexts: bwaVLAteTestResults.setDescription('Applicable to all units.  \n            Results of ATE Test ')
bwaVLSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 35))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSerialNumber.setStatus('current')
if mibBuilder.loadTexts: bwaVLSerialNumber.setDescription('Applicable to all units.  \n            Serial Number of the unit')
bwaVLUnitControl = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2))
bwaVLResetUnit = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cancel", 1), ("resetSystemNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLResetUnit.setStatus('current')
if mibBuilder.loadTexts: bwaVLResetUnit.setDescription('Applicable to all units.  \n             Resets the unit and applies new parameter values.')
bwaVLSetDefaults = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noDefaultSettingRequested", 0), ("completeFactory", 1), ("partialFactory", 2), ("completeOperator", 3), ("partialOperator", 4), ("cancelCurrentPendingRequest", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSetDefaults.setStatus('current')
if mibBuilder.loadTexts: bwaVLSetDefaults.setDescription('Applicable to all units.  \n             Sets unit configuration to Defaults values after the \n             next reset.    \n             noDefaultSettingRequested : Read-Only Option, no Default setting was Issued.\n             completeFactory : All parameters revert to Factory \n                               Defaults values.\n             partialFactory  : All parameters revert to Factory \n                               Defaults values, except the parameters \n                               required for maintaining wireless \n                               connectivity.    \n             completeOperator: All parameters revert to Operator \n                               Defaults values. \n             partialOperator : All parameters revert to Operator \n                               Defaults values, except the parameters \n                               required for maintaining wireless \n                               connectivity.\n             cancelCurrentPendingRequest : Default Setting request is cancelled.')
bwaVLUnitName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUnitName.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitName.setDescription('Applicable to all units.  \n             The unit name. \n             A string of up to 32 printable ASCII characters.')
bwaVLFlashMemoryControl = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("resetAndBootFromShadowVersion", 1), ("useRunningVersionAfterReset", 2), ("cancel", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFlashMemoryControl.setStatus('current')
if mibBuilder.loadTexts: bwaVLFlashMemoryControl.setDescription('Applicable to all units.  \n             resetAndBootFromShadowVersion : Activates the backup \n                                             version.   \n             useRunningVersionAfterReset   : The currently active \n                                             version will become the main \n                                             version and will be activated \n                                             after next reset.')
bwaVLTelnetLogoutTimer = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTelnetLogoutTimer.setStatus('current')
if mibBuilder.loadTexts: bwaVLTelnetLogoutTimer.setDescription('Applicable to all units.  \n             Time-out of management via Telnet program. \n             Automatic exit if the program is inactive for the \n             defined time.\n             Range: 1 to 999 (minutes).')
bwaVLSaveCurrentConfigurationAsOperatorDefaults = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("saveAsDefaults", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSaveCurrentConfigurationAsOperatorDefaults.setStatus('current')
if mibBuilder.loadTexts: bwaVLSaveCurrentConfigurationAsOperatorDefaults.setDescription('Applicable to all units.  \n             Saves the current configuration as Operator Defaults.\n             Cannot be executed after requesting set defaults \n             and the unit was not reset.')
bwaVLExitTelnet = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cancelOperation", 1), ("exit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLExitTelnet.setStatus('current')
if mibBuilder.loadTexts: bwaVLExitTelnet.setDescription('Applicable to all units.  \n             Exit the management via Telnet program.')
bwaVLUnitPasswords = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 8))
bwaVLReadOnlyPassword = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 8, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLReadOnlyPassword.setStatus('current')
if mibBuilder.loadTexts: bwaVLReadOnlyPassword.setDescription('Applicable to all units. \n             The User (read only) password.\n             This is also the Read Community String.\n             Up to 8 printable ASCII characters.')
bwaVLInstallerPassword = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLInstallerPassword.setStatus('current')
if mibBuilder.loadTexts: bwaVLInstallerPassword.setDescription('Applicable to all units. \n             The Installer password.\n             Up to 8 printable ASCII characters.')
bwaVLAdminPassword = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAdminPassword.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdminPassword.setDescription('Applicable to all units. \n            The Administrator password. Accessible only with SNMP Write \n            Community String (administrator password). \n            Up to 8 printable ASCII characters.')
bwaVLEthernetNegotiationMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("force10MbpsAndHalfDuplex", 1), ("force10MbpsAndFullDuplex", 2), ("force100MbpsAndHalfDuplex", 3), ("force100MbpsAndFullDuplex", 4), ("autoNegotiationMode", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthernetNegotiationMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthernetNegotiationMode.setDescription('Applicable to all units.  \n             The speed/duplex mode of the Ethernet port.')
bwaVLFTPParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10))
bwaVLFTPServerParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1))
bwaVLFTPServerUserName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPServerUserName.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPServerUserName.setDescription('Applicable to all units. \n             The user name to be used for access to the FTP server. \n             Accessible only with SNMP Write Community String \n             (administrator password).')
bwaVLFTPServerPassword = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPServerPassword.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPServerPassword.setDescription('Applicable to all units. \n             The password to be used for access to the FTP server. \n             Accessible only with SNMP Write Community String \n             (administrator password).')
bwaVLFTPClientIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPClientIPAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPClientIPAddress.setDescription('Applicable to all units.  \n             For SW version higher than 4.0 this is read-only. \n             The IP address of the FTP stack in the unit.')
bwaVLFTPServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPServerIpAddress.setDescription('Applicable to all units.  \n             The IP address of the FTP server.')
bwaVLFTPClientMask = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPClientMask.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPClientMask.setDescription('Applicable to all units.  \n             The Mask of the FTP stack in the unit.')
bwaVLFTPGatewayIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPGatewayIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPGatewayIpAddress.setDescription('Applicable to all units.  \n             The FTP Gateway address')
bwaVLFTPSwDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 2))
bwaVLFTPSwFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPSwFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPSwFileName.setDescription('Applicable to all units.  \n             The name of the SW file to be downloaded.')
bwaVLFTPSwSourceDir = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPSwSourceDir.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPSwSourceDir.setDescription('Applicable to all units.  \n             The source directory of the required file in the FTP server.\n             Up to 80 printable ASCII characters.\n             Use dot (.) To clear field')
bwaVLFTPDownloadSwFile = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("downloadFile", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPDownloadSwFile.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPDownloadSwFile.setDescription('Applicable to all units.  \n             Execution  of the SW download operation')
bwaVLConfigurationFileLoading = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 3))
bwaVLConfigurationFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLConfigurationFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLConfigurationFileName.setDescription('Applicable to all units.  \n             The name of the configuration file to be downloaded/uploaded.')
bwaVLOperatorDefaultsFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLOperatorDefaultsFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLOperatorDefaultsFileName.setDescription('Applicable to all units.  \n             The name of the Operator Defaults file to be downloaded/uploaded')
bwaVLFTPConfigurationFileSourceDir = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFTPConfigurationFileSourceDir.setStatus('current')
if mibBuilder.loadTexts: bwaVLFTPConfigurationFileSourceDir.setDescription('Applicable to all units.  \n             The source directory of the required file in the FTP server.\n             Up to 80 printable ASCII characters.\n             Use dot (.) To clear field')
bwaVLExecuteFTPConfigurationFileLoading = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("executeFTPGetConfigurationFile", 1), ("executeFTPPutConfigurationFile", 2), ("executeFTPGetOperatorDefaults", 3), ("executeFTPPutOperatorDefaults", 4), ("cancel", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLExecuteFTPConfigurationFileLoading.setStatus('current')
if mibBuilder.loadTexts: bwaVLExecuteFTPConfigurationFileLoading.setDescription('Applicable to all units.  \n             Execution of the file download/upload operation.')
bwaVLEventLogFileUploading = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 4))
bwaVLEventLogFileName = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEventLogFileName.setStatus('current')
if mibBuilder.loadTexts: bwaVLEventLogFileName.setDescription('Applicable to all units.  \n             The name of the Event Log file to be uploaded.')
bwaVLEventLogDestinationDir = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEventLogDestinationDir.setStatus('current')
if mibBuilder.loadTexts: bwaVLEventLogDestinationDir.setDescription('Applicable to all units.  \n             The destination directory of the event log file.\n             Up to 80 printable ASCII characters.\n             Use dot (.) To clear field.')
bwaVLUploadEventLogFile = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 10, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uploadFile", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUploadEventLogFile.setStatus('current')
if mibBuilder.loadTexts: bwaVLUploadEventLogFile.setDescription('Applicable to all units.  \n             Execution  of the event log upload operation.')
bwaVLLoadingStatus = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inProcess", 1), ("successful", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLLoadingStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLLoadingStatus.setDescription('Applicable to all units.  \n             The status of the last loading operation.')
bwaVLEventLogFileParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 12))
bwaVLEventLogPolicy = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("message", 1), ("warning", 2), ("error", 3), ("fatal", 4), ("logNone", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEventLogPolicy.setStatus('current')
if mibBuilder.loadTexts: bwaVLEventLogPolicy.setDescription('Applicable to all units.  \n              The lowest level event to be registered in the event log.')
bwaVLEraseEventLog = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eraseEventLog", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEraseEventLog.setStatus('current')
if mibBuilder.loadTexts: bwaVLEraseEventLog.setDescription('Applicable to all units.  \n              Erase the event log.')
bwaVLSystemLocation = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 34))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSystemLocation.setStatus('current')
if mibBuilder.loadTexts: bwaVLSystemLocation.setDescription('Applicable to all units.  \n             The unit location.')
bwaVLFeatureUpgrade = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 14))
bwaVLFeatureUpgradeManually = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 14, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFeatureUpgradeManually.setStatus('current')
if mibBuilder.loadTexts: bwaVLFeatureUpgradeManually.setDescription('Applicable to all units.  \n             Upgrade unit to support new feature. Enter your license number \n             (32 to 64 hex digits).')
bwaVLChangeUnitType = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bu", 1), ("rb", 2), ("cancel", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLChangeUnitType.setStatus('current')
if mibBuilder.loadTexts: bwaVLChangeUnitType.setDescription('Applicable RB/BU only.  \n             Change the unit type between BU and RB.')
bwaLighteAPWorkingMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 2, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaLighteAPWorkingMode.setStatus('current')
if mibBuilder.loadTexts: bwaLighteAPWorkingMode.setDescription('Applicable to AU only. \n         \tChange unit running mode: 0 - VL mode 1 - Mixed cell mode')
bwaVLNwMngParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3))
bwaVLAccessToNwMng = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("fromWirelessOnly", 1), ("fromEthernetOnly", 2), ("fromBothWirelessAndEthernet", 3), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAccessToNwMng.setStatus('current')
if mibBuilder.loadTexts: bwaVLAccessToNwMng.setDescription('Applicable to all units.  \n             The port to be used for remote management.')
bwaVLNwMngFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("disable", 1), ("activateOnEthernetPort", 2), ("activateOnWirelessPort", 3), ("activateOnBothWirelessAndEthernet", 4), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLNwMngFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwMngFilter.setDescription('Applicable to all units.  \n             Disables or enable on one of the ports, or on both \n             ports, IP address based filtering of management messages \n             (e.g. SNMP , Telnet , TFTP , DHCP).')
mngIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 3), )
if mibBuilder.loadTexts: mngIpFilterTable.setStatus('current')
if mibBuilder.loadTexts: mngIpFilterTable.setDescription('Applicable to all units.  \n             A Management IP Filter Table of up to 3 IP addresses \n             of devices that are authorized to access the unit \n             for management purposes.')
mngIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 3, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLNwMngIpTableIdx"))
if mibBuilder.loadTexts: mngIpFilterEntry.setStatus('current')
if mibBuilder.loadTexts: mngIpFilterEntry.setDescription('Applicable to all units.  \n             A Management IP Filter Table entry.')
bwaVLNwMngIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 3, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLNwMngIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwMngIpAddress.setDescription('Applicable to all units.  \n             An IP address in the Management IP Filter Table.')
bwaVLNwMngIpTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNwMngIpTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwMngIpTableIdx.setDescription('Applicable to all units.  \n             A table index for an entry in the Management IP Filter \n             Table.')
bwaVLDeleteOneNwIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 10), ValueRangeConstraint(255, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteOneNwIpAddr.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteOneNwIpAddr.setDescription('Applicable to all units.  \n             0 - cancel operation.\n             1..10 - Deletes a single selected entry from the Management IP \n             Filter Table.')
bwaVLDeleteAllNwIpAddrs = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteAllNwIpAddrs.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteAllNwIpAddrs.setDescription('Applicable to all units.  \n             Deletes all entries from the Management IP Filter Table.')
bwaVLAccessToNwTrap = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAccessToNwTrap.setStatus('current')
if mibBuilder.loadTexts: bwaVLAccessToNwTrap.setDescription('Applicable to all units.  \n             Enables or disables sending of traps.')
mngTrapTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 7), )
if mibBuilder.loadTexts: mngTrapTable.setStatus('current')
if mibBuilder.loadTexts: mngTrapTable.setDescription('Applicable to all units.  \n             A Management Trap Table of up to 10 IP addresses of \n             stations to send traps to.')
mngTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 7, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLNwTrapTableIdx"))
if mibBuilder.loadTexts: mngTrapEntry.setStatus('current')
if mibBuilder.loadTexts: mngTrapEntry.setDescription('Applicable to all units.  \n             A Management Trap Table entry.')
bwaVLNwMngTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 7, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLNwMngTrapCommunity.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwMngTrapCommunity.setDescription('Applicable to all units.  \n             The trap community associated with the applicable \n             entry in the Management Trap Table.\n             Up to 14 printable case sensitive ASCII characters.')
bwaVLNwMngTrapAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 7, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLNwMngTrapAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwMngTrapAddress.setDescription('Applicable to all units.  \n             An IP address in the Management Trap Table entry.')
bwaVLNwTrapTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNwTrapTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLNwTrapTableIdx.setDescription('Applicable to all units.  \n             Tables Index for an entry in the Management Trap Table.')
bwaVLDeleteOneTrapAddr = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 10), ValueRangeConstraint(255, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteOneTrapAddr.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteOneTrapAddr.setDescription('Applicable to all units.  \n             0 - cancel operation.\n             1..10 - Deletes a single selected entry from the Management \n             Trap Table.')
bwaVLDeleteAllTrapAddrs = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteAllTrapAddrs.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteAllTrapAddrs.setDescription('Applicable to all units.  \n             Deletes all entries from the Management Trap Table.')
bwaVLMngIpRangesTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10), )
if mibBuilder.loadTexts: bwaVLMngIpRangesTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangesTable.setDescription('Applicable to all units.  \n             Table of Management IP Address Ranges')
bwaVLMngIpRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLMngIpRangeIdx"))
if mibBuilder.loadTexts: bwaVLMngIpRangeEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeEntry.setDescription('Applicable to all units.  \n             A Management IP Address Ranges Table entry')
bwaVLMngIpRangeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMngIpRangeIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeIdx.setDescription('Applicable to all units.  \n             Index of an entry in the Management IP Address Ranges Table')
bwaVLMngIpRangeFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rangeDefinedByStartEndAddr", 1), ("rangeDefinedByStartAddrMask", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMngIpRangeFlag.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeFlag.setDescription('Applicable to all units.  \n             Defines the method of defining the range:\n             Using Start & End Address( rangeDefinedByStartEndAddr ),\n             or using Start Address and Mask ( rangeDefinedByStartAddrSubNetMask ).')
bwaVLMngIpRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMngIpRangeStart.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeStart.setDescription('Applicable to all units.  \n             Start Address of the range')
bwaVLMngIpRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMngIpRangeEnd.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeEnd.setDescription('Applicable to all units.  \n             End Address of the range. \n             Used only if bwaVLMngIpRangeFlag is  rangeDefinedByStartEndAddr')
bwaVLMngIpRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMngIpRangeMask.setStatus('current')
if mibBuilder.loadTexts: bwaVLMngIpRangeMask.setDescription('Applicable to all units.  \n             End Address of the range. \n             Used only if bwaVLMngIpRangeFlag is  rangeDefinedByStartAddrMask')
bwaVLDeleteOneNwIpRange = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 10), ValueRangeConstraint(255, 255), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteOneNwIpRange.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteOneNwIpRange.setDescription('Applicable to all units.  \n             0 - cancel operation.\n             1..10 - Deletes a single selected entry from the Management IP \n             Ranges Table.')
bwaVLDeleteAllNwIpRanges = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteAllNwIpRanges.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteAllNwIpRanges.setDescription('Applicable to all units.  \n             Deletes all entries from the Management IP Ranges Table.')
bwaVLApClientIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 3, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLApClientIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLApClientIpAddress.setDescription('Applicable to SU/RB unit only.  \n             The IP Address of the WIFI WIMAX unit')
bwaVLIpParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4))
bwaVLUnitIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUnitIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitIpAddress.setDescription('Applicable to all units.  \n             IP address of the unit.')
bwaVLSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSubNetMask.setStatus('current')
if mibBuilder.loadTexts: bwaVLSubNetMask.setDescription('Applicable to all units.  \n             Subnet mask of the unit.')
bwaVLDefaultGWAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDefaultGWAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLDefaultGWAddress.setDescription('Applicable to all units.  \n             Default gateway IP address of the unit.')
bwaVLUseDhcp = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("dhcpOnly", 2), ("automatic", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUseDhcp.setStatus('current')
if mibBuilder.loadTexts: bwaVLUseDhcp.setDescription('Applicable to all units.  \n             DHCP client mode of operation. \n             disabled : Use regular (manual) methods to configure IP \n                        parameters. \n             dHCP Only: Use DHCP server to configure IP parameters. \n             automatic: Use DHCP server to configure IP parameters. \n                        If a DHCP server is not available, use \n                        manually configured values.')
bwaVLAccessToDHCP = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fromWirelessOnly", 1), ("fromEthernetOnly", 2), ("fromBothWirelessAndEthernet", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAccessToDHCP.setStatus('current')
if mibBuilder.loadTexts: bwaVLAccessToDHCP.setDescription('Applicable to all units.  \n             The port to be used for communicating with a DHCP server.')
bwaVLRunTimeIPaddr = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunTimeIPaddr.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunTimeIPaddr.setDescription('Applicable to all units.  \n             The run-time IP address. If DHCP is used the Run Time \n             IP Address is the address given to the unit by the \n             server. Otherwise it is the manually configured address.')
bwaVLRunTimeSubNetMask = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunTimeSubNetMask.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunTimeSubNetMask.setDescription('Applicable to all units.  \n             The run-time Subnet Mask. If DHCP is used the Run Time \n             Subnet Mask is the mask given to the unit by the server. \n             Otherwise it is the manually configured mask.')
bwaVLRunTimeDefaultIPGateway = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 4, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunTimeDefaultIPGateway.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunTimeDefaultIPGateway.setDescription('Applicable to all units.  \n             The run-time Gateway IP address. If DHCP is used the \n             Run Time Gateway IP Address is the address given to the \n             unit by the server. Otherwise it is the manually \n             configured address.')
bwaVLBridgeParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5))
bwaVLVLANSupport = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1))
bwaVLVlanID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanID.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanID.setDescription('Applicable to SU/RB only.\n             VLAN ID for data frame tagging. \n             Applicable to Access Link only. \n             Range: 1 to 4094. 0 - not applicable.')
bwaVLEthernetLinkType = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("accessLink", 1), ("trunkLink", 2), ("hybridLink", 3), ("serviceProviderLink", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthernetLinkType.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthernetLinkType.setDescription('Applicable to all units.  \n             VLAN support mode (Link Type). \n             The Access Link option is not available for AU/BU.\n             Service Provider Link is not available for BU/RB.')
bwaVLManagementVlanID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLManagementVlanID.setStatus('current')
if mibBuilder.loadTexts: bwaVLManagementVlanID.setDescription('Applicable to all units.  \n             VLAN ID for management frame tagging.\n             Range: 1 to 4094, 65535 for No VLAN tagging.')
bwaVLVLANForwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4))
bwaVLVlanForwardingSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanForwardingSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanForwardingSupport.setDescription('Applicable to all units.  \n             Enables or disables the VLAN forwarding feature. \n             (applicable in Trunk and Service Provider links only).')
bwaVLVlanForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4, 2), )
if mibBuilder.loadTexts: bwaVLVlanForwardingTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanForwardingTable.setDescription('Applicable to all units.  \n             A VLAN Forwarding Table of up to 20 VLAN IDs of devices \n             to which data frames are forwarded when VLAN Forwarding \n             is Enabled. (applicable in Trunk and Service Provider links only).')
bwaVLVlanForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLVlanForwardingTableIdx"))
if mibBuilder.loadTexts: bwaVLVlanForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanForwardingEntry.setDescription('Applicable to all units.  \n             A VLAN Forwarding Table entry. (applicable in Trunk and Service Provider \n             links only).')
bwaVLVlanForwardingTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLVlanForwardingTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanForwardingTableIdx.setDescription('Applicable to all units.  \n             A read only table index for a VLAN entry in the VLAN \n             Forwarding Table.')
bwaVLVlanIdForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanIdForwarding.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanIdForwarding.setDescription("Applicable to all units.  \n             The list of VLAN ID's in the VLAN ID Forwarding Table. \n             To Remove a VLAN ID - SET the corresponding entry to 0. \n             To Add a new VLAN ID SET an entry which is currently 0.\n             Range : 0 to 4094")
bwaVLVlanRelaying = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5))
bwaVLVlanRelayingSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanRelayingSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanRelayingSupport.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products. \n             Enables or disables VLAN Relaying (applicable in \n             Trunk and Service Provider links only).')
bwaVLVlanRelayingTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5, 2), )
if mibBuilder.loadTexts: bwaVLVlanRelayingTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanRelayingTable.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP products.\n             A VLAN Relaying Table of up to 20 VLAN IDs of devices \n             to which data frames are relayed when VLAN Relaying is \n             Enabled. (applicable in Trunk and Service Provider links only).')
bwaVLVlanRelayingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLVlanRelayingTableIdx"))
if mibBuilder.loadTexts: bwaVLVlanRelayingEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanRelayingEntry.setDescription('Applicable to AU only.\n             Not applicable to BWA-PtP products. \n             A VLAN Relaying Table entry. (applicable in Trunk and Service \n             Provider links only).')
bwaVLVlanRelayingTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLVlanRelayingTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanRelayingTableIdx.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products.\n             A table index for a VLAN entry in the VLAN \n             Relaying Table.')
bwaVLVlanIdRelaying = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 5, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanIdRelaying.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanIdRelaying.setDescription("Applicable to AU only. \n             Not applicable to BWA-PtP products.\n             The list of VLAN ID's in the VLAN ID Relaying Table. \n             To Remove a VLAN ID - SET the corresponding entry to 0. \n             To Add a new VLAN ID SET an entry which is currently 0.\n             Range: 0 to 4094 , 0 - remove entry.")
bwaVLVLANTrafficPriority = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 6))
bwaVLVlanDataPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanDataPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanDataPriority.setDescription('Applicable to SU/RB only. \n             Priority tagging for data frames. Applicable to Access \n             Link only.\n             Range: 0 to 7.')
bwaVLVlanManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanManagementPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanManagementPriority.setDescription('Applicable to all units.  \n             Priority tagging for management frames. Applicable to \n             Access Link and Trunk Link only.\n             Range: 0 to 7.')
bwaVLVlanPriorityThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVlanPriorityThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLVlanPriorityThreshold.setDescription('Applicable to all units. Not applicable to units with SW \n             version 3.1 or higher. \n             Priority threshold for tagged frames received from \n             Ethernet port. Applicable to Hybrid Link and Trunk Link \n             only.\n             Valid values: 0-7.')
bwaVLVLANQinQ = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 7))
bwaVLQinQEthertype = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(33025, 36864), ValueRangeConstraint(37120, 37120), ValueRangeConstraint(37376, 37376), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLQinQEthertype.setStatus('current')
if mibBuilder.loadTexts: bwaVLQinQEthertype.setDescription('Applicable to AU and SU. Not applicable to PtP units. \n            The Ethernet type of the Service Provider Tag.\n            The range is  0x8101(33025) - 0x9000(36864), 0x9100(37120), 0x9200(37376).')
bwaVLQinQProviderVlanID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLQinQProviderVlanID.setStatus('current')
if mibBuilder.loadTexts: bwaVLQinQProviderVlanID.setDescription('Applicable to SU only.\n            VLAN ID of the Service Provider Tag.')
bwaVLBridgeAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBridgeAgingTime.setStatus('current')
if mibBuilder.loadTexts: bwaVLBridgeAgingTime.setDescription('Applicable to all units.  \n             Bridge aging time for devices on both the Ethernet and \n             wireless link sides. \n             Range: 20 to 2000 seconds.')
bwaVLBroadcastRelaying = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("disable", 1), ("broadcastMulticastEnable", 2), ("broadcastEnable", 3), ("multicastEnable", 4), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBroadcastRelaying.setStatus('current')
if mibBuilder.loadTexts: bwaVLBroadcastRelaying.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products.\n             Enables/disables the relaying of broadcast messages to \n             the wireless link.')
bwaVLUnicastRelaying = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUnicastRelaying.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnicastRelaying.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products.\n             Enables/disables the relaying of unicast messages to \n             the wireless link.')
bwaVLEthBroadcastFiltering = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("disable", 1), ("onEthernetOnly", 2), ("onWirelessOnly", 3), ("onBothWirelessAndEthernet", 4), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthBroadcastFiltering.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastFiltering.setDescription('Applicable to SU/RB only. \n             Enables/disables the filtering of Ethernet (layer2) \n             broadcasts.    \n             disable             : No filtering.    \n             onEthernetOnly      : Filters broadcasts received on the Ethernet port only.    \n             onWirelessOnly      : Filters broadcasts received on the Wlan port only.    \n             onBothWirelessAndEth: Filters broadcasts received on both ports.')
bwaVLEthBroadcastingParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7))
bwaVLDHCPBroadcastOverrideFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDHCPBroadcastOverrideFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLDHCPBroadcastOverrideFilter.setDescription('Applicable to SU/RB only. \n             Enables or disables the broadcasting of DHCP messages, \n             overriding the general *bwaVLEthBroadcastFiltering Ethernet \n             broadcast filtering option.')
bwaVLPPPoEBroadcastOverrideFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLPPPoEBroadcastOverrideFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLPPPoEBroadcastOverrideFilter.setDescription('Applicable to SU/RB only. \n             Enables or disables the broadcasting of PPPoE messages, \n             overriding the general *bwaVLEthBroadcastFiltering Ethernet \n             broadcast filtering option.')
bwaVLARPBroadcastOverrideFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLARPBroadcastOverrideFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLARPBroadcastOverrideFilter.setDescription('Applicable to SU/RB only. \n             Enables or disables the broadcasting of ARP messages, \n             overriding the general *bwaVLEthBroadcastFiltering Ethernet \n             broadcast filtering option.')
bwaVLEthBroadcastMulticastLimiterOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("limitOnlyBroadcasts", 2), ("limitMulticastsExceptBroadcasts", 3), ("limitAllMulticasts", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterOption.setDescription('Applicable to all units.\n            Enable/disable the limiter for multicast and broadcast packets.')
bwaVLEthBroadcastMulticastLimiterThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterThreshold.setDescription('Applicable to all units.\n            The limit on the number of multicast and broadcast packets when the \n            Ethernet Broadcast/Multicast Limiter Option is enabled.\n            Range: 0 to 204800')
bwaVLEthBroadcastMulticastLimiterSendTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 7, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterSendTrapInterval.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticastLimiterSendTrapInterval.setDescription('Applicable to all units.\n            The minimum time between two successive traps that are sent indicating the \n            number of packets that were dropped by the Ethernet Broadcast/Multicast \n            Limiter since the last trap was sent.\n            Range: 1 to 60 minutes')
bwaVLToSPriorityParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 8))
bwaVLToSPrecedenceThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 8, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLToSPrecedenceThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLToSPrecedenceThreshold.setDescription('Applicable to all units. Not applicable to units with SW version 3.1 or higher.\n             Priority threshold (based on the ToS) for frames received \n             from the Ethernet port.\n             Range: 0 to 7.')
bwaVLRoamingOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLRoamingOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLRoamingOption.setDescription('Applicable to SU/RB only.\n             Disable/enable the roaming feature. When enabled, the SU/RB will start \n             scanning for an AU/BU after about one second of not receiving beacons or data \n             from current AU/BU. Once it found a new AU/BU, it will also send through \n             the wireless network a roaming SNAP on behalf of its clients informing \n             other devices in the network of their new location. When disabled, it \n             will wait for about seven seconds before starting scanning, and it will not \n             send a roaming SNAP.')
bwaVLMacAddressDenyList = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10))
bwaVLMacAddressDenyListTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 1), )
if mibBuilder.loadTexts: bwaVLMacAddressDenyListTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListTable.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP units.                                   \n             A list of up to 100 MAC Addresses of SUs.\n             If bwaVLMacAddressDenyListAction is set to denyList, \n             these are SUs that are not allowed to transfer data \n             to the AU. \n             If bwaVLMacAddressDenyListAction is set to allowList, \n             only these SUs are allowed to transfer data to the AU.')
bwaVLMacAddressDenyListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 1, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLMacAddressDenyListTableIdx"))
if mibBuilder.loadTexts: bwaVLMacAddressDenyListEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListEntry.setDescription('Applicable to AU only.\n\t\t\t Not applicable to BWA-PtP units.                                   \n             An entry in the Mac Address Deny List Table.')
bwaVLMacAddressDenyListTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMacAddressDenyListTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListTableIdx.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP units.                                   \n             A read only table index for a MAC Address entry \n             in the Mac Address Deny List Table. Range: 1 to 100.')
bwaVLMacAddressDenyListId = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 1, 1, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMacAddressDenyListId.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListId.setDescription('Applicable to AU only.\n\t\t\t Not applicable to BWA-PtP units.                                   \n             The list of MAC Addresses in the Mac Address Deny \n             List Table. \n             To Remove a MAC Address - SET the corresponding entry \n             to 0. \n             To Add a new MAC Address - SET an entry which is \n             currently 0.')
bwaVLMacAddressDenyListAdd = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMacAddressDenyListAdd.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListAdd.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP units.                                   \n             Add a MAC address to the MAC Address Deny List Table')
bwaVLMacAddressDenyListRemove = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMacAddressDenyListRemove.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListRemove.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP units.                                   \n             Delete a MAC address from the MAC Address Deny List Table')
bwaVLNumberOfMacAddressesInDenyList = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNumberOfMacAddressesInDenyList.setStatus('current')
if mibBuilder.loadTexts: bwaVLNumberOfMacAddressesInDenyList.setDescription('Applicable to AU only. \n\t\t\t Not applicable to BWA-PtP units.                                   \n             Number of MAC addresses in the MAC Address Deny List Table.')
bwaVLMacAddressDenyListAction = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("denyList", 1), ("allowedList", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMacAddressDenyListAction.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacAddressDenyListAction.setDescription('Applicable to AU only.        \n            Define the action to be used by the Mac Address Deny List.\n            allowedList(2) means that the list becomes Allow list.')
bwaVLPortsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 11))
bwaVLEthernetPortControl = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 5, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLEthernetPortControl.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthernetPortControl.setDescription('Applicable to SU/RB only.\n             Enable/disable the Ethernet port. When disabled, only \n             data frames are blocked. Management frames are accepted.')
bwaVLAirInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6))
bwaVLESSIDParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 1))
bwaVLESSID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLESSID.setStatus('current')
if mibBuilder.loadTexts: bwaVLESSID.setDescription('Applicable to all units. \n             The Extended Service Set ID (ESSID) used to prevent \n             the merging of collocated systems.\n             The ESSID is accessible only with the write community \n             string (administrator password).\n             Up to 31 printable case sensitive ASCII characters.')
bwaVLOperatorESSIDOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLOperatorESSIDOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLOperatorESSIDOption.setDescription('Applicable to AU/BU only. \n             Enabling/disabling the use of the Operator ESSID.')
bwaVLOperatorESSID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLOperatorESSID.setStatus('current')
if mibBuilder.loadTexts: bwaVLOperatorESSID.setDescription('Applicable to AU/BU only.\n             A secondary ESSID to support easy installation of SUs as well as\n             the use of the Best AU/BU feature.\n             Accessible only with SNMP Write Community \n             Up to 31 printable case sensitive ASCII characters.')
bwaVLRunTimeESSID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(31, 31)).setFixedLength(31)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRunTimeESSID.setStatus('current')
if mibBuilder.loadTexts: bwaVLRunTimeESSID.setDescription('Applicable to SU/RB only. \n\t\t     The ESSID of the associated AU/BU.\n\t\t     Accessible only with SNMP Write Community.\n\t\t     Up to 31 printable ASCII characters, case sensitive.')
bwaVLMaximumCellRadius = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaximumCellRadius.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumCellRadius.setDescription('Applicable to all units.  \n             For AU/BU: read-write. In units with SW version 2.0 and up -\n             applicable only when the Cell Distance Mode is set to Manual. \n             The highest distance from the AU/BU of any SU/RB served by it. \n             Affects the maximum time the units wait for a response message \n             and the slot size by taking into account the round trip propagation delay. \n             For SU/RB: read-only. The distance is learned from the AU/BU. \n             Range: For units below version 2.0 the range is 0 - 50000 Meters. \n             Otherwise - the range is 0 to 54 Kilometers.\n             0 means no compensation (minimum slot size, maximal delay timeout).')
bwaVLAIFS = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("oneSlot", 1), ("twoSlots", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAIFS.setStatus('current')
if mibBuilder.loadTexts: bwaVLAIFS.setDescription('Applicable to AU and SU. Not applicable to BWA-PtP products.\n             Not applicable if Wireless Link Prioritization is enabled.\n             Arbitration Inter-Frame Spacing (AIFS) value, in slots. \n             This is the number of time slots that define the DIFS. (DIFS=SIFS+AIFS). \n             A value of 1 should be used only in point-to-point applications to \n             allow one unit to have advantage over the other unit.')
bwaVLWirelessTrapThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLWirelessTrapThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLWirelessTrapThreshold.setDescription('Applicable to AU/BU only.\n\t     A wireless link quality threshold, expressed in % of retransmissions,\n\t     for sending the bwaVLAUWirelessQualityTRAP.   \n\t     This trap indicate whether the quality has gone below or \n\t     above the specified threshold.\n\t     The Threshold Range: 1 to 100 (%  retransmissions).')
bwaVLTransmitPowerTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5), )
if mibBuilder.loadTexts: bwaVLTransmitPowerTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLTransmitPowerTable.setDescription('Applicable to all units.\n             A table of transmit power parameters. ')
bwaVLTransmitPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLTransmitPowerIdx"))
if mibBuilder.loadTexts: bwaVLTransmitPowerEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLTransmitPowerEntry.setDescription('Applicable to all units. \n             An entry in the Transmit Power Table.')
bwaVLTransmitPowerIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTransmitPowerIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLTransmitPowerIdx.setDescription('Applicable to all units.\n             An index of an entry in the Transmit Power Table.')
bwaVLApplicableModulationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("level1to5", 1), ("level6", 2), ("level7", 3), ("level8", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLApplicableModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLApplicableModulationLevel.setDescription('Applicable to all units.\n             The applicable modulation level for an entry in the Transmit Power Table.\n              Level 8 is not applicable to units with HW revision A.')
bwaVLMaximumTxPowerRange = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaximumTxPowerRange.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumTxPowerRange.setDescription('Applicable to all units.\n             The allowed range for the bwaVLTxPower parameter at the \n             applicable modulation level . Range: -10 to the maximum allowed \n             power level at the applicable modulation level , in dBm.')
bwaVLTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTxPower.setStatus('current')
if mibBuilder.loadTexts: bwaVLTxPower.setDescription('Applicable to all units.\n             Read-only for units with SW version 4.0 and higher.\n\t\t\t In AU/BU: The transmit power in dBm defined for the applicable rate.\n\t\t\t In SU/RB: If ATPC is disabled, this is the transmit power in dBm \n\t\t\t defined for the applicable rate.\n\t\t\t If ATPC is enabled, it serves as the initial transmit power in dBm \n\t\t\t for the ATPC algorithm. \n\t\t\t In SU/RB: The range is -10 dBm to the power value defined by \n\t\t\t           bwaVLMaximumTxPower for the applicable modulation level.\n\t\t\t In AU/BU: The range is -10 dBm to the power value defined by \n\t\t\t           bwaVLMaximumTxPowerRange for the applicable modulation level.')
bwaVLCurrentTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentTxPower.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentTxPower.setDescription('Applicable to SU/RB.\n             The actual transmit power in dBm for the applicable rate.\n             Range: -17 to the maximum value defined by bwaVLMaximumTxPowerRange \n             for the applicable modulation level.')
bwaVLMaximumTransmitPowerTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6), )
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerTable.setDescription('Applicable to SU/RB only.\n             A table of maximum transmit power parameters. ')
bwaVLMaximumTransmitPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLMaximumTransmitPowerIdx"))
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerEntry.setDescription('Applicable to SU/RB only. \n             An entry in the Maximum Transmit Power Table.')
bwaVLMaximumTransmitPowerIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumTransmitPowerIdx.setDescription('Applicable to SU/RB only.\n             An index of an entry in the Maximum Transmit Power Table.')
bwaVLMaxTxApplicableModulationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("level1to5", 1), ("level6", 2), ("level7", 3), ("level8", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaxTxApplicableModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxTxApplicableModulationLevel.setDescription('Applicable to SU/RB only.\n             The applicable modulation level for an entry in the Maximum \n              Transmit Power Table.\n              Level 8 is not applicable to units with HW revision A.')
bwaVLDefinedMaximumTxPowerRange = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDefinedMaximumTxPowerRange.setStatus('current')
if mibBuilder.loadTexts: bwaVLDefinedMaximumTxPowerRange.setDescription('Applicable to SU/RB only.\n             The allowed range for the bwaVLMaxTxPower parameter at the \n             applicable modulation level .\n             Range: -10 to the maximum allowed power level at the applicable \n             modulation level , in dBm.')
bwaVLMaxTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 6, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaxTxPower.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxTxPower.setDescription('Applicable to SU/RB only.\n            Read-only for units with SW version 4.0 and higher.\n\t\t\tThe maximum value that can be configured for the bwaVLTxPower \n\t\t\tparameter. This is also the maximum power level that can be reached \n\t\t\tby the ATPC algorithm.\n\t\t\tThe range is -10 dBm to the maximum value defined by \n\t\t\tbwaVLDefinedMaximumTxPowerRange for the applicable modulation level.')
bwaVLMaxNumOfAssociations = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaxNumOfAssociations.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxNumOfAssociations.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products.\n             Sets the upper limit for the number of SUs \n             that can be associated with the AU.\n             Range: For regular AUs (AU-BS, AU-SA) \n             the range is from 0 to 512 if encryption is disabled\n             the range id form 0 to 124 if encryption is enabled\n             For AUS-BS and AUS-SA with SW version 4.0 and higher \n             the range is between 0 to 8 or 25 (via licensing).\n             For AUS-BS and AUS-SA with SW version below 4.0             the range \n             is between 0 to 5.  \n             BWA-PtP products return 65535.')
bwaVLBestAu = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11))
bwaVLBestAuSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBestAuSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLBestAuSupport.setDescription('Applicable to SU/RB only. \n             Disable/enable the Best AU/BU selection mechanism.')
bwaVLBestAuNoOfScanningAttempts = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBestAuNoOfScanningAttempts.setStatus('current')
if mibBuilder.loadTexts: bwaVLBestAuNoOfScanningAttempts.setDescription('Applicable to SU/RB only. \n             The number of scanning attempts to collect information \n             for the Best AU/BU decision.\n             Range: 1 to 255.')
bwaVLPreferredAuMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLPreferredAuMacAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLPreferredAuMacAddress.setDescription('Applicable to SU/RB only.\n             The MAC address of the preferred AU/BU (overriding the \n             Best AU/BU selection process). \n             000000000000 means no preferred AU/BU.')
bwaVLNeighborAuTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4), )
if mibBuilder.loadTexts: bwaVLNeighborAuTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuTable.setDescription('Applicable to SU/RB only. \n             A table of data on neighboring AUs/BUs.')
bwaVLNeighborAuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLNeighborAuIdx"))
if mibBuilder.loadTexts: bwaVLNeighborAuEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuEntry.setDescription('Applicable to SU/RB only. \n             An entry in the Neighbor AU/BU Table.')
bwaVLNeighborAuIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuIdx.setDescription('Applicable to SU/RB only. \n             An index of an entry in the Neighbor AU/BU Table.')
bwaVLNeighborAuMacAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuMacAdd.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuMacAdd.setDescription('Applicable to SU/RB only. \n             A MAC address of an AU/BU in the Neighbor AU/BU Table.')
bwaVLNeighborAuESSID = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuESSID.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuESSID.setDescription('Applicable to SU/RB only.  \n             The ESSID of an AU/BU in the Neighbor AU/BU Table.\n             Accessible only with SNMP Write Community.')
bwaVLNeighborAuSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuSNR.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuSNR.setDescription('Applicable to SU/RB only. \n             The received signal quality (SNR) in dB of an AU/BU \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuAssocLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("full", 1), ("notFull", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuAssocLoadStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuAssocLoadStatus.setDescription('Applicable to SU/RB only. \n             Neighbor AU/BU association load status in the Neighbor \n             AU/BU Table.')
bwaVLNeighborAuMark = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuMark.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuMark.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU mark in the Neighbor AU/BU Table.')
bwaVLNeighborAuHwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("hwRevisionA", 1), ("hwRevisionB", 2), ("hwRevisionC", 3), ("hwRevisionD", 4), ("hwRevisionE", 5), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuHwRevision.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuHwRevision.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU HW revision in the Neighbor AU/BU Table.')
bwaVLNeighborAuCountryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuCountryCode.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuCountryCode.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU supported country code in the Neighbor \n             AU/BU Table.')
bwaVLNeighborAuSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuSwVer.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuSwVer.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU SW version in the Neighbor \n             AU/BU Table.')
bwaVLNeighborAuAtpcOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuAtpcOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuAtpcOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU ATPC option configuration in the Neighbor \n             AU/BU Table.')
bwaVLNeighborAuAdapModOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuAdapModOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuAdapModOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU adaptive modulation option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuBurstModeOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuBurstModeOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuBurstModeOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU burst mode option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuDfsOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuDfsOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuDfsOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU DFS option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuConcatenationOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuConcatenationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuConcatenationOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU concatenation option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuLearnCountryCodeBySU = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuLearnCountryCodeBySU.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuLearnCountryCodeBySU.setDescription('Applicable to SU only.\n             Starting with 4.0 is not applicable for BWA 4900 and BWA PtP products.\n             Neighbor AU Learn Country Code by SU configuration \n             in the Neighbor AU Table.')
bwaVLNeighborAuSecurityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("wep", 1), ("aesOCB", 2), ("fips197", 3), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuSecurityMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuSecurityMode.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU security mode configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuAuthOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("openSystem", 1), ("sharedKey", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuAuthOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuAuthOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU authentication option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuDataEncyptOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuDataEncyptOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuDataEncyptOption.setDescription('Applicable to SU/RB only.\n             Neighbor AU/BU data encryption option configuration \n             in the Neighbor AU/BU Table.')
bwaVLNeighborAuPerSuDistanceLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 11, 4, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNeighborAuPerSuDistanceLearning.setStatus('current')
if mibBuilder.loadTexts: bwaVLNeighborAuPerSuDistanceLearning.setDescription('Applicable to SU only.\n             Neighbor AU per SU distance learning option configuration \n             in the Neighbor AU Table.')
bwaVLFrequencyDefinition = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12))
bwaVLSubBandLowerFrequency = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSubBandLowerFrequency.setStatus('obsolete')
if mibBuilder.loadTexts: bwaVLSubBandLowerFrequency.setDescription('Applicable to SU only. \n\t\t     Not applicable to units with SW version 2.0 or higher. \n             The lowest frequency in the subset to be used for scanning.\n             For 5.8GHz products the range is 5740 to 5830 MHz using 10MHz resolution.\n             For 4.9GHz products the range is 4920 to 5080 MHz using 10MHz resolution.\n             For HW Revision C and above this leaf is not relevant - shall return 0.')
bwaVLSubBandUpperFrequency = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSubBandUpperFrequency.setStatus('obsolete')
if mibBuilder.loadTexts: bwaVLSubBandUpperFrequency.setDescription('Applicable to SU only. \n             Not applicable to units with SW version 2.0 or higher. \n             The highest frequency in the subset to be used for scanning.\n             For 5.8GHz products the range is 5740 to 5830 MHz using 10MHz resolution.\n             For 4.9GHz products the range is 4920 to 5080 MHz using 10MHz resolution.\n             For HW Revision C and above this leaf is not relevant - shall return 0.')
bwaVLScanningStep = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("mhz-5", 1), ("mhz-10", 2), ("mhz-20", 3), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLScanningStep.setStatus('current')
if mibBuilder.loadTexts: bwaVLScanningStep.setDescription('Applicable to all units - For flexible Sub-Bands only.\t\t\n             For units with version 2.0 and above this is a read-only parameter.\n             The scanning step to be used for generating the frequency subset.')
bwaVLFrequencySubsetTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4), )
if mibBuilder.loadTexts: bwaVLFrequencySubsetTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetTable.setDescription('Applicable to SU/RB and to AU/BU.\n             Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The Frequency Subset Table that includes all frequencies from \n\t\t\t the selected Sub-band.')
bwaVLFrequencySubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLFrequencySubsetTableIdx"))
if mibBuilder.loadTexts: bwaVLFrequencySubsetEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetEntry.setDescription('Applicable to SU/RB and to AU/BU.\n             Not applicable to SU/RB with SW version 4.0 and higher.\n             An entry in the Frequency Subset Table. ')
bwaVLFrequencySubsetTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFrequencySubsetTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetTableIdx.setDescription('Applicable to SU/RB and to AU/BU.\n             Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t An index of an entry in the Frequency subset Table.')
bwaVLFrequencySubsetFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFrequencySubsetFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetFrequency.setDescription('Applicable to SU/RB and to AU/BU. \n             Not applicable to SU/RB with SW version 4.0 and higher.\n             Applicable to all units with HW revision B and lower \n             (for units with HW revision C and higher replaced by \n             bwaVLFrequencySubsetFrequencyNew to support a \n             resolution of 0.5 MHz).  \n             The frequency in MHz of an entry in the Frequency Subset table.')
bwaVLFrequencySubsetActive = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFrequencySubsetActive.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetActive.setDescription('Applicable to SU/RB and to AU/BU.\n             Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The status of an entry in the Frequency subset Table.\n\t\t\t The frequency of an active entry will be included in the \n\t\t\t final list of frequencies to be used for scanning.')
bwaVLFrequencySubsetFrequencyNew = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFrequencySubsetFrequencyNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLFrequencySubsetFrequencyNew.setDescription('Applicable to all units. \n             Not applicable to SU/RB with SW version 4.0 and higher.\n             The frequency in MHz of an entry in the Frequency Subset table. \n             (Replaces bwaVLFrequencySubsetFrequency to support a resolution \n             of 0.5 MHz for units with HW revision C and higher).')
bwaVLSetSelectedFreqSubset = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("setSelectedFreqsSubset", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSetSelectedFreqSubset.setStatus('current')
if mibBuilder.loadTexts: bwaVLSetSelectedFreqSubset.setDescription('Applicable to SU/RB and to AU/BU.\n             Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t Apply the selected subset.\n\t\t\t After the next reset the new subset will be used.')
bwaVLCurrentFrequencySubsetTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 6), )
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetTable.setDescription('Applicable to SU/RB and to AU/BU.\n\t\t\t Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The Current Frequency Subset table. In SU/RB it includes all \n\t\t\t frequencies that are currently used for scanning.\n\t\t\t In AU/BU it includes all frequencies that can be used by the \n\t\t\t DFS mechanism (if applicable)')
bwaVLCurrentFrequencySubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 6, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLCurrentFrequencySubsetTableIdx"))
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetEntry.setDescription('Applicable to SU/RB and to AU/BU.\n             An entry in the Current Frequency Subset Table. ')
bwaVLCurrentFrequencySubsetTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetTableIdx.setDescription('Applicable to SU/RB and to AU/BU.\n\t\t\t An index of an entry in the Current Frequency subset Table.\n\t\t\t Not applicable to SU/RB with SW version 4.0 and higher.')
bwaVLCurrentFrequencySubsetFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetFrequency.setDescription('Applicable to all units. \n\t\t\t Not applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t Applicable to all units with HW revision B and lower \n\t\t\t (for units with HW revision C and higher replaced by \n\t\t\t bwaVLCurrentFrequencySubsetFrequencyNew to support \n\t\t\t a resolution of 0.5 MHz). \n\t\t\t The frequency in MHz of an entry in the Current Frequency Subset table.')
bwaVLCurrentFrequencySubsetFrequencyNew = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 6, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetFrequencyNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentFrequencySubsetFrequencyNew.setDescription('Applicable to all units. Not applicable to SU/RB with SW version 4.0 and higher. \n             The frequency in MHz of an entry in the Current Frequency Subset table. \n             (Replaces bwaVLCurrentFrequencySubsetFrequency to support a \n             resolution of 0.5 MHz for units with HW revision C and higher).')
bwaVLCurrentAUOperatingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentAUOperatingFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentAUOperatingFrequency.setDescription('Applicable to AU/BU with HW revision B and lower \n\t\t     (for units with HW revision C and higher replaced by \n\t\t     bwaVLCurrentUOperatingFrequencyNew to support a resolution \n\t\t     of 0.5 MHz). \n\t\t     The operating frequency in MHz. \n\t\t     For 5.8GHz products with SW version below 2.0 the range is \n\t\t     5740 to 5830 MHz using 10MHz resolution. \n\t\t     For units with SW version 2.0 and up the range is as defined \n\t\t     in the selected Sub Band.')
bwaVLCurrentAUOperatingFrequencyNew = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentAUOperatingFrequencyNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentAUOperatingFrequencyNew.setDescription('Applicable to AU/BU. The operating frequency in MHz. \n             (Replaces bwaVLCurrentAUOperatingFrequency to support \n             a resolution of 0.5 MHz for units with HW revision C and higher). \n             For 5.8GHz products with SW version below 2.0 the range is \n             5740 to 5830 MHz using 10MHz resolution. \n             For units with SW version 2.0 and up the range is as defined \n             in the selected Sub Band.')
bwaVLAUDefinedFrequency = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUDefinedFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUDefinedFrequency.setDescription('Applicable to AU/BU with HW revision B and lower \n             (for units with HW revision C and higher replaced by \n             bwaVLAUDefinedFrequencyNew to support a resolution of 0.5 MHz). \n             For 5.8GHz products with SW version below 2.0 this is the frequency \n             in MHz of the AU/BU after the next reset. \n             For units with SW version 2.0 and up this is the frequency in MHz \n             to use when the DFS Option is disabled. \n             For 5.8GHz products with SW version below 2.0 the range is \n             5740 to 5830 MHz using 10MHz resolution. \n             For units with SW version 2.0 and up the range is as defined \n             in the selected Sub Band.')
bwaVLAUDefinedFrequencyNew = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUDefinedFrequencyNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUDefinedFrequencyNew.setDescription('Applicable to AU/BU. \n             For 5.8GHz products with SW version below 2.0 this is the \n             frequency in MHz of the AU/BU after the next reset. \n             For units with SW version 2.0 and up this is the \n             frequency in MHz to use when the DFS Option is disabled. \n             (Replaces bwaVLAUDefinedFrequency to support a resolution \n             of 0.5 MHz for units with HW revision C and higher). \n             For 5.8GHz products with SW version below 2.0 the range \n             is 5740 to 5830 MHz using 10MHz resolution. \n             For units with SW version 2.0 and up the range is as \n             defined in the selected Sub Band.')
bwaVLCurrentSUOperatingFrequency = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCurrentSUOperatingFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLCurrentSUOperatingFrequency.setDescription('Applicable to SU/RB only.\n\t\t\t The frequency used currently by the unit.\n\t\t\t For 5.8GHz products with SW version below 2.0 the range is \n\t\t\t 5740 to 5830 MHz using 10MHz resolution.\n             For units with SW version 2.0 and up the range is as defined \n             in the selected Sub Band.')
bwaVLSubBandSelect = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 10))
bwaVLSelectSubBandIndex = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 10, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSelectSubBandIndex.setStatus('current')
if mibBuilder.loadTexts: bwaVLSelectSubBandIndex.setDescription('Applicable to all units with SW version below 4.0 \n            For units with SW version 4.0 and up it is applicable \n            only for AU/BU. For SU/RB it defines only the sub-band \n            for the Spectrum Analyzer.\n             The ID of the sub-band used by the unit.')
bwaVLDFSParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11))
bwaVLDFSOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSOption.setDescription('Applicable to AU/BU only.\n             Enabling/disabling the DFS Algorithm. \n             Not applicable if DFS Option is not supported by the current Sub Band.')
bwaVLDFSChannelCheckTime = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSChannelCheckTime.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelCheckTime.setDescription('Applicable to AU/BU only. \n             Defines the time the unit checks the channel for presence of \n             radar signals and does not transmit after power up or association \n             or after moving to a new channel due to detecting radar in the used \n             channel. Range: 1 to 3600 (seconds).')
bwaVLDFSChannelAvoidancePeriod = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSChannelAvoidancePeriod.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelAvoidancePeriod.setDescription('Applicable to AU/BU only. \n             Defines the time after detecting radar signals in a channel of \n             avoiding using the channel or adjacent channels in \n             accordance with the bandwidth. Range: 1 to 60 (minutes).')
bwaVLDFSSuWaitingOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSSuWaitingOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSSuWaitingOption.setDescription('Applicable to AU/BU only. \n            Defines whether the associated SUs should wait for this AU/BU \n            after it stopped transmitting due to radar detection, before \n            they starts scanning for other AUs/BUs.')
bwaVLDFSClearRadarDetectedChannelsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("cancel", 1), ("clearRadarChannels", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSClearRadarDetectedChannelsAfterReset.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSClearRadarDetectedChannelsAfterReset.setDescription('Applicable to AU/BU only. \n             Clear Radar Detected and Adjacent to Radar channels after unit reset.\n             Returns the unit to operate in default frequency.')
bwaVLDFSRadarDetectionChannelsTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7), )
if mibBuilder.loadTexts: bwaVLDFSRadarDetectionChannelsTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSRadarDetectionChannelsTable.setDescription('Applicable to AU/BU only. \n             Applicable only when DFS option is on.\n             Displays the current channels defined in the sub-band and their radar \n             detection status.')
bwaVLDFSRadarDetectionChannelsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLDFSChannelIdx"))
if mibBuilder.loadTexts: bwaVLDFSRadarDetectionChannelsEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSRadarDetectionChannelsEntry.setDescription('Applicable to AU/BU only. \n\t         An entry in the bwaVLDFSRadarDetectionChannelsTable.')
bwaVLDFSChannelIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSChannelIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelIdx.setDescription('Applicable to AU/BU only. Read-only. \n             The index of the entry in the \n             bwaVLDFSRadarDetectionChannelsTable.')
bwaVLDFSChannelFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSChannelFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelFrequency.setDescription('Applicable to AU/BU with HW revision B and lower \n\t\t\t (for units with HW revision C and higher replaced by \n\t\t\t bwaVLDFSChannelFrequency New to support a resolution \n\t\t\t of 0.5 MHz). \n\t\t\t The frequency in MHz of a channel in the DFS Radar \n\t\t\t Detection Channels Table.')
bwaVLDFSChannelRadarStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("radarFree", 1), ("adjacentToRadar", 2), ("radarDetected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSChannelRadarStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelRadarStatus.setDescription('Applicable to AU/BU only.  \n             The radar detection status of a channel in \n             bwaVLDFSRadarDetectionChannelTable.')
bwaVLDFSChannelFrequencyNew = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 7, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSChannelFrequencyNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelFrequencyNew.setDescription('Applicable to AU/BU. The frequency of a channel in the \n\t\t\t DFS Radar Detection Channels Table. \n\t\t\t (Replaces bwaVLDFSChannelFrequency to support a \n\t\t\t resolution of 0.5 MHz for units with HW revision C and higher).')
bwaVLDFSMinimumPulsesToDetect = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSMinimumPulsesToDetect.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSMinimumPulsesToDetect.setDescription('Applicable to AU/BU only. \n             Defines the minimum number of pulses to detect a radar. \n             Range: 1 - 100.')
bwaVLDFSChannelReuseParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 9))
bwaVLDFSChannelReuseOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSChannelReuseOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSChannelReuseOption.setDescription('Applicable to AU/BU only.\n             Enabling/disabling the DFS Channel Reuse Algorithm. \n             Not applicable if DFS Option is not supported by the current Sub Band.')
bwaVLDFSRadarActivityAssessmentPeriod = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSRadarActivityAssessmentPeriod.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSRadarActivityAssessmentPeriod.setDescription('Applicable to AU/BU only. \n             Range: 1 to 12 (Houres).')
bwaVLDFSMaximumNumberOfDetectionsInAssessmentPeriod = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 11, 9, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDFSMaximumNumberOfDetectionsInAssessmentPeriod.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSMaximumNumberOfDetectionsInAssessmentPeriod.setDescription('Applicable to AU/BU only. \n             Range: 1 to 10 (Times).')
bwaVLCountryCodeLearningBySU = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLCountryCodeLearningBySU.setStatus('current')
if mibBuilder.loadTexts: bwaVLCountryCodeLearningBySU.setDescription('Applicable to AU only. \n             Starting with 4.0 it is nor applicable for BWA 4900 and BWA PtP.\n             Defines whether the SUs learn the country code of the AU.')
bwaVLAutoSubBandSelect = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15))
bwaVLAutoSubBandSelectedFreqSubset = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("setAllSelectedFreqsSubset", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAutoSubBandSelectedFreqSubset.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandSelectedFreqSubset.setDescription('Applicable to SU/RB with SW version 4.0 and higher.        \n\t\t\t Apply the selected subset. After the next reset the new \n\t\t\t subset will be used for scanning.')
bwaVLAutoSubBandFrequencySubsetTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2), )
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetTable.setDescription('Applicable to SU/RB with SW version 4.0 and higher. \n            The Frequency Subset Table that includes all available \n            sub-bands and all the frequencies in these sub-bands.')
bwaVLAutoSubBandFrequencySubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLAutoSubBandFrequencySubsetBandIdx"), (0, "BWA-DOT11-WLAN-MIB", "bwaVLAutoSubBandFrequencySubsetFrequencyIdx"))
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetEntry.setDescription('Applicable to SU/RB with SW version 4.0 and higher.\n             An entry in the Frequency Subset Table. ')
bwaVLAutoSubBandFrequencySubsetBandIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetBandIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetBandIdx.setDescription('Applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The index of the applicable Sub Band. \n\t\t\t This is the Sub Band ID of the relevant entry in \n\t\t\t the Country Dependent Parameters table.\n\t\t\t Serves also as an index of the entry in the \n\t\t\t Frequency subset Table.')
bwaVLAutoSubBandFrequencySubsetFrequencyIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetFrequencyIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetFrequencyIdx.setDescription('Applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The index of the applicable frequency in the \n\t\t\t applicable Sub Band.  \n\t\t\t Serves also as an index of the entry in the \n\t\t\t Frequency subset Table.')
bwaVLAutoSubBandFrequencySubsetActive = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("notActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetActive.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetActive.setDescription('Applicable to SU/RB with SW version 4.0 and higher.\n\t\t\t The status of an entry in the Auto Sub Band Frequency subset Table.\n\t\t\t The frequency of an active entry will be included in the \n\t\t\t final list of frequencies to be used for scanning.')
bwaVLAutoSubBandFrequencySubsetFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 12, 15, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetFrequency.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutoSubBandFrequencySubsetFrequency.setDescription('Applicable to SU/RB with SW version 4.0 and higher. \n             The frequency in MHz of the entry in the Auto Sub Band Frequency Subset table.')
bwaVLATPC = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13))
bwaVLAtpcOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAtpcOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAtpcOption.setDescription('Applicable all units.\n             Enabling/disabling the ATPC Algorithm.')
bwaVLDeltaFromMinSNRLevel = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeltaFromMinSNRLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeltaFromMinSNRLevel.setDescription('Applicable AU/BU only.\n\t\t\t The Minimum SNR Level plus the value of this parameter define the \n\t\t\t maximum desired level of the average SNR at the AU/BU. \n\t\t\t If the ATPC Option is enabled,\tthan if the received SNR is above \n\t\t\t the maximum desired level, the AU/BU will transmit Power-Down \n\t\t\t messages to the applicable SU/RB.\n             Range: 4 to 20 (dB).')
bwaVLMinimumSNRLevel = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMinimumSNRLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinimumSNRLevel.setDescription('Applicable AU/BU only.\n             Defines the minimum desired level of the average SNR at the AU/BU.\n             Below this level, if *AtpcOption is enabled, the AU/BU will transmit\n             ATPC Power-Up messages to the applicable SU/RB.\n             The *MinimumSNRLevel cannot be higher  than *MaximumSNRLevel.\n             Range: 4 to 60 (dB).')
bwaVLMinimumIntervalBetweenATPCMessages = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMinimumIntervalBetweenATPCMessages.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinimumIntervalBetweenATPCMessages.setDescription('Applicable AU/BU only.\n\t\t\t The minimum interval between two consecutive AU/BU to SU/RB messages.\n             Range: 1 to 3600 (Sec).')
bwaVLPowerLevelSteps = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 13, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLPowerLevelSteps.setStatus('current')
if mibBuilder.loadTexts: bwaVLPowerLevelSteps.setDescription('Applicable AU/BU only.\n\t\t\t The step in dB that the SU/RB will use when receiving an ATPC \n\t\t\t Power-Up/Power-Down message.\n             Range: 1 to 20  (dB).')
bwaVLCellDistanceParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15))
bwaVLCellDistanceMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLCellDistanceMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLCellDistanceMode.setDescription('Applicable AU/BU only. \n             The selected mode of deciding on Cell Distance.')
bwaVLFairnessFactor = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLFairnessFactor.setStatus('current')
if mibBuilder.loadTexts: bwaVLFairnessFactor.setDescription('Applicable AU/BU only.\n             Not applicable to BWA-PtP products for SW version below 4.0.. \n             The percentage of the maximum distance that is taken into \n             account in the time slot calculation. Range: 0 to 100 \n             (Percent). A value of 0 means the minimal slot size \n             (9 microseconds).\n             BWA-PtP products with SW version below 4.0 return na.')
bwaVLMeasuredCellDistance = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("below-2-Km", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMeasuredCellDistance.setStatus('current')
if mibBuilder.loadTexts: bwaVLMeasuredCellDistance.setDescription('Applicable AU/BU only.\n\t\t\t The Maximum Cell Distance as calculated by the AU/BU.\n             Range: 0 to 54 (Kilometers).')
bwaVLUnitWithMaxDistance = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnitWithMaxDistance.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitWithMaxDistance.setDescription('Applicable AU only.\n\t\t\t Not applicable to BWA-PtP units.\n\t\t\t The MAC address of the unit with the maximum distance\n\t\t\t from the AU.')
bwaVLPerSuDistanceLearning = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLPerSuDistanceLearning.setStatus('current')
if mibBuilder.loadTexts: bwaVLPerSuDistanceLearning.setDescription('Aplicable to AU only. Applicable only if Cell Distance Mode is \n\t\t\tset to Automatic. When disabled, all SUs in the cell will use \n\t\t\tfor the ACK Timeout the computed distance of the farthest SU. \n\t\t\tWhen enabled, each SU will use its own computed distance')
bwaVLScanningMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLScanningMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLScanningMode.setDescription('Applicable to SU/RB only. \n             The scanning mode. In cells where the DFS Option is enabled \n             Scanning Mode is forced to Passive.')
bwaVLAntennaGain = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 17), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAntennaGain.setStatus('current')
if mibBuilder.loadTexts: bwaVLAntennaGain.setDescription("Applicable to all units. Read-write in units where \n             bwaVLAntennaGainChange  is supported. \n             Read-only in units where bwaVLAntennaGainChange is not supported. \n             The net gain (including cable attenuation for detached antennas) of \n             the antenna. \n             Range: 0  - to Maximum EIRP defined by country code + 10 (dBi). \n             A value of -2 (this value is configurable only in factory) \n             means don't care.\n             A value of -1 (this value is configurable only in factory) \n             means that the unit will not transmit until the actual value \n             is configured.")
bwaVLSpectrumAnalysisParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18))
bwaVLSpectrumAnalysisChannelScanPeriod = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisChannelScanPeriod.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisChannelScanPeriod.setDescription('Applicable to all units. \n             The period of staying on each channel for information gathering \n             when performing Spectrum analysis. \n             Range: 2-30 seconds.')
bwaVLSpectrumAnalysisScanCycles = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisScanCycles.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisScanCycles.setDescription('Applicable to all units.  \n             The number of scanning cycles when performing Spectrum Analysis. \n             Range: 1-100.')
bwaVLAutomaticChannelSelection = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAutomaticChannelSelection.setStatus('current')
if mibBuilder.loadTexts: bwaVLAutomaticChannelSelection.setDescription('Applicable to AU/BU only.  \n             Defines weather the AU/BU shall choose the most noise free channel\n             upon startup after spectrum analysis.')
bwaVLSpectrumAnalysisActivation = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cancelOperation", 1), ("activateNow", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisActivation.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisActivation.setDescription('Applicable to all units.  \n             Activates spectrum analysis, the unit is automatically reset upon \n             activation.')
bwaVLSpectrumAnalysisStatus = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("currentlyActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisStatus.setDescription('Applicable to all units.  \n             Defines weather the unit is currently under performing \n             a spectrum analysis process.')
bwaVLResetSpectrumCounters = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cancelOperation", 1), ("resetCounters", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLResetSpectrumCounters.setStatus('current')
if mibBuilder.loadTexts: bwaVLResetSpectrumCounters.setDescription('Applicable to all units.  \n             Resets the spectrum analysis counters.')
bwaVLSpectrumAnalysisInformationTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7), )
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationTable.setDescription('Applicable to all units.  \n             The spectrum analysis information table.')
bwaVLSpectrumAnalysisInformationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLSpectrumAnalysisInformationTableIdx"))
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationEntry.setDescription('Applicable to all units.  \n             The spectrum analysis information table entry.')
bwaVLSpectrumAnalysisInformationTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationTableIdx.setDescription('Applicable to all units.  \n             A read only table index for a Spectrum Analysis Information entry in the  \n             Spectrum Analysis Information Table.')
bwaVLSpectrumAnalysisInformationChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationChannel.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationChannel.setDescription('Applicable to all units.  \n             The channels in the Spectrum Analysis Information Table.\n             If the unit is currently under spectrum analysis the channels would \n             be those on which the analysis is currently performed.\n             If the unit is in normal mode the channels would be the those on \n             which the last analysis was performed.')
bwaVLSpectrumAnalysisInformationSignalCount = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalCount.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalCount.setDescription('Applicable to all units.\n             The number of signals (excluding OFDM frames) detected in the channel. \n             If the unit is currently under spectrum analysis the count would \n             be of the analysis that is currently performed. \n             If the unit is in normal mode the count would be of the last \n             analysis performed.')
bwaVLSpectrumAnalysisInformationSignalSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalSNR.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalSNR.setDescription('Applicable to all units.\n\t\t\t The approximate SNR of the signals (excluding OFDM frames)\n\t\t\t detected in the channel.\n\t\t\t If the unit is currently under spectrum analysis the SNR would\n\t\t\t be of the analysis that is currently performed.\n\t\t\t If the unit is in normal mode the SNR would be of the last\n\t\t\t analysis performed.')
bwaVLSpectrumAnalysisInformationSignalWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalWidth.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationSignalWidth.setDescription('Applicable to all units. \n             The average width of the signals (excluding OFDM frames) \n             detected in the channel. \n             If the unit is currently under spectrum analysis the width would \n             be of the analysis that is currently performed. \n             If the unit is in normal mode the width would be of the last \n             analysis performed.')
bwaVLSpectrumAnalysisInformationOFDMFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 18, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationOFDMFrames.setStatus('current')
if mibBuilder.loadTexts: bwaVLSpectrumAnalysisInformationOFDMFrames.setDescription('Applicable to all units. \n             The number of OFDM frames detected in the channel. \n             If the unit is currently under spectrum analysis the count would \n             be of the analysis that is currently performed. \n             If the unit is in normal mode the count would be of the last \n             analysis performed.')
bwaVLMaxNumOfAssociationsLimit = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLMaxNumOfAssociationsLimit.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxNumOfAssociationsLimit.setDescription('Applicable to AU only. \n             Not applicable to BWA-PtP products. \n             Shows the limit for the number of SUs that can be associated \n             with the AU. \n             For AU-BS, AU-SA if Data Encryption is enabled, the upper \n             limit is 124, otherwise it is 512. \n             For AUS-BS, AUS-SA with SW version 4.0 and higher the upper limit \n             is 8 or 25 (via licensing).\n             For AUS-BS, AUS-SA with SW version below 4.0 the upper limit is 5.\n             BWA-PtP products return 65535.')
bwaVLDisassociate = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 20))
bwaVLDisassociateAllSUs = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cancelOperation", 1), ("disassociateAllSUs", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDisassociateAllSUs.setStatus('current')
if mibBuilder.loadTexts: bwaVLDisassociateAllSUs.setDescription('Applicable to AU only.  \n             The AU shall disassociate all its associated units.')
bwaVLDisassociateSuByMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 20, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDisassociateSuByMacAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLDisassociateSuByMacAddress.setDescription('Applicable to AU only.  \n             The AU shall disassociate the SU with the configured MAC address.')
bwaVLTxControl = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTxControl.setStatus('current')
if mibBuilder.loadTexts: bwaVLTxControl.setDescription('Applicable to AU/BU only.  \n             Tx Control of the AU/BU.\n             Starting with version 4.0 it is run-time.\n             For SW version below 4.0 the unit reset itself.\n\t\t\t If set to ethernetStatusControl, the unit will not transmit \n             if the Ethernet link is down.\n             This parameter can be configured only via the ethernet port.')
bwaVLLostBeaconsWatchdogThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(100, 1000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLLostBeaconsWatchdogThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLLostBeaconsWatchdogThreshold.setDescription('Applicable to AU/BU only.  \n            The number of unsuccessful consecutive transmissions beacons \n            before Internal refresh is performed. \n\t\t\t0 means that the lost beacons watchdog is not \n\t\t\tused and internal refresh is not performed.')
bwaVLTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTransmitPower.setStatus('current')
if mibBuilder.loadTexts: bwaVLTransmitPower.setDescription('Applicable to all units with SW version 4.0 and higher.\n             The uniform transmit power for all modulation levels. For a specific\n             modulation level the effective transmit power (bwaVLTxPower) is \n             the minimum between the uniform transmit power and the maximum \n             transmit power for that modulation level.')
bwaVLMaximumTxPower = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaximumTxPower.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumTxPower.setDescription('Applicable to only SU/RB with SW version 4.0 and higher.\n            The Maximum Transmit Power for all modulation levels.\n            The Maximum Transmit Power for a specific modulation level is the \n            minimum between this parameter and the hardware limitation for \n            that modulation level')
bwaVLCountryCodeParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 25))
bwaLCountryCodeReApply = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 6, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("reapply", 1), ("cancel", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaLCountryCodeReApply.setStatus('current')
if mibBuilder.loadTexts: bwaLCountryCodeReApply.setDescription('Applicable to all units.\n             Re-apply country code parameters.')
bwaVLServiceParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7))
bwaVLMirDownlink = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMirDownlink.setStatus('current')
if mibBuilder.loadTexts: bwaVLMirDownlink.setDescription('Applicable to SU/RB only. \n         The Maximum Information Rate (MIR) from AU/BU to SU/RB.\n         MIR must be above bwaVLCirDownlink value.\n         Range for set: 128 to 2,048 (Kbps) for SU-3 with SW version below 4.0,\n\t\t\t\t\t\t128 to 3,072 (Kbps) for SU-3 with SW version 4.0 and higher,\t\t\t\t\n                        128 to 3,968 (Kbps) for SU-6 with SW version less than 4.0,\n                        128 to 6,016 (Kbps) for SU-6 with SW version greater than 4.0,\n         \t            128 to 14,976 (Kbps) for SU-24, \n         \t            128 to 53,888 (Kbps) for SU-BD and SU-54,\n         \t            128 to 6,912  (Kbps) for RB-14, \n         \t            128 to 22,016 (Kbps) for RB-28,\n         \t            128 to 107,904 (Kbps) for RB-100.\n         \t            128 to 6,016 (Kbps) for SU-I.\n         The actual value (Get) will be the entered value rounded to the nearest \n         multiple of 128 (N*128).')
bwaVLMirUplink = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMirUplink.setStatus('current')
if mibBuilder.loadTexts: bwaVLMirUplink.setDescription('Applicable to SU/RB only. \n         The Maximum Information Rate (MIR) from SU/RB to AU/BU.\n         MIR must be above bwaVLCirUplink value.\n         Range for set: 128 to 2,048 (Kbps) for SU-3,\n                        128 to 3,968  (Kbps) for SU-6 with SW version less than 4.0,\n                        128 to 4,096  (Kbps) for SU-6 with SW version greater than 4.0,\n         \t            128 to 14,976 (Kbps) for SU-24, \n         \t            128 to 53,888 (Kbps) for SU-BD and SU-54,\n         \t            128 to 6,912  (Kbps) for RB-14, \n         \t            128 to 22,016 (Kbps) for RB-28, \n         \t            128 to 107,904 (Kbps) for RB-100.\n         \t            128 to 2,048 (Kbps) for SU-I.\n\t\t The actual value (Get) will be the entered value rounded to the nearest \n\t\t multiple of 128 (N*128).')
bwaVLCirDownlink = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLCirDownlink.setStatus('current')
if mibBuilder.loadTexts: bwaVLCirDownlink.setDescription('Applicable to SU only. \n         Not applicable to BWA-PtP products. \n         The Committed Information Rate (CIR) from AU to SU.\n         CIR must be below bwaVLMirDownlink value.\n         Range for Set: \n         0 to 2,048 (Kbps) for SU-3 with SW version below 4.0,\n\t\t 0 to 3,072 (Kbps) for SU-3 with SW version 4.0 and higher,\t\t\t\t\n         0 to 3,968 (Kbps) for SU-6 with SW version less than 4.0,\n         0 to 6,016 (Kbps) for SU-6 with SW version greater than 4.0\n         0 to 14,976 (Kbps) for SU-24, \n         0 to 45,056 (Kbps) for SU-BD and SU-54. \n         0 to 6,016 (Kbps) for SU-I.\n         The actual value (Get) will be the entered value rounded to the \n         nearest multiple of 128 (N*128).\n\t\t BWA-PtP products will return 65535.')
bwaVLCirUplink = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLCirUplink.setStatus('current')
if mibBuilder.loadTexts: bwaVLCirUplink.setDescription('Applicable to SU only. \n          Not applicable to BWA-PtP products. \n          The Committed Information Rate (CIR) from SU to AU.\n          CIR must be below bwaVLMirUplink value.\n          Range for Set: \n          0 to 2,048 (Kbps) for SU-3,\n          0 to 3,968  (Kbps) for SU-6 with SW version less than 4.0,\n          0 to 4,096  (Kbps) for SU-6 with SW version greater than 4.0,\n          0 to 14,976 (Kbps) for SU-24, \n          0 to 45,056 (Kbps) for SU-BD and SU-54. \n          0 to 2,048 (Kbps) for SU-I.\n          The actual value (Get) will be the entered value rounded to the nearest \n          multiple of 128 (N*128).\n          BWA-PtP products will return 65535.')
bwaVLMaxDelay = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaxDelay.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxDelay.setDescription('Applicable to SU only. \n         Not applicable to BWA-PtP products.\n         The maximal time packets may be delayed by the \n         CIR\\MIR mechanism. Above the configured maximal period \n         the packets are discarded.\n         Range: 300 to 10000 milliseconds.\n         BWA-PtP products return 65535.')
bwaVLMaxBurstDuration = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaxBurstDuration.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxBurstDuration.setDescription('Applicable to AU and SU. \n         Not applicable to BWA-PtP products.\n         The maximum time during which inactivity bonus time \n         can be accumulated for future burst transmissions.\n         Range: 0 to 2000 milliseconds.\n         BWA-PtP products return 65535')
bwaVLGracefulDegradationLimit = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLGracefulDegradationLimit.setStatus('current')
if mibBuilder.loadTexts: bwaVLGracefulDegradationLimit.setDescription('Applicable to AU only. \n         Not applicable to BWA-PtP products.\n         The maximum limit for activating the graceful \n         degradation algorithm.\n         Range: 0 to 70% rate of the CIR.\n         BWA-PtP products return 255.')
bwaVLMirOnlyOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMirOnlyOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLMirOnlyOption.setDescription('Applicable to AU only. \n         Not applicable to BWA-PtP products. \n         When bwaMirOnly is enabled, it overrides the CIR/MIR \n         algorithm for determining actual information rate and \n         forces the algorithm to operate with MIR parameter \n         settings only. When enabled, the Graceful Degradation \n         algorithm is disabled.')
bwaVLTrafficPrioritization = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10))
bwaVLTrafficPriVLAN = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 1))
bwaVLVLANPriorityThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLVLANPriorityThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLVLANPriorityThreshold.setDescription("Applicable to all units. \n        If the VLAN Priority's value of the frame is less than or equal to this\n        threshold the frame will get LOW priority, otherwise the frame will get \n        HIGH priority.\n        Untagged frames will get LOW priority")
bwaVLTrafficPriIPToS = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 2))
bwaVLToSPrioritizationOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("ipPrecedence", 2), ("dSCP", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLToSPrioritizationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLToSPrioritizationOption.setDescription('Applicable to all units. Disable/Enable IP ToS prioritization and \n\t\tchoose the interpretation of the IP ToS field from IP header.\n\t\tipPrecedence(2): The IP ToS field is defined by RFC791. In this \n                         case the prioritization will be done using the \n                         Precedence sub-field of IP ToS. This sub-field \n                         has 3 bits, so it can be between 0 and 7.\n\t\tdSCP(3):         The IP ToS field is defined by RFC2474. In this\n                         case the prioritization will be done using the \n                         DSCP sub-field. The size of the sub-field is 6 bits, \n                         so the range is 0 to 63.')
bwaVLIPPrecedenceThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLIPPrecedenceThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLIPPrecedenceThreshold.setDescription('Applicable to all units. The threshold of Precedence sub-field of IP ToS \n\t\tfield from IP Header (RFC791) to be used when the ToS Prioritization \n\t\tOption is set to IP Precedence.\n\t\tIf the Precedence sub-field of a frame is less than or equal to this \n\t\tthreshold the frame will have LOW priority, otherwise it will get HIGH \n\t\tpriority.')
bwaVLIPDSCPThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLIPDSCPThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLIPDSCPThreshold.setDescription('Applicable to all units. The threshold of DSCP sub-field of IP ToS \n\t\tfield from IP Header (RFC2474) to be used when ToS Prioritization \n\t\tOption is set to DSCP.\n\t\tIf the DSCP sub-field of a frame is less than or equal to this \n\t\tthreshold the frame will have LOW priority, otherwise it will get \n\t\tHIGH priority.')
bwaVLTrafficPriUdpTcpPortRange = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3))
bwaVLUdpTcpPortRangePrioritizationOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("udpOnly", 2), ("tcpOnly", 3), ("udpANDtcp", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUdpTcpPortRangePrioritizationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpTcpPortRangePrioritizationOption.setDescription('Applicable to all units. Disable/Enable Prioritization using UDP and/or\n        TCP Port Ranges. \n\t\tudpOnly(2)  : prioritization will be done only for UDP packets\n\t\ttcpOnly(3)  : prioritization will be done only for TCP packets\n\t\tudpANDtcp(4): prioritization will be done for UDP and TCP packets')
bwaVLUdpPortRangeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2))
bwaVLUdpPortPriRTPRTCP = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rtpANDrtcp", 1), ("rtpOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUdpPortPriRTPRTCP.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortPriRTPRTCP.setDescription('Applicale to all units.\n        RTP/RTCP ports prioritization option for UDP packets. \n        rtpANDrtcp(1): the possible RTP and RTCP packet with destination port in the\n                       defined port ranges will get HIGH priority\n\t\trtpOnly(2): only possible RTP packet (packet with even destination port ) \n\t\t            with destination port in the defined port ranges will get HIGH \n\t\t            priority.')
bwaVLUdpPortRangeNum = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUdpPortRangeNum.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeNum.setDescription('Applicable to all units. The number of entries in the UDP Port Range Table')
bwaVLUdpPortRangeTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 3), )
if mibBuilder.loadTexts: bwaVLUdpPortRangeTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeTable.setDescription('Applicable to all units. A table of UDP port ranges use for prioritization. \n\t\tThe user can define up to 64 ranges.\n        An entry is empty if start is 65535 and end is 0')
bwaVLUdpPortRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 3, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLUdpPortRangeIdx"))
if mibBuilder.loadTexts: bwaVLUdpPortRangeEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeEntry.setDescription('Applicable to all units. A UDP Port Ranges Table entry.')
bwaVLUdpPortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUdpPortRangeStart.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeStart.setDescription('Applicable to all units. Start port of an UDP Port Range')
bwaVLUdpPortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUdpPortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeEnd.setDescription('Applicable to all units. End port of an UDP Port Range')
bwaVLUdpPortRangeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUdpPortRangeIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeIdx.setDescription("Applicable to all units. UDP Port Range Entry's index ")
bwaVLUdpPortRangeAdd = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUdpPortRangeAdd.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeAdd.setDescription('Applicable to all units. Add port range(s) to UDP Port Ranges Table. \n        Get operation will return the empty string. \n\t\tA range is defined <start>-<end> or <start> where <start> is the Start \n\t\tPort of the range and <end> is the End Port. If only <start> is \n\t\tspecified the range is <start>-<start>.\n        The value of  <start> and <end> are between 0..65535.\n        The user can add several ranges using a comma to separate between ranges. \n        Example: 10-256,99,987-900')
bwaVLUdpPortRangeDelete = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUdpPortRangeDelete.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeDelete.setDescription('Applicable to all units. Delete port range(s) from UDP Port Ranges Table. \n        Get operation will return the empty string.\n        A range is defined <start>-<end> or <start> where <start> is the Start \n        Port of the range and <end> is the End Port. If only <start> is \n        specified the range is <start>-<start>.\n        The value of  <start> and <end> are between 0..65535.\n        The user can delete several ranges using a comma to separate between \n        ranges.\n        Example: 10-256,99,987-900')
bwaVLUdpPortRangeDeleteAll = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUdpPortRangeDeleteAll.setStatus('current')
if mibBuilder.loadTexts: bwaVLUdpPortRangeDeleteAll.setDescription('Applicable to all units. Delete all entries form UDP Port Ranges Table. \n\t\tGet operation will return 1')
bwaVLTcpPortRangeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3))
bwaVLTcpPortPriRTPRTCP = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rtpANDrtcp", 1), ("rtpOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTcpPortPriRTPRTCP.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortPriRTPRTCP.setDescription('Applicable to all units. RTP/RTCP ports prioritization option for TCP packets. \n\t\trtpANDrtcp(1): the possible RTP and RTCP packet with destination port \n\t\tin the defined port ranges will get HIGH priority\n\t\trtpOnly(2): only possible RTP packet (packet with even destination port )')
bwaVLTcpPortRangeNum = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTcpPortRangeNum.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeNum.setDescription('Applicable to all units. The number of entries in the TCP Port Range Table')
bwaVLTcpPortRangeTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 3), )
if mibBuilder.loadTexts: bwaVLTcpPortRangeTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeTable.setDescription('Table of TCP Port Ranges use for prioritization.\n        The user can define up to 64 ranges.\n        An entry is empty if start is 65535 and end is 0')
bwaVLTcpPortRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 3, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLTcpPortRangeIdx"))
if mibBuilder.loadTexts: bwaVLTcpPortRangeEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeEntry.setDescription('Applicable to all units. A TCP Port Ranges Table entry.')
bwaVLTcpPortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTcpPortRangeStart.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeStart.setDescription('Applicable to all units. Start port of a TCP Port Range')
bwaVLTcpPortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTcpPortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeEnd.setDescription('Applicable to all units. End port of a TCP Port Range')
bwaVLTcpPortRangeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTcpPortRangeIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeIdx.setDescription("Applicable to all units. TCP Port Range Entry's index")
bwaVLTcpPortRangeAdd = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTcpPortRangeAdd.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeAdd.setDescription('Applicable to all units. Add port range(s) to TCP Port Ranges Table. \n        Get operation will return the empty string. \n\t\tA range is defined <start>-<end> or <start> where <start> is the Start \n\t\tPort of the range and <end> is the End Port. If only <start> is specified \n\t\tthe range is <start>-<start>.\n        The value of  <start> and <end> are between 0..65535.\n        The user can add several ranges using comma to separate between ranges.\n        Example: 10-256,99,987-900')
bwaVLTcpPortRangeDelete = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTcpPortRangeDelete.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeDelete.setDescription('Applicable to all units. Delete port range(s) from TCP Port Ranges Table. \n\t\tGet operation will return the empty string.\n        A range is defined <start>-<end> or <start> where <start> is the Start \n        Port of the range and <end> is the End Port. If only <start> is specified \n        the range is <start>-<start>.\n        The value of  <start> and <end> are between 0..65535.\n        The user can delete several ranges using comma to separate between ranges.\n        Example: 10-256,99,987-900')
bwaVLTcpPortRangeDeleteAll = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLTcpPortRangeDeleteAll.setStatus('current')
if mibBuilder.loadTexts: bwaVLTcpPortRangeDeleteAll.setDescription('Applicable to all units. Delete all entries form TCP Port Ranges Table\n        Get operation will return 1')
bwaVLWirelessLinkPrioritization = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4))
bwaVLWirelessLinkPrioritizationOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLWirelessLinkPrioritizationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLWirelessLinkPrioritizationOption.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n             Enable/disable the traffic prioritization over the \n             Wireless Link')
bwaVLlowPriorityAIFS = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLlowPriorityAIFS.setStatus('current')
if mibBuilder.loadTexts: bwaVLlowPriorityAIFS.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n            Applicable only if the Wireless Link Prioritization Option is enabled.\n            Define the AIFS (Arbitration Inter-frame Space) that will be used   \n            for transmitting Low Priority Traffic')
bwaVLHWRetriesHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLHWRetriesHighPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLHWRetriesHighPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100.\n            Applicable only if the Wireless Link Prioritization Option is enabled. \n            Defines the Maximum number of HW Retries for a unicast data packet \n            that has High Priority')
bwaVLHWRetriesLowPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLHWRetriesLowPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLHWRetriesLowPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100.\n            Applicable only if the Wireless Link Prioritization Option is enabled. \n            Defines the Maximum number of HW Retries for a unicast data packet \n            that has Low Priority')
bwaVLAUBurstDurationHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUBurstDurationHighPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUBurstDurationHighPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n            Applicable only if the Wireless Link Prioritization Option is enabled.\n             Defines the Maximum duration of burst that can be done by AU with \n             High Priority packets.\n             The time is given in 250 microseconds units')
bwaVLAUBurstDurationLowPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUBurstDurationLowPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUBurstDurationLowPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n            Applicable only if the Wireless Link Prioritization Option is enabled.\n             Defines the Maximum duration of burst that can be done by AU \n             with Low Priority packets.\n             The time is given in 250 microseconds units')
bwaVLSUBurstDurationHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSUBurstDurationHighPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUBurstDurationHighPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n            Applicable only if the Wireless Link Prioritization Option is enabled.\n            Defines the Maximum duration of burst that can be done by SU/RB \n            with High Priority packets.\n            The parameter is configurable in AU and the SUs/RB will learn it \n            form AU/BU.\n            The time is given in 250 microseconds units')
bwaVLSUBurstDurationLowPriority = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 10, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSUBurstDurationLowPriority.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUBurstDurationLowPriority.setDescription('Applicable only to AU with a license for the Wireless Link Prioritization feature and to BU-100. \n            Applicable only if the Wireless Link Prioritization Option is enabled.\n            Defines the Maximum duration of burst that can be done by SU/RB \n            with High Priority packets.\n            The parameter is configurable in AU/BU and the SUs/RB will learn it \n            from AU/BU.\n            The time is given in 250 microseconds units')
bwaVLDrap = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11))
bwaVLDrapSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDrapSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapSupport.setDescription('Applicable to AU. Not applicable to BWA PtP products.\n\t\tDisable/Enable the DRAP feature')
bwaVLDrapUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8000, 8200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDrapUdpPort.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapUdpPort.setDescription('Applicable to AU when DRAP support is enabled. \n\t\tNot applicable to BWA PtP products. \n\t\tThe UDP port used for the DRAP server')
bwaVLDrapMaxNumberOfVoiceCalls = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDrapMaxNumberOfVoiceCalls.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapMaxNumberOfVoiceCalls.setDescription('Applicable to AU when DRAP support is enabled. \n\t\tNot applicable to BWA PtP products. \n\t\tThe maximum number of voice calls that can be supported by the AU')
bwaVLDrapTTL = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDrapTTL.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapTTL.setDescription('Applicable to AU when DRAP support is enabled. \n\t\tNot applicable to BWA PtP products. \n\t\tThe maximum time between two allocation requests')
bwaVLDrapNoOfActiveVoiceCalls = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 11, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDrapNoOfActiveVoiceCalls.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapNoOfActiveVoiceCalls.setDescription('Applicable to AU when DRAP support is enabled. \n\t\tNot applicable to BWA PtP products. \n\t\tThe current total number of  active voice calls.')
bwaVLLowPriorityTrafficMinimumPercent = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLLowPriorityTrafficMinimumPercent.setStatus('current')
if mibBuilder.loadTexts: bwaVLLowPriorityTrafficMinimumPercent.setDescription('The minimum percent of the traffic rate that is allocated to the low priority traffic')
bwaVLSUPMirDownlink = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSUPMirDownlink.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPMirDownlink.setDescription('Applicable to AU only. \n         The Maximum Information Rate (MIR) from AU to SUP.\n            Range for set: 128 to 12,032 (Kbps).\n         The actual value (Get) will be the entered value rounded to the nearest \n         multiple of 128 (N*128).')
bwaVLMIRThresholdPercent = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 7, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMIRThresholdPercent.setStatus('current')
if mibBuilder.loadTexts: bwaVLMIRThresholdPercent.setDescription('Applicable to AU only.  \n\t\tMIR Threshold Percent')
bwaVLUserFilterParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8))
bwaVLUserFilterOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("disable", 1), ("ipOnly", 2), ("userDefinedAddrOnly", 3), ("pPPoEOnly", 4), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLUserFilterOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLUserFilterOption.setDescription('Applicable to SU/RB only. \n             Defines user-filtering options.\n             disable: No filtering.\n             iPOnly: Only IP protocol frames pass. \n             userDefinedAddrOnly: Only ip frames to/from user defined IP \n                                  addresses pass.\n             pPPoE Only: Only PPPoE frames pass.')
bwaVLIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2), )
if mibBuilder.loadTexts: bwaVLIpFilterTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLIpFilterTable.setDescription('Applicable to SU/RB only. \n             An IP Filter Table of up to 8 user defined addresses, \n             or address groups, to be used if the selected User \n             Filtering option is userDefinedAddrOnly.')
bwaVLIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLIpFilterIdx"))
if mibBuilder.loadTexts: bwaVLIpFilterEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLIpFilterEntry.setDescription('Applicable to SU/RB only. \n             An IP Filter Table entry.')
bwaVLIpID = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLIpID.setStatus('current')
if mibBuilder.loadTexts: bwaVLIpID.setDescription('Applicable to SU/RB only. \n             An IP address of an IP Filter Table entry.')
bwaVLMaskID = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaskID.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaskID.setDescription('Applicable to SU/RB only. \n             An IP Mask of an IP Filter Table entry. Either a mask \n             or a range, but not both can be used to define an \n             address group. If the range is other than 0, than the mask is \n             ignored and only the range value is used to define the address group.')
bwaVLIpFilterRange = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLIpFilterRange.setStatus('current')
if mibBuilder.loadTexts: bwaVLIpFilterRange.setDescription('Applicable to SU/RB only. \n             An addresses range for the IP Filter Table entry. The \n             first address in the range is the IP address.\n             O means that the range is not used.  \n             Either a mask or a range, but not both can be used to \n             define an address group.\n\t\t\t If the range is other than 0, than the mask is ignored and \n\t\t\t only the range value is used to define the address group.\n             Range: 0 to 255.')
bwaVLIpFilterIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLIpFilterIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLIpFilterIdx.setDescription('Applicable to SU/RB only. \n             A table index for the IP Filter Table entry.')
bwaVLDeleteOneUserFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("deletefirstEntry", 1), ("deletesecondEntry", 2), ("deletethirdEntry", 3), ("deletefourthEntry", 4), ("deletefifthEntry", 5), ("deletesixthEntry", 6), ("deleteseventhEntry", 7), ("deleteeighthEntry", 8), ("cancelOperation", 9), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteOneUserFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteOneUserFilter.setDescription('Applicable to SU/RB only. \n             Deletes a single selected entry from the IP Filter \n             Table.')
bwaVLDeleteAllUserFilters = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("deleteAll", 1), ("cancelOperation", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDeleteAllUserFilters.setStatus('current')
if mibBuilder.loadTexts: bwaVLDeleteAllUserFilters.setDescription('Applicable to SU/RB only. \n             Deletes all entries from the IP Filter Table.')
bwaVLDHCPUnicastOverrideFilter = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDHCPUnicastOverrideFilter.setStatus('current')
if mibBuilder.loadTexts: bwaVLDHCPUnicastOverrideFilter.setDescription('Applicable to SU/RB only. \n             Enables or disables the unicast DHCP messages, \n             overriding the IP Filtering option.')
bwaVLSecurityParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9))
bwaVLAuthenticationAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("openSystem", 1), ("sharedKey", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAuthenticationAlgorithm.setStatus('current')
if mibBuilder.loadTexts: bwaVLAuthenticationAlgorithm.setDescription('Applicable to all units.\n            Enables/disables the authentication encryption option.\n            openSystem: Authentication messages are not encrypted.\n            sharedKey : Authentication messages are encrypted ')
bwaVLSUDefaultKeyID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSUDefaultKeyID.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUDefaultKeyID.setDescription('Applicable to SU/RB only.\n\t\t\t The key to be used for encryption of authentication messages \n\t\t\t and/or data.\n             Range: 1 to 4. ')
bwaVLDataEncryptionOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLDataEncryptionOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLDataEncryptionOption.setDescription('Applicable to all units.\n             Enables/disables the data encryption option. ')
bwaVLAUDefaultMulticastKeyID = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUDefaultMulticastKeyID.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUDefaultMulticastKeyID.setDescription('Applicable to AU/BU only.\n             The key to be used for encryption of multicasts and broadcasts.')
bwaVLSecurityMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("wep", 1), ("aesOCB", 2), ("fips197", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSecurityMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLSecurityMode.setDescription('Applicable to all units. The fips197 option is applicable only to units with a license to\n             use FIPS 197 algorithm.\n             The encryption algorithm to be used for authentication messages \n             and/or data encryption.')
bwaVLAuthenticationPromiscuousMode = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAuthenticationPromiscuousMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLAuthenticationPromiscuousMode.setDescription('Applicable to AU/BU only.\n             Enables/disable the promiscuous mode allowing authentication of \n             and communication with all SUs/RB regardless of their security \n             parameters.')
bwaVLKey1 = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLKey1.setStatus('current')
if mibBuilder.loadTexts: bwaVLKey1.setDescription('Applicable to all units.\n             Key number 1. Accessible only with SNMP Write Community String \n             (administrator password).\n             Valid values: 32 hexadecimal digits.')
bwaVLKey2 = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLKey2.setStatus('current')
if mibBuilder.loadTexts: bwaVLKey2.setDescription('Applicable to all units.\n             Key number 2. Accessible only with SNMP Write Community String \n             (administrator password).\n             Valid values: 32 hexadecimal digits.')
bwaVLKey3 = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLKey3.setStatus('current')
if mibBuilder.loadTexts: bwaVLKey3.setDescription('Applicable to all units.\n             Key number 3. Accessible only with SNMP Write Community String \n             (administrator password).\n             Valid values: 32 hexadecimal digits.')
bwaVLKey4 = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLKey4.setStatus('current')
if mibBuilder.loadTexts: bwaVLKey4.setDescription('Applicable to all units.\n             Key number 4. Accessible only with SNMP Write Community String \n             (administrator password).\n             Valid values: 32 hexadecimal digits.')
bwaVLSecurityModeSupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 9, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSecurityModeSupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLSecurityModeSupport.setDescription('Applicable to all units. Returns types of encryption that are supported.\n            0 - no encryption\n            1 - WEP\n            2 - AES OCB\n            3 - WEP and AES OCB\n            4 - FIPS-197\n            5 - FIPS-197 and WEP\n            6 - FIPS-197 and AES OCB\n            7 - FIPS-197, AES OCB and WEP')
bwaVLPerformanceParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10))
bwaVLRTSThreshold = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLRTSThreshold.setStatus('current')
if mibBuilder.loadTexts: bwaVLRTSThreshold.setDescription('Applicable to SU and AU. \n             Not applicable to BWA-PtP products. \n             The minimum frame size that requires an RTS/CTS handshake.            \n             Range: For units bearing SW version 3.0 and above: 20 to 3400 bytes,\n\t\t\t for previous SW versions 20 to 1600 bytes.\n             BWA-PtP products return 65535.')
bwaVLMinContentionWindow = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMinContentionWindow.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinContentionWindow.setDescription('Applicable to SU and AU. \n             For units bearing SW version 4.0 and above applicable to \n             BWA PtP products, for previous SW versions not applicable \n             to BWA PtP products. \n             The initial value to be used by the contention window calculation \n             algorithm.\n             Value must be 0 or power of 2 minus 1 (7,15,31...).\n             Range: 0 to 1023, excluding 1 and 3.\n             BWA-PtP products with SW version below 4.0 return 65535.')
bwaVLMaxContentionWindow = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaxContentionWindow.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaxContentionWindow.setDescription('Applicable to SU and AU. \n             For units bearing SW version 4.0 and above applicable to \n             BWA PtP products, for previous SW versions not applicable \n             to BWA PtP products. \n             The maximum value to be used by the contention window calculation \n             algorithm.\n             Value must be power of 2 minus 1 (7,15,31...)\n             Range: 7 to 1023.')
bwaVLMaximumModulationLevel = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7), ("level8", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMaximumModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMaximumModulationLevel.setDescription('Applicable to all units.\n             If the Adaptive Modulation algorithm is enabled, it sets the \n             Maximum Modulation Level to be used.\n             If The Modulation algorithm is disabled, it sets the Fixed \n             Modulation Level to be used.\n\t\t\t The range is 1 to 8. 8 is not applicable for units with HW revision A.')
bwaVLMulticastModulationLevel = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7), ("level8", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMulticastModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLMulticastModulationLevel.setDescription('Applicable to AU/BU only.\n             The modulation level for multicast and broadcast data frames.\n\t\t\t The range is 1 to 8.\n\t\t\t 8 is not applicable for units with HW revision A.')
bwaVLAvgSNRMemoryFactor = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAvgSNRMemoryFactor.setStatus('current')
if mibBuilder.loadTexts: bwaVLAvgSNRMemoryFactor.setDescription('Applicable to all units.\n\t\t\t The weight of history in average SNR calculation.\n\t\t\t The higher is the value, the higher is the weight of history.\n             Range: -1 (Disregard History) to 32.')
bwaVLHardwareRetries = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLHardwareRetries.setStatus('current')
if mibBuilder.loadTexts: bwaVLHardwareRetries.setDescription('Applicable to all units.\n             Not applicable if Wireless Link Prioritization is enabled.\n             The maximum number of trials to transmit an unacknowledged \n             frame in each Hardware Retrial phase.\n             Range : 1 to 14.')
bwaVLAdaptiveModulationParams = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9))
bwaVLAdaptiveModulationAlgorithmOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAdaptiveModulationAlgorithmOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdaptiveModulationAlgorithmOption.setDescription('Applicable to all units. \n             Enables/disables the adaptive modulation level decision mechanism.')
bwaVLSoftwareRetrySupport = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLSoftwareRetrySupport.setStatus('current')
if mibBuilder.loadTexts: bwaVLSoftwareRetrySupport.setDescription('Applicable to all units. \n             Read-only for units with version 2.0. \n             Not applicable for units with SW version 3.0 and higher. \n             The status of the Software Retry mechanism. \n             Enabled when the Adaptive Modulation algorithm is enabled and \n             the Burst Mode Option is disabled. Otherwise it is disabled.')
bwaVLNumOfSoftwareRetries = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(255))).clone(namedValues=NamedValues(("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLNumOfSoftwareRetries.setStatus('current')
if mibBuilder.loadTexts: bwaVLNumOfSoftwareRetries.setDescription('Applicable to all units. \n             Read-only for units with version 2.0. \n             Not applicable for units with SW version 3.0 and higher. \n             The maximum number of times to use the Software Retry mechanism \n             when it is enabled.')
bwaVLMinIntervalBetweenAdaptiveModulationAlgorithmMessages = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMinIntervalBetweenAdaptiveModulationAlgorithmMessages.setStatus('current')
if mibBuilder.loadTexts: bwaVLMinIntervalBetweenAdaptiveModulationAlgorithmMessages.setDescription('Applicable all units.\n\t\t\t The minimum interval between two consecutive AU/BU to SU/RB messages.\n             Range: 1 to 3600 (Sec).')
bwaVLAdaptiveModulationDecisionThresholds = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 9, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("normal", 1), ("high", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAdaptiveModulationDecisionThresholds.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdaptiveModulationDecisionThresholds.setDescription('Applicable to all units. \n             Defines the setting of thresholds for the rate decision algorithm. \n             high (2) should typically be used when the SNR is lower than 13dB.')
bwaVLBurstMode = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 10))
bwaVLBurstModeOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("blocked", 3), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBurstModeOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLBurstModeOption.setDescription('Applicable to all units.\n             Applicable only if Burst Mode Option is supported by country \n             specific parameters of the Sub Band.  \n             Not applicable if Wireless Link Prioritization is enabled.\n             Enables/disable burst mode operation.\n             In SU/RB with HW Revision B or lower blocked(3) value is returned\n             when Security Mode is Wep , Data Encryption Option\n\t\t\t is Enabled and Burst option is Enabled.\n\t\t\t In AU/BU with HW Revision B or lower blocked(3) value is returned\n\t\t\t when Dfs Option is Enabled and Burst mode is enabled.')
bwaVLBurstInterval = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLBurstInterval.setStatus('current')
if mibBuilder.loadTexts: bwaVLBurstInterval.setDescription('Applicable to all units.\n             Not applicable if Wireless Link Prioritization is enabled.\n             Burst mode interval in milliseconds.\n             Range: 1 to the maximum value as defined in the country \n             specific parameters of the Sub Band (milliseconds).')
bwaVLConcatenationParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 11))
bwaVLConcatenationOption = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLConcatenationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLConcatenationOption.setDescription('Applicable to all units. \n             Defines the Concatenation option.')
bwaVLConcatenationMaximumNumberOfFrames = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLConcatenationMaximumNumberOfFrames.setStatus('current')
if mibBuilder.loadTexts: bwaVLConcatenationMaximumNumberOfFrames.setDescription('Applicable to all units with SW version 3.X . \n             Not applicable for version 4.0 and higher.\n             Defines the maximum numbers of frames that can be concatenated.\n             Range:2 to 8 (frames).')
bwaVLConcatenationMaxFrameSize = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 10, 11, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLConcatenationMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: bwaVLConcatenationMaxFrameSize.setDescription('Applicable to all units. \n\t\t\t Defines the maximum size of a concatenated frame.\n\t\t\t Range:\n\t\t\t 256 to 2200 (bytes) for BWA PtP products BU/RB14 BU/RB28, \n\t\t\t or for AU/SU with HW revision A or B.\n\t\t\t 256 to 4032 (bytes) for AU/SU with HW Revision \n\t\t\t C or higher and BWA PtP products BU/RB100.')
bwaVLSiteSurvey = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11))
bwaVLAverageReceiveSNR = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAverageReceiveSNR.setStatus('current')
if mibBuilder.loadTexts: bwaVLAverageReceiveSNR.setDescription('Applicable to SU/RB only. \n             The average Signal to Noise Ratio of received frames.')
bwaVLTrafficStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2))
bwaVLResetTrafficCounters = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLResetTrafficCounters.setStatus('current')
if mibBuilder.loadTexts: bwaVLResetTrafficCounters.setDescription('Applicable to all units.\n             Resets the traffic counters.')
bwaVLEthCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 2))
bwaVLWirelessLinkCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3))
bwaVLWirelessLinkEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4))
bwaVLPerModulationLevelCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5))
bwaVLResetPerModulationLevelCounters = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("resetCounters", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLResetPerModulationLevelCounters.setStatus('current')
if mibBuilder.loadTexts: bwaVLResetPerModulationLevelCounters.setDescription('Applicable to all units.\n             Resets the per-Modulation Level counters .')
bwaVLSUPerModulationLevelCountersTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2), )
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTable.setDescription('Applicable to SU/RB. \n             Per Rate Counters table.')
bwaVLSUPerModulationLevelCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLSUPerModulationLevelCountersTableIdx"))
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersEntry.setDescription('Applicable to SU/RB. \n             An entry in the Per modulation  Counters table.')
bwaVLSUPerModulationLevelCountersTableIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTableIdx.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTableIdx.setDescription('Applicable to SU/RB.\n             An index of an entry in the Per modulation level Counters table.')
bwaVLSUPerModulationLevelCountersApplicableModLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("modLevel-1", 1), ("modLevel-2", 2), ("modLevel-3", 3), ("modLevel-4", 4), ("modLevel-5", 5), ("modLevel-6", 6), ("modLevel-7", 7), ("modLevel-8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersApplicableModLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersApplicableModLevel.setDescription('Applicable to SU/RB.\n             The applicable modulation level of the entry in the Per \n             modulation level Counters table.\n             Modulation Level 8 is not applicable for units with HW revision A.')
bwaVLSUPerModulationLevelCountersTxSuccess = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTxSuccess.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTxSuccess.setDescription('Applicable to SU/RB.\n             The total number of successfully transmitted unicasts at the \n             applicable modulation level.')
bwaVLSUPerModulationLevelCountersTxFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTxFailed.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUPerModulationLevelCountersTxFailed.setDescription('Applicable to SU/RB.\n             The total number of dropped frames at the applicable \n             Modulation Level.')
bwaVLAverageModulationLevel = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAverageModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLAverageModulationLevel.setDescription('Applicable to SU/RB. \n\t         The average modulation level for successful transmission \n\t         (rounded to nearest integer) since last reset of the \n\t         Per Modulation Level counters. \n\t         Range: 1 to 8.')
bwaVLTotalRxFramesViaEthernet = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxFramesViaEthernet.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxFramesViaEthernet.setDescription('Applicable to all units. \n             Total number of frames received via the Ethernet port.')
bwaVLTxWirelessToEthernet = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTxWirelessToEthernet.setStatus('current')
if mibBuilder.loadTexts: bwaVLTxWirelessToEthernet.setDescription('Applicable to all units. \n             Total number of frames transmitted to the Ethernet port.')
bwaVLTxFramesToWireless = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1))
bwaVLAUBeaconsToWireless = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAUBeaconsToWireless.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUBeaconsToWireless.setDescription('Applicable to AU/BU only.\n             The number of beacons transmitted to the wireless media.')
bwaVLDataAndOtherMngFramesToWireless = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDataAndOtherMngFramesToWireless.setStatus('current')
if mibBuilder.loadTexts: bwaVLDataAndOtherMngFramesToWireless.setDescription('Applicable to AU/BU only.\n             The number of data and management frames transmitted to the \n             wireless media. The count includes one count for each data \n             frame transmitted successfully (excluding retransmissions).')
bwaVLTotalTxFramesToWireless = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTxFramesToWireless.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTxFramesToWireless.setDescription('Applicable to all units. \n             The number of frames transmitted to the wireless media.\n             The count includes one count for each data frame\n             that was transmitted successfully (excluding retransmissions),\n             and also the number of transmitted control and management frames, \n             including beacons.')
bwaVLTotalTransmittedUnicasts = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTransmittedUnicasts.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTransmittedUnicasts.setDescription('Applicable to AU/BU only.\t \n             The total number of unicast frames successfully transmitted \n             to the wireless media, excluding retransmissions.')
bwaVLTotalTransmittedConcatenatedFramesDouble = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesDouble.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesDouble.setDescription('Applicable to all products.\t \n             The total number of double concatenated frames successfully transmitted \n             to the wireless media, excluding retransmissions.')
bwaVLTotalTransmittedConcatenatedFramesSingle = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesSingle.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesSingle.setDescription('Applicable to all products.\t \n             The total number of double concatenated frames successfully transmitted \n             to the wireless media, excluding retransmissions.')
bwaVLTotalTransmittedConcatenatedFramesMore = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesMore.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTransmittedConcatenatedFramesMore.setDescription('Applicable to all products.\t \n             The total number of concatenated frames with more then two frames successfully \n             transmitted to the wireless media, excluding retransmissions.')
bwaVLTotalRxFramesFromWireless = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxFramesFromWireless.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxFramesFromWireless.setDescription('Applicable to all units. \n             The total number of frames that were received\n             from the wireless media.\n             The count includes data and control and management\n             frames, including beacons received from the AU/BU.\n             The count does not include frames that were discarded\n             internally, bad frames and duplicate frames.')
bwaVLTotalRetransmittedFrames = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRetransmittedFrames.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRetransmittedFrames.setDescription('Applicable to all units. \n             The total number of retransmissions of data frames \n             (counts all unsuccessful transmissions/retransmissions).')
bwaVLFramesDropped = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFramesDropped.setStatus('current')
if mibBuilder.loadTexts: bwaVLFramesDropped.setDescription('Applicable to all units. \n             The number of dropped frames.\n             The frames that were retransmitted to the extent\n             of the maximum allowed number of retransmissions\n             without being acknowledged..')
bwaVLDataFramesSubmittedToBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 5))
bwaVLFramesSubmittedViaHighQueue = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaHighQueue.setStatus('current')
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaHighQueue.setDescription('Applicable to all units. \n             Frames submitted to the internal bridge via the High priority queue. \n             for transmission to the wireless media.')
bwaVLFramesSubmittedViaMidQueue = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaMidQueue.setStatus('current')
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaMidQueue.setDescription('Applicable to all units. \n             Frames submitted to the internal bridge via the Mid priority queue \n             for transmission to the wireless media.')
bwaVLFramesSubmittedViaLowQueue = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaLowQueue.setStatus('current')
if mibBuilder.loadTexts: bwaVLFramesSubmittedViaLowQueue.setDescription('Applicable to all units. \n             Frames submitted to the internal bridge via the Low priority queue \n             for transmission to the wireless media.')
bwaVLTotalNoOfDataFramesSubmitted = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalNoOfDataFramesSubmitted.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalNoOfDataFramesSubmitted.setDescription('Applicable to all units. \n             The total number of data frames submitted to the internal bridge \n             for transmission to the wireless media.')
bwaVLTotalRecievedDataFrames = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRecievedDataFrames.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRecievedDataFrames.setDescription('Applicable to all units. \n             The total number of data frames received from the\n             wireless media, including duplicate frames.')
bwaVLRecievedBadFrames = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRecievedBadFrames.setStatus('current')
if mibBuilder.loadTexts: bwaVLRecievedBadFrames.setDescription('Applicable to all units. \n             The number of frames received from the wireless\n             media with errors (CRC errors).')
bwaVLNoOfDuplicateFramesDiscarded = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNoOfDuplicateFramesDiscarded.setStatus('current')
if mibBuilder.loadTexts: bwaVLNoOfDuplicateFramesDiscarded.setDescription('Applicable to all units. \n             The number of frames discarded due to receiving multiple copies.')
bwaVLNoOfInternallyDiscardedMirCir = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNoOfInternallyDiscardedMirCir.setStatus('current')
if mibBuilder.loadTexts: bwaVLNoOfInternallyDiscardedMirCir.setDescription('Applicable to all units. \n            The number of data frames received from the Ethernet port that were \n            discarded by the MIR/CIR mechanism either to avoid exceeding the \n            maximum allowed information rate, or when the wireless link conditions \n            do not enable reaching the allowed rate.')
bwaVLTotalRxConcatenatedFramesDouble = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesDouble.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesDouble.setDescription('Applicable to all units.\n            The total number of double concatenated frames received \n            from the wireless media, including duplicate frames.')
bwaVLTotalRxConcatenatedFramesSingle = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesSingle.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesSingle.setDescription('Applicable to all units. \n             The total number of data fast frames single concatenated \n             frames received from the wireless media, including duplicate frames.')
bwaVLTotalRxConcatenatedFramesMore = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 3, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesMore.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxConcatenatedFramesMore.setDescription('Applicable to all units. \n             The total number of data fast frames concatenated with more then two \n             frames received from the wireless media, including duplicate frames.')
bwaVLTxEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1))
bwaVLDroppedFrameEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDroppedFrameEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLDroppedFrameEvents.setDescription('Applicable to all units. \n\t\t\t The number of frames that were dropped because they were retransmitted\n\t\t\t to the maximum allowed number of retransmissions without being \n\t\t\t acknowledged.')
bwaVLFramesDelayedDueToSwRetry = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLFramesDelayedDueToSwRetry.setStatus('current')
if mibBuilder.loadTexts: bwaVLFramesDelayedDueToSwRetry.setDescription('Applicable to all units. \n             Not applicable for units with SW Version 3.0 and higher.\n             The number of frames that were delayed because the SW retry \n             algorithm was activated on a previous frame designated for the \n             same recipient.')
bwaVLUnderrunEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUnderrunEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnderrunEvents.setDescription('Applicable to all units. \n             The number of frames whose transmission was aborted because the rate\n             of submitting frames for transmission exceeded the available \n             transmission capability.')
bwaVLOthersTxEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLOthersTxEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLOthersTxEvents.setDescription('Applicable to all units. \n             The number of Tx events due to problems other than those of \n             the other Tx Events counters.')
bwaVLTotalTxEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalTxEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalTxEvents.setDescription('Applicable to all units. \n             The total number of Tx special events.')
bwaVLRxEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2))
bwaVLPhyErrors = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLPhyErrors.setStatus('current')
if mibBuilder.loadTexts: bwaVLPhyErrors.setDescription('Applicable to all units, only when DFS is enabled. \n             The number of unidentified signals.')
bwaVLCRCErrors = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLCRCErrors.setStatus('current')
if mibBuilder.loadTexts: bwaVLCRCErrors.setDescription('Applicable to all units. \n             The number of frames received from the wireless media containing \n             CRC errors.')
bwaVLOverrunEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLOverrunEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLOverrunEvents.setDescription('Applicable to all units. \n             The number of frames that were discarded because the receive \n             rate exceeded the processing capability or the capacity of the \n             Ethernet port.')
bwaVLRxDecryptEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLRxDecryptEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLRxDecryptEvents.setDescription('Applicable to all units. \n             The number of frames that were not received properly due to a \n             problem in the data decryption mechanism.')
bwaVLTotalRxEvents = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 2, 4, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTotalRxEvents.setStatus('current')
if mibBuilder.loadTexts: bwaVLTotalRxEvents.setDescription('Applicable to all units. \n             The total number of Rx special events.')
bwaVLMacAddressDatabase = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5))
bwaVLAUMacAddressDatabase = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1))
bwaVLAUAdbResetAllModulationLevelCounters = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLAUAdbResetAllModulationLevelCounters.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUAdbResetAllModulationLevelCounters.setDescription('Applicable to AU/BU only. \n\t   To reset all the counters for all SUs/RB in the MAC Address Database.')
bwaVLAUAdbTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2), )
if mibBuilder.loadTexts: bwaVLAUAdbTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUAdbTable.setDescription('Applicable to AU/BU only. \n       AU/BU MAC Address Database table.')
bwaVLAUAdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLAdbIndex"))
if mibBuilder.loadTexts: bwaVLAUAdbEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUAdbEntry.setDescription('Applicable to AU/BU only. \n       An entry in the AU/BU MAC Address Database table.')
bwaVLAdbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbIndex.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbIndex.setDescription('Applicable to AU/BU only. \n\t   The index of an entry in the AU/BU MAC Address Database table.')
bwaVLAdbMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbMacAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbMacAddress.setDescription('Applicable to AU/BU only. \n\t   The MAC Address of an SU/RB entry in the MAC Address Database \n\t   table.')
bwaVLAdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("associated", 1), ("authenticated", 2), ("notAuthenticated", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbStatus.setDescription('Applicable to AU/BU only. \n\t   The status of the relevant SU/RB.')
bwaVLAdbSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbSwVersion.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbSwVersion.setDescription('Applicable to AU/BU only. \n\t   The SW version of the relevant SU/RB.')
bwaVLAdbSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbSNR.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbSNR.setDescription('Applicable to AU/BU only. \n\t   The average Signal to Noise Ratio in dB of frames received by \n\t   the AU/BU from the relevant SU/RB.')
bwaVLAdbMaxModulationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("modLevel-1", 1), ("modLevel-2", 2), ("modLevel-3", 3), ("modLevel-4", 4), ("modLevel-5", 5), ("modLevel-6", 6), ("modLevel-7", 7), ("modLevel-8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbMaxModulationLevel.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbMaxModulationLevel.setDescription('Applicable to AU/BU only. \n\t   The value configured in the relevant SU/RB for the Maximum Modulation \n\t   Level parameter.\n\t   Modulation Level 8 is not applicable for units with HW revision A.')
bwaVLAdbTxFramesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFramesTotal.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFramesTotal.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast  frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link.')
bwaVLAdbDroppedFramesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbDroppedFramesTotal.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbDroppedFramesTotal.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of frames intended to the SU/RB that \n\t   were dropped because they were retransmitted to the extent \n\t   of the maximum allowed number of retransmissions without \n\t   being acknowledged.')
bwaVLAdbTxSuccessModLevel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel1.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel1.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 1.')
bwaVLAdbTxSuccessModLevel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel2.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel2.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 2.')
bwaVLAdbTxSuccessModLevel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel3.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel3.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/BU over the wireless link \n\t   using modulation level 3.')
bwaVLAdbTxSuccessModLevel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel4.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel4.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 4.')
bwaVLAdbTxSuccessModLevel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel5.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel5.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 5.')
bwaVLAdbTxSuccessModLevel6 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel6.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel6.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/BU over the wireless link \n\t   using modulation level 6.')
bwaVLAdbTxSuccessModLevel7 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel7.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel7.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 7.')
bwaVLAdbTxSuccessModLevel8 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel8.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxSuccessModLevel8.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of unicast frames (excluding retransmissions) \n\t   that were successfully transmitted to the SU/RB over the wireless link \n\t   using modulation level 8.\n\t   Not applicable for units with HW revision A.')
bwaVLAdbTxFailedModLevel1 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel1.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel1.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 1.')
bwaVLAdbTxFailedModLevel2 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel2.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel2.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 2.')
bwaVLAdbTxFailedModLevel3 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel3.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel3.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 3.')
bwaVLAdbTxFailedModLevel4 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel4.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel4.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 4.')
bwaVLAdbTxFailedModLevel5 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel5.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel5.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 5.')
bwaVLAdbTxFailedModLevel6 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel6.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel6.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 6.')
bwaVLAdbTxFailedModLevel7 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel7.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel7.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 7.')
bwaVLAdbTxFailedModLevel8 = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel8.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbTxFailedModLevel8.setDescription('Applicable to AU/BU only. \n\t   Counts the total number of failures to successfully\n\t   transmit unicast frames intended to the SU/RB using modulation level 8.\n\t   Not applicable for units with HW revision A.')
bwaVLAdbCirTx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbCirTx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbCirTx.setDescription('Applicable to AU Only. \n    Not applicable to BWA-PtP products. Read-only. \n    The value configured in the relevant SU for the CIR: \n    SU to AU parameter.')
bwaVLAdbMirTx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbMirTx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbMirTx.setDescription('Applicable to AU/BU only. \n    The value configured in the relevant SU/RB for the MIR: \n    SU/RB to AU/BU parameter.')
bwaVLAdbCirRx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbCirRx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbCirRx.setDescription('Applicable to AU Only.\n    Not applicable to BWA-PtP products.\n    The value configured in the relevant SU for the CIR: \n    AU to SU parameter.')
bwaVLAdbMirRx = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbMirRx.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbMirRx.setDescription('Applicable to AU/BU only. \n    The value configured in the relevant SU/RB for the MIR: \n    AU/BU to SU/RB parameter.')
bwaVLAdbCirMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbCirMaxDelay.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbCirMaxDelay.setDescription('Applicable to AU Only. \n    Not applicable to BWA-PtP products.\n    The value configured in the relevant SU for the CIR Maximum \n    Delay parameter.')
bwaVLAdbDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("below-2-Km", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbDistance.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbDistance.setDescription('Applicable to AU/BU Only.  \n    The distance between the SU/RB and the AU/BU (In Kilometers).')
bwaVLAdbHwRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("hwRevisionA", 1), ("hwRevisionB", 2), ("hwRevisionC", 3), ("hwRevisionD", 4), ("hwRevisionE", 5), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbHwRevision.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbHwRevision.setDescription('Applicable to AU/BU Only.  \n    The SU/RB HW Revision.')
bwaVLAdbCpldVer = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 32), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbCpldVer.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbCpldVer.setDescription('Applicable to AU/BU Only.  \n    The SU/RB CPLD Version.')
bwaVLAdbCountryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbCountryCode.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbCountryCode.setDescription('Applicable to AU/BU Only.  \n    The SU/RB supported country code.')
bwaVLAdbBootVer = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 34), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbBootVer.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbBootVer.setDescription('Applicable to AU/BU Only.  \n    The SU/RB Boot Version.')
bwaVLAdbAtpcOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbAtpcOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbAtpcOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB ATPC option configuration.')
bwaVLAdbAdapModOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbAdapModOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbAdapModOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB adaptive modulation option configuration.')
bwaVLAdbBurstModeOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbBurstModeOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbBurstModeOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB burst mode option configuration.')
bwaVLAdbConcatenationOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbConcatenationOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbConcatenationOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB concatenation option configuration.')
bwaVLAdbSecurityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("wep", 1), ("aes", 2), ("fips197", 3), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbSecurityMode.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbSecurityMode.setDescription('Applicable to AU/BU Only.  \n    The SU/RB security mode configuration.')
bwaVLAdbAuthOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("openSystem", 1), ("sharedKey", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbAuthOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbAuthOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB authentication algorithm configuration.')
bwaVLAdbDataEncyptOption = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2), ("na", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbDataEncyptOption.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbDataEncyptOption.setDescription('Applicable to AU/BU Only.  \n    The SU/RB data encryption option configuration.')
bwaVLAdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbAge.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbAge.setDescription('Applicable to AU/BU only. \n\t   The time since any packet was received from the relevant SU/RB.')
bwaVLAdbUnitName = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 5, 1, 2, 1, 45), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLAdbUnitName.setStatus('current')
if mibBuilder.loadTexts: bwaVLAdbUnitName.setDescription('Applicable to AU/BU only. \n\t   The unit name of the relevant SU/RB.')
bwaVLUpLinkQualityIndicator = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 6))
bwaVLMeasureUpLinkQualityIndicator = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bwaVLMeasureUpLinkQualityIndicator.setStatus('current')
if mibBuilder.loadTexts: bwaVLMeasureUpLinkQualityIndicator.setDescription('Applicable to SU/RB. \n\t   Starts calculation of LQI. \n\t   The calculation will be for a period of 10 seconds.')
bwaVLReadUpLinkQualityIndicator = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLReadUpLinkQualityIndicator.setStatus('current')
if mibBuilder.loadTexts: bwaVLReadUpLinkQualityIndicator.setDescription('Applicable to SU/RB. \n\t   The results of the last LQI calculation. \n\t   Range: 1 to 8.')
bwaVLUpLinkQualityIndicatorStatus = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fullTest", 1), ("limitedTest", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLUpLinkQualityIndicatorStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLUpLinkQualityIndicatorStatus.setDescription('Applicable to SU/RB Only. \n\t   Indicates the test conditions. \n\t   fullTest means that there are no limitations \n\t   on the range of available modulation levels, and that all modulation levels \n\t   from 1 to 8 can be used. \n\t   limitedTest indicates that the results may not indicate the true quality since \n\t   the available range is limited - by HW (HW Revision A), \n\t   or by the applicable parameters in the country code, \n\t   or by the configurable Maximum Modulation Level parameter.')
bwaVLMacPinpoint = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 7))
bwaVLMacPinpointTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 7, 1), )
if mibBuilder.loadTexts: bwaVLMacPinpointTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacPinpointTable.setDescription('Applicable to AU/BU only.\n                      A table that contains information about wireless device\n                      used by a certain Ethernet station in order to\n                      connect to the wireless network')
bwaVLMacPinpointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 7, 1, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "mptEthernetStationMACAddress"))
if mibBuilder.loadTexts: bwaVLMacPinpointEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLMacPinpointEntry.setDescription('Applicable to AU/BU only. An entry in the MAC Pinpoint Table.\n                      Each entry contains an Ethernet station MAC address and the MAC\n                      address of the wireless device used to connect it to the wireless \n                      network')
mptEthernetStationMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 7, 1, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mptEthernetStationMACAddress.setStatus('current')
if mibBuilder.loadTexts: mptEthernetStationMACAddress.setDescription('Applicable to AU/BU only.\n                      The MAC address of the Ethernet station. It is used as an \n                      index in the MAC Pinpoint Table.')
mptUnitMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 7, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mptUnitMACAddress.setStatus('current')
if mibBuilder.loadTexts: mptUnitMACAddress.setDescription('Applicable to AU/BU only. The MAC address of the wireless \n                      device used by the station with the MAC Address from the \n                      index in order to access the wireless network.')
bwaVLDrapGatewaysTable = MibTable((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8), )
if mibBuilder.loadTexts: bwaVLDrapGatewaysTable.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewaysTable.setDescription('This table provides information about Gateways supporting DRAP that are\n\t\tregistered at the AU')
bwaVLDrapGatewayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8, 1), ).setIndexNames((0, "BWA-DOT11-WLAN-MIB", "bwaVLDrapGatewayIndex"))
if mibBuilder.loadTexts: bwaVLDrapGatewayEntry.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewayEntry.setDescription('A Drap Gateway Entry.')
bwaVLDrapGatewayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDrapGatewayIndex.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewayIndex.setDescription("Gateway Entry's Index")
bwaVLDrapGatewayIP = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDrapGatewayIP.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewayIP.setDescription('The IP address of the Gateway')
bwaVLDrapGatewayType = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 11, 255))).clone(namedValues=NamedValues(("vgDataVoice", 4), ("vgData1Voice1", 5), ("vgData4Voice2", 6), ("vgDataVoice2", 7), ("ngData4Wireless", 11), ("vgUnknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDrapGatewayType.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewayType.setDescription('The Gateway type')
bwaVLDrapGatewayNoOfActiveVoiceCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 12394, 1, 1, 11, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDrapGatewayNoOfActiveVoiceCalls.setStatus('current')
if mibBuilder.loadTexts: bwaVLDrapGatewayNoOfActiveVoiceCalls.setDescription('The current number of active voice calls handled by the Gateway')
bwaVLTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14))
bwaVLTrapSUMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapSUMacAddr.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapSUMacAddr.setDescription('Applicable to AU/BU only.\n     SU/RB MAC Address.')
bwaVLTrapText = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapText.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapText.setDescription('Textual string for future use.')
bwaVLTrapToggle = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapToggle.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapToggle.setDescription('Applicable to all units.\n     An On/Off toggle status.')
bwaVLTrapParameterChanged = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("cirOrMir", 1), ("ipFilter", 2), ("vlan", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapParameterChanged.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapParameterChanged.setDescription('Applicable to all units.\n     A modification to one of the parameters related to CIR/MIR,  \n     IP Filtering or VLAN.')
bwaVLTrapAccessRights = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notLoggedIn", 1), ("readOnly", 2), ("installer", 3), ("administrator", 4), ("factory", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapAccessRights.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapAccessRights.setDescription('Applicable to all units.\n     The access rights used for login.')
bwaVLTrapLog = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("telnetLogin", 3), ("telnetLogout", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapLog.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapLog.setDescription('Applicable to all units.\n     Login or logout to the Monitor program via Telnet.')
bwaVLTrapTelnetUserIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapTelnetUserIpAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapTelnetUserIpAddress.setDescription('Applicable to all units.\n     The IP address of a Telnet user.')
bwaVLTrapRTx = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapRTx.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapRTx.setDescription('Applicable to AU/BU only. \n     Retransmissions as a percentage of total transmissions.')
bwaVLTrapFtpOrTftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("successful", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapFtpOrTftpStatus.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapFtpOrTftpStatus.setDescription('Applicable to all units.\n     The status of the last FTP/TFTP loading procedure.')
bwaVLDFSMoveFreq = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSMoveFreq.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSMoveFreq.setDescription('Applicable to AU/BU with HW revision B and lower \n     (for units with HW revision C and higher replaced by \n     bwaVLTrapDFSMoveFreq New to support a resolution of 0.5 MHz). \n     The new frequency in MHz after detecting radar on a previous channel.')
bwaVLDFSMoveFreqNew = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLDFSMoveFreqNew.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSMoveFreqNew.setDescription('Applicable to AU/BU. \n     The new frequency in MHz after detecting radar on a previous channel. \n     (Replaces bwaVLDFSMoveFreq to support a resolution of 0.5 MHz for \n     units with HW revision C and higher).')
bwaVLEthBroadcastThresholdExceeded = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLEthBroadcastThresholdExceeded.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastThresholdExceeded.setDescription('Applicable to all units. \n    The number of packets that are dropped by the ethernet broadcast/multicast limiter.')
bwaVLTrapSubscriberType = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 6, 14, 24, 28, 54, 100))).clone(namedValues=NamedValues(("unknownSubscriberType", 0), ("su-3", 3), ("su-6", 6), ("rb-14", 14), ("su-24", 24), ("rb-28", 28), ("su-54", 54), ("rb-100", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapSubscriberType.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapSubscriberType.setDescription('Applicable to AUS only.\n    The type of subscriber that was rejected by AUS')
bwaVLTrapMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 15), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapMACAddress.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapMACAddress.setDescription('Applicable to BU/RB only.\n    The MAC address of the BWA PtP unit whose type has been changed')
bwaVLNewUnitTypeTrap = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bu", 1), ("rb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLNewUnitTypeTrap.setStatus('current')
if mibBuilder.loadTexts: bwaVLNewUnitTypeTrap.setDescription('Applicable to BU/RB only.\n    The new type of the BWA PtP unit.')
bwaVLTrapSWVersion = MibScalar((1, 3, 6, 1, 4, 1, 12394, 1, 1, 14, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bwaVLTrapSWVersion.setStatus('current')
if mibBuilder.loadTexts: bwaVLTrapSWVersion.setDescription('The SW version of the SU that tries to associate \n    with a station that has Wireless Link Prioritization Enabled')
bwaVLSUassociatedAUTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 2)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapSUMacAddr"))
if mibBuilder.loadTexts: bwaVLSUassociatedAUTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUassociatedAUTRAP.setDescription('An AU/BU trap indicating a new association with an SU/RB.')
bwaVLAUdisassociatedTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 3)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapSUMacAddr"))
if mibBuilder.loadTexts: bwaVLAUdisassociatedTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUdisassociatedTRAP.setDescription('An AU/BU trap indicating that an SU/RB has been disassociated \n         from the AU.\n         The AU/BU decides that an SU/RB has been disassociated from it and remove it\n         from the ADB after receiving from another AU/BU a SNAP frame with the SU/RB \n         MAC address.\n         The SNAP frame indicating a network topology change where the SU/RB has \n         associated with another AU/BU will be received if both AUs/BUs are \n         connected to the same Ethernet backbone.')
bwaVLAUagingTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 4)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapSUMacAddr"))
if mibBuilder.loadTexts: bwaVLAUagingTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUagingTRAP.setDescription('An AU/BU trap indicating that the unit association was aged out\n\t     and removed from the Association database following its failure\n\t     to acknowledge a specified number of consecutive frames.')
bwaVLSUassociatedTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 6)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLAssociatedAU"))
if mibBuilder.loadTexts: bwaVLSUassociatedTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLSUassociatedTRAP.setDescription('An SU/RB trap indicating association with an AU/BU. \n         In addition to the MAC address information of the AU/BU, the \n         trap also includes information on the average SNR of frames \n         received from the AU/BU.')
bwaVLAUwirelessQualityTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 20)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapToggle"), ("BWA-DOT11-WLAN-MIB", "bwaVLTrapRTx"))
if mibBuilder.loadTexts: bwaVLAUwirelessQualityTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUwirelessQualityTRAP.setDescription('An AU/BU trap, indicating that the quality of the wireless \n         link (retransmissions rate) has changed and dropped below (Off) or increased  \n         above (On) a threshold , defined by the *bwaVLWirelessTrapThreshold. \n         The threshold for AU/BU is a percentage of retransmissions.')
bwaVLPowerUpFromReset = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 101)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLUnitMacAddress"))
if mibBuilder.loadTexts: bwaVLPowerUpFromReset.setStatus('current')
if mibBuilder.loadTexts: bwaVLPowerUpFromReset.setDescription('An AU/BU trap indicating power up after Reset.')
bwaVLTelnetStatusTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 102)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapLog"), ("BWA-DOT11-WLAN-MIB", "bwaVLTrapAccessRights"), ("BWA-DOT11-WLAN-MIB", "bwaVLTrapTelnetUserIpAddress"))
if mibBuilder.loadTexts: bwaVLTelnetStatusTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLTelnetStatusTRAP.setDescription('Applicable to all units.\n         A trap indicating that a log-in or log-out has been performed \n         via Telnet. Includes the log-in access \n         right and the IP address of the PC performing Telnet.')
bwaVLParameterChangedTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 103)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapParameterChanged"))
if mibBuilder.loadTexts: bwaVLParameterChangedTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLParameterChangedTRAP.setDescription('Applicable to all units. A trap indicating a change in a CIR/MIR, IP Filter \n         or VLAN parameter.')
bwaVLLoadingStatusTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 104)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapFtpOrTftpStatus"), ("BWA-DOT11-WLAN-MIB", "bwaVLUnitMacAddress"))
if mibBuilder.loadTexts: bwaVLLoadingStatusTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLLoadingStatusTRAP.setDescription('Applicable to all units.\n         A trap indicating that last FTP/TFTP loading process has been \n         finished successfully or failed. ')
bwaVLPromiscuousModeTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 105)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapToggle"), ("BWA-DOT11-WLAN-MIB", "bwaVLUnitMacAddress"))
if mibBuilder.loadTexts: bwaVLPromiscuousModeTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLPromiscuousModeTRAP.setDescription('An AU/BU trap, indicating that the AU/BU In (On) Promiscuous Mode or \n         out (Off) Promiscuous Mode.')
bwaVLDFSRadarDetecetedTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 106))
if mibBuilder.loadTexts: bwaVLDFSRadarDetecetedTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSRadarDetecetedTRAP.setDescription('DFS: Applicable to AU/BU only.\n         A trap indicating that a radar was detected. ')
bwaVLDFSFrequcnyTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 107)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLDFSMoveFreq"), ("BWA-DOT11-WLAN-MIB", "bwaVLDFSMoveFreqNew"))
if mibBuilder.loadTexts: bwaVLDFSFrequcnyTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSFrequcnyTRAP.setDescription('Applicable to AU/BU only.\n         A trap indicating that the unit moved to a new frequency. ')
bwaVLDFSNoFreeChannelsExistsTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 108))
if mibBuilder.loadTexts: bwaVLDFSNoFreeChannelsExistsTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLDFSNoFreeChannelsExistsTRAP.setDescription('Applicable to AU/BU only.\n         A trap indicating that a radar was detected and there is no \n         free channel. ')
bwaVLEthBroadcastMulticatLimiterTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 109)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLEthBroadcastThresholdExceeded"))
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticatLimiterTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLEthBroadcastMulticatLimiterTRAP.setDescription('Applicable to all units. The trap is send if the \n\t\tethernet broadcast filter threshold is exceeded\n\t\tand it contains the number of dropped packets.')
bwaVLAUSUnsupportedSubscriberTypeTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 110)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapSUMacAddr"), ("BWA-DOT11-WLAN-MIB", "bwaVLTrapSubscriberType"))
if mibBuilder.loadTexts: bwaVLAUSUnsupportedSubscriberTypeTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLAUSUnsupportedSubscriberTypeTRAP.setDescription('Applicable to AUS only.\n\t\tThis trap is generated when a subscriber with unsupported type tries to associate to AUS.\n\t\tThe AUS supports only SU-3 and SU-6.\n\t\tThe first variable of the trap is the subscriber MAC Address.\n\t\tThe second variable is the type of subscriber')
bwaVLUnitTypeChangedTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 111)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapMACAddress"), ("BWA-DOT11-WLAN-MIB", "bwaVLNewUnitTypeTrap"))
if mibBuilder.loadTexts: bwaVLUnitTypeChangedTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLUnitTypeChangedTRAP.setDescription('Applicable to BU/RB only.\n\t\tThis trap is generated when the user change the type of the BWA PtP unit.\n\t\tThe RB can be converted in BU or vice versa.\n\t\tThe first variable of the trap is the unit MAC Address.\n\t\tThe second variable is the new type of the unit')
bwaVLWLPrioritizationNotSupportedBySUTRAP = NotificationType((1, 3, 6, 1, 4, 1, 12394, 4, 1, 3, 112)).setObjects(("BWA-DOT11-WLAN-MIB", "bwaVLTrapSUMacAddr"), ("BWA-DOT11-WLAN-MIB", "bwaVLTrapSWVersion"))
if mibBuilder.loadTexts: bwaVLWLPrioritizationNotSupportedBySUTRAP.setStatus('current')
if mibBuilder.loadTexts: bwaVLWLPrioritizationNotSupportedBySUTRAP.setDescription('Applicable to AU/BU only.\n         This trap is generated when an SU/RB with a SW version below 4.0 \n         that does not support Wireless Link Prioritization is associated \n         with an AU/BU with thw Wireless Link Prioritization Option enabled. \n\t\t The first variable of the trap is the SU/RB MAC Address.\n\t\t The second variable is the SW version of the SU/RB')
mibBuilder.exportSymbols("BWA-DOT11-WLAN-MIB", bwaVLVlanRelayingTableIdx=bwaVLVlanRelayingTableIdx, bwaVLAdbTxFailedModLevel7=bwaVLAdbTxFailedModLevel7, bwaVLUnitName=bwaVLUnitName, bwaVLBestAuNoOfScanningAttempts=bwaVLBestAuNoOfScanningAttempts, bwaVLTcpPortRangeIdx=bwaVLTcpPortRangeIdx, bwaVLSpectrumAnalysisInformationChannel=bwaVLSpectrumAnalysisInformationChannel, bwaVLFlashMemoryControl=bwaVLFlashMemoryControl, bwaVLSoftwareRetrySupport=bwaVLSoftwareRetrySupport, bwaVLTotalTransmittedConcatenatedFramesDouble=bwaVLTotalTransmittedConcatenatedFramesDouble, bwaVLFrequencyDefinition=bwaVLFrequencyDefinition, bwaVLAverageReceiveSNR=bwaVLAverageReceiveSNR, bwaVLAU_SA=bwaVLAU_SA, bwaVLAUwirelessQualityTRAP=bwaVLAUwirelessQualityTRAP, bwaVLTxFramesToWireless=bwaVLTxFramesToWireless, bwaVLUnitPasswords=bwaVLUnitPasswords, bwaVLTotalRetransmittedFrames=bwaVLTotalRetransmittedFrames, bwaVLTotalRxFramesViaEthernet=bwaVLTotalRxFramesViaEthernet, bwaVLSUPerModulationLevelCountersTableIdx=bwaVLSUPerModulationLevelCountersTableIdx, bwaVLAutoSubBandFrequencySubsetFrequencyIdx=bwaVLAutoSubBandFrequencySubsetFrequencyIdx, bwaVLMaximumTransmitPowerTable=bwaVLMaximumTransmitPowerTable, bwaVLCurrentEthernetPortState=bwaVLCurrentEthernetPortState, bwaVLMeasuredCellDistance=bwaVLMeasuredCellDistance, bwaVLSaveCurrentConfigurationAsOperatorDefaults=bwaVLSaveCurrentConfigurationAsOperatorDefaults, bwaVLWirelessTrapThreshold=bwaVLWirelessTrapThreshold, bwaVLSetDefaults=bwaVLSetDefaults, bwaVLDataFramesSubmittedToBridge=bwaVLDataFramesSubmittedToBridge, bwaVLNwMngIpTableIdx=bwaVLNwMngIpTableIdx, bwaVLVLANSupport=bwaVLVLANSupport, bwaVLAutoSubBandFrequencySubsetTable=bwaVLAutoSubBandFrequencySubsetTable, bwaVLUdpPortRangeEnd=bwaVLUdpPortRangeEnd, bwaVLTcpPortRangeNum=bwaVLTcpPortRangeNum, bwaVLOperatorESSIDOption=bwaVLOperatorESSIDOption, bwaVLCurrentTxPower=bwaVLCurrentTxPower, bwaVLESSID=bwaVLESSID, bwaVLDeleteAllNwIpAddrs=bwaVLDeleteAllNwIpAddrs, bwaVLSpectrumAnalysisInformationSignalWidth=bwaVLSpectrumAnalysisInformationSignalWidth, bwaVLAdbTxSuccessModLevel7=bwaVLAdbTxSuccessModLevel7, bwaVLFTPServerParams=bwaVLFTPServerParams, bwaVLCRCErrors=bwaVLCRCErrors, bwaVLTrafficPriVLAN=bwaVLTrafficPriVLAN, bwaVLDrapNoOfActiveVoiceCalls=bwaVLDrapNoOfActiveVoiceCalls, bwaVLMacAddressDenyListTableIdx=bwaVLMacAddressDenyListTableIdx, bwaVLFrequencySubsetFrequency=bwaVLFrequencySubsetFrequency, bwaVLAU=bwaVLAU, bwaVLMinContentionWindow=bwaVLMinContentionWindow, bwaVLATPC=bwaVLATPC, ptp_RB_B14=ptp_RB_B14, bwaVLTotalTransmittedConcatenatedFramesMore=bwaVLTotalTransmittedConcatenatedFramesMore, bwaVLIPPrecedenceThreshold=bwaVLIPPrecedenceThreshold, bwaVLAuthenticationAlgorithm=bwaVLAuthenticationAlgorithm, bwaVLProducts=bwaVLProducts, bwaVLBurstInterval=bwaVLBurstInterval, bwaVLTrapAccessRights=bwaVLTrapAccessRights, bwaVLEthernetPortControl=bwaVLEthernetPortControl, bwaVLUnitType=bwaVLUnitType, bwaVLVlanForwardingEntry=bwaVLVlanForwardingEntry, bwaVLTcpPortRangeAdd=bwaVLTcpPortRangeAdd, bwaVLAdbTxFailedModLevel2=bwaVLAdbTxFailedModLevel2, bwaVLDFSChannelReuseParameters=bwaVLDFSChannelReuseParameters, bwaVLTransmitPowerTable=bwaVLTransmitPowerTable, bwaVLRoamingOption=bwaVLRoamingOption, bwaVLMacPinpointTable=bwaVLMacPinpointTable, bwaVLMngIpRangesTable=bwaVLMngIpRangesTable, bwaVLServiceParameters=bwaVLServiceParameters, bwaVLAccessToNwTrap=bwaVLAccessToNwTrap, bwaVLAdbCirMaxDelay=bwaVLAdbCirMaxDelay, bwaVLAtpcOption=bwaVLAtpcOption, MacAddress=MacAddress, bwaVLDrapMaxNumberOfVoiceCalls=bwaVLDrapMaxNumberOfVoiceCalls, bwaVLDFSParameters=bwaVLDFSParameters, bwaVLAdaptiveModulationAlgorithmOption=bwaVLAdaptiveModulationAlgorithmOption, bwaVLAdbAdapModOption=bwaVLAdbAdapModOption, bwaVLAdbIndex=bwaVLAdbIndex, bwaVLMacAddressDenyListAdd=bwaVLMacAddressDenyListAdd, bwaVLConcatenationParameters=bwaVLConcatenationParameters, bwaVLVLANTrafficPriority=bwaVLVLANTrafficPriority, bwaVLMaxNumOfAssociationsLimit=bwaVLMaxNumOfAssociationsLimit, bwaVLMngIpRangeFlag=bwaVLMngIpRangeFlag, bwaVLBurstModeSupport=bwaVLBurstModeSupport, bwaVLAutoSubBandFrequencySubsetFrequency=bwaVLAutoSubBandFrequencySubsetFrequency, bwaVLAutoSubBandFrequencySubsetBandIdx=bwaVLAutoSubBandFrequencySubsetBandIdx, bwaVLUploadEventLogFile=bwaVLUploadEventLogFile, bwaVLSpectrumAnalysisInformationSignalCount=bwaVLSpectrumAnalysisInformationSignalCount, bwaVLAdbDroppedFramesTotal=bwaVLAdbDroppedFramesTotal, bwaVLTrapParameterChanged=bwaVLTrapParameterChanged, bwaVLRxDecryptEvents=bwaVLRxDecryptEvents, bwaVLVlanIdRelaying=bwaVLVlanIdRelaying, bwaVLAdbStatus=bwaVLAdbStatus, bwaVLMirOnlyOption=bwaVLMirOnlyOption, bwaVLSysInfo=bwaVLSysInfo, bwaVLFTPServerUserName=bwaVLFTPServerUserName, bwaVLAutoSubBandSelect=bwaVLAutoSubBandSelect, bwaVLSubBandSelect=bwaVLSubBandSelect, bwaVLTcpPortRangeConfig=bwaVLTcpPortRangeConfig, bwaVLAUBeaconsToWireless=bwaVLAUBeaconsToWireless, bwaVLAdaptiveModulationDecisionThresholds=bwaVLAdaptiveModulationDecisionThresholds, bwaVLAdbTxFailedModLevel6=bwaVLAdbTxFailedModLevel6, bwaVLDataAndOtherMngFramesToWireless=bwaVLDataAndOtherMngFramesToWireless, bwaVLBestAu=bwaVLBestAu, bwaVLAuthenticationEncryptionSupport=bwaVLAuthenticationEncryptionSupport, bwaVLNeighborAuBurstModeOption=bwaVLNeighborAuBurstModeOption, bwaVLEventLogFileParams=bwaVLEventLogFileParams, bwaVLHardwareRetries=bwaVLHardwareRetries, bwaVLPowerLevelSteps=bwaVLPowerLevelSteps, bwaVLBurstMode=bwaVLBurstMode, bwaVLAdbTxFramesTotal=bwaVLAdbTxFramesTotal, bwaVLMainVersionNumber=bwaVLMainVersionNumber, bwaVLHWRetriesLowPriority=bwaVLHWRetriesLowPriority, bwaVLMaxContentionWindow=bwaVLMaxContentionWindow, bwaVLAdminPassword=bwaVLAdminPassword, bwaVLTxEvents=bwaVLTxEvents, bwaVLKey4=bwaVLKey4, bwaVLNoOfInternallyDiscardedMirCir=bwaVLNoOfInternallyDiscardedMirCir, bwaVLAdbMaxModulationLevel=bwaVLAdbMaxModulationLevel, bwaVLTotalRxConcatenatedFramesDouble=bwaVLTotalRxConcatenatedFramesDouble, bwaVLFTPConfigurationFileSourceDir=bwaVLFTPConfigurationFileSourceDir, bwaVLAdbConcatenationOption=bwaVLAdbConcatenationOption, bwaVLChangeUnitType=bwaVLChangeUnitType, bwaVLRxEvents=bwaVLRxEvents, bwaVLAutomaticChannelSelection=bwaVLAutomaticChannelSelection, bwaVLFTPGatewayIpAddress=bwaVLFTPGatewayIpAddress, bwaVLAU_EZ=bwaVLAU_EZ, bwaVLTransmitPowerIdx=bwaVLTransmitPowerIdx, bwaVLApplicableModulationLevel=bwaVLApplicableModulationLevel, bwaVLIpFilterRange=bwaVLIpFilterRange, bwaVLKey2=bwaVLKey2, bwaVLDataEncryptionOption=bwaVLDataEncryptionOption, bwaVLRunningFrom=bwaVLRunningFrom, bwaVLFramesSubmittedViaMidQueue=bwaVLFramesSubmittedViaMidQueue, bwaVLNeighborAuSNR=bwaVLNeighborAuSNR, bwaVLDrapGatewayEntry=bwaVLDrapGatewayEntry, bwaVLDHCPUnicastOverrideFilter=bwaVLDHCPUnicastOverrideFilter, bwaVLCurrentFrequencySubsetFrequency=bwaVLCurrentFrequencySubsetFrequency, bwaVLTrafficPriIPToS=bwaVLTrafficPriIPToS, bwaVLAdbDataEncyptOption=bwaVLAdbDataEncyptOption, bwaVLResetTrafficCounters=bwaVLResetTrafficCounters, bwaVLTrafficPriUdpTcpPortRange=bwaVLTrafficPriUdpTcpPortRange, bwaVLBroadcastRelaying=bwaVLBroadcastRelaying, bwaVLTrapMACAddress=bwaVLTrapMACAddress, bwaVLCurrentFrequencySubsetTable=bwaVLCurrentFrequencySubsetTable, bwaVLEventLogDestinationDir=bwaVLEventLogDestinationDir, bwaVLMngIpRangeEntry=bwaVLMngIpRangeEntry, bwaVLTelnetStatusTRAP=bwaVLTelnetStatusTRAP, bwaVLAvgSNRMemoryFactor=bwaVLAvgSNRMemoryFactor, bwaVLBestAuSupport=bwaVLBestAuSupport, bwaVLTraps=bwaVLTraps, bwaVLFrequencySubsetTableIdx=bwaVLFrequencySubsetTableIdx, bwaVLConcatenationOption=bwaVLConcatenationOption, bwaVLTimeSinceLastReset=bwaVLTimeSinceLastReset, bwaVLMacAddressDatabase=bwaVLMacAddressDatabase, bwaVLSpectrumAnalysisInformationTableIdx=bwaVLSpectrumAnalysisInformationTableIdx, bwaVLPerformanceParams=bwaVLPerformanceParams, bwaVLTcpPortRangeDelete=bwaVLTcpPortRangeDelete, bwaVLAUdisassociatedTRAP=bwaVLAUdisassociatedTRAP, bwaVLTxWirelessToEthernet=bwaVLTxWirelessToEthernet, bwaLighteAPWorkingMode=bwaLighteAPWorkingMode, bwaVLCountryCode=bwaVLCountryCode, bwaVLMIRThresholdPercent=bwaVLMIRThresholdPercent, bwaVLTrapSubscriberType=bwaVLTrapSubscriberType, bwaVLMngIpRangeMask=bwaVLMngIpRangeMask, bwaVLAteTestResults=bwaVLAteTestResults, bwaVLRunTimeSubNetMask=bwaVLRunTimeSubNetMask, bwaVLRegulationMaxTxPowerAtAntennaPort=bwaVLRegulationMaxTxPowerAtAntennaPort, bwaVLLoadingStatus=bwaVLLoadingStatus, bwaVLAccessToDHCP=bwaVLAccessToDHCP, bwaVLDisassociateSuByMacAddress=bwaVLDisassociateSuByMacAddress, bwaVLFTPClientIPAddress=bwaVLFTPClientIPAddress, bwaVLIpID=bwaVLIpID, bwaVLAdbUnitName=bwaVLAdbUnitName, bwaVLAutoSubBandFrequencySubsetActive=bwaVLAutoSubBandFrequencySubsetActive, bwaVLUdpPortRangeNum=bwaVLUdpPortRangeNum, bwaVLVlanManagementPriority=bwaVLVlanManagementPriority, bwaVLSecurityModeSupport=bwaVLSecurityModeSupport, bwaVLSU_24_BD=bwaVLSU_24_BD, bwaVLDeltaFromMinSNRLevel=bwaVLDeltaFromMinSNRLevel, bwaVLNeighborAuMark=bwaVLNeighborAuMark, bwaVLPortsControl=bwaVLPortsControl, bwaVLBridgeParameters=bwaVLBridgeParameters, bwaVLToSPriorityParameters=bwaVLToSPriorityParameters, bwaVLExecuteFTPConfigurationFileLoading=bwaVLExecuteFTPConfigurationFileLoading, bwaVLExitTelnet=bwaVLExitTelnet, bwaVLSerialNumber=bwaVLSerialNumber, bwaVLSUBurstDurationLowPriority=bwaVLSUBurstDurationLowPriority, bwaVLAUBurstDurationHighPriority=bwaVLAUBurstDurationHighPriority, bwaVLEventLogFileName=bwaVLEventLogFileName, bwaVLDFSChannelIdx=bwaVLDFSChannelIdx, bwaVLFTPClientMask=bwaVLFTPClientMask, bwaVLAutoSubBandSelectedFreqSubset=bwaVLAutoSubBandSelectedFreqSubset, bwaVLKey3=bwaVLKey3, bwaVLNumOfSoftwareRetries=bwaVLNumOfSoftwareRetries, bwaVLDrapGatewaysTable=bwaVLDrapGatewaysTable, bwaVLMngIpRangeEnd=bwaVLMngIpRangeEnd, bwaVLUnitIpAddress=bwaVLUnitIpAddress, bwaVLMaxNumOfAssociations=bwaVLMaxNumOfAssociations, bwaOID=bwaOID, bwaVLVlanRelayingSupport=bwaVLVlanRelayingSupport, bwaVLFramesSubmittedViaHighQueue=bwaVLFramesSubmittedViaHighQueue, bwaVLDHCPBroadcastOverrideFilter=bwaVLDHCPBroadcastOverrideFilter, bwaVLAdbAtpcOption=bwaVLAdbAtpcOption, bwaVLTotalTransmittedConcatenatedFramesSingle=bwaVLTotalTransmittedConcatenatedFramesSingle, bwaVLRadioBand=bwaVLRadioBand, bwaVLCurrentFrequencySubsetFrequencyNew=bwaVLCurrentFrequencySubsetFrequencyNew, bwaVLFrequencySubsetEntry=bwaVLFrequencySubsetEntry, bwaVLSpectrumAnalysisInformationEntry=bwaVLSpectrumAnalysisInformationEntry, bwaVLMinimumIntervalBetweenATPCMessages=bwaVLMinimumIntervalBetweenATPCMessages, bwaVLPreferredAuMacAddress=bwaVLPreferredAuMacAddress, bwaVLNwMngTrapAddress=bwaVLNwMngTrapAddress, bwaVLPromiscuousModeTRAP=bwaVLPromiscuousModeTRAP, bwaVLVlanRelaying=bwaVLVlanRelaying, bwaVLMaximumModulationLevel=bwaVLMaximumModulationLevel, bwaVLFrequencySubsetTable=bwaVLFrequencySubsetTable, bwaVLNumOfAssociationsSinceLastReset=bwaVLNumOfAssociationsSinceLastReset, bwaVLEthBroadcastMulticastLimiterSendTrapInterval=bwaVLEthBroadcastMulticastLimiterSendTrapInterval, bwaVLAdbMacAddress=bwaVLAdbMacAddress, bwaVLFramesSubmittedViaLowQueue=bwaVLFramesSubmittedViaLowQueue, bwaVLDrapUdpPort=bwaVLDrapUdpPort, bwaVLNwMngIpAddress=bwaVLNwMngIpAddress, mngIpFilterTable=mngIpFilterTable, bwaVLDFSChannelReuseOption=bwaVLDFSChannelReuseOption, bwaVLUserFilterParams=bwaVLUserFilterParams, bwaVLAdbSecurityMode=bwaVLAdbSecurityMode, bwaVLUnitTypeChangedTRAP=bwaVLUnitTypeChangedTRAP, bwaVLWirelessLinkEvents=bwaVLWirelessLinkEvents, bwaVLUdpPortPriRTPRTCP=bwaVLUdpPortPriRTPRTCP, bwaVLMaximumTxPower=bwaVLMaximumTxPower, bwaVLAdbMirRx=bwaVLAdbMirRx, bwaVLSelectSubBandIndex=bwaVLSelectSubBandIndex, bwaVLScanningStep=bwaVLScanningStep, bwaVLFrequencySubsetActive=bwaVLFrequencySubsetActive, bwaVLVlanPriorityThreshold=bwaVLVlanPriorityThreshold, bwaVLSetSelectedFreqSubset=bwaVLSetSelectedFreqSubset, bwaVLFairnessFactor=bwaVLFairnessFactor, bwaVLSUPerModulationLevelCountersTable=bwaVLSUPerModulationLevelCountersTable, bwaVLAntennaGain=bwaVLAntennaGain, PYSNMP_MODULE_ID=bwaVLMib, bwaVLTransmitPower=bwaVLTransmitPower, bwaVLDefinedMaximumTxPowerRange=bwaVLDefinedMaximumTxPowerRange, bwa4900_SU_BD=bwa4900_SU_BD, bwaVLAIFS=bwaVLAIFS, bwaVLKey1=bwaVLKey1, bwaVLTcpPortRangeTable=bwaVLTcpPortRangeTable, bwa4900_AU_BS=bwa4900_AU_BS, bwaVLDrapGatewayIP=bwaVLDrapGatewayIP, bwaVLTrapTelnetUserIpAddress=bwaVLTrapTelnetUserIpAddress, bwaVLSU_I=bwaVLSU_I, bwaVLRunTimeESSID=bwaVLRunTimeESSID, bwaVLAdaptiveModulationParams=bwaVLAdaptiveModulationParams, bwaVLDrapGatewayNoOfActiveVoiceCalls=bwaVLDrapGatewayNoOfActiveVoiceCalls, bwaVLScanningMode=bwaVLScanningMode, mngIpFilterEntry=mngIpFilterEntry, bwaVLNeighborAuTable=bwaVLNeighborAuTable, bwaVLUdpPortRangeDeleteAll=bwaVLUdpPortRangeDeleteAll, bwaVLNumberOfMacAddressesInDenyList=bwaVLNumberOfMacAddressesInDenyList, bwaVLTcpPortPriRTPRTCP=bwaVLTcpPortPriRTPRTCP)
mibBuilder.exportSymbols("BWA-DOT11-WLAN-MIB", bwaVLNeighborAuLearnCountryCodeBySU=bwaVLNeighborAuLearnCountryCodeBySU, bwaVLToSPrioritizationOption=bwaVLToSPrioritizationOption, bwaVLMacAddressDenyList=bwaVLMacAddressDenyList, bwaVLTcpPortRangeEntry=bwaVLTcpPortRangeEntry, bwa=bwa, bwaVLDFSChannelAvoidancePeriod=bwaVLDFSChannelAvoidancePeriod, bwaVLAdbAuthOption=bwaVLAdbAuthOption, bwaVLNeighborAuESSID=bwaVLNeighborAuESSID, bwaVLEthernetNegotiationMode=bwaVLEthernetNegotiationMode, bwaVLSpectrumAnalysisInformationOFDMFrames=bwaVLSpectrumAnalysisInformationOFDMFrames, bwaVLCountryDependentParameters=bwaVLCountryDependentParameters, bwaVLFramesDelayedDueToSwRetry=bwaVLFramesDelayedDueToSwRetry, bwaVLMinModulationLevel=bwaVLMinModulationLevel, bwaVLDeleteOneNwIpRange=bwaVLDeleteOneNwIpRange, bwaVLSU=bwaVLSU, bwaVLDFSChannelCheckTime=bwaVLDFSChannelCheckTime, mptEthernetStationMACAddress=mptEthernetStationMACAddress, bwaVLPhyErrors=bwaVLPhyErrors, bwaVLTotalRxFramesFromWireless=bwaVLTotalRxFramesFromWireless, bwaVLTotalRecievedDataFrames=bwaVLTotalRecievedDataFrames, bwaVLDFSMoveFreqNew=bwaVLDFSMoveFreqNew, bwaVLTransmitPowerEntry=bwaVLTransmitPowerEntry, bwaVLRegulationMaxEIRP=bwaVLRegulationMaxEIRP, bwaVLRunTimeDefaultIPGateway=bwaVLRunTimeDefaultIPGateway, bwaVLTcpPortRangeEnd=bwaVLTcpPortRangeEnd, bwaVLTotalTxEvents=bwaVLTotalTxEvents, bwaVLMaskID=bwaVLMaskID, bwaVLDFSRadarDetectionChannelsTable=bwaVLDFSRadarDetectionChannelsTable, bwaVLAdbSwVersion=bwaVLAdbSwVersion, bwa4900_AU_SA=bwa4900_AU_SA, bwaVLCountryCodeLearningBySU=bwaVLCountryCodeLearningBySU, bwaVLTrapToggle=bwaVLTrapToggle, bwaVLDrapTTL=bwaVLDrapTTL, bwaVLUnitControl=bwaVLUnitControl, bwaVLMinimumSNRLevel=bwaVLMinimumSNRLevel, bwaVLAdbCountryCode=bwaVLAdbCountryCode, bwaVLPerSuDistanceLearning=bwaVLPerSuDistanceLearning, bwaVLSecurityParameters=bwaVLSecurityParameters, bwaVLMulticastModulationLevel=bwaVLMulticastModulationLevel, bwaVLSUPerModulationLevelCountersApplicableModLevel=bwaVLSUPerModulationLevelCountersApplicableModLevel, bwaVLDataEncryptionSupport=bwaVLDataEncryptionSupport, bwaVLEthBroadcastThresholdExceeded=bwaVLEthBroadcastThresholdExceeded, bwaVLTotalNoOfDataFramesSubmitted=bwaVLTotalNoOfDataFramesSubmitted, bwaVLAllowedBandwidth=bwaVLAllowedBandwidth, bwaVLResetUnit=bwaVLResetUnit, bwaVLMacAddressDenyListTable=bwaVLMacAddressDenyListTable, bwaVLAdbSNR=bwaVLAdbSNR, bwaVLAdbTxFailedModLevel4=bwaVLAdbTxFailedModLevel4, bwaVLUseDhcp=bwaVLUseDhcp, bwaVLReadUpLinkQualityIndicator=bwaVLReadUpLinkQualityIndicator, bwaVLAUSUnsupportedSubscriberTypeTRAP=bwaVLAUSUnsupportedSubscriberTypeTRAP, bwaVLMacAddressDenyListEntry=bwaVLMacAddressDenyListEntry, bwaVLNoOfDuplicateFramesDiscarded=bwaVLNoOfDuplicateFramesDiscarded, bwaVLConfigurationFileName=bwaVLConfigurationFileName, bwaVLCurrentAUOperatingFrequency=bwaVLCurrentAUOperatingFrequency, bwaVLVLANPriorityThreshold=bwaVLVLANPriorityThreshold, bwaVLQinQEthertype=bwaVLQinQEthertype, bwaVLAdbTxSuccessModLevel8=bwaVLAdbTxSuccessModLevel8, bwaVLNeighborAuAtpcOption=bwaVLNeighborAuAtpcOption, bwaVLCurrentFrequencySubsetTableIdx=bwaVLCurrentFrequencySubsetTableIdx, bwaVLMaximumCellRadius=bwaVLMaximumCellRadius, bwaVLAntennaGainChange=bwaVLAntennaGainChange, bwaVLMinimumHwRevision=bwaVLMinimumHwRevision, bwaVLDeleteOneUserFilter=bwaVLDeleteOneUserFilter, bwaVLAdbDistance=bwaVLAdbDistance, bwaVLAUS_SA=bwaVLAUS_SA, bwaVLAccessToNwMng=bwaVLAccessToNwMng, DisplayString=DisplayString, bwaVLVLANForwarding=bwaVLVLANForwarding, bwaVLCurrentFrequencySubsetEntry=bwaVLCurrentFrequencySubsetEntry, bwaVLIpFilterIdx=bwaVLIpFilterIdx, bwaVLWirelessLinkPrioritization=bwaVLWirelessLinkPrioritization, bwaVLAUAdbTable=bwaVLAUAdbTable, bwaVLCurrentAUOperatingFrequencyNew=bwaVLCurrentAUOperatingFrequencyNew, bwaVLSUPerModulationLevelCountersTxSuccess=bwaVLSUPerModulationLevelCountersTxSuccess, bwaVLEthBroadcastingParameters=bwaVLEthBroadcastingParameters, bwaVLNeighborAuCountryCode=bwaVLNeighborAuCountryCode, bwaVLUnitWithMaxDistance=bwaVLUnitWithMaxDistance, bwaVLVLANQinQ=bwaVLVLANQinQ, bwaVLVlanDataPriority=bwaVLVlanDataPriority, bwaVLIpParams=bwaVLIpParams, bwaVLDfsSupport=bwaVLDfsSupport, bwaVLDFSOption=bwaVLDFSOption, bwaVLNeighborAuMacAdd=bwaVLNeighborAuMacAdd, bwaVLUpLinkQualityIndicatorStatus=bwaVLUpLinkQualityIndicatorStatus, bwaVLOverrunEvents=bwaVLOverrunEvents, bwaVLSpectrumAnalysisActivation=bwaVLSpectrumAnalysisActivation, bwaVLNewUnitTypeTrap=bwaVLNewUnitTypeTrap, bwaVLApClientIpAddress=bwaVLApClientIpAddress, bwaVLCellDistanceParameters=bwaVLCellDistanceParameters, bwaVLEventLogPolicy=bwaVLEventLogPolicy, bwaVLDeleteOneNwIpAddr=bwaVLDeleteOneNwIpAddr, bwaVLUdpPortRangeConfig=bwaVLUdpPortRangeConfig, bwaVLMaximumTxPowerRange=bwaVLMaximumTxPowerRange, bwaVLTotalRxConcatenatedFramesMore=bwaVLTotalRxConcatenatedFramesMore, bwaVLDrapGatewayType=bwaVLDrapGatewayType, bwaVLEthBroadcastFiltering=bwaVLEthBroadcastFiltering, mptUnitMACAddress=mptUnitMACAddress, bwaVLDisassociate=bwaVLDisassociate, bwaVLAdbTxSuccessModLevel4=bwaVLAdbTxSuccessModLevel4, bwaVLDFSMaximumNumberOfDetectionsInAssessmentPeriod=bwaVLDFSMaximumNumberOfDetectionsInAssessmentPeriod, bwaVLMaxDelay=bwaVLMaxDelay, bwaVLDFSRadarDetectionChannelsEntry=bwaVLDFSRadarDetectionChannelsEntry, bwaVLAverageModulationLevel=bwaVLAverageModulationLevel, bwaVLHWRetriesHighPriority=bwaVLHWRetriesHighPriority, bwaVLMaxModulationLevel=bwaVLMaxModulationLevel, bwaVLTrafficPrioritization=bwaVLTrafficPrioritization, bwaVLFeatureUpgrade=bwaVLFeatureUpgrade, bwaVLRunningSoftwareVersion=bwaVLRunningSoftwareVersion, bwaVLWirelessLinkCounters=bwaVLWirelessLinkCounters, bwaVLTrapSWVersion=bwaVLTrapSWVersion, bwaVLNeighborAuConcatenationOption=bwaVLNeighborAuConcatenationOption, bwaVLTotalRxConcatenatedFramesSingle=bwaVLTotalRxConcatenatedFramesSingle, bwaVLCountryDependentParameterFrequencies=bwaVLCountryDependentParameterFrequencies, bwaVLMib=bwaVLMib, ptp_BU_B14=ptp_BU_B14, bwaVLSU_54_BD=bwaVLSU_54_BD, bwaVLOperatorESSID=bwaVLOperatorESSID, bwaVLTelnetLogoutTimer=bwaVLTelnetLogoutTimer, bwaVLSpectrumAnalysisParameters=bwaVLSpectrumAnalysisParameters, bwaVLTotalTxFramesToWireless=bwaVLTotalTxFramesToWireless, bwaVLDeleteAllNwIpRanges=bwaVLDeleteAllNwIpRanges, bwaVLMirUplink=bwaVLMirUplink, bwaVLTrapFtpOrTftpStatus=bwaVLTrapFtpOrTftpStatus, bwaVLNeighborAuPerSuDistanceLearning=bwaVLNeighborAuPerSuDistanceLearning, bwaVLMaxTxApplicableModulationLevel=bwaVLMaxTxApplicableModulationLevel, bwaVLCountryCodeParameters=bwaVLCountryCodeParameters, bwaVLSUPerModulationLevelCountersTxFailed=bwaVLSUPerModulationLevelCountersTxFailed, bwaVLNwTrapTableIdx=bwaVLNwTrapTableIdx, bwaVLAUAdbResetAllModulationLevelCounters=bwaVLAUAdbResetAllModulationLevelCounters, bwaVLUnicastRelaying=bwaVLUnicastRelaying, bwaVLSecurityMode=bwaVLSecurityMode, bwaVLUdpTcpPortRangePrioritizationOption=bwaVLUdpTcpPortRangePrioritizationOption, bwaVLSubNetMask=bwaVLSubNetMask, bwaVLDFSMoveFreq=bwaVLDFSMoveFreq, bwaLCountryCodeReApply=bwaLCountryCodeReApply, bwaVLVlanForwardingSupport=bwaVLVlanForwardingSupport, bwaVLAdbMirTx=bwaVLAdbMirTx, bwaVLSpectrumAnalysisScanCycles=bwaVLSpectrumAnalysisScanCycles, ptp_RB_B28=ptp_RB_B28, ptp_RB_B100=ptp_RB_B100, bwaVLSUassociatedTRAP=bwaVLSUassociatedTRAP, bwaVLNeighborAuSwVer=bwaVLNeighborAuSwVer, bwaVLNeighborAuAdapModOption=bwaVLNeighborAuAdapModOption, bwaVLUserFilterOption=bwaVLUserFilterOption, bwaVLEthCounters=bwaVLEthCounters, bwaVLMeasureUpLinkQualityIndicator=bwaVLMeasureUpLinkQualityIndicator, bwaVLSU_6_BD=bwaVLSU_6_BD, bwaVLNeighborAuIdx=bwaVLNeighborAuIdx, bwaVLAdbBurstModeOption=bwaVLAdbBurstModeOption, bwaVLDFSChannelFrequencyNew=bwaVLDFSChannelFrequencyNew, bwaVLPowerUpFromReset=bwaVLPowerUpFromReset, bwaVLDFSFrequcnyTRAP=bwaVLDFSFrequcnyTRAP, bwaVLAirInterface=bwaVLAirInterface, bwaVLQinQProviderVlanID=bwaVLQinQProviderVlanID, bwaVLSiteSurvey=bwaVLSiteSurvey, bwaVLFTPSwFileName=bwaVLFTPSwFileName, bwaVLTrapRTx=bwaVLTrapRTx, bwaVLMaximumBurstDuration=bwaVLMaximumBurstDuration, bwaVLEthBroadcastMulticatLimiterTRAP=bwaVLEthBroadcastMulticatLimiterTRAP, bwaVLUnitBootVersion=bwaVLUnitBootVersion, bwaVLFramesDropped=bwaVLFramesDropped, bwaVLDFSRadarDetecetedTRAP=bwaVLDFSRadarDetecetedTRAP, bwaVLCirUplink=bwaVLCirUplink, bwaVLTxControl=bwaVLTxControl, bwaVLSubBandLowerFrequency=bwaVLSubBandLowerFrequency, bwaVLNeighborAuAuthOption=bwaVLNeighborAuAuthOption, bwaVLAdbTxFailedModLevel1=bwaVLAdbTxFailedModLevel1, bwaVLAdbTxFailedModLevel3=bwaVLAdbTxFailedModLevel3, bwaVLMaxBurstDuration=bwaVLMaxBurstDuration, bwaVLARPBroadcastOverrideFilter=bwaVLARPBroadcastOverrideFilter, bwaVLAdbCirRx=bwaVLAdbCirRx, bwaVLNwMngParameters=bwaVLNwMngParameters, bwaVLMaximumTransmitPowerIdx=bwaVLMaximumTransmitPowerIdx, bwaVLFTPServerPassword=bwaVLFTPServerPassword, bwaVLVlanID=bwaVLVlanID, bwaVLVlanForwardingTableIdx=bwaVLVlanForwardingTableIdx, bwaVLOID=bwaVLOID, bwaVLDFSChannelFrequency=bwaVLDFSChannelFrequency, bwaVLTrapLog=bwaVLTrapLog, bwaVLVlanRelayingEntry=bwaVLVlanRelayingEntry, bwaVLNeighborAuSecurityMode=bwaVLNeighborAuSecurityMode, bwaVLESSIDParameters=bwaVLESSIDParameters, bwaVLCurrentSUOperatingFrequency=bwaVLCurrentSUOperatingFrequency, bwaVLAuthenticationPromiscuousMode=bwaVLAuthenticationPromiscuousMode, bwaVLEthBroadcastMulticastLimiterThreshold=bwaVLEthBroadcastMulticastLimiterThreshold, bwaVLUdpPortRangeIdx=bwaVLUdpPortRangeIdx, bwaVLFTPSwDownload=bwaVLFTPSwDownload, bwaVLVlanForwardingTable=bwaVLVlanForwardingTable, bwaVLEthernetLinkType=bwaVLEthernetLinkType, bwaVLEventLogFileUploading=bwaVLEventLogFileUploading, bwaVLMaxTxPower=bwaVLMaxTxPower, bwaVLDFSChannelRadarStatus=bwaVLDFSChannelRadarStatus, bwaVLConcatenationMaximumNumberOfFrames=bwaVLConcatenationMaximumNumberOfFrames, bwaVLUnderrunEvents=bwaVLUnderrunEvents, bwaVLTotalTransmittedUnicasts=bwaVLTotalTransmittedUnicasts, bwaVLSpectrumAnalysisInformationTable=bwaVLSpectrumAnalysisInformationTable, bwaVLDisassociateAllSUs=bwaVLDisassociateAllSUs, bwaVLTcpPortRangeStart=bwaVLTcpPortRangeStart, bwaVLUnitMacAddress=bwaVLUnitMacAddress, bwaVLEraseEventLog=bwaVLEraseEventLog, bwaVLIPDSCPThreshold=bwaVLIPDSCPThreshold, bwaVLResetSpectrumCounters=bwaVLResetSpectrumCounters, bwaVLNeighborAuEntry=bwaVLNeighborAuEntry, bwaVLSpectrumAnalysisInformationSignalSNR=bwaVLSpectrumAnalysisInformationSignalSNR, bwaVLAdbCpldVer=bwaVLAdbCpldVer, bwaVLNwMngFilter=bwaVLNwMngFilter, bwaVLDFSSuWaitingOption=bwaVLDFSSuWaitingOption, bwaVLShadowVersionNumber=bwaVLShadowVersionNumber, bwaVLNeighborAuHwRevision=bwaVLNeighborAuHwRevision, bwaVLTrapText=bwaVLTrapText, bwaVLAU_BS=bwaVLAU_BS, bwaVLSpectrumAnalysisChannelScanPeriod=bwaVLSpectrumAnalysisChannelScanPeriod, bwaVLMacAddressDenyListId=bwaVLMacAddressDenyListId, bwaVLAssociatedAU=bwaVLAssociatedAU, bwaVLAdbTxSuccessModLevel1=bwaVLAdbTxSuccessModLevel1, bwaVLMacAddressDenyListRemove=bwaVLMacAddressDenyListRemove, bwaVLIpFilterTable=bwaVLIpFilterTable, bwaVLWLPrioritizationNotSupportedBySUTRAP=bwaVLWLPrioritizationNotSupportedBySUTRAP, bwaVLOperatorDefaultsFileName=bwaVLOperatorDefaultsFileName, bwaVLAUDefinedFrequency=bwaVLAUDefinedFrequency, bwaVLPPPoEBroadcastOverrideFilter=bwaVLPPPoEBroadcastOverrideFilter, bwaVLNeighborAuAssocLoadStatus=bwaVLNeighborAuAssocLoadStatus, bwaVLUdpPortRangeStart=bwaVLUdpPortRangeStart, bwaVLFTPServerIpAddress=bwaVLFTPServerIpAddress, bwaVLCountryDependentParameterEntry=bwaVLCountryDependentParameterEntry, ptp_BU_B28=ptp_BU_B28, bwaVLRTSThreshold=bwaVLRTSThreshold, bwaVLDeleteOneTrapAddr=bwaVLDeleteOneTrapAddr, bwaVLWirelessLinkPrioritizationOption=bwaVLWirelessLinkPrioritizationOption, bwaVLAdbHwRevision=bwaVLAdbHwRevision, bwaVLTcpPortRangeDeleteAll=bwaVLTcpPortRangeDeleteAll, bwaVLMacPinpointEntry=bwaVLMacPinpointEntry, bwaVLManagementVlanID=bwaVLManagementVlanID, bwaVLCellDistanceMode=bwaVLCellDistanceMode, bwaVLFTPDownloadSwFile=bwaVLFTPDownloadSwFile, bwaVLMinIntervalBetweenAdaptiveModulationAlgorithmMessages=bwaVLMinIntervalBetweenAdaptiveModulationAlgorithmMessages, bwaVLTrapSUMacAddr=bwaVLTrapSUMacAddr, bwaVLSUPerModulationLevelCountersEntry=bwaVLSUPerModulationLevelCountersEntry, bwaVLRunTimeIPaddr=bwaVLRunTimeIPaddr, bwaVLBridgeAgingTime=bwaVLBridgeAgingTime, bwaVLAdbTxSuccessModLevel5=bwaVLAdbTxSuccessModLevel5, bwaVLMirDownlink=bwaVLMirDownlink, bwaVLCirDownlink=bwaVLCirDownlink, bwaVLSpectrumAnalysisStatus=bwaVLSpectrumAnalysisStatus, bwaVLAUS_BS=bwaVLAUS_BS, bwaVLSUassociatedAUTRAP=bwaVLSUassociatedAUTRAP, bwaVLNeighborAuDataEncyptOption=bwaVLNeighborAuDataEncyptOption, bwaVLDFSRadarActivityAssessmentPeriod=bwaVLDFSRadarActivityAssessmentPeriod, bwaVLUpLinkQualityIndicator=bwaVLUpLinkQualityIndicator, bwaVLInstallerPassword=bwaVLInstallerPassword, bwaVLSU_BD=bwaVLSU_BD, bwaVLSUDefaultKeyID=bwaVLSUDefaultKeyID, bwaVLSU_3_1D=bwaVLSU_3_1D)
mibBuilder.exportSymbols("BWA-DOT11-WLAN-MIB", bwaVLAdbTxSuccessModLevel6=bwaVLAdbTxSuccessModLevel6, bwaVLShadowVersionFileName=bwaVLShadowVersionFileName, bwaVLAUDefaultMulticastKeyID=bwaVLAUDefaultMulticastKeyID, bwaVLTrafficStatistics=bwaVLTrafficStatistics, bwaVLPerModulationLevelCounters=bwaVLPerModulationLevelCounters, bwaVLIpFilterEntry=bwaVLIpFilterEntry, products=products, bwaVLDFSMinimumPulsesToDetect=bwaVLDFSMinimumPulsesToDetect, bwaVLTxPower=bwaVLTxPower, bwaVLUnitHwVersion=bwaVLUnitHwVersion, bwaVLToSPrecedenceThreshold=bwaVLToSPrecedenceThreshold, bwaVLReadOnlyPassword=bwaVLReadOnlyPassword, bwaVLMacAddressDenyListAction=bwaVLMacAddressDenyListAction, bwaVLUdpPortRangeAdd=bwaVLUdpPortRangeAdd, bwaVLBurstModeOption=bwaVLBurstModeOption, bwaVLGracefulDegradationLimit=bwaVLGracefulDegradationLimit, bwaVLMngIpRangeIdx=bwaVLMngIpRangeIdx, bwaVLUdpPortRangeDelete=bwaVLUdpPortRangeDelete, bwaVLRecievedBadFrames=bwaVLRecievedBadFrames, bwaVLAdbBootVer=bwaVLAdbBootVer, bwaVLAUagingTRAP=bwaVLAUagingTRAP, bwaVLSystemLocation=bwaVLSystemLocation, bwaVLTotalRxEvents=bwaVLTotalRxEvents, bwaVLConfigurationFileLoading=bwaVLConfigurationFileLoading, bwaVLFTPParameters=bwaVLFTPParameters, bwaVLResetPerModulationLevelCounters=bwaVLResetPerModulationLevelCounters, bwaVLMaximumTransmitPowerEntry=bwaVLMaximumTransmitPowerEntry, bwaVLAutoSubBandFrequencySubsetEntry=bwaVLAutoSubBandFrequencySubsetEntry, bwaVLAdbTxSuccessModLevel2=bwaVLAdbTxSuccessModLevel2, ptp_BU_B100=ptp_BU_B100, bwaVLConcatenationMaxFrameSize=bwaVLConcatenationMaxFrameSize, bwaVLFrequencySubsetFrequencyNew=bwaVLFrequencySubsetFrequencyNew, bwaVLSubBandUpperFrequency=bwaVLSubBandUpperFrequency, bwaVLOthersTxEvents=bwaVLOthersTxEvents, bwaVLAESEncryptionSupport=bwaVLAESEncryptionSupport, bwaVLAdbTxFailedModLevel5=bwaVLAdbTxFailedModLevel5, bwaVLAUMacAddressDatabase=bwaVLAUMacAddressDatabase, bwaVLSU_3_4D=bwaVLSU_3_4D, mngTrapEntry=mngTrapEntry, bwaVLAdbCirTx=bwaVLAdbCirTx, bwaVLEthBroadcastMulticastLimiterOption=bwaVLEthBroadcastMulticastLimiterOption, bwaVLSU_6_1D=bwaVLSU_6_1D, bwaVLNwMngTrapCommunity=bwaVLNwMngTrapCommunity, bwaVLParameterChangedTRAP=bwaVLParameterChangedTRAP, bwaVLFeatureUpgradeManually=bwaVLFeatureUpgradeManually, bwaVLlowPriorityAIFS=bwaVLlowPriorityAIFS, bwaVLDeleteAllUserFilters=bwaVLDeleteAllUserFilters, bwaVLLostBeaconsWatchdogThreshold=bwaVLLostBeaconsWatchdogThreshold, bwaVLFTPSwSourceDir=bwaVLFTPSwSourceDir, bwaVLAUAdbEntry=bwaVLAUAdbEntry, bwaVLAUDefinedFrequencyNew=bwaVLAUDefinedFrequencyNew, bwaVLDeleteAllTrapAddrs=bwaVLDeleteAllTrapAddrs, bwaVLLowPriorityTrafficMinimumPercent=bwaVLLowPriorityTrafficMinimumPercent, bwaVLAUBurstDurationLowPriority=bwaVLAUBurstDurationLowPriority, bwaVLAdbTxFailedModLevel8=bwaVLAdbTxFailedModLevel8, bwaVLUdpPortRangeTable=bwaVLUdpPortRangeTable, bwaVLNeighborAuDfsOption=bwaVLNeighborAuDfsOption, bwaVLSUPMirDownlink=bwaVLSUPMirDownlink, bwaVLDFSClearRadarDetectedChannelsAfterReset=bwaVLDFSClearRadarDetectedChannelsAfterReset, bwaVLUdpPortRangeEntry=bwaVLUdpPortRangeEntry, bwaVLDrap=bwaVLDrap, bwaVLDrapGatewayIndex=bwaVLDrapGatewayIndex, bwaVLDFSNoFreeChannelsExistsTRAP=bwaVLDFSNoFreeChannelsExistsTRAP, mngTrapTable=mngTrapTable, bwaVLMacPinpoint=bwaVLMacPinpoint, bwaVLDroppedFrameEvents=bwaVLDroppedFrameEvents, bwaVLVlanRelayingTable=bwaVLVlanRelayingTable, bwaVLAdbAge=bwaVLAdbAge, bwaVLDefaultGWAddress=bwaVLDefaultGWAddress, bwaVLAdbTxSuccessModLevel3=bwaVLAdbTxSuccessModLevel3, bwaVLCurrentNumOfAssociations=bwaVLCurrentNumOfAssociations, bwaVLMngIpRangeStart=bwaVLMngIpRangeStart, bwaVLCountryDependentParamsTable=bwaVLCountryDependentParamsTable, bwaVLLoadingStatusTRAP=bwaVLLoadingStatusTRAP, bwaVLMainVersionFileName=bwaVLMainVersionFileName, bwaVLDrapSupport=bwaVLDrapSupport, bwaVLVlanIdForwarding=bwaVLVlanIdForwarding, bwaVLCountryDependentParameterTableIdx=bwaVLCountryDependentParameterTableIdx, bwaVLSUBurstDurationHighPriority=bwaVLSUBurstDurationHighPriority)
