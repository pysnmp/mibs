#
# PySNMP MIB module TELDAT-MON-CommonInfo-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/teldat/TELDAT-MON-CommonInfo-MIB
# Produced by pysmi-1.1.8 at Thu Jan 27 21:46:15 2022
# On host fv-az135-463 platform Linux version 5.11.0-1027-azure by user runner
# Using Python version 3.10.2 (main, Jan 16 2022, 11:55:27) [GCC 9.3.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Counter32, TimeTicks, Counter64, IpAddress, ModuleIdentity, Integer32, Bits, Unsigned32, Gauge32, NotificationType, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Counter32", "TimeTicks", "Counter64", "IpAddress", "ModuleIdentity", "Integer32", "Bits", "Unsigned32", "Gauge32", "NotificationType", "MibIdentifier")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
telProdNpMonInterface, telProdNpMonInterfRouter, telProdNpMonitSistema = mibBuilder.importSymbols("TELDAT-SW-STRUCTURE-MIB", "telProdNpMonInterface", "telProdNpMonInterfRouter", "telProdNpMonitSistema")
telProdNpMonSistemMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1))
telProdNpMonSistemMemSize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemSize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemSize.setDescription('System Memory Size.')
telProdNpMonSistemMemAvailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemAvailable.setDescription('Available System Memory Size.')
telProdNpMonSistemMemPooldissize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldissize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldissize.setDescription('Size of the memory area reserved to the task that manage the disk.')
telProdNpMonSistemMemPooldisavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldisavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldisavailable.setDescription('Free space in the memory area reserved to the task that manages\n        the disk.')
telProdNpMonSistemMemPoolmdissize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolmdissize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolmdissize.setDescription('Size of the memory area reserved to save information messages\n        of the disk task.')
telProdNpMonSistemMemPoolmdisavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolmdisavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolmdisavailable.setDescription('Free space in the memory area reserved to save information messages\n        of the disk task.')
telProdNpMonSistemMemPooltsize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooltsize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooltsize.setDescription('Size of the memory area reserved to save the application temporal\n        variables.')
telProdNpMonSistemMemPooltavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooltavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooltavailable.setDescription('Free space in the memory area reserved to save the application temporal\n        variables.')
telProdNpMonSistemMemPoolpsize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolpsize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolpsize.setDescription('Size of the memory area reserved to save the application permanent\n        variables.')
telProdNpMonSistemMemPoolpavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolpavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolpavailable.setDescription('Free space in the memory area reserved to save the application permanent\n        variables.')
telProdNpMonSistemMemPool0size = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0size.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0size.setDescription('Size of the memory area 0 reserved to messages of the node side.')
telProdNpMonSistemMemPool0restpart = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0restpart.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0restpart.setDescription('Number of partitions of the memory area 0 reserved  to messages\n        of the node side.')
telProdNpMonSistemMemPool0available = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0available.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool0available.setDescription('Number of available partitions of the memory area 0 reserved  to messages\n        of the node side.')
telProdNpMonSistemMemPool1size = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1size.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1size.setDescription('Size of the memory area 1 reserved to messages of the node side.')
telProdNpMonSistemMemPool1restpart = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1restpart.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1restpart.setDescription('Number of partitions of the memory area 1 reserved to messages\n        of the node side.')
telProdNpMonSistemMemPool1available = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1available.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool1available.setDescription('Number of available partitions of the memory area 1 reserved to\n        messages of the node side.')
telProdNpMonSistemMemPool2size = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2size.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2size.setDescription('Size of the memory area 2 reserved to messages of the node side.')
telProdNpMonSistemMemPool2restpart = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2restpart.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2restpart.setDescription('Number of partitions of the memory area 2 reserved  to messages\n        of the node side.')
telProdNpMonSistemMemPool2available = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2available.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPool2available.setDescription('Number of available partitions of the memory area 2 reserved  to messages\n        of the node side.')
telProdNpMonSistemMemPoolisize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolisize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolisize.setDescription('Size of the memory area reserved to messages of the routers side.')
telProdNpMonSistemMemPoolirestpart = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolirestpart.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPoolirestpart.setDescription('Number of partitions of the memory area reserved  to messages\n        of the router side.')
telProdNpMonSistemMemPooliavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooliavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooliavailable.setDescription('Number of available partitions of the memory area reserved  to messages\n        of the router side.')
telProdNpMonSistemMemPooldlssize = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlssize.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlssize.setDescription('Size of the memory area reserved to DLS messages.')
telProdNpMonSistemMemPooldlsrestpart = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlsrestpart.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlsrestpart.setDescription('Number of partitions of the memory area reserved to DLS messages.')
telProdNpMonSistemMemPooldlsavailable = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlsavailable.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemPooldlsavailable.setDescription('Number of available partitions of the memory area reserved to\n        DLS messages.')
telProdNpMonSistemMemTotal = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemTotal.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemTotal.setDescription('Total system memory in bytes.')
telProdNpMonSistemMemTotalcache = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemTotalcache.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemTotalcache.setDescription('Total cache memory in bytes.')
telProdNpMonSistemMemFreecache = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemFreecache.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemFreecache.setDescription('Available free cache memory in bytes.')
telProdNpMonSistemMemTotalnoncache = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemTotalnoncache.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemTotalnoncache.setDescription('Total non cache memory in bytes.')
telProdNpMonSistemMemFreenoncache = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemFreenoncache.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemFreenoncache.setDescription('Free non cache memory in bytes.')
telProdNpMonSistemMemCaches = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(30, 30)).setFixedLength(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemCaches.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemCaches.setDescription('Caches.')
telProdNpMonSistemMemFlash = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemFlash.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemFlash.setDescription('System flash memory in bytes.')
telProdNpMonSistemMemFreeglobbuffer = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemFreeglobbuffer.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemMemFreeglobbuffer.setDescription('Number of available public buffers in the system.')
telProdNpMonSistemMemHeap = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemHeap.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemHeap.setDescription('Size of the available heap in bytes.')
telProdNpMonSistemMemIcused = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemIcused.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemIcused.setDescription('Used CPU percentage.')
telProdNpMonSistemMemIcindex = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemIcindex.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemIcindex.setDescription('CPU index.')
telProdNpMonSistemMemTc = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemMemTc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonSistemMemTc.setDescription('Cycle Time.')
telProdNpMonSistemFan = MibIdentifier((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 3))
telProdNpMonSistemFanCpu = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemFanCpu.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemFanCpu.setDescription('CPU Fanspeed in rpm')
telProdNpMonSistemFanCpuPerCent = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemFanCpuPerCent.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemFanCpuPerCent.setDescription('CPU Fanspeed in percentage of nominal value')
telProdNpMonSistemFanCase = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemFanCase.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemFanCase.setDescription('Case Fanspeed in rpm')
telProdNpMonSistemFanCasePerCent = MibScalar((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonSistemFanCasePerCent.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonSistemFanCasePerCent.setDescription('Case Fanspeed in percentage of nominal value')
telProdNpMonPoeCardsTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 4), )
if mibBuilder.loadTexts: telProdNpMonPoeCardsTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonPoeCardsTable.setDescription('Table to show if Poe Card are present.')
telProdNpMonPoeCardsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 4, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonPoeCardsInd"))
if mibBuilder.loadTexts: telProdNpMonPoeCardsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonPoeCardsEntry.setDescription('Each entry corresponds to POE card.')
telProdNpMonPoeCardsInd = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonPoeCardsInd.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonPoeCardsInd.setDescription('Index number (table index).')
telProdNpMonPoeCardsState = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 1, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonPoeCardsState.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonPoeCardsState.setDescription('Shows which POE Card is present.')
telProdNpMonInterfCommandsTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 1), )
if mibBuilder.loadTexts: telProdNpMonInterfCommandsTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfCommandsTable.setDescription('Table used to delete general statistics of nets (not of nodes).')
telProdNpMonInterfCommandsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 1, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfCommandsIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfCommandsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfCommandsEntry.setDescription('Each entry corresponds to a net interface.')
telProdNpMonInterfCommandsIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfCommandsIfc.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfCommandsIfc.setDescription('Interface number (table index).')
telProdNpMonInterfCommandsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("valid", 2), ("error", 3), ("undefined", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telProdNpMonInterfCommandsClear.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfCommandsClear.setDescription('Statistics Delete command for the chosen interface. If the operation\n        successes (2) valid will appear. If the operation could not be\n        performed (3)error will appear. If no delete operation has been\n        performed (4)undefined will appear.')
telProdNpMonInterfBufferTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1), )
if mibBuilder.loadTexts: telProdNpMonInterfBufferTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferTable.setDescription('It shows information about the packet buffers assigned to\n        each interface.')
telProdNpMonInterfBufferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfBufferIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfBufferEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferEntry.setDescription('Each entry corresponds to information about an interface.')
telProdNpMonInterfBufferIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferIfc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonInterfBufferIfc.setDescription('Interface number (table index).')
telProdNpMonInterfBufferKind = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67))).clone(namedValues=NamedValues(("vi", 1), ("pn", 2), ("pri", 3), ("xeth", 4), ("arpa", 5), ("chp", 6), ("osl", 7), ("eth", 8), ("sl", 9), ("x28", 10), ("dmr", 11), ("tkr", 12), ("snk", 13), ("x25", 14), ("man", 15), ("atr", 16), ("fddi", 17), ("srly", 18), ("ippn", 19), ("fr", 20), ("ppp", 21), ("bdg", 22), ("null", 23), ("isdnb", 24), ("sdlc", 25), ("v25b", 26), ("routernode", 27), ("noderouter", 28), ("isdnd", 29), ("xot", 30), ("int270", 31), ("tnip", 32), ("mppp", 33), ("atm", 34), ("subatm", 35), ("ipsec", 36), ("bri", 37), ("x25fak", 38), ("isdnbfak", 39), ("isdndfak", 40), ("xotfak", 41), ("int270fak", 42), ("asdp", 43), ("syncsl", 44), ("asyncsl", 45), ("aptb", 46), ("dialrout", 47), ("arly", 48), ("mem", 49), ("vlaneth", 50), ("voip", 51), ("l2tp", 52), ("bvi", 53), ("scada", 54), ("wlan", 55), ("sepi", 56), ("eibz", 57), ("gpio", 58), ("autosl", 59), ("mdmemu", 60), ("frsub", 61), ("bvisub", 62), ("nic", 63), ("dip", 64), ("iec101gw", 65), ("gps", 66), ("gpsdatasl", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferKind.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferKind.setDescription('Interface type.\n        VI,                     VI LNI\n        PN,                     ProNET\n        PRI,                    PRI IFC CH, CHAOS Net\n        XETH,                   Experimental EtherNet (3 MBit)\n        ARPA,                   ARPANet\n        CHP,                    CHAOS protocol net\n        OSL,                    Serial line interface\n        Eth,                    EtherNet (10 MBit)\n        SL,                     New serial line link\n        X28,                    X.28\n        DMR,                    DEC DMR interface\n        TKR,                    802.5 token ring\n        SNK,                    Sink network (not a real network)\n        X25,                    X25 network\n        MAN,                    802.6 metro area network\n        ATR,                    Apollo Token Ring\n        FDDI,                   FDDI\n        SRLY,                   SDLC relay int\n        IPPN,                   IP Protocol Net\n        FR,                     Frame Relay network\n        PPP,                    PPP network\n        BDG,                    Bridging pseudo-handler\n        NULL,                   Null device\n        GWT_NTYPE_B_ISDN,       ISDN network B channel\n        SDLC,                   TRUE SDLC int\n        V25B,                   V.25bis base network\n        R->N,                   Teldat Micro-node\n        N->R,                   Teldat Router\n        GWT_NTYPE_D_ISDN,       RDSI D channel\n        270,                    270 Virtual port\n        XOT,                    XOT\n        TNIP,                   IP tunnel\n        MPPP,                   PPP Multilink\n        ATM,                    ATM Interface\n        SUBATM,                 ATM subinterface\n        IPSEC,                  IPSEC\n        BRI,                    RDSI (2Bs)\n        X25_FAK,                X25 fake\n        ISDNB_FAK,              ISDNB fake\n        ISDND_FAK,              ISDND fake\n        XOT_FAK,                XOT fake\n        270_FAK,                270 fake\n        ASDP,                   Asynchronous serial device\n        SYNC_SL,                Synchronous serial line\n        ASYNC_SL,               Asynchronous serial line\n        APTB,                   Asynchronous serial line\n        DIALROUT,               Fake for Dial Routing\n        ARLY,                   AP alarms relay\n        MEM,                    PCI Memory card\n        VLAN_ETH,               VLAN Ethernet\n        VOIP,                   VoIP card\n        L2TP,                   L2TP Virtual Interface\n        BVI,                    Bridge Virtual Interface\n        SCADA,                  SCADA Virtual Interface\n        WLAN,                   Wireless LAN\n        SEPI,                   Serial Event Printing Interface\n        EIB_Z,                  Zennio EIB Adapter\n        GPIO,                   General Parallel I/O\n        AUTO_SL,                Synchronous serial line\n        MDMEMU,                 Modem Emulator Interface\n        FR_SUB,                 FR subinterface\n        BVI_SUB,                BVI subinterface\n        NIC,                    USB_NIC Device\n        DIP,                    Generic DirectIP encapsulation\n        IEC101GW,               SCADA Virtual Interface\n        GPS,                    GPS Receiver Interface\n        GPSDATA_SL,             GPS DATA Serial line')
telProdNpMonInterfBufferOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferOrder.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferOrder.setDescription('This type interface number.')
telProdNpMonInterfBufferReq = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferReq.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferReq.setDescription('Number of input buffers requiered.')
telProdNpMonInterfBufferAlloc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferAlloc.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferAlloc.setDescription('Number of input buffers assigned.')
telProdNpMonInterfBufferLow = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferLow.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferLow.setDescription('Low water mark (flow control).')
telProdNpMonInterfBufferCurr = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferCurr.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferCurr.setDescription('Current number of input buffers to this device. If the value is 0, the\n        device is disabled. When the packet is received, if the value of Curr\n        in lower than Low, then the flow control can choose it.')
telProdNpMonInterfBufferHdr = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferHdr.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferHdr.setDescription('It is the maximum value between the following two:\n        The largest LLC, plus MAC, plus the header size of the output device.\n        The MAC plus the header size of the output device.')
telProdNpMonInterfBufferWrap = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferWrap.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferWrap.setDescription('Given range for MAC, LLC, or network layer.')
telProdNpMonInterfBufferData = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferData.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferData.setDescription('Maximum size of the data link layer packet.')
telProdNpMonInterfBufferTrail = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferTrail.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferTrail.setDescription('Addition of the largest MAC and the hardware trailers.')
telProdNpMonInterfBufferTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferTotal.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferTotal.setDescription('Global size of each packet buffer.')
telProdNpMonInterfBufferAlloc2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfBufferAlloc2.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfBufferAlloc2.setDescription('Amount of buffer memory bytes for this device. This value is\n        calculated multiplying Curr by Total.')
telProdNpMonInterfGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2), )
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTable.setDescription('Table that shows statistic information about interfaces.')
telProdNpMonInterfGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfGeneralIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfGeneralEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralEntry.setDescription('Each entry corresponds to an interface.')
telProdNpMonInterfGeneralIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralIfc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralIfc.setDescription('Interface number (table index).')
telProdNpMonInterfGeneralKind = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67))).clone(namedValues=NamedValues(("vi", 1), ("pn", 2), ("pri", 3), ("xeth", 4), ("arpa", 5), ("chp", 6), ("osl", 7), ("eth", 8), ("sl", 9), ("x28", 10), ("dmr", 11), ("tkr", 12), ("snk", 13), ("x25", 14), ("man", 15), ("atr", 16), ("fddi", 17), ("srly", 18), ("ippn", 19), ("fr", 20), ("ppp", 21), ("bdg", 22), ("null", 23), ("isdnb", 24), ("sdlc", 25), ("v25b", 26), ("routernode", 27), ("noderouter", 28), ("isdnd", 29), ("xot", 30), ("int270", 31), ("tnip", 32), ("mppp", 33), ("atm", 34), ("subatm", 35), ("ipsec", 36), ("bri", 37), ("x25fak", 38), ("isdnbfak", 39), ("isdndfak", 40), ("xotfak", 41), ("int270fak", 42), ("asdp", 43), ("syncsl", 44), ("asyncsl", 45), ("aptb", 46), ("dialrout", 47), ("arly", 48), ("mem", 49), ("vlaneth", 50), ("voip", 51), ("l2tp", 52), ("bvi", 53), ("scada", 54), ("wlan", 55), ("sepi", 56), ("eibz", 57), ("gpio", 58), ("autosl", 59), ("mdmemu", 60), ("frsub", 61), ("bvisub", 62), ("nic", 63), ("dip", 64), ("iec101gw", 65), ("gps", 66), ("gpsdatasl", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralKind.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralKind.setDescription('Interface type.\n        VI,                     VI LNI\n        PN,                     ProNET\n        PRI,                    PRI IFC CH, CHAOS Net\n        XETH,                   Experimental EtherNet (3 MBit)\n        ARPA,                   ARPANet\n        CHP,                    CHAOS protocol net\n        OSL,                    Serial line interface\n        Eth,                    EtherNet (10 MBit)\n        SL,                     New serial line link\n        X28,                    X.28\n        DMR,                    DEC DMR interface\n        TKR,                    802.5 token ring\n        SNK,                    Sink network (not a real network)\n        X25,                    X25 network\n        MAN,                    802.6 metro area network\n        ATR,                    Apollo Token Ring\n        FDDI,                   FDDI\n        SRLY,                   SDLC relay int\n        IPPN,                   IP Protocol Net\n        FR,                     Frame Relay network\n        PPP,                    PPP network\n        BDG,                    Bridging pseudo-handler\n        NULL,                   Null device\n        GWT_NTYPE_B_ISDN,       ISDN network B channel\n        SDLC,                   TRUE SDLC int\n        V25B,                   V.25bis base network\n        R->N,                   Teldat Micro-node\n        N->R,                   Teldat Router\n        GWT_NTYPE_D_ISDN,       RDSI D channel\n        270,                    270 Virtual port\n        XOT,                    XOT\n        TNIP,                   IP tunnel\n        MPPP,                   PPP Multilink\n        ATM,                    ATM Interface\n        SUBATM,                 ATM subinterface\n        IPSEC,                  IPSEC\n        BRI,                    RDSI (2Bs)\n        X25_FAK,                X25 fake\n        ISDNB_FAK,              ISDNB fake\n        ISDND_FAK,              ISDND fake\n        XOT_FAK,                XOT fake\n        270_FAK,                270 fake\n        ASDP,                   Asynchronous serial device\n        SYNC_SL,                Synchronous serial line\n        ASYNC_SL,               Asynchronous serial line\n        APTB,                   Asynchronous serial line\n        DIALROUT,               Fake for Dial Routing\n        ARLY,                   AP alarms relay\n        MEM,                    PCI Memory card\n        VLAN_ETH,               VLAN Ethernet\n        VOIP,                   VoIP card\n        L2TP,                   L2TP Virtual Interface\n        BVI,                    Bridge Virtual Interface\n        SCADA,                  SCADA Virtual Interface\n        WLAN,                   Wireless LAN\n        SEPI,                   Serial Event Printing Interface\n        EIB_Z,                  Zennio EIB Adapter\n        GPIO,                   General Parallel I/O\n        AUTO_SL,                Synchronous serial line\n        MDMEMU,                 Modem Emulator Interface\n        FR_SUB,                 FR subinterface\n        BVI_SUB,                BVI subinterface\n        NIC,                    USB_NIC Device\n        DIP,                    Generic DirectIP encapsulation\n        IEC101GW,               SCADA Virtual Interface\n        GPS,                    GPS Receiver Interface\n        GPSDATA_SL,             GPS DATA Serial line')
telProdNpMonInterfGeneralOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralOrder.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralOrder.setDescription('This type interface number.')
telProdNpMonInterfGeneralCsr = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralCsr.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralCsr.setDescription('Command and Status Register address.')
telProdNpMonInterfGeneralVect = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralVect.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralVect.setDescription('Interruption vector.')
telProdNpMonInterfGeneralTestvalid = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTestvalid.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTestvalid.setDescription('Times the auto-test has succeded (the interface status changes\n        from down to up).')
telProdNpMonInterfGeneralTestfailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTestfailure.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralTestfailure.setDescription('Times the auto-test has failed (the interface status changes\n        from up to down).')
telProdNpMonInterfGeneralMaintenFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfGeneralMaintenFailure.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfGeneralMaintenFailure.setDescription('Number of maintenance failures.')
telProdNpMonInterfErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3), )
if mibBuilder.loadTexts: telProdNpMonInterfErrorsTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsTable.setDescription('Error table. It shows error statistics for the network.')
telProdNpMonInterfErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfErrorsIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfErrorsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsEntry.setDescription('Each entry reports the interface errors.')
telProdNpMonInterfErrorsIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIfc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIfc.setDescription('Interface number. Table index.')
telProdNpMonInterfErrorsKind = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67))).clone(namedValues=NamedValues(("vi", 1), ("pn", 2), ("pri", 3), ("xeth", 4), ("arpa", 5), ("chp", 6), ("osl", 7), ("eth", 8), ("sl", 9), ("x28", 10), ("dmr", 11), ("tkr", 12), ("snk", 13), ("x25", 14), ("man", 15), ("atr", 16), ("fddi", 17), ("srly", 18), ("ippn", 19), ("fr", 20), ("ppp", 21), ("bdg", 22), ("null", 23), ("isdnb", 24), ("sdlc", 25), ("v25b", 26), ("routernode", 27), ("noderouter", 28), ("isdnd", 29), ("xot", 30), ("int270", 31), ("tnip", 32), ("mppp", 33), ("atm", 34), ("subatm", 35), ("ipsec", 36), ("bri", 37), ("x25fak", 38), ("isdnbfak", 39), ("isdndfak", 40), ("xotfak", 41), ("int270fak", 42), ("asdp", 43), ("syncsl", 44), ("asyncsl", 45), ("aptb", 46), ("dialrout", 47), ("arly", 48), ("mem", 49), ("vlaneth", 50), ("voip", 51), ("l2tp", 52), ("bvi", 53), ("scada", 54), ("wlan", 55), ("sepi", 56), ("eibz", 57), ("gpio", 58), ("autosl", 59), ("mdmemu", 60), ("frsub", 61), ("bvisub", 62), ("nic", 63), ("dip", 64), ("iec101gw", 65), ("gps", 66), ("gpsdatasl", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsKind.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsKind.setDescription('Interface type.\n        VI,                     VI LNI\n        PN,                     ProNET\n        PRI,                    PRI IFC CH, CHAOS Net\n        XETH,                   Experimental EtherNet (3 MBit)\n        ARPA,                   ARPANet\n        CHP,                    CHAOS protocol net\n        OSL,                    Serial line interface\n        Eth,                    EtherNet (10 MBit)\n        SL,                     New serial line link\n        X28,                    X.28\n        DMR,                    DEC DMR interface\n        TKR,                    802.5 token ring\n        SNK,                    Sink network (not a real network)\n        X25,                    X25 network\n        MAN,                    802.6 metro area network\n        ATR,                    Apollo Token Ring\n        FDDI,                   FDDI\n        SRLY,                   SDLC relay int\n        IPPN,                   IP Protocol Net\n        FR,                     Frame Relay network\n        PPP,                    PPP network\n        BDG,                    Bridging pseudo-handler\n        NULL,                   Null device\n        GWT_NTYPE_B_ISDN,       ISDN network B channel\n        SDLC,                   TRUE SDLC int\n        V25B,                   V.25bis base network\n        R->N,                   Teldat Micro-node\n        N->R,                   Teldat Router\n        GWT_NTYPE_D_ISDN,       RDSI D channel\n        270,                    270 Virtual port\n        XOT,                    XOT\n        TNIP,                   IP tunnel\n        MPPP,                   PPP Multilink\n        ATM,                    ATM Interface\n        SUBATM,                 ATM subinterface\n        IPSEC,                  IPSEC\n        BRI,                    RDSI (2Bs)\n        X25_FAK,                X25 fake\n        ISDNB_FAK,              ISDNB fake\n        ISDND_FAK,              ISDND fake\n        XOT_FAK,                XOT fake\n        270_FAK,                270 fake\n        ASDP,                   Asynchronous serial device\n        SYNC_SL,                Synchronous serial line\n        ASYNC_SL,               Asynchronous serial line\n        APTB,                   Asynchronous serial line\n        DIALROUT,               Fake for Dial Routing\n        ARLY,                   AP alarms relay\n        MEM,                    PCI Memory card\n        VLAN_ETH,               VLAN Ethernet\n        VOIP,                   VoIP card\n        L2TP,                   L2TP Virtual Interface\n        BVI,                    Bridge Virtual Interface\n        SCADA,                  SCADA Virtual Interface\n        WLAN,                   Wireless LAN\n        SEPI,                   Serial Event Printing Interface\n        EIB_Z,                  Zennio EIB Adapter\n        GPIO,                   General Parallel I/O\n        AUTO_SL,                Synchronous serial line\n        MDMEMU,                 Modem Emulator Interface\n        FR_SUB,                 FR subinterface\n        BVI_SUB,                BVI subinterface\n        NIC,                    USB_NIC Device\n        DIP,                    Generic DirectIP encapsulation\n        IEC101GW,               SCADA Virtual Interface\n        GPS,                    GPS Receiver Interface\n        GPSDATA_SL,             GPS DATA Serial line')
telProdNpMonInterfErrorsOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOrder.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOrder.setDescription('This type interface number.')
telProdNpMonInterfErrorsIdiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIdiscard.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIdiscard.setDescription('Number of discarded packets due to flow control on reception.')
telProdNpMonInterfErrorsIerrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIerrors.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIerrors.setDescription('Number of faulty packets found in the link layer.')
telProdNpMonInterfErrorsIunkprot = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIunkprot.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsIunkprot.setDescription('Number of received packets for an unknown protocol.')
telProdNpMonInterfErrorsOflowdrop = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOflowdrop.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOflowdrop.setDescription('Number of received packets that have been discarded later due to\n        flow control in transmission.')
telProdNpMonInterfErrorsOdiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOdiscard.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOdiscard.setDescription('Number of discarded packets due to flow control in transmission.')
telProdNpMonInterfErrorsOerrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOerrors.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfErrorsOerrors.setDescription('Number of output errors, such as attempts to send to a network that\n        has crashed during transmission.')
telProdNpMonInterfQueueTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4), )
if mibBuilder.loadTexts: telProdNpMonInterfQueueTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueTable.setDescription('It shows statistics about input and output queues in the specified\n        interfaces. The provided information consists of:\n        -Total number of assigned buffers\n        -Value of the low layer buffer\n        -Number of active buffers at present in the interface.')
telProdNpMonInterfQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfQueueIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfQueueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueEntry.setDescription('There is an entry per interface.')
telProdNpMonInterfQueueIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueIfc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonInterfQueueIfc.setDescription('Interface number. Table index.')
telProdNpMonInterfQueueKind = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67))).clone(namedValues=NamedValues(("vi", 1), ("pn", 2), ("pri", 3), ("xeth", 4), ("arpa", 5), ("chp", 6), ("osl", 7), ("eth", 8), ("sl", 9), ("x28", 10), ("dmr", 11), ("tkr", 12), ("snk", 13), ("x25", 14), ("man", 15), ("atr", 16), ("fddi", 17), ("srly", 18), ("ippn", 19), ("fr", 20), ("ppp", 21), ("bdg", 22), ("null", 23), ("isdnb", 24), ("sdlc", 25), ("v25b", 26), ("routernode", 27), ("noderouter", 28), ("isdnd", 29), ("xot", 30), ("int270", 31), ("tnip", 32), ("mppp", 33), ("atm", 34), ("subatm", 35), ("ipsec", 36), ("bri", 37), ("x25fak", 38), ("isdnbfak", 39), ("isdndfak", 40), ("xotfak", 41), ("int270fak", 42), ("asdp", 43), ("syncsl", 44), ("asyncsl", 45), ("aptb", 46), ("dialrout", 47), ("arly", 48), ("mem", 49), ("vlaneth", 50), ("voip", 51), ("l2tp", 52), ("bvi", 53), ("scada", 54), ("wlan", 55), ("sepi", 56), ("eibz", 57), ("gpio", 58), ("autosl", 59), ("mdmemu", 60), ("frsub", 61), ("bvisub", 62), ("nic", 63), ("dip", 64), ("iec101gw", 65), ("gps", 66), ("gpsdatasl", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueKind.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueKind.setDescription('Interface type.\n        VI,                     VI LNI\n        PN,                     ProNET\n        PRI,                    PRI IFC CH, CHAOS Net\n        XETH,                   Experimental EtherNet (3 MBit)\n        ARPA,                   ARPANet\n        CHP,                    CHAOS protocol net\n        OSL,                    Serial line interface\n        Eth,                    EtherNet (10 MBit)\n        SL,                     New serial line link\n        X28,                    X.28\n        DMR,                    DEC DMR interface\n        TKR,                    802.5 token ring\n        SNK,                    Sink network (not a real network)\n        X25,                    X25 network\n        MAN,                    802.6 metro area network\n        ATR,                    Apollo Token Ring\n        FDDI,                   FDDI\n        SRLY,                   SDLC relay int\n        IPPN,                   IP Protocol Net\n        FR,                     Frame Relay network\n        PPP,                    PPP network\n        BDG,                    Bridging pseudo-handler\n        NULL,                   Null device\n        GWT_NTYPE_B_ISDN,       ISDN network B channel\n        SDLC,                   TRUE SDLC int\n        V25B,                   V.25bis base network\n        R->N,                   Teldat Micro-node\n        N->R,                   Teldat Router\n        GWT_NTYPE_D_ISDN,       RDSI D channel\n        270,                    270 Virtual port\n        XOT,                    XOT\n        TNIP,                   IP tunnel\n        MPPP,                   PPP Multilink\n        ATM,                    ATM Interface\n        SUBATM,                 ATM subinterface\n        IPSEC,                  IPSEC\n        BRI,                    RDSI (2Bs)\n        X25_FAK,                X25 fake\n        ISDNB_FAK,              ISDNB fake\n        ISDND_FAK,              ISDND fake\n        XOT_FAK,                XOT fake\n        270_FAK,                270 fake\n        ASDP,                   Asynchronous serial device\n        SYNC_SL,                Synchronous serial line\n        ASYNC_SL,               Asynchronous serial line\n        APTB,                   Asynchronous serial line\n        DIALROUT,               Fake for Dial Routing\n        ARLY,                   AP alarms relay\n        MEM,                    PCI Memory card\n        VLAN_ETH,               VLAN Ethernet\n        VOIP,                   VoIP card\n        L2TP,                   L2TP Virtual Interface\n        BVI,                    Bridge Virtual Interface\n        SCADA,                  SCADA Virtual Interface\n        WLAN,                   Wireless LAN\n        SEPI,                   Serial Event Printing Interface\n        EIB_Z,                  Zennio EIB Adapter\n        GPIO,                   General Parallel I/O\n        AUTO_SL,                Synchronous serial line\n        MDMEMU,                 Modem Emulator Interface\n        FR_SUB,                 FR subinterface\n        BVI_SUB,                BVI subinterface\n        NIC,                    USB_NIC Device\n        DIP,                    Generic DirectIP encapsulation\n        IEC101GW,               SCADA Virtual Interface\n        GPS,                    GPS Receiver Interface\n        GPSDATA_SL,             GPS DATA Serial line')
telProdNpMonInterfQueueOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueOrder.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueOrder.setDescription('Interface number.')
telProdNpMonInterfQueueIalloc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueIalloc.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueIalloc.setDescription('Number of input buffers assigned to this device.')
telProdNpMonInterfQueueIlow = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueIlow.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueIlow.setDescription('Water mark for flow control in the device.')
telProdNpMonInterfQueueIcurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueIcurrent.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueIcurrent.setDescription('Current number of input buffers to this device. The value is 0\n        when the device is disabled.')
telProdNpMonInterfQueueOfair = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueOfair.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueOfair.setDescription('Fair level for output queue in the device.')
telProdNpMonInterfQueueOcurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfQueueOcurrent.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfQueueOcurrent.setDescription('Number of packets currently waiting for transmission in this\n        device.')
telProdNpMonInterfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5), )
if mibBuilder.loadTexts: telProdNpMonInterfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsTable.setDescription('It contains statistics information with reference to the network\n        software, such as network configuration in the router.')
telProdNpMonInterfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1), ).setIndexNames((0, "TELDAT-MON-CommonInfo-MIB", "telProdNpMonInterfStatsIfc"))
if mibBuilder.loadTexts: telProdNpMonInterfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsEntry.setDescription('Each register provides information about an interface.')
telProdNpMonInterfStatsIfc = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsIfc.setStatus('obsolete')
if mibBuilder.loadTexts: telProdNpMonInterfStatsIfc.setDescription('Interface number. Table index.')
telProdNpMonInterfStatsKind = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67))).clone(namedValues=NamedValues(("vi", 1), ("pn", 2), ("pri", 3), ("xeth", 4), ("arpa", 5), ("chp", 6), ("osl", 7), ("eth", 8), ("sl", 9), ("x28", 10), ("dmr", 11), ("tkr", 12), ("snk", 13), ("x25", 14), ("man", 15), ("atr", 16), ("fddi", 17), ("srly", 18), ("ippn", 19), ("fr", 20), ("ppp", 21), ("bdg", 22), ("null", 23), ("isdnb", 24), ("sdlc", 25), ("v25b", 26), ("routernode", 27), ("noderouter", 28), ("isdnd", 29), ("xot", 30), ("int270", 31), ("tnip", 32), ("mppp", 33), ("atm", 34), ("subatm", 35), ("ipsec", 36), ("bri", 37), ("x25fak", 38), ("isdnbfak", 39), ("isdndfak", 40), ("xotfak", 41), ("int270fak", 42), ("asdp", 43), ("syncsl", 44), ("asyncsl", 45), ("aptb", 46), ("dialrout", 47), ("arly", 48), ("mem", 49), ("vlaneth", 50), ("voip", 51), ("l2tp", 52), ("bvi", 53), ("scada", 54), ("wlan", 55), ("sepi", 56), ("eibz", 57), ("gpio", 58), ("autosl", 59), ("mdmemu", 60), ("frsub", 61), ("bvisub", 62), ("nic", 63), ("dip", 64), ("iec101gw", 65), ("gps", 66), ("gpsdatasl", 67)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsKind.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsKind.setDescription('Interface type.\n        VI,                     VI LNI\n        PN,                     ProNET\n        PRI,                    PRI IFC CH, CHAOS Net\n        XETH,                   Experimental EtherNet (3 MBit)\n        ARPA,                   ARPANet\n        CHP,                    CHAOS protocol net\n        OSL,                    Serial line interface\n        Eth,                    EtherNet (10 MBit)\n        SL,                     New serial line link\n        X28,                    X.28\n        DMR,                    DEC DMR interface\n        TKR,                    802.5 token ring\n        SNK,                    Sink network (not a real network)\n        X25,                    X25 network\n        MAN,                    802.6 metro area network\n        ATR,                    Apollo Token Ring\n        FDDI,                   FDDI\n        SRLY,                   SDLC relay int\n        IPPN,                   IP Protocol Net\n        FR,                     Frame Relay network\n        PPP,                    PPP network\n        BDG,                    Bridging pseudo-handler\n        NULL,                   Null device\n        GWT_NTYPE_B_ISDN,       ISDN network B channel\n        SDLC,                   TRUE SDLC int\n        V25B,                   V.25bis base network\n        R->N,                   Teldat Micro-node\n        N->R,                   Teldat Router\n        GWT_NTYPE_D_ISDN,       RDSI D channel\n        270,                    270 Virtual port\n        XOT,                    XOT\n        TNIP,                   IP tunnel\n        MPPP,                   PPP Multilink\n        ATM,                    ATM Interface\n        SUBATM,                 ATM subinterface\n        IPSEC,                  IPSEC\n        BRI,                    RDSI (2Bs)\n        X25_FAK,                X25 fake\n        ISDNB_FAK,              ISDNB fake\n        ISDND_FAK,              ISDND fake\n        XOT_FAK,                XOT fake\n        270_FAK,                270 fake\n        ASDP,                   Asynchronous serial device\n        SYNC_SL,                Synchronous serial line\n        ASYNC_SL,               Asynchronous serial line\n        APTB,                   Asynchronous serial line\n        DIALROUT,               Fake for Dial Routing\n        ARLY,                   AP alarms relay\n        MEM,                    PCI Memory card\n        VLAN_ETH,               VLAN Ethernet\n        VOIP,                   VoIP card\n        L2TP,                   L2TP Virtual Interface\n        BVI,                    Bridge Virtual Interface\n        SCADA,                  SCADA Virtual Interface\n        WLAN,                   Wireless LAN\n        SEPI,                   Serial Event Printing Interface\n        EIB_Z,                  Zennio EIB Adapter\n        GPIO,                   General Parallel I/O\n        AUTO_SL,                Synchronous serial line\n        MDMEMU,                 Modem Emulator Interface\n        FR_SUB,                 FR subinterface\n        BVI_SUB,                BVI subinterface\n        NIC,                    USB_NIC Device\n        DIP,                    Generic DirectIP encapsulation\n        IEC101GW,               SCADA Virtual Interface\n        GPS,                    GPS Receiver Interface\n        GPSDATA_SL,             GPS DATA Serial line')
telProdNpMonInterfStatsOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsOrder.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsOrder.setDescription('Interface number.')
telProdNpMonInterfStatsUnipkrcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsUnipkrcv.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsUnipkrcv.setDescription('Number of no-multicast, no-broadcast packets specificly addressed\n        in the MAC sub-layer.')
telProdNpMonInterfStatsMulpkrcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsMulpkrcv.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsMulpkrcv.setDescription('Number of received multicast or broadcast packets.')
telProdNpMonInterfStatsBytesrcv = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsBytesrcv.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsBytesrcv.setDescription('Number of received bytes  in this interface MAC sub-layer.')
telProdNpMonInterfStatsPkxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsPkxt.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsPkxt.setDescription('Number of unicast, multicast, or broadcast transmitted packets.')
telProdNpMonInterfStatsBytesxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2007, 4, 1, 2, 2, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: telProdNpMonInterfStatsBytesxt.setStatus('mandatory')
if mibBuilder.loadTexts: telProdNpMonInterfStatsBytesxt.setDescription('Number of transmitted bytes in the MAC sub-layer.')
mibBuilder.exportSymbols("TELDAT-MON-CommonInfo-MIB", telProdNpMonInterfGeneralTable=telProdNpMonInterfGeneralTable, telProdNpMonInterfStatsKind=telProdNpMonInterfStatsKind, telProdNpMonSistemMemPool1available=telProdNpMonSistemMemPool1available, telProdNpMonInterfBufferHdr=telProdNpMonInterfBufferHdr, telProdNpMonInterfStatsBytesrcv=telProdNpMonInterfStatsBytesrcv, telProdNpMonInterfBufferReq=telProdNpMonInterfBufferReq, telProdNpMonInterfBufferTrail=telProdNpMonInterfBufferTrail, telProdNpMonInterfStatsPkxt=telProdNpMonInterfStatsPkxt, telProdNpMonInterfQueueKind=telProdNpMonInterfQueueKind, telProdNpMonInterfStatsEntry=telProdNpMonInterfStatsEntry, telProdNpMonInterfErrorsKind=telProdNpMonInterfErrorsKind, telProdNpMonSistemMemAvailable=telProdNpMonSistemMemAvailable, telProdNpMonInterfBufferData=telProdNpMonInterfBufferData, telProdNpMonInterfBufferTable=telProdNpMonInterfBufferTable, telProdNpMonSistemMemTotalnoncache=telProdNpMonSistemMemTotalnoncache, telProdNpMonSistemMemPooldissize=telProdNpMonSistemMemPooldissize, telProdNpMonInterfGeneralIfc=telProdNpMonInterfGeneralIfc, telProdNpMonInterfErrorsOdiscard=telProdNpMonInterfErrorsOdiscard, telProdNpMonSistemMemPoolpsize=telProdNpMonSistemMemPoolpsize, telProdNpMonSistemMemPoolpavailable=telProdNpMonSistemMemPoolpavailable, telProdNpMonSistemMemSize=telProdNpMonSistemMemSize, telProdNpMonSistemMemPool0restpart=telProdNpMonSistemMemPool0restpart, telProdNpMonInterfGeneralTestfailure=telProdNpMonInterfGeneralTestfailure, telProdNpMonInterfStatsOrder=telProdNpMonInterfStatsOrder, telProdNpMonInterfBufferKind=telProdNpMonInterfBufferKind, telProdNpMonSistemMemFlash=telProdNpMonSistemMemFlash, telProdNpMonSistemMemPool1restpart=telProdNpMonSistemMemPool1restpart, telProdNpMonInterfErrorsOerrors=telProdNpMonInterfErrorsOerrors, telProdNpMonSistemMemPool0available=telProdNpMonSistemMemPool0available, telProdNpMonSistemMemPooldlsavailable=telProdNpMonSistemMemPooldlsavailable, telProdNpMonSistemFan=telProdNpMonSistemFan, telProdNpMonInterfBufferLow=telProdNpMonInterfBufferLow, telProdNpMonInterfErrorsIfc=telProdNpMonInterfErrorsIfc, telProdNpMonInterfStatsMulpkrcv=telProdNpMonInterfStatsMulpkrcv, telProdNpMonSistemMemIcused=telProdNpMonSistemMemIcused, telProdNpMonSistemMemTc=telProdNpMonSistemMemTc, telProdNpMonInterfBufferOrder=telProdNpMonInterfBufferOrder, telProdNpMonInterfBufferIfc=telProdNpMonInterfBufferIfc, telProdNpMonSistemMemPool2restpart=telProdNpMonSistemMemPool2restpart, telProdNpMonSistemMemTotal=telProdNpMonSistemMemTotal, telProdNpMonInterfQueueIalloc=telProdNpMonInterfQueueIalloc, telProdNpMonInterfGeneralVect=telProdNpMonInterfGeneralVect, telProdNpMonInterfQueueIfc=telProdNpMonInterfQueueIfc, telProdNpMonInterfErrorsTable=telProdNpMonInterfErrorsTable, telProdNpMonInterfQueueOcurrent=telProdNpMonInterfQueueOcurrent, telProdNpMonSistemMemPool0size=telProdNpMonSistemMemPool0size, telProdNpMonInterfBufferEntry=telProdNpMonInterfBufferEntry, telProdNpMonSistemMemPooldlssize=telProdNpMonSistemMemPooldlssize, telProdNpMonInterfErrorsOflowdrop=telProdNpMonInterfErrorsOflowdrop, telProdNpMonPoeCardsState=telProdNpMonPoeCardsState, telProdNpMonInterfCommandsTable=telProdNpMonInterfCommandsTable, telProdNpMonPoeCardsEntry=telProdNpMonPoeCardsEntry, telProdNpMonInterfQueueIlow=telProdNpMonInterfQueueIlow, telProdNpMonSistemMemPool1size=telProdNpMonSistemMemPool1size, telProdNpMonInterfBufferCurr=telProdNpMonInterfBufferCurr, telProdNpMonSistemFanCpuPerCent=telProdNpMonSistemFanCpuPerCent, telProdNpMonInterfGeneralTestvalid=telProdNpMonInterfGeneralTestvalid, telProdNpMonInterfStatsUnipkrcv=telProdNpMonInterfStatsUnipkrcv, telProdNpMonSistemMemPooltavailable=telProdNpMonSistemMemPooltavailable, telProdNpMonInterfErrorsIunkprot=telProdNpMonInterfErrorsIunkprot, telProdNpMonSistemFanCase=telProdNpMonSistemFanCase, telProdNpMonSistemMemPoolmdissize=telProdNpMonSistemMemPoolmdissize, telProdNpMonSistemMemPool2available=telProdNpMonSistemMemPool2available, telProdNpMonInterfErrorsIerrors=telProdNpMonInterfErrorsIerrors, telProdNpMonPoeCardsInd=telProdNpMonPoeCardsInd, telProdNpMonPoeCardsTable=telProdNpMonPoeCardsTable, telProdNpMonSistemMemIcindex=telProdNpMonSistemMemIcindex, telProdNpMonSistemMemPooldlsrestpart=telProdNpMonSistemMemPooldlsrestpart, telProdNpMonInterfQueueTable=telProdNpMonInterfQueueTable, telProdNpMonInterfGeneralOrder=telProdNpMonInterfGeneralOrder, telProdNpMonInterfGeneralKind=telProdNpMonInterfGeneralKind, telProdNpMonSistemMemPooldisavailable=telProdNpMonSistemMemPooldisavailable, telProdNpMonInterfBufferAlloc=telProdNpMonInterfBufferAlloc, telProdNpMonSistemMemTotalcache=telProdNpMonSistemMemTotalcache, telProdNpMonSistemMemFreecache=telProdNpMonSistemMemFreecache, telProdNpMonInterfCommandsIfc=telProdNpMonInterfCommandsIfc, telProdNpMonSistemMemPooltsize=telProdNpMonSistemMemPooltsize, telProdNpMonInterfBufferWrap=telProdNpMonInterfBufferWrap, telProdNpMonSistemMemPoolirestpart=telProdNpMonSistemMemPoolirestpart, telProdNpMonInterfQueueOfair=telProdNpMonInterfQueueOfair, telProdNpMonInterfCommandsClear=telProdNpMonInterfCommandsClear, telProdNpMonSistemFanCasePerCent=telProdNpMonSistemFanCasePerCent, telProdNpMonSistemMemPoolisize=telProdNpMonSistemMemPoolisize, telProdNpMonInterfErrorsOrder=telProdNpMonInterfErrorsOrder, telProdNpMonInterfBufferTotal=telProdNpMonInterfBufferTotal, telProdNpMonSistemMemCaches=telProdNpMonSistemMemCaches, telProdNpMonInterfGeneralEntry=telProdNpMonInterfGeneralEntry, telProdNpMonInterfBufferAlloc2=telProdNpMonInterfBufferAlloc2, telProdNpMonInterfStatsIfc=telProdNpMonInterfStatsIfc, telProdNpMonInterfStatsBytesxt=telProdNpMonInterfStatsBytesxt, telProdNpMonInterfQueueIcurrent=telProdNpMonInterfQueueIcurrent, telProdNpMonSistemMemPoolmdisavailable=telProdNpMonSistemMemPoolmdisavailable, telProdNpMonInterfStatsTable=telProdNpMonInterfStatsTable, telProdNpMonSistemMemFreeglobbuffer=telProdNpMonSistemMemFreeglobbuffer, telProdNpMonSistemMemPool2size=telProdNpMonSistemMemPool2size, telProdNpMonInterfQueueEntry=telProdNpMonInterfQueueEntry, telProdNpMonInterfQueueOrder=telProdNpMonInterfQueueOrder, telProdNpMonSistemFanCpu=telProdNpMonSistemFanCpu, telProdNpMonInterfGeneralMaintenFailure=telProdNpMonInterfGeneralMaintenFailure, telProdNpMonInterfGeneralCsr=telProdNpMonInterfGeneralCsr, telProdNpMonSistemMemHeap=telProdNpMonSistemMemHeap, telProdNpMonSistemMemPooliavailable=telProdNpMonSistemMemPooliavailable, telProdNpMonSistemMemory=telProdNpMonSistemMemory, telProdNpMonInterfCommandsEntry=telProdNpMonInterfCommandsEntry, telProdNpMonInterfErrorsEntry=telProdNpMonInterfErrorsEntry, telProdNpMonInterfErrorsIdiscard=telProdNpMonInterfErrorsIdiscard, telProdNpMonSistemMemFreenoncache=telProdNpMonSistemMemFreenoncache)
