#
# PySNMP MIB module HYTERA-REPEATER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hytera/HYTERA-REPEATER-MIB
# Produced by pysmi-1.1.12 at Mon Sep 16 14:56:17 2024
# On host fv-az1272-448 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, private, ObjectIdentity, TimeTicks, Counter32, Bits, Integer32, Counter64, ModuleIdentity, Unsigned32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, NotificationType, Gauge32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "private", "ObjectIdentity", "TimeTicks", "Counter32", "Bits", "Integer32", "Counter64", "ModuleIdentity", "Unsigned32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "NotificationType", "Gauge32", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hyteraRepeaterMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 40297))
product = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1))
repeater = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2))
rptRealTimeInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1))
rptControl = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2))
rptLog = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3))
rptSystemInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4))
rptConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5))
rptAlarmInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1))
rptVoltageAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptVoltageAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptVoltageAlarm.setDescription('The voltage alarm.\n\t\t normal(0), low voltage alarm(1), high voltage alarm(2), abnormal(3).\n\t\t The abnormal condition is used for RD960. For the RD960 do not distinguish\n\t\t low voltage alarm and high voltage alarm, we use abnormal to replace them.')
rptTemperatureAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptTemperatureAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptTemperatureAlarm.setDescription('The temperature alarm.\n\t\t normal(0), low temperature alarm(1), high temperature alarm(2).')
rptFanAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptFanAlarm.setStatus('optional')
if mibBuilder.loadTexts: rptFanAlarm.setDescription('The fan alarm.\n\t\t normal(0), alarm(1).\n\t\t The object is not supported yet.')
rptForwardAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptForwardAlarm.setStatus('optional')
if mibBuilder.loadTexts: rptForwardAlarm.setDescription('The forward power alarm.\n\t\t undefined(-1), normal(0), alarm(1).\n\t\t The object is not supported yet.')
rptReflectedAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptReflectedAlarm.setStatus('optional')
if mibBuilder.loadTexts: rptReflectedAlarm.setDescription('The reflected power alarm.\n\t\t undefined(-1), normal(0), alarm(1).\n\t\t The object is not supported yet.')
rptVswrAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptVswrAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptVswrAlarm.setDescription('The voltage standing wave radio alarm.\n\t\t normal(0), alarm(1).')
rptTxPllAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptTxPllAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptTxPllAlarm.setDescription('The transmitting PLL alarm.\n\t\t normal(0), alarm(1).')
rptRxPllAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptRxPllAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptRxPllAlarm.setDescription('The receiving PLL alarm.\n\t\t normal(0), alarm(1).')
rptBatteryVoltageAlarm = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptBatteryVoltageAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rptBatteryVoltageAlarm.setDescription('The battery voltage alarm.\n\t\t normal(0), abnormal(1).')
rptDataInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2))
rptVoltage = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: rptVoltage.setDescription('The voltage.\n\t\t It should be changed to float format.\n\t\t If the repeater is rd620 and rd960, the value is invalid.')
rptPaTemprature = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptPaTemprature.setStatus('mandatory')
if mibBuilder.loadTexts: rptPaTemprature.setDescription('The temperature.\n\t\t It should be changed to float format.\n\t\t The value is invalid, if the repeater is rd960.')
rptFanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptFanSpeed.setStatus('optional')
if mibBuilder.loadTexts: rptFanSpeed.setDescription('The fan speed.\n\t\t The object is not supported yet.')
rptVswr = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptVswr.setStatus('mandatory')
if mibBuilder.loadTexts: rptVswr.setDescription('The VSWR.\n\t\t It should be changed to float format. ')
rptTxFwdPower = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptTxFwdPower.setStatus('mandatory')
if mibBuilder.loadTexts: rptTxFwdPower.setDescription('The forward power.\n\t\t It should be changed to float format.\n\t\t The value is invalid, if the repeater is rd960 or rd620.')
rptTxRefPower = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptTxRefPower.setStatus('mandatory')
if mibBuilder.loadTexts: rptTxRefPower.setDescription('The reflected power.\n\t\t It should be changed to float format.\n\t\t The value is invalid, if the repeater is rd960 or rd620.')
rptDataInfoBak1 = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptDataInfoBak1.setStatus('optional')
if mibBuilder.loadTexts: rptDataInfoBak1.setDescription('The backup object.\n\t\t The object is not supported yet.')
rptDataInfoBak2 = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptDataInfoBak2.setStatus('optional')
if mibBuilder.loadTexts: rptDataInfoBak2.setDescription('The backup object.\n\t\tThe object is not supported yet.')
rptSlot1Rssi = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 9), Integer32().clone(-200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptSlot1Rssi.setStatus('mandatory')
if mibBuilder.loadTexts: rptSlot1Rssi.setDescription('The RSSI value of slot1.\n\t\t unit: dB.')
rptSlot2Rssi = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 10), Integer32().clone(-200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptSlot2Rssi.setStatus('mandatory')
if mibBuilder.loadTexts: rptSlot2Rssi.setDescription('The RSSI value of slot2.\n\t\t unit: dB.\n\t\t The value is valid only in digital model.')
rptSupplyPowerType = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptSupplyPowerType.setStatus('mandatory')
if mibBuilder.loadTexts: rptSupplyPowerType.setDescription('The type of power.\n\t\t DC(0), Battery(1).')
rptBatteryConnect = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptBatteryConnect.setStatus('mandatory')
if mibBuilder.loadTexts: rptBatteryConnect.setDescription('The battery connecting condition.\n\t\t disconnected(0), connected(1).')
rptBatteryVoltage = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 1, 2, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptBatteryVoltage.setStatus('optional')
if mibBuilder.loadTexts: rptBatteryVoltage.setDescription('The battery voltage.\n\t\t The object is not supported yet.')
rptRestart = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptRestart.setStatus('mandatory')
if mibBuilder.loadTexts: rptRestart.setDescription('Restart the repeater.\n\t\t do nothing(0), reset(1).')
rptChannelNumber = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptChannelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rptChannelNumber.setDescription('The current channel number in the zone.')
rptChannelType = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: rptChannelType.setDescription('The current channel type.\n\t\t digital(0), analog(1), mixed(2).')
rptControlObjBak1 = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptControlObjBak1.setStatus('optional')
if mibBuilder.loadTexts: rptControlObjBak1.setDescription('The backup object.\n\t\t The object is not supported yet.')
rptTxPowerLevel = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptTxPowerLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rptTxPowerLevel.setDescription('The transmit power level.\n\t\t high(0), low(2).')
rptKnockdown = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptKnockdown.setStatus('mandatory')
if mibBuilder.loadTexts: rptKnockdown.setDescription('The status of repeating.\n\t\t repeating(0), knockdown(1).')
rptRadioState = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptRadioState.setStatus('mandatory')
if mibBuilder.loadTexts: rptRadioState.setDescription("The status of the repeater's normal function.\n\t\t enable(0), disable(1).")
rptSnmpTrapIp = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptSnmpTrapIp.setStatus('mandatory')
if mibBuilder.loadTexts: rptSnmpTrapIp.setDescription('The SNMP trapping IP address.\n     The default value is 230.37.0.0.')
rptSnmpTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(162, 162)).clone(162)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptSnmpTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: rptSnmpTrapPort.setDescription('The SNMP trapping port.')
rptchannelParaTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10), )
if mibBuilder.loadTexts: rptchannelParaTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptchannelParaTable.setDescription("The table of channel's parameters relevant to the repeater's channels.")
channelParaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "channelParaIndex"))
if mibBuilder.loadTexts: channelParaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: channelParaEntry.setDescription("The channel's parameters for one of the repeater's channels.")
channelParaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelParaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: channelParaIndex.setDescription("The index of the table which uniquely identifies the channel's parameters.")
actChannelAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: actChannelAlias.setStatus('mandatory')
if mibBuilder.loadTexts: actChannelAlias.setDescription('The channel alias.\n\t   It is an unicode string')
actChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: actChannelType.setDescription('The channel type.\n\t   digital(0), analog(1), mixed(2).')
actTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actTxPower.setStatus('mandatory')
if mibBuilder.loadTexts: actTxPower.setDescription('The transmit power level.\n\t   high(0), low(2).')
actChannelNo = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actChannelNo.setStatus('mandatory')
if mibBuilder.loadTexts: actChannelNo.setDescription("The channel number in the repeater's zone.")
actChannelSubNo = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actChannelSubNo.setStatus('mandatory')
if mibBuilder.loadTexts: actChannelSubNo.setDescription('The channel number in the group of same type.')
rptForbid = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptForbid.setStatus('mandatory')
if mibBuilder.loadTexts: rptForbid.setDescription("The status of the repeater's all function.\n\t\t nomal(0), forbid(1).\n\t\t If the repeater is forbided, you can only wake up it by setting\n\t\t the rptRadioStatus object to 0 in local RDAC model.")
logTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1), )
if mibBuilder.loadTexts: logTable.setStatus('mandatory')
if mibBuilder.loadTexts: logTable.setDescription('The table of alarm records.')
logEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "logIndex"))
if mibBuilder.loadTexts: logEntry.setStatus('mandatory')
if mibBuilder.loadTexts: logEntry.setDescription("The record's content.")
logIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: logIndex.setStatus('mandatory')
if mibBuilder.loadTexts: logIndex.setDescription('The index of the table which uniquely identifies the alram record.')
alarmName = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 9), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmName.setStatus('mandatory')
if mibBuilder.loadTexts: alarmName.setDescription('The alarm name.\n\t   temperature alarm(0), fan alarm(1), vswr alarm(2), low forward power alarm(3),\n     low voltage alarm(4), high voltage alarm(5), tx unlock alarm(6),\n     rx unlock alarm(7), battery voltage alarm(8), invalid(65535).')
alarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: alarmStatus.setDescription('The alarm status.\n\t   alarm recove(0), alarm happen(1), invalid(65535).')
logTime = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 134217728)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: logTime.setStatus('mandatory')
if mibBuilder.loadTexts: logTime.setDescription('The alarm time.\n\t   unit: second.\n\t   The time is the time lapsed since the repeater starting up. If the value\n\t   is -1, the record is invalid.')
clearLog = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearLog.setStatus('mandatory')
if mibBuilder.loadTexts: clearLog.setDescription('Clear the log.\n\t   do nothing(0), clear log(0).')
recordCount = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: recordCount.setStatus('mandatory')
if mibBuilder.loadTexts: recordCount.setDescription('The number of records.')
latestRecordPosition = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: latestRecordPosition.setStatus('mandatory')
if mibBuilder.loadTexts: latestRecordPosition.setDescription('The row number of the latest record.\n\t   If the value is 0, there is no valid record in the table.')
rptModelName = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptModelName.setStatus('mandatory')
if mibBuilder.loadTexts: rptModelName.setDescription('The model name.\n\t\t It is an unicode string.')
rptModelNo = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptModelNo.setStatus('mandatory')
if mibBuilder.loadTexts: rptModelNo.setDescription('The model number.\n\t\t It is an unicode string.')
rptFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptFirmwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rptFirmwareVersion.setDescription('The firmware version.\n\t\t It is an unicode string.')
rptRcdbVersion = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptRcdbVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rptRcdbVersion.setDescription('The RCDB version.\n\t\t It is an unicode string.')
rptSerialNo = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptSerialNo.setStatus('mandatory')
if mibBuilder.loadTexts: rptSerialNo.setDescription('The serial number.\n\t\t It is an unicode string.')
rptRadioAlias = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptRadioAlias.setStatus('mandatory')
if mibBuilder.loadTexts: rptRadioAlias.setDescription('The repeater alias.\n\t\t It is an unicode string.')
rptRadioID = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptRadioID.setStatus('mandatory')
if mibBuilder.loadTexts: rptRadioID.setDescription('The ID of the repeater.')
rptCurChannelType = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptCurChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: rptCurChannelType.setDescription('The type of the wroking channel.\n\t\t digital(0), analog(1), mixed(2).')
rptChannelName = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptChannelName.setStatus('mandatory')
if mibBuilder.loadTexts: rptChannelName.setDescription('The name of the current channel.\n\t\t It is an unicode string.')
rptCurTxFreq = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptCurTxFreq.setStatus('mandatory')
if mibBuilder.loadTexts: rptCurTxFreq.setDescription('The current transmitting frequency.\n\t\t unit: Hz.')
rptCurRxFreq = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptCurRxFreq.setStatus('mandatory')
if mibBuilder.loadTexts: rptCurRxFreq.setDescription('The current receiving frequency.\n\t\t unit: Hz.')
rptWorkState = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptWorkState.setStatus('mandatory')
if mibBuilder.loadTexts: rptWorkState.setDescription('The work status of the repeater.\n\t\t receive(0), transmit(1).')
rptCurZoneAlias = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 4, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptCurZoneAlias.setStatus('mandatory')
if mibBuilder.loadTexts: rptCurZoneAlias.setDescription('The alias of the current zone.\n\t\t It is an unicode string.')
rptBasicSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1))
powerOn = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 1))
designatedPowerOnChn = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: designatedPowerOnChn.setStatus('mandatory')
if mibBuilder.loadTexts: designatedPowerOnChn.setDescription('Designate the power on channel.\n         disable(0), enable(1).')
powerOnChannelNo = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: powerOnChannelNo.setStatus('mandatory')
if mibBuilder.loadTexts: powerOnChannelNo.setDescription('The the power on channel number.\n\t\t invalid(65535).')
microphone = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 2))
internalMicGain = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 36)).clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: internalMicGain.setStatus('mandatory')
if mibBuilder.loadTexts: internalMicGain.setDescription('The gain of the internal microphone.\n\t\t It is double of the real value.')
externalMicGain = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 36)).clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: externalMicGain.setStatus('mandatory')
if mibBuilder.loadTexts: externalMicGain.setDescription('The gain of the external microphone.\n\t\t It is double of the real value.')
multiCTCCDCTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3), )
if mibBuilder.loadTexts: multiCTCCDCTable.setStatus('mandatory')
if mibBuilder.loadTexts: multiCTCCDCTable.setDescription('The table of subaudio frequency.')
multiCTCCDCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "ctcssIndex"))
if mibBuilder.loadTexts: multiCTCCDCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: multiCTCCDCEntry.setDescription('The subaudio frequency.')
ctcssIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctcssIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctcssIndex.setDescription('The index of the table which uniquely identifies the subaudio frequency.')
txCtcssFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(19, 492), ValueRangeConstraint(670, 2541), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txCtcssFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: txCtcssFrequency.setDescription("The transmitting subaudio frequency.\n\t\t The value is limitted to the range. The range is changed with the type:\n                 0        (txCtcssType: none)\n                 19~492   (txCtcssType: CDCSS or CDCSS invert)\n                 670~2541 (txCtcssType: CTCSS)\n     The value is 10 times of the real value when the type is CTCSS.\n     The value in first row is unable to be set.\n     It's not able to be set, unless the rxCtcssType in the same row is not none.\n     It will be set to the matched minimum available value automatically, when the\n     txCtcssType in the same row is changed.")
txCtcssType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txCtcssType.setStatus('mandatory')
if mibBuilder.loadTexts: txCtcssType.setDescription("The type of the transmitting subaudio frequency.\n\t none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).\n\t The value in first row is unable to be set.\n   It's not able to be set, unless the rxCtcssType in the same row is not none.")
rxCtcssFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(19, 492), ValueRangeConstraint(670, 2541), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rxCtcssFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: rxCtcssFrequency.setDescription('The receiving subaudio frequency.\n\t\t The value is limitted to the range and is not allowed to duplicate but 0.\n\t\t The range is changed with the type:0\n                 0        (rxCtcssType: none)\n                 19~492   (rxCtcssType: CDCSS or CDCSS invert)\n                 670~2541 (rxCtcssType: CTCSS)\n     The value is 10 times of the real value when the type is CTCSS.\n     The value in first row is unable to be set.\n     It will be set to the matched minimum available value automatically, when the\n     rxCtcssType in the same row is changed.')
rxCtcssType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rxCtcssType.setStatus('mandatory')
if mibBuilder.loadTexts: rxCtcssType.setDescription('The type of the receiving subaudio frequency.\n\t   none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).\n\t   It must be set according to line sequence.\n     The value in first row is unable to be set.')
audioPriority = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 4))
pathPriority = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pathPriority.setStatus('mandatory')
if mibBuilder.loadTexts: pathPriority.setDescription('The transmit path priority.\n\t\t PTT request(0), repeat request(1), first come first send(2).')
pttPriority = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pttPriority.setStatus('mandatory')
if mibBuilder.loadTexts: pttPriority.setDescription('The PTT priority.\n\t\t external PTT(0), front PTT(1), remote PTT(2), first come first send(3).')
jitterBufferLenth = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jitterBufferLenth.setStatus('mandatory')
if mibBuilder.loadTexts: jitterBufferLenth.setDescription('The jitter buffer length.')
analogCallHangTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogCallHangTime.setStatus('mandatory')
if mibBuilder.loadTexts: analogCallHangTime.setDescription('The analog call hang time.\n\t\t unit: second.')
repeatRequestPriority = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: repeatRequestPriority.setStatus('mandatory')
if mibBuilder.loadTexts: repeatRequestPriority.setDescription('The repeat request priority.\n\t\t local repeating(0), IP connect repeating(1), first come first send(2).')
rptDigitalChannelSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2))
digitalChnTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1), )
if mibBuilder.loadTexts: digitalChnTable.setStatus('mandatory')
if mibBuilder.loadTexts: digitalChnTable.setDescription("The table of digital channel's configuration parameters relevant to the\n\t\t repeater's digital channels.")
digitalChnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "digitalChnIndex"))
if mibBuilder.loadTexts: digitalChnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: digitalChnEntry.setDescription("The digital channel's configuration parameters for one of the repeater's digital channels.")
digitalChnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: digitalChnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: digitalChnIndex.setDescription("The index of the table which uniquely identifies the digital channel's parameter.\n\t\t It also represents the channel number which is counted from 1.")
digitalColorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: digitalColorCode.setStatus('mandatory')
if mibBuilder.loadTexts: digitalColorCode.setDescription('The color code.')
digitalIpMultisiteConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: digitalIpMultisiteConnect.setStatus('mandatory')
if mibBuilder.loadTexts: digitalIpMultisiteConnect.setDescription('The multisite connecting based on network.\n\t\t None(0), slot1(1), slot2(2), slot1&slot2(3).')
digitalReceiveFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: digitalReceiveFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: digitalReceiveFrequency.setDescription('The receiving frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
digitalTransmitFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: digitalTransmitFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: digitalTransmitFrequency.setDescription('The transmitting frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
digitalTxContactName = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: digitalTxContactName.setStatus('mandatory')
if mibBuilder.loadTexts: digitalTxContactName.setDescription('The row number of transmitting contact name.\n\t\t none(0), row number(1~512).\n\t\t The value is limmited by the number of rows in contact table.')
rptAnalogChannelSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3))
analogChnTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1), )
if mibBuilder.loadTexts: analogChnTable.setStatus('mandatory')
if mibBuilder.loadTexts: analogChnTable.setDescription("The table of analog channel's configuration parameters relevant to the\n\t\t repeater's analog channels.")
analogChnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "analogChnIndex"))
if mibBuilder.loadTexts: analogChnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: analogChnEntry.setDescription("The analog channel's configuration parameters for one of the repeater's analog channels.")
analogChnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: analogChnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: analogChnIndex.setDescription("The index of the table which uniquely identifies the analog channel's parameters.\n\t\t It also represents the channel number which is counted from 1.")
analogCarrierSquelchLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogCarrierSquelchLevel.setStatus('mandatory')
if mibBuilder.loadTexts: analogCarrierSquelchLevel.setDescription('The carrier squelch level.\n\t\t open(0), normal(1), tight(2)')
analogMultiCtcCdc = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogMultiCtcCdc.setStatus('mandatory')
if mibBuilder.loadTexts: analogMultiCtcCdc.setDescription("The multiCtcCdc control.\n\t\t disable(0), enable(1).\n\t\t It can't be set to enable until the analogRxCtcCdcType is not 0\n\t\t and there is some valid data is multiCTCCDCTable.")
analogPreEmp = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogPreEmp.setStatus('mandatory')
if mibBuilder.loadTexts: analogPreEmp.setDescription('The pre-emphasis control.\n\t\t disable(0), enable(1).')
analogScrambler = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogScrambler.setStatus('mandatory')
if mibBuilder.loadTexts: analogScrambler.setDescription('The scrambler control.\n\t\t disable(0), enable(1).')
analogFlatAudio = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogFlatAudio.setStatus('mandatory')
if mibBuilder.loadTexts: analogFlatAudio.setDescription('The flat audio control.\n\t\t disable(0), enable(1).')
analogReceiveFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogReceiveFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: analogReceiveFrequency.setDescription('The receiving frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
analogRxCtcCdcType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogRxCtcCdcType.setStatus('mandatory')
if mibBuilder.loadTexts: analogRxCtcCdcType.setDescription('The type of receiving subaudio frequency.\n\t\t none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).')
analogRxCtcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(670, 2541), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogRxCtcss.setStatus('mandatory')
if mibBuilder.loadTexts: analogRxCtcss.setDescription("The value of receiving CTCSS.\n\t\t It's 10 times of the real value.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogRxCtcCdcType.")
analogRxCdcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(19, 492), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogRxCdcss.setStatus('mandatory')
if mibBuilder.loadTexts: analogRxCdcss.setDescription('The value of receiving CDCSS.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogRxCtcCdcType.')
analogTransmitFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogTransmitFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: analogTransmitFrequency.setDescription('The transmitting frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
analogTxCtcCdcType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogTxCtcCdcType.setStatus('mandatory')
if mibBuilder.loadTexts: analogTxCtcCdcType.setDescription('The type of transmitting subaudio frequency.\n\t\t none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).')
analogTxCtcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(670, 2541), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogTxCtcss.setStatus('mandatory')
if mibBuilder.loadTexts: analogTxCtcss.setDescription("The value of transmitting CTCSS.\n\t\t It's 10 times of the real value.\n\t\t 65535 is an invalid value.\n\t\t The value is limited by analogTxCtcCdcType.")
analogTxCdcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(19, 492), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: analogTxCdcss.setStatus('mandatory')
if mibBuilder.loadTexts: analogTxCdcss.setDescription('The value of transmitting CDCSS.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogTxCtcCdcType.')
rptMixedChannelSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4))
mixedChnTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1), )
if mibBuilder.loadTexts: mixedChnTable.setStatus('mandatory')
if mibBuilder.loadTexts: mixedChnTable.setDescription("The table of mixed channel's configuration parameters relevant to the\n\t\t repeater's mixed channels.")
mixedChnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "analogChnIndex"))
if mibBuilder.loadTexts: mixedChnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mixedChnEntry.setDescription("The mixed channel's configuration parameters for one of the repeater's mixed channels.")
mixedChnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mixedChnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mixedChnIndex.setDescription("The index of the table which uniquely identifies the mixed channel's parameters.\n\t\t It also represents the channel number which is counted from 1.")
mixedCarrierSquelchLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedCarrierSquelchLevel.setStatus('mandatory')
if mibBuilder.loadTexts: mixedCarrierSquelchLevel.setDescription('The carrier squelch level control.\n\t\t open(0), normal(1), tight(2).')
mixedTxContactName = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTxContactName.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTxContactName.setDescription('The row number of transmitting contact name.\n\t\t none(0), row number(1~512).\n\t\t The value is limited to the numbers of row in the contact table.')
mixedIpMultisiteConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedIpMultisiteConnect.setStatus('mandatory')
if mibBuilder.loadTexts: mixedIpMultisiteConnect.setDescription('The multisite connecting based on network.\n\t\t none(0), slot1(1), slot 2(2), slot1&slot2(3).')
mixedColorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedColorCode.setStatus('mandatory')
if mibBuilder.loadTexts: mixedColorCode.setDescription('The color code.')
mixedTxChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTxChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTxChannelType.setDescription('The type of transmitting channel.\n\t\t digital(0), analog(1).')
mixedPreEmp = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedPreEmp.setStatus('mandatory')
if mibBuilder.loadTexts: mixedPreEmp.setDescription('The pre-emphasis control.\n\t\t disable(0), enable(1).')
mixedScrambler = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedScrambler.setStatus('mandatory')
if mibBuilder.loadTexts: mixedScrambler.setDescription('The scrambler control.\n\t\t disable(0), enable(1).')
mixedFlatAudio = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedFlatAudio.setStatus('mandatory')
if mibBuilder.loadTexts: mixedFlatAudio.setDescription('The flat audio control.\n\t\t disable(0), enable(1).')
mixedMultiCtcCdc = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedMultiCtcCdc.setStatus('mandatory')
if mibBuilder.loadTexts: mixedMultiCtcCdc.setDescription("The multiCtcCdc control.\n\t\t disable(0), enable(1).\n\t\t It can't be set to enable until the mixedRxCtcCdcType is not 0\n\t\t and there is some valid data in multiCTCCDC Table.")
mixedReceiveFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedReceiveFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: mixedReceiveFrequency.setDescription('The receiving frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
mixedRxCtcCdcType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedRxCtcCdcType.setStatus('mandatory')
if mibBuilder.loadTexts: mixedRxCtcCdcType.setDescription('The type of receiving subaudio frequency.\n\t\t none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).')
mixedRxCtcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(670, 2541), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedRxCtcss.setStatus('mandatory')
if mibBuilder.loadTexts: mixedRxCtcss.setDescription("The value of receiving CTCSS.\n\t\t It's 10 times of the real value.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogRxCtcCdcType.")
mixedRxCdcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(19, 492), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedRxCdcss.setStatus('mandatory')
if mibBuilder.loadTexts: mixedRxCdcss.setDescription('The value of receiving CDCSS.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogRxCtcCdcType.')
mixedTransmitFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100000000, 550000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTransmitFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTransmitFrequency.setDescription('The transmitting frequency.\n\t\t unit: Hz.\n\t\t The value is limitted by the assigned frequency range and the last digit\n\t\t should be 0 or 5.')
mixedTxCtcCdcType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTxCtcCdcType.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTxCtcCdcType.setDescription('The type of transmitting subaudio frequency.\n\t\t none(0), CTCSS(1), CDCSS(2), CDCSS invert(3).')
mixedTxCtcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(670, 2541), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTxCtcss.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTxCtcss.setDescription("The value of transmitting CTCSS.\n\t\t It's 10 times of the real value.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogTxCtcCdcType.")
mixedTxCdcss = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(19, 492), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mixedTxCdcss.setStatus('mandatory')
if mibBuilder.loadTexts: mixedTxCdcss.setDescription('The value of transmitting CDCSS.\n\t\t 65535 is an invalid value.\n\t\t The value is restricted by analogTxCtcCdcType.')
rptServiceSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5))
groupCallHangTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupCallHangTime.setStatus('mandatory')
if mibBuilder.loadTexts: groupCallHangTime.setDescription('The group call hang time.\n\t\t unit: second.\n\t\t The value is 2 times of the real value and should not be greater than the\n\t\t value of sit.')
privateCallHangTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: privateCallHangTime.setStatus('mandatory')
if mibBuilder.loadTexts: privateCallHangTime.setDescription('The private call hang time.\n\t\t unit: second.\n\t\t The value is 2 times of the real value and should not be greater than the\n\t\t value of sit.')
emergencyCallHangTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: emergencyCallHangTime.setStatus('mandatory')
if mibBuilder.loadTexts: emergencyCallHangTime.setDescription('The emergency call hang time.\n\t\t unit: second.\n\t\t The value is 2 times of the real value and should not be greater than the\n\t\t value of sit.')
sit = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(2, 120), )).clone(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sit.setStatus('mandatory')
if mibBuilder.loadTexts: sit.setDescription('The sit.\n\t\t unit: second.\n\t\t transmit always(0), the value of sit(2~120).\n         The value is 2 times of the real value and should not be less than\n         groupCallHangTime, privateCallHangTime and emergencyCallHangTime.')
txPreambleDuration = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 144)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txPreambleDuration.setStatus('mandatory')
if mibBuilder.loadTexts: txPreambleDuration.setDescription('The preamble duration.\n\t\t unit: milisecond.\n\t\t The value is 1/60 times of the real value.')
beaconTxMode = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: beaconTxMode.setStatus('mandatory')
if mibBuilder.loadTexts: beaconTxMode.setDescription('The beacon transmit mode.\n\t\t local(0), network(1).')
beaconDuration = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(4, 150), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: beaconDuration.setStatus('mandatory')
if mibBuilder.loadTexts: beaconDuration.setDescription('The beacon duration.\n\t\t unit: milisecond.\n\t\t disable(0), beacon duration(4~150).\n\t\t The value is 1/120 times of the real value')
beaconInterval = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: beaconInterval.setStatus('mandatory')
if mibBuilder.loadTexts: beaconInterval.setDescription('The beacon interval.\n\t\t unit: second.')
multisiteAccessManagement = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multisiteAccessManagement.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteAccessManagement.setDescription('The multisite access management control.\n\t\t disable(0), enable(1).')
accessManagement = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessManagement.setStatus('mandatory')
if mibBuilder.loadTexts: accessManagement.setDescription('The access management control.\n\t\t disable(0), enable(1).')
multisiteAccessManageTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11), )
if mibBuilder.loadTexts: multisiteAccessManageTable.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteAccessManageTable.setDescription("The table of multisite access management's parameters relevant to the\n\t   multisite access management.")
multisiteAccessManageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "mutisiteAccessManageIndex"))
if mibBuilder.loadTexts: multisiteAccessManageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteAccessManageEntry.setDescription('The multisite management parameters.')
multisiteAccessManageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: multisiteAccessManageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteAccessManageIndex.setDescription("The index of the table which uniquely identifies the multisite access\n\t   management's parameters.")
multisiteStartId = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16776415))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multisiteStartId.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteStartId.setDescription("The start ID.\n\t   invalid record(0), start ID(1~16776415).\n\t   It can't be set until multisiteAccessManagement is enable and the previous\n\t   row is set. If it is set, the matched multisiteIdLength and\n\t   multisiteAccessCallType will be set to 100 and 1 automaticly.")
multisiteIdLength = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 255), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multisiteIdLength.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteIdLength.setDescription("The ID length.\n\t   invalid(65535), ID length(1~255).\n\t   It can't be set until the multisiteAccessManagement is enable and the\n\t   matched multisiteStartId is set.")
multisiteAccessCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1), ValueRangeConstraint(65535, 65535), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multisiteAccessCallType.setStatus('mandatory')
if mibBuilder.loadTexts: multisiteAccessCallType.setDescription("The call type.\n\t   private call(0), group call(1), invalid(65535).\n     It can't be set until multisiteAccessManagement is enable.")
contactTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12), )
if mibBuilder.loadTexts: contactTable.setStatus('mandatory')
if mibBuilder.loadTexts: contactTable.setDescription('The table of contacts.\n\t   It is not allowed to add a new contact information.')
contactEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "contactIndex"))
if mibBuilder.loadTexts: contactEntry.setStatus('mandatory')
if mibBuilder.loadTexts: contactEntry.setDescription('The contact information.')
contactIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: contactIndex.setStatus('mandatory')
if mibBuilder.loadTexts: contactIndex.setDescription('The index of the table which uniquely identifies the contact information.')
callAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: callAlias.setStatus('mandatory')
if mibBuilder.loadTexts: callAlias.setDescription('The call alias.\n\t   It is an unicode string.\n\t   The value should be exclusive.')
contactCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 2), ValueRangeConstraint(65535, 65535), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: contactCallType.setStatus('mandatory')
if mibBuilder.loadTexts: contactCallType.setDescription('The call type.\n\t   private call(0), group call(1), all call(2), invalid(65535).\n     If the contactCallType is all call, the matched callId will be set to\n     16777215 automatically. The number of all call contact must be less than 2.')
callId = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16776415), ValueRangeConstraint(16777215, 16777215), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: callId.setStatus('mandatory')
if mibBuilder.loadTexts: callId.setDescription('The call ID.\n\t   invalid(0), call ID(1~16776415,16777215).\n\t   The callId should be exclusive in the group of same call type.')
accessManageTable = MibTable((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 13), )
if mibBuilder.loadTexts: accessManageTable.setStatus('mandatory')
if mibBuilder.loadTexts: accessManageTable.setDescription("The table of access management's parameters relevant to the access management.")
accessManageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 13, 1), ).setIndexNames((0, "HYTERA-REPEATER-MIB", "accessManageIndex"))
if mibBuilder.loadTexts: accessManageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: accessManageEntry.setDescription('The access management parameters.')
accessManageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessManageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessManageIndex.setDescription("The index of the table which uniquely identifies the access management's\n\t   parameters.")
startId = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16776415))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: startId.setStatus('mandatory')
if mibBuilder.loadTexts: startId.setDescription("The start ID.\n\t   invalid record(0), start ID(1~16776415).\n\t   It can't be set until accessManagement is enable and the previous\n\t   row is set. If it is set, the matched idLength will be set to 100\n\t   automaticly.")
idLength = MibTableColumn((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 255), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: idLength.setStatus('mandatory')
if mibBuilder.loadTexts: idLength.setDescription("The ID length.\n\t   invalid(65535), ID length(1~255).\n\t   It can't be set until the accessManagement is enable and the\n\t   matched startId is set.")
repeatTOTTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 120), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: repeatTOTTime.setStatus('mandatory')
if mibBuilder.loadTexts: repeatTOTTime.setDescription('The repeat TOT time.\n\t\t unit: second.\n\t\t The value is 1/5 times of the real value.')
rerepeatTOTTime = MibScalar((1, 3, 6, 1, 4, 1, 40297, 1, 2, 5, 5, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rerepeatTOTTime.setStatus('mandatory')
if mibBuilder.loadTexts: rerepeatTOTTime.setDescription('The rerepeat TOT time.\n\t\t unit: second.')
mibBuilder.exportSymbols("HYTERA-REPEATER-MIB", analogTxCdcss=analogTxCdcss, rptPaTemprature=rptPaTemprature, product=product, digitalChnTable=digitalChnTable, mixedChnIndex=mixedChnIndex, rxCtcssFrequency=rxCtcssFrequency, digitalTransmitFrequency=digitalTransmitFrequency, pttPriority=pttPriority, mixedTransmitFrequency=mixedTransmitFrequency, digitalTxContactName=digitalTxContactName, startId=startId, rptTxFwdPower=rptTxFwdPower, rptTemperatureAlarm=rptTemperatureAlarm, analogRxCtcss=analogRxCtcss, multisiteAccessManagement=multisiteAccessManagement, repeater=repeater, rptReflectedAlarm=rptReflectedAlarm, actTxPower=actTxPower, mixedTxChannelType=mixedTxChannelType, analogChnIndex=analogChnIndex, rptCurRxFreq=rptCurRxFreq, contactCallType=contactCallType, rptVswrAlarm=rptVswrAlarm, analogTxCtcCdcType=analogTxCtcCdcType, rptFanAlarm=rptFanAlarm, accessManageEntry=accessManageEntry, callId=callId, analogChnEntry=analogChnEntry, rptConfiguration=rptConfiguration, contactEntry=contactEntry, digitalChnEntry=digitalChnEntry, rxCtcssType=rxCtcssType, rptSerialNo=rptSerialNo, rptDataInfoBak1=rptDataInfoBak1, rptFirmwareVersion=rptFirmwareVersion, accessManagement=accessManagement, logIndex=logIndex, actChannelType=actChannelType, mixedTxContactName=mixedTxContactName, microphone=microphone, mixedFlatAudio=mixedFlatAudio, clearLog=clearLog, logEntry=logEntry, rptAnalogChannelSetting=rptAnalogChannelSetting, rptBatteryConnect=rptBatteryConnect, analogCarrierSquelchLevel=analogCarrierSquelchLevel, rerepeatTOTTime=rerepeatTOTTime, externalMicGain=externalMicGain, repeatRequestPriority=repeatRequestPriority, mixedTxCtcss=mixedTxCtcss, rptModelNo=rptModelNo, mixedChnTable=mixedChnTable, rptRestart=rptRestart, actChannelSubNo=actChannelSubNo, rptServiceSetting=rptServiceSetting, multisiteAccessManageTable=multisiteAccessManageTable, analogRxCtcCdcType=analogRxCtcCdcType, beaconInterval=beaconInterval, callAlias=callAlias, multisiteAccessManageIndex=multisiteAccessManageIndex, rptRealTimeInfo=rptRealTimeInfo, mixedTxCtcCdcType=mixedTxCtcCdcType, rptTxRefPower=rptTxRefPower, rptRadioState=rptRadioState, rptMixedChannelSetting=rptMixedChannelSetting, rptCurTxFreq=rptCurTxFreq, rptSnmpTrapIp=rptSnmpTrapIp, rptControlObjBak1=rptControlObjBak1, analogFlatAudio=analogFlatAudio, idLength=idLength, internalMicGain=internalMicGain, channelParaIndex=channelParaIndex, groupCallHangTime=groupCallHangTime, alarmName=alarmName, alarmStatus=alarmStatus, powerOn=powerOn, rptAlarmInfo=rptAlarmInfo, ctcssIndex=ctcssIndex, rptForbid=rptForbid, mixedRxCtcCdcType=mixedRxCtcCdcType, contactTable=contactTable, pathPriority=pathPriority, digitalChnIndex=digitalChnIndex, logTime=logTime, logTable=logTable, rptBatteryVoltageAlarm=rptBatteryVoltageAlarm, rptChannelNumber=rptChannelNumber, rptRadioID=rptRadioID, mixedChnEntry=mixedChnEntry, txCtcssFrequency=txCtcssFrequency, rptForwardAlarm=rptForwardAlarm, multisiteIdLength=multisiteIdLength, analogTransmitFrequency=analogTransmitFrequency, rptVoltage=rptVoltage, accessManageIndex=accessManageIndex, rptDataInfo=rptDataInfo, hyteraRepeaterMIB=hyteraRepeaterMIB, repeatTOTTime=repeatTOTTime, rptSlot1Rssi=rptSlot1Rssi, rptControl=rptControl, beaconDuration=beaconDuration, rptVoltageAlarm=rptVoltageAlarm, analogPreEmp=analogPreEmp, analogChnTable=analogChnTable, accessManageTable=accessManageTable, latestRecordPosition=latestRecordPosition, mixedTxCdcss=mixedTxCdcss, mixedRxCtcss=mixedRxCtcss, rptSlot2Rssi=rptSlot2Rssi, analogMultiCtcCdc=analogMultiCtcCdc, rptWorkState=rptWorkState, multiCTCCDCTable=multiCTCCDCTable, actChannelNo=actChannelNo, txPreambleDuration=txPreambleDuration, analogTxCtcss=analogTxCtcss, jitterBufferLenth=jitterBufferLenth, mixedMultiCtcCdc=mixedMultiCtcCdc, rptLog=rptLog, multisiteAccessManageEntry=multisiteAccessManageEntry, rptDataInfoBak2=rptDataInfoBak2, sit=sit, mixedPreEmp=mixedPreEmp, emergencyCallHangTime=emergencyCallHangTime, recordCount=recordCount, rptKnockdown=rptKnockdown, digitalReceiveFrequency=digitalReceiveFrequency, mixedRxCdcss=mixedRxCdcss, digitalColorCode=digitalColorCode, mixedReceiveFrequency=mixedReceiveFrequency, contactIndex=contactIndex, mixedCarrierSquelchLevel=mixedCarrierSquelchLevel, mixedIpMultisiteConnect=mixedIpMultisiteConnect, mixedColorCode=mixedColorCode, designatedPowerOnChn=designatedPowerOnChn, rptTxPowerLevel=rptTxPowerLevel, rptRcdbVersion=rptRcdbVersion, digitalIpMultisiteConnect=digitalIpMultisiteConnect, rptVswr=rptVswr, analogRxCdcss=analogRxCdcss, txCtcssType=txCtcssType, powerOnChannelNo=powerOnChannelNo, rptRxPllAlarm=rptRxPllAlarm, rptCurZoneAlias=rptCurZoneAlias, rptSystemInfo=rptSystemInfo, rptTxPllAlarm=rptTxPllAlarm, rptCurChannelType=rptCurChannelType, rptChannelName=rptChannelName, rptchannelParaTable=rptchannelParaTable, rptSupplyPowerType=rptSupplyPowerType, channelParaEntry=channelParaEntry, multiCTCCDCEntry=multiCTCCDCEntry, rptDigitalChannelSetting=rptDigitalChannelSetting, rptFanSpeed=rptFanSpeed, actChannelAlias=actChannelAlias, privateCallHangTime=privateCallHangTime, beaconTxMode=beaconTxMode, mixedScrambler=mixedScrambler, rptRadioAlias=rptRadioAlias, rptModelName=rptModelName, analogCallHangTime=analogCallHangTime, rptChannelType=rptChannelType, audioPriority=audioPriority, analogReceiveFrequency=analogReceiveFrequency, multisiteStartId=multisiteStartId, multisiteAccessCallType=multisiteAccessCallType, rptSnmpTrapPort=rptSnmpTrapPort, analogScrambler=analogScrambler, rptBatteryVoltage=rptBatteryVoltage, rptBasicSetting=rptBasicSetting)
