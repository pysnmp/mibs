#
# PySNMP MIB module CAMBIUM-PTP650-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/cambium/CAMBIUM-PTP650-MIB
# Produced by pysmi-1.1.12 at Thu Nov 28 02:55:31 2024
# On host fv-az885-149 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Integer32, enterprises, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, TimeTicks, iso, Counter64, Unsigned32, Gauge32, MibIdentifier, NotificationType, Bits, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "enterprises", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "TimeTicks", "iso", "Counter64", "Unsigned32", "Gauge32", "MibIdentifier", "NotificationType", "Bits", "ModuleIdentity", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cambium = ModuleIdentity((1, 3, 6, 1, 4, 1, 17713))
cambium.setRevisions(('2015-02-06 04:43', '2014-06-18 14:12', '2014-02-21 15:03', '2013-08-02 10:28',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cambium.setRevisionsDescriptions(('PTP650-01-40:\n         Added Second Data Service attributes to support a second data path over\n         wireless link.\n         Added support for Cable Diagnostics.\n         Added IEEE 1588 Transparent Clock source port and Transparent Clock source\n         alarm attributes.', "PTP650-01-20:\n         Added TDM group and NIDU attributes to support the telecomms interfaces.\n         Added Router Protocols group to support Microwave Adaptive Bandwidth (MAB).\n         Added support for Out-Of-Band Remote Management, and for mute and enable\n         transmission. Renamed 'ethernet bridging' attributes to 'data bridging'.\n         Made more SyncE attributes writable.", 'PTP650-01-10:\n         Added Synchronous Ethernet (SyncE) and IEEE 1588 Transparent Clock.\n         Support PTP650s. Clarified localPacketFiltering, regulatoryBand,\n         TDD Sync status & alarm. TX power max increased to 30dBm.\n         Modified the bit assignments of enabledDiagnosticAlarms to combine\n         the various status & warning bits for the main PSU, Aux & SFP ports\n         into a single portState bit.', 'PTP650-01-00: Initial revision.',))
if mibBuilder.loadTexts: cambium.setLastUpdated('201502060443Z')
if mibBuilder.loadTexts: cambium.setOrganization('Cambium Networks Ltd.')
if mibBuilder.loadTexts: cambium.setContactInfo('Post:  Simon Whitaker\n                 Cambium Networks Ltd.\n                 Unit B2,\n                 Linhay Business Park,\n                 Eastern Road,\n                 Ashburton,\n                 Devon.\n                 TQ13 7UP\n                 United Kingdom\n         Phone:  +44 (0) 1364 655 500\n         Email:  simon.whitaker@cambiumnetworks.com')
if mibBuilder.loadTexts: cambium.setDescription('MIB for non-line-of-sight (NLOS) wireless ethernet bridge.')
ptp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 1))
ptmp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 2))
ptp650 = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7))
dfs = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 3))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 4))
configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 5))
ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 6))
tDM = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 7))
license = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 8))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 9))
phyControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 10))
phyStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 12))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 13))
smtp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 15))
snmpControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 16))
sntp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 17))
reset = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 18))
versions = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 19))
pubStats = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 20))
encryption = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 22))
tDDControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 23))
aAAControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 25))
syslogControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 24))
routerProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 26))
cableDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 27))
supplementary = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 96))
ptpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 98))
ptpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 99))
ptpTrapPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0))
ptpCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 17713, 7, 97)).setObjects(("CAMBIUM-PTP650-MIB", "dfsGroup"), ("CAMBIUM-PTP650-MIB", "bridgeGroup"), ("CAMBIUM-PTP650-MIB", "configurationGroup"), ("CAMBIUM-PTP650-MIB", "ethernetGroup"), ("CAMBIUM-PTP650-MIB", "tDMGroup"), ("CAMBIUM-PTP650-MIB", "licenseGroup"), ("CAMBIUM-PTP650-MIB", "managementGroup"), ("CAMBIUM-PTP650-MIB", "phyControlGroup"), ("CAMBIUM-PTP650-MIB", "phyStatusGroup"), ("CAMBIUM-PTP650-MIB", "alarmsGroup"), ("CAMBIUM-PTP650-MIB", "smtpGroup"), ("CAMBIUM-PTP650-MIB", "snmpControlGroup"), ("CAMBIUM-PTP650-MIB", "sntpGroup"), ("CAMBIUM-PTP650-MIB", "resetGroup"), ("CAMBIUM-PTP650-MIB", "versionsGroup"), ("CAMBIUM-PTP650-MIB", "pubStatsGroup"), ("CAMBIUM-PTP650-MIB", "encryptionGroup"), ("CAMBIUM-PTP650-MIB", "tDDControlGroup"), ("CAMBIUM-PTP650-MIB", "aAAControlGroup"), ("CAMBIUM-PTP650-MIB", "syslogControlGroup"), ("CAMBIUM-PTP650-MIB", "routerProtocolsGroup"), ("CAMBIUM-PTP650-MIB", "cableDiagnosticsGroup"), ("CAMBIUM-PTP650-MIB", "supplementaryGroup"), ("CAMBIUM-PTP650-MIB", "notificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpCompliance = ptpCompliance.setStatus('current')
if mibBuilder.loadTexts: ptpCompliance.setDescription('The compliance statement for the Cambium PTP MIB')
dfsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 3)).setObjects(("CAMBIUM-PTP650-MIB", "dfsTableNumber"), ("CAMBIUM-PTP650-MIB", "extendedSpectrumScanning"), ("CAMBIUM-PTP650-MIB", "dfsMeans"), ("CAMBIUM-PTP650-MIB", "dfsNineNinePointNinePercentiles"), ("CAMBIUM-PTP650-MIB", "dfsPeaks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dfsGroup = dfsGroup.setStatus('current')
if mibBuilder.loadTexts: dfsGroup.setDescription('The dfs object group.')
bridgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 4)).setObjects(("CAMBIUM-PTP650-MIB", "localPacketFiltering"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bridgeGroup = bridgeGroup.setStatus('current')
if mibBuilder.loadTexts: bridgeGroup.setDescription('The bridge object group.')
configurationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 5)).setObjects(("CAMBIUM-PTP650-MIB", "iPv4Address"), ("CAMBIUM-PTP650-MIB", "subnetMask"), ("CAMBIUM-PTP650-MIB", "gatewayIPAddress"), ("CAMBIUM-PTP650-MIB", "targetMACAddress"), ("CAMBIUM-PTP650-MIB", "masterSlaveMode"), ("CAMBIUM-PTP650-MIB", "maximumTransmitPower"), ("CAMBIUM-PTP650-MIB", "antennaGain"), ("CAMBIUM-PTP650-MIB", "cableLoss"), ("CAMBIUM-PTP650-MIB", "eIRP"), ("CAMBIUM-PTP650-MIB", "channelBandwidth"), ("CAMBIUM-PTP650-MIB", "linkName"), ("CAMBIUM-PTP650-MIB", "siteName"), ("CAMBIUM-PTP650-MIB", "accessMethod"), ("CAMBIUM-PTP650-MIB", "groupID"), ("CAMBIUM-PTP650-MIB", "iPv6Address"), ("CAMBIUM-PTP650-MIB", "iPVersion"), ("CAMBIUM-PTP650-MIB", "iPv6AutoConfiguredLinkLocalAddress"), ("CAMBIUM-PTP650-MIB", "iPv6PrefixLength"), ("CAMBIUM-PTP650-MIB", "iPv6GatewayAddress"), ("CAMBIUM-PTP650-MIB", "remoteInternetAddressType"), ("CAMBIUM-PTP650-MIB", "remoteInternetAddress"), ("CAMBIUM-PTP650-MIB", "subbandLowestFrequency"), ("CAMBIUM-PTP650-MIB", "subbandHighestFrequency"), ("CAMBIUM-PTP650-MIB", "enableTransmission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    configurationGroup = configurationGroup.setStatus('current')
if mibBuilder.loadTexts: configurationGroup.setDescription('The configuration object group.')
ethernetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 6)).setObjects(("CAMBIUM-PTP650-MIB", "mainPSUPortAutoNegotiation"), ("CAMBIUM-PTP650-MIB", "mainPSUPortAutoNegAdvertisement"), ("CAMBIUM-PTP650-MIB", "mainPSUPortAutoMdix"), ("CAMBIUM-PTP650-MIB", "mainPSUPortStatus"), ("CAMBIUM-PTP650-MIB", "mainPSUPortSpeedAndDuplex"), ("CAMBIUM-PTP650-MIB", "dataPortWirelessDownAlert"), ("CAMBIUM-PTP650-MIB", "useVLANForManagementInterfaces"), ("CAMBIUM-PTP650-MIB", "vLANManagementPriority"), ("CAMBIUM-PTP650-MIB", "vLANManagementVID"), ("CAMBIUM-PTP650-MIB", "auxPortStatus"), ("CAMBIUM-PTP650-MIB", "auxPortSpeedAndDuplex"), ("CAMBIUM-PTP650-MIB", "ethernetPriorityTableNumber"), ("CAMBIUM-PTP650-MIB", "l2CPPriorityTableNumber"), ("CAMBIUM-PTP650-MIB", "iPDSCPPriorityTableNumber"), ("CAMBIUM-PTP650-MIB", "mPLSTCPriorityTableNumber"), ("CAMBIUM-PTP650-MIB", "managementPortWirelessDownAlert"), ("CAMBIUM-PTP650-MIB", "qOSPriorityScheme"), ("CAMBIUM-PTP650-MIB", "unknownNetworkPriorityQueueMapping"), ("CAMBIUM-PTP650-MIB", "dSCPManagementPriority"), ("CAMBIUM-PTP650-MIB", "dataBridgingStatus"), ("CAMBIUM-PTP650-MIB", "mainPSUPortAllocation"), ("CAMBIUM-PTP650-MIB", "auxPortAllocation"), ("CAMBIUM-PTP650-MIB", "sFPPortAllocation"), ("CAMBIUM-PTP650-MIB", "dataPortPauseFrames"), ("CAMBIUM-PTP650-MIB", "sFPPortAutoNegotiation"), ("CAMBIUM-PTP650-MIB", "sFPPortAutoNegAdvertisement"), ("CAMBIUM-PTP650-MIB", "sFPPortAutoMdix"), ("CAMBIUM-PTP650-MIB", "sFPPortStatus"), ("CAMBIUM-PTP650-MIB", "sFPPortSpeedAndDuplex"), ("CAMBIUM-PTP650-MIB", "auxPortPowerOverEthernetOutput"), ("CAMBIUM-PTP650-MIB", "auxPortPowerOverEthernetOutputStatus"), ("CAMBIUM-PTP650-MIB", "syncETracking"), ("CAMBIUM-PTP650-MIB", "syncEEquipmentClock"), ("CAMBIUM-PTP650-MIB", "mainPSUPortQLRxOverwrite"), ("CAMBIUM-PTP650-MIB", "mainPSUPortSSMTx"), ("CAMBIUM-PTP650-MIB", "sFPPortSSMTx"), ("CAMBIUM-PTP650-MIB", "auxPortSSMTx"), ("CAMBIUM-PTP650-MIB", "syncETrackingState"), ("CAMBIUM-PTP650-MIB", "mainPSUPortQLRx"), ("CAMBIUM-PTP650-MIB", "auxPortQLRx"), ("CAMBIUM-PTP650-MIB", "sFPPortQLRx"), ("CAMBIUM-PTP650-MIB", "mainPSUPortQLTx"), ("CAMBIUM-PTP650-MIB", "auxPortQLTx"), ("CAMBIUM-PTP650-MIB", "sFPPortQLTx"), ("CAMBIUM-PTP650-MIB", "mainPSUPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "auxPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "sFPPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "mainPSUPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "auxPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "sFPPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "transparentClock"), ("CAMBIUM-PTP650-MIB", "transparentClockVLAN"), ("CAMBIUM-PTP650-MIB", "transparentClockVID"), ("CAMBIUM-PTP650-MIB", "mainPSUPortAcceptedQLRx"), ("CAMBIUM-PTP650-MIB", "auxPortAcceptedQLRx"), ("CAMBIUM-PTP650-MIB", "sFPPortAcceptedQLRx"), ("CAMBIUM-PTP650-MIB", "mainPSUPortSyncERxStatus"), ("CAMBIUM-PTP650-MIB", "auxPortSyncERxStatus"), ("CAMBIUM-PTP650-MIB", "sFPPortSyncERxStatus"), ("CAMBIUM-PTP650-MIB", "nIDULanPortStatus"), ("CAMBIUM-PTP650-MIB", "nIDULanPortSpeedAndDuplex"), ("CAMBIUM-PTP650-MIB", "oOBPriorityQueueMapping"), ("CAMBIUM-PTP650-MIB", "nIDULanPortAutoNegotiation"), ("CAMBIUM-PTP650-MIB", "nIDULanPortAutoNegAdvertisement"), ("CAMBIUM-PTP650-MIB", "nIDULanPortAutoMdix"), ("CAMBIUM-PTP650-MIB", "nIDULanPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP650-MIB", "txMABFrames"), ("CAMBIUM-PTP650-MIB", "managementNetworkAccessEnabled"), ("CAMBIUM-PTP650-MIB", "secondDataPortPauseFrames"), ("CAMBIUM-PTP650-MIB", "secondDataBridgingStatus"), ("CAMBIUM-PTP650-MIB", "transparentClockPort"), ("CAMBIUM-PTP650-MIB", "ethernetPriorityQueueMapping"), ("CAMBIUM-PTP650-MIB", "l2CPPriorityQueueMapping"), ("CAMBIUM-PTP650-MIB", "iPDSCPPriorityQueueMapping"), ("CAMBIUM-PTP650-MIB", "mPLSTCPriorityQueueMapping"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ethernetGroup = ethernetGroup.setStatus('current')
if mibBuilder.loadTexts: ethernetGroup.setDescription('The ethernet object group.')
tDMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 7)).setObjects(("CAMBIUM-PTP650-MIB", "tDMInterfaceControl"), ("CAMBIUM-PTP650-MIB", "tDMInterfaceStatus"), ("CAMBIUM-PTP650-MIB", "tDMEnabledChannels"), ("CAMBIUM-PTP650-MIB", "tdmTableNumber"), ("CAMBIUM-PTP650-MIB", "tDMConfigurationMismatch"), ("CAMBIUM-PTP650-MIB", "lowestTDMModulationMode"), ("CAMBIUM-PTP650-MIB", "tDMChannelStatus"), ("CAMBIUM-PTP650-MIB", "tDMChannelLineCode"), ("CAMBIUM-PTP650-MIB", "tDMChannelCableLength"), ("CAMBIUM-PTP650-MIB", "tDMChannelLoopback"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tDMGroup = tDMGroup.setStatus('current')
if mibBuilder.loadTexts: tDMGroup.setDescription('The tDM object group.')
licenseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 8)).setObjects(("CAMBIUM-PTP650-MIB", "regulatoryBand"), ("CAMBIUM-PTP650-MIB", "productVariant"), ("CAMBIUM-PTP650-MIB", "productName"), ("CAMBIUM-PTP650-MIB", "frequencyVariant"), ("CAMBIUM-PTP650-MIB", "sNMPv3Enable"), ("CAMBIUM-PTP650-MIB", "licenseVersion"), ("CAMBIUM-PTP650-MIB", "licenseUnitSerialNumber"), ("CAMBIUM-PTP650-MIB", "licenseIssueNumber"), ("CAMBIUM-PTP650-MIB", "licenseCountry"), ("CAMBIUM-PTP650-MIB", "licenseNumberOfRegulatoryBands"), ("CAMBIUM-PTP650-MIB", "licenseBandwidthCap"), ("CAMBIUM-PTP650-MIB", "licenseEncryption"), ("CAMBIUM-PTP650-MIB", "licenseSecurityLevel"), ("CAMBIUM-PTP650-MIB", "licenseGroupAccess"), ("CAMBIUM-PTP650-MIB", "licenseOOBManagementSupport"), ("CAMBIUM-PTP650-MIB", "licenseSFPPortSupport"), ("CAMBIUM-PTP650-MIB", "licenseAuxiliaryPortSupport"), ("CAMBIUM-PTP650-MIB", "licenseCapacity"), ("CAMBIUM-PTP650-MIB", "licenseMaxNumberOfTDMChannels"), ("CAMBIUM-PTP650-MIB", "licenseIEEE1588Support"), ("CAMBIUM-PTP650-MIB", "licenseSyncESupport"), ("CAMBIUM-PTP650-MIB", "licenseIPv6Support"), ("CAMBIUM-PTP650-MIB", "licenseMinimumFirmwareVersion"), ("CAMBIUM-PTP650-MIB", "licenseFullCapabilityTrialStatus"), ("CAMBIUM-PTP650-MIB", "licenseRemainingTrialPeriod"), ("CAMBIUM-PTP650-MIB", "licenseRemainingTrialPeriodAlarm"), ("CAMBIUM-PTP650-MIB", "capacityVariantMismatch"), ("CAMBIUM-PTP650-MIB", "licenseTDDSyncSupport"), ("CAMBIUM-PTP650-MIB", "licenseMaxLinkRange"), ("CAMBIUM-PTP650-MIB", "licenseTrialPeriod"), ("CAMBIUM-PTP650-MIB", "licenseRARSupport"), ("CAMBIUM-PTP650-MIB", "licenseRegulatoryBandsList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    licenseGroup = licenseGroup.setStatus('current')
if mibBuilder.loadTexts: licenseGroup.setDescription('The license object group.')
managementGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 9)).setObjects(("CAMBIUM-PTP650-MIB", "targetRange"), ("CAMBIUM-PTP650-MIB", "rangingMode"), ("CAMBIUM-PTP650-MIB", "installStatus"), ("CAMBIUM-PTP650-MIB", "installArmState"), ("CAMBIUM-PTP650-MIB", "tFTPServerPortNumber"), ("CAMBIUM-PTP650-MIB", "tFTPSoftwareUpgradeFileName"), ("CAMBIUM-PTP650-MIB", "tFTPStartSoftwareUpgrade"), ("CAMBIUM-PTP650-MIB", "tFTPSoftwareUpgradeStatus"), ("CAMBIUM-PTP650-MIB", "tFTPSoftwareUpgradeStatusText"), ("CAMBIUM-PTP650-MIB", "tFTPSoftwareUpgradeStatusAdditionalText"), ("CAMBIUM-PTP650-MIB", "hTTPAccessEnabled"), ("CAMBIUM-PTP650-MIB", "telnetAccessEnabled"), ("CAMBIUM-PTP650-MIB", "hTTPPortNumber"), ("CAMBIUM-PTP650-MIB", "hTTPSPortNumber"), ("CAMBIUM-PTP650-MIB", "telnetPortNumber"), ("CAMBIUM-PTP650-MIB", "hTTPSAccessEnabled"), ("CAMBIUM-PTP650-MIB", "tFTPServerInternetAddressType"), ("CAMBIUM-PTP650-MIB", "tFTPServerInternetAddress"), ("CAMBIUM-PTP650-MIB", "lowestDataModulationMode"), ("CAMBIUM-PTP650-MIB", "lowestSecondDataModulationMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    managementGroup = managementGroup.setStatus('current')
if mibBuilder.loadTexts: managementGroup.setDescription('The management object group.')
phyControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 10)).setObjects(("CAMBIUM-PTP650-MIB", "linkSymmetry"), ("CAMBIUM-PTP650-MIB", "userConfiguredMaxModulationMode"), ("CAMBIUM-PTP650-MIB", "linkModeOptimization"), ("CAMBIUM-PTP650-MIB", "txColorCode"), ("CAMBIUM-PTP650-MIB", "rxColorCode"), ("CAMBIUM-PTP650-MIB", "remoteMaximumTransmitPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    phyControlGroup = phyControlGroup.setStatus('current')
if mibBuilder.loadTexts: phyControlGroup.setDescription('The phyControl object group.')
phyStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 12)).setObjects(("CAMBIUM-PTP650-MIB", "linkLoss"), ("CAMBIUM-PTP650-MIB", "receivePower"), ("CAMBIUM-PTP650-MIB", "vectorError"), ("CAMBIUM-PTP650-MIB", "transmitPower"), ("CAMBIUM-PTP650-MIB", "receiveChannel"), ("CAMBIUM-PTP650-MIB", "transmitChannel"), ("CAMBIUM-PTP650-MIB", "receiveFreqMHz"), ("CAMBIUM-PTP650-MIB", "transmitFreqMHz"), ("CAMBIUM-PTP650-MIB", "signalStrengthRatio"), ("CAMBIUM-PTP650-MIB", "receiveFreqKHz"), ("CAMBIUM-PTP650-MIB", "transmitFreqKHz"), ("CAMBIUM-PTP650-MIB", "rawReceivePower"), ("CAMBIUM-PTP650-MIB", "range"), ("CAMBIUM-PTP650-MIB", "receiveModulationMode"), ("CAMBIUM-PTP650-MIB", "transmitModulationMode"), ("CAMBIUM-PTP650-MIB", "searchState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    phyStatusGroup = phyStatusGroup.setStatus('current')
if mibBuilder.loadTexts: phyStatusGroup.setDescription('The phyStatus object group.')
alarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 13)).setObjects(("CAMBIUM-PTP650-MIB", "unitOutOfCalibration"), ("CAMBIUM-PTP650-MIB", "incompatibleRegulatoryBands"), ("CAMBIUM-PTP650-MIB", "noWirelessChannelAvailable"), ("CAMBIUM-PTP650-MIB", "wirelessLinkDisabledWarning"), ("CAMBIUM-PTP650-MIB", "mainPSUPortDisabledWarning"), ("CAMBIUM-PTP650-MIB", "sFPError"), ("CAMBIUM-PTP650-MIB", "mainPSUPortConfigurationMismatch"), ("CAMBIUM-PTP650-MIB", "incompatibleMasterAndSlave"), ("CAMBIUM-PTP650-MIB", "tDDSynchronizationStatus"), ("CAMBIUM-PTP650-MIB", "auxPortDisabledWarning"), ("CAMBIUM-PTP650-MIB", "tDDSynchronizationAlarm"), ("CAMBIUM-PTP650-MIB", "linkModeOptimizationMismatch"), ("CAMBIUM-PTP650-MIB", "auxPortConfigurationMismatch"), ("CAMBIUM-PTP650-MIB", "secureModeAlarm"), ("CAMBIUM-PTP650-MIB", "dataBridgingStatusAlarm"), ("CAMBIUM-PTP650-MIB", "sFPPortDisabledWarning"), ("CAMBIUM-PTP650-MIB", "sFPPortConfigurationMismatch"), ("CAMBIUM-PTP650-MIB", "maxLinkRangeExceeded"), ("CAMBIUM-PTP650-MIB", "nIDULanPortDisabledWarning"), ("CAMBIUM-PTP650-MIB", "nIDULanPortConfigurationMismatch"), ("CAMBIUM-PTP650-MIB", "portAllocationMismatch"), ("CAMBIUM-PTP650-MIB", "secondDataBridgingStatusAlarm"), ("CAMBIUM-PTP650-MIB", "transparentClockSourcePortAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alarmsGroup = alarmsGroup.setStatus('current')
if mibBuilder.loadTexts: alarmsGroup.setDescription('The alarms object group.')
smtpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 15)).setObjects(("CAMBIUM-PTP650-MIB", "sMTPEmailAlert"), ("CAMBIUM-PTP650-MIB", "sMTPServerPortNumber"), ("CAMBIUM-PTP650-MIB", "sMTPSourceEmailAddress"), ("CAMBIUM-PTP650-MIB", "sMTPDestinationEmailAddress"), ("CAMBIUM-PTP650-MIB", "sMTPEnabledMessages"), ("CAMBIUM-PTP650-MIB", "sMTPServerInternetAddressType"), ("CAMBIUM-PTP650-MIB", "sMTPServerInternetAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smtpGroup = smtpGroup.setStatus('current')
if mibBuilder.loadTexts: smtpGroup.setDescription('The smtp object group.')
snmpControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 16)).setObjects(("CAMBIUM-PTP650-MIB", "sNMPPortNumber"), ("CAMBIUM-PTP650-MIB", "sNMPCommunityString"), ("CAMBIUM-PTP650-MIB", "sNMPTrapTableNumber"), ("CAMBIUM-PTP650-MIB", "sNMPTrapVersion"), ("CAMBIUM-PTP650-MIB", "sNMPEnabledTraps"), ("CAMBIUM-PTP650-MIB", "enabledDiagnosticAlarms"), ("CAMBIUM-PTP650-MIB", "sNMPSendAllTrapsAtStartup"), ("CAMBIUM-PTP650-MIB", "sNMPTrapPortNumber"), ("CAMBIUM-PTP650-MIB", "sNMPTrapInternetAddressType"), ("CAMBIUM-PTP650-MIB", "sNMPTrapInternetAddress"), ("CAMBIUM-PTP650-MIB", "sNMPTrapReceiverEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snmpControlGroup = snmpControlGroup.setStatus('current')
if mibBuilder.loadTexts: snmpControlGroup.setDescription('The snmpControl object group.')
sntpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 17)).setObjects(("CAMBIUM-PTP650-MIB", "sNTPState"), ("CAMBIUM-PTP650-MIB", "sNTPPollInterval"), ("CAMBIUM-PTP650-MIB", "sNTPSync"), ("CAMBIUM-PTP650-MIB", "sNTPLastSync"), ("CAMBIUM-PTP650-MIB", "systemClock"), ("CAMBIUM-PTP650-MIB", "timeZone"), ("CAMBIUM-PTP650-MIB", "daylightSaving"), ("CAMBIUM-PTP650-MIB", "sNTPPrimaryServer"), ("CAMBIUM-PTP650-MIB", "sNTPPrimaryServerDeadTime"), ("CAMBIUM-PTP650-MIB", "sNTPServerRetries"), ("CAMBIUM-PTP650-MIB", "sNTPServerTimeout"), ("CAMBIUM-PTP650-MIB", "sNTPServerTableNumber"), ("CAMBIUM-PTP650-MIB", "sNTPServerPortNumber"), ("CAMBIUM-PTP650-MIB", "sNTPServerStatus"), ("CAMBIUM-PTP650-MIB", "sNTPServerInternetAddressType"), ("CAMBIUM-PTP650-MIB", "sNTPServerInternetAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sntpGroup = sntpGroup.setStatus('current')
if mibBuilder.loadTexts: sntpGroup.setDescription('The sntp object group.')
resetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 18)).setObjects(("CAMBIUM-PTP650-MIB", "systemReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    resetGroup = resetGroup.setStatus('current')
if mibBuilder.loadTexts: resetGroup.setDescription('The reset object group.')
versionsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 19)).setObjects(("CAMBIUM-PTP650-MIB", "softwareVersion"), ("CAMBIUM-PTP650-MIB", "hardwareVersion"), ("CAMBIUM-PTP650-MIB", "secondarySoftwareVersion"), ("CAMBIUM-PTP650-MIB", "bootVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    versionsGroup = versionsGroup.setStatus('current')
if mibBuilder.loadTexts: versionsGroup.setDescription('The versions object group.')
pubStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 20)).setObjects(("CAMBIUM-PTP650-MIB", "receiveDataRate"), ("CAMBIUM-PTP650-MIB", "transmitDataRate"), ("CAMBIUM-PTP650-MIB", "aggregateDataRate"), ("CAMBIUM-PTP650-MIB", "wirelessLinkAvailability"), ("CAMBIUM-PTP650-MIB", "wirelessLinkStatus"), ("CAMBIUM-PTP650-MIB", "byteErrorRatio"), ("CAMBIUM-PTP650-MIB", "receiveModulationModeDetail"), ("CAMBIUM-PTP650-MIB", "dataBridgingAvailability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pubStatsGroup = pubStatsGroup.setStatus('current')
if mibBuilder.loadTexts: pubStatsGroup.setDescription('The pubStats object group.')
encryptionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 22)).setObjects(("CAMBIUM-PTP650-MIB", "encryptionAlgorithm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    encryptionGroup = encryptionGroup.setStatus('current')
if mibBuilder.loadTexts: encryptionGroup.setDescription('The encryption object group.')
tDDControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 23)).setObjects(("CAMBIUM-PTP650-MIB", "tDDSynchronizationMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tDDControlGroup = tDDControlGroup.setStatus('current')
if mibBuilder.loadTexts: tDDControlGroup.setDescription('The tDDControl object group.')
aAAControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 25)).setObjects(("CAMBIUM-PTP650-MIB", "userTableNumber"), ("CAMBIUM-PTP650-MIB", "userName"), ("CAMBIUM-PTP650-MIB", "userRole"), ("CAMBIUM-PTP650-MIB", "userEnabled"), ("CAMBIUM-PTP650-MIB", "userPassword"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aAAControlGroup = aAAControlGroup.setStatus('current')
if mibBuilder.loadTexts: aAAControlGroup.setDescription('The aAAControl object group.')
syslogControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 24)).setObjects(("CAMBIUM-PTP650-MIB", "syslogClient"), ("CAMBIUM-PTP650-MIB", "syslogState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    syslogControlGroup = syslogControlGroup.setStatus('current')
if mibBuilder.loadTexts: syslogControlGroup.setDescription('The syslogControl object group.')
routerProtocolsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 26)).setObjects(("CAMBIUM-PTP650-MIB", "microwaveAdaptiveBandwidth"), ("CAMBIUM-PTP650-MIB", "mABNominalModulationMode"), ("CAMBIUM-PTP650-MIB", "mABTransmissionInterval"), ("CAMBIUM-PTP650-MIB", "mABHoldoffPeriod"), ("CAMBIUM-PTP650-MIB", "mABMaintenanceLevel"), ("CAMBIUM-PTP650-MIB", "useVLANForMABProtocol"), ("CAMBIUM-PTP650-MIB", "mABProtocolVID"), ("CAMBIUM-PTP650-MIB", "mABProtocolVLANPriority"), ("CAMBIUM-PTP650-MIB", "mABState"), ("CAMBIUM-PTP650-MIB", "mABNominalTransmitCapacity"), ("CAMBIUM-PTP650-MIB", "mABCurrentTransmitCapacity"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    routerProtocolsGroup = routerProtocolsGroup.setStatus('current')
if mibBuilder.loadTexts: routerProtocolsGroup.setDescription('The routerProtocols object group.')
cableDiagnosticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 27)).setObjects(("CAMBIUM-PTP650-MIB", "cableDiagnosticsPorts"), ("CAMBIUM-PTP650-MIB", "cableDiagnosticsControl"), ("CAMBIUM-PTP650-MIB", "cableDiagnosticsWarning"), ("CAMBIUM-PTP650-MIB", "cableDiagnosticsResultTableNumber"), ("CAMBIUM-PTP650-MIB", "cableDiagnosticsResultsDateTime"), ("CAMBIUM-PTP650-MIB", "cableDiagPair1Results"), ("CAMBIUM-PTP650-MIB", "cableDiagPair1Distance"), ("CAMBIUM-PTP650-MIB", "cableDiagPair2Results"), ("CAMBIUM-PTP650-MIB", "cableDiagPair2Distance"), ("CAMBIUM-PTP650-MIB", "cableDiagPair3Results"), ("CAMBIUM-PTP650-MIB", "cableDiagPair3Distance"), ("CAMBIUM-PTP650-MIB", "cableDiagPair4Results"), ("CAMBIUM-PTP650-MIB", "cableDiagPair4Distance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cableDiagnosticsGroup = cableDiagnosticsGroup.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsGroup.setDescription('The cableDiagnostics object group.')
supplementaryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 96)).setObjects(("CAMBIUM-PTP650-MIB", "longitude"), ("CAMBIUM-PTP650-MIB", "latitude"), ("CAMBIUM-PTP650-MIB", "altitude"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    supplementaryGroup = supplementaryGroup.setStatus('current')
if mibBuilder.loadTexts: supplementaryGroup.setDescription('The supplementary object group.')
notificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 17713, 7, 98, 99)).setObjects(("CAMBIUM-PTP650-MIB", "channelChangeTrap"), ("CAMBIUM-PTP650-MIB", "dfsImpulsiveInterferenceTrap"), ("CAMBIUM-PTP650-MIB", "mainPSUPortStatusTrap"), ("CAMBIUM-PTP650-MIB", "mainPSUPortDisabledWarningTrap"), ("CAMBIUM-PTP650-MIB", "mainPSUPortConfigurationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "auxPortStatusTrap"), ("CAMBIUM-PTP650-MIB", "auxPortDisabledWarningTrap"), ("CAMBIUM-PTP650-MIB", "regulatoryBandTrap"), ("CAMBIUM-PTP650-MIB", "installStatusTrap"), ("CAMBIUM-PTP650-MIB", "installArmStateTrap"), ("CAMBIUM-PTP650-MIB", "unitOutOfCalibrationTrap"), ("CAMBIUM-PTP650-MIB", "auxPortPowerOverEthernetOutputStatusTrap"), ("CAMBIUM-PTP650-MIB", "incompatibleRegulatoryBandsTrap"), ("CAMBIUM-PTP650-MIB", "noWirelessChannelAvailableTrap"), ("CAMBIUM-PTP650-MIB", "wirelessLinkDisabledWarningTrap"), ("CAMBIUM-PTP650-MIB", "auxPortConfigurationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "sFPErrorTrap"), ("CAMBIUM-PTP650-MIB", "sFPPortStatusTrap"), ("CAMBIUM-PTP650-MIB", "incompatibleMasterAndSlaveTrap"), ("CAMBIUM-PTP650-MIB", "sNTPSyncTrap"), ("CAMBIUM-PTP650-MIB", "tDDSynchronizationAlarmTrap"), ("CAMBIUM-PTP650-MIB", "sFPPortDisabledWarningTrap"), ("CAMBIUM-PTP650-MIB", "sFPPortConfigurationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "linkModeOptimizationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "tDMInterfaceStatusTrap"), ("CAMBIUM-PTP650-MIB", "tDMChannelStatusTrap"), ("CAMBIUM-PTP650-MIB", "tDMChannelLoopbackTrap"), ("CAMBIUM-PTP650-MIB", "nIDULanPortStatusTrap"), ("CAMBIUM-PTP650-MIB", "syslogStateTrap"), ("CAMBIUM-PTP650-MIB", "syslogLocalNearlyFullTrap"), ("CAMBIUM-PTP650-MIB", "syslogLocalWrappedTrap"), ("CAMBIUM-PTP650-MIB", "syslogClientTrap"), ("CAMBIUM-PTP650-MIB", "secureModeAlarmTrap"), ("CAMBIUM-PTP650-MIB", "dataBridgingStatusAlarmTrap"), ("CAMBIUM-PTP650-MIB", "licenseRemainingTrialPeriodAlarmTrap"), ("CAMBIUM-PTP650-MIB", "capacityVariantMismatchTrap"), ("CAMBIUM-PTP650-MIB", "maxLinkRangeExceededTrap"), ("CAMBIUM-PTP650-MIB", "tDMConfigurationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "nIDULanPortDisabledWarningTrap"), ("CAMBIUM-PTP650-MIB", "nIDULanPortConfigurationMismatchTrap"), ("CAMBIUM-PTP650-MIB", "secondDataBridgingStatusAlarmTrap"), ("CAMBIUM-PTP650-MIB", "transparentClockSourcePortAlarmTrap"), ("CAMBIUM-PTP650-MIB", "portAllocationMismatchTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    notificationsGroup = notificationsGroup.setStatus('current')
if mibBuilder.loadTexts: notificationsGroup.setDescription('The notifications group.')
dfsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2), )
if mibBuilder.loadTexts: dfsTable.setStatus('current')
if mibBuilder.loadTexts: dfsTable.setDescription(' A table storing a snapshot of various DFS measurements for each channel')
dfsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "dfsTableIndex"))
if mibBuilder.loadTexts: dfsTableEntry.setStatus('current')
if mibBuilder.loadTexts: dfsTableEntry.setDescription('Table DfsTable')
ethernetPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 6, 15), )
if mibBuilder.loadTexts: ethernetPriorityTable.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by Ethernet priority.')
ethernetPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 6, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "ethernetPriorityTableIndex"))
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setDescription('Table EthernetPriorityTable')
l2CPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 6, 17), )
if mibBuilder.loadTexts: l2CPPriorityTable.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by L2CP priority.')
l2CPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 6, 17, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "l2CPPriorityTableIndex"))
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setDescription('Table L2CPPriorityTable')
iPDSCPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 6, 19), )
if mibBuilder.loadTexts: iPDSCPPriorityTable.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by L3 IP DSCP priority.')
iPDSCPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 6, 19, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "iPDSCPPriorityTableIndex"))
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setDescription('Table IPDSCPPriorityTable')
mPLSTCPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 6, 21), )
if mibBuilder.loadTexts: mPLSTCPriorityTable.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTable.setDescription(' A priority queue mapping table. This is a list of priority queues indexed by MPLS TC priority.')
mPLSTCPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 6, 21, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "mPLSTCPriorityTableIndex"))
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setDescription('Table MPLSTCPriorityTable')
tdmTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5), )
if mibBuilder.loadTexts: tdmTable.setStatus('current')
if mibBuilder.loadTexts: tdmTable.setDescription(' A table storing a configuration and status for each TDM channel')
tdmTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "tdmTableIndex"))
if mibBuilder.loadTexts: tdmTableEntry.setStatus('current')
if mibBuilder.loadTexts: tdmTableEntry.setDescription('Table TdmTable')
licenseRegulatoryBandsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 8, 18), )
if mibBuilder.loadTexts: licenseRegulatoryBandsTable.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTable.setDescription('')
licenseRegulatoryBandsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 8, 18, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "licenseRegulatoryBandsTableIndex"))
if mibBuilder.loadTexts: licenseRegulatoryBandsTableEntry.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTableEntry.setDescription('Table LicenseRegulatoryBandsTable')
sNMPTrapTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4), )
if mibBuilder.loadTexts: sNMPTrapTable.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTable.setDescription(' SNMP trap configuration table.')
sNMPTrapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "sNMPTrapTableIndex"))
if mibBuilder.loadTexts: sNMPTrapTableEntry.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableEntry.setDescription('Table SNMPTrapTable')
sNTPServerTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15), )
if mibBuilder.loadTexts: sNTPServerTable.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTable.setDescription('')
sNTPServerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "sNTPServerTableIndex"))
if mibBuilder.loadTexts: sNTPServerTableEntry.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableEntry.setDescription('Table SNTPServerTable')
userTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2), )
if mibBuilder.loadTexts: userTable.setStatus('current')
if mibBuilder.loadTexts: userTable.setDescription(' The User Table Control group contains objects specifically for user account management.')
userTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "userTableIndex"))
if mibBuilder.loadTexts: userTableEntry.setStatus('current')
if mibBuilder.loadTexts: userTableEntry.setDescription('Table UserTable')
cableDiagnosticsResultTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5), )
if mibBuilder.loadTexts: cableDiagnosticsResultTable.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTable.setDescription('')
cableDiagnosticsResultTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1), ).setIndexNames((0, "CAMBIUM-PTP650-MIB", "cableDiagnosticsResultTableIndex"))
if mibBuilder.loadTexts: cableDiagnosticsResultTableEntry.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableEntry.setDescription('Table CableDiagnosticsResultTable')
dfsTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsTableNumber.setStatus('current')
if mibBuilder.loadTexts: dfsTableNumber.setDescription('Number of entries in the dfsTable')
extendedSpectrumScanning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extendedSpectrumScanning.setStatus('current')
if mibBuilder.loadTexts: extendedSpectrumScanning.setDescription('Enables Extended Spectrum Scanning')
dfsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)))
if mibBuilder.loadTexts: dfsTableIndex.setStatus('current')
if mibBuilder.loadTexts: dfsTableIndex.setDescription('used to index values in the dfsTable.')
dfsMeans = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsMeans.setStatus('current')
if mibBuilder.loadTexts: dfsMeans.setDescription('Snapshot of DFS means')
dfsNineNinePointNinePercentiles = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsNineNinePointNinePercentiles.setStatus('current')
if mibBuilder.loadTexts: dfsNineNinePointNinePercentiles.setDescription('Snapshot of DFS 99.9 percentiles')
dfsPeaks = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsPeaks.setStatus('current')
if mibBuilder.loadTexts: dfsPeaks.setDescription('Snapshot of DFS peaks')
localPacketFiltering = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localPacketFiltering.setStatus('current')
if mibBuilder.loadTexts: localPacketFiltering.setDescription('When Local Packet Filtering is Enabled, the unit keeps \n             track of the port (Main, SFP, Aux or Wireless) on which a \n             packet with a given MAC source address destined to the \n             management agent has been received. This MAC address to \n             port mapping is then used in order to route any response \n             from the management agent to the right port. When Local \n             Packet Filtering is Disabled, any Ethernet packet from \n             the management agent is sent to all ports.')
iPv4Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv4Address.setStatus('current')
if mibBuilder.loadTexts: iPv4Address.setDescription('Internet protocol (IPv4) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
subnetMask = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetMask.setStatus('current')
if mibBuilder.loadTexts: subnetMask.setDescription('A subnet allows the flow of network traffic between \n             hosts to be segregated based on a network configuration. \n             By organizing hosts into logical groups, subnetting can \n             improve network security and performance.')
gatewayIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gatewayIPAddress.setStatus('current')
if mibBuilder.loadTexts: gatewayIPAddress.setDescription('The IPv4 address of a device on the current network that \n             acts as an IPv4 network gateway. A gateway acts as an \n             entrance / exit to packets from / to other networks')
targetMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: targetMACAddress.setStatus('current')
if mibBuilder.loadTexts: targetMACAddress.setDescription('MAC address of the PTP wireless unit forming the other \n             end of the PTP link')
masterSlaveMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: masterSlaveMode.setStatus('current')
if mibBuilder.loadTexts: masterSlaveMode.setDescription('The PTP wireless link operates using a master and slave \n             relationship')
maximumTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maximumTransmitPower.setStatus('current')
if mibBuilder.loadTexts: maximumTransmitPower.setDescription('Maximum transmit power the wireless unit is permitted to \n             use when establishing and maintaining the wireless link. \n             This may be reduced during installation')
antennaGain = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(130, 610))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: antennaGain.setStatus('current')
if mibBuilder.loadTexts: antennaGain.setDescription('Antenna Gain. Expressed in 10ths of dBi.')
cableLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableLoss.setStatus('current')
if mibBuilder.loadTexts: cableLoss.setDescription('Loss in the cable between the ODU and the antenna. \n             Expressed in 10ths of dB. NB: This attribute is ignored \n             for variants with an integral antenna.')
eIRP = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eIRP.setStatus('current')
if mibBuilder.loadTexts: eIRP.setDescription('Effective Isotropic Radiated Power (EIRP) describes the \n             strength of the radio signal leaving the wireless unit. \n             Expressed in 10ths of dBm')
channelBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bw30MHz", 0), ("bw15MHz", 1), ("bw10MHz", 2), ("bw5MHz", 3), ("bw20MHz", 4), ("bw56MHz", 5), ("bw50MHz", 6), ("bw40MHz", 7), ("bw45MHz", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelBandwidth.setStatus('current')
if mibBuilder.loadTexts: channelBandwidth.setDescription('This control sets the bandwidth of the transmit and \n             receive radio channels')
linkName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkName.setStatus('current')
if mibBuilder.loadTexts: linkName.setDescription('Name of the PTP link allocated by the System \n             Administrator. Used to establish a connection with the \n             correct PTP wireless unit at the other end of the link. \n             NOTE: The link name MUST be the same at both ends of the \n             PTP link.')
siteName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siteName.setStatus('current')
if mibBuilder.loadTexts: siteName.setDescription('This field contains a user-provided description of the \n             site name together with any additional notes')
accessMethod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("linkAccess", 0), ("linkNameAccess", 1), ("groupAccess", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessMethod.setStatus('current')
if mibBuilder.loadTexts: accessMethod.setDescription('ODUs must be configured in pairs before a link can be \n             established. The Access Method attribute determines how \n             the paired ODUs will recognise each other. For the Link \n             Access method, each ODU must be configured with Target \n             MAC Address equal to the MAC Address of the other unit. \n             For the Link Name Access method, both units must be \n             configured with the same Link Name. For the Group Access \n             method, both units must be configured with the same Group \n             ID.')
groupID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupID.setStatus('current')
if mibBuilder.loadTexts: groupID.setDescription('When Access Method is set to Group Access, the Group ID \n             identifies all the units belonging to the same group')
iPv6Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6Address.setStatus('current')
if mibBuilder.loadTexts: iPv6Address.setDescription('Internet protocol (IPv6) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
iPVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("iPv4", 0), ("iPv6", 1), ("dualIPv4andIPv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPVersion.setStatus('current')
if mibBuilder.loadTexts: iPVersion.setDescription('IP protocol selection. Choice of IPv4, IPv6 or Dual.')
iPv6AutoConfiguredLinkLocalAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setDescription('The auto configured link local IPv6 address')
iPv6PrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6PrefixLength.setStatus('current')
if mibBuilder.loadTexts: iPv6PrefixLength.setDescription('IPv6 prefix length')
iPv6GatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6GatewayAddress.setStatus('current')
if mibBuilder.loadTexts: iPv6GatewayAddress.setDescription('The IPv6 address of a device on the current network that \n             is currently acting as an IPv6 network gateway. A gateway \n             acts as an entrance / exit to packets from / to other \n             networks.')
remoteInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddressType.setDescription('The type of Internet address specified by the associated \n             remoteInternetAddressType.')
remoteInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 25), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddress.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddress.setDescription('INET address used to identify the peer wireless unit')
subbandLowestFrequency = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: subbandLowestFrequency.setStatus('current')
if mibBuilder.loadTexts: subbandLowestFrequency.setDescription('Lowest center frequency of the subset of channels.')
subbandHighestFrequency = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: subbandHighestFrequency.setStatus('current')
if mibBuilder.loadTexts: subbandHighestFrequency.setDescription('Highest center frequency of the subset of channels.')
enableTransmission = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 5, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("muted", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableTransmission.setStatus('current')
if mibBuilder.loadTexts: enableTransmission.setDescription('Control for enabling/disabling the radio transmitter of \n             the Master. Note: Use Web Properties to control this \n             feature.')
mainPSUPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoNegotiation.setDescription('This controls whether the local Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
mainPSUPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 2), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoNegAdvertisement.setDescription('This sets the different Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
mainPSUPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
mainPSUPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortStatus.setDescription('Current status of the Main PSU Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSpeedAndDuplex.setDescription('The current speed and duplex of the Main PSU Ethernet \n             link')
dataPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setStatus('current')
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setDescription('When enabled, this causes the Ethernet link to be \n             dropped briefly when the wireless link drops. This is so \n             that spanning tree algorithms can quickly detect that \n             there is a problem.')
useVLANForManagementInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noVLANTagging", 0), ("iEEE8021QTaggedCTagType8100", 1), ("iEEE8021adTaggedSTagorBTagType88a8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setStatus('current')
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setDescription('This controls whether the management interfaces \n             (WWW/SNMP/SMTP/SNTP) use VLAN tags or not. NB: The new \n             setting will only take effect after a system reboot')
vLANManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("p0", 0), ("p1", 1), ("p2", 2), ("p3", 3), ("p4", 4), ("p5", 5), ("p6", 6), ("p7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementPriority.setStatus('current')
if mibBuilder.loadTexts: vLANManagementPriority.setDescription('This VLAN Priority (0-7) will be included in packets \n             generated by the management interfaces')
vLANManagementVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementVID.setStatus('current')
if mibBuilder.loadTexts: vLANManagementVID.setDescription('This VLAN VID (0-4094) will be included in packets \n             generated by the management interfaces. Note the new \n             setting will only take effect after a system reboot')
auxPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortStatus.setDescription('Current status of the Aux Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
auxPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: auxPortSpeedAndDuplex.setDescription('The current speed and duplex of the Aux Ethernet link')
ethernetPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(9, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setDescription('Number of entries in the vLANPriorityTable.')
l2CPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setDescription('Number of entries in the l2CPPriorityTable.')
iPDSCPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setDescription('Number of entries in the iPDSCPPriorityTable.')
mPLSTCPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setDescription('Number of entries in the mPLSTCPriorityTable.')
managementPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setStatus('current')
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setDescription('When enabled, this causes the management link to be \n             dropped briefly when the wireless link drops. This is so \n             that spanning tree algorithms can quickly detect that \n             there is a problem.')
qOSPriorityScheme = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ethernet", 0), ("iPMPLS", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qOSPriorityScheme.setStatus('current')
if mibBuilder.loadTexts: qOSPriorityScheme.setDescription('Selects classification based on fields in the Ethernet \n             header (Layer 2) or in the Network header (Layer 3). The \n             unit recognises two network layer protocols: IP and MPLS')
unknownNetworkPriorityQueueMapping = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setDescription('Configures the classification of unknown network \n             protocols to an egress queue at the wireless port. \n             Unknown means something other than IP and MPLS')
dSCPManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dSCPManagementPriority.setStatus('current')
if mibBuilder.loadTexts: dSCPManagementPriority.setDescription('This Differentiated Services Code Point value will be \n             inserted in the IP Header of all IP Datagrams transmitted \n             by the management interfaces')
dataBridgingStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatus.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatus.setDescription('Current status of Ethernet Data traffic bridging over \n             the wireless link')
mainPSUPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4), ("secondDataOnly", 5), ("secondDataandInBandManagement", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAllocation.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAllocation.setDescription('Indicates the service or services supported by the Main \n             PSU Ethernet port')
auxPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4), ("secondDataOnly", 5), ("secondDataandInBandManagement", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortAllocation.setStatus('current')
if mibBuilder.loadTexts: auxPortAllocation.setDescription('Indicates the service or services supported by the Aux \n             Ethernet port')
sFPPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4), ("secondDataOnly", 5), ("secondDataandInBandManagement", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAllocation.setStatus('current')
if mibBuilder.loadTexts: sFPPortAllocation.setDescription('Indicates the service or services supported by the SFP \n             Ethernet port')
dataPortPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tunnel", 0), ("discard", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortPauseFrames.setStatus('current')
if mibBuilder.loadTexts: dataPortPauseFrames.setDescription('Controls whether the bridge tunnels or discards Layer 2 \n             PAUSE frames arriving at the Data Port. Such frames are \n             identified by the destination MAC Address being equal to \n             01-80-C2-00-00-01')
sFPPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoNegotiation.setDescription('This controls whether the local SFP Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
sFPPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 33), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoNegAdvertisement.setDescription('This sets the different SFP Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
sFPPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
sFPPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortStatus.setDescription('Current status of the SFP Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
sFPPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: sFPPortSpeedAndDuplex.setDescription('The current speed and duplex of the SFP Ethernet link')
auxPortPowerOverEthernetOutput = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutput.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutput.setDescription('The state of the Power Over Ethernet (PoE) output of the \n             Aux port. Enabling PoE output may lead to system \n             instability; please refer to the User Guide before \n             enabling this control')
auxPortPowerOverEthernetOutputStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("poEOutputOn", 0), ("poEOutputDisabled", 1), ("poEOutputEnabledbutNotActiveErrororNoLoadPresent", 2), ("poEOutputOverloadError", 3), ("poEOutputOverTempError", 4), ("poEOutputErrorDetected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatus.setDescription('Current status of the Power Over Ethernet (PoE) output \n             of the Aux port')
syncETracking = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("internalTDMUseOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syncETracking.setStatus('current')
if mibBuilder.loadTexts: syncETracking.setDescription('Controls whether Synchronous Ethernet (SyncE) network \n             synchronization is enabled.')
syncEEquipmentClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("eECOption1", 0), ("eECOption2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syncEEquipmentClock.setStatus('current')
if mibBuilder.loadTexts: syncEEquipmentClock.setDescription('EEC-Option 1 applies to synchronous Ethernet equipments \n             that are designed to interwork with networks optimized \n             for the 2048-kbit/s hierarchy. Corresponds to ITU-T G.813 \n             Option 1; EEC-Option 2 applies to synchronous Ethernet \n             equipments that are designed to interwork with networks \n             optimized for the 1544-kbit/s hierarchy. Corresponds to \n             Type IV clock from ITU-T G.812.')
mainPSUPortQLRxOverwrite = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("disabled", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mainPSUPortQLRxOverwrite.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLRxOverwrite.setDescription('Override for the Synchronous Ethernet (SyncE) received \n             Quality Level (QL) on the main PSU port.')
mainPSUPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mainPSUPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the Main PSU port')
sFPPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFPPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: sFPPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the SFP port')
auxPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: auxPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: auxPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the Aux port')
syncETrackingState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 0), ("acquiringWirelessLock", 1), ("freeRunning", 2), ("lockedLocalAcquiringHoldover", 3), ("lockedLocalHoldoverAcquired", 4), ("holdover", 5), ("lockedRemoteAcquiringHoldover", 6), ("lockedRemoteHoldoverAcquired", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syncETrackingState.setStatus('current')
if mibBuilder.loadTexts: syncETrackingState.setDescription('The current state of Synchronous Ethernet (SyncE) \n             network synchronization.')
mainPSUPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortQLRx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the main PSU port.')
auxPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortQLRx.setStatus('current')
if mibBuilder.loadTexts: auxPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the auxiliary port.')
sFPPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortQLRx.setStatus('current')
if mibBuilder.loadTexts: sFPPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the SFP port.')
mainPSUPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortQLTx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the main PSU port.')
auxPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortQLTx.setStatus('current')
if mibBuilder.loadTexts: auxPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the auxiliary port.')
sFPPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortQLTx.setStatus('current')
if mibBuilder.loadTexts: sFPPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the SFP port.')
mainPSUPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSyncEMasterSlaveStatus.setDescription('The main PSU port Synchronous Ethernet (SyncE) \n             Master/Slave status')
auxPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortSyncEMasterSlaveStatus.setDescription('The auxiliary port Synchronous Ethernet (SyncE) \n             Master/Slave status')
sFPPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortSyncEMasterSlaveStatus.setDescription('The SFP port Synchronous Ethernet (SyncE) Master/Slave \n             status')
mainPSUPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortGigabitMasterSlaveStatus.setDescription('The main PSU port Gigabit Ethernet Master/Slave status')
auxPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortGigabitMasterSlaveStatus.setDescription('The auxiliary port Gigabit Ethernet Master/Slave status')
sFPPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortGigabitMasterSlaveStatus.setDescription('The SFP port Gigabit Ethernet Master/Slave status')
transparentClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClock.setStatus('current')
if mibBuilder.loadTexts: transparentClock.setDescription('This control enables the Precision Time Protocol \n             (IEEE-1588) Transparent Clock. Once enabled the unit will \n             modify the correction field in PTP event messages to take \n             account of the time these frames have been resident in \n             this system. This will happen for all PTP frames at Layer \n             2 & Layer 3 (IPv4 & IPv6) unless a transparent clock VLAN \n             is enabled.')
transparentClockVLAN = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("all", 0), ("sTagged", 1), ("cTagged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockVLAN.setStatus('current')
if mibBuilder.loadTexts: transparentClockVLAN.setDescription('If All is selected then all PTP frames will have their \n             correction fields modified with the residence time. If an \n             S-TAG or C-TAG is selected, only frames with this VLAN \n             tag and matching the VLAN ID in the Transparent Clock VID \n             will have their correction fields modified.')
transparentClockVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockVID.setStatus('current')
if mibBuilder.loadTexts: transparentClockVID.setDescription('The VLAN ID which frames must match if they are to be \n             corrected. Only valid when an S-TAG or C-TAG has been \n             selected.')
mainPSUPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the main PSU port.')
auxPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: auxPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the auxiliary port.')
sFPPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: sFPPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the SFP port.')
mainPSUPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             main PSU port')
auxPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             auxiliary port')
sFPPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             SFP port')
nIDULanPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortStatus.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortStatus.setDescription('Current status of the NIDU LAN Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
nIDULanPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortSpeedAndDuplex.setDescription('The current speed and duplex of the Ethernet link to the \n             NIDU LAN Port')
oOBPriorityQueueMapping = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oOBPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: oOBPriorityQueueMapping.setDescription('Configures the classification of traffic to an egress \n             queue at the wireless port')
nIDULanPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoNegotiation.setDescription('This controls whether the local Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
nIDULanPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 71), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoNegAdvertisement.setDescription('This sets the different Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
nIDULanPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
nIDULanPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortGigabitMasterSlaveStatus.setDescription('The NIDU LAN port Gigabit Ethernet Master/Slave status')
txMABFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMABFrames.setStatus('current')
if mibBuilder.loadTexts: txMABFrames.setDescription('Number of MAB frames transmitted')
managementNetworkAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementNetworkAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: managementNetworkAccessEnabled.setDescription('When enabled the local Out-of-Band interface can be used \n             to access the remote management network. If not enabled \n             the local management agent can still be accessed from the \n             remote management network and the local Out-of-Band \n             interface')
secondDataPortPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tunnel", 0), ("discard", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondDataPortPauseFrames.setStatus('current')
if mibBuilder.loadTexts: secondDataPortPauseFrames.setDescription('Controls whether the bridge tunnels or discards Layer 2 \n             PAUSE frames arriving at the Second Data Service Port. \n             Such frames are identified by the destination MAC Address \n             being equal to 01-80-C2-00-00-01')
secondDataBridgingStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondDataBridgingStatus.setStatus('current')
if mibBuilder.loadTexts: secondDataBridgingStatus.setDescription('Current status of bridging Second Data Service Ethernet \n             traffic over the wireless link')
transparentClockPort = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 6, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("mainPSU", 0), ("aux", 1), ("sFP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockPort.setStatus('current')
if mibBuilder.loadTexts: transparentClockPort.setDescription('IEEE 1588 Transparent Clock source')
ethernetPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("p0", 1), ("p1", 2), ("p2", 3), ("p3", 4), ("p4", 5), ("p5", 6), ("p6", 7), ("p7", 8), ("untagged", 9))))
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setDescription('Ethernet priority flag, used to index values in the \n             ethernetPriorityTable')
ethernetPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setDescription('Configures the classification of this Ethernet priority \n             (also known as IEEE 802.1p value) to an egress queue at \n             the wireless port')
l2CPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("bridge", 1), ("mRP", 2), ("cFM", 3), ("rAPS", 4), ("eAPS", 5))))
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setDescription('L2CP priority flag, used to index values in the \n             l2CPPriorityTable')
l2CPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setDescription('Configures the classification of this layer two control \n             protocol (L2CP) to an egress queue at the wireless port')
iPDSCPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setDescription('IP DSCP priority flag, used to index values in the \n             iPDSCPPriorityTable')
iPDSCPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setDescription('Configures the classification of this IP differentiated \n             services code point (DSCP) value to an egress queue at \n             the wireless port')
mPLSTCPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setDescription('MPLS TC priority flag, used to index values in the \n             mPLSTCPriorityTable')
mPLSTCPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 6, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setDescription('Configures the classification of this MPLS traffic class \n             (the field formerly known as EXP) to an egress queue at \n             the wireless port')
tDMInterfaceControl = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("e1", 1), ("t1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMInterfaceControl.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceControl.setDescription("The line interface type. If this is set to 'None' then \n             the TDM interfaces are disabled, and the TDM settings \n             will be ignored.")
tDMInterfaceStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("connectedNotConfigured", 1), ("notConnected", 2), ("nIDUdetectedonAUXport", 3), ("error", 4), ("codeDownloadInProgress", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMInterfaceStatus.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceStatus.setDescription("@Current status of the connection to the TDM Box. A \n             state of 'Up' on a green background indicates that the \n             TDM Box is connected OK. When connecting a TDM Box only \n             the Main Ethernet port should be used")
tDMEnabledChannels = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMEnabledChannels.setStatus('current')
if mibBuilder.loadTexts: tDMEnabledChannels.setDescription('The number of TDM channels enabled in the system')
tdmTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tdmTableNumber.setStatus('current')
if mibBuilder.loadTexts: tdmTableNumber.setDescription('Number of entries in the TdmTable')
tDMConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("linetypemismatch", 1), ("enabledchannelsmismatch", 2), ("linetypeandenabledchannelsmismatch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: tDMConfigurationMismatch.setDescription("Current status of the configuration of the TDM Box. A \n             state of 'Ok' on a green background indicates that the \n             TDM Box configuration is matched OK with the remote end.")
lowestTDMModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lowestTDMModulationMode.setStatus('current')
if mibBuilder.loadTexts: lowestTDMModulationMode.setDescription('The lowest modulation mode at which tdm data will be \n             sent. The effective lowest modulation mode is displayed \n             in the TDM Configuration page')
tdmTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tdmTableIndex.setStatus('current')
if mibBuilder.loadTexts: tdmTableIndex.setDescription('TDM Channel flag, used to index channels in the \n             TdmTable')
tDMChannelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 0), ("noSignalLocal", 1), ("noSignalRemote", 2), ("noSignalLocalandRemote", 3), ("remoteTiming", 4), ("noSignalLocalandRemoteTiming", 5), ("disabled", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelStatus.setStatus('current')
if mibBuilder.loadTexts: tDMChannelStatus.setDescription('Current status of the TDM channels. A value of 0 \n             indicates that a TDM channel is established')
tDMChannelLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aMI", 0), ("b8ZSorHDB3", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelLineCode.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLineCode.setDescription('The line code setting of the TDM interfaces. This must \n             match the setting of the device connected to an \n             interface')
tDMChannelCableLength = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("feet133", 0), ("feet266", 1), ("feet399", 2), ("feet533", 3), ("feet655", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelCableLength.setStatus('current')
if mibBuilder.loadTexts: tDMChannelCableLength.setDescription('The lengths of the cables connected to the TDM \n             interfaces, measured in feet')
tDMChannelLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 7, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("copper", 1), ("wireless", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelLoopback.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLoopback.setDescription("The loopback status of TDM channels. This is intended \n             for installation testing and should be set to 'None' for \n             normal operation. The wire connections to a unit can be \n             tested by applying a 'Copper' loopback to the local unit. \n             The wireless connection to the remote unit can be tested \n             by applying a 'Wireless' loopback to the remote unit with \n             no loopback on the local unit. NB: a change of state may \n             generate an SNMP trap and/or SMTP email alert")
regulatoryBand = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("regInvalid", 0), ("reg158GHz", 1), ("reg258GHz", 2), ("reg358GHz", 3), ("reg458GHz", 4), ("reg558GHz", 5), ("reg658GHz", 6), ("reg754GHzUnrestrictedEIRPwithDFS", 7), ("reg854GHzUnrestrictedEIRP", 8), ("reg9", 9), ("reg1058GHz", 10), ("reg1158GHz", 11), ("reg1254GHzFCCUNII2C", 12), ("reg1354GHz", 13), ("reg1449GHzPublicSafety", 14), ("reg15", 15), ("reg1659GHz", 16), ("reg1759GHz", 17), ("reg1849GHzPublicSafety", 18), ("reg1958GHz", 19), ("reg2054GHz", 20), ("reg2154GHz", 21), ("reg2258GHz", 22), ("reg23", 23), ("reg2458GHz", 24), ("reg2558GHzETSI", 25), ("reg2654GHzETSI", 26), ("reg2758GHz", 27), ("reg2858GHz", 28), ("reg2958GHzUnrestrictedEIRPwithDFSandRTTT", 29), ("reg3054GHz", 30), ("reg3158GHz", 31), ("reg3249GHzLicensed", 32), ("reg3349GHzETSIBroadbandDisasterRelief", 33), ("reg3458GHz", 34), ("reg3558GHzUnrestrictedEIRP", 35), ("reg3654GHz", 36), ("reg3758GHz", 37), ("reg3852GHzFCCUNII2A", 38), ("reg3951GHzETSIBroadbandDisasterRelief", 39), ("reg4054GHz", 40), ("reg4154GHz", 41), ("reg4254GHz", 42), ("reg4354GHz", 43), ("reg4458GHz", 44), ("reg4558GHz", 45), ("reg4658GHz", 46), ("reg4758GHz", 47), ("reg4858GHz", 48), ("reg4958GHz", 49), ("reg5058GHz", 50), ("reg5158GHz", 51), ("reg5258GHz", 52), ("reg5358GHz", 53), ("reg5458GHz", 54), ("reg5558GHz", 55), ("reg5654GHz", 56), ("reg5754GHz", 57), ("reg5858GHz", 58), ("reg5958GHz", 59), ("reg6058GHz", 60), ("reg6149GHz", 61), ("reg6252GHz", 62), ("reg6352GHz", 63), ("reg6451GHz", 64), ("reg6551GHz", 65), ("reg6651GHz", 66), ("reg6752GHz", 67), ("reg6852GHz", 68), ("reg6952GHz", 69), ("reg7052GHz", 70), ("reg7152GHz", 71), ("reg7252GHz", 72), ("reg7352GHz", 73), ("reg7452GHz", 74), ("reg7552GHz", 75), ("reg7652GHz", 76), ("reg7752GHz", 77), ("reg7849GHz", 78), ("reg7954GHz", 79), ("reg8049GHz", 80), ("reg8147GHz", 81), ("reg8247GHz", 82), ("reg8352GHz", 83), ("reg8451GHzFCCUNII1", 84), ("reg8552GHzFCCUNII12A", 85), ("reg8654GHzFCCUNII2A2C", 86), ("reg8758GHz", 87), ("reg8849GHz", 88), ("reg8949GHz", 89), ("reg9054GHzFCCUNII2CParabolicantenna", 90), ("reg9152GHzFCCUNII2AParabolicantenna", 91), ("reg9251GHzFCCUNII1Parabolicantenna", 92), ("reg9349GHz", 93), ("reg94", 94), ("reg95", 95), ("reg96", 96), ("reg97", 97), ("reg98", 98), ("reg99", 99), ("reg100", 100), ("reg101", 101), ("reg102", 102), ("reg103", 103), ("reg104", 104), ("reg105", 105), ("reg106", 106), ("reg107", 107), ("reg108", 108), ("reg109", 109), ("reg110", 110), ("reg111", 111), ("reg112", 112), ("reg113", 113), ("reg114", 114), ("reg115", 115), ("reg116", 116), ("reg117", 117), ("reg118", 118), ("reg119", 119), ("reg120", 120), ("reg121", 121), ("reg122", 122), ("reg123", 123), ("reg124", 124), ("reg125", 125), ("reg126", 126), ("reg127", 127), ("reg128", 128), ("reg129", 129), ("reg130", 130), ("reg131", 131), ("reg132", 132), ("reg133", 133), ("reg134", 134), ("reg135", 135), ("reg136", 136), ("reg137", 137), ("reg138", 138), ("reg139", 139), ("reg140", 140), ("reg141", 141), ("reg142", 142), ("reg143", 143), ("reg144", 144), ("reg145", 145), ("reg146", 146), ("reg147", 147), ("reg148", 148), ("reg149", 149), ("reg150", 150), ("reg151", 151), ("reg152", 152), ("reg153", 153), ("reg154", 154), ("reg155", 155), ("reg156", 156), ("reg157", 157), ("reg158", 158), ("reg159", 159), ("reg160", 160), ("reg161", 161), ("reg162", 162), ("reg163", 163), ("reg164", 164), ("reg165", 165), ("reg166", 166), ("reg167", 167), ("reg168", 168), ("reg169", 169), ("reg170", 170), ("reg171", 171), ("reg172", 172), ("reg173", 173), ("reg174", 174), ("reg175", 175), ("reg176", 176), ("reg177", 177), ("reg178", 178), ("reg179", 179), ("reg180", 180), ("reg181", 181), ("reg182", 182), ("reg183", 183), ("reg184", 184), ("reg185", 185), ("reg186", 186), ("reg187", 187), ("reg188", 188), ("reg189", 189), ("reg190", 190), ("reg191", 191), ("reg192", 192), ("reg193", 193), ("reg194", 194), ("reg195", 195), ("reg196", 196), ("reg197", 197), ("reg198", 198), ("reg199", 199), ("reg200", 200), ("reg201", 201), ("reg202", 202), ("reg203", 203), ("reg204", 204), ("reg205", 205), ("reg206", 206), ("reg207", 207), ("reg208", 208), ("reg209", 209), ("reg210", 210), ("reg211", 211), ("reg212", 212), ("reg213", 213), ("reg214", 214), ("reg215", 215), ("reg216", 216), ("reg217", 217), ("reg218", 218), ("reg219", 219), ("reg220", 220), ("reg221", 221), ("reg222", 222), ("reg223", 223), ("reg224", 224), ("reg225", 225), ("reg226", 226), ("reg227", 227), ("reg228", 228), ("reg229", 229), ("reg230", 230), ("reg231", 231), ("reg232", 232), ("reg233", 233), ("reg234", 234), ("reg235", 235), ("reg236", 236), ("reg237", 237), ("reg238", 238), ("reg239", 239), ("reg240", 240), ("reg241", 241), ("reg242", 242), ("reg243", 243), ("reg244", 244), ("reg245", 245), ("reg246", 246), ("reg247", 247), ("reg248", 248), ("reg249", 249), ("reg250", 250), ("reg251", 251), ("reg252", 252), ("reg253", 253), ("reg254", 254)) + NamedValues(("reg255", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: regulatoryBand.setStatus('current')
if mibBuilder.loadTexts: regulatoryBand.setDescription('The Regulatory Band prohibits the wireless unit from \n             operating outside the regulated limits. An invalid \n             Regulatory Band may be caused by a missing or incorrect \n             License Key, a corrupt MAC Address or an attempt to \n             configure a Regulatory Band not allowed by the License \n             Key. NB: a change of state may generate an SNMP trap \n             and/or SMTP email alert.')
productVariant = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("pTPxx400Full", 0), ("pTPxx400Deprecated1", 1), ("pTPxx400Deprecated2", 2), ("pTPxx400Lite", 3), ("spare1", 4), ("pTPxx300", 5), ("spare2", 6), ("spare3", 7), ("pTPxx500FullDeprecated", 8), ("pTPxx500LiteDeprecated", 9), ("pTPxx500", 10), ("pTPxx600Lite", 11), ("pTPxx600Full", 12), ("pTPxx650", 13), ("spare6", 14), ("pTP800", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productVariant.setStatus('current')
if mibBuilder.loadTexts: productVariant.setDescription('The product variant')
productName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productName.setStatus('current')
if mibBuilder.loadTexts: productName.setDescription('Name of the product variant')
frequencyVariant = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("freq5GHz", 0), ("freq4GHz", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frequencyVariant.setStatus('current')
if mibBuilder.loadTexts: frequencyVariant.setDescription('The hardware frequency variant')
sNMPv3Enable = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPv3Enable.setStatus('current')
if mibBuilder.loadTexts: sNMPv3Enable.setDescription('SNMPv3 availability control')
licenseVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseVersion.setStatus('current')
if mibBuilder.loadTexts: licenseVersion.setDescription('The license key version.')
licenseUnitSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseUnitSerialNumber.setStatus('current')
if mibBuilder.loadTexts: licenseUnitSerialNumber.setDescription('The unit serial number.')
licenseIssueNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIssueNumber.setStatus('current')
if mibBuilder.loadTexts: licenseIssueNumber.setDescription('The license key issue number for this unit.')
licenseCountry = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 103))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseCountry.setStatus('current')
if mibBuilder.loadTexts: licenseCountry.setDescription('The country in which this unit is licensed to operate.')
licenseNumberOfRegulatoryBands = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseNumberOfRegulatoryBands.setStatus('current')
if mibBuilder.loadTexts: licenseNumberOfRegulatoryBands.setDescription('The number of regulatory bands for which the unit is \n             licensed to operate.')
licenseBandwidthCap = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseBandwidthCap.setStatus('current')
if mibBuilder.loadTexts: licenseBandwidthCap.setDescription('The wireless link bandwidth cap in MHz. Zero indicates \n             no bandwidth cap.')
licenseEncryption = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("aESRijndael", 1), ("aES192bitRijndael", 2), ("aES256bitRijndael", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseEncryption.setStatus('current')
if mibBuilder.loadTexts: licenseEncryption.setDescription('The license key encryption algorithms available.')
licenseSecurityLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("fIPS", 1), ("uCAPL", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: licenseSecurityLevel.setDescription('The license key security level.')
licenseGroupAccess = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseGroupAccess.setStatus('current')
if mibBuilder.loadTexts: licenseGroupAccess.setDescription('The license key group access setting.')
licenseOOBManagementSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseOOBManagementSupport.setStatus('current')
if mibBuilder.loadTexts: licenseOOBManagementSupport.setDescription('The license key Out-Of-Band (OOB) support setting.')
licenseSFPPortSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSFPPortSupport.setStatus('current')
if mibBuilder.loadTexts: licenseSFPPortSupport.setDescription('The license key Ethernet SFP Port support setting.')
licenseAuxiliaryPortSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseAuxiliaryPortSupport.setStatus('current')
if mibBuilder.loadTexts: licenseAuxiliaryPortSupport.setDescription('The license key Ethernet Auxiliary Port support \n             setting.')
licenseCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("full", 0), ("mid", 1), ("lite", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseCapacity.setStatus('current')
if mibBuilder.loadTexts: licenseCapacity.setDescription('The license key capacity')
licenseMaxNumberOfTDMChannels = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMaxNumberOfTDMChannels.setStatus('current')
if mibBuilder.loadTexts: licenseMaxNumberOfTDMChannels.setDescription('The license key maximum TDM channels setting. Zero \n             indicates TDM not available.')
licenseIEEE1588Support = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIEEE1588Support.setStatus('current')
if mibBuilder.loadTexts: licenseIEEE1588Support.setDescription('The license key IEEE-1588 support setting.')
licenseSyncESupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSyncESupport.setStatus('current')
if mibBuilder.loadTexts: licenseSyncESupport.setDescription('The license key SyncE support setting.')
licenseIPv6Support = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIPv6Support.setStatus('current')
if mibBuilder.loadTexts: licenseIPv6Support.setDescription('The license key IPv6 support setting.')
licenseMinimumFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMinimumFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: licenseMinimumFirmwareVersion.setDescription('The minimum firmware version required to support this \n             license key.')
licenseFullCapabilityTrialStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("available", 0), ("active", 1), ("inactive", 2), ("expired", 3), ("unavailable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseFullCapabilityTrialStatus.setStatus('current')
if mibBuilder.loadTexts: licenseFullCapabilityTrialStatus.setDescription('The license key full capability trial period status.')
licenseRemainingTrialPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31536000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRemainingTrialPeriod.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriod.setDescription('The remaining time for the license key full capability \n             trial period.')
licenseRemainingTrialPeriodAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("fullCapabilityTrialNotActiveOrMoreThan7DaysRemaining", 0), ("fullCapabilityTrialExpiringInLessThan7Days", 1), ("fullCapabilityTrialExpiringInLessThan6Days", 2), ("fullCapabilityTrialExpiringInLessThan5Days", 3), ("fullCapabilityTrialExpiringInLessThan4Days", 4), ("fullCapabilityTrialExpiringInLessThan3Days", 5), ("fullCapabilityTrialExpiringInLessThan2Days", 6), ("fullCapabilityTrialExpiringInLessThan1Day", 7), ("fullCapabilityTrialHasExpired", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarm.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarm.setDescription('If the full capability trial license period is about to \n             expire then purchase a license upgrade from your \n             reseller.')
capacityVariantMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capacityVariantMismatch.setStatus('current')
if mibBuilder.loadTexts: capacityVariantMismatch.setDescription('The remote node of this link has a lower link capacity. \n             Operating with a reduced effective link capacity.')
licenseTDDSyncSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseTDDSyncSupport.setStatus('current')
if mibBuilder.loadTexts: licenseTDDSyncSupport.setDescription('The license key TDD Synchronization support setting.')
licenseMaxLinkRange = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMaxLinkRange.setStatus('current')
if mibBuilder.loadTexts: licenseMaxLinkRange.setDescription('Maximum licensed range for the wireless link in tenths \n             of km. A value of zero indicates that the maximum link \n             range is not limited by the license.')
licenseTrialPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseTrialPeriod.setStatus('current')
if mibBuilder.loadTexts: licenseTrialPeriod.setDescription('The license key maximum trial period, in days.')
licenseRARSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 8, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("mAB", 1), ("dLEP", 2), ("mABandDLEP", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRARSupport.setStatus('current')
if mibBuilder.loadTexts: licenseRARSupport.setDescription('The license key Radio Aware Routing support setting.')
licenseRegulatoryBandsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 8, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: licenseRegulatoryBandsTableIndex.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTableIndex.setDescription('License regulatory bands, used to index the \n             LicenseRegulatoryBandsTable.')
licenseRegulatoryBandsList = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 8, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("regInvalid", 0), ("reg158GHz", 1), ("reg258GHz", 2), ("reg358GHz", 3), ("reg458GHz", 4), ("reg558GHz", 5), ("reg658GHz", 6), ("reg754GHzUnrestrictedEIRPwithDFS", 7), ("reg854GHzUnrestrictedEIRP", 8), ("reg9", 9), ("reg1058GHz", 10), ("reg1158GHz", 11), ("reg1254GHzFCCUNII2C", 12), ("reg1354GHz", 13), ("reg1449GHzPublicSafety", 14), ("reg15", 15), ("reg1659GHz", 16), ("reg1759GHz", 17), ("reg1849GHzPublicSafety", 18), ("reg1958GHz", 19), ("reg2054GHz", 20), ("reg2154GHz", 21), ("reg2258GHz", 22), ("reg23", 23), ("reg2458GHz", 24), ("reg2558GHzETSI", 25), ("reg2654GHzETSI", 26), ("reg2758GHz", 27), ("reg2858GHz", 28), ("reg2958GHzUnrestrictedEIRPwithDFSandRTTT", 29), ("reg3054GHz", 30), ("reg3158GHz", 31), ("reg3249GHzLicensed", 32), ("reg3349GHzETSIBroadbandDisasterRelief", 33), ("reg3458GHz", 34), ("reg3558GHzUnrestrictedEIRP", 35), ("reg3654GHz", 36), ("reg3758GHz", 37), ("reg3852GHzFCCUNII2A", 38), ("reg3951GHzETSIBroadbandDisasterRelief", 39), ("reg4054GHz", 40), ("reg4154GHz", 41), ("reg4254GHz", 42), ("reg4354GHz", 43), ("reg4458GHz", 44), ("reg4558GHz", 45), ("reg4658GHz", 46), ("reg4758GHz", 47), ("reg4858GHz", 48), ("reg4958GHz", 49), ("reg5058GHz", 50), ("reg5158GHz", 51), ("reg5258GHz", 52), ("reg5358GHz", 53), ("reg5458GHz", 54), ("reg5558GHz", 55), ("reg5654GHz", 56), ("reg5754GHz", 57), ("reg5858GHz", 58), ("reg5958GHz", 59), ("reg6058GHz", 60), ("reg6149GHz", 61), ("reg6252GHz", 62), ("reg6352GHz", 63), ("reg6451GHz", 64), ("reg6551GHz", 65), ("reg6651GHz", 66), ("reg6752GHz", 67), ("reg6852GHz", 68), ("reg6952GHz", 69), ("reg7052GHz", 70), ("reg7152GHz", 71), ("reg7252GHz", 72), ("reg7352GHz", 73), ("reg7452GHz", 74), ("reg7552GHz", 75), ("reg7652GHz", 76), ("reg7752GHz", 77), ("reg7849GHz", 78), ("reg7954GHz", 79), ("reg8049GHz", 80), ("reg8147GHz", 81), ("reg8247GHz", 82), ("reg8352GHz", 83), ("reg8451GHzFCCUNII1", 84), ("reg8552GHzFCCUNII12A", 85), ("reg8654GHzFCCUNII2A2C", 86), ("reg8758GHz", 87), ("reg8849GHz", 88), ("reg8949GHz", 89), ("reg9054GHzFCCUNII2CParabolicantenna", 90), ("reg9152GHzFCCUNII2AParabolicantenna", 91), ("reg9251GHzFCCUNII1Parabolicantenna", 92), ("reg9349GHz", 93), ("reg94", 94), ("reg95", 95), ("reg96", 96), ("reg97", 97), ("reg98", 98), ("reg99", 99), ("reg100", 100), ("reg101", 101), ("reg102", 102), ("reg103", 103), ("reg104", 104), ("reg105", 105), ("reg106", 106), ("reg107", 107), ("reg108", 108), ("reg109", 109), ("reg110", 110), ("reg111", 111), ("reg112", 112), ("reg113", 113), ("reg114", 114), ("reg115", 115), ("reg116", 116), ("reg117", 117), ("reg118", 118), ("reg119", 119), ("reg120", 120), ("reg121", 121), ("reg122", 122), ("reg123", 123), ("reg124", 124), ("reg125", 125), ("reg126", 126), ("reg127", 127), ("reg128", 128), ("reg129", 129), ("reg130", 130), ("reg131", 131), ("reg132", 132), ("reg133", 133), ("reg134", 134), ("reg135", 135), ("reg136", 136), ("reg137", 137), ("reg138", 138), ("reg139", 139), ("reg140", 140), ("reg141", 141), ("reg142", 142), ("reg143", 143), ("reg144", 144), ("reg145", 145), ("reg146", 146), ("reg147", 147), ("reg148", 148), ("reg149", 149), ("reg150", 150), ("reg151", 151), ("reg152", 152), ("reg153", 153), ("reg154", 154), ("reg155", 155), ("reg156", 156), ("reg157", 157), ("reg158", 158), ("reg159", 159), ("reg160", 160), ("reg161", 161), ("reg162", 162), ("reg163", 163), ("reg164", 164), ("reg165", 165), ("reg166", 166), ("reg167", 167), ("reg168", 168), ("reg169", 169), ("reg170", 170), ("reg171", 171), ("reg172", 172), ("reg173", 173), ("reg174", 174), ("reg175", 175), ("reg176", 176), ("reg177", 177), ("reg178", 178), ("reg179", 179), ("reg180", 180), ("reg181", 181), ("reg182", 182), ("reg183", 183), ("reg184", 184), ("reg185", 185), ("reg186", 186), ("reg187", 187), ("reg188", 188), ("reg189", 189), ("reg190", 190), ("reg191", 191), ("reg192", 192), ("reg193", 193), ("reg194", 194), ("reg195", 195), ("reg196", 196), ("reg197", 197), ("reg198", 198), ("reg199", 199), ("reg200", 200), ("reg201", 201), ("reg202", 202), ("reg203", 203), ("reg204", 204), ("reg205", 205), ("reg206", 206), ("reg207", 207), ("reg208", 208), ("reg209", 209), ("reg210", 210), ("reg211", 211), ("reg212", 212), ("reg213", 213), ("reg214", 214), ("reg215", 215), ("reg216", 216), ("reg217", 217), ("reg218", 218), ("reg219", 219), ("reg220", 220), ("reg221", 221), ("reg222", 222), ("reg223", 223), ("reg224", 224), ("reg225", 225), ("reg226", 226), ("reg227", 227), ("reg228", 228), ("reg229", 229), ("reg230", 230), ("reg231", 231), ("reg232", 232), ("reg233", 233), ("reg234", 234), ("reg235", 235), ("reg236", 236), ("reg237", 237), ("reg238", 238), ("reg239", 239), ("reg240", 240), ("reg241", 241), ("reg242", 242), ("reg243", 243), ("reg244", 244), ("reg245", 245), ("reg246", 246), ("reg247", 247), ("reg248", 248), ("reg249", 249), ("reg250", 250), ("reg251", 251), ("reg252", 252), ("reg253", 253), ("reg254", 254)) + NamedValues(("reg255", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRegulatoryBandsList.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsList.setDescription('The list of regulatory bands for which the unit is \n             licensed to operate. A regulatory band prohibits the \n             wireless unit from operating outside the regulated \n             limits. An invalid regulatory band indicates a corrupted \n             license key. NB: a change of state may generate an SNMP \n             trap and/or SMTP email alert.')
targetRange = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: targetRange.setStatus('current')
if mibBuilder.loadTexts: targetRange.setDescription('Initial target range used in installation +/-1, \n             expressed in tenths of a kilometer. When Auto-Ranging \n             this must be set to 0')
rangingMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("auto0to40km", 0), ("auto0to100km", 1), ("auto0to200km", 2), ("targetRange", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rangingMode.setStatus('current')
if mibBuilder.loadTexts: rangingMode.setDescription('Type of ranging to use during installation, either \n             Auto-Ranging or use a selectable Target Range')
installStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("wrongPeer", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installStatus.setStatus('current')
if mibBuilder.loadTexts: installStatus.setDescription('A non-zero value indicates that signalling was received \n             with the wrong MAC address or a mismatched link name. NB: \n             It is very unusual to detect this, because units with \n             mis-configured Target MAC Address will normally fail to \n             establish a wireless link. However, rare circumstances \n             may establish a partial wireless link and detect this \n             situation. NB: A non-zero value on start-up, or a change \n             of value during operation, may generate an SNMP trap \n             and/or SMTP email alert')
installArmState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disarmed", 0), ("armed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installArmState.setStatus('current')
if mibBuilder.loadTexts: installArmState.setDescription('Indicates if the unit is being installed. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
tFTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: tFTPServerPortNumber.setDescription('The port number of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
tFTPSoftwareUpgradeFileName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setDescription('Filename of the Software Upgrade to be loaded from the \n             TFTP Server')
tFTPStartSoftwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setStatus('current')
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setDescription("Write '1' to this attribute to start the TFTP software \n             upgrade process. The attribute will be reset to 0 when \n             the upgrade process has finished. Continuing with the \n             software upgrade will cause spectrum management (DSO) \n             channel metrics collection to stop. The wireless unit \n             will no longer search for the optimal operational radio \n             channel. The performance of this wireless link may \n             deterioate over time. If operating in a regulatory band \n             where RADAR detection is mandatory you must complete the \n             software upgrade and reboot the unit. Channel metrics \n             collection will only be restarted after the wireless unit \n             has been rebooted")
tFTPSoftwareUpgradeStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 0), ("uploadinprogress", 1), ("uploadsuccessfulprogrammingFLASH", 2), ("upgradesuccessfulreboottorunthenewsoftwareimage", 3), ("upgradefailed", 4), ("upgradewarning", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setDescription('The current status of the TFTP Software upgrade process')
tFTPSoftwareUpgradeStatusText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setDescription('Descriptive text describing the status of the TFTP \n             Software upgrade process, including any error details')
tFTPSoftwareUpgradeStatusAdditionalText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setDescription('Any additional text describing the status of the TFTP \n             Software upgrade process, including any error details')
hTTPAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: hTTPAccessEnabled.setDescription('This controls whether or not HTTP access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the HTTP port. Remote \n             management via HTTPS is not affected by this setting. Any \n             change in this setting will not take effect until the \n             unit has been rebooted. (Factory default = Enabled)')
telnetAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: telnetAccessEnabled.setDescription('This controls whether or not Telnet access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the TELNET port. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = Disabled)')
hTTPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPPortNumber.setStatus('current')
if mibBuilder.loadTexts: hTTPPortNumber.setDescription('This controls the port number for HTTP access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 80)')
hTTPSPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPSPortNumber.setStatus('current')
if mibBuilder.loadTexts: hTTPSPortNumber.setDescription('This controls the port number for HTTPS access. A value \n             of zero will use the default port number. Availability of \n             HTTPS is controlled via the License Key. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 443)')
telnetPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetPortNumber.setStatus('current')
if mibBuilder.loadTexts: telnetPortNumber.setDescription('This controls the port number for TELNET access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 23)')
hTTPSAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPSAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: hTTPSAccessEnabled.setDescription('This controls whether or not HTTPS access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the HTTPS port. Remote \n             management via HTTP is not affected by this setting. Any \n             change in this setting will not take effect until the \n             unit has been rebooted. (Factory default = Enabled)')
tFTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             tFTPServerInternetAddress.')
tFTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 19), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: tFTPServerInternetAddress.setDescription('INET address of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
lowestDataModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lowestDataModulationMode.setStatus('current')
if mibBuilder.loadTexts: lowestDataModulationMode.setDescription('The lowest modulation mode at which Ethernet Data \n             traffic will be bridged over the wireless link')
lowestSecondDataModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 9, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lowestSecondDataModulationMode.setStatus('current')
if mibBuilder.loadTexts: lowestSecondDataModulationMode.setDescription('The lowest modulation mode at which Second Data Service \n             Ethernet traffic will be bridged over the wireless link')
linkSymmetry = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("symmetryAdaptive", 0), ("symmetry2to1", 1), ("symmetry1to1", 2), ("symmetry1to2", 3), ("symmetry3to1", 4), ("symmetry1to3", 5), ("symmetry5to1", 6), ("symmetry1to5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSymmetry.setStatus('current')
if mibBuilder.loadTexts: linkSymmetry.setDescription('Provides configuration options for sharing the available \n             wireless capacity between the transmit and receive \n             directions. Fixed link symmetry is defined by a ratio of \n             the burst duration for the transmit direction to the \n             burst duration for the receive direction. Permitted \n             settings are 5:1, 3:1, 2:1, 1:1, 1:2, 1:3, 1:5. The 1:1 \n             option provides fixed symmetric operation. The adaptive \n             option selects transmit and receive burst durations \n             automatically in response to the offered Ethernet traffic \n             in each link direction. This attribute is valid only for \n             a unit configured as a TDD Master')
userConfiguredMaxModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("modBpsk63percent", 0), ("modQpsk63percent", 1), ("modQpsk87percent", 2), ("mod16qam63percent", 3), ("mod16qam87percent", 4), ("mod64qam75percent", 5), ("mod64qam92percent", 6), ("mod256qam81percent", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userConfiguredMaxModulationMode.setStatus('current')
if mibBuilder.loadTexts: userConfiguredMaxModulationMode.setDescription('The maximum receive modulation mode controls the MAX \n             mode used for adaptive modulation. NOTE: This attribute \n             is automatically disabled when the installation agent is \n             armed. To disarm the installation agent use the \n             installation wizard')
linkModeOptimization = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("iPTraffic", 0), ("tDMTraffic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkModeOptimization.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimization.setDescription("Optimizes the wireless link behavior for the type of \n             traffic to be carried. In 'IP Traffic' mode, the wireless \n             link will minimize transmission errors by automatically \n             adapting the modulation mode. In 'TDM Traffic' mode, the \n             wireless link will minimize transmission latency and \n             preserve throughput by maintaining a higher modulation \n             mode in the presence of a limited number of errors. The \n             'TDM Traffic' mode is recommended for E1/T1 applications \n             and connectionless protocols.")
txColorCode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3), ("e", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: txColorCode.setStatus('current')
if mibBuilder.loadTexts: txColorCode.setDescription('Transmit Color Code. This attribute need only be \n             considered when the unit is installed in a network of PTP \n             units and where some of the units are operating on the \n             same frequency. In this case, the value would normally be \n             derived by a network planner. In all other cases, it is \n             recommended that this attribute is left at the default \n             value. NOTE: For the link to operate, the value of this \n             parameter must in all cases match the value of the Rx \n             Color Code parameter at the far end of the link.')
rxColorCode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3), ("e", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxColorCode.setStatus('current')
if mibBuilder.loadTexts: rxColorCode.setDescription('Receive Color Code. This attribute need only be \n             considered when the unit is installed in a network of PTP \n             units and where some of the units are operating on the \n             same frequency. In this case, the value would normally be \n             derived by a network planner. In all other cases, it is \n             recommended that this attribute is left at the default \n             value. NOTE: For the link to operate, the value of this \n             parameter must in all cases match the value of the Tx \n             Color Code parameter at the far end of the link.')
remoteMaximumTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 10, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setStatus('current')
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setDescription('Maximum transmit power the remote wireless unit is \n             permitted to use when establishing and maintaining the \n             wireless link')
linkLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-500, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkLoss.setStatus('current')
if mibBuilder.loadTexts: linkLoss.setDescription('The wireless link loss expressed in tenths of a dB')
receivePower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivePower.setStatus('current')
if mibBuilder.loadTexts: receivePower.setDescription('Receive power expressed in tenths of a dBm')
vectorError = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vectorError.setStatus('current')
if mibBuilder.loadTexts: vectorError.setDescription("The vector error measurement compares the received \n             signal's IQ modulation characteristics to an ideal signal \n             to determine the composite error vector magnitude. The \n             value represented by this attribute is the average vector \n             error over the previous second expressed in tenths of a \n             dB")
transmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitPower.setStatus('current')
if mibBuilder.loadTexts: transmitPower.setDescription('Transmit power expressed in tenths of a dBm')
receiveChannel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveChannel.setStatus('current')
if mibBuilder.loadTexts: receiveChannel.setDescription('Current active receive channel')
transmitChannel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitChannel.setStatus('current')
if mibBuilder.loadTexts: transmitChannel.setDescription('Current active transmit channel')
receiveFreqMHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveFreqMHz.setStatus('current')
if mibBuilder.loadTexts: receiveFreqMHz.setDescription('Current receive frequency expressed in integer MHz')
transmitFreqMHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitFreqMHz.setStatus('current')
if mibBuilder.loadTexts: transmitFreqMHz.setDescription('Current transmit frequency expressed in integer MHz')
signalStrengthRatio = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalStrengthRatio.setStatus('current')
if mibBuilder.loadTexts: signalStrengthRatio.setDescription('Signal strength ratio (Vertical / Horizontal) : the \n             number of dB larger the Vertical antenna input is than \n             the Horizontal antenna input expressed in tenths of a dB')
receiveFreqKHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveFreqKHz.setStatus('current')
if mibBuilder.loadTexts: receiveFreqKHz.setDescription('Current receive frequency expressed as KHz')
transmitFreqKHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitFreqKHz.setStatus('current')
if mibBuilder.loadTexts: transmitFreqKHz.setDescription('Current transmit frequency expressed as KHz')
rawReceivePower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rawReceivePower.setStatus('current')
if mibBuilder.loadTexts: rawReceivePower.setDescription('Raw receive power expressed in tenths of a dBm')
range = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: range.setStatus('current')
if mibBuilder.loadTexts: range.setDescription('Distance between the two peer wireless units expressed \n             in tenths of a kilometer')
receiveModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationMode.setStatus('current')
if mibBuilder.loadTexts: receiveModulationMode.setDescription('Current active receive modulation mode')
transmitModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitModulationMode.setStatus('current')
if mibBuilder.loadTexts: transmitModulationMode.setDescription('Current active transmit modulation mode')
searchState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 12, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("registering", 0), ("searching", 1), ("acquiring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: searchState.setStatus('current')
if mibBuilder.loadTexts: searchState.setDescription("Search status of the wireless modem. 'Registering' means \n             that the modem has locked to an OFDM signal, and the \n             wireless link is up. 'Searching' means that no wireless \n             signal has been detected. 'Acquiring' means that a \n             wireless signal has been detected, but the modem has not \n             locked to an OFDM signal.")
unitOutOfCalibration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("calibrated", 0), ("partialCalibration", 1), ("invalidCalibration", 2), ("bandwidthvariantunsupportedPAsShutdown", 3), ("outOfCalibrationPAsShutdown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitOutOfCalibration.setStatus('current')
if mibBuilder.loadTexts: unitOutOfCalibration.setDescription('The unit is out of calibration')
incompatibleRegulatoryBands = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("regOK", 0), ("regIncompatibleLicenseKeys", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleRegulatoryBands.setStatus('current')
if mibBuilder.loadTexts: incompatibleRegulatoryBands.setDescription('The master and slave units have incompatible regulatory \n             bands. NB: Both units must have compatible license keys')
noWirelessChannelAvailable = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("noWirelessChannelAvailable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: noWirelessChannelAvailable.setStatus('current')
if mibBuilder.loadTexts: noWirelessChannelAvailable.setDescription('Spectrum Management was unable to locate a suitable \n             wireless channel to operate on')
wirelessLinkDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkDisabledWarning.setDescription('The SNMP ifAdminStatus of the wireless interface has \n             disabled wireless traffic')
mainPSUPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPError = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("installedSFPNotLicensed", 1), ("fiberLinkNotEstablishedButLOSNotDetected", 2), ("fiberLinkNotEstablishedAndLOSDetected", 3), ("installedSFPNotSupported", 4), ("sFPInitializationFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPError.setStatus('current')
if mibBuilder.loadTexts: sFPError.setDescription('If the SFP link is not OK, there are five possible \n             causes: Either a SFP has been installed but the license \n             key does not include SFP fiber support, a fiber link \n             could not be established even though no LOS was detected \n             (i.e. an optical carrier was detected, which could be due \n             to a broken TX fiber, or because the link is disabled at \n             the fiber link partner), a fiber link could not be \n             established and LOS is detected (i.e. no optical carrier \n             is detected), the installed SFP is not supported or the \n             installed SFP failed to initialize correctly. NB: a \n             change of status may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch')
incompatibleMasterAndSlave = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("incompatibleProductVariants", 1), ("differentSoftwareVersionsRunning", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleMasterAndSlave.setStatus('current')
if mibBuilder.loadTexts: incompatibleMasterAndSlave.setDescription('A non-zero value indicates that the master and slave \n             ends of a link are different hardware products, or have \n             different software versions. NB: It is very unusual to \n             detect this, because incompatible units will normally \n             fail to establish a wireless link. However, some \n             combinations may establish a partial wireless link and \n             detect this situation. NB: A non-zero value may generate \n             an SNMP trap and/or SMTP email alert')
tDDSynchronizationStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("locked", 0), ("holdover", 1), ("holdoverNoGPSSyncIn", 2), ("notSynchronized", 3), ("notSynchronizedNoGPSSyncIn", 4), ("pTPSYNCNotConnected", 5), ("initialising", 6), ("clusterTimingMaster", 7), ("acquiringLock", 8), ("inactive", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationStatus.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationStatus.setDescription('An alarm value (displayed in red) indicates that one of \n             the following conditions has not been met (i) An external \n             timing system is connected or internal timing has been \n             configured. (ii) The timing system is providing a useable \n             reference. (iii) The ODU is locked to this reference.')
auxPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: auxPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
tDDSynchronizationAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("synchronizationLost", 1), ("referenceSignalLost", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationAlarm.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationAlarm.setDescription('Not Synchronized indicates failure of the external \n             timing system for a period greater than the holdover \n             timer. TDD frame timing will have drifted, and this link \n             may cause interference with other links in a synchronized \n             network. Timing System Failure is an early warning, \n             indicating that 80% of the holdover period has expired.')
linkModeOptimizationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("linkModeOptimizationMismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkModeOptimizationMismatch.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimizationMismatch.setDescription('The remote node of this link has been configured with a \n             different link mode optimization')
auxPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: auxPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
secureModeAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("secureModeIsActive", 0), ("secureModeIsNotConfigured", 1), ("secureModeIsConfiguredButNotActive", 2), ("secureModeIsNotSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secureModeAlarm.setStatus('current')
if mibBuilder.loadTexts: secureModeAlarm.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
dataBridgingStatusAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bridgingEnabled", 0), ("bridgingDisabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatusAlarm.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusAlarm.setDescription('Ethernet Data traffic bridging is disabled because the \n             wireless link is not operating at the configured Lowest \n             Data Modulation Mode')
sFPPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: sFPPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: sFPPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
maxLinkRangeExceeded = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("maxLinkRangeOK", 0), ("maxLinkRangeExceeded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxLinkRangeExceeded.setStatus('current')
if mibBuilder.loadTexts: maxLinkRangeExceeded.setDescription('The measured link range is greater than the maximum \n             allowed by the license key. The link will operate at a \n             reduced capacity while this condition applies. This alarm \n             is only raised if the license specifies a maximum link \n             range and the trial license is not active.')
nIDULanPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
nIDULanPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch.')
portAllocationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("portAllocationOK", 0), ("mismatchinSecondDataService", 1), ("mismatchinOutofBandRemoteManagementService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAllocationMismatch.setStatus('current')
if mibBuilder.loadTexts: portAllocationMismatch.setDescription('The local and remote ODUs have different services \n             configured.')
secondDataBridgingStatusAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bridgingEnabled", 0), ("bridgingDisabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondDataBridgingStatusAlarm.setStatus('current')
if mibBuilder.loadTexts: secondDataBridgingStatusAlarm.setDescription('Bridging of Ethernet traffic from Second Data Service \n             has been disabled because the wireless link is not \n             operating at the configured Lowest Second Data Modulation \n             Mode')
transparentClockSourcePortAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 13, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("invalidTransparentClockSourcePort", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transparentClockSourcePortAlarm.setStatus('current')
if mibBuilder.loadTexts: transparentClockSourcePortAlarm.setDescription('Transparent Clock will not function properly because \n             SFP, the selected clock source port is not FIBER')
sMTPEmailAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEmailAlert.setStatus('current')
if mibBuilder.loadTexts: sMTPEmailAlert.setDescription('Simple Mail Transfer Protocol is used to send equipment \n             alerts via email to a specified email address')
sMTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: sMTPServerPortNumber.setDescription('Port number of the SMTP server')
sMTPSourceEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setDescription("The 'from' email address used when constructing the \n             automatically generated e-mail message")
sMTPDestinationEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setDescription("The 'to' email address used when constructing the \n             automatically generated e-mail message")
sMTPEnabledMessages = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 6), Bits().clone(namedValues=NamedValues(("nIDULanPortUpDown", 0), ("sFPPortUpDown", 1), ("auxPortUpDown", 2), ("mainPSUPortUpDown", 3), ("enabledDiagnosticAlarms", 4), ("dFSImpulseInterference", 5), ("channelChange", 6), ("wirelessLinkUpDown", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEnabledMessages.setStatus('current')
if mibBuilder.loadTexts: sMTPEnabledMessages.setDescription('This controls which SMTP messages the unit will send')
sMTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sMTPServerInternetAddress.')
sMTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 15, 8), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPServerInternetAddress.setDescription('Internet address of the SMTP server')
sNMPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPPortNumber.setDescription('The IP port number used to access the SNMP MIB (i.e. \n             Gets and Sets) (default = 161). NB: A system reboot is \n             required to activate changes to this attribute')
sNMPCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPCommunityString.setStatus('current')
if mibBuilder.loadTexts: sNMPCommunityString.setDescription('The SNMP community string. NB: A system reboot is \n             required to activate changes to this attribute')
sNMPTrapTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapTableNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableNumber.setDescription('Number of entries in the sNMPTrapTable.')
sNMPTrapVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("v1", 0), ("v2c", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapVersion.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapVersion.setDescription('The SNMP protocol version to use for SNMP Traps. NB: A \n             system reboot is required to activate changes to this \n             attribute')
sNMPEnabledTraps = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 6), Bits().clone(namedValues=NamedValues(("auxPortUpDown", 0), ("mainPSUPortUpDown", 1), ("authenticationFailure", 2), ("enabledDiagnosticAlarms", 3), ("dFSImpulseInterference", 4), ("channelChange", 5), ("wirelessLinkUpDown", 6), ("coldStart", 7), ("nIDULanPortUpDown", 14), ("sFPPortUpDown", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPEnabledTraps.setStatus('current')
if mibBuilder.loadTexts: sNMPEnabledTraps.setDescription('This controls which SNMP Traps the unit will send')
enabledDiagnosticAlarms = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 7), Bits().clone(namedValues=NamedValues(("portState", 0), ("incompatibleMasterAndSlave", 1), ("incompatibleRegulatoryBands", 2), ("maximumLinkRangeExceeded", 3), ("unitOutOfCalibration", 4), ("installArmState", 5), ("installStatus", 6), ("regulatoryBand", 7), ("syslogLocalWrapped", 8), ("syslogLocalNearlyFull", 9), ("syslogDisabledWarning", 10), ("linkModeOptimizationMismatch", 11), ("tDDSynchronizationAlarm", 12), ("wirelessLinkDisabledWarning", 13), ("sNTPSynchronizationFailed", 14), ("noWirelessChannelAvailable", 15), ("tDMAlarms", 18), ("capacityVariantMismatch", 19), ("remainingFullCapacityTrialTime", 20), ("dataBridgingStatus", 21), ("unknown18", 22), ("syslogClientDisabledWarning", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setStatus('current')
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setDescription("Controls which individual diagnostic alarms are enabled. \n             The unit may be configured to generate SNMP traps and/or \n             SMTP email alerts for these enabled alarms by selecting \n             'Enabled Diagnostic Alarms' on the 'SNMP Enabled Traps' \n             and/or 'SMTP Enabled Messages' attributes")
sNMPSendAllTrapsAtStartup = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 16, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPSendAllTrapsAtStartup.setStatus('current')
if mibBuilder.loadTexts: sNMPSendAllTrapsAtStartup.setDescription('Controls whether cleared traps are reported at start-up \n             as well as raised traps. Only enabled traps will be \n             reported. NB: Traps corresponding to transient events \n             (i.e. not associated with an alarm or status value) are \n             only sent when required and not at start-up.')
sNMPTrapTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNMPTrapTableIndex.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableIndex.setDescription('SNMP trap value, used to index the SNMPTrapTable.')
sNMPTrapPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapPortNumber.setDescription('Destination port for SNMP Traps (default=162). NB: A \n             system reboot is required to activate changes to this \n             attribute.')
sNMPTrapInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNMPTrapInternetAddress.')
sNMPTrapInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setDescription('The Internet address to which all SNMP Traps are sent.')
sNMPTrapReceiverEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 16, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setDescription('A value of 0 disables the sending of SNMP trap to \n             corresponding receiver. A value of 1 enables the sending \n             of SNMP trap to corresponding receiver.')
sNTPState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPState.setStatus('current')
if mibBuilder.loadTexts: sNTPState.setDescription('SNTP control state')
sNTPPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 43200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPollInterval.setStatus('current')
if mibBuilder.loadTexts: sNTPPollInterval.setDescription('The SNTP server polling interval')
sNTPSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noSync", 0), ("inSync", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPSync.setStatus('current')
if mibBuilder.loadTexts: sNTPSync.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP')
sNTPLastSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPLastSync.setStatus('current')
if mibBuilder.loadTexts: sNTPLastSync.setDescription('Last SNTP sync time')
systemClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemClock.setStatus('current')
if mibBuilder.loadTexts: systemClock.setDescription('System clock presented as local time')
timeZone = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50))).clone(namedValues=NamedValues(("gmtMinus1200", 0), ("gmtMinus1130", 1), ("gmtMinus1100", 2), ("gmtMinus1030", 3), ("gmtMinus1000", 4), ("gmtMinus0930", 5), ("gmtMinus0900", 6), ("gmtMinus0830", 7), ("gmtMinus0800", 8), ("gmtMinus0730", 9), ("gmtMinus0700", 10), ("gmtMinus0630", 11), ("gmtMinus0600", 12), ("gmtMinus0530", 13), ("gmtMinus0500", 14), ("gmtMinus0430", 15), ("gmtMinus0400", 16), ("gmtMinus0330", 17), ("gmtMinus0300", 18), ("gmtMinus0230", 19), ("gmtMinus0200", 20), ("gmtMinus0130", 21), ("gmtMinus0100", 22), ("gmtMinus0030", 23), ("gmtZero", 24), ("gmtPlus0030", 25), ("gmtPlus0100", 26), ("gmtPlus0130", 27), ("gmtPlus0200", 28), ("gmtPlus0230", 29), ("gmtPlus0300", 30), ("gmtPlus0330", 31), ("gmtPlus0400", 32), ("gmtPlus0430", 33), ("gmtPlus0500", 34), ("gmtPlus0530", 35), ("gmtPlus0600", 36), ("gmtPlus0630", 37), ("gmtPlus0700", 38), ("gmtPlus0730", 39), ("gmtPlus0800", 40), ("gmtPlus0830", 41), ("gmtPlus0900", 42), ("gmtPlus0930", 43), ("gmtPlus1000", 44), ("gmtPlus1030", 45), ("gmtPlus1100", 46), ("gmtPlus1130", 47), ("gmtPlus1200", 48), ("gmtPlus1230", 49), ("gmtPlus1300", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeZone.setStatus('current')
if mibBuilder.loadTexts: timeZone.setDescription('Time zone offsets from Greenwich Mean Time (GMT)')
daylightSaving = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylightSaving.setStatus('current')
if mibBuilder.loadTexts: daylightSaving.setDescription('Daylight Saving Time')
sNTPPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("server1", 0), ("server2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: sNTPPrimaryServer.setDescription('Specifies the primary SNTP server, determining the order \n             in which the servers are tried.')
sNTPPrimaryServerDeadTime = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setStatus('current')
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setDescription('Time (in seconds) to wait before retrying communications \n             with an unresponsive primary SNTP server. Setting the \n             value to 0 disables the timer.')
sNTPServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerRetries.setStatus('current')
if mibBuilder.loadTexts: sNTPServerRetries.setDescription('Number of times the PTP will retry after an SNTP server \n             fails to respond.')
sNTPServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerTimeout.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTimeout.setDescription('Time (in seconds) the PTP will wait for a response from \n             an SNTP server.')
sNTPServerTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 17, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerTableNumber.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableNumber.setDescription('Number of entries in the SNTPServerTable.')
sNTPServerTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNTPServerTableIndex.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableIndex.setDescription('Index range for the SNTPServerTable.')
sNTPServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNTPServerPortNumber.setDescription('The IP port number of the SNTP server. Defaults to port \n             123.')
sNTPServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerStatus.setStatus('current')
if mibBuilder.loadTexts: sNTPServerStatus.setDescription('Status message reflecting the result of communications \n             with the SNTP server when last polled')
sNTPServerInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNTPServerInternetAddress.')
sNTPServerInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 17, 15, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNTPServerInternetAddress.setDescription('The Internet address of a valid SNTP server')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("running", 0), ("consoleReboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('current')
if mibBuilder.loadTexts: systemReset.setDescription("Setting this attribute to '1' will cause a system \n             reboot. NB: a system reboot will apply any pending new \n             settings held in memory")
softwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersion.setStatus('current')
if mibBuilder.loadTexts: softwareVersion.setDescription('Current software version')
hardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 19, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareVersion.setStatus('current')
if mibBuilder.loadTexts: hardwareVersion.setDescription('Hardware platform version')
secondarySoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 19, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondarySoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: secondarySoftwareVersion.setDescription('Secondary software version, used when the primary \n             software image is invalid or erased')
bootVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 19, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootVersion.setStatus('current')
if mibBuilder.loadTexts: bootVersion.setDescription('Boot code software version')
receiveDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveDataRate.setStatus('current')
if mibBuilder.loadTexts: receiveDataRate.setDescription('Average data rate over the last one second interval \n             (kbps)')
transmitDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitDataRate.setStatus('current')
if mibBuilder.loadTexts: transmitDataRate.setDescription('Average data rate over the last one second interval \n             (kbps)')
aggregateDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregateDataRate.setStatus('current')
if mibBuilder.loadTexts: aggregateDataRate.setDescription('Average data rate over the last one second interval \n             (kbps)')
wirelessLinkAvailability = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkAvailability.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkAvailability.setDescription('Link availability calculated since the last reset of the \n             system counters, as a percentage multiplied by 10000 to \n             give four decimal places of precision')
wirelessLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 0), ("registering", 1), ("searching", 2), ("acquiring", 3), ("radarCAC", 4), ("initialising", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkStatus.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkStatus.setDescription('Current status of the wireless link')
byteErrorRatio = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: byteErrorRatio.setStatus('current')
if mibBuilder.loadTexts: byteErrorRatio.setDescription('Reciprocal of the byte error ratio calculated since the \n             last reset of the system counters')
receiveModulationModeDetail = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("runningAtMaximumReceiveMode", 0), ("runningAtUserConfiguredMaxModulationMode", 1), ("restrictedBecauseInstallationIsArmed", 2), ("restrictedBecauseOfByteErrorsOnTheWirelessLink", 3), ("restrictedBecauseTheLinkParametersAreUpdating", 4), ("restrictedBecauseChannelChangeIsInProgress", 5), ("restrictedDueToTheLowEthernetLinkSpeed", 6), ("runningAtMaximumReceiveModeForChannelBandwidth", 7), ("limitedByTheWirelessConditions", 8), ("restrictedBecauseFullCapabilityTrialLicenseExpired", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationModeDetail.setStatus('current')
if mibBuilder.loadTexts: receiveModulationModeDetail.setDescription('The reason for the current receive modulation mode')
dataBridgingAvailability = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 20, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingAvailability.setStatus('current')
if mibBuilder.loadTexts: dataBridgingAvailability.setDescription('Link availability bridging Ethernet Data traffic \n             calculated since the last reset of the system counters, \n             as a percentage multiplied by 10000 to give four decimal \n             places of precision')
encryptionAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("aESRijndael", 1), ("aES192bitRijndael", 2), ("aES256bitRijndael", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: encryptionAlgorithm.setStatus('current')
if mibBuilder.loadTexts: encryptionAlgorithm.setDescription('The Encryption Algorithm used by the wireless link. NB: \n             A system reboot is required to activate changes to this \n             attribute. NB: The same Encryption Algorithm must be \n             configured at BOTH ends of the link for it to function \n             correctly')
tDDSynchronizationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 23, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationMode.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationMode.setDescription('TDD Synchronization Mode selection')
userTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 25, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userTableNumber.setStatus('current')
if mibBuilder.loadTexts: userTableNumber.setDescription('Number of entries in the userTable')
userTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: userTableIndex.setStatus('current')
if mibBuilder.loadTexts: userTableIndex.setDescription('used to index values in the userTable.')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 67))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('current')
if mibBuilder.loadTexts: userName.setDescription('User name which must be entered, along with the \n             appropriate password, in order to gain access to the \n             system.')
userRole = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("readOnly", 0), ("systemAdministrator", 1), ("securityOfficer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userRole.setStatus('current')
if mibBuilder.loadTexts: userRole.setDescription('Role of the selected user. A Security Officer has access \n             to and can modify all settings. A System Administrator \n             has access to and can modify all non-security settings. A \n             Read Only user can view settings, but cannot make any \n             changes.')
userEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userEnabled.setStatus('current')
if mibBuilder.loadTexts: userEnabled.setDescription('Enable / Disable the selected user')
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 25, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 67))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('current')
if mibBuilder.loadTexts: userPassword.setDescription('User password, which must be entered in order to gain \n             access to the system.')
syslogClient = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 24, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogClient.setStatus('current')
if mibBuilder.loadTexts: syslogClient.setDescription('Enable or disable the syslog client')
syslogState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 24, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogState.setStatus('current')
if mibBuilder.loadTexts: syslogState.setDescription('The syslog service has been enabled or disabled')
microwaveAdaptiveBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: microwaveAdaptiveBandwidth.setStatus('current')
if mibBuilder.loadTexts: microwaveAdaptiveBandwidth.setDescription('Enable support of Microwave Adaptive Bandwidth Protocol. \n             MAB is disabled if link symmetry is configured as \n             Adaptive')
mABNominalModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABNominalModulationMode.setStatus('current')
if mibBuilder.loadTexts: mABNominalModulationMode.setDescription('The Nominal modulation mode is the desired modulation \n             mode. MAB VSM packets are generated when the current \n             modulation mode falls below the nominal modulation.')
mABTransmissionInterval = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("transmissionInterval1s", 0), ("transmissionInterval10s", 1), ("transmissionInterval60s", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABTransmissionInterval.setStatus('current')
if mibBuilder.loadTexts: mABTransmissionInterval.setDescription('The minimum interval (in seconds) between successive MAB \n             vendor specific messages (VSM). These VSM are sent when \n             the current transmit capacity falls below the configured \n             MAB Nominal Modulation Mode.')
mABHoldoffPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABHoldoffPeriod.setStatus('current')
if mibBuilder.loadTexts: mABHoldoffPeriod.setDescription('The period (in seconds) over which transmit capacity is \n             averaged over to determine when the wireless link has \n             degraded')
mABMaintenanceLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABMaintenanceLevel.setStatus('current')
if mibBuilder.loadTexts: mABMaintenanceLevel.setDescription('Maintenance Levels (0-7) determines the destination MAC \n             address of MAB vendor specific messages.')
useVLANForMABProtocol = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noVLANTagging", 0), ("iEEE8021QTaggedCTagType8100", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: useVLANForMABProtocol.setStatus('current')
if mibBuilder.loadTexts: useVLANForMABProtocol.setDescription('This controls whether MAB vendor specific messages (VSM) \n             packets use VLAN tags or not.')
mABProtocolVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABProtocolVID.setStatus('current')
if mibBuilder.loadTexts: mABProtocolVID.setDescription('This VLAN VID (0-4094) will be included in MAB vendor \n             specific messages (VSM) packets.')
mABProtocolVLANPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABProtocolVLANPriority.setStatus('current')
if mibBuilder.loadTexts: mABProtocolVLANPriority.setDescription('This VLAN Priority (0-7) will be included in MAB vendor \n             specific messages (VSM) packets.')
mABState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("degraded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABState.setStatus('current')
if mibBuilder.loadTexts: mABState.setDescription("Current state of MAB Protocol. A state of 'Normal' on a \n             green background indicates that a PTP link is operating \n             at nominal capacity")
mABNominalTransmitCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABNominalTransmitCapacity.setStatus('current')
if mibBuilder.loadTexts: mABNominalTransmitCapacity.setDescription('The nominal Tx capacity used in MAB Vendor Specific \n             Messages for the selected nominal modulation mode ')
mABCurrentTransmitCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 26, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABCurrentTransmitCapacity.setStatus('current')
if mibBuilder.loadTexts: mABCurrentTransmitCapacity.setDescription('The current Tx capacity of the wireless link used in the \n             last MAB Vendor Specific Message transmitted.')
cableDiagnosticsPorts = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 27, 1), Bits().clone(namedValues=NamedValues(("auxPort", 6), ("mainPSUPort", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableDiagnosticsPorts.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsPorts.setDescription('Select ports on which Cable Diagnostics must be \n             executed')
cableDiagnosticsControl = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 27, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("startTest", 0), ("testInProgress", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableDiagnosticsControl.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsControl.setDescription("Set this attribute to 'Test in Progress' to start a \n             Cable Diagnostics test")
cableDiagnosticsWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 27, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("idle", 0), ("testInProgress", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsWarning.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsWarning.setDescription('Normal Ethernet operation is disrupted when a Cable \n             Diagnostics test is in progress')
cableDiagnosticsResultTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 27, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsResultTableNumber.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableNumber.setDescription('Number of rows in the Cable Diagnostics Result Table.')
cableDiagnosticsResultTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: cableDiagnosticsResultTableIndex.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableIndex.setDescription('Cable Diagnostics Port value used to index into the \n             result table.')
cableDiagnosticsResultsDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsResultsDateTime.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultsDateTime.setDescription('The Date and Time when a Cable Diagnostics test was last \n             executed')
cableDiagPair1Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair1Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair1Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 1. According to the T658B \n             wiring scheme, pair 1 is pins 4 & 5 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair1Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair1Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair1Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair2Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair2Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair2Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 2. According to the T658B \n             wiring scheme, pair 2 is pins 1 & 2 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair2Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair2Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair2Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair3Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair3Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair3Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 3. According to the T658B \n             wiring scheme, pair 3 is pins 3 & 6 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair3Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair3Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair3Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair4Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair4Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair4Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 4. According to the T658B \n             wiring scheme, pair 4 is pins 7 & 8 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair4Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 7, 27, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair4Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair4Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
longitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 96, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: longitude.setStatus('current')
if mibBuilder.loadTexts: longitude.setDescription('The longitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
latitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 96, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: latitude.setStatus('current')
if mibBuilder.loadTexts: latitude.setDescription('The latitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
altitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 7, 96, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: altitude.setStatus('current')
if mibBuilder.loadTexts: altitude.setDescription('The altitude of the unit, measured in meters. This \n             object is set by the SNMP manager and has no internal \n             function.')
channelChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 1)).setObjects(("CAMBIUM-PTP650-MIB", "receiveChannel"))
if mibBuilder.loadTexts: channelChangeTrap.setStatus('current')
if mibBuilder.loadTexts: channelChangeTrap.setDescription('The PTP radio has changed wireless channel.\n                 This has been caused by either\n                 i) mandatory radar avoidance,\n                    a DFS impulsive interference event will also be\n                    detected,\n                 or\n                 ii) Dynamic Spectrum Optimization, (DSO)\n                     DSO improves link performance by selecting the\n                     most appropriate transmit and receive channels\n                     with the lowest level of interference.')
dfsImpulsiveInterferenceTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 2)).setObjects(("CAMBIUM-PTP650-MIB", "receiveChannel"))
if mibBuilder.loadTexts: dfsImpulsiveInterferenceTrap.setStatus('current')
if mibBuilder.loadTexts: dfsImpulsiveInterferenceTrap.setDescription('DFS impulsive interference detected event')
mainPSUPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 3)).setObjects(("CAMBIUM-PTP650-MIB", "mainPSUPortStatus"))
if mibBuilder.loadTexts: mainPSUPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortStatusTrap.setDescription('Current status of the Main PSU Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 4)).setObjects(("CAMBIUM-PTP650-MIB", "mainPSUPortDisabledWarning"))
if mibBuilder.loadTexts: mainPSUPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
mainPSUPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 5)).setObjects(("CAMBIUM-PTP650-MIB", "mainPSUPortConfigurationMismatch"))
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch')
auxPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 6)).setObjects(("CAMBIUM-PTP650-MIB", "auxPortStatus"))
if mibBuilder.loadTexts: auxPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortStatusTrap.setDescription('Current status of the Aux Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
auxPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 7)).setObjects(("CAMBIUM-PTP650-MIB", "auxPortDisabledWarning"))
if mibBuilder.loadTexts: auxPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
regulatoryBandTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 8)).setObjects(("CAMBIUM-PTP650-MIB", "regulatoryBand"))
if mibBuilder.loadTexts: regulatoryBandTrap.setStatus('current')
if mibBuilder.loadTexts: regulatoryBandTrap.setDescription('The Regulatory Band prohibits the wireless unit from \n             operating outside the regulated limits. An invalid \n             Regulatory Band may be caused by a missing or incorrect \n             License Key, a corrupt MAC Address or an attempt to \n             configure a Regulatory Band not allowed by the License \n             Key. NB: a change of state may generate an SNMP trap \n             and/or SMTP email alert.')
installStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 9)).setObjects(("CAMBIUM-PTP650-MIB", "installStatus"))
if mibBuilder.loadTexts: installStatusTrap.setStatus('current')
if mibBuilder.loadTexts: installStatusTrap.setDescription('A non-zero value indicates that signalling was received \n             with the wrong MAC address or a mismatched link name. NB: \n             It is very unusual to detect this, because units with \n             mis-configured Target MAC Address will normally fail to \n             establish a wireless link. However, rare circumstances \n             may establish a partial wireless link and detect this \n             situation. NB: A non-zero value on start-up, or a change \n             of value during operation, may generate an SNMP trap \n             and/or SMTP email alert')
installArmStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 10)).setObjects(("CAMBIUM-PTP650-MIB", "installArmState"))
if mibBuilder.loadTexts: installArmStateTrap.setStatus('current')
if mibBuilder.loadTexts: installArmStateTrap.setDescription('Indicates if the unit is being installed. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
unitOutOfCalibrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 11)).setObjects(("CAMBIUM-PTP650-MIB", "unitOutOfCalibration"))
if mibBuilder.loadTexts: unitOutOfCalibrationTrap.setStatus('current')
if mibBuilder.loadTexts: unitOutOfCalibrationTrap.setDescription('The unit is out of calibration')
auxPortPowerOverEthernetOutputStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 12)).setObjects(("CAMBIUM-PTP650-MIB", "auxPortPowerOverEthernetOutputStatus"))
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatusTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatusTrap.setDescription('Current status of the Power Over Ethernet (PoE) output \n             of the Aux port')
incompatibleRegulatoryBandsTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 14)).setObjects(("CAMBIUM-PTP650-MIB", "incompatibleRegulatoryBands"))
if mibBuilder.loadTexts: incompatibleRegulatoryBandsTrap.setStatus('current')
if mibBuilder.loadTexts: incompatibleRegulatoryBandsTrap.setDescription('The master and slave units have incompatible regulatory \n             bands. NB: Both units must have compatible license keys')
noWirelessChannelAvailableTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 15)).setObjects(("CAMBIUM-PTP650-MIB", "noWirelessChannelAvailable"))
if mibBuilder.loadTexts: noWirelessChannelAvailableTrap.setStatus('current')
if mibBuilder.loadTexts: noWirelessChannelAvailableTrap.setDescription('Spectrum Management was unable to locate a suitable \n             wireless channel to operate on')
wirelessLinkDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 16)).setObjects(("CAMBIUM-PTP650-MIB", "wirelessLinkDisabledWarning"))
if mibBuilder.loadTexts: wirelessLinkDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the wireless interface has \n             disabled wireless traffic')
auxPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 17)).setObjects(("CAMBIUM-PTP650-MIB", "auxPortConfigurationMismatch"))
if mibBuilder.loadTexts: auxPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
sFPErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 18)).setObjects(("CAMBIUM-PTP650-MIB", "sFPError"))
if mibBuilder.loadTexts: sFPErrorTrap.setStatus('current')
if mibBuilder.loadTexts: sFPErrorTrap.setDescription('If the SFP link is not OK, there are five possible \n             causes: Either a SFP has been installed but the license \n             key does not include SFP fiber support, a fiber link \n             could not be established even though no LOS was detected \n             (i.e. an optical carrier was detected, which could be due \n             to a broken TX fiber, or because the link is disabled at \n             the fiber link partner), a fiber link could not be \n             established and LOS is detected (i.e. no optical carrier \n             is detected), the installed SFP is not supported or the \n             installed SFP failed to initialize correctly. NB: a \n             change of status may generate an SNMP trap and/or SMTP \n             email alert')
sFPPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 19)).setObjects(("CAMBIUM-PTP650-MIB", "sFPPortStatus"))
if mibBuilder.loadTexts: sFPPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortStatusTrap.setDescription('Current status of the SFP Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
incompatibleMasterAndSlaveTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 20)).setObjects(("CAMBIUM-PTP650-MIB", "incompatibleMasterAndSlave"))
if mibBuilder.loadTexts: incompatibleMasterAndSlaveTrap.setStatus('current')
if mibBuilder.loadTexts: incompatibleMasterAndSlaveTrap.setDescription('A non-zero value indicates that the master and slave \n             ends of a link are different hardware products, or have \n             different software versions. NB: It is very unusual to \n             detect this, because incompatible units will normally \n             fail to establish a wireless link. However, some \n             combinations may establish a partial wireless link and \n             detect this situation. NB: A non-zero value may generate \n             an SNMP trap and/or SMTP email alert')
sNTPSyncTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 21)).setObjects(("CAMBIUM-PTP650-MIB", "sNTPSync"))
if mibBuilder.loadTexts: sNTPSyncTrap.setStatus('current')
if mibBuilder.loadTexts: sNTPSyncTrap.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP')
tDDSynchronizationAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 22)).setObjects(("CAMBIUM-PTP650-MIB", "tDDSynchronizationAlarm"))
if mibBuilder.loadTexts: tDDSynchronizationAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationAlarmTrap.setDescription('Not Synchronized indicates failure of the external \n             timing system for a period greater than the holdover \n             timer. TDD frame timing will have drifted, and this link \n             may cause interference with other links in a synchronized \n             network. Timing System Failure is an early warning, \n             indicating that 80% of the holdover period has expired.')
sFPPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 23)).setObjects(("CAMBIUM-PTP650-MIB", "sFPPortDisabledWarning"))
if mibBuilder.loadTexts: sFPPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 24)).setObjects(("CAMBIUM-PTP650-MIB", "sFPPortConfigurationMismatch"))
if mibBuilder.loadTexts: sFPPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
linkModeOptimizationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 25)).setObjects(("CAMBIUM-PTP650-MIB", "linkModeOptimizationMismatch"))
if mibBuilder.loadTexts: linkModeOptimizationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimizationMismatchTrap.setDescription('The remote node of this link has been configured with a \n             different link mode optimization')
tDMInterfaceStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 26)).setObjects(("CAMBIUM-PTP650-MIB", "tDMInterfaceStatus"))
if mibBuilder.loadTexts: tDMInterfaceStatusTrap.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceStatusTrap.setDescription("@Current status of the connection to the TDM Box. A \n             state of 'Up' on a green background indicates that the \n             TDM Box is connected OK. When connecting a TDM Box only \n             the Main Ethernet port should be used")
tDMChannelStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 27)).setObjects(("CAMBIUM-PTP650-MIB", "tDMChannelStatus"))
if mibBuilder.loadTexts: tDMChannelStatusTrap.setStatus('current')
if mibBuilder.loadTexts: tDMChannelStatusTrap.setDescription('Current status of the TDM channels. A value of 0 \n             indicates that a TDM channel is established')
tDMChannelLoopbackTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 28)).setObjects(("CAMBIUM-PTP650-MIB", "tDMChannelLoopback"))
if mibBuilder.loadTexts: tDMChannelLoopbackTrap.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLoopbackTrap.setDescription("The loopback status of TDM channels. This is intended \n             for installation testing and should be set to 'None' for \n             normal operation. The wire connections to a unit can be \n             tested by applying a 'Copper' loopback to the local unit. \n             The wireless connection to the remote unit can be tested \n             by applying a 'Wireless' loopback to the remote unit with \n             no loopback on the local unit. NB: a change of state may \n             generate an SNMP trap and/or SMTP email alert")
nIDULanPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 29)).setObjects(("CAMBIUM-PTP650-MIB", "nIDULanPortStatus"))
if mibBuilder.loadTexts: nIDULanPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortStatusTrap.setDescription('Current status of the NIDU LAN Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
syslogStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 30)).setObjects(("CAMBIUM-PTP650-MIB", "syslogState"))
if mibBuilder.loadTexts: syslogStateTrap.setStatus('current')
if mibBuilder.loadTexts: syslogStateTrap.setDescription('The syslog service has been enabled or disabled')
syslogLocalNearlyFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 31))
if mibBuilder.loadTexts: syslogLocalNearlyFullTrap.setStatus('current')
if mibBuilder.loadTexts: syslogLocalNearlyFullTrap.setDescription('The syslog local log is nearly full (90%)')
syslogLocalWrappedTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 32))
if mibBuilder.loadTexts: syslogLocalWrappedTrap.setStatus('current')
if mibBuilder.loadTexts: syslogLocalWrappedTrap.setDescription('The syslog local log has wrapped')
syslogClientTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 33)).setObjects(("CAMBIUM-PTP650-MIB", "syslogClient"))
if mibBuilder.loadTexts: syslogClientTrap.setStatus('current')
if mibBuilder.loadTexts: syslogClientTrap.setDescription('Enable or disable the syslog client')
secureModeAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 34)).setObjects(("CAMBIUM-PTP650-MIB", "secureModeAlarm"))
if mibBuilder.loadTexts: secureModeAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: secureModeAlarmTrap.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
dataBridgingStatusAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 35)).setObjects(("CAMBIUM-PTP650-MIB", "dataBridgingStatusAlarm"))
if mibBuilder.loadTexts: dataBridgingStatusAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusAlarmTrap.setDescription('Ethernet Data traffic bridging is disabled because the \n             wireless link is not operating at the configured Lowest \n             Data Modulation Mode')
licenseRemainingTrialPeriodAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 36)).setObjects(("CAMBIUM-PTP650-MIB", "licenseRemainingTrialPeriodAlarm"))
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarmTrap.setDescription('If the full capability trial license period is about to \n             expire then purchase a license upgrade from your \n             reseller.')
capacityVariantMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 37)).setObjects(("CAMBIUM-PTP650-MIB", "capacityVariantMismatch"))
if mibBuilder.loadTexts: capacityVariantMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: capacityVariantMismatchTrap.setDescription('The remote node of this link has a lower link capacity. \n             Operating with a reduced effective link capacity.')
maxLinkRangeExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 38)).setObjects(("CAMBIUM-PTP650-MIB", "maxLinkRangeExceeded"))
if mibBuilder.loadTexts: maxLinkRangeExceededTrap.setStatus('current')
if mibBuilder.loadTexts: maxLinkRangeExceededTrap.setDescription('The measured link range is greater than the maximum \n             allowed by the license key. The link will operate at a \n             reduced capacity while this condition applies. This alarm \n             is only raised if the license specifies a maximum link \n             range and the trial license is not active.')
tDMConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 39)).setObjects(("CAMBIUM-PTP650-MIB", "tDMConfigurationMismatch"))
if mibBuilder.loadTexts: tDMConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: tDMConfigurationMismatchTrap.setDescription("Current status of the configuration of the TDM Box. A \n             state of 'Ok' on a green background indicates that the \n             TDM Box configuration is matched OK with the remote end.")
nIDULanPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 40)).setObjects(("CAMBIUM-PTP650-MIB", "nIDULanPortDisabledWarning"))
if mibBuilder.loadTexts: nIDULanPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
nIDULanPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 41)).setObjects(("CAMBIUM-PTP650-MIB", "nIDULanPortConfigurationMismatch"))
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch.')
secondDataBridgingStatusAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 42)).setObjects(("CAMBIUM-PTP650-MIB", "secondDataBridgingStatusAlarm"))
if mibBuilder.loadTexts: secondDataBridgingStatusAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: secondDataBridgingStatusAlarmTrap.setDescription('Bridging of Ethernet traffic from Second Data Service \n             has been disabled because the wireless link is not \n             operating at the configured Lowest Second Data Modulation \n             Mode')
transparentClockSourcePortAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 43)).setObjects(("CAMBIUM-PTP650-MIB", "transparentClockSourcePortAlarm"))
if mibBuilder.loadTexts: transparentClockSourcePortAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: transparentClockSourcePortAlarmTrap.setDescription('Transparent Clock will not function properly because \n             SFP, the selected clock source port is not FIBER')
portAllocationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 7, 99, 0, 44)).setObjects(("CAMBIUM-PTP650-MIB", "portAllocationMismatch"))
if mibBuilder.loadTexts: portAllocationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: portAllocationMismatchTrap.setDescription('The local and remote ODUs have different services \n             configured.')
mibBuilder.exportSymbols("CAMBIUM-PTP650-MIB", nIDULanPortGigabitMasterSlaveStatus=nIDULanPortGigabitMasterSlaveStatus, alarmsGroup=alarmsGroup, iPv6GatewayAddress=iPv6GatewayAddress, transmitFreqMHz=transmitFreqMHz, nIDULanPortSpeedAndDuplex=nIDULanPortSpeedAndDuplex, sNMPEnabledTraps=sNMPEnabledTraps, mainPSUPortAutoNegotiation=mainPSUPortAutoNegotiation, receiveFreqKHz=receiveFreqKHz, sNMPSendAllTrapsAtStartup=sNMPSendAllTrapsAtStartup, sNTPServerTable=sNTPServerTable, syslogState=syslogState, ptpGroups=ptpGroups, tdmTableNumber=tdmTableNumber, useVLANForMABProtocol=useVLANForMABProtocol, licenseCountry=licenseCountry, sFPPortDisabledWarningTrap=sFPPortDisabledWarningTrap, auxPortAllocation=auxPortAllocation, wirelessLinkStatus=wirelessLinkStatus, nIDULanPortAutoMdix=nIDULanPortAutoMdix, tDMConfigurationMismatchTrap=tDMConfigurationMismatchTrap, userTable=userTable, transmitChannel=transmitChannel, nIDULanPortStatus=nIDULanPortStatus, cableDiagPair4Results=cableDiagPair4Results, phyControl=phyControl, userTableNumber=userTableNumber, dfs=dfs, sMTPEnabledMessages=sMTPEnabledMessages, ptpTrapPrefix=ptpTrapPrefix, rangingMode=rangingMode, linkModeOptimization=linkModeOptimization, sFPPortDisabledWarning=sFPPortDisabledWarning, licenseMaxNumberOfTDMChannels=licenseMaxNumberOfTDMChannels, sNMPPortNumber=sNMPPortNumber, tDMConfigurationMismatch=tDMConfigurationMismatch, tFTPServerPortNumber=tFTPServerPortNumber, tFTPStartSoftwareUpgrade=tFTPStartSoftwareUpgrade, nIDULanPortAutoNegAdvertisement=nIDULanPortAutoNegAdvertisement, sNTPSync=sNTPSync, wirelessLinkAvailability=wirelessLinkAvailability, dataPortWirelessDownAlert=dataPortWirelessDownAlert, cableDiagPair3Results=cableDiagPair3Results, aggregateDataRate=aggregateDataRate, portAllocationMismatchTrap=portAllocationMismatchTrap, tdmTableIndex=tdmTableIndex, sMTPServerInternetAddress=sMTPServerInternetAddress, auxPortStatus=auxPortStatus, secondDataBridgingStatusAlarm=secondDataBridgingStatusAlarm, auxPortAcceptedQLRx=auxPortAcceptedQLRx, reset=reset, userPassword=userPassword, mainPSUPortAllocation=mainPSUPortAllocation, mainPSUPortSSMTx=mainPSUPortSSMTx, wirelessLinkDisabledWarningTrap=wirelessLinkDisabledWarningTrap, aAAControl=aAAControl, installArmStateTrap=installArmStateTrap, cableDiagnosticsResultTableIndex=cableDiagnosticsResultTableIndex, telnetAccessEnabled=telnetAccessEnabled, tDMChannelStatus=tDMChannelStatus, siteName=siteName, ptp650=ptp650, mPLSTCPriorityTableEntry=mPLSTCPriorityTableEntry, userRole=userRole, routerProtocols=routerProtocols, mainPSUPortDisabledWarningTrap=mainPSUPortDisabledWarningTrap, iPDSCPPriorityTableEntry=iPDSCPPriorityTableEntry, versionsGroup=versionsGroup, unitOutOfCalibrationTrap=unitOutOfCalibrationTrap, tFTPSoftwareUpgradeFileName=tFTPSoftwareUpgradeFileName, licenseRemainingTrialPeriod=licenseRemainingTrialPeriod, installStatus=installStatus, ptpTraps=ptpTraps, secureModeAlarm=secureModeAlarm, sMTPServerPortNumber=sMTPServerPortNumber, licenseBandwidthCap=licenseBandwidthCap, sFPPortStatusTrap=sFPPortStatusTrap, sFPPortAutoNegAdvertisement=sFPPortAutoNegAdvertisement, tFTPServerInternetAddress=tFTPServerInternetAddress, systemReset=systemReset, dataPortPauseFrames=dataPortPauseFrames, rawReceivePower=rawReceivePower, auxPortSSMTx=auxPortSSMTx, dfsMeans=dfsMeans, sNMPTrapInternetAddress=sNMPTrapInternetAddress, sNTPServerTableIndex=sNTPServerTableIndex, auxPortDisabledWarning=auxPortDisabledWarning, mABHoldoffPeriod=mABHoldoffPeriod, mABCurrentTransmitCapacity=mABCurrentTransmitCapacity, routerProtocolsGroup=routerProtocolsGroup, dfsTable=dfsTable, mPLSTCPriorityTableIndex=mPLSTCPriorityTableIndex, sNTPServerRetries=sNTPServerRetries, mABProtocolVLANPriority=mABProtocolVLANPriority, mainPSUPortQLTx=mainPSUPortQLTx, nIDULanPortConfigurationMismatch=nIDULanPortConfigurationMismatch, licenseNumberOfRegulatoryBands=licenseNumberOfRegulatoryBands, targetRange=targetRange, tDDSynchronizationAlarmTrap=tDDSynchronizationAlarmTrap, sNTPServerTableEntry=sNTPServerTableEntry, sNTPServerPortNumber=sNTPServerPortNumber, syncETracking=syncETracking, masterSlaveMode=masterSlaveMode, licenseMinimumFirmwareVersion=licenseMinimumFirmwareVersion, hTTPSAccessEnabled=hTTPSAccessEnabled, sFPError=sFPError, sNTPLastSync=sNTPLastSync, receiveDataRate=receiveDataRate, nIDULanPortConfigurationMismatchTrap=nIDULanPortConfigurationMismatchTrap, supplementary=supplementary, syslogClient=syslogClient, syslogStateTrap=syslogStateTrap, enableTransmission=enableTransmission, dfsImpulsiveInterferenceTrap=dfsImpulsiveInterferenceTrap, licenseGroupAccess=licenseGroupAccess, licenseAuxiliaryPortSupport=licenseAuxiliaryPortSupport, auxPortConfigurationMismatchTrap=auxPortConfigurationMismatchTrap, auxPortSyncERxStatus=auxPortSyncERxStatus, syslogControl=syslogControl, auxPortDisabledWarningTrap=auxPortDisabledWarningTrap, mABState=mABState, licenseSecurityLevel=licenseSecurityLevel, tDDControl=tDDControl, maximumTransmitPower=maximumTransmitPower, ethernetGroup=ethernetGroup, unknownNetworkPriorityQueueMapping=unknownNetworkPriorityQueueMapping, sNTPSyncTrap=sNTPSyncTrap, oOBPriorityQueueMapping=oOBPriorityQueueMapping, cableDiagPair2Results=cableDiagPair2Results, signalStrengthRatio=signalStrengthRatio, linkModeOptimizationMismatch=linkModeOptimizationMismatch, daylightSaving=daylightSaving, capacityVariantMismatchTrap=capacityVariantMismatchTrap, receivePower=receivePower, timeZone=timeZone, bridgeGroup=bridgeGroup, licenseIPv6Support=licenseIPv6Support, mainPSUPortAutoMdix=mainPSUPortAutoMdix, secondDataPortPauseFrames=secondDataPortPauseFrames, maxLinkRangeExceededTrap=maxLinkRangeExceededTrap, encryptionGroup=encryptionGroup, productVariant=productVariant, maxLinkRangeExceeded=maxLinkRangeExceeded, tFTPSoftwareUpgradeStatusText=tFTPSoftwareUpgradeStatusText, licenseSFPPortSupport=licenseSFPPortSupport, secondDataBridgingStatus=secondDataBridgingStatus, nIDULanPortAutoNegotiation=nIDULanPortAutoNegotiation, l2CPPriorityTable=l2CPPriorityTable, sNMPTrapInternetAddressType=sNMPTrapInternetAddressType, tDDSynchronizationStatus=tDDSynchronizationStatus, incompatibleRegulatoryBands=incompatibleRegulatoryBands, mainPSUPortConfigurationMismatchTrap=mainPSUPortConfigurationMismatchTrap, dfsTableNumber=dfsTableNumber, mPLSTCPriorityQueueMapping=mPLSTCPriorityQueueMapping, secondDataBridgingStatusAlarmTrap=secondDataBridgingStatusAlarmTrap, auxPortPowerOverEthernetOutput=auxPortPowerOverEthernetOutput, iPVersion=iPVersion, licenseIssueNumber=licenseIssueNumber, l2CPPriorityTableNumber=l2CPPriorityTableNumber, syslogLocalNearlyFullTrap=syslogLocalNearlyFullTrap, nIDULanPortStatusTrap=nIDULanPortStatusTrap, tdmTable=tdmTable, l2CPPriorityTableIndex=l2CPPriorityTableIndex, cableDiagnostics=cableDiagnostics, remoteInternetAddress=remoteInternetAddress, cableDiagPair2Distance=cableDiagPair2Distance, transmitFreqKHz=transmitFreqKHz, ethernetPriorityQueueMapping=ethernetPriorityQueueMapping, altitude=altitude, licenseFullCapabilityTrialStatus=licenseFullCapabilityTrialStatus, nIDULanPortDisabledWarning=nIDULanPortDisabledWarning, channelChangeTrap=channelChangeTrap, sNTPServerStatus=sNTPServerStatus, cableDiagnosticsControl=cableDiagnosticsControl, tDDSynchronizationAlarm=tDDSynchronizationAlarm, cableDiagnosticsPorts=cableDiagnosticsPorts, l2CPPriorityQueueMapping=l2CPPriorityQueueMapping, regulatoryBand=regulatoryBand, secondarySoftwareVersion=secondarySoftwareVersion, encryptionAlgorithm=encryptionAlgorithm, cambium=cambium, txMABFrames=txMABFrames, portAllocationMismatch=portAllocationMismatch, ethernetPriorityTable=ethernetPriorityTable, auxPortPowerOverEthernetOutputStatusTrap=auxPortPowerOverEthernetOutputStatusTrap, subnetMask=subnetMask, cableDiagnosticsResultTableNumber=cableDiagnosticsResultTableNumber, iPDSCPPriorityQueueMapping=iPDSCPPriorityQueueMapping, mPLSTCPriorityTableNumber=mPLSTCPriorityTableNumber, enabledDiagnosticAlarms=enabledDiagnosticAlarms, groupID=groupID, licenseRegulatoryBandsTableIndex=licenseRegulatoryBandsTableIndex, dfsTableIndex=dfsTableIndex, managementPortWirelessDownAlert=managementPortWirelessDownAlert, sNMPTrapTable=sNMPTrapTable, sNTPServerInternetAddress=sNTPServerInternetAddress, sFPPortQLRx=sFPPortQLRx, remoteInternetAddressType=remoteInternetAddressType, secureModeAlarmTrap=secureModeAlarmTrap, transparentClockPort=transparentClockPort, sFPPortAutoMdix=sFPPortAutoMdix, managementGroup=managementGroup, sNTPPollInterval=sNTPPollInterval, sFPPortGigabitMasterSlaveStatus=sFPPortGigabitMasterSlaveStatus, mainPSUPortSyncERxStatus=mainPSUPortSyncERxStatus, lowestDataModulationMode=lowestDataModulationMode, mainPSUPortSyncEMasterSlaveStatus=mainPSUPortSyncEMasterSlaveStatus, nIDULanPortDisabledWarningTrap=nIDULanPortDisabledWarningTrap, sFPPortAllocation=sFPPortAllocation, sFPPortConfigurationMismatch=sFPPortConfigurationMismatch, userConfiguredMaxModulationMode=userConfiguredMaxModulationMode, microwaveAdaptiveBandwidth=microwaveAdaptiveBandwidth, snmpControlGroup=snmpControlGroup, cableDiagnosticsGroup=cableDiagnosticsGroup, syncETrackingState=syncETrackingState, ethernet=ethernet, sNTPServerTimeout=sNTPServerTimeout, cableDiagPair4Distance=cableDiagPair4Distance, versions=versions, auxPortGigabitMasterSlaveStatus=auxPortGigabitMasterSlaveStatus, sNMPTrapPortNumber=sNMPTrapPortNumber, linkLoss=linkLoss, targetMACAddress=targetMACAddress, incompatibleMasterAndSlaveTrap=incompatibleMasterAndSlaveTrap, smtp=smtp, sFPPortStatus=sFPPortStatus, noWirelessChannelAvailable=noWirelessChannelAvailable, softwareVersion=softwareVersion, tDMInterfaceControl=tDMInterfaceControl, cableDiagPair3Distance=cableDiagPair3Distance, auxPortSyncEMasterSlaveStatus=auxPortSyncEMasterSlaveStatus, userName=userName, licenseVersion=licenseVersion, sFPPortAutoNegotiation=sFPPortAutoNegotiation, frequencyVariant=frequencyVariant, hTTPSPortNumber=hTTPSPortNumber, transmitDataRate=transmitDataRate, dSCPManagementPriority=dSCPManagementPriority, transparentClock=transparentClock, installStatusTrap=installStatusTrap, sNTPServerTableNumber=sNTPServerTableNumber, sFPErrorTrap=sFPErrorTrap, tDMChannelStatusTrap=tDMChannelStatusTrap, useVLANForManagementInterfaces=useVLANForManagementInterfaces, eIRP=eIRP, longitude=longitude, gatewayIPAddress=gatewayIPAddress, mABMaintenanceLevel=mABMaintenanceLevel, capacityVariantMismatch=capacityVariantMismatch, alarms=alarms, supplementaryGroup=supplementaryGroup, pubStatsGroup=pubStatsGroup, vLANManagementVID=vLANManagementVID, sFPPortSpeedAndDuplex=sFPPortSpeedAndDuplex, transparentClockSourcePortAlarmTrap=transparentClockSourcePortAlarmTrap)
mibBuilder.exportSymbols("CAMBIUM-PTP650-MIB", pubStats=pubStats, management=management, qOSPriorityScheme=qOSPriorityScheme, phyStatus=phyStatus, transparentClockVLAN=transparentClockVLAN, sntp=sntp, unitOutOfCalibration=unitOutOfCalibration, syslogLocalWrappedTrap=syslogLocalWrappedTrap, sFPPortSyncEMasterSlaveStatus=sFPPortSyncEMasterSlaveStatus, cableDiagPair1Results=cableDiagPair1Results, linkModeOptimizationMismatchTrap=linkModeOptimizationMismatchTrap, cableLoss=cableLoss, tDMGroup=tDMGroup, wirelessLinkDisabledWarning=wirelessLinkDisabledWarning, txColorCode=txColorCode, transmitPower=transmitPower, mainPSUPortAutoNegAdvertisement=mainPSUPortAutoNegAdvertisement, iPDSCPPriorityTableIndex=iPDSCPPriorityTableIndex, accessMethod=accessMethod, sNMPv3Enable=sNMPv3Enable, sMTPEmailAlert=sMTPEmailAlert, dfsGroup=dfsGroup, bootVersion=bootVersion, sMTPServerInternetAddressType=sMTPServerInternetAddressType, antennaGain=antennaGain, receiveModulationMode=receiveModulationMode, mainPSUPortQLRx=mainPSUPortQLRx, sNMPTrapTableEntry=sNMPTrapTableEntry, receiveModulationModeDetail=receiveModulationModeDetail, latitude=latitude, localPacketFiltering=localPacketFiltering, transparentClockVID=transparentClockVID, channelBandwidth=channelBandwidth, dataBridgingStatus=dataBridgingStatus, sNMPTrapVersion=sNMPTrapVersion, tFTPServerInternetAddressType=tFTPServerInternetAddressType, mainPSUPortConfigurationMismatch=mainPSUPortConfigurationMismatch, sMTPSourceEmailAddress=sMTPSourceEmailAddress, vectorError=vectorError, sFPPortSyncERxStatus=sFPPortSyncERxStatus, subbandLowestFrequency=subbandLowestFrequency, licenseCapacity=licenseCapacity, auxPortSpeedAndDuplex=auxPortSpeedAndDuplex, rxColorCode=rxColorCode, licenseRegulatoryBandsList=licenseRegulatoryBandsList, dfsNineNinePointNinePercentiles=dfsNineNinePointNinePercentiles, sFPPortSSMTx=sFPPortSSMTx, licenseTrialPeriod=licenseTrialPeriod, syslogClientTrap=syslogClientTrap, cableDiagPair1Distance=cableDiagPair1Distance, licenseOOBManagementSupport=licenseOOBManagementSupport, noWirelessChannelAvailableTrap=noWirelessChannelAvailableTrap, mPLSTCPriorityTable=mPLSTCPriorityTable, cableDiagnosticsResultTable=cableDiagnosticsResultTable, auxPortStatusTrap=auxPortStatusTrap, auxPortConfigurationMismatch=auxPortConfigurationMismatch, sFPPortConfigurationMismatchTrap=sFPPortConfigurationMismatchTrap, ethernetPriorityTableNumber=ethernetPriorityTableNumber, auxPortPowerOverEthernetOutputStatus=auxPortPowerOverEthernetOutputStatus, sFPPortAcceptedQLRx=sFPPortAcceptedQLRx, extendedSpectrumScanning=extendedSpectrumScanning, sNMPTrapTableNumber=sNMPTrapTableNumber, tDMInterfaceStatus=tDMInterfaceStatus, userEnabled=userEnabled, cableDiagnosticsResultTableEntry=cableDiagnosticsResultTableEntry, iPv6PrefixLength=iPv6PrefixLength, incompatibleMasterAndSlave=incompatibleMasterAndSlave, iPDSCPPriorityTable=iPDSCPPriorityTable, configuration=configuration, remoteMaximumTransmitPower=remoteMaximumTransmitPower, tDM=tDM, sNTPPrimaryServer=sNTPPrimaryServer, sNMPTrapReceiverEnabled=sNMPTrapReceiverEnabled, mABTransmissionInterval=mABTransmissionInterval, transparentClockSourcePortAlarm=transparentClockSourcePortAlarm, ethernetPriorityTableIndex=ethernetPriorityTableIndex, mABNominalTransmitCapacity=mABNominalTransmitCapacity, hTTPPortNumber=hTTPPortNumber, sNMPCommunityString=sNMPCommunityString, tDMInterfaceStatusTrap=tDMInterfaceStatusTrap, userTableEntry=userTableEntry, vLANManagementPriority=vLANManagementPriority, licenseRemainingTrialPeriodAlarm=licenseRemainingTrialPeriodAlarm, sntpGroup=sntpGroup, mainPSUPortStatusTrap=mainPSUPortStatusTrap, PYSNMP_MODULE_ID=cambium, ptp=ptp, lowestTDMModulationMode=lowestTDMModulationMode, installArmState=installArmState, licenseEncryption=licenseEncryption, cableDiagnosticsResultsDateTime=cableDiagnosticsResultsDateTime, aAAControlGroup=aAAControlGroup, mABNominalModulationMode=mABNominalModulationMode, cableDiagnosticsWarning=cableDiagnosticsWarning, encryption=encryption, byteErrorRatio=byteErrorRatio, tDDControlGroup=tDDControlGroup, mainPSUPortGigabitMasterSlaveStatus=mainPSUPortGigabitMasterSlaveStatus, syncEEquipmentClock=syncEEquipmentClock, phyStatusGroup=phyStatusGroup, mainPSUPortQLRxOverwrite=mainPSUPortQLRxOverwrite, licenseSyncESupport=licenseSyncESupport, tFTPSoftwareUpgradeStatusAdditionalText=tFTPSoftwareUpgradeStatusAdditionalText, resetGroup=resetGroup, searchState=searchState, syslogControlGroup=syslogControlGroup, notificationsGroup=notificationsGroup, productName=productName, licenseIEEE1588Support=licenseIEEE1588Support, tDDSynchronizationMode=tDDSynchronizationMode, mainPSUPortSpeedAndDuplex=mainPSUPortSpeedAndDuplex, tDMChannelLineCode=tDMChannelLineCode, bridge=bridge, configurationGroup=configurationGroup, systemClock=systemClock, tFTPSoftwareUpgradeStatus=tFTPSoftwareUpgradeStatus, linkName=linkName, sMTPDestinationEmailAddress=sMTPDestinationEmailAddress, incompatibleRegulatoryBandsTrap=incompatibleRegulatoryBandsTrap, licenseUnitSerialNumber=licenseUnitSerialNumber, dataBridgingStatusAlarm=dataBridgingStatusAlarm, auxPortQLRx=auxPortQLRx, tdmTableEntry=tdmTableEntry, ptmp=ptmp, tDMEnabledChannels=tDMEnabledChannels, managementNetworkAccessEnabled=managementNetworkAccessEnabled, licenseRegulatoryBandsTableEntry=licenseRegulatoryBandsTableEntry, tDMChannelLoopbackTrap=tDMChannelLoopbackTrap, sNTPPrimaryServerDeadTime=sNTPPrimaryServerDeadTime, dfsPeaks=dfsPeaks, sFPPortQLTx=sFPPortQLTx, license=license, telnetPortNumber=telnetPortNumber, l2CPPriorityTableEntry=l2CPPriorityTableEntry, sNTPServerInternetAddressType=sNTPServerInternetAddressType, mainPSUPortAcceptedQLRx=mainPSUPortAcceptedQLRx, licenseTDDSyncSupport=licenseTDDSyncSupport, transmitModulationMode=transmitModulationMode, licenseRemainingTrialPeriodAlarmTrap=licenseRemainingTrialPeriodAlarmTrap, receiveFreqMHz=receiveFreqMHz, auxPortQLTx=auxPortQLTx, dataBridgingAvailability=dataBridgingAvailability, dataBridgingStatusAlarmTrap=dataBridgingStatusAlarmTrap, snmpControl=snmpControl, hardwareVersion=hardwareVersion, smtpGroup=smtpGroup, userTableIndex=userTableIndex, mABProtocolVID=mABProtocolVID, dfsTableEntry=dfsTableEntry, licenseRARSupport=licenseRARSupport, ethernetPriorityTableEntry=ethernetPriorityTableEntry, linkSymmetry=linkSymmetry, range=range, licenseMaxLinkRange=licenseMaxLinkRange, regulatoryBandTrap=regulatoryBandTrap, subbandHighestFrequency=subbandHighestFrequency, receiveChannel=receiveChannel, iPv6AutoConfiguredLinkLocalAddress=iPv6AutoConfiguredLinkLocalAddress, iPv6Address=iPv6Address, licenseRegulatoryBandsTable=licenseRegulatoryBandsTable, hTTPAccessEnabled=hTTPAccessEnabled, mainPSUPortStatus=mainPSUPortStatus, licenseGroup=licenseGroup, sNTPState=sNTPState, mainPSUPortDisabledWarning=mainPSUPortDisabledWarning, iPv4Address=iPv4Address, ptpCompliance=ptpCompliance, tDMChannelCableLength=tDMChannelCableLength, sNMPTrapTableIndex=sNMPTrapTableIndex, lowestSecondDataModulationMode=lowestSecondDataModulationMode, tDMChannelLoopback=tDMChannelLoopback, iPDSCPPriorityTableNumber=iPDSCPPriorityTableNumber, phyControlGroup=phyControlGroup)
