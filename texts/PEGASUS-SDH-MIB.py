#
# PySNMP MIB module PEGASUS-SDH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/pegasus/PEGASUS-SDH-MIB
# Produced by pysmi-1.1.8 at Thu Apr 27 10:32:26 2023
# On host fv-az842-726 platform Linux version 5.15.0-1036-azure by user runner
# Using Python version 3.10.11 (main, Apr  6 2023, 07:59:08) [GCC 11.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndex, ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "InterfaceIndexOrZero")
OperStateEnum, CommStateEnum, pegasusMibModule, AvailabilityStatusElem = mibBuilder.importSymbols("PEGASUS-MIB", "OperStateEnum", "CommStateEnum", "pegasusMibModule", "AvailabilityStatusElem")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, NotificationType, Bits, Gauge32, MibIdentifier, Unsigned32, iso, ModuleIdentity, Counter32, ObjectIdentity, Integer32, TimeTicks, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "NotificationType", "Bits", "Gauge32", "MibIdentifier", "Unsigned32", "iso", "ModuleIdentity", "Counter32", "ObjectIdentity", "Integer32", "TimeTicks", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
pegasusSdhMibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6368, 2, 8))
pegasusSdhMibModule.setRevisions(('2004-03-18 00:00', '2004-01-07 00:00', '2003-11-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pegasusSdhMibModule.setRevisionsDescriptions(('Improved Alarm signalisation. A new variable stm1CardAlarmStatus shows \n    the alarms that are active on the STM-1 card. Active Ethernet alarms are \n    shown by ethernetIfAlarmStatus. The following values for vcAlarmStatus \n    are can not occur (not used):\n        - vcgTxAddTimeout     - vcgDnuOk\n        - vcgTxAdd            - vcgRxAdd\n        - vcgTxRemove         - vcgRxRemove\n        - vcgTxDnu            - vcgRxFail', 'Actually, only GFP is supported as Ethernet Encapsulation. Therefore \n    the variable etherIfEncapsulation is now read-only.', 'Initial Revision.',))
if mibBuilder.loadTexts: pegasusSdhMibModule.setLastUpdated('200403180000Z')
if mibBuilder.loadTexts: pegasusSdhMibModule.setOrganization('Schmid Telecom, Zurich')
if mibBuilder.loadTexts: pegasusSdhMibModule.setContactInfo('Schmid Telecom AG\n     Binzstrasse 35, CH-8048 Zurich\n     Switzerland\n\n     Email: xdslsupport@schmid-telecom.ch')
if mibBuilder.loadTexts: pegasusSdhMibModule.setDescription('This MIB applies to the PEGASUS SDSL product manufactured by Schmid\n    Telecom Zurich. The MIB is modelled after the PEM management model, so\n    object hierarchy and individual variables agree with the PEM client. This \n    MIB represents an extension to the DS1-MIB and the SONET-MIB. These three\n    MIB files are used to manage the PEGASUS STM-1 card.\n\n    The PEGASUS-SDH-MIB contains five tables:\n    - stm1CardTable         one entry for each STM-1 card configured.\n    - stm1CardClockTable    one entry for each STM-1 card configured.\n    - ethernetIfTable       one entry for each Ethernet interface of a \n                              configured STM-1 card.\n    - vcTable               one entry for each Virtual Container (VC-3/4/12).\n    - tugConfigTable        one entry for each Tributary Unit Group (TUG-3).\n\n    Note\n    - The tables that represent extensions to the DS1-/SINET-MIB use the \n      ifIndex from IF-MIB (ifTable).')
class ClockSourceEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rxLineClock", 1), ("referenceClock", 2), ("freeRun", 3))

class ClockSyncStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("syncOk", 1), ("syncNotOk", 2))

class ClockModeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class ClockPriorityEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("primary", 1), ("secondary", 2))

class ClockQualityEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("prc", 1), ("ssu-a", 2), ("ssu-b", 3), ("sec", 4), ("dnu", 5), ("auto", 6), ("unknown", 7))

class ClockStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("invalid", 1), ("valid", 2))

class MultiplexingModeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("au3", 1), ("au4", 2))

class VirtualContainerTypeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("vc4", 1), ("vc3", 2), ("vc12", 3))

class LaserOperationModeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("off", 1), ("als", 2))

class LaserStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("on", 1), ("shutdown", 2), ("restart", 3))

class SdhInterfaceEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("optical", 1), ("e1", 2))

class PRBSPatternEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("pattern2exp15", 1), ("pattern2exp20", 2))

class TraceSizeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("size1byte", 1), ("size16byte", 2))

class SignalLabel(TextualConvention, Integer32):
    description = "Representation of a VC Signal Label. The meaning of the SignalLabel\n      depends on the type of vitual container. \n      VC-12s use the following values:\n      001b    Unequipped\n      001b    Equipped (non specific)\n      010b    Asynchronous\n      011b    Bit Synchronous\n      100b    Byte Synchronous\n      101b    Reserved for future use\n      110b    Test signal (O.181)\n      111b    VC-AIS\n\n      VC-4 and VC-3 use these values:\n      00h     Unequipped or supervisory-unequipped\n      01h     Equipped - non-specific\n      02h     TUG Structure\n      03h     Locked TU-n\n      04h     Asynch. mapping of 34'386/44'736 kbit/s into Container-3\n      12h     Asynch. mapping of 139'264 kbit/s into Container-4\n      13h     ATM Mapping\n      14h     MAN DQDB (IEEE 802.6 mapping\n      15h     FDDI (ISO 9314) mapping\n      16h     Mapping of HDLC/PPP framed signal\n      17h     Mapping of SDL with SDH self synch. Scrambler\n      18h     Mapping of HDLC/LAP-S framed signals\n      19h     Mapping of SDL with set-reset scrambler\n      1Ah     Mapping of 10 Gbit/s Ethernet frames (IEEE 802.3)\n      CFh     Obsolete mapping of HDLC/PPP framed signal\n      E1h-FCh Reserved for national use\n      FEh     Test signal, O.181 specific mapping\n      FFh     VC-AIS"
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(18, 26), ValueRangeConstraint(207, 207), ValueRangeConstraint(225, 252), ValueRangeConstraint(254, 255), )
class ConcatenationTypeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("lcas", 1), ("nonLCAS", 2))

class EthernetIfEncapsulationEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("disabled", 1), ("gfp", 2), ("lapf", 3), ("laps", 4), ("ppp", 5))

class OrderLevelEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("highOrder", 1), ("lowOrder", 2))

class STM1SlotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(2, 2)

class TUGIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 3)

class TUGIndexOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 3)

stm1CardTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1), )
if mibBuilder.loadTexts: stm1CardTable.setStatus('current')
if mibBuilder.loadTexts: stm1CardTable.setDescription('A table containing stm1 card specific information.')
stm1CardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1), ).setIndexNames((0, "PEGASUS-SDH-MIB", "stm1CardSlotNumber"))
if mibBuilder.loadTexts: stm1CardEntry.setStatus('current')
if mibBuilder.loadTexts: stm1CardEntry.setDescription('Row and index definition for stm1 card table.')
stm1CardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 1), STM1SlotNumber())
if mibBuilder.loadTexts: stm1CardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: stm1CardSlotNumber.setDescription('Slot number for stm1 card.')
stm1CardName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardName.setStatus('current')
if mibBuilder.loadTexts: stm1CardName.setDescription('Name of the PEGASUS device.')
stm1CardHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: stm1CardHardwareVersion.setDescription("Hardware version of the STM-1 card. This is also called CHM-number\n          (it always starts with the letters 'CHM'). The number '404' after\n          'CHM' identifies the card as a STM-1 card.")
stm1CardFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: stm1CardFirmwareVersion.setDescription("Version number and build date of the firmware running on the line \n          card. The format is 'major.minor YYYYMMDD hh:mm'.")
stm1CardManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardManufacturer.setStatus('current')
if mibBuilder.loadTexts: stm1CardManufacturer.setDescription('Manufacturer of the STM-1 card.')
stm1CardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: stm1CardSerialNumber.setDescription("Serial number of the line card. Also called HM-number, as it always \n          starts with 'HM'. Example: HMVSS014810294.")
stm1CardMultiplexingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 7), MultiplexingModeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardMultiplexingMode.setStatus('current')
if mibBuilder.loadTexts: stm1CardMultiplexingMode.setDescription('Selects the SDH multiplexing mode. Either it is STM1-AU3-VC3 or \n          STM1-AU4-VC4.')
stm1CardJ0TraceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 8), OperStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ0TraceMonitoring.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ0TraceMonitoring.setDescription('If trace monitoring is disable no alarm is propagated to PEM and \n          also no RDI/AIS is inserted.')
stm1CardJ1TraceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 9), OperStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ1TraceMonitoring.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ1TraceMonitoring.setDescription('If trace monitoring is disable no alarm is propagated to PEM and \n          also no RDI/AIS is inserted.')
stm1CardJ2TraceMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 10), OperStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ2TraceMonitoring.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ2TraceMonitoring.setDescription('If trace monitoring is disable no alarm is propagated to PEM and \n          also no RDI/AIS is inserted.')
stm1CardJ0PathTraceSize = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 11), TraceSizeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ0PathTraceSize.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ0PathTraceSize.setDescription('Size of the Regenerator Section Trace Message.')
stm1CardJ0PathTraceSend = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ0PathTraceSend.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ0PathTraceSend.setDescription('Configurable Regenerator Section (RS) Trace Message.')
stm1CardJ0PathTraceExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardJ0PathTraceExpected.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ0PathTraceExpected.setDescription('Regenerator Section (RS) Trace Message that should be received.')
stm1CardJ0PathTraceReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardJ0PathTraceReceive.setStatus('current')
if mibBuilder.loadTexts: stm1CardJ0PathTraceReceive.setDescription('Regenerator Section (RS) Trace Message that is be received.')
stm1CardLaserOperationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 15), LaserOperationModeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardLaserOperationMode.setStatus('current')
if mibBuilder.loadTexts: stm1CardLaserOperationMode.setDescription("Configuration of the 'Automatic Laser Shutdown' feature.")
stm1CardLaserState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 16), LaserStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardLaserState.setStatus('current')
if mibBuilder.loadTexts: stm1CardLaserState.setDescription('Actual state of the laser.')
stm1CardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 17), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardOperState.setStatus('current')
if mibBuilder.loadTexts: stm1CardOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
stm1CardAvailabilityState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 18), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardAvailabilityState.setStatus('current')
if mibBuilder.loadTexts: stm1CardAvailabilityState.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
stm1CardMgmtCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 19), CommStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardMgmtCommState.setStatus('current')
if mibBuilder.loadTexts: stm1CardMgmtCommState.setDescription("The Management Comm State indicates the state of the management\n          connection between the PEM Server and the STM-1 card.\n          disconnected            No connection has been established.\n          init                    A connection has freshly been established on\n                                  the underlying protocol, but no management\n                                  information has been transmitted so far.\n          identification          The connected device is being identified.\n          check hardware          The connected hardware is compared to the one\n                                  stored in the configuration.\n          hardware adaptation     If the configured and the existing device do\n                                  not match, an adoption is made. The behaviour\n                                  in this case can be configured with the 'HW\n                                  Adaptation Policy' option.\n          check program version   The program version of the connected hardware\n                                  is compared to the one stored in the\n                                  configuration.\n          check config version    The configuration version of the connected\n                                  hardware is compared to the one stored in the\n                                  configuration.\n          download config         If a configuration version mismatch has been\n                                  detected and the 'Config Priority' of 'PEGASUS\n                                  system' is set to 'Device', the configuration\n                                  is downloaded from the device to the PEM\n                                  Server.\n          upload config           If a configuration version mismatch has been\n                                  detected and the 'Config Priority' of 'PEGASUS\n                                  system' is set to 'Server', the configuration\n                                  is uploaded from the PEM Server to the device.\n          status synch            The values of the status properties are being\n                                  synchronised.\n          resetting               The device is resetting.\n          inactive                The device is connected, but it is inactive,\n                                  that is not operational. This may be due to a\n                                  hardware mismatch.\n          active                  The management connection between the device\n                                  and the PEM Server is fully established and\n                                  the device is active.")
stm1CardPRBSGeneratorSink = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 20), SdhInterfaceEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardPRBSGeneratorSink.setStatus('current')
if mibBuilder.loadTexts: stm1CardPRBSGeneratorSink.setDescription('Determines, whether the PRBS Generator should be used on the \n          optical or on the E1 links.')
stm1CardPRBSAnalyzerSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 21), SdhInterfaceEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardPRBSAnalyzerSource.setStatus('current')
if mibBuilder.loadTexts: stm1CardPRBSAnalyzerSource.setDescription('Determines, whether the PRBS Analyzer should be used on the \n          optical or on the E1 links.')
stm1CardPRBSPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 22), PRBSPatternEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardPRBSPattern.setStatus('current')
if mibBuilder.loadTexts: stm1CardPRBSPattern.setDescription('Determines the PRBS Pattern to be used.')
stm1CardAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: stm1CardAlarmStatus.setDescription("This variable indicates the status of STM-1 card, regenerator \n          section and multiplex section. It's a bitmap represented as a sum. \n          Therefore multiple alarms can be displayed simultaneously. The value \n          noAlarm is only set if there isn't any alarm active. \n          The various bit positions are:\n            1     No alarm present\n            -- STM-1 card --\n            2     Initialization failure\n            4     Firmware Version Mismatch\n            8     Maintenance\n            -- regenerator section RS --\n            16    Loss of Signal (LOS)\n            32    Loss of Frame (LOF)\n            64    Trace ID Mismatch (RS-TIM)\n            -- multiplex section MS --\n            128   Alarm Indication Signal (MS-AIS)\n            256   Remote Defect Indication (MS-RDI, former FERF)")
stm1CardClockTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2), )
if mibBuilder.loadTexts: stm1CardClockTable.setStatus('current')
if mibBuilder.loadTexts: stm1CardClockTable.setDescription('A table containing stm1 card specific clock information.')
stm1CardClockEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1), ).setIndexNames((0, "PEGASUS-SDH-MIB", "stm1CardSlotNumber"))
if mibBuilder.loadTexts: stm1CardClockEntry.setStatus('current')
if mibBuilder.loadTexts: stm1CardClockEntry.setDescription('Row and index definition for stm1 card clock table.')
stm1CardActiveClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 1), ClockSourceEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardActiveClockSource.setStatus('current')
if mibBuilder.loadTexts: stm1CardActiveClockSource.setDescription('Displays which clock sourceis active and used as sync source.')
stm1CardClockSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 2), ClockSyncStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardClockSyncState.setStatus('current')
if mibBuilder.loadTexts: stm1CardClockSyncState.setDescription('Sync status is OK if RX or Reference clock is valid and used as \n          active sync source.')
stm1CardTxLineClockQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 3), ClockQualityEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardTxLineClockQuality.setStatus('current')
if mibBuilder.loadTexts: stm1CardTxLineClockQuality.setDescription('This is the clock quality of the outgoing SDH signal. The default \n          sets the outgoing quality to the incoming quality. Sometime it may \n          be useful to set a fix outgoing quality.')
stm1CardRxClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 4), ClockModeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardRxClockMode.setStatus('current')
if mibBuilder.loadTexts: stm1CardRxClockMode.setDescription('If enabled the RX line clock can be used as sync source.')
stm1CardRxClockPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 5), ClockPriorityEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardRxClockPriority.setStatus('current')
if mibBuilder.loadTexts: stm1CardRxClockPriority.setDescription('This value has always the opposite value of Reference Clock \n          Priority.')
stm1CardRxClockQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 6), ClockQualityEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardRxClockQuality.setStatus('current')
if mibBuilder.loadTexts: stm1CardRxClockQuality.setDescription('This is the clock quality of the incoming SDH signal.')
stm1CardRxClockState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 7), ClockStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardRxClockState.setStatus('current')
if mibBuilder.loadTexts: stm1CardRxClockState.setDescription('Clock status is valid if a good clock can be found on input \n          (clock checker).')
stm1CardReferenceClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 8), ClockModeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardReferenceClockMode.setStatus('current')
if mibBuilder.loadTexts: stm1CardReferenceClockMode.setDescription('If enabled the Reference clock (V5 card input) can be used as sync \n          source.')
stm1CardReferenceClockPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 9), ClockPriorityEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardReferenceClockPriority.setStatus('current')
if mibBuilder.loadTexts: stm1CardReferenceClockPriority.setDescription('This value has always the opposite value of Rx Clock Priority.')
stm1CardReferenceClockQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 10), ClockQualityEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stm1CardReferenceClockQuality.setStatus('current')
if mibBuilder.loadTexts: stm1CardReferenceClockQuality.setDescription('Defines the quality of the reference clock input. This value will \n          be transmitted in SDH-TX if reference clock is used as active sync \n          source.')
stm1CardReferenceClockState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 2, 1, 11), ClockStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stm1CardReferenceClockState.setStatus('current')
if mibBuilder.loadTexts: stm1CardReferenceClockState.setDescription('Clock status is valid if a good clock can be found on input \n          (clock checker).')
ethernetIfTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3), )
if mibBuilder.loadTexts: ethernetIfTable.setStatus('current')
if mibBuilder.loadTexts: ethernetIfTable.setDescription('This table contains additional information concerning the ethernet \n          interfaces of a STM-1 card. It represents an extension of the \n          if(X)Table (see IF-MIB).')
ethernetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ethernetIfEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetIfEntry.setDescription('Row and index definition for the ethernetIfTable.')
etherIfConcatenationOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3, 1, 1), ConcatenationTypeEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: etherIfConcatenationOption.setStatus('current')
if mibBuilder.loadTexts: etherIfConcatenationOption.setDescription('Configuration of the Link Capacity Adjustment Scheme.')
etherIfEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3, 1, 2), EthernetIfEncapsulationEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherIfEncapsulation.setStatus('current')
if mibBuilder.loadTexts: etherIfEncapsulation.setDescription('This attribute shows the used Ethernet encapsulation protocol.')
etherIfOrderLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3, 1, 3), OrderLevelEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherIfOrderLevel.setStatus('current')
if mibBuilder.loadTexts: etherIfOrderLevel.setDescription('Only relevant, if SDH Multiplexing Mode (see STM-1 card propertied) \n          is set to VC3.')
etherIfAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: etherIfAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: etherIfAlarmStatus.setDescription("This variable indicates the status of an Ethernet Interface. It's \n          a bitmap represented as a sum. Therefore multiple defects can be \n          displayed simultaneously. The value noAlarm is only set if there \n          isn't any alarm. \n          The various bit positions are (LO = LowOrder, HO = HighOrder):\n            1   No alarm\n            2   LO LCAS group identifier mismatch (Rx)\n            4   HO LCAS group identifier mismatch (Rx)\n            8   LO VCG exceeds max. differential delay (Rx)\n            16  HO VCG exceeds max. differential delay (Rx)\n            32  LO VCG exceeds max. differential delay, calculated over all \n                containers (Rx)\n            64  HO VCG exceeds max. differential delay, calculated over all \n                containers (Rx)\n            128 Transmit FIFO overflow (Tx)\n            256 Rx head-of-line blocking FIFO overflow")
vcTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4), )
if mibBuilder.loadTexts: vcTable.setStatus('current')
if mibBuilder.loadTexts: vcTable.setDescription("This table contains additional information for VC concerning the \n          multiplexing configuration. It's an extension of the ifTable \n          (IF-MIB) and the tables of the SONET/SDH-MIB.\n          ")
vcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: vcEntry.setStatus('current')
if mibBuilder.loadTexts: vcEntry.setDescription('Row and index definition for the vcConfigTable.')
vcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 1), VirtualContainerTypeEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcType.setStatus('current')
if mibBuilder.loadTexts: vcType.setDescription('Type of Virtual Container (VC). In Pegasus VC-4, VC-3 or VC-12.')
vcRelatedTUG = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 2), TUGIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcRelatedTUG.setStatus('current')
if mibBuilder.loadTexts: vcRelatedTUG.setDescription("Represents the index of the Tributary Unit Group within the \n          tugConfigTable to which this VC is assigned to. The value depends \n          also on the multiplexing mode. If the value is 0, there doesn't \n          exist the relation VC-x to TUG-3. Possible values:\n          1) multiplexing mode = AU-4:\n              VC-4:    vcRelatedTUG = 0\n              VC-3/12: vcRelatedTUG = 1..3\n          2) multiplexing mode = AU-3:\n              vcRelatedTUG = 0 (no dependency on VC type)")
vcRelatedVC = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcRelatedVC.setStatus('current')
if mibBuilder.loadTexts: vcRelatedVC.setDescription("Represents the index of the Virtual Container within the \n          ifTable to which this VC is assigned to. The value depends \n          also on the multiplexing mode. If the value is 0, there doesn't \n          exist the relation VC-x to VC-x. Possible values:\n          1) multiplexing mode = AU-4:\n              vcRelatedVC = 0 (no dependency on VC type)\n          2) multiplexing mode = AU-3:\n              VC-3:   vcRelatedVC = 0\n              VC-12:  vcRelatedVC = 2031..2033 (example for slot 2)")
vcAssignedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcAssignedIfIndex.setStatus('current')
if mibBuilder.loadTexts: vcAssignedIfIndex.setDescription('Represents the index of the interface within the ifTable (IF-MIB) \n          that transmits to this VC.')
vcPathTraceSend = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcPathTraceSend.setStatus('current')
if mibBuilder.loadTexts: vcPathTraceSend.setDescription('The value of the outgoing J1 Byte VC Path Trace byte message.')
vcPathTraceExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcPathTraceExpected.setStatus('current')
if mibBuilder.loadTexts: vcPathTraceExpected.setDescription('The value of the expected J1 Byte VC Path Trace byte message.')
vcPathTraceReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcPathTraceReceive.setStatus('current')
if mibBuilder.loadTexts: vcPathTraceReceive.setDescription('The value of the incoming J1 Byte VC Path Trace byte message.')
vcSignalLabelSend = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 8), SignalLabel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcSignalLabelSend.setStatus('current')
if mibBuilder.loadTexts: vcSignalLabelSend.setDescription('The outgoing C2 VC Signal Label (0x02 = TUG structure).')
vcSignalLabelExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 9), SignalLabel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vcSignalLabelExpected.setStatus('current')
if mibBuilder.loadTexts: vcSignalLabelExpected.setDescription('The expected C2 VC Signal Label (0x02 = TUG structure).')
vcSignalLabelReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 10), SignalLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcSignalLabelReceive.setStatus('current')
if mibBuilder.loadTexts: vcSignalLabelReceive.setDescription('The incoming C2 VC Signal Label (0x02 = TUG structure).')
vcAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 524287))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vcAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: vcAlarmStatus.setDescription("This variable indicates the status of the VC. It's a bitmap \n           represented as a sum. Therefore multiple defects can be displayed \n           simultaneously. The value noDefect should only be set if there is \n           no other defect. Some alarms can't occur actually.\n           The various bit positions are:\n            1       vcNoDefect\n            2       vcAlarmAIS\n            4       vcAlarmLOP\n            8       vcAlarmRDI\n            16      vcAlarmUnequipped\n            32      vcAlarmPLM\n            64      vcAlarmTIM\n            128     vcAlarmLOM\n            256     vcAlarmRFI\n            512     vcgTxAddTimeout     -- not used (deprecated)\n            1024    vcgTxAdd            -- not used (deprecated)\n            2048    vcgTxRemove         -- not used (deprecated)\n            4096    vcgTxDnu            -- not used (deprecated)\n            8192    vcgDnuOk            -- not used (deprecated)\n            16384   vcgRxAdd            -- not used (deprecated)\n            32768   vcgRxRemove         -- not used (deprecated)\n            65536   vcgRxFail           -- not used (deprecated)\n            131072  vcgLcasCrcError\n            262144  vcgNonLcasSeqError")
tugConfigTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 8, 5), )
if mibBuilder.loadTexts: tugConfigTable.setStatus('current')
if mibBuilder.loadTexts: tugConfigTable.setDescription('This table contains information concerning Tributary Unit Groups. \n          If AU-3 structure is used, this table is empty.')
tugConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 8, 5, 1), ).setIndexNames((0, "PEGASUS-SDH-MIB", "tugIndex"))
if mibBuilder.loadTexts: tugConfigEntry.setStatus('current')
if mibBuilder.loadTexts: tugConfigEntry.setDescription('Row and index definition for the tugConfigTable.')
tugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 5, 1, 1), TUGIndex())
if mibBuilder.loadTexts: tugIndex.setStatus('current')
if mibBuilder.loadTexts: tugIndex.setDescription('Number of the TUG. Range 1..3')
tugRelatedVC4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 5, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tugRelatedVC4.setStatus('current')
if mibBuilder.loadTexts: tugRelatedVC4.setDescription('')
tugOrderLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 8, 5, 1, 3), OrderLevelEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tugOrderLevel.setStatus('current')
if mibBuilder.loadTexts: tugOrderLevel.setDescription('Individual Order Level of this TUG. If high order is used, the TUG \n          has exactly one VC-3 and no VC-12s. If low order is used, the TUG \n          has exactly 21 VC-12 and no VC-3.')
sdhMibRevision = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 8, 6), DisplayString().clone('$Workfile: PEGASUS-SDH-MIB.txt $ $Revision: 14 $ $Date: 3/18/04 6:40p $')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sdhMibRevision.setStatus('current')
if mibBuilder.loadTexts: sdhMibRevision.setDescription('The version number assigned by the version control system. You can query\n      this from the agent, to find out with which version of the MIB was built\n      into the agent. The value is also present in copies of the MIB to feed\n      into SNMP managers. Comparing the version numbers from both sources can\n      help to detect mismatches. The revision string for this version is:\n      $Workfile: PEGASUS-SDH-MIB.txt $ $Revision: 14 $ $Date: 3/18/04 6:40p $')
mibBuilder.exportSymbols("PEGASUS-SDH-MIB", ethernetIfTable=ethernetIfTable, stm1CardEntry=stm1CardEntry, TUGIndex=TUGIndex, TraceSizeEnum=TraceSizeEnum, tugOrderLevel=tugOrderLevel, stm1CardRxClockPriority=stm1CardRxClockPriority, TUGIndexOrZero=TUGIndexOrZero, stm1CardSerialNumber=stm1CardSerialNumber, vcSignalLabelReceive=vcSignalLabelReceive, stm1CardJ0PathTraceExpected=stm1CardJ0PathTraceExpected, vcTable=vcTable, stm1CardLaserOperationMode=stm1CardLaserOperationMode, PYSNMP_MODULE_ID=pegasusSdhMibModule, stm1CardAvailabilityState=stm1CardAvailabilityState, stm1CardReferenceClockState=stm1CardReferenceClockState, stm1CardRxClockQuality=stm1CardRxClockQuality, PRBSPatternEnum=PRBSPatternEnum, tugConfigTable=tugConfigTable, ClockSyncStateEnum=ClockSyncStateEnum, stm1CardClockSyncState=stm1CardClockSyncState, vcEntry=vcEntry, SignalLabel=SignalLabel, pegasusSdhMibModule=pegasusSdhMibModule, stm1CardJ0TraceMonitoring=stm1CardJ0TraceMonitoring, stm1CardClockTable=stm1CardClockTable, vcRelatedTUG=vcRelatedTUG, LaserOperationModeEnum=LaserOperationModeEnum, stm1CardClockEntry=stm1CardClockEntry, tugRelatedVC4=tugRelatedVC4, ConcatenationTypeEnum=ConcatenationTypeEnum, vcAssignedIfIndex=vcAssignedIfIndex, vcSignalLabelExpected=vcSignalLabelExpected, vcPathTraceReceive=vcPathTraceReceive, vcAlarmStatus=vcAlarmStatus, VirtualContainerTypeEnum=VirtualContainerTypeEnum, ClockSourceEnum=ClockSourceEnum, etherIfAlarmStatus=etherIfAlarmStatus, ClockModeEnum=ClockModeEnum, ClockStateEnum=ClockStateEnum, stm1CardReferenceClockPriority=stm1CardReferenceClockPriority, stm1CardRxClockState=stm1CardRxClockState, EthernetIfEncapsulationEnum=EthernetIfEncapsulationEnum, stm1CardTable=stm1CardTable, stm1CardMultiplexingMode=stm1CardMultiplexingMode, STM1SlotNumber=STM1SlotNumber, stm1CardJ0PathTraceReceive=stm1CardJ0PathTraceReceive, stm1CardFirmwareVersion=stm1CardFirmwareVersion, sdhMibRevision=sdhMibRevision, stm1CardName=stm1CardName, vcPathTraceExpected=vcPathTraceExpected, stm1CardManufacturer=stm1CardManufacturer, etherIfOrderLevel=etherIfOrderLevel, vcPathTraceSend=vcPathTraceSend, stm1CardSlotNumber=stm1CardSlotNumber, etherIfConcatenationOption=etherIfConcatenationOption, vcRelatedVC=vcRelatedVC, etherIfEncapsulation=etherIfEncapsulation, stm1CardOperState=stm1CardOperState, stm1CardActiveClockSource=stm1CardActiveClockSource, stm1CardPRBSPattern=stm1CardPRBSPattern, stm1CardPRBSGeneratorSink=stm1CardPRBSGeneratorSink, vcSignalLabelSend=vcSignalLabelSend, stm1CardReferenceClockQuality=stm1CardReferenceClockQuality, stm1CardReferenceClockMode=stm1CardReferenceClockMode, stm1CardLaserState=stm1CardLaserState, ethernetIfEntry=ethernetIfEntry, MultiplexingModeEnum=MultiplexingModeEnum, stm1CardRxClockMode=stm1CardRxClockMode, ClockQualityEnum=ClockQualityEnum, stm1CardHardwareVersion=stm1CardHardwareVersion, SdhInterfaceEnum=SdhInterfaceEnum, stm1CardAlarmStatus=stm1CardAlarmStatus, stm1CardJ0PathTraceSend=stm1CardJ0PathTraceSend, ClockPriorityEnum=ClockPriorityEnum, stm1CardJ2TraceMonitoring=stm1CardJ2TraceMonitoring, stm1CardPRBSAnalyzerSource=stm1CardPRBSAnalyzerSource, LaserStateEnum=LaserStateEnum, stm1CardTxLineClockQuality=stm1CardTxLineClockQuality, stm1CardMgmtCommState=stm1CardMgmtCommState, tugConfigEntry=tugConfigEntry, vcType=vcType, stm1CardJ0PathTraceSize=stm1CardJ0PathTraceSize, stm1CardJ1TraceMonitoring=stm1CardJ1TraceMonitoring, tugIndex=tugIndex, OrderLevelEnum=OrderLevelEnum)
