#
# PySNMP MIB module RAD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/packetlight/RAD-MIB
# Produced by pysmi-1.1.12 at Thu May 30 02:20:01 2024
# On host fv-az775-912 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
IANAifType, = mibBuilder.importSymbols("IANAifType-MIB", "IANAifType")
ifIndex, ifAlias = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifAlias")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
PerfIntervalCount, PerfTotalCount, PerfCurrentCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfIntervalCount", "PerfTotalCount", "PerfCurrentCount")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, IpAddress, NotificationType, Integer32, Bits, Unsigned32, Counter64, Gauge32, ModuleIdentity, enterprises, ObjectIdentity, TimeTicks, MibIdentifier, iso, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "IpAddress", "NotificationType", "Integer32", "Bits", "Unsigned32", "Counter64", "Gauge32", "ModuleIdentity", "enterprises", "ObjectIdentity", "TimeTicks", "MibIdentifier", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
RowPointer, TimeStamp, TruthValue, TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "TruthValue", "TextualConvention", "DisplayString", "RowStatus")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

rad = MibIdentifier((1, 3, 6, 1, 4, 1, 164))
radGen = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6))
systems = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 1))
agnt = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2))
agnHwVersion = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnHwVersion.setStatus('current')
if mibBuilder.loadTexts: agnHwVersion.setDescription("ASCII string for description and display of the agent hardware version,\n      as it is known by the agent software.The user can update the version\n       upon request when he changes   components in the agent's module  ")
agnTrapMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTrapMask.setStatus('current')
if mibBuilder.loadTexts: agnTrapMask.setDescription("The value of this attribute determines the type of traps the \n       agent should mask and not send to the management console. The \n       value is differently determined for different products. There are \n       mainly two methods:\n       - an integer number, specifying the traps' severity.\n       - a sum of 2**n, where n is a bit assigned to a certain \n         masked trap group.\n       User should consult the product specification, to find out \n       the method employed.")
agnTrapValue = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(100, 100)).setFixedLength(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTrapValue.setStatus('deprecated')
if mibBuilder.loadTexts: agnTrapValue.setDescription('The value of the trap decoded in internal RAD format. Full description is given\n\t  in the Trap definition file')
agnChangeCnt = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnChangeCnt.setStatus('current')
if mibBuilder.loadTexts: agnChangeCnt.setDescription('The number of changes in system configuration that were  reported to the \n\tmanager since last cold start')
agnSpecific = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnSpecific.setStatus('current')
if mibBuilder.loadTexts: agnSpecific.setDescription(' Object identifier of entity containing additional information \n      regarding this instance.')
agnConfigMsg = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnConfigMsg.setStatus('current')
if mibBuilder.loadTexts: agnConfigMsg.setDescription("Full configuration message  coded in internal RAD application format.\n       This entry describes agent's configuration.\n\n       For MP-2200 R3, this object describes agent's support of the V5.1\n       feature: 1 octet ; bit 0 (LSB). \n       '1' - V5.1 feature is supported\n       '0' - V5.1 feature is not supported.")
mngTrapIpTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 7), )
if mibBuilder.loadTexts: mngTrapIpTable.setStatus('current')
if mibBuilder.loadTexts: mngTrapIpTable.setDescription('This table indicates  the destination address of the traps.\n\t  Internally it will be limited to ten addresses. ')
mngEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1), ).setIndexNames((0, "RAD-MIB", "mngID"))
if mibBuilder.loadTexts: mngEntry.setStatus('current')
if mibBuilder.loadTexts: mngEntry.setDescription('An entry in table.')
mngID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mngID.setStatus('current')
if mibBuilder.loadTexts: mngID.setDescription(' This value indicates an index of a specific IP address')
mngIP = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIP.setStatus('current')
if mibBuilder.loadTexts: mngIP.setDescription('This value indicates  the  destination address of the traps. IP 0.0.0.0 removes the entry. ')
mngIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngIPMask.setStatus('deprecated')
if mibBuilder.loadTexts: mngIPMask.setDescription('This value indicates  the  mask of the destination addresses of the traps. ')
mngTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngTrapMask.setStatus('current')
if mibBuilder.loadTexts: mngTrapMask.setDescription("The value of this attribute determines the type of traps the \n       agent should mask and not send to this NMS. The \n       value is differently determined for different products. There are \n       mainly two methods:\n       - an integer number, specifying the traps' severity.\n       - a sum of 2**n, where n is a bit assigned to a certain \n         masked trap group.\n       User should consult the product specification, to find out \n       the method employed.")
mngAlarmTrapMask = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngAlarmTrapMask.setStatus('current')
if mibBuilder.loadTexts: mngAlarmTrapMask.setDescription('The value of this object determines the alarm traps that the \n      agent should mask (not send to this manager).\n      The value is an Octet String, where each bit \n      is assigned to a certain trap.\n        If the bit = 1, the trap will be masked.\n        If the bit = 0, the trap will not be masked.\n      For more details on the specific alarm traps masked, \n      see product specification.')
mngSnmpTrapUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 7, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mngSnmpTrapUdpPort.setStatus('current')
if mibBuilder.loadTexts: mngSnmpTrapUdpPort.setDescription('This variable enables to set the UDP port (socket) used for SNMP traps.')
agnIndication = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("faulty", 1), ("warning", 2), ("normal", 3), ("minor", 4), ("major", 5), ("event", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnIndication.setStatus('current')
if mibBuilder.loadTexts: agnIndication.setDescription('Attribute describing the state of the entity the agent is responsible for.\n       In case of a modular entity, the value of this attribute will be according\n       to the component which is in the worst state.\n       The order of severity (from top to bottom) is:\n       critical-> major (or faulty)-> minor-> event-> warning-> normal (off).')
agnMonitorModeCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnMonitorModeCmd.setStatus('current')
if mibBuilder.loadTexts: agnMonitorModeCmd.setDescription('Setting this attribute to ON, will enforce the agent to change its mode of operation to\n\t Monitor Mode')
agnLed = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnLed.setStatus('current')
if mibBuilder.loadTexts: agnLed.setDescription('This entry specifies  the LEDs status of the agent module . Each led will be represented by 4 \n\t bits  where the first 2 bits (left) will specify  the status :\n\t (00=NA, 01=OFF, 10=ON, 11=BLINK),\n     and the next two bits (right) will specify the color :\n     (00=GREEN, 01=RED, 10=YELLOW, 11=GRAY)')
trapTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 11), )
if mibBuilder.loadTexts: trapTable.setStatus('current')
if mibBuilder.loadTexts: trapTable.setDescription('This table includes the last few traps generated by the agent, for future retrieval. The table\n\t has a limited capacity. If traps are not retrieved in proper time, they will be\n\t over-written by new traps ')
trapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1), ).setIndexNames((0, "RAD-MIB", "trapID"))
if mibBuilder.loadTexts: trapEntry.setStatus('current')
if mibBuilder.loadTexts: trapEntry.setDescription('An entry in table.')
trapID = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapID.setStatus('current')
if mibBuilder.loadTexts: trapID.setDescription(' This value indicates an index of a specific trap ')
trapVal = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapVal.setStatus('current')
if mibBuilder.loadTexts: trapVal.setDescription('This value is the actual ASCII description  of the trap. ')
trapTimeSinceOccurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 11, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setStatus('current')
if mibBuilder.loadTexts: trapTimeSinceOccurrence.setDescription('This value indicates the amount of  time passed since the occurrence of the event that\n\t   trigger this trap. ')
fileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 12))
fileServerIP = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileServerIP.setStatus('current')
if mibBuilder.loadTexts: fileServerIP.setDescription('The IP address of the server from which the file is loaded ')
fileName = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileName.setStatus('current')
if mibBuilder.loadTexts: fileName.setDescription('The name of the file to be loaded. For protection, read returns\n\t NULL. ')
fileTransCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 255))).clone(namedValues=NamedValues(("swDwnLoad", 1), ("configDwnLoad", 2), ("configUpLoad", 3), ("coProcDwnLoad", 4), ("stateUpLoad", 5), ("dwnLoadUserFile", 6), ("upLoadUserFile", 7), ("swDwnLoadAndReset", 8), ("swUpLoad", 9), ("swDwnLoad2BkupStorage", 10), ("bootDwnLoad", 11), ("bootUpLoad", 12), ("swUpLoadFromBkupStorage", 13), ("licenseDwnLoad", 14), ("configDwnLoadToDefaultFile", 15), ("noOp", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransCmd.setStatus('current')
if mibBuilder.loadTexts: fileTransCmd.setDescription('The command to be executed on fileName at fileServerIP.')
tftpRetryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpRetryTimeOut.setStatus('current')
if mibBuilder.loadTexts: tftpRetryTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
tftpTotalTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpTotalTimeOut.setStatus('current')
if mibBuilder.loadTexts: tftpTotalTimeOut.setDescription(' Total Retransmission time-out value (seconds) ')
tftpStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noOp", 2), ("connecting", 3), ("transferringData", 4), ("endedTimeOut", 5), ("endedOk", 6), ("error", 7))).clone('noOp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpStatus.setStatus('current')
if mibBuilder.loadTexts: tftpStatus.setDescription("Status of tftp session. When a session ended with success,\n    the tftpStatus should be endedOk(6). Before restarting a\n    tftp session, the NMS should set the tftpStatus to noOp(2).\n    That's the reason of MAX-ACCESS read-write to this field.")
tftpError = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpError.setStatus('current')
if mibBuilder.loadTexts: tftpError.setDescription(' The MSB represents the standard error code.\n    The LSB represents the private error code.\n    0x0000 is No Error\n    0x0100 is File Not Found\n\t0x0200 is Access violation\n\t0x0300 is Disk full or allocation exceeded\n    0x0400 is Illegal TFTP operation\n    0x0500 is Unknown transfer ID\n\t0x0600 is File already exists\n\t0x0700 is No such user\n    0x0001 is Server Overflow\n    0x0002 is No empty UDP port\n    0x0003 is No empty connection\n    0x0004 is Illegal File Mode\n    0x0007 is Illegal PDU size\n\t0x0008 is TFTP Server does not exist \n\t0x0009 is Incorrect File\n\t0x000A is Wrong License format\n\t0x000B is License ID already used ')
fileTransferToSubSystems = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferToSubSystems.setStatus('current')
if mibBuilder.loadTexts: fileTransferToSubSystems.setDescription(" This object represents the sub-systems the fileTransCmd \n      refers to. It should be used when a system is divided \n      to sub-systems and each sub-system (or part of them) can \n\t  have a different SW/Configuration.\n\n\t  Each bit of this object will represent one of the sub-systems.\n\t  Bit='1' - APPLY to respective sub-system\n\t  Bit='0' - DO NOT APPLY to respective sub-system\n\n\t  For the meaning of each bit, see product's specification.\n\t  User will select the sub-systems envolved by filling-in the bits\n      that represent these sub-systems.\n      In this case, the file represented by 'fileName' will \n\t  include several parts, each representing one of the sub-systems.\n\t  The agent will refer only to the part/s indicated by this object.\n\n      0 Octet Strings = not applicable  \n      DEFVAL = 0h\tfor  the products that support this object.")
fileNameWithinProduct = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileNameWithinProduct.setStatus('current')
if mibBuilder.loadTexts: fileNameWithinProduct.setDescription('The file name used by the product within the product file system.')
intSwdlTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10), )
if mibBuilder.loadTexts: intSwdlTable.setStatus('current')
if mibBuilder.loadTexts: intSwdlTable.setDescription('This parameters table is for \n       internal Software down load. It also includes data \n       about all files contained in the Object from which \n       down-load is performed.')
intSwdlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1), ).setIndexNames((0, "RAD-MIB", "intSwdlObjIdx"), (0, "RAD-MIB", "intSwdlFileIdx"))
if mibBuilder.loadTexts: intSwdlEntry.setStatus('current')
if mibBuilder.loadTexts: intSwdlEntry.setDescription('An entry in table.')
intSwdlObjIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlObjIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlObjIdx.setDescription('The index of the object from which down-load is performed.')
intSwdlFileIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileIdx.setDescription('The index of the files included in intSwdlObjIdx.\n       One of these files can be selected to be internally \n       downloaded.')
intSwdlFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileName.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileName.setDescription('The name of the file.')
intSwdlFileSwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFileSwVer.setStatus('current')
if mibBuilder.loadTexts: intSwdlFileSwVer.setDescription('The software version of the file.')
intSwdlSwDate = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlSwDate.setStatus('current')
if mibBuilder.loadTexts: intSwdlSwDate.setDescription('The software version date of the file.')
intSwdlSize = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlSize.setStatus('current')
if mibBuilder.loadTexts: intSwdlSize.setDescription('The size of the file.')
intSwdlCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: intSwdlCmd.setStatus('current')
if mibBuilder.loadTexts: intSwdlCmd.setDescription('The command to down-load a SW file to an object.\n       The Agent will change the value of this MIB object to off(2) \n\t  automatically, after accepting the command.')
intSwdlToSubSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: intSwdlToSubSystem.setStatus('current')
if mibBuilder.loadTexts: intSwdlToSubSystem.setDescription(" This object defines the subsystem for download.\n       Bit='1'- APPLY to respective sub system.\n       Bit='0'- DO NOT APPLY to respective sub system.\n       For more details see product specification. \n       For every octet bit0=LSB, bit7=MSB")
intSwdlCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 220, 221, 222, 223, 270, 271, 272, 273, 280, 290, 300, 301, 302, 303, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325))).clone(namedValues=NamedValues(("unknown", 1), ("gstm1", 220), ("goc3", 221), ("gstm1D", 222), ("goc3D", 223), ("serverE1", 270), ("serverT1", 271), ("serverE1Pw", 272), ("serverT1Pw", 273), ("gigabitEth", 280), ("channelizedT3Pw1", 290), ("cesT128", 300), ("cesE128", 301), ("cesT1Pw28", 302), ("cesE1Pw28", 303), ("vmxE1VeDe", 310), ("vmxE1VeDi", 311), ("vmxE1ViDe", 312), ("vmxE1ViDi", 313), ("vmxT1VeDe", 314), ("vmxT1VeDi", 315), ("vmxT1ViDe", 316), ("vmxT1ViDi", 317), ("vc12E1UeNe", 318), ("vc12E1UeNi", 319), ("vc12E1UiNe", 320), ("vc12E1UiNi", 321), ("vc12T1UeNe", 322), ("vc12T1UeNi", 323), ("vc12T1UiNe", 324), ("vc12T1UiNi", 325)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlCardType.setStatus('current')
if mibBuilder.loadTexts: intSwdlCardType.setDescription('This object defines the Card type that this file is relevant for.')
intSwdlFlashIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intSwdlFlashIdx.setStatus('current')
if mibBuilder.loadTexts: intSwdlFlashIdx.setDescription('The index of the flash memory this file is stored in (1 or 2)\n      (Example: 1= The file is stored in flash No.1).\n      ASMi52 file will always be stored in Flash No.2 (intSwdlFlashIdx=2).')
swdlStatusTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11), )
if mibBuilder.loadTexts: swdlStatusTable.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTable.setDescription('This parameters table is for software download status. \n       It also includes data about the files down-loaded or \n       attempted to be down-loaded.')
swdlStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1), ).setIndexNames((0, "RAD-MIB", "swdlStatusTypeIdx"), (0, "RAD-MIB", "swdlStatusIdx"))
if mibBuilder.loadTexts: swdlStatusEntry.setStatus('current')
if mibBuilder.loadTexts: swdlStatusEntry.setDescription('An entry in table.')
swdlStatusTypeIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusTypeIdx.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTypeIdx.setDescription('The index of the down-load type (e.g. external (1) or internal (2)).')
swdlStatusIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusIdx.setStatus('current')
if mibBuilder.loadTexts: swdlStatusIdx.setDescription('The index of the status rows.')
swdlStatusFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusFileName.setStatus('current')
if mibBuilder.loadTexts: swdlStatusFileName.setDescription('The name of the file.')
swdlStatusSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusSlot.setStatus('current')
if mibBuilder.loadTexts: swdlStatusSlot.setDescription('The slot of the updated (or attempted to be updated) object.')
swdlStatusSubSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusSubSystem.setStatus('current')
if mibBuilder.loadTexts: swdlStatusSubSystem.setDescription('The subsystem that updated (or attempted to be updated).')
swdlStatusStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusStatus.setStatus('current')
if mibBuilder.loadTexts: swdlStatusStatus.setDescription('The status of the down load process.\n\t  Value:  Fail (2), OK (3), InProcess (4).')
swdlStatusTime = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 11, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swdlStatusTime.setStatus('current')
if mibBuilder.loadTexts: swdlStatusTime.setDescription('This MIB parameter indicates the time SW download was finished.\n           The format shuld be YYYY-MM-DD, hh:mm:ss')
clearDwldStatusLog = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clearDwldStatusLog.setStatus('current')
if mibBuilder.loadTexts: clearDwldStatusLog.setDescription('This object clears the status log.\n\t  Value: off(2), external(3), internal(4)\n\t  The Agent will change the value of this MIB object to off(2) \n\t  automatically, after accepting the command .')
autoFileTransfer = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13))
autoFileTransferTable = MibTable((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1), )
if mibBuilder.loadTexts: autoFileTransferTable.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferTable.setDescription('Scheduling configuration table for \n       Agent initiated file transfer.')
autoFileTransferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1), ).setIndexNames((0, "RAD-MIB", "autoFileTransferType"))
if mibBuilder.loadTexts: autoFileTransferEntry.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferEntry.setDescription('An entry in the table.')
autoFileTransferType = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("alarmsBuffer", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: autoFileTransferType.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferType.setDescription('This object defines the type of file to be transferred \n\t by agent. ')
autoFileTransferServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferServerIp.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferServerIp.setDescription('This object defines the IP Address of the\n\t server to which the file is uploaded.')
autoFileTransferFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 3), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferFileName.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferFileName.setDescription('This object defines the name of \n\t the file to be uploaded.')
autoFileTransferScheduling = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("now", 2), ("recurrence", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferScheduling.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferScheduling.setDescription("This object defines schedule for TFTP Automatic session(s) \n\t initiated by Agent, according to the value selected:\n     now          -  initiate immediate single session.\n\n     recurrence- initiate single session 'every M time units'. \n                 or 'every N occurrences' or upon both, (earliest event).\n                 Time reccurence period (M) is defined by\n\t\t\t\t fileTransferTimeRecurrence.\n\t\t\t\t Occurrence reccurence (N) is defined by \n\t\t\t\t fileTransferOccurrenceRecurrence.\n                 Zero value means that the object is not relevant (not\n                 taken into account for the recurrence). It is invalid \n                 that both will have zero values in our case (recurrence).\n\t\t\t\t When both are non zero, file is transferred\n\t\t\t\t upon earliest event")
autoFileTransferTimeRecurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferTimeRecurrence.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferTimeRecurrence.setDescription("This object defines time reccurence interval, \n\t e.g. M can be 'every M days', 'every M hours' etc.\n\t Zero is used to indicate \n\t there's no time reccurence (0= notApplicable).\n\t This object is taken into account only \n\t if autoFileTransferScheduling = recurrence\n\t For LA-110 time units are days.")
autoFileTransferOccurrenceRecurrence = MibTableColumn((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 13, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFileTransferOccurrenceRecurrence.setStatus('current')
if mibBuilder.loadTexts: autoFileTransferOccurrenceRecurrence.setDescription("This object defines Occurrence reccurence interval, \n\t e.g N can be in 'every N alarms', 'every N log entries' etc.\n\t zero is used to indicate \n\t There's no Event Reccurence. (0= notApplicable) \n \t This object is taken into account only \n\t if autoFileTransferScheduling = recurrence\n\t Occurence Type (Alarms, etc.) is according\n\t to autoFileTransferType.")
fileTransferServerPort = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 14), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferServerPort.setStatus('current')
if mibBuilder.loadTexts: fileTransferServerPort.setDescription('Server Port number used for File Transfer. \n     Applicable for SFTP.\n     Valid values: 0..65535.')
fileTransferProtocol = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 12, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tftp", 1), ("sftp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileTransferProtocol.setStatus('current')
if mibBuilder.loadTexts: fileTransferProtocol.setDescription('File Transfer protocol used.')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("off", 2), ("on", 3), ("resetConfig", 4), ("resetMapping", 5), ("resetStandby", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('current')
if mibBuilder.loadTexts: systemReset.setDescription('Reset action to be performed on the system.\n\t - resetMapping - reset SDH/SONET mapping to \n\t   default for all SDH/SONET links.\n\t - resetStandby(6) - can be used only by devices with redundancy on MAIN/CL.')
systemTiming = MibIdentifier((1, 3, 6, 1, 4, 1, 164, 6, 2, 14))
systemDate = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDate.setStatus('current')
if mibBuilder.loadTexts: systemDate.setDescription('System date.')
systemTime = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemTime.setStatus('current')
if mibBuilder.loadTexts: systemTime.setDescription('System time.')
systemTimeElapsed = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: systemTimeElapsed.setDescription('The number of seconds that have elapsed since the\n        beginning of the current error-measurement\n        period. Same for all ports of the device.')
systemResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemResetAllStatsCmd.setStatus('current')
if mibBuilder.loadTexts: systemResetAllStatsCmd.setDescription('Reset statistics of all ports and connections of the device.')
systemClearTablesCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("tempCnfgTables", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemClearTablesCmd.setStatus('current')
if mibBuilder.loadTexts: systemClearTablesCmd.setDescription("tempCnfgTables - Set *RowStatus = destroy for all entries of \n                         some tables having *RowStatus object, for \n                         temporary configuration only! (255).\n                         For the relevant tables, see product's specification.\n                         This object should be used by WAN product applications \n                         before performing the Update operation, in order to clear \n                         old entries of these tables.\n                         For MP-104/204 the entries will be destroyed for cnfg=1. \n        off - agent will automatically change to this value, after performing the \n              command. ")
systemParameter = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemParameter.setStatus('current')
if mibBuilder.loadTexts: systemParameter.setDescription("This parameter can be used for different purposes: \n        - TELNET session time-out in seconds.\n\t   \t- Ace20: when trying to create row in a table that already\n\t\t\t\t has row with the same values, if set of values has to be unique\n\t\t\t\t in table, this attribute is set to the index of the existing row.\n\t\t- Optimux-T3: when CH interfaces are RJ-45, user can select via this\n\t\t         object, the interface type for each Group of channels: T1 or E1:\n\t\t         The selection will be a sum of the following Bits.\n\t\t         '0' = T1\n\t\t         '1' = E1\n\t\t         Bit    Group               Value for each Bit having '1'\n\t\t\t\t  1\t\t  1 (CH-1..CH-8)        \t  1\n\t\t\t\t  2\t\t  2 (CH-9..CH-12)       \t  2\n\t\t\t\t  3\t\t  3 (CH-13..CH-20)\t          4\n\t\t\t\t  4\t\t  4 (CH-21..CH-28)\t          8\n\t\t\t\t Examples:\n\t\t\t\t 15 = all Groups are selected to be E1\n\t\t\t\t  6 = Group 2 and Group 3 are selected to be E1 \n\t\t\t\t     (Group 1 and Group 4 are T1).\n\t\t- FCD-A, FCD-M: user can select via this object the configuration\n\t\t         used for Get values of MSDSL parameters that don't have\n\t\t         configuration index.\n\t\t         1  =active configuration\n\t\t         255=temporary configuration.\n\t\t         Set of this object should be done before Getting the MSDSL \n\t\t         RW parameters.\n\t\t- Ace2002: This parameter indicates the number of intervals that\n\t\t         were successfully uploaded upon statistics collection session.        \n\t\t- FCD-IP, WR, FCD-IPD, LA-240:\n\t\t         This parameter indicates whether Telnet Access is enabled/disabled:\n\t\t         Values:\n\t\t\t\t 2 - Telnet Access is Disabled.\n\t\t\t\t 3 - Telnet Access is Enabled. \t\t\t\t \n        -Vmux-110: This parameter value equals to maximum number of bundles.\n\t\t-Optimux-155: Simmilar usage to Optimux T3. user can select via this\n\t\t         object, interface type T1 or E1 for each Group of \n\t\t         channels (LIU):  LIU group consists of 7 channels. \n\t\t         Up to 12 LIUs are represented (84 T1 Channels).\n                 The selection will be a sum of the 2**n\n                 For each bit:'0' = T1 ,'1' = E1\n\t\t         Bit    Group              \n\t\t\t\t  1\t\t  1 (CH-1 ..  CH-7)   \n\t\t\t\t  2\t\t  2 (CH-8 .. CH-14)  \n\t\t\t\t  3\t\t  3 (CH-15 ..CH-21) \n                   ...\n\t\t\t\t  9\t\t  9 (CH-56.. CH-63) \n                   ...\n\t\t\t\t  10\t  10 (CH-64..CH-70) \n\t\t\t\t  11\t  11 (CH-71..CH-77) \n\t\t\t\t  12\t  12 (CH-78..CH-84) ")
agnGlobalAlarmMask = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(100, 100)).setFixedLength(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnGlobalAlarmMask.setStatus('current')
if mibBuilder.loadTexts: agnGlobalAlarmMask.setDescription('The value of this attribute determines the alarm traps the \n       agent should mask and not send to the managers.\n       Each bit from a certain octet represents a certain alarm.')
alarmSeverity = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("event", 3), ("minor", 4), ("major", 5), ("warning", 6), ("critical", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSeverity.setStatus('current')
if mibBuilder.loadTexts: alarmSeverity.setDescription('This object specifies the severity of the alarms.')
alarmState = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmState.setStatus('current')
if mibBuilder.loadTexts: alarmState.setDescription('.')
agnTestStatus = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnTestStatus.setStatus('current')
if mibBuilder.loadTexts: agnTestStatus.setDescription('Indicates the current test status (for all levels: system,\n\t   card, port).\n       This attribute will be set to: \n         on(3): when there is at least one test\tin progress on the\n                system/card/port\n\t\t off(2): when there is NO test in progress on the\n    \t         system/card/port')
systemSaveAndResetAllStatsCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("on", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setStatus('current')
if mibBuilder.loadTexts: systemSaveAndResetAllStatsCmd.setDescription('on  - a command to Save data of Current Period in Last Period\n           data-set and start a new counting period for Current Period.\n     off - agent will automatically change to this value, after performing the \n           command.')
systemDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: systemDefaultGateway.setDescription("Default Gateway's IP Address.")
agnSendTrapParameter = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSendTrapParameter.setStatus('current')
if mibBuilder.loadTexts: agnSendTrapParameter.setDescription('This object specifies if the agent will attach a specific\n\tparameter to a trap.\n\t\n\tFor ACE2002 the agent will attach or not the openViewSeverity \n\tparameter according to the value of this parameter:\n\t1 - will attach openViewSeverity.\n\t0 - will not attach openViewSeverity.')
agnDeviceCapabilities = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 42), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: agnDeviceCapabilities.setStatus('current')
if mibBuilder.loadTexts: agnDeviceCapabilities.setDescription("Indicates the optional capabilities that are implemented by this device\n     and are manageable through this MIB. \n\n\t For each capability 1 BIT is allocated in each Octet starting from the LSB.\n\t If the value of the BIT = 1, the capability is Enabled.\n\t If the value of the BIT = 0, the capability is Disabled.\n     For bit assignment, refer to device specification.\t \n\t Capabilities example:\n\t Router - BIT 0 (0000 0001 = 01 Hex = 1 Decimal).\n\t \n\t The 2nd octet (MSB) will represent the maximum number of intervals that\n\t the Agent can keep in its DB (same for all ports).\n\t \n     For Vmux, this object describes agent's support of LBRAD coder feature:\n     1 octet ; bit 0 (LSB).\n     '1' - LBRAD feature is supported\n     '0' - LBRAD feature is not supported.")
agnStoreCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("off", 2), ("inFlash", 3), ("asDefConfigFile", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnStoreCmd.setStatus('current')
if mibBuilder.loadTexts: agnStoreCmd.setDescription("Store command.\n\t inFlash(3)\t\t\t= store the current Agent configuration in Flash memory.\n\t asDefConfigFile(4)\t= store the current Agent configuration as\n\t                      Default Configuration file (e.g. 'DefConfig.cfg').\n\t Agent will perform the required command and change automatically \n\t the value of this object to off(2).")
agnSwVersionSwapCmd = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("off", 2), ("mainAndBackup", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnSwVersionSwapCmd.setStatus('current')
if mibBuilder.loadTexts: agnSwVersionSwapCmd.setDescription('SW switch command.\n\t mainAndBackup (3) = Swap between Main SW and the backup one.\n\t Agent will perform the required command and change automatically \n\t the value of this object to off(2).')
agnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 164, 6, 2, 60), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agnTrapDelay.setStatus('current')
if mibBuilder.loadTexts: agnTrapDelay.setDescription('This variable enables the user to set a delay (in seconds) before a trap is sent.\n\t This delay will be used only for traps that need to be sent during device initialization.\n\t It is needed because the device connected to our device starts transmitting traps later.\n\t The delay starts from the end of the Boot process. The device will keep the init traps\n\t in the correct order, and cancel those which clear former ones in the list.\n\t After this init delay, traps will be sent without a delay.')
systemsEvents = ObjectIdentity((1, 3, 6, 1, 4, 1, 164, 6, 1, 0))
if mibBuilder.loadTexts: systemsEvents.setStatus('current')
if mibBuilder.loadTexts: systemsEvents.setDescription('The events for RAD products.')
tftpStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 1)).setObjects(("RAD-MIB", "tftpStatus"))
if mibBuilder.loadTexts: tftpStatusChangeTrap.setStatus('current')
if mibBuilder.loadTexts: tftpStatusChangeTrap.setDescription('This trap is sent whenever the status of tftp changed.')
agnStatusChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 2)).setObjects(("RAD-MIB", "agnIndication"))
if mibBuilder.loadTexts: agnStatusChangeTrap.setStatus('current')
if mibBuilder.loadTexts: agnStatusChangeTrap.setDescription('This trap is sent whenever the state of the entity the agent is\n\t responsible for changed.\n\t TDM devices will send agnTestStatus variable to indicate the current test status.')
swdlStatusResult = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 4)).setObjects(("RAD-MIB", "swdlStatusFileName"))
if mibBuilder.loadTexts: swdlStatusResult.setStatus('current')
if mibBuilder.loadTexts: swdlStatusResult.setDescription('This notification is sent when Software Down Load is finished.\n\t The attached object indicates the File Name.')
intSwdlSlotFileMismatch = NotificationType((1, 3, 6, 1, 4, 1, 164, 6, 1, 0, 5)).setObjects(("RAD-MIB", "intSwdlFileName"))
if mibBuilder.loadTexts: intSwdlSlotFileMismatch.setStatus('current')
if mibBuilder.loadTexts: intSwdlSlotFileMismatch.setDescription("This notification is sent when the card in the chosen slot doesn't match \n\t the chosen file.\n\t The attached object indicates the File Name.")
mibBuilder.exportSymbols("RAD-MIB", trapTable=trapTable, systemSaveAndResetAllStatsCmd=systemSaveAndResetAllStatsCmd, trapTimeSinceOccurrence=trapTimeSinceOccurrence, systemsEvents=systemsEvents, autoFileTransferFileName=autoFileTransferFileName, intSwdlFileSwVer=intSwdlFileSwVer, fileTransferToSubSystems=fileTransferToSubSystems, systemTiming=systemTiming, autoFileTransferScheduling=autoFileTransferScheduling, fileTransCmd=fileTransCmd, systemDate=systemDate, intSwdlObjIdx=intSwdlObjIdx, tftpTotalTimeOut=tftpTotalTimeOut, intSwdlCmd=intSwdlCmd, intSwdlFlashIdx=intSwdlFlashIdx, systemParameter=systemParameter, rad=rad, swdlStatusEntry=swdlStatusEntry, systemTimeElapsed=systemTimeElapsed, tftpStatusChangeTrap=tftpStatusChangeTrap, autoFileTransfer=autoFileTransfer, autoFileTransferOccurrenceRecurrence=autoFileTransferOccurrenceRecurrence, autoFileTransferTimeRecurrence=autoFileTransferTimeRecurrence, agnStatusChangeTrap=agnStatusChangeTrap, intSwdlSwDate=intSwdlSwDate, agnTrapValue=agnTrapValue, mngIPMask=mngIPMask, systemClearTablesCmd=systemClearTablesCmd, systems=systems, mngTrapMask=mngTrapMask, mngIP=mngIP, mngID=mngID, agnSwVersionSwapCmd=agnSwVersionSwapCmd, mngTrapIpTable=mngTrapIpTable, swdlStatusStatus=swdlStatusStatus, trapVal=trapVal, agnSendTrapParameter=agnSendTrapParameter, intSwdlSlotFileMismatch=intSwdlSlotFileMismatch, swdlStatusResult=swdlStatusResult, fileTransferServerPort=fileTransferServerPort, swdlStatusSlot=swdlStatusSlot, MacAddress=MacAddress, swdlStatusTime=swdlStatusTime, tftpRetryTimeOut=tftpRetryTimeOut, agnStoreCmd=agnStoreCmd, fileServerIP=fileServerIP, agnConfigMsg=agnConfigMsg, trapID=trapID, alarmState=alarmState, clearDwldStatusLog=clearDwldStatusLog, agnt=agnt, agnDeviceCapabilities=agnDeviceCapabilities, agnSpecific=agnSpecific, agnIndication=agnIndication, intSwdlSize=intSwdlSize, agnTrapDelay=agnTrapDelay, intSwdlToSubSystem=intSwdlToSubSystem, systemReset=systemReset, swdlStatusFileName=swdlStatusFileName, autoFileTransferServerIp=autoFileTransferServerIp, autoFileTransferType=autoFileTransferType, swdlStatusTypeIdx=swdlStatusTypeIdx, fileTransfer=fileTransfer, agnTestStatus=agnTestStatus, swdlStatusSubSystem=swdlStatusSubSystem, trapEntry=trapEntry, intSwdlCardType=intSwdlCardType, mngSnmpTrapUdpPort=mngSnmpTrapUdpPort, tftpError=tftpError, systemTime=systemTime, agnGlobalAlarmMask=agnGlobalAlarmMask, mngAlarmTrapMask=mngAlarmTrapMask, intSwdlTable=intSwdlTable, autoFileTransferTable=autoFileTransferTable, agnLed=agnLed, agnHwVersion=agnHwVersion, mngEntry=mngEntry, swdlStatusIdx=swdlStatusIdx, agnChangeCnt=agnChangeCnt, tftpStatus=tftpStatus, swdlStatusTable=swdlStatusTable, agnMonitorModeCmd=agnMonitorModeCmd, intSwdlEntry=intSwdlEntry, alarmSeverity=alarmSeverity, intSwdlFileName=intSwdlFileName, fileName=fileName, radGen=radGen, intSwdlFileIdx=intSwdlFileIdx, fileTransferProtocol=fileTransferProtocol, systemDefaultGateway=systemDefaultGateway, autoFileTransferEntry=autoFileTransferEntry, systemResetAllStatsCmd=systemResetAllStatsCmd, fileNameWithinProduct=fileNameWithinProduct, agnTrapMask=agnTrapMask)
