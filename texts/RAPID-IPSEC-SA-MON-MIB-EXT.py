#
# PySNMP MIB module RAPID-IPSEC-SA-MON-MIB-EXT (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nortel/RAPID-IPSEC-SA-MON-MIB-EXT
# Produced by pysmi-1.1.12 at Tue Jun  4 02:43:39 2024
# On host fv-az1200-411 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
IpsecDoiEspTransform, IpsecDoiIpcompTransform, IpsecDoiIdentType, IpsecDoiAhTransform, IpsecDoiAuthAlgorithm, IpsecDoiSecProtocolId, IpsecDoiEncapsulationMode = mibBuilder.importSymbols("IPSEC-ISAKMP-IKE-DOI-TC", "IpsecDoiEspTransform", "IpsecDoiIpcompTransform", "IpsecDoiIdentType", "IpsecDoiAhTransform", "IpsecDoiAuthAlgorithm", "IpsecDoiSecProtocolId", "IpsecDoiEncapsulationMode")
rapidstream, = mibBuilder.importSymbols("RAPID-MIB", "rapidstream")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, iso, Integer32, Counter64, Bits, ObjectIdentity, Counter32, MibIdentifier, Gauge32, Unsigned32, enterprises, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "iso", "Integer32", "Counter64", "Bits", "ObjectIdentity", "Counter32", "MibIdentifier", "Gauge32", "Unsigned32", "enterprises", "ModuleIdentity", "NotificationType")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
rsIpsecSaMonModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 4355, 3))
rsIpsecSaMonModule.setRevisions(('2000-03-21 12:00', '2002-11-01 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rsIpsecSaMonModule.setRevisionsDescriptions(('Initial revision.', 'Changed CONTACT-INFO.',))
if mibBuilder.loadTexts: rsIpsecSaMonModule.setLastUpdated('200003211200Z')
if mibBuilder.loadTexts: rsIpsecSaMonModule.setOrganization('WatchGuard Technologies, Inc.')
if mibBuilder.loadTexts: rsIpsecSaMonModule.setContactInfo('   Ella Yu\n                      WatchGuard Technologies, Inc.\n                      1841 Zanker Road\n                      San Jose, CA 95112\n                      USA\n\n                      408-519-4888\n                      ella.yu@watchguard.com ')
if mibBuilder.loadTexts: rsIpsecSaMonModule.setDescription("The MIB module describes generic IPSec objects\n            defined in IETF working draft \n            'draft-ieft-ipsec-monitor-mib-01' and RapidStream's\n            extension.")
class IpsecSaCreatorIdent(TextualConvention, Integer32):
    description = 'A value indicating how an SA was created.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("unknown", 0), ("static", 1), ("ike", 2), ("other", 3))

class IpsecIpv6Address(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 address prefixes. This\n            is a binary string of 16 octets in network byte-order.'
    status = 'current'
    displayHint = '2x:2x:2x:2x:2x:2x:1d.1d.1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

rsIpsecSaMonitorMIB = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1))
if mibBuilder.loadTexts: rsIpsecSaMonitorMIB.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaMonitorMIB.setDescription('This is the base object identifier for all IPSec branches.')
rsSaTables = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1))
if mibBuilder.loadTexts: rsSaTables.setStatus('current')
if mibBuilder.loadTexts: rsSaTables.setDescription('This is the base object identifier for all SA tables.')
rsSaStatistics = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2))
if mibBuilder.loadTexts: rsSaStatistics.setStatus('current')
if mibBuilder.loadTexts: rsSaStatistics.setDescription('This is the base object identifier for all objects which\n            are global counters for IPSec security associations.')
rsSaErrors = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3))
if mibBuilder.loadTexts: rsSaErrors.setStatus('current')
if mibBuilder.loadTexts: rsSaErrors.setDescription('This is the base object identifier for all objects which\n            are global error counters for IPSec security associations.')
rsSaTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4))
if mibBuilder.loadTexts: rsSaTraps.setStatus('current')
if mibBuilder.loadTexts: rsSaTraps.setDescription('This is the base object identifier for all objects which\n            are traps for IPSec security associations.')
rsSaTrapObjects = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 5))
if mibBuilder.loadTexts: rsSaTrapObjects.setStatus('current')
if mibBuilder.loadTexts: rsSaTrapObjects.setDescription('This is the base object identifier for objects which are\n            used as part of traps.')
rsSaTrapControl = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6))
if mibBuilder.loadTexts: rsSaTrapControl.setStatus('current')
if mibBuilder.loadTexts: rsSaTrapControl.setDescription('This is the base object identifier for all objects which\n            are trap controls for IPSec security associations.')
rsSaGroups = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 7))
if mibBuilder.loadTexts: rsSaGroups.setStatus('current')
if mibBuilder.loadTexts: rsSaGroups.setDescription('This is the base object identifier for all objects which\n            describe the groups in this MIB.')
rsSaConformance = ObjectIdentity((1, 3, 6, 1, 4, 1, 4355, 3, 1, 8))
if mibBuilder.loadTexts: rsSaConformance.setStatus('current')
if mibBuilder.loadTexts: rsSaConformance.setDescription('This is the base object identifier for all objects which\n            describe the conformance for this MIB.')
rsIpsecSaEspInTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1), )
if mibBuilder.loadTexts: rsIpsecSaEspInTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInTable.setDescription('The (conceptual) table containing information on IPSec\n            inbound ESP SAs.\n\n            There should be one row for every inbound ESP security\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaEspInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspInAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspInSpi"))
if mibBuilder.loadTexts: rsIpsecSaEspInEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec inbound ESP SA.\n\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaEspInAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInAddress.setDescription("The destination address of the SA.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaEspInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInSpi.setReference('RFC 2406 Section 2.1')
if mibBuilder.loadTexts: rsIpsecSaEspInSpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInSpi.setDescription('The security parameters index of the SA.')
rsIpsecSaEspInDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchanged during SA creation negotiation.')
rsIpsecSaEspInDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInDestIdType.setDescription("The type of identifier presented by 'rsIpsecSaEspInDestId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaEspInSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during SA creation negotiation.')
rsIpsecSaEspInSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInSourceIdType.setDescription("The type of identifier presented by 'rsIpsecSaEspInSourceId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaEspInProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspInProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaEspInDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspInDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaEspInSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspInSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaEspInCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaEspInEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaEspInEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 12), IpsecDoiEspTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInEncAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInEncAlg.setDescription('A unique value representing the encryption algorithm\n            applied to traffic or 0 if there is no encryption used.')
rsIpsecSaEspInEncKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInEncKeyLength.setDescription("The length of the encryption key in bits used for the\n            algorithm specified in the 'rsIpsecSaEspInEncAlg' object, or 0\n            if the key length is implicit in the specified algorithm or\n            there is no encryption specified.")
rsIpsecSaEspInAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 14), IpsecDoiAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInAuthAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInAuthAlg.setDescription('A unique value representing the hash algorithm applied to\n            traffic or 0 if there is no authentication used.')
rsIpsecSaEspInLimitSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 15), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is\n            no time constraint on its expiration.\n            The display value is limited to 4294967295 seconds (more\n            than 136 years); values greater than that value will be\n            truncated.')
rsIpsecSaEspInLimitKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 16), Integer32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInLimitKbytes.setDescription('The maximum traffic in kilobytes that the SA is allowed to\n            support, or 0 if there is no traffic constraint on its\n            expiration.\n\n            The display value is limited to 4294967295 kilobytes; values\n            greater than that value will be truncated.')
rsIpsecSaEspInAccSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 17), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInAccSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInAccSeconds.setDescription("The number of seconds accumulated against the SA's\n            expiration by time.\n\n            This is also the number of seconds that the SA has existed.")
rsIpsecSaEspInAccKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 18), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInAccKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInAccKbytes.setDescription("The amount of traffic accumulated that counts against the\n            SA's expiration by traffic limitation, measured in Kbytes.\n\n            This value may be 0 if the SA does not expire based on\n            traffic.")
rsIpsecSaEspInUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 19), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.\n\n            This is not necessarily the same as the amount of traffic\n            applied against the traffic expiration limit.')
rsIpsecSaEspInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInPackets.setDescription('The number of packets handled by the SA.')
rsIpsecSaEspInDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInDecryptErrors.setDescription('The number of packets discarded by the SA due to decryption\n            errors.')
rsIpsecSaEspInAuthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInAuthErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInAuthErrors.setDescription('The number of packets discarded by the SA due to\n            authentication errors.')
rsIpsecSaEspInReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInReplayErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInReplayErrors.setDescription('The number of packets discarded by the SA due to replay\n            errors.')
rsIpsecSaEspInPolicyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInPolicyErrors.setDescription('The number of packets discarded by the SA due to policy\n            errors. This includes packets where the next protocol is\n            invalid.')
rsIpsecSaEspInPadErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInPadErrors.setReference('RFC 2406 section 2.4')
if mibBuilder.loadTexts: rsIpsecSaEspInPadErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInPadErrors.setDescription('The number of packets discarded by the SA due to pad value\n            errors.\n\n            Implementations that do not check this must not support this\n            object.')
rsIpsecSaEspInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors\n            other than decryption, authentication or replay errors. This\n            may include packets dropped due to a lack of receive\n            buffers, and may include packets dropped due to congestion\n            at the decryption element.')
rsIpsecSaAhInTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2), )
if mibBuilder.loadTexts: rsIpsecSaAhInTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInTable.setDescription('The (conceptual) table containing information on IPSec\n            inbound AH SAs.\n            There should be one row for every inbound AH security\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaAhInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhInAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhInSpi"))
if mibBuilder.loadTexts: rsIpsecSaAhInEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec inbound AH SA.\n\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaAhInAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInAddress.setDescription("The destination address of the SA.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaAhInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInSpi.setReference('RFC 2402 Section 2.4')
if mibBuilder.loadTexts: rsIpsecSaAhInSpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInSpi.setDescription('The security parameters index of the SA.')
rsIpsecSaAhInDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during SA creation negotiation.')
rsIpsecSaAhInDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInDestIdType.setDescription("The type of identifier presented by 'rsIpsecSaAhInDestId', or\n            0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaAhInSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during SA creation negotiation.')
rsIpsecSaAhInSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInSourceIdType.setDescription("The type of identifier presented by 'rsIpsecSaAhInSourceId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaAhInProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhInProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaAhInDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhInDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaAhInSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhInSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaAhInCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaAhInEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaAhInAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 12), IpsecDoiAhTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInAuthAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInAuthAlg.setDescription('A unique value representing the hash algorithm applied to\n            traffic carried by this SA if it uses ESP or 0 if there is\n            no authentication applied by ESP.')
rsIpsecSaAhInLimitSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 13), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is\n            no time constraint on its expiration.\n\n            The display value is limited to 4294967295 seconds (more\n            than 136 years); values greater than that value will be\n            truncated.')
rsIpsecSaAhInLimitKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 14), Integer32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInLimitKbytes.setDescription('The maximum traffic in Kbytes that the SA is allowed to\n            support, or 0 if there is no traffic constraint on its\n            expiration.\n\n            The display value is limited to 4294967295 kilobytes; values\n            greater than that value will be truncated.')
rsIpsecSaAhInAccSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 15), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInAccSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInAccSeconds.setDescription("The number of seconds accumulated against the SA's\n            expiration by time.\n\n            This is also the number of seconds that the SA has existed.")
rsIpsecSaAhInAccKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 16), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInAccKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInAccKbytes.setDescription("The amount of traffic accumulated that counts against the\n            SA's expiration by traffic limitation, measured in Kbytes.\n            This value may be 0 if the SA does not expire based on\n            traffic.")
rsIpsecSaAhInUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 17), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.\n\n            This is not necessarily the same as the amount of traffic\n            applied against the traffic expiration limit.')
rsIpsecSaAhInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInPackets.setDescription('The number of packets handled by the SA.')
rsIpsecSaAhInAuthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInAuthErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInAuthErrors.setDescription('The number of packets discarded by the SA due to\n            authentication errors.')
rsIpsecSaAhInReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInReplayErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInReplayErrors.setDescription('The number of packets discarded by the SA due to replay\n            errors.')
rsIpsecSaAhInPolicyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInPolicyErrors.setDescription('The number of packets discarded by the SA due to policy\n            errors. This includes packets where the next protocol is\n            invalid.')
rsIpsecSaAhInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors\n            other than decryption, authentication or replay errors. This\n            may include packets dropped due to a lack of receive\n            buffers, and may include packets dropped due to congestion\n            at the authentication element.')
rsIpsecSaIpcompInTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3), )
if mibBuilder.loadTexts: rsIpsecSaIpcompInTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInTable.setDescription('The (conceptual) table containing information on IPSec\n            inbound IPCOMP SAs.\n\n            There should be one row for every inbound IPCOMP (security)\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaIpcompInEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaIpcompInAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaIpcompInCpi"))
if mibBuilder.loadTexts: rsIpsecSaIpcompInEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec inbound IPCOMP SA.\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaIpcompInAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInAddress.setDescription("The destination address of the SA.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaIpcompInCpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 2), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInCpi.setReference('RFC 2393 Section 3.3')
if mibBuilder.loadTexts: rsIpsecSaIpcompInCpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInCpi.setDescription('The CPI of the SA. Since the lower values of CPIs are\n            reserved to be the same as the algorithm, the syntax for\n            this object is the same as the transform.')
rsIpsecSaIpcompInDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode, or 0 if this SA is used with\n            multiple SAs in protection suites.\n\n            This value, if non-zero, is taken directly from the optional\n            ID payloads that are exchange during SA creation\n            negotiation.')
rsIpsecSaIpcompInDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestIdType.setDescription("The type of identifier presented by\n            'rsIpsecSaIpcompInDestId', or 0 if unknown or if the SA uses\n            transport mode, or 0 if this SA is used with multiple SAs in\n            protection suites.")
rsIpsecSaIpcompInSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation, or 0 if this SA is\n            used with multiple SAs in protection suites.\n\n            This value, if non-zero, is taken directly from the optional\n            ID payloads that are exchange during SA creation\n            negotiation.')
rsIpsecSaIpcompInSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourceIdType.setDescription("The type of identifier presented by\n            'rsIpsecSaIpcompInSourceId', or 0 if unknown or if the SA uses\n            transport mode encapsulation, or 0 if this SA is used with\n            multiple SAs in protection suites.")
rsIpsecSaIpcompInProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompInProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaIpcompInDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaIpcompInSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaIpcompInCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaIpcompInEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaIpcompInDecompAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 12), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInDecompAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDecompAlg.setDescription('A unique value representing the decompression algorithm\n            applied to traffic.')
rsIpsecSaIpcompInSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 13), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInSeconds.setDescription('The number of seconds that the SA has existed.')
rsIpsecSaIpcompInUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 14), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.')
rsIpsecSaIpcompInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInPackets.setDescription('The number of packets handled by the SA.')
rsIpsecSaIpcompInDecompErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInDecompErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInDecompErrors.setDescription('The number of packets discarded by the SA due to\n            decompression errors.')
rsIpsecSaIpcompInOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompInOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompInOtherReceiveErrors.setDescription('The number of packets discarded by the SA due to errors\n            other than decompression errors. This may include packets\n            dropped due to a lack of receive buffers, and packets\n            dropped due to congestion at the decompression element.')
rsIpsecSaEspOutTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4), )
if mibBuilder.loadTexts: rsIpsecSaEspOutTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutTable.setDescription('The (conceptual) table containing information on IPSec\n            Outbound ESP SAs.\n\n            There should be one row for every outbound ESP security\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaEspOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspOutAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspOutSpi"))
if mibBuilder.loadTexts: rsIpsecSaEspOutEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec Outbound ESP SA.\n\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaEspOutAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutAddress.setDescription("The destination address of the SA.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaEspOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutSpi.setReference('RFC 2406 Section 2.1')
if mibBuilder.loadTexts: rsIpsecSaEspOutSpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutSpi.setDescription('The security parameters index of the SA.')
rsIpsecSaEspOutSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during phase 2 negotiations.')
rsIpsecSaEspOutSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutSourceIdType.setDescription("The type of identifier presented by\n            'rsIpsecSaEspOutSourceId', or 0 if unknown or if the SA uses\n            transport mode encapsulation.")
rsIpsecSaEspOutDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during phase 2 negotiations.')
rsIpsecSaEspOutDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutDestIdType.setDescription("The type of identifier presented by 'rsIpsecSaEspOutDestId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaEspOutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspOutProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaEspOutSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaEspOutDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaEspOutDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaEspOutCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaEspOutEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaEspOutEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 12), IpsecDoiEspTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutEncAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutEncAlg.setDescription('A unique value representing the encryption algorithm\n            applied to traffic or 0 if there is no encryption used.')
rsIpsecSaEspOutEncKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65531))).setUnits('bits').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutEncKeyLength.setDescription("The length of the encryption key in bits used for the\n            algorithm specified in the 'rsIpsecSaEspOutEncAlg' object, or\n            0 if the key length is implicit in the specified algorithm\n            or there is no encryption specified.")
rsIpsecSaEspOutAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 14), IpsecDoiAuthAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutAuthAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutAuthAlg.setDescription('A unique value representing the hash algorithm applied to\n            traffic or 0 if there is no authentication used.')
rsIpsecSaEspOutLimitSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 15), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is\n            no time constraint on its expiration.\n\n            The display value is limited to 4294967295 seconds (more\n            than 136 years); values greater than that value will be\n            truncated.')
rsIpsecSaEspOutLimitKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 16), Integer32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutLimitKbytes.setDescription('The maximum traffic in kbytes that the SA is allowed to\n            support, or 0 if there is no traffic constraint on its\n            expiration.\n\n            The display value is limited to 4294967295 kilobytes; values\n            greater than that value will be truncated.')
rsIpsecSaEspOutAccSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 17), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutAccSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutAccSeconds.setDescription("The number of seconds accumulated against the SA's\n            expiration by time.\n\n            This is also the number of seconds that the SA has existed.")
rsIpsecSaEspOutAccKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 18), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutAccKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutAccKbytes.setDescription("The amount of traffic accumulated that counts against the\n            SA's expiration by traffic limitation, measured in Kbytes.\n\n            This value may be 0 if the SA does not expire based on\n            traffic.")
rsIpsecSaEspOutUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 19), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.\n\n            This is not necessarily the same as the amount of traffic\n            applied against the traffic expiration limit.')
rsIpsecSaEspOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutPackets.setDescription('The number of packets handled by the SA.')
rsIpsecSaEspOutSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaEspOutSendErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaEspOutSendErrors.setDescription('The number of packets discarded by the SA due to any error.\n            This may include errors due to a lack of transmit buffers.')
rsIpsecSaAhOutTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5), )
if mibBuilder.loadTexts: rsIpsecSaAhOutTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutTable.setDescription('The (conceptual) table containing information on IPSec\n            Outbound AH SAs.\n\n            There should be one row for every outbound AH security\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaAhOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhOutAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhOutSpi"))
if mibBuilder.loadTexts: rsIpsecSaAhOutEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec Outbound AH SA.\n\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaAhOutAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutAddress.setDescription("The destination address of the SA.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaAhOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutSpi.setReference('RFC 2402 Section 2.4')
if mibBuilder.loadTexts: rsIpsecSaAhOutSpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutSpi.setDescription('The security parameters index of the SA.')
rsIpsecSaAhOutSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during phase 2 negotiations.')
rsIpsecSaAhOutSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutSourceIdType.setDescription("The type of identifier presented by 'rsIpsecSaAhOutSourceId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaAhOutDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode encapsulation.\n\n            This value is taken directly from the optional ID payloads\n            that are exchange during phase 2 negotiations.')
rsIpsecSaAhOutDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutDestIdType.setDescription("The type of identifier presented by 'rsIpsecSaAhOutDestId',\n            or 0 if unknown or if the SA uses transport mode\n            encapsulation.")
rsIpsecSaAhOutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhOutProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaAhOutSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaAhOutDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaAhOutDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaAhOutCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaAhOutEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaAhOutAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 12), IpsecDoiAhTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutAuthAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutAuthAlg.setDescription('A unique value representing the hash algorithm applied to\n            traffic or 0 if there is no authentication used.')
rsIpsecSaAhOutLimitSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 13), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutLimitSeconds.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is\n            no time constraint on its expiration.\n\n            The display value is limited to 4294967295 seconds (more\n            than 136 years); values greater than that value will be\n            truncated.')
rsIpsecSaAhOutLimitKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 14), Integer32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutLimitKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutLimitKbytes.setDescription('The maximum traffic in Kbytes that the SA is allowed to\n            support, or 0 if there is no traffic constraint on its\n            expiration.\n\n            The display value is limited to 4294967295 kilobytes; values\n            greater than that value will be truncated.')
rsIpsecSaAhOutAccSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 15), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutAccSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutAccSeconds.setDescription("The number of seconds accumulated against the SA's\n            expiration by time.\n\n            This is also the number of seconds that the SA has existed.")
rsIpsecSaAhOutAccKbytes = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 16), Counter32()).setUnits('kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutAccKbytes.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutAccKbytes.setDescription("The amount of traffic accumulated that counts against the\n            SA's expiration by traffic limitation, measured in Kbytes.\n\n            This value may be 0 if the SA does not expire based on\n            traffic.")
rsIpsecSaAhOutUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 17), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.\n\n            This is not necessarily the same as the amount of traffic\n            applied against the traffic expiration limit.')
rsIpsecSaAhOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutPackets.setDescription('The number of packets handled by the SA.')
rsIpsecSaAhOutSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaAhOutSendErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaAhOutSendErrors.setDescription('The number of packets discarded by the SA due to any error.\n            This may include errors due to a lack of transmit buffers.')
rsIpsecSaIpcompOutTable = MibTable((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6), )
if mibBuilder.loadTexts: rsIpsecSaIpcompOutTable.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutTable.setDescription('The (conceptual) table containing information on IPSec\n            Outbound IPCOMP SAs.\n\n            There should be one row for every outbound IPCOMP (security)\n            association that exists in the entity. The maximum number of\n            rows is implementation dependent.')
rsIpsecSaIpcompOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1), ).setIndexNames((0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaIpcompOutAddress"), (0, "RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaIpcompOutCpi"))
if mibBuilder.loadTexts: rsIpsecSaIpcompOutEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutEntry.setDescription('An entry (conceptual row) containing the information on a\n            particular IPSec Outbound IPCOMP SA.\n\n            A row in this table cannot be created or deleted by SNMP\n            operations on columns of the table.')
rsIpsecSaIpcompOutAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutAddress.setDescription("The destination address of the SA.\n\n            If the IPCOMP SA is shared across multiple SAs in protection\n            suites, this value may be 0.\n\n            For implementations that do not support IPv6, this address\n            should appear as one of the IPv4-mapped IPv6 addresses as\n            defined in Section 2.5.4 of [IPV6AA].\n\n            Specifically, the prefix '0000:0000:0000:0000:0000:FFFF:' is\n            used for IPv4 only nodes, while the prefix\n            '0000:0000:0000:0000:0000:0000:' is used for bi-lingual\n            nodes.")
rsIpsecSaIpcompOutCpi = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 2), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCpi.setReference('RFC 2393 Section 3.3')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCpi.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCpi.setDescription('The CPI of the SA. Since the lower values of CPIs are\n            reserved to be the same as the algorithm, the syntax for\n            this object is the same as the transform.')
rsIpsecSaIpcompOutSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourceId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourceId.setDescription('The source identifier of the SA, or 0 if unknown or if the\n            SA uses transport mode encapsulation, or 0 if this SA is\n            used with multiple SAs in protection suites.\n\n            This value, if non-zero, is taken directly from the optional\n            ID payloads that are exchange during phase 2 negotiations.')
rsIpsecSaIpcompOutSourceIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 4), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourceIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourceIdType.setDescription("The type of identifier presented by\n            'rsIpsecSaIpcompOutSourceId', or 0 if unknown or if the SA\n            uses transport mode encapsulation, or 0 if this SA is used\n            with multiple SAs in protection suites.")
rsIpsecSaIpcompOutDestId = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestId.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestId.setDescription('The destination identifier of the SA, or 0 if unknown or if\n            the SA uses transport mode encapsulation, or 0 if this SA is\n            used with multiple SAs in protection suites.\n\n            This value, if non-zero, is taken directly from the optional\n            ID payloads that are exchange during phase 2 negotiations.')
rsIpsecSaIpcompOutDestIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 6), IpsecDoiIdentType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestIdType.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestIdType.setDescription("The type of identifier presented by\n            'rsIpsecSaIpcompOutDestId', or 0 if unknown or if the SA uses\n            transport mode encapsulation, or 0 if this SA is used with\n            multiple SAs in protection suites.")
rsIpsecSaIpcompOutProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutProtocol.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutProtocol.setDescription('The transport-layer protocol number that this SA carries,\n            or 0 if it carries any protocol.')
rsIpsecSaIpcompOutSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourcePort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourcePort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSourcePort.setDescription('The source port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaIpcompOutDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestPort.setReference('RFC2401 section 4.4.2')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestPort.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutDestPort.setDescription('The destination port number of the protocol that this SA\n            carries, or 0 if it carries any port number.')
rsIpsecSaIpcompOutCreator = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 10), IpsecSaCreatorIdent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCreator.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCreator.setDescription('The creator of this SA.\n\n            This MIB makes no assumptions about how the SAs are created.\n            They may be created statically, or by a key exchange\n            protocol such as IKE, or by some other method.')
rsIpsecSaIpcompOutEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 11), IpsecDoiEncapsulationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutEncapsulation.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutEncapsulation.setDescription('The type of encapsulation used by this SA.')
rsIpsecSaIpcompOutCompAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 12), IpsecDoiIpcompTransform()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCompAlg.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutCompAlg.setDescription('A unique value representing the compression algorithm\n            applied to traffic.')
rsIpsecSaIpcompOutSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 13), Counter32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSeconds.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutSeconds.setDescription('The number of seconds that the SA has existed.')
rsIpsecSaIpcompOutUserOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 14), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutUserOctets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutUserOctets.setDescription('The amount of user level traffic measured in bytes handled\n            by the SA.\n\n            This is not necessarily the same as the amount of traffic\n            applied against the traffic expiration limit.')
rsIpsecSaIpcompOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 4355, 3, 1, 1, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSaIpcompOutPackets.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSaIpcompOutPackets.setDescription('The number of packets handled by the SA.')
rsIpsecEspCurrentInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecEspCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecEspCurrentInboundSAs.setDescription('The current number of inbound ESP SAs in the entity.')
rsIpsecEspTotalInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecEspTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecEspTotalInboundSAs.setDescription('The total number of inbound ESP SAs created in the entity\n            since boot time.')
rsIpsecEspCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecEspCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecEspCurrentOutboundSAs.setDescription('The current number of outbound ESP SAs in the entity.')
rsIpsecEspTotalOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecEspTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecEspTotalOutboundSAs.setDescription('The total number of outbound ESP SAs created in the entity\n            since boot time.')
rsIpsecAhCurrentInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecAhCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecAhCurrentInboundSAs.setDescription('The current number of inbound AH SAs in the entity.')
rsIpsecAhTotalInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecAhTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecAhTotalInboundSAs.setDescription('The total number of inbound AH SAs created in the entity\n            since boot time.')
rsIpsecAhCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecAhCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecAhCurrentOutboundSAs.setDescription('The current number of outbound AH SAs in the entity.')
rsIpsecAhTotalOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecAhTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecAhTotalOutboundSAs.setDescription('The total number of outbound AH SAs created in the entity\n            since boot time.')
rsIpsecIpcompCurrentInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecIpcompCurrentInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecIpcompCurrentInboundSAs.setDescription('The current number of inbound IPCOMP SAs in the entity.')
rsIpsecIpcompTotalInboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecIpcompTotalInboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecIpcompTotalInboundSAs.setDescription('The total number of inbound IPCOMP SAs created in the\n            entity since boot time.')
rsIpsecIpcompCurrentOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecIpcompCurrentOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecIpcompCurrentOutboundSAs.setDescription('The current number of outbound IPCOMP SAs in the entity.')
rsIpsecIpcompTotalOutboundSAs = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecIpcompTotalOutboundSAs.setStatus('current')
if mibBuilder.loadTexts: rsIpsecIpcompTotalOutboundSAs.setDescription('The total number of outbound IPCOMP SAs created in the\n            entity since boot time.')
rsIpsecDecryptionErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecDecryptionErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecDecryptionErrors.setDescription('The total number of packets received by the entity in SAs\n            since boot time with decryption errors.')
rsIpsecAuthenticationErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecAuthenticationErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecAuthenticationErrors.setDescription('The total number of packets received by the entity in SAs\n            since boot time with authentication errors.\n\n            This includes all packets in which the hash value is\n            determined to be invalid, for both ESP and AH SAs.')
rsIpsecReplayErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecReplayErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecReplayErrors.setDescription('The total number of packets received by the entity in SAs\n            since boot time with replay errors.')
rsIpsecPolicyErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecPolicyErrors.setDescription('The total number of packets received by the entity in SAs\n            since boot time and discarded due to policy errors. This\n            includes packets that had selectors that were invalid for\n            the SA that carried them.')
rsIpsecOtherReceiveErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecOtherReceiveErrors.setDescription('The total number of packets received by the entity in SAs\n            since boot time and discarded due to errors not due to\n            decryption, authentication, replay or policy.')
rsIpsecSendErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSendErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSendErrors.setDescription('The total number of packets to be sent by the entity in SAs\n            since boot time and discarded due to errors.')
rsIpsecUnknownSpiErrors = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecUnknownSpiErrors.setStatus('current')
if mibBuilder.loadTexts: rsIpsecUnknownSpiErrors.setDescription('The total number of packets received by the entity since\n            boot time with SPIs or CPIs that were not valid.')
rsIpsecSecurityProtocol = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 5, 1), IpsecDoiSecProtocolId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSecurityProtocol.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSecurityProtocol.setDescription('A security protocol associated with the trap.')
rsIpsecSPI = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecSPI.setStatus('current')
if mibBuilder.loadTexts: rsIpsecSPI.setDescription('An SPI associated with a trap. Where the security protocol\n            associated with the trap is IPCOMP, this value has a maximum\n            of 65535.')
rsIpsecLocalAddress = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 5, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecLocalAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecLocalAddress.setDescription('A local IP address associated with the trap.')
rsIpsecPeerAddress = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 5, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpsecPeerAddress.setStatus('current')
if mibBuilder.loadTexts: rsIpsecPeerAddress.setDescription('A peer IP address associated with the trap.')
rsEspAuthFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsEspAuthFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsEspAuthFailureTrapEnable.setDescription('Indicates whether espAuthFailureTrap traps should be\n            generated.')
rsAhAuthFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsAhAuthFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsAhAuthFailureTrapEnable.setDescription('Indicates whether ahAuthFailureTrap traps should be\n            generated.')
rsEspReplayFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsEspReplayFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsEspReplayFailureTrapEnable.setDescription('Indicates whether espReplayFailureTrap traps should be\n            generated.')
rsAhReplayFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsAhReplayFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsAhReplayFailureTrapEnable.setDescription('Indicates whether ahReplayFailureTrap traps should be\n            generated.')
rsEspPolicyFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsEspPolicyFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsEspPolicyFailureTrapEnable.setDescription('Indicates whether espPolicyFailureTrap traps should be\n            generated.')
rsAhPolicyFailureTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsAhPolicyFailureTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsAhPolicyFailureTrapEnable.setDescription('Indicates whether ahPolicyFailureTrap traps should be\n            generated.')
rsInvalidSpiTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 4355, 3, 1, 6, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsInvalidSpiTrapEnable.setStatus('current')
if mibBuilder.loadTexts: rsInvalidSpiTrapEnable.setDescription('Indicates whether invalidSpiTrap traps should be\n            generated.')
rsEspAuthFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 1)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspInAuthErrors"))
if mibBuilder.loadTexts: rsEspAuthFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsEspAuthFailureTrap.setDescription("IPSec packets with invalid hashes were found in an inbound\n            ESP SA. The total number of authentication errors\n            accumulated is sent for the specific row of the\n            'rsIpsecSaEspInTable' table for the SA; this provides the\n            identity of the SA in which the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsAhAuthFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 2)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhInAuthErrors"))
if mibBuilder.loadTexts: rsAhAuthFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsAhAuthFailureTrap.setDescription("IPSec packets with invalid hashes were found in an inbound\n            AH SA. The total number of authentication errors accumulated\n            is sent for the specific row of the 'rsIpsecSaAhInTable' table\n            for the SA; this provides the identity of the SA in which\n            the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsEspReplayFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 3)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspInReplayErrors"))
if mibBuilder.loadTexts: rsEspReplayFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsEspReplayFailureTrap.setDescription("IPSec packets with invalid sequence numbers were found in\n            an inbound ESP SA. The total number of replay errors\n            accumulated is sent for the specific row of the\n            'rsIpsecSaEspInTable' table for the SA; this provides the\n            identity of the SA in which the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsAhReplayFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 4)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhInReplayErrors"))
if mibBuilder.loadTexts: rsAhReplayFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsAhReplayFailureTrap.setDescription("IPSec packets with invalid sequence numbers were found in\n            the specified AH SA. The total number of replay errors\n            accumulated is sent for the specific row of the\n            'rsIpsecSaAhInTable' table for the SA; this provides the\n            identity of the SA in which the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsEspPolicyFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 5)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaEspInPolicyErrors"))
if mibBuilder.loadTexts: rsEspPolicyFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsEspPolicyFailureTrap.setDescription("IPSec packets carrying packets with invalid selectors for\n            the specified ESP SA were found. The total number of policy\n            errors accumulated is sent for the specific row of the\n\n            'rsIpsecSaEspInTable' table for the SA; this provides the\n            identity of the SA in which the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsAhPolicyFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 6)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSaAhInPolicyErrors"))
if mibBuilder.loadTexts: rsAhPolicyFailureTrap.setStatus('current')
if mibBuilder.loadTexts: rsAhPolicyFailureTrap.setDescription("IPSec packets carrying packets with invalid selectors for\n            the specified AH SA were found. The total number of policy\n            errors accumulated is sent for the specific row of the\n            'rsIpsecSaAhInTable' table for the SA; this provides the\n            identity of the SA in which the error occurred.\n\n            Implementations SHOULD send one trap per SA (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
rsInvalidSpiTrap = NotificationType((1, 3, 6, 1, 4, 1, 4355, 3, 1, 4, 0, 7)).setObjects(("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecLocalAddress"), ("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSecurityProtocol"), ("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecPeerAddress"), ("RAPID-IPSEC-SA-MON-MIB-EXT", "rsIpsecSPI"), ("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rsInvalidSpiTrap.setStatus('current')
if mibBuilder.loadTexts: rsInvalidSpiTrap.setDescription("A packet with an unknown SPI was detected from the\n            specified peer with the specified SPI using the specified\n            protocol. The destination address of the received packet is\n            specified by 'ipsecLocalAddress'.\n\n            The value 'ifIndex' may be 0 if this optional linkage is\n            unsupported.\n\n            If the object 'ipsecSecurityProtocol' has the value for\n            IPCOMP, then the 'ipsecSPI' object is the CPI of the packet.\n            Implementations SHOULD send one trap per peer (within a\n            reasonable time period), rather than sending one trap per\n            packet.")
mibBuilder.exportSymbols("RAPID-IPSEC-SA-MON-MIB-EXT", rsIpsecSaEspInPolicyErrors=rsIpsecSaEspInPolicyErrors, rsIpsecSaAhInPackets=rsIpsecSaAhInPackets, rsAhAuthFailureTrap=rsAhAuthFailureTrap, rsIpsecSaIpcompInOtherReceiveErrors=rsIpsecSaIpcompInOtherReceiveErrors, rsIpsecSaEspOutLimitKbytes=rsIpsecSaEspOutLimitKbytes, rsEspPolicyFailureTrapEnable=rsEspPolicyFailureTrapEnable, rsIpsecLocalAddress=rsIpsecLocalAddress, rsIpsecEspCurrentInboundSAs=rsIpsecEspCurrentInboundSAs, rsIpsecSaMonitorMIB=rsIpsecSaMonitorMIB, rsAhPolicyFailureTrap=rsAhPolicyFailureTrap, rsIpsecSaEspInPadErrors=rsIpsecSaEspInPadErrors, rsIpsecUnknownSpiErrors=rsIpsecUnknownSpiErrors, rsIpsecSaEspInAuthErrors=rsIpsecSaEspInAuthErrors, rsIpsecSaEspOutSourcePort=rsIpsecSaEspOutSourcePort, rsIpsecSaEspOutEncAlg=rsIpsecSaEspOutEncAlg, rsIpsecSaIpcompOutEntry=rsIpsecSaIpcompOutEntry, rsIpsecSaEspInDestIdType=rsIpsecSaEspInDestIdType, rsIpsecAhTotalOutboundSAs=rsIpsecAhTotalOutboundSAs, rsIpsecSaAhInSpi=rsIpsecSaAhInSpi, rsIpsecSaAhOutCreator=rsIpsecSaAhOutCreator, rsIpsecSaEspInProtocol=rsIpsecSaEspInProtocol, rsIpsecSaAhInSourceId=rsIpsecSaAhInSourceId, rsIpsecSaEspInEncKeyLength=rsIpsecSaEspInEncKeyLength, rsIpsecSaIpcompInUserOctets=rsIpsecSaIpcompInUserOctets, rsIpsecSaEspOutUserOctets=rsIpsecSaEspOutUserOctets, rsIpsecSaIpcompOutCreator=rsIpsecSaIpcompOutCreator, rsIpsecSaIpcompInCpi=rsIpsecSaIpcompInCpi, rsIpsecSecurityProtocol=rsIpsecSecurityProtocol, rsIpsecAhCurrentInboundSAs=rsIpsecAhCurrentInboundSAs, rsIpsecSaIpcompOutSourceId=rsIpsecSaIpcompOutSourceId, rsIpsecSaEspOutAccSeconds=rsIpsecSaEspOutAccSeconds, rsIpsecSaAhOutSourcePort=rsIpsecSaAhOutSourcePort, rsIpsecDecryptionErrors=rsIpsecDecryptionErrors, rsIpsecSaAhOutProtocol=rsIpsecSaAhOutProtocol, rsIpsecSaEspInEncapsulation=rsIpsecSaEspInEncapsulation, rsIpsecSaEspOutCreator=rsIpsecSaEspOutCreator, rsInvalidSpiTrap=rsInvalidSpiTrap, rsIpsecSaEspInDestId=rsIpsecSaEspInDestId, rsIpsecSaAhOutDestPort=rsIpsecSaAhOutDestPort, rsIpsecSaAhInAccSeconds=rsIpsecSaAhInAccSeconds, rsIpsecSaAhInAddress=rsIpsecSaAhInAddress, rsIpsecSaAhOutDestIdType=rsIpsecSaAhOutDestIdType, rsIpsecSaEspInReplayErrors=rsIpsecSaEspInReplayErrors, rsIpsecSaAhInLimitSeconds=rsIpsecSaAhInLimitSeconds, rsIpsecSaEspOutDestIdType=rsIpsecSaEspOutDestIdType, rsEspAuthFailureTrapEnable=rsEspAuthFailureTrapEnable, rsIpsecSaIpcompOutAddress=rsIpsecSaIpcompOutAddress, IpsecIpv6Address=IpsecIpv6Address, rsIpsecSaAhInSourceIdType=rsIpsecSaAhInSourceIdType, rsIpsecSaAhInCreator=rsIpsecSaAhInCreator, rsIpsecSaIpcompInEntry=rsIpsecSaIpcompInEntry, rsInvalidSpiTrapEnable=rsInvalidSpiTrapEnable, rsSaTrapObjects=rsSaTrapObjects, rsIpsecSaEspOutLimitSeconds=rsIpsecSaEspOutLimitSeconds, rsIpsecSaAhOutLimitSeconds=rsIpsecSaAhOutLimitSeconds, rsIpsecSaEspInDestPort=rsIpsecSaEspInDestPort, rsSaStatistics=rsSaStatistics, rsIpsecSaIpcompOutProtocol=rsIpsecSaIpcompOutProtocol, rsIpsecSaEspOutAuthAlg=rsIpsecSaEspOutAuthAlg, rsIpsecSaAhInAccKbytes=rsIpsecSaAhInAccKbytes, rsIpsecSaIpcompInPackets=rsIpsecSaIpcompInPackets, rsIpsecSaEspInSourceId=rsIpsecSaEspInSourceId, rsIpsecSaIpcompOutSourceIdType=rsIpsecSaIpcompOutSourceIdType, rsIpsecSaEspInSpi=rsIpsecSaEspInSpi, rsIpsecSaAhInEncapsulation=rsIpsecSaAhInEncapsulation, rsIpsecSaIpcompInTable=rsIpsecSaIpcompInTable, rsIpsecSaEspInLimitSeconds=rsIpsecSaEspInLimitSeconds, rsIpsecSaAhOutPackets=rsIpsecSaAhOutPackets, rsIpsecSaEspInUserOctets=rsIpsecSaEspInUserOctets, rsIpsecSaIpcompInAddress=rsIpsecSaIpcompInAddress, rsIpsecSaAhOutSourceId=rsIpsecSaAhOutSourceId, rsIpsecSaAhInPolicyErrors=rsIpsecSaAhInPolicyErrors, rsSaGroups=rsSaGroups, rsIpsecSaEspOutEncapsulation=rsIpsecSaEspOutEncapsulation, rsIpsecSaAhOutUserOctets=rsIpsecSaAhOutUserOctets, rsIpsecSaEspInOtherReceiveErrors=rsIpsecSaEspInOtherReceiveErrors, rsIpsecSaEspInSourcePort=rsIpsecSaEspInSourcePort, rsIpsecSaEspOutDestPort=rsIpsecSaEspOutDestPort, rsIpsecSaEspOutEncKeyLength=rsIpsecSaEspOutEncKeyLength, rsSaTraps=rsSaTraps, rsIpsecSaEspInTable=rsIpsecSaEspInTable, rsIpsecSaAhOutAccKbytes=rsIpsecSaAhOutAccKbytes, rsIpsecSaIpcompOutTable=rsIpsecSaIpcompOutTable, rsIpsecSaIpcompOutCpi=rsIpsecSaIpcompOutCpi, rsIpsecSaEspInAuthAlg=rsIpsecSaEspInAuthAlg, rsIpsecSaIpcompOutSeconds=rsIpsecSaIpcompOutSeconds, rsIpsecSaAhInEntry=rsIpsecSaAhInEntry, rsAhReplayFailureTrapEnable=rsAhReplayFailureTrapEnable, rsIpsecSaIpcompOutPackets=rsIpsecSaIpcompOutPackets, rsIpsecSaIpcompInDestIdType=rsIpsecSaIpcompInDestIdType, rsIpsecSaAhInDestId=rsIpsecSaAhInDestId, rsIpsecSaEspInEntry=rsIpsecSaEspInEntry, rsSaTrapControl=rsSaTrapControl, rsSaErrors=rsSaErrors, rsAhAuthFailureTrapEnable=rsAhAuthFailureTrapEnable, rsIpsecSaAhInOtherReceiveErrors=rsIpsecSaAhInOtherReceiveErrors, rsIpsecSaAhOutTable=rsIpsecSaAhOutTable, rsIpsecSaEspInDecryptErrors=rsIpsecSaEspInDecryptErrors, rsIpsecSaIpcompInDestId=rsIpsecSaIpcompInDestId, rsIpsecSaIpcompInSourceId=rsIpsecSaIpcompInSourceId, rsIpsecSaIpcompInSourceIdType=rsIpsecSaIpcompInSourceIdType, rsIpsecPeerAddress=rsIpsecPeerAddress, rsIpsecSaIpcompInEncapsulation=rsIpsecSaIpcompInEncapsulation, rsIpsecEspCurrentOutboundSAs=rsIpsecEspCurrentOutboundSAs, rsIpsecAhTotalInboundSAs=rsIpsecAhTotalInboundSAs, rsIpsecSaAhInDestPort=rsIpsecSaAhInDestPort, rsAhPolicyFailureTrapEnable=rsAhPolicyFailureTrapEnable, rsIpsecAhCurrentOutboundSAs=rsIpsecAhCurrentOutboundSAs, rsIpsecSaAhInDestIdType=rsIpsecSaAhInDestIdType, rsIpsecOtherReceiveErrors=rsIpsecOtherReceiveErrors, rsIpsecSaAhOutSourceIdType=rsIpsecSaAhOutSourceIdType, rsEspReplayFailureTrap=rsEspReplayFailureTrap, rsIpsecSaIpcompInDecompErrors=rsIpsecSaIpcompInDecompErrors, rsIpsecIpcompTotalOutboundSAs=rsIpsecIpcompTotalOutboundSAs, rsIpsecSaEspOutAccKbytes=rsIpsecSaEspOutAccKbytes, rsIpsecSaEspOutSpi=rsIpsecSaEspOutSpi, rsIpsecSaIpcompOutSourcePort=rsIpsecSaIpcompOutSourcePort, rsEspReplayFailureTrapEnable=rsEspReplayFailureTrapEnable, rsIpsecSaAhOutDestId=rsIpsecSaAhOutDestId, rsIpsecSaAhOutAddress=rsIpsecSaAhOutAddress, rsIpsecSaIpcompOutCompAlg=rsIpsecSaIpcompOutCompAlg, rsIpsecSaAhInAuthAlg=rsIpsecSaAhInAuthAlg, rsIpsecSaEspOutSourceId=rsIpsecSaEspOutSourceId, rsIpsecSaIpcompOutDestIdType=rsIpsecSaIpcompOutDestIdType, rsIpsecSPI=rsIpsecSPI, rsIpsecSaAhInProtocol=rsIpsecSaAhInProtocol, rsIpsecSaAhInUserOctets=rsIpsecSaAhInUserOctets, rsIpsecSaIpcompOutDestPort=rsIpsecSaIpcompOutDestPort, rsIpsecSaEspOutProtocol=rsIpsecSaEspOutProtocol, rsIpsecSaAhOutEntry=rsIpsecSaAhOutEntry, rsIpsecSaAhOutSendErrors=rsIpsecSaAhOutSendErrors, rsIpsecSaIpcompInCreator=rsIpsecSaIpcompInCreator, rsIpsecSaEspOutDestId=rsIpsecSaEspOutDestId, rsIpsecSaEspOutPackets=rsIpsecSaEspOutPackets, rsIpsecSaAhOutLimitKbytes=rsIpsecSaAhOutLimitKbytes, rsIpsecSaEspOutSendErrors=rsIpsecSaEspOutSendErrors, rsEspAuthFailureTrap=rsEspAuthFailureTrap, rsAhReplayFailureTrap=rsAhReplayFailureTrap, rsIpsecSaAhInLimitKbytes=rsIpsecSaAhInLimitKbytes, rsIpsecSaAhInReplayErrors=rsIpsecSaAhInReplayErrors, rsIpsecSaEspInSourceIdType=rsIpsecSaEspInSourceIdType, rsIpsecSaEspOutAddress=rsIpsecSaEspOutAddress, rsIpsecSaEspOutSourceIdType=rsIpsecSaEspOutSourceIdType, rsIpsecPolicyErrors=rsIpsecPolicyErrors, rsSaConformance=rsSaConformance, rsIpsecSaAhOutAuthAlg=rsIpsecSaAhOutAuthAlg, rsIpsecSaIpcompOutUserOctets=rsIpsecSaIpcompOutUserOctets, rsIpsecSaEspOutEntry=rsIpsecSaEspOutEntry, rsEspPolicyFailureTrap=rsEspPolicyFailureTrap, IpsecSaCreatorIdent=IpsecSaCreatorIdent, rsIpsecSaEspOutTable=rsIpsecSaEspOutTable, rsIpsecIpcompCurrentOutboundSAs=rsIpsecIpcompCurrentOutboundSAs, rsIpsecIpcompTotalInboundSAs=rsIpsecIpcompTotalInboundSAs, rsIpsecSaEspInEncAlg=rsIpsecSaEspInEncAlg, rsIpsecSaEspInCreator=rsIpsecSaEspInCreator, rsIpsecSaEspInPackets=rsIpsecSaEspInPackets, rsIpsecReplayErrors=rsIpsecReplayErrors, rsIpsecSaEspInAccKbytes=rsIpsecSaEspInAccKbytes, rsIpsecSaEspInAddress=rsIpsecSaEspInAddress, rsIpsecSaMonModule=rsIpsecSaMonModule, rsIpsecSaAhInSourcePort=rsIpsecSaAhInSourcePort, rsIpsecSaEspInAccSeconds=rsIpsecSaEspInAccSeconds, rsIpsecSaIpcompOutEncapsulation=rsIpsecSaIpcompOutEncapsulation, rsIpsecEspTotalInboundSAs=rsIpsecEspTotalInboundSAs, rsIpsecSaEspInLimitKbytes=rsIpsecSaEspInLimitKbytes, rsIpsecEspTotalOutboundSAs=rsIpsecEspTotalOutboundSAs, rsIpsecSaIpcompInDestPort=rsIpsecSaIpcompInDestPort, rsIpsecIpcompCurrentInboundSAs=rsIpsecIpcompCurrentInboundSAs, rsIpsecSaIpcompInSourcePort=rsIpsecSaIpcompInSourcePort, rsIpsecSaAhOutSpi=rsIpsecSaAhOutSpi, rsIpsecSendErrors=rsIpsecSendErrors, rsIpsecSaAhInAuthErrors=rsIpsecSaAhInAuthErrors, rsIpsecSaIpcompInProtocol=rsIpsecSaIpcompInProtocol, rsIpsecSaIpcompInSeconds=rsIpsecSaIpcompInSeconds, PYSNMP_MODULE_ID=rsIpsecSaMonModule, rsSaTables=rsSaTables, rsIpsecSaIpcompInDecompAlg=rsIpsecSaIpcompInDecompAlg, rsIpsecSaIpcompOutDestId=rsIpsecSaIpcompOutDestId, rsIpsecSaAhInTable=rsIpsecSaAhInTable, rsIpsecAuthenticationErrors=rsIpsecAuthenticationErrors, rsIpsecSaAhOutEncapsulation=rsIpsecSaAhOutEncapsulation, rsIpsecSaAhOutAccSeconds=rsIpsecSaAhOutAccSeconds)
