#
# PySNMP MIB module AT-PTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/allied/AT-PTP-MIB
# Produced by pysmi-1.1.12 at Mon Jul  1 10:50:58 2024
# On host fv-az665-510 platform Linux version 6.5.0-1022-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint")
modules, = mibBuilder.importSymbols("AT-SMI-MIB", "modules")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Counter32, Bits, Gauge32, TimeTicks, ModuleIdentity, ObjectIdentity, NotificationType, iso, MibIdentifier, Counter64, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Bits", "Gauge32", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "NotificationType", "iso", "MibIdentifier", "Counter64", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32")
TextualConvention, AutonomousType, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "AutonomousType", "DisplayString", "TruthValue")
atPtpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504))
atPtpMIB.setRevisions(('2017-01-23 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atPtpMIB.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: atPtpMIB.setLastUpdated('201701230000Z')
if mibBuilder.loadTexts: atPtpMIB.setOrganization('Allied Telesis, Inc.')
if mibBuilder.loadTexts: atPtpMIB.setContactInfo('http://www.alliedtelesis.com')
if mibBuilder.loadTexts: atPtpMIB.setDescription('This MIB file contains definitions of managed objects for the\n                 IEEE 1588v2 Precision Time Protocol (PTP) module.')
class PtpClockDomainType(TextualConvention, Unsigned32):
    reference = 'Section 7.1 Domains, Table 2 of [IEEE 1588-2008]'
    description = 'The Domain is identified by an integer, the domainNumber, in\n                the range of 0 to 255. An integer value that is used to assign\n                each PTP device to a particular domain. The following values\n                define the valid domains.\n\n                 Value       Definition\n                 ---------   -------------------\n                 0           Default domain\n                 1           Alternate domain 1\n                 2           Alternate domain 2\n                 3           Alternate domain 3\n                 4 - 127     User-defined domains\n                 128 - 255   Reserved'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class PtpClockIdentity(TextualConvention, OctetString):
    reference = 'Section 7.5.2.2.1 of [IEEE 1588-2008]'
    description = 'The clock Identity is an 8-octet array and will be presented in\n                the form of a character array.  Network byte order is assumed.\n\n                The value of the PtpClockIdentity should be taken from the\n                IEEE EUI-64 individual assigned numbers as indicated in\n                Section 7.5.2.2.2 of [IEEE 1588-2008]. It can also be non-EUI-64\n                address as defined in section 7.5.2.2.3 of [IEEE 1588-2008].\n\n                The EUI-64 address is divided into the following fields:\n\n                    OUI bytes (0-2)\n                    Extension identifier bytes (3-7)\n\n                The clock identifier can be constructed from existing EUI-48\n                assignments and here is an abbreviated example extracted from\n                section 7.5.2.2.2 [IEEE 1588-2008].\n\n                    Company EUI-48 = 0xACDE4823456716\n                    EUI-64 = ACDE48FFFE23456716\n\n                It is important to note the IEEE Registration Authority has\n                deprecated the use of MAC-48 in any new design.'
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class PtpClockInstanceType(TextualConvention, Unsigned32):
    description = 'The instance of the Clock of a given clock type in a given\n                domain.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class PtpClockIntervalBase2(TextualConvention, Integer32):
    reference = 'Section 7.7.2.1 General interval specification of\n                        [IEEE 1588-2008]'
    description = 'The interval included in message types Announce, Sync,\n                Delay_Req, and Pdelay_Req as indicated in section 7.7.2.1 of\n                [IEEE 1588-2008].\n\n                The mean time interval between successive messages shall be\n                represented as the logarithm to the base 2 of this time\n                interval measured in seconds on the local clock of the device\n                sending the message. The values of these logarithmic attributes\n                shall be selected from integers in the range -128 to 127 subject\n                to further limits established in an applicable PTP profile.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-128, 127)

class PtpClockMechanismType(TextualConvention, Integer32):
    reference = 'Sections 8.2.5.4.4 portDS.delayMechanism,\n                6.6.4  Measuring link propagation delay in clocks supporting\n                peer-to-peer path correction,\n                7.4.2 communication Path asymmetry of [IEEE 1588-2008].'
    description = 'The clock type based on whether end-to-end or peer-to-peer\n                mechanisms are used. The mechanism used to calculate the Mean\n                Path Delay as indicated in Table 9 of [IEEE 1588-2008].\n\n                Delay mechanism   Value(hex)  Specification\n                ---------------   ----------  -------------\n                E2E                  01       The port is configured to use the\n                                              delay request-response mechanism.\n                P2P                  02       The port is configured to use the\n                                              peer delay mechanism.\n                DISABLED             FE       The port does not implement the\n                                              delay mechanism.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 254))
    namedValues = NamedValues(("e2e", 1), ("p2p", 2), ("disabled", 254))

class PtpClockPortNumber(TextualConvention, Unsigned32):
    reference = 'Sections 7.5.2.3 portNumber and 5.3.5 PortIdentity of\n                [IEEE 1588-2008]'
    description = 'An index identifying a specific Precision Time Protocol (PTP)\n                port on a PTP node.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class PtpClockPortState(TextualConvention, Integer32):
    reference = 'Section 8.2.5.3.1 portState and 9.2.5 State machines of\n                [IEEE 1588-2008]'
    description = 'This is the value of the current state of the protocol engine\n                associated with this port.\n\n                Port state      Value     Description\n                -----------------------------------------------------------\n                initializing      1       In this state a port initializes\n                                          its data sets, hardware, and\n                                          communication facilities.\n                faulty            2       The fault state of the protocol.\n                disabled 3       The port shall not place any\n                                          messages on its communication path.\n                listening         4       The port is waiting for the\n                                          announceReceiptTimeout to expire or\n                                          to receive an Announce message from\n                                          a master.\n                preMaster         5       The port shall behave in all respects\n                                          as though it were in the MASTER state\n                                          except that it shall not place any\n                                          messages on its communication path\n                                          except for Pdelay_Req, Pdelay_Resp,\n                                          Pdelay_Resp_Follow_Up, signaling, or\n                                          management messages.\n                master            6       The port is behaving as a master port.\n                passive           7       The port shall not place any messages\n                                          on its communication path except for\n                                          Pdelay_Req, Pdelay_Resp,\n                                          Pdelay_Resp_Follow_Up, or signaling\n                                          messages, or management messages that\n                                          are a required response to another\n                                          management message\n                uncalibrated      8       The local port is preparing to\n                                          synchronize to the master port.\n                slave             9       The port is synchronizing to the\n                                          selected master port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("preMaster", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9))

class PtpClockPortTransportTypeAddress(TextualConvention, OctetString):
    reference = 'Annex D (IPv4), Annex E (IPv6), Annex F (Ethernet),\n                         Annex G (DeviceNET), Annex H (ControlNET) and\n                         Annex I (IEC61158) of [IEEE 1588-2008]'
    description = 'The Clock port transport protocol address used for this\n                 communication between the clock nodes. This is a string\n                 corresponding to the address type as specified by the\n                 transport type used. The transport types can be defined\n                 elsewhere, in addition to the ones defined in this document.\n                 This can be an address of type IP version 4, IP version 6,\n                 Ethernet, DeviceNET, ControlNET or IEC61158. The OCTET STRING\n                 representation of the OID of ptpWellKnownTransportTypes\n                 will be used in the values contained in the OCTET STRING.'
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class PtpClockProfileType(TextualConvention, Integer32):
    reference = 'Section 3.1.30 profile and 19.3 PTP profiles of\n                             [IEEE 1588-2008]'
    description = 'Clock Profile used. A profile is the set of allowed Precision\n                Time Protocol (PTP) features applicable to a device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("default", 1), ("telecom", 2), ("vendorspecific", 3))

class PtpClockQualityAccuracyType(TextualConvention, Integer32):
    reference = 'Section 5.3.7 ClockQuality, 7.6.2.5 clockAccuracy and Table 6\n                clockAccuracy enumeration of [IEEE 1588-2008]'
    description = 'The ClockQuality as specified in sections 5.3.7, 7.6.2.5 and\n                Table 6 of [IEEE 1588-2008].\n\n                The following values are not represented in the enumerated\n                values.\n\n                         0x01-0x1F Reserved\n                         0x32-0x7F Reserved\n\n                It is important to note that section 7.1.1 of [RFC 2578] allows\n                for gaps and enumerate values starting at zero when indicated by\n                the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))
    namedValues = NamedValues(("nanoSecond25", 32), ("nanoSecond100", 33), ("nanoSecond250", 34), ("microSec1", 35), ("microSec2dot5", 36), ("microSec10", 37), ("microSec25", 38), ("microSec100", 39), ("microSec250", 40), ("milliSec1", 41), ("milliSec2dot5", 42), ("milliSec10", 43), ("milliSec25", 44), ("milliSec100", 45), ("milliSec250", 46), ("second1", 47), ("second10", 48), ("secondGreater10", 49), ("unknown", 254))

class PtpClockQualityClassType(TextualConvention, Integer32):
    reference = 'Section 5.3.7, 7.6.2.4 and Table 5 of\n                             [IEEE 1588-2008].'
    description = 'The ClockQuality as specified in section 5.3.7 ClockQuality,\n                7.6.2.4 clockClass and Table 5 clockClass specifications of\n                [IEEE 1588-2008].\n\n                Value     Description\n                --------  ------------------------------------------------\n                       0  Reserved to enable compatibility with future\n                          versions.\n                     1-5  Reserved\n                       6  Shall designate a clock that is synchronized\n                          to a primary reference time source.  The\n                          timescale distributed shall be PTP.  A\n                          clockClass 6 clock shall not be a slave to\n                          another clock in the domain.\n                       7  Shall designate a clock that has previously\n                          been designated as clockClass 6 but that has\n                          lost the ability to synchronize to a primary\n                          reference time source and is in holdover mode\n                          and within holdover specifications. The\n                          timescale distributed shall be PTP.  A\n                          clockClass 7 clock shall not be a slave to\n                          another clock in the domain.\n                       8  Reserved.\n                    9-10  Reserved to enable compatibility with future\n                          versions.\n                   11-12  Reserved.\n                      13  Shall designate a clock that is synchronized\n                          to an application-specific source of time.\n                          The timescale distributed shall be ARB.  A\n                          clockClass 13 clock shall not be a slave to\n                          another clock in the domain.\n                      14  Shall designate a clock that has previously\n                          been designated as clockClass 13 but that\n                          has lost the ability to synchronize to an\n                          application-specific source of time and is\n                          in holdover mode and within holdover\n                          specifications. The timescale distributed\n                          shall be ARB.  A clockClass 14 clock shall\n                          not be a slave to another clock in the domain.\n                   15-51  Reserved.\n                      52  Degradation alternative A for a clock of\n                          clockClass 7 that is not within holdover\n                          specification.  A clock of clockClass 52\n                          shall not be a slave to another clock in\n                          the domain.\n                   53-57  Reserved.\n                      58  Degradation alternative A for a clock of\n                          clockClass 14 that is not within holdover\n                          specification. A clock of clockClass 58 shall\n                          not be a slave to another clock in the domain.\n                   59-67  Reserved.\n                  68-122  For use by alternate PTP profiles.\n                 123-127  Reserved.\n                 128-132  Reserved.\n                 133-170  For use by alternate PTP profiles.\n                 171-186  Reserved.\n                     187  Degradation alternative B for a clock of\n                          clockClass 7 that is not within holdover\n                          specification. A clock of clockClass 187 may\n                          be a slave to another clock in the domain.\n                 188-192  Reserved.\n                     193  Degradation alternative B for a clock of\n                          clockClass 14 that is not within holdover\n                          specification. A clock of clockClass 193 may\n                          be a slave to another clock in the domain.\n                 194-215  Reserved.\n                 216-232  For use by alternate PTP profiles.\n                 233-247  Reserved.\n                     248  Default. This clockClass shall be used if\n                          none of the other clockClass definitions apply.\n                 249-250  Reserved.\n                     251  Reserved for version 1 compatibility; see Clause 18.\n                 252-254  Reserved.\n                     255  Shall be the clockClass of a slave-only clock; see\n                          9.2.2.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(6, 7, 13, 14, 52, 58))
    namedValues = NamedValues(("clockclass6", 6), ("clockclass7", 7), ("clockclass13", 13), ("clockclass14", 14), ("clockclass52", 52), ("clockclass58", 58))

class PtpClockRoleType(TextualConvention, Integer32):
    description = 'The Clock Role. The protocol generates a Master Slave\n                relationship among the clocks in the system.\n\n                Clock Role      Value     Description\n                --------------------------------------------------------------\n                Master clock     1        A clock that is the source of\n                                          time to which all other clocks on\n                                          that path synchronize.\n                Slave clock      2        A clock which synchronizes to\n                                          another clock (master).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("master", 1), ("slave", 2))

class PtpClockStateType(TextualConvention, Integer32):
    description = 'The clock state returned by a PTP engine.\n\n                Clock State      Value   Description\n                --------------------------------------------------------------\n                Freerun state       1   Applies to a slave device that is not\n                                        locked to a master. This is the initial\n                                        state a slave starts out with when it\n                                        is not getting any PTP packets from the\n                                        master or because of some other input\n                                        error (erroneous packets, etc).\n                Holdover state      2   In this state the slave device is\n                                        locked to a master but communication\n                                        with the master has been lost or the\n                                        timestamps in the PTP packets are\n                                        incorrect.  Since the slave was\n                                        locked to the master, it can run in this\n                                        state, with similar accuracy for some\n                                        time.  If communication with the master\n                                        is not restored for an extended period\n                                        (dependent on the clock implementation),\n                                        the device should move to the Freerun\n                                        state.\n                Acquiring state     3   The slave device is receiving packets\n                                        from a master and is trying to acquire\n                                        a lock.\n                Freq_locked state   4   Slave device is locked to the Master\n                                        with respect to frequency, but not phase\n                                        aligned\n                Phase_aligned state 5   Locked to the master with respect to\n                                        frequency and phase.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("freerun", 1), ("holdover", 2), ("acquiring", 3), ("frequencyLocked", 4), ("phaseAligned", 5))

class PtpClockTimeInterval(TextualConvention, OctetString):
    reference = 'Section 5.3.2 TimeInterval and section 7.7.2.1 Timer interval\n                 specification of [IEEE 1588-2008]'
    description = "This textual convention corresponds to the TimeInterval\n                structure indicated in section 5.3.2 of [IEEE 1588-2008].\n                It will be presented in the form of a character array.\n                Network byte order is assumed.\n\n                The TimeInterval type represents time intervals.\n\n                     struct TimeInterval\n                     {\n                          Integer64 scaledNanoseconds;\n                     };\n\n                The scaledNanoseconds member is the time interval expressed in\n                units of nanoseconds and multiplied by 2**16.\n\n                Positive or negative time intervals outside the maximum range\n                of this data type shall be encoded as the largest positive and\n                negative values of the data type, respectively.\n\n                For example, 2.5 ns is expressed as string '0000 0000 0002 8000'\n                in Base16."
    status = 'current'
    displayHint = '255a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class PtpClockTimeSourceType(TextualConvention, Integer32):
    reference = 'Section 5.3.7, 7.6.2.6 and Table 7 of\n                             [IEEE 1588-2008].'
    description = 'The ClockQuality as specified in Sections 5.3.7, 7.6.2.6 and\n                Table 7 of [IEEE 1588-2008].\n\n                The following values are not represented in the enumerated\n                values.\n\n                    0xF0-0xFE  For use by alternate PTP profiles\n                    0xFF       Reserved\n\n                It is important to note that section 7.1.1 RFC 2578 allows for\n                gaps and enumerate values to start with zero when indicated by\n                the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160))
    namedValues = NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOscillator", 160))

class PtpClockTxModeType(TextualConvention, Integer32):
    description = 'Transmission mode.\n\n                Unicast:       Using unicast communication channel.\n                Multicast:     Using Multicast communication channel.\n                multicast-mix: Using multicast-unicast communication channel'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unicast", 1), ("multicast", 2), ("multicastmix", 3))

class PtpClockType(TextualConvention, Integer32):
    reference = 'Section 6.5.1 PTP device types of [IEEE 1588-2008].'
    description = 'The clock types as defined in the MIB module description.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("ordinaryClock", 1), ("boundaryClock", 2), ("transparentClock", 3), ("boundaryNode", 4))

ptpMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 0))
ptpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1))
ptpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2))
ptpMIBSystemInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1))
ptpMIBClockInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2))
ptpSystemTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 1), )
if mibBuilder.loadTexts: ptpSystemTable.setStatus('current')
if mibBuilder.loadTexts: ptpSystemTable.setDescription('Table of count information about the PTP system for all\n                domains.')
ptpSystemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 1, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpDomainIndex"), (0, "AT-PTP-MIB", "ptpInstanceIndex"))
if mibBuilder.loadTexts: ptpSystemEntry.setStatus('current')
if mibBuilder.loadTexts: ptpSystemEntry.setDescription('An entry in the table, containing count information about a\n                single domain. New row entries are added when the PTP clock for\n                this domain is configured, while the unconfiguration of the PTP\n                clock removes it.')
ptpDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 1, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices. The Clock Domain is a logical\n                group of clocks and devices that synchronize with each other\n                using the PTP protocol.\n\n                0           Default domain\n                1           Alternate domain 1\n                2           Alternate domain 2\n                3           Alternate domain 3\n                4 - 127     User-defined domains\n                128 - 255   Reserved')
ptpInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 1, 1, 2), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpInstanceIndex.setDescription('This object specifies the instance of the Clock for this\n                domain.')
ptpDomainClockPortsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 1, 1, 3), Gauge32()).setUnits('ptp ports').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDomainClockPortsTotal.setStatus('current')
if mibBuilder.loadTexts: ptpDomainClockPortsTotal.setDescription('This object specifies the total number of clock ports\n                configured within a domain in the system.')
ptpSystemDomainTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 2), )
if mibBuilder.loadTexts: ptpSystemDomainTable.setStatus('current')
if mibBuilder.loadTexts: ptpSystemDomainTable.setDescription('Table of information about the PTP system for all clock modes\n                -- ordinary, boundary or transparent.')
ptpSystemDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 2, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpSystemDomainClockTypeIndex"))
if mibBuilder.loadTexts: ptpSystemDomainEntry.setStatus('current')
if mibBuilder.loadTexts: ptpSystemDomainEntry.setDescription('An entry in the table, containing information about a single\n                clock mode for the PTP system. A row entry gets added when PTP\n                clocks are configured on the node.')
ptpSystemDomainClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 2, 1, 1), PtpClockType())
if mibBuilder.loadTexts: ptpSystemDomainClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpSystemDomainClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpSystemDomainTotals = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 2, 1, 2), Unsigned32()).setUnits('domains').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpSystemDomainTotals.setStatus('current')
if mibBuilder.loadTexts: ptpSystemDomainTotals.setDescription('This object specifies the total number of PTP domains for this\n                particular clock type configured in this node.')
ptpSystemProfile = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 1, 3), PtpClockProfileType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpSystemProfile.setReference('Section 19.3 PTP profiles of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpSystemProfile.setStatus('current')
if mibBuilder.loadTexts: ptpSystemProfile.setDescription('This object specifies the PTP Profile implemented on the\n                system.')
ptpClockCurrentDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1), )
if mibBuilder.loadTexts: ptpClockCurrentDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSTable.setDescription('Table of information about the PTP clock Current Datasets for\n                all domains.')
ptpClockCurrentDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockCurrentDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockCurrentDSClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockCurrentDSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockCurrentDSEntry.setReference('[IEEE 1588-2008] Section 8.2.2 currentDS data set member\n                specifications of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockCurrentDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSEntry.setDescription('An entry in the table, containing information about a single\n                PTP clock Current Datasets for a domain.')
ptpClockCurrentDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockCurrentDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockCurrentDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockCurrentDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpClockCurrentDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockCurrentDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockCurrentDSStepsRemoved = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 4), Unsigned32()).setUnits('Steps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockCurrentDSStepsRemoved.setReference('Section 8.2.2.2 stepsRemoved of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockCurrentDSStepsRemoved.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSStepsRemoved.setDescription('The current clock dataset StepsRemoved value.\n\n                This object specifies the distance measured by the number of\n                Boundary clocks between the local clock and the Foreign master\n                as indicated in the stepsRemoved field of Announce messages.')
ptpClockCurrentDSOffsetFromMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 5), PtpClockTimeInterval()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockCurrentDSOffsetFromMaster.setReference('Section 8.2.2.3 currentDS.offsetFromMaster of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockCurrentDSOffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSOffsetFromMaster.setDescription('This object specifies the current clock dataset ClockOffset\n                value. The value of the computation of the offset in time\n                between a slave and a master clock.')
ptpClockCurrentDSMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 1, 1, 6), PtpClockTimeInterval()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockCurrentDSMeanPathDelay.setReference('Section 8.2.2.4 currentDS.meanPathDelay of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockCurrentDSMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: ptpClockCurrentDSMeanPathDelay.setDescription('This object specifies the current clock dataset MeanPathDelay\n                value.\n\n                The mean path delay between a pair of ports as measured by the\n                delay request-response mechanism.')
ptpClockParentDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2), )
if mibBuilder.loadTexts: ptpClockParentDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSTable.setDescription('Table of information about the PTP clock Parent Datasets for\n                all domains.')
ptpClockParentDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockParentDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockParentDSClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockParentDSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockParentDSEntry.setReference('Section 8.2.3 parentDS data set member specifications of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSEntry.setDescription('An entry in the table, containing information about a single\n                PTP clock Parent Datasets for a domain.')
ptpClockParentDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockParentDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockParentDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockParentDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpClockParentDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockParentDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockParentDSParentPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSParentPortIdentity.setReference('Section 8.2.3.2 parentDS.parentPortIdentity of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSParentPortIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSParentPortIdentity.setDescription('This object specifies the value of portIdentity of the port on\n                the master that issues the Sync messages used in synchronizing\n                this clock.')
ptpClockParentDSParentStats = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSParentStats.setReference('Section 8.2.3.3 parentDS.parentStats of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSParentStats.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSParentStats.setDescription('This object specifies the Parent Dataset ParentStats value.\n\n                This value indicates whether the values of ParentDSOffset\n                and ParentDSClockPhChRate have been measured and are valid.\n                A TRUE value shall indicate valid data.')
ptpClockParentDSOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 6), PtpClockIntervalBase2().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSOffset.setReference('Section 8.2.3.4\n                parentDS.observedParentOffsetScaledLogVariance\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSOffset.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSOffset.setDescription("This object specifies the Parent Dataset\n                ParentOffsetScaledLogVariance value.\n\n                This value is the variance of the parent clock's phase as\n                measured by the local clock.")
ptpClockParentDSClockPhChRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSClockPhChRate.setReference('Section 8.2.3.5\n                parentDS.observedParentClockPhaseChangeRate of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSClockPhChRate.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSClockPhChRate.setDescription("This object specifies the clock's parent dataset\n                ParentClockPhaseChangeRate value.\n\n                This value is an estimate of the parent clock's phase change\n                rate as measured by the slave clock.")
ptpClockParentDSGMClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 8), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockIdentity.setReference('Section 8.2.3.6 parentDS.grandmasterIdentity of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockIdentity.setDescription('This object specifies the parent dataset Grandmaster clock\n                identity.')
ptpClockParentDSGMClockPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority1.setReference('Section 8.2.3.8 parentDS.grandmasterPriority1 of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority1.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority1.setDescription('This object specifies the parent dataset Grandmaster clock\n                priority1.')
ptpClockParentDSGMClockPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority2.setReference('Section 8.2.3.9 parentDS.grandmasterPriority2 of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority2.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockPriority2.setDescription('This object specifies the parent dataset grandmaster clock\n                priority2.')
ptpClockParentDSGMClockQualityClass = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 11), PtpClockQualityClassType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityClass.setReference('Section 8.2.3.7 parentDS.grandmasterClockQuality of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityClass.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityClass.setDescription('This object specifies the parent dataset grandmaster clock\n                quality class.')
ptpClockParentDSGMClockQualityAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 12), PtpClockQualityAccuracyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityAccuracy.setReference('Section 8.2.3.7 parentDS.grandmasterClockQuality of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityAccuracy.setDescription('This object specifies the parent dataset grandmaster clock\n                quality accuracy.')
ptpClockParentDSGMClockQualityOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityOffset.setReference('Section 8.2.3.7 parentDS.grandmasterClockQuality of\n                 [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityOffset.setStatus('current')
if mibBuilder.loadTexts: ptpClockParentDSGMClockQualityOffset.setDescription('This object specifies the parent dataset grandmaster clock\n                quality offset.')
ptpClockDefaultDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3), )
if mibBuilder.loadTexts: ptpClockDefaultDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSTable.setDescription('Table of information about the PTP clock Default Datasets for\n                all domains.')
ptpClockDefaultDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockDefaultDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockDefaultDSClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockDefaultDSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockDefaultDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSEntry.setDescription('An entry in the table, containing information about a single\n                PTP clock Default Datasets for a domain.')
ptpClockDefaultDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockDefaultDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockDefaultDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockDefaultDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual\n                convention description.')
ptpClockDefaultDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockDefaultDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockDefaultDSTwoStepFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSTwoStepFlag.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSTwoStepFlag.setDescription('This object specifies whether the Two Step process is used.')
ptpClockDefaultDSClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 5), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSClockIdentity.setDescription('This object specifies the default Datasets clock identity.')
ptpClockDefaultDSPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSPriority1.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSPriority1.setDescription('This object specifies the default Datasets clock Priority1.')
ptpClockDefaultDSPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSPriority2.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSPriority2.setDescription('This object specifies the default Datasets clock Priority2.')
ptpClockDefaultDSSlaveOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSSlaveOnly.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSSlaveOnly.setDescription('Whether the SlaveOnly flag is set.')
ptpClockDefaultDSQualityClass = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 9), PtpClockQualityClassType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSQualityClass.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSQualityClass.setDescription('This object specifies the default dataset Quality Class.')
ptpClockDefaultDSQualityAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 10), PtpClockQualityAccuracyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSQualityAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSQualityAccuracy.setDescription('This object specifies the default dataset Quality Accuracy.')
ptpClockDefaultDSQualityOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDefaultDSQualityOffset.setStatus('current')
if mibBuilder.loadTexts: ptpClockDefaultDSQualityOffset.setDescription('This object specifies the default dataset Quality offset.')
ptpClockRunningTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4), )
if mibBuilder.loadTexts: ptpClockRunningTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningTable.setDescription('Table of information about the PTP clock Running Datasets for\n                all domains.')
ptpClockRunningEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockRunningDomainIndex"), (0, "AT-PTP-MIB", "ptpClockRunningClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockRunningInstanceIndex"))
if mibBuilder.loadTexts: ptpClockRunningEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningEntry.setDescription('An entry in the table, containing information about a single\n                PTP clock running Datasets for a domain.')
ptpClockRunningDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockRunningDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningDomainIndex.setDescription('This object specifies the domain number used to create a\n                Logical group of PTP devices.')
ptpClockRunningClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockRunningClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpClockRunningInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockRunningInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockRunningState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 4), PtpClockStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockRunningState.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningState.setDescription('This object specifies the Clock state returned by a PTP engine\n                which was described earlier.\n\n                Freerun state.  Applies to a slave device that is not locked to\n                a master.  This is the initial state a slave starts out with\n                when it is not getting any PTP packets from the master, or\n                because of some other input error (erroneous packets, etc).\n\n                Holdover state.  In this state the slave device is locked to a\n                master but communication with the master has been lost or the\n                timestamps in the PTP packets are incorrect.  Since the\n                slave was previously locked to the master, it can run in this\n                state, with similar accuracy for some time.  If communication\n                with the master is not restored for an extended period\n                (dependent on the clock implementation), the device should move\n                to the FREERUN state.\n\n                Acquiring state. The slave device is receiving packets from a\n                master and is trying to acquire a lock.\n\n                Freq_locked state. Slave device is locked to the Master with\n                respect to frequency, but not phase aligned.\n\n                Phase_aligned state. Locked to the master with respect to\n                frequency and phase.')
ptpClockRunningPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockRunningPacketsSent.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningPacketsSent.setDescription('This object specifies the total number of all unicast and\n                multicast packets that have been sent out for this clock in this\n                domain for this type. These counters are discontinuous.')
ptpClockRunningPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockRunningPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: ptpClockRunningPacketsReceived.setDescription('This object specifies the total number of all unicast and\n                multicast packets that have been received for this clock in this\n                domain for this type. These counters are discontinuous.')
ptpClockTimePropertiesDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5), )
if mibBuilder.loadTexts: ptpClockTimePropertiesDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSTable.setDescription('Table of information about the PTP clock time properties\n                datasets for all domains.')
ptpClockTimePropertiesDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockTimePropertiesDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockTimePropertiesDSClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockTimePropertiesDSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockTimePropertiesDSEntry.setReference('Section 8.2.4 timePropertiesDS data set member specifications\n                of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSEntry.setDescription('An entry in the table, containing information about a single\n                PTP clock timeproperties Datasets for a domain.')
ptpClockTimePropertiesDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockTimePropertiesDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockTimePropertiesDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockTimePropertiesDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpClockTimePropertiesDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockTimePropertiesDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockTimePropertiesDSCurrentUTCOffsetValid = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffsetValid.setReference('Section 8.2.4.2 timePropertiesDS.currentUtcOffset of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffsetValid.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffsetValid.setDescription('This object specifies the timeproperties dataset value of\n                whether the current UTC offset is valid.')
ptpClockTimePropertiesDSCurrentUTCOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffset.setReference('Section 8.2.4.3 timePropertiesDS.currentUtcOffsetValid of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffset.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSCurrentUTCOffset.setDescription('This object specifies the timeproperties dataset value of\n                the current UTC offset.\n\n                In PTP systems whose epoch is the PTP epoch, the value of\n                timePropertiesDS.currentUtcOffset is the offset between TAI and\n                UTC; otherwise the value has no meaning. The value shall be in\n                units of seconds.\n\n                The initialization value shall be selected as follows:\n\n                a) If the timePropertiesDS.ptpTimescale (see 8.2.4.8) is TRUE,\n                the value is the value obtained from a primary reference if the\n                value is known at the time of initialization, else,\n                b) The value shall be the current number of leap seconds (7.2.3)\n                when the node is designed.')
ptpClockTimePropertiesDSLeap59 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap59.setReference('Section 8.2.4.4 timePropertiesDS.leap59 of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap59.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap59.setDescription('This object specifies the Leap59 value in the clock Current\n                Dataset.')
ptpClockTimePropertiesDSLeap61 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap61.setReference('Section 8.2.4.5 timePropertiesDS.leap61 of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap61.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSLeap61.setDescription('This object specifies the Leap61 value in the clock Current\n                Dataset.')
ptpClockTimePropertiesDSTimeTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSTimeTraceable.setReference('Section 8.2.4.6 timePropertiesDS.timeTraceable of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSTimeTraceable.setDescription('This object specifies the Time Traceable value in the clock\n                Current Dataset.')
ptpClockTimePropertiesDSFreqTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSFreqTraceable.setReference('Section 8.2.4.7 timePropertiesDS.frequencyTraceable of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSFreqTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSFreqTraceable.setDescription('This object specifies the Frequency Traceable value in the\n                clock Current Dataset.')
ptpClockTimePropertiesDSPTPTimescale = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSPTPTimescale.setReference('Section 8.2.4.8 timePropertiesDS.ptpTimescale of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSPTPTimescale.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSPTPTimescale.setDescription('This object specifies the PTP Timescale value in the clock\n                Current Dataset.')
ptpClockTimePropertiesDSSource = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 5, 1, 11), PtpClockTimeSourceType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTimePropertiesDSSource.setReference('Section 8.2.4.9 timePropertiesDS.timeSource of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSSource.setStatus('current')
if mibBuilder.loadTexts: ptpClockTimePropertiesDSSource.setDescription('This object specifies the Timesource value in the clock Current\n                Dataset.')
ptpClockTransDefaultDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6), )
if mibBuilder.loadTexts: ptpClockTransDefaultDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSTable.setDescription('Table of information about the PTP Transparent clock Default\n                Datasets for all domains.')
ptpClockTransDefaultDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockTransDefaultDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockTransDefaultDSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockTransDefaultDSEntry.setReference('Section 8.3.2 transparentClockDefaultDS data set member\n                specifications of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTransDefaultDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSEntry.setDescription('An entry in the table, containing information about a single\n                PTP Transparent clock Default Datasets for a domain.')
ptpClockTransDefaultDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockTransDefaultDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockTransDefaultDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 2), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockTransDefaultDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockTransDefaultDSClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 3), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTransDefaultDSClockIdentity.setReference('Section 8.3.2.2.1 transparentClockDefaultDS.clockIdentity of\n               [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTransDefaultDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSClockIdentity.setDescription('This object specifies the value of the clockIdentity attribute\n                of the local clock.')
ptpClockTransDefaultDSNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTransDefaultDSNumOfPorts.setReference('Section 8.3.2.2.2 transparentClockDefaultDS.numberPorts of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTransDefaultDSNumOfPorts.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSNumOfPorts.setDescription('This object specifies the number of PTP ports of the device.\n                 These counters are discontinuous.')
ptpClockTransDefaultDSDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 5), PtpClockMechanismType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTransDefaultDSDelay.setReference('Section 8.3.2.3.1 transparentClockDefaultDS.delayMechanism of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTransDefaultDSDelay.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSDelay.setDescription('This object, if the transparent clock is an end-to-end\n                transparent clock, has the value of E2E; if the transparent\n                clock is a peer-to-peer transparent clock, the value shall be\n                P2P.')
ptpClockTransDefaultDSPrimaryDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 6, 1, 6), PtpClockDomainType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTransDefaultDSPrimaryDomain.setReference('Section 8.3.2.3.2 transparentClockDefaultDS.primaryDomain of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockTransDefaultDSPrimaryDomain.setStatus('current')
if mibBuilder.loadTexts: ptpClockTransDefaultDSPrimaryDomain.setDescription('This object specifies the value of the primary syntonization\n                domain. The initialization value shall be 0.')
ptpClockPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7), )
if mibBuilder.loadTexts: ptpClockPortTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTable.setDescription('Table of information about the clock ports for a particular\n                domain.')
ptpClockPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockPortDomainIndex"), (0, "AT-PTP-MIB", "ptpClockPortClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockPortClockInstanceIndex"), (0, "AT-PTP-MIB", "ptpClockPortTablePortNumberIndex"))
if mibBuilder.loadTexts: ptpClockPortEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortEntry.setDescription('An entry in the table, containing information about a single\n                clock port.')
ptpClockPortDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockPortDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockPortClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockPortClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual\n                convention description.')
ptpClockPortClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockPortClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockPortTablePortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 4), PtpClockPortNumber())
if mibBuilder.loadTexts: ptpClockPortTablePortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTablePortNumberIndex.setDescription('This object specifies the PTP Portnumber for this port.')
ptpClockPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortName.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortName.setDescription('This object specifies the PTP clock port name configured on the\n                node.')
ptpClockPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 6), PtpClockRoleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRole.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRole.setDescription('This object describes the current role (slave/master) of the\n                port.')
ptpClockPortSyncTwoStep = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortSyncTwoStep.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortSyncTwoStep.setDescription('This object specifies that two-step clock operation between\n                the PTP master and slave device is enabled.')
ptpClockPortCurrentPeerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 8), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortCurrentPeerAddressType.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentPeerAddressType.setDescription("This object specifies the current peer's network address type\n                 used for PTP communication.")
ptpClockPortCurrentPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 9), PtpClockPortTransportTypeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortCurrentPeerAddress.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentPeerAddress.setDescription("This object specifies the current peer's network address used\n                for PTP communication.")
ptpClockPortNumOfAssociatedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 7, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortNumOfAssociatedPorts.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortNumOfAssociatedPorts.setDescription('This object specifies -\n\n                For a master port - the number of PTP slave sessions (peers)\n                associated with this PTP port.\n\n                For a slave port - the number of masters available to this slave\n                port (might or might not be peered).')
ptpClockPortDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8), )
if mibBuilder.loadTexts: ptpClockPortDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSTable.setDescription('Table of information about the clock ports dataset for a\n                particular domain.')
ptpClockPortDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockPortDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockPortDSClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockPortDSClockInstanceIndex"), (0, "AT-PTP-MIB", "ptpClockPortDSPortNumberIndex"))
if mibBuilder.loadTexts: ptpClockPortDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSEntry.setDescription('An entry in the table, containing port dataset information for\n                a single clock port.')
ptpClockPortDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockPortDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockPortDSClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockPortDSClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n                Textual convention description.')
ptpClockPortDSClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockPortDSClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockPortDSPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 4), PtpClockPortNumber())
if mibBuilder.loadTexts: ptpClockPortDSPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSPortNumberIndex.setDescription('This object specifies the PTP portnumber associated with this\n                PTP port.')
ptpClockPortDSName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSName.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSName.setDescription('This object specifies the PTP clock port dataset name.')
ptpClockPortDSPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSPortIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSPortIdentity.setDescription('This object specifies the PTP clock port Identity.')
ptpClockPortDSlogAnnouncementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 7), PtpClockIntervalBase2()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSlogAnnouncementInterval.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSlogAnnouncementInterval.setDescription('This object specifies the Announce message transmission\n                interval associated with this clock port.')
ptpClockPortDSAnnounceRctTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSAnnounceRctTimeout.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSAnnounceRctTimeout.setDescription('This object specifies the Announce receipt timeout associated\n                with this clock port.')
ptpClockPortDSlogSyncInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 9), PtpClockIntervalBase2()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSlogSyncInterval.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSlogSyncInterval.setDescription('This object specifies the Sync message transmission interval.')
ptpClockPortDSMinDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSMinDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSMinDelayReqInterval.setDescription('This object specifies the Delay_Req message transmission\n                interval.')
ptpClockPortDSPeerDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSPeerDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSPeerDelayReqInterval.setDescription('This object specifies the Pdelay_Req message transmission\n                interval.')
ptpClockPortDSDelayMech = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 12), PtpClockMechanismType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSDelayMech.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSDelayMech.setDescription('This object specifies the delay mechanism used. If the clock\n                is an end-to-end clock, the value of the is e2e, else if the\n                clock is a peer to-peer clock, the value shall be p2p.')
ptpClockPortDSPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 13), PtpClockTimeInterval()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSPeerMeanPathDelay.setDescription('This object specifies the peer meanPathDelay.')
ptpClockPortDSGrantDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 14), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSGrantDuration.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSGrantDuration.setDescription('This object specifies the grant duration allocated by the\n                master.')
ptpClockPortDSPTPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 8, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortDSPTPVersion.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortDSPTPVersion.setDescription('This object specifies the PTP version being used.')
ptpClockPortRunningTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9), )
if mibBuilder.loadTexts: ptpClockPortRunningTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningTable.setDescription('Table of information about the clock ports running datasets for\n                a particular domain.')
ptpClockPortRunningEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockPortRunningDomainIndex"), (0, "AT-PTP-MIB", "ptpClockPortRunningClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockPortRunningClockInstanceIndex"), (0, "AT-PTP-MIB", "ptpClockPortRunningPortNumberIndex"))
if mibBuilder.loadTexts: ptpClockPortRunningEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningEntry.setDescription('An entry in the table, containing running dataset information\n                about a single clock port.')
ptpClockPortRunningDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockPortRunningDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningDomainIndex.setDescription('This object specifies the domain number used to create a\n                logical group of PTP devices.')
ptpClockPortRunningClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockPortRunningClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningClockTypeIndex.setDescription('This object specifies the clock type as defined in the Textual\n                convention description.')
ptpClockPortRunningClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockPortRunningClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockPortRunningPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 4), PtpClockPortNumber())
if mibBuilder.loadTexts: ptpClockPortRunningPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningPortNumberIndex.setDescription('This object specifies the PTP portnumber associated with this\n                clock port.')
ptpClockPortRunningName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningName.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningName.setDescription('This object specifies the PTP clock port name.')
ptpClockPortRunningState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 6), PtpClockPortState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningState.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningState.setDescription('This object specifies the port state returned by PTP engine.\n\n                initializing - In this state a port initializes\n                               its data sets, hardware, and\n                               communication facilities.\n                faulty       - The fault state of the protocol.\n                disabled     - The port shall not place any\n                               messages on its communication path.\n                listening    - The port is waiting for the\n                               announceReceiptTimeout to expire or\n                               to receive an Announce message from\n                               a master.\n                preMaster    - The port shall behave in all respects\n                               as though it were in the MASTER state\n                               except that it shall not place any\n                               messages on its communication path\n                               except for Pdelay_Req, Pdelay_Resp,\n                               Pdelay_Resp_Follow_Up, signaling, or\n                               management messages.\n                master       - The port is behaving as a master port.\n                passive      - The port shall not place any\n                               messages on its communication path\n                               except for Pdelay_Req, Pdelay_Resp,\n                               Pdelay_Resp_Follow_Up, or signaling\n                               messages, or management messages\n                               that are a required response to\n                               another management message\n                uncalibrated - The local port is preparing to\n                               synchronize to the master port.\n                slave        - The port is synchronizing to the\n                               selected master port.')
ptpClockPortRunningRole = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 7), PtpClockRoleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningRole.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningRole.setDescription('This object specifies the Clock Role.')
ptpClockPortRunningInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningInterfaceIndex.setDescription('This object specifies the interface on the node being used by\n                the PTP Clock for PTP communication.')
ptpClockPortRunningTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 9), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningTransport.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningTransport.setDescription('This object specifies the transport protocol being used for PTP\n                communication (the mapping used).')
ptpClockPortRunningEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 10), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningEncapsulationType.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningEncapsulationType.setDescription('This object specifies the type of encapsulation if the\n                interface is adding extra layers (e.g., VLAN, Pseudowire\n                encapsulation...) for the PTP messages.')
ptpClockPortRunningTxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 11), PtpClockTxModeType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningTxMode.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningTxMode.setDescription('This object specifies the clock transmission mode as\n\n                unicast:       Using unicast communication channel.\n                multicast:     Using Multicast communication channel.\n                multicast-mix: Using multicast-unicast communication channel')
ptpClockPortRunningRxMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 12), PtpClockTxModeType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningRxMode.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningRxMode.setDescription('This object specifies the clock receive mode as\n\n                unicast:       Using unicast communication channel.\n                multicast:     Using Multicast communication channel.\n                multicast-mix: Using multicast-unicast communication channel')
ptpClockPortRunningPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 13), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningPacketsReceived.setDescription('This object specifies the packets received on the clock port\n                (cumulative). These counters are discontinuous.')
ptpClockPortRunningPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 9, 1, 14), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortRunningPacketsSent.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortRunningPacketsSent.setDescription('This object specifies the packets sent on the clock port\n                (cumulative). These counters are discontinuous.')
ptpClockPortTransDSTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10), )
if mibBuilder.loadTexts: ptpClockPortTransDSTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSTable.setDescription('Table of information about the Transparent clock ports running\n                dataset for a particular domain.')
ptpClockPortTransDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockPortTransDSDomainIndex"), (0, "AT-PTP-MIB", "ptpClockPortTransDSInstanceIndex"), (0, "AT-PTP-MIB", "ptpClockPortTransDSPortNumberIndex"))
if mibBuilder.loadTexts: ptpClockPortTransDSEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSEntry.setDescription('An entry in the table, containing clock port Transparent\n                dataset information about a single clock port')
ptpClockPortTransDSDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockPortTransDSDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSDomainIndex.setDescription('This object specifies the domain number used to create a\n                Logical group of PTP devices.')
ptpClockPortTransDSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 2), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockPortTransDSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockPortTransDSPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 3), PtpClockPortNumber())
if mibBuilder.loadTexts: ptpClockPortTransDSPortNumberIndex.setReference('Section 7.5.2 Port Identity of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockPortTransDSPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSPortNumberIndex.setDescription('This object specifies the PTP port number associated with this\n                port.')
ptpClockPortTransDSPortIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 4), PtpClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortTransDSPortIdentity.setReference('Section 8.3.3.2.1 transparentClockPortDS.portIdentity of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockPortTransDSPortIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSPortIdentity.setDescription('This object specifies the value of the PortIdentity\n                attribute of the local port.')
ptpClockPortTransDSlogMinPdelayReqInt = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 5), PtpClockIntervalBase2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortTransDSlogMinPdelayReqInt.setReference('Section 8.3.3.3.1 transparentClockPortDS.logMinPdelayReqInterval\n                of [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockPortTransDSlogMinPdelayReqInt.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSlogMinPdelayReqInt.setDescription('This object specifies the value of the logarithm to the\n                base 2 of the minPdelayReqInterval.')
ptpClockPortTransDSFaultyFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortTransDSFaultyFlag.setReference('Section 8.3.3.3.2 transparentClockPortDS.faultyFlag of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockPortTransDSFaultyFlag.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSFaultyFlag.setDescription('This object specifies the value TRUE if the port is faulty\n                and FALSE if the port is operating normally.')
ptpClockPortTransDSPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 10, 1, 7), PtpClockTimeInterval()).setUnits('Time Interval').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortTransDSPeerMeanPathDelay.setReference('Section 8.3.3.3.3 transparentClockPortDS.peerMeanPathDelay of\n                [IEEE 1588-2008]')
if mibBuilder.loadTexts: ptpClockPortTransDSPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortTransDSPeerMeanPathDelay.setDescription('This object specifies, if the delayMechanism used is P2P, the\n                value of the estimate of the current one-way propagation delay,\n                i.e., <meanPathDelay> on the link attached to this port,\n                computed using the peer delay mechanism. If the value of the\n                delayMechanism used is E2E, then the value will be zero.')
ptpClockPortAssociateTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11), )
if mibBuilder.loadTexts: ptpClockPortAssociateTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateTable.setDescription("Table of information about a given port's associated ports.\n\n                For a master port: multiple slave ports that have established\n                                   sessions with the current master port.\n                For a slave port:  the list of masters available for a given\n                                   slave port.\n\n                Session information (packets, errors) to be displayed based on\n                availability and scenario.")
ptpWellKnownTransportTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12))
ptpTransportTypeIPversion4 = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 1))
if mibBuilder.loadTexts: ptpTransportTypeIPversion4.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeIPversion4.setDescription('IP version 4')
ptpTransportTypeIPversion6 = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 2))
if mibBuilder.loadTexts: ptpTransportTypeIPversion6.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeIPversion6.setDescription('IP version 6')
ptpTransportTypeEthernet = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 3))
if mibBuilder.loadTexts: ptpTransportTypeEthernet.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeEthernet.setDescription('Ethernet')
ptpTransportTypeDeviceNET = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 4))
if mibBuilder.loadTexts: ptpTransportTypeDeviceNET.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeDeviceNET.setDescription('Device NET')
ptpTransportTypeControlNET = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 5))
if mibBuilder.loadTexts: ptpTransportTypeControlNET.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeControlNET.setDescription('Control NET')
ptpTransportTypeIEC61158 = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 12, 6))
if mibBuilder.loadTexts: ptpTransportTypeIEC61158.setStatus('current')
if mibBuilder.loadTexts: ptpTransportTypeIEC61158.setDescription('IEC61158')
ptpWellKnownEncapsulationTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13))
ptpEncapsulationTypeEthernet = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13, 1))
if mibBuilder.loadTexts: ptpEncapsulationTypeEthernet.setStatus('current')
if mibBuilder.loadTexts: ptpEncapsulationTypeEthernet.setDescription('Ethernet Encapsulation type.')
ptpEncapsulationTypeVLAN = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13, 2))
if mibBuilder.loadTexts: ptpEncapsulationTypeVLAN.setStatus('current')
if mibBuilder.loadTexts: ptpEncapsulationTypeVLAN.setDescription('VLAN Encapsulation type.')
ptpEncapsulationTypeUDPIPLSP = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13, 3))
if mibBuilder.loadTexts: ptpEncapsulationTypeUDPIPLSP.setStatus('current')
if mibBuilder.loadTexts: ptpEncapsulationTypeUDPIPLSP.setDescription('UDP/IP over MPLS Encapsulation type.')
ptpEncapsulationTypePWUDPIPLSP = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13, 4))
if mibBuilder.loadTexts: ptpEncapsulationTypePWUDPIPLSP.setStatus('current')
if mibBuilder.loadTexts: ptpEncapsulationTypePWUDPIPLSP.setDescription('UDP/IP Pseudowire over MPLS Encapsulation type.')
ptpEncapsulationTypePWEthernetLSP = ObjectIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 13, 5))
if mibBuilder.loadTexts: ptpEncapsulationTypePWEthernetLSP.setStatus('current')
if mibBuilder.loadTexts: ptpEncapsulationTypePWEthernetLSP.setDescription('Ethernet Pseudowire over MPLS Encapsulation type.')
ptpClockPortAssociateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1), ).setIndexNames((0, "AT-PTP-MIB", "ptpClockPortCurrentDomainIndex"), (0, "AT-PTP-MIB", "ptpClockPortCurrentClockTypeIndex"), (0, "AT-PTP-MIB", "ptpClockPortCurrentClockInstanceIndex"), (0, "AT-PTP-MIB", "ptpClockPortCurrentPortNumberIndex"), (0, "AT-PTP-MIB", "ptpClockPortAssociatePortIndex"))
if mibBuilder.loadTexts: ptpClockPortAssociateEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateEntry.setDescription('An entry in the table, containing information about a single\n                associated port for the given clockport.')
ptpClockPortCurrentDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 1), PtpClockDomainType())
if mibBuilder.loadTexts: ptpClockPortCurrentDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentDomainIndex.setDescription("This object specifies the given port's domain number.")
ptpClockPortCurrentClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 2), PtpClockType())
if mibBuilder.loadTexts: ptpClockPortCurrentClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentClockTypeIndex.setDescription("This object specifies the given port's clock type.")
ptpClockPortCurrentClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 3), PtpClockInstanceType())
if mibBuilder.loadTexts: ptpClockPortCurrentClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentClockInstanceIndex.setDescription('This object specifies the instance of the clock for this clock\n                type in the given domain.')
ptpClockPortCurrentPortNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 4), PtpClockPortNumber())
if mibBuilder.loadTexts: ptpClockPortCurrentPortNumberIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortCurrentPortNumberIndex.setDescription('This object specifies the PTP Port Number for the given port.')
ptpClockPortAssociatePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ptpClockPortAssociatePortIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociatePortIndex.setDescription("This object specifies the associated port's serial number in\n                the current port's context.")
ptpClockPortAssociateAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 6), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociateAddressType.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateAddressType.setDescription("This object specifies the peer port's network address type used\n                for PTP communication. The OCTET STRING representation of the\n                OID of ptpWellKnownTransportTypes will be used in the values\n                contained in the OCTET STRING.")
ptpClockPortAssociateAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 7), PtpClockPortTransportTypeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociateAddress.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateAddress.setDescription("This object specifies the peer port's network address used for\n                PTP communication.")
ptpClockPortAssociatePacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 8), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociatePacketsSent.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociatePacketsSent.setDescription('The number of packets sent to this peer port from the current\n                port. These counters are discontinuous.')
ptpClockPortAssociatePacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 9), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociatePacketsReceived.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociatePacketsReceived.setDescription('The number of packets received from this peer port by the\n                current port. These counters are discontinuous.')
ptpClockPortAssociateInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociateInErrors.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateInErrors.setDescription('This object specifies the input errors associated with the\n                peer port. These counters are discontinuous.')
ptpClockPortAssociateOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 1, 2, 11, 1, 11), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPortAssociateOutErrors.setStatus('current')
if mibBuilder.loadTexts: ptpClockPortAssociateOutErrors.setDescription('This object specifies the output errors associated with the\n                peer port. These counters are discontinuous.')
ptpMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 1))
ptpMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2))
ptpMIBCompliancesSystemInfo = ModuleCompliance((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 1, 1)).setObjects(("AT-PTP-MIB", "ptpMIBSystemInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBCompliancesSystemInfo = ptpMIBCompliancesSystemInfo.setStatus('current')
if mibBuilder.loadTexts: ptpMIBCompliancesSystemInfo.setDescription('Compliance statement for agents that provide read-only support\n                for PTPBASE-MIB to provide system level information of clock\n                devices. Such devices can only be monitored using this MIB\n                module.\n\n                The Module is implemented with support for read-only.  In other\n                words, only monitoring is available by implementing this\n                MODULE-COMPLIANCE.')
ptpMIBCompliancesClockInfo = ModuleCompliance((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 1, 2)).setObjects(("AT-PTP-MIB", "ptpMIBClockCurrentDSGroup"), ("AT-PTP-MIB", "ptpMIBClockParentDSGroup"), ("AT-PTP-MIB", "ptpMIBClockDefaultDSGroup"), ("AT-PTP-MIB", "ptpMIBClockRunningGroup"), ("AT-PTP-MIB", "ptpMIBClockTimepropertiesGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBCompliancesClockInfo = ptpMIBCompliancesClockInfo.setStatus('current')
if mibBuilder.loadTexts: ptpMIBCompliancesClockInfo.setDescription('Compliance statement for agents that provide read-only support\n                for PTPBASE-MIB to provide clock related information.\n                Such devices can only be monitored using this MIB module.\n\n                The Module is implemented with support for read-only. In other\n                words, only monitoring is available by implementing this\n                MODULE-COMPLIANCE.')
ptpMIBCompliancesClockPortInfo = ModuleCompliance((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 1, 3)).setObjects(("AT-PTP-MIB", "ptpMIBClockPortGroup"), ("AT-PTP-MIB", "ptpMIBClockPortDSGroup"), ("AT-PTP-MIB", "ptpMIBClockPortRunningGroup"), ("AT-PTP-MIB", "ptpMIBClockPortAssociateGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBCompliancesClockPortInfo = ptpMIBCompliancesClockPortInfo.setStatus('current')
if mibBuilder.loadTexts: ptpMIBCompliancesClockPortInfo.setDescription('Compliance statement for agents that provide read-only support\n                for PTPBASE-MIB to provide clock port related information.\n                Such devices can only be monitored using this MIB module.\n\n                The Module is implemented with support for read-only. In other\n                words, only monitoring is available by implementing this\n                MODULE-COMPLIANCE.')
ptpMIBCompliancesTransparentClockInfo = ModuleCompliance((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 1, 4)).setObjects(("AT-PTP-MIB", "ptpMIBClockTranparentDSGroup"), ("AT-PTP-MIB", "ptpMIBClockPortTransDSGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBCompliancesTransparentClockInfo = ptpMIBCompliancesTransparentClockInfo.setStatus('current')
if mibBuilder.loadTexts: ptpMIBCompliancesTransparentClockInfo.setDescription('Compliance statement for agents that provide read-only support\n                for PTPBASE-MIB to provide Transparent clock related\n                information. Such devices can only be monitored using this MIB\n                module.\n\n                The Module is implemented with support for read-only. In other\n                words, only monitoring is available by implementing this\n                MODULE-COMPLIANCE.')
ptpMIBSystemInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 1)).setObjects(("AT-PTP-MIB", "ptpSystemDomainTotals"), ("AT-PTP-MIB", "ptpDomainClockPortsTotal"), ("AT-PTP-MIB", "ptpSystemProfile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBSystemInfoGroup = ptpMIBSystemInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBSystemInfoGroup.setDescription('Group which aggregates objects describing system-wide\n                information')
ptpMIBClockCurrentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 2)).setObjects(("AT-PTP-MIB", "ptpClockCurrentDSStepsRemoved"), ("AT-PTP-MIB", "ptpClockCurrentDSOffsetFromMaster"), ("AT-PTP-MIB", "ptpClockCurrentDSMeanPathDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockCurrentDSGroup = ptpMIBClockCurrentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockCurrentDSGroup.setDescription('Group which aggregates objects describing PTP Current Dataset\n                information')
ptpMIBClockParentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 3)).setObjects(("AT-PTP-MIB", "ptpClockParentDSParentPortIdentity"), ("AT-PTP-MIB", "ptpClockParentDSParentStats"), ("AT-PTP-MIB", "ptpClockParentDSOffset"), ("AT-PTP-MIB", "ptpClockParentDSClockPhChRate"), ("AT-PTP-MIB", "ptpClockParentDSGMClockIdentity"), ("AT-PTP-MIB", "ptpClockParentDSGMClockPriority1"), ("AT-PTP-MIB", "ptpClockParentDSGMClockPriority2"), ("AT-PTP-MIB", "ptpClockParentDSGMClockQualityClass"), ("AT-PTP-MIB", "ptpClockParentDSGMClockQualityAccuracy"), ("AT-PTP-MIB", "ptpClockParentDSGMClockQualityOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockParentDSGroup = ptpMIBClockParentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockParentDSGroup.setDescription('Group which aggregates objects describing PTP Parent Dataset\n                information')
ptpMIBClockDefaultDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 4)).setObjects(("AT-PTP-MIB", "ptpClockDefaultDSTwoStepFlag"), ("AT-PTP-MIB", "ptpClockDefaultDSClockIdentity"), ("AT-PTP-MIB", "ptpClockDefaultDSPriority1"), ("AT-PTP-MIB", "ptpClockDefaultDSPriority2"), ("AT-PTP-MIB", "ptpClockDefaultDSSlaveOnly"), ("AT-PTP-MIB", "ptpClockDefaultDSQualityClass"), ("AT-PTP-MIB", "ptpClockDefaultDSQualityAccuracy"), ("AT-PTP-MIB", "ptpClockDefaultDSQualityOffset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockDefaultDSGroup = ptpMIBClockDefaultDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockDefaultDSGroup.setDescription('Group which aggregates objects describing PTP Default Dataset\n                information')
ptpMIBClockRunningGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 5)).setObjects(("AT-PTP-MIB", "ptpClockRunningState"), ("AT-PTP-MIB", "ptpClockRunningPacketsSent"), ("AT-PTP-MIB", "ptpClockRunningPacketsReceived"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockRunningGroup = ptpMIBClockRunningGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockRunningGroup.setDescription('Group which aggregates objects describing PTP running state\n                information')
ptpMIBClockTimepropertiesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 6)).setObjects(("AT-PTP-MIB", "ptpClockTimePropertiesDSCurrentUTCOffsetValid"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSCurrentUTCOffset"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSLeap59"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSLeap61"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSTimeTraceable"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSFreqTraceable"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSPTPTimescale"), ("AT-PTP-MIB", "ptpClockTimePropertiesDSSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockTimepropertiesGroup = ptpMIBClockTimepropertiesGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockTimepropertiesGroup.setDescription('Group which aggregates objects describing PTP Time Properties\n                information')
ptpMIBClockTranparentDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 7)).setObjects(("AT-PTP-MIB", "ptpClockTransDefaultDSClockIdentity"), ("AT-PTP-MIB", "ptpClockTransDefaultDSNumOfPorts"), ("AT-PTP-MIB", "ptpClockTransDefaultDSDelay"), ("AT-PTP-MIB", "ptpClockTransDefaultDSPrimaryDomain"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockTranparentDSGroup = ptpMIBClockTranparentDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockTranparentDSGroup.setDescription('Group which aggregates objects describing PTP Transparent\n                Dataset information')
ptpMIBClockPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 8)).setObjects(("AT-PTP-MIB", "ptpClockPortName"), ("AT-PTP-MIB", "ptpClockPortSyncTwoStep"), ("AT-PTP-MIB", "ptpClockPortCurrentPeerAddress"), ("AT-PTP-MIB", "ptpClockPortNumOfAssociatedPorts"), ("AT-PTP-MIB", "ptpClockPortCurrentPeerAddressType"), ("AT-PTP-MIB", "ptpClockPortRole"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockPortGroup = ptpMIBClockPortGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockPortGroup.setDescription('Group which aggregates objects describing information for a\n                given PTP Port.')
ptpMIBClockPortDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 9)).setObjects(("AT-PTP-MIB", "ptpClockPortDSName"), ("AT-PTP-MIB", "ptpClockPortDSPortIdentity"), ("AT-PTP-MIB", "ptpClockPortDSlogAnnouncementInterval"), ("AT-PTP-MIB", "ptpClockPortDSAnnounceRctTimeout"), ("AT-PTP-MIB", "ptpClockPortDSlogSyncInterval"), ("AT-PTP-MIB", "ptpClockPortDSMinDelayReqInterval"), ("AT-PTP-MIB", "ptpClockPortDSPeerDelayReqInterval"), ("AT-PTP-MIB", "ptpClockPortDSDelayMech"), ("AT-PTP-MIB", "ptpClockPortDSPeerMeanPathDelay"), ("AT-PTP-MIB", "ptpClockPortDSGrantDuration"), ("AT-PTP-MIB", "ptpClockPortDSPTPVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockPortDSGroup = ptpMIBClockPortDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockPortDSGroup.setDescription('Group which aggregates objects describing PTP Port Dataset\n                information')
ptpMIBClockPortRunningGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 10)).setObjects(("AT-PTP-MIB", "ptpClockPortRunningName"), ("AT-PTP-MIB", "ptpClockPortRunningState"), ("AT-PTP-MIB", "ptpClockPortRunningRole"), ("AT-PTP-MIB", "ptpClockPortRunningInterfaceIndex"), ("AT-PTP-MIB", "ptpClockPortRunningTransport"), ("AT-PTP-MIB", "ptpClockPortRunningEncapsulationType"), ("AT-PTP-MIB", "ptpClockPortRunningTxMode"), ("AT-PTP-MIB", "ptpClockPortRunningRxMode"), ("AT-PTP-MIB", "ptpClockPortRunningPacketsReceived"), ("AT-PTP-MIB", "ptpClockPortRunningPacketsSent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockPortRunningGroup = ptpMIBClockPortRunningGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockPortRunningGroup.setDescription('Group which aggregates objects describing PTP running interface\n                information')
ptpMIBClockPortTransDSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 11)).setObjects(("AT-PTP-MIB", "ptpClockPortTransDSPortIdentity"), ("AT-PTP-MIB", "ptpClockPortTransDSlogMinPdelayReqInt"), ("AT-PTP-MIB", "ptpClockPortTransDSFaultyFlag"), ("AT-PTP-MIB", "ptpClockPortTransDSPeerMeanPathDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockPortTransDSGroup = ptpMIBClockPortTransDSGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockPortTransDSGroup.setDescription('Group which aggregates objects describing PTP TransparentDS\n                information')
ptpMIBClockPortAssociateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 504, 2, 2, 12)).setObjects(("AT-PTP-MIB", "ptpClockPortAssociatePacketsSent"), ("AT-PTP-MIB", "ptpClockPortAssociatePacketsReceived"), ("AT-PTP-MIB", "ptpClockPortAssociateAddress"), ("AT-PTP-MIB", "ptpClockPortAssociateAddressType"), ("AT-PTP-MIB", "ptpClockPortAssociateInErrors"), ("AT-PTP-MIB", "ptpClockPortAssociateOutErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpMIBClockPortAssociateGroup = ptpMIBClockPortAssociateGroup.setStatus('current')
if mibBuilder.loadTexts: ptpMIBClockPortAssociateGroup.setDescription('Group which aggregates objects describing information on peer\n                PTP ports for a given PTP clock-port.')
mibBuilder.exportSymbols("AT-PTP-MIB", ptpClockPortRunningPortNumberIndex=ptpClockPortRunningPortNumberIndex, PtpClockIntervalBase2=PtpClockIntervalBase2, ptpClockPortDSClockInstanceIndex=ptpClockPortDSClockInstanceIndex, ptpClockRunningClockTypeIndex=ptpClockRunningClockTypeIndex, ptpClockPortAssociatePortIndex=ptpClockPortAssociatePortIndex, ptpMIBNotifs=ptpMIBNotifs, ptpClockRunningTable=ptpClockRunningTable, ptpMIBConformance=ptpMIBConformance, ptpClockPortName=ptpClockPortName, ptpSystemDomainTable=ptpSystemDomainTable, ptpClockCurrentDSTable=ptpClockCurrentDSTable, ptpMIBCompliancesClockPortInfo=ptpMIBCompliancesClockPortInfo, ptpMIBObjects=ptpMIBObjects, PtpClockPortState=PtpClockPortState, ptpClockPortCurrentPeerAddress=ptpClockPortCurrentPeerAddress, ptpClockPortDSPortNumberIndex=ptpClockPortDSPortNumberIndex, ptpClockPortCurrentPeerAddressType=ptpClockPortCurrentPeerAddressType, ptpClockPortDSPortIdentity=ptpClockPortDSPortIdentity, ptpMIBSystemInfoGroup=ptpMIBSystemInfoGroup, ptpClockDefaultDSTable=ptpClockDefaultDSTable, ptpClockCurrentDSStepsRemoved=ptpClockCurrentDSStepsRemoved, ptpClockPortRole=ptpClockPortRole, ptpSystemEntry=ptpSystemEntry, ptpClockPortDSPTPVersion=ptpClockPortDSPTPVersion, ptpEncapsulationTypeEthernet=ptpEncapsulationTypeEthernet, ptpClockTimePropertiesDSTable=ptpClockTimePropertiesDSTable, ptpClockPortRunningEncapsulationType=ptpClockPortRunningEncapsulationType, ptpMIBCompliancesClockInfo=ptpMIBCompliancesClockInfo, ptpClockCurrentDSInstanceIndex=ptpClockCurrentDSInstanceIndex, ptpClockPortNumOfAssociatedPorts=ptpClockPortNumOfAssociatedPorts, ptpClockParentDSGMClockPriority2=ptpClockParentDSGMClockPriority2, ptpTransportTypeControlNET=ptpTransportTypeControlNET, ptpMIBClockRunningGroup=ptpMIBClockRunningGroup, ptpMIBClockPortAssociateGroup=ptpMIBClockPortAssociateGroup, ptpClockPortDSEntry=ptpClockPortDSEntry, ptpClockPortCurrentClockTypeIndex=ptpClockPortCurrentClockTypeIndex, ptpMIBClockCurrentDSGroup=ptpMIBClockCurrentDSGroup, ptpClockPortDSTable=ptpClockPortDSTable, PtpClockQualityAccuracyType=PtpClockQualityAccuracyType, ptpClockDefaultDSQualityOffset=ptpClockDefaultDSQualityOffset, ptpClockPortTransDSlogMinPdelayReqInt=ptpClockPortTransDSlogMinPdelayReqInt, ptpClockParentDSClockPhChRate=ptpClockParentDSClockPhChRate, ptpClockPortTransDSInstanceIndex=ptpClockPortTransDSInstanceIndex, ptpClockTransDefaultDSDomainIndex=ptpClockTransDefaultDSDomainIndex, ptpClockRunningState=ptpClockRunningState, ptpClockPortRunningPacketsReceived=ptpClockPortRunningPacketsReceived, ptpClockRunningInstanceIndex=ptpClockRunningInstanceIndex, ptpClockTimePropertiesDSInstanceIndex=ptpClockTimePropertiesDSInstanceIndex, ptpClockPortDSPeerMeanPathDelay=ptpClockPortDSPeerMeanPathDelay, PtpClockQualityClassType=PtpClockQualityClassType, ptpClockTransDefaultDSInstanceIndex=ptpClockTransDefaultDSInstanceIndex, ptpDomainClockPortsTotal=ptpDomainClockPortsTotal, ptpDomainIndex=ptpDomainIndex, ptpClockTimePropertiesDSLeap61=ptpClockTimePropertiesDSLeap61, PtpClockStateType=PtpClockStateType, PtpClockRoleType=PtpClockRoleType, ptpEncapsulationTypeVLAN=ptpEncapsulationTypeVLAN, ptpClockPortRunningTransport=ptpClockPortRunningTransport, ptpClockPortAssociateInErrors=ptpClockPortAssociateInErrors, ptpMIBCompliancesSystemInfo=ptpMIBCompliancesSystemInfo, ptpClockDefaultDSClockTypeIndex=ptpClockDefaultDSClockTypeIndex, PtpClockPortNumber=PtpClockPortNumber, PtpClockMechanismType=PtpClockMechanismType, ptpClockRunningPacketsReceived=ptpClockRunningPacketsReceived, ptpSystemTable=ptpSystemTable, ptpClockPortTransDSEntry=ptpClockPortTransDSEntry, ptpClockParentDSGMClockQualityClass=ptpClockParentDSGMClockQualityClass, ptpClockPortCurrentPortNumberIndex=ptpClockPortCurrentPortNumberIndex, ptpClockTimePropertiesDSPTPTimescale=ptpClockTimePropertiesDSPTPTimescale, ptpMIBClockParentDSGroup=ptpMIBClockParentDSGroup, ptpClockPortRunningInterfaceIndex=ptpClockPortRunningInterfaceIndex, ptpMIBClockTimepropertiesGroup=ptpMIBClockTimepropertiesGroup, ptpClockPortClockInstanceIndex=ptpClockPortClockInstanceIndex, ptpClockParentDSParentPortIdentity=ptpClockParentDSParentPortIdentity, ptpClockTimePropertiesDSClockTypeIndex=ptpClockTimePropertiesDSClockTypeIndex, ptpClockDefaultDSQualityClass=ptpClockDefaultDSQualityClass, ptpTransportTypeIPversion6=ptpTransportTypeIPversion6, ptpClockDefaultDSInstanceIndex=ptpClockDefaultDSInstanceIndex, ptpInstanceIndex=ptpInstanceIndex, ptpClockDefaultDSDomainIndex=ptpClockDefaultDSDomainIndex, ptpClockTimePropertiesDSEntry=ptpClockTimePropertiesDSEntry, ptpClockParentDSClockTypeIndex=ptpClockParentDSClockTypeIndex, ptpClockPortTransDSPortNumberIndex=ptpClockPortTransDSPortNumberIndex, ptpClockParentDSTable=ptpClockParentDSTable, ptpClockDefaultDSEntry=ptpClockDefaultDSEntry, ptpClockParentDSGMClockIdentity=ptpClockParentDSGMClockIdentity, ptpClockPortTransDSPortIdentity=ptpClockPortTransDSPortIdentity, ptpClockPortTransDSPeerMeanPathDelay=ptpClockPortTransDSPeerMeanPathDelay, ptpMIBClockPortDSGroup=ptpMIBClockPortDSGroup, ptpClockPortRunningName=ptpClockPortRunningName, ptpSystemDomainTotals=ptpSystemDomainTotals, PtpClockProfileType=PtpClockProfileType, ptpMIBSystemInfo=ptpMIBSystemInfo, ptpClockPortDSMinDelayReqInterval=ptpClockPortDSMinDelayReqInterval, ptpClockPortRunningEntry=ptpClockPortRunningEntry, ptpClockPortEntry=ptpClockPortEntry, ptpClockPortDSAnnounceRctTimeout=ptpClockPortDSAnnounceRctTimeout, ptpClockTimePropertiesDSFreqTraceable=ptpClockTimePropertiesDSFreqTraceable, ptpClockPortCurrentDomainIndex=ptpClockPortCurrentDomainIndex, ptpWellKnownTransportTypes=ptpWellKnownTransportTypes, PtpClockInstanceType=PtpClockInstanceType, ptpClockTransDefaultDSTable=ptpClockTransDefaultDSTable, ptpClockPortRunningState=ptpClockPortRunningState, ptpEncapsulationTypePWEthernetLSP=ptpEncapsulationTypePWEthernetLSP, ptpClockCurrentDSClockTypeIndex=ptpClockCurrentDSClockTypeIndex, ptpClockPortRunningDomainIndex=ptpClockPortRunningDomainIndex, ptpClockPortClockTypeIndex=ptpClockPortClockTypeIndex, ptpClockPortAssociateOutErrors=ptpClockPortAssociateOutErrors, ptpClockRunningEntry=ptpClockRunningEntry, ptpClockTimePropertiesDSDomainIndex=ptpClockTimePropertiesDSDomainIndex, ptpClockPortDSlogSyncInterval=ptpClockPortDSlogSyncInterval, ptpClockRunningDomainIndex=ptpClockRunningDomainIndex, ptpMIBCompliances=ptpMIBCompliances, ptpClockDefaultDSSlaveOnly=ptpClockDefaultDSSlaveOnly, ptpClockParentDSEntry=ptpClockParentDSEntry, ptpSystemDomainEntry=ptpSystemDomainEntry, ptpSystemProfile=ptpSystemProfile, ptpClockDefaultDSPriority2=ptpClockDefaultDSPriority2, ptpClockTimePropertiesDSSource=ptpClockTimePropertiesDSSource, ptpClockTransDefaultDSNumOfPorts=ptpClockTransDefaultDSNumOfPorts, ptpClockPortTransDSTable=ptpClockPortTransDSTable, ptpMIBCompliancesTransparentClockInfo=ptpMIBCompliancesTransparentClockInfo, PtpClockTxModeType=PtpClockTxModeType, PtpClockTimeInterval=PtpClockTimeInterval, ptpClockParentDSInstanceIndex=ptpClockParentDSInstanceIndex, ptpClockParentDSGMClockPriority1=ptpClockParentDSGMClockPriority1, ptpEncapsulationTypePWUDPIPLSP=ptpEncapsulationTypePWUDPIPLSP, ptpClockCurrentDSDomainIndex=ptpClockCurrentDSDomainIndex, ptpClockParentDSOffset=ptpClockParentDSOffset, ptpClockTransDefaultDSEntry=ptpClockTransDefaultDSEntry, ptpMIBGroups=ptpMIBGroups, ptpClockDefaultDSClockIdentity=ptpClockDefaultDSClockIdentity, ptpClockPortRunningClockInstanceIndex=ptpClockPortRunningClockInstanceIndex, atPtpMIB=atPtpMIB, ptpClockCurrentDSEntry=ptpClockCurrentDSEntry, ptpClockPortSyncTwoStep=ptpClockPortSyncTwoStep, ptpClockTransDefaultDSDelay=ptpClockTransDefaultDSDelay, ptpClockPortCurrentClockInstanceIndex=ptpClockPortCurrentClockInstanceIndex, ptpClockPortDSClockTypeIndex=ptpClockPortDSClockTypeIndex, ptpMIBClockTranparentDSGroup=ptpMIBClockTranparentDSGroup, PtpClockIdentity=PtpClockIdentity, ptpClockDefaultDSTwoStepFlag=ptpClockDefaultDSTwoStepFlag, ptpMIBClockPortGroup=ptpMIBClockPortGroup, ptpClockParentDSParentStats=ptpClockParentDSParentStats, ptpClockTransDefaultDSClockIdentity=ptpClockTransDefaultDSClockIdentity, ptpClockParentDSDomainIndex=ptpClockParentDSDomainIndex, ptpClockPortRunningPacketsSent=ptpClockPortRunningPacketsSent, ptpClockPortTransDSFaultyFlag=ptpClockPortTransDSFaultyFlag, ptpSystemDomainClockTypeIndex=ptpSystemDomainClockTypeIndex, ptpTransportTypeEthernet=ptpTransportTypeEthernet, PtpClockDomainType=PtpClockDomainType, ptpClockPortAssociateTable=ptpClockPortAssociateTable, ptpClockPortDSDomainIndex=ptpClockPortDSDomainIndex, ptpClockPortDSName=ptpClockPortDSName, ptpClockPortAssociateAddress=ptpClockPortAssociateAddress, ptpClockPortAssociatePacketsReceived=ptpClockPortAssociatePacketsReceived, ptpClockPortRunningTable=ptpClockPortRunningTable, ptpMIBClockPortRunningGroup=ptpMIBClockPortRunningGroup, ptpClockParentDSGMClockQualityOffset=ptpClockParentDSGMClockQualityOffset, ptpClockTimePropertiesDSLeap59=ptpClockTimePropertiesDSLeap59, ptpMIBClockPortTransDSGroup=ptpMIBClockPortTransDSGroup, ptpWellKnownEncapsulationTypes=ptpWellKnownEncapsulationTypes, PtpClockPortTransportTypeAddress=PtpClockPortTransportTypeAddress, ptpClockTimePropertiesDSCurrentUTCOffsetValid=ptpClockTimePropertiesDSCurrentUTCOffsetValid, ptpClockRunningPacketsSent=ptpClockRunningPacketsSent, ptpClockPortTable=ptpClockPortTable, PYSNMP_MODULE_ID=atPtpMIB, ptpClockPortTablePortNumberIndex=ptpClockPortTablePortNumberIndex, ptpClockPortRunningTxMode=ptpClockPortRunningTxMode, ptpClockCurrentDSMeanPathDelay=ptpClockCurrentDSMeanPathDelay, ptpClockTransDefaultDSPrimaryDomain=ptpClockTransDefaultDSPrimaryDomain, ptpClockCurrentDSOffsetFromMaster=ptpClockCurrentDSOffsetFromMaster, ptpClockDefaultDSPriority1=ptpClockDefaultDSPriority1, ptpClockPortDSlogAnnouncementInterval=ptpClockPortDSlogAnnouncementInterval, ptpClockPortDSGrantDuration=ptpClockPortDSGrantDuration, ptpClockPortAssociatePacketsSent=ptpClockPortAssociatePacketsSent, ptpClockPortDSDelayMech=ptpClockPortDSDelayMech, ptpClockPortRunningRole=ptpClockPortRunningRole, ptpMIBClockInfo=ptpMIBClockInfo, ptpTransportTypeDeviceNET=ptpTransportTypeDeviceNET, ptpTransportTypeIPversion4=ptpTransportTypeIPversion4, ptpClockPortDomainIndex=ptpClockPortDomainIndex, ptpEncapsulationTypeUDPIPLSP=ptpEncapsulationTypeUDPIPLSP, ptpClockTimePropertiesDSCurrentUTCOffset=ptpClockTimePropertiesDSCurrentUTCOffset, ptpTransportTypeIEC61158=ptpTransportTypeIEC61158, ptpClockPortAssociateAddressType=ptpClockPortAssociateAddressType, PtpClockTimeSourceType=PtpClockTimeSourceType, ptpClockTimePropertiesDSTimeTraceable=ptpClockTimePropertiesDSTimeTraceable, ptpClockPortAssociateEntry=ptpClockPortAssociateEntry, ptpClockPortRunningClockTypeIndex=ptpClockPortRunningClockTypeIndex, ptpClockPortTransDSDomainIndex=ptpClockPortTransDSDomainIndex, ptpClockDefaultDSQualityAccuracy=ptpClockDefaultDSQualityAccuracy, ptpClockPortDSPeerDelayReqInterval=ptpClockPortDSPeerDelayReqInterval, ptpClockPortRunningRxMode=ptpClockPortRunningRxMode, ptpClockParentDSGMClockQualityAccuracy=ptpClockParentDSGMClockQualityAccuracy, ptpMIBClockDefaultDSGroup=ptpMIBClockDefaultDSGroup, PtpClockType=PtpClockType)
