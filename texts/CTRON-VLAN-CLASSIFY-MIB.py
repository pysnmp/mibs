#
# PySNMP MIB module CTRON-VLAN-CLASSIFY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-VLAN-CLASSIFY-MIB
# Produced by pysmi-1.1.10 at Wed Nov 15 02:37:16 2023
# On host fv-az661-425 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ctVlanExt, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctVlanExt")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
ObjectIdentity, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, iso, TimeTicks, MibIdentifier, ModuleIdentity, Unsigned32, Bits, Counter32, Integer32, Gauge32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "iso", "TimeTicks", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Bits", "Counter32", "Integer32", "Gauge32", "IpAddress")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
ctVlanClassify = ModuleIdentity((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6))
ctVlanClassify.setRevisions(('2002-12-19 16:31', '2002-03-27 20:55',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ctVlanClassify.setRevisionsDescriptions(('This revision primarily contains modifications to,\n                 and expansion of, the CtVlanClassifyType Textual\n                 Convention.  These modification address historical\n                 and future usage.', 'This revision, 01.02.00, is a merge of revision 00.00.01,\n                 dated March 18, 1999, and revision 01.01.00, dated\n                 September 26, 2001.',))
if mibBuilder.loadTexts: ctVlanClassify.setLastUpdated('200301292215Z')
if mibBuilder.loadTexts: ctVlanClassify.setOrganization('Enterasys Networks, Inc')
if mibBuilder.loadTexts: ctVlanClassify.setContactInfo('       Enterasys Networks, Inc.\n        Postal: 35 Industrial Way, P.O. Box 5005\n                Rochester, NH 03867-0505\n         Phone: (603) 332-9400\n         Email: support@enterasys.com\n           Web: http://www.enterasys.com')
if mibBuilder.loadTexts: ctVlanClassify.setDescription('The Enterasys VLAN Classify MIB module for controlling\n         Enterasys specific VLAN classification criteria based\n         on packet content.')
ctVlanClassifyObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1))
class CtVlanClassifyType(TextualConvention, Integer32):
    description = "Each enumerated value represents a unique classification\n        type.  Different types have different rules regarding\n        how data is interpreted during classification.  These\n        rules are spelled out in the comments preceding each type.\n\n        Unless otherwise specified providing a value for DataMask is \n        optional and the description for DataMask is as follows:\n\n        DataMask is the same logical size the as the associated DataVal.\n        DataMask is the one's complement of the DataVal bits to attempt\n        to match on.  (e.g., to match on the IP subnet 255.255.240.0\n        the value for DataMask would be 0x00000fff)\n        Working from the most significant to the least significant bit\n        '1 to 0' transitions are not allowed.  (e.g., 0x000ffffe is not\n        valid.)\n        For DataVal objects that are less than 32 bits the leading\n        inconsequential bits in the corresponding DataMask value must\n        be zero.  (e.g., 0x0000000f would attempt to match on the high\n        order four bits in an eight bit DataVal.)"
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34))
    namedValues = NamedValues(("etherType", 1), ("llcDsapSsap", 2), ("ipTypeOfService", 3), ("ipProtocolType", 4), ("ipxClassOfService", 5), ("ipxPacketType", 6), ("ipAddressSource", 7), ("ipAddressDestination", 8), ("ipAddressBilateral", 9), ("ipxNetworkSource", 10), ("ipxNetworkDestination", 11), ("ipxNetworkBilateral", 12), ("ipUdpPortSource", 13), ("ipUdpPortDestination", 14), ("ipUdpPortBilateral", 15), ("ipTcpPortSource", 16), ("ipTcpPortDestination", 17), ("ipTcpPortBilateral", 18), ("ipxSocketSource", 19), ("ipxSocketDestination", 20), ("ipxSocketBilateral", 21), ("macAddressSource", 22), ("macAddressDestination", 23), ("macAddressBilateral", 24), ("ipFragments", 25), ("ipUdpPortSourceRange", 26), ("ipUdpPortDestinationRange", 27), ("ipUdpPortBilateralRange", 28), ("ipTcpPortSourceRange", 29), ("ipTcpPortDestinationRange", 30), ("ipTcpPortBilateralRange", 31), ("icmpType", 32), ("vlanId", 33), ("tci", 34))

class VlanIndex(TextualConvention, Unsigned32):
    description = 'A value used to index per-VLAN tables: values of 0 and\n        4095 have special meaning; if the value is between 1 and\n        4094 inclusive, it represents an 802.1Q VLAN-ID with\n        global scope within a given bridged domain (see VlanId\n        textual convention).  If the value is greater than 4095\n        then it represents a VLAN with scope local to the\n        particular agent. If the value is 0 it indicates that the \n        packets will be dropped.  If the value is 4095, it indicates\n        that the packets will be forwarded, but no VLAN is \n        specified here.'
    status = 'current'

ctVlanClassifyStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctVlanClassifyStatus.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyStatus.setDescription('Allows the VLAN Classification feature to be globally\n        enabled/disabled.  A value of disable(2), functionally\n        supersedes the RowStatus of individual entries in the\n        ctVlanClassifyTable, but does not change their actual\n        RowStatus value.')
ctVlanClassifyMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctVlanClassifyMaxEntries.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyMaxEntries.setDescription('The maximum number of entries allowed in the\n        ctVlanClassifyTable.')
ctVlanClassifyNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctVlanClassifyNumEntries.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyNumEntries.setDescription('The current number of entries in the ctVlanClassifyTable.')
ctVlanClassifyTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4), )
if mibBuilder.loadTexts: ctVlanClassifyTable.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyTable.setDescription('A table containing configuration information for each\n        VLAN classification configured into the device by (local\n        or network) management.  All entries are permanent and\n        will be restored after the device is reset.')
ctVlanClassifyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1), ).setIndexNames((0, "CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyVlanIndex"), (0, "CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyDataMeaning"), (0, "CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyDataVal"), (0, "CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyDataMask"))
if mibBuilder.loadTexts: ctVlanClassifyEntry.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyEntry.setDescription('Describes a particular entry of ctVlanClassifyTable.')
ctVlanClassifyVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 1), VlanIndex())
if mibBuilder.loadTexts: ctVlanClassifyVlanIndex.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyVlanIndex.setDescription('The VLAN index for this entry.  Any packet meeting the\n        classification criteria specified by this conceptual row\n        will be put into the VLAN indicated by this object.')
ctVlanClassifyDataMeaning = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 2), CtVlanClassifyType())
if mibBuilder.loadTexts: ctVlanClassifyDataMeaning.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyDataMeaning.setDescription('The meaning of the ctVlanClassifyDataVal leaf for this\n        conceptual row.  The ctVlanClassifyDataVal specifies a\n        particular value which, when compared to packet data,\n        is used to classify that packet into a particular VLAN.\n        The part of the packet (if any), to which this data\n        comparison applies, is determined by this object.\n\n        For example, the value ipAddressBilateral(8) means that\n        the value ctVlanClassifyDataVal for this entry is an IP\n        address.  It further means that the given IP address\n        will be compared against both source and destination\n        IP address fields in a packet.  Such an entry obviously\n        would not not match against any non-IP packets.\n\n        Additionally, the value of this leaf will impose certain\n        implicit ranges and interpretations of data contained\n        within the ctVlanClassifyDataVal leaf for this entry.  The\n        specific limitations of each type should be spelled out\n        in the comments for that type.')
ctVlanClassifyDataVal = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 3), Unsigned32())
if mibBuilder.loadTexts: ctVlanClassifyDataVal.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyDataVal.setDescription('The data value associated with ctVlanClassifyDataMeaning.\n        The explicit range of this value is any unsigned 32-bit\n        integer(0..4294967295).  This range may vary, however, \n        depending upon the value of ctVlanClassifyDataMeaning.\n        Illegal values should not be allowed.')
ctVlanClassifyDataMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 4), Unsigned32())
if mibBuilder.loadTexts: ctVlanClassifyDataMask.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyDataMask.setDescription("This object is the one's complement of a 32-bit mask.\n        This mask is applicable to the data comparison of\n        ctVlanClassifyDataVal.  The mask is applied to the actual\n        packet data under consideration through a logical bitwise\n        AND operation.  This result is then compared to the data.\n\n        For example, we want to classify according to a bilateral\n        IP address of 134.141.0.0 with a mask of 255.255.240.0.\n        This would be reflected by the following values:\n\n        ctVlanClassifyDataMeaning: ipAddressBilateral(8)\n        ctVlanClassifyDataVal:     0x868d0000\n        ctVlanClassifyDataMask:    0x00000fff\n\n        Again there are contextual implications for this leaf\n        depending upon the value of ctVlanClassifyDataMeaning.\n        Not all types will use the mask, and others will impose\n        restrictions.  This value should however be a true\n        indication of the masking operation.  In other words,\n        data types that don't use a mask should only allow a\n        value of zero, indicating that all data bits are\n        significant in the comparison.\n\n        The specific restrictions of each type should be spelled\n        out in the comments for that type.  Illegal values should\n        not be allowed.")
ctVlanClassifyIngressList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 5), PortList().clone(hexValue="0000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctVlanClassifyIngressList.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyIngressList.setDescription('The set of ports on which this classification rule applies.\n        Classification occurs on ingress.  An agent implementation\n        should allow a set operation of this object to create a\n        row if it does not exist.')
ctVlanClassifyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctVlanClassifyRowStatus.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyRowStatus.setDescription("This object provides both control and status for the\n        associated conceptual row in the table.  Rows can be\n        created in two ways.\n\n        createAndGo - The specified row will be created and\n            activated if the instance is allowable.  If not, an\n            inconsistentValue exception will be returned and the\n            row will not be created.  This provides the most\n            optimal method of creating an active row, but provides\n            the user no explanation if the row cannot be created.\n\n        createAndWait - The specified row will be created and put\n            in the notInService state if the instance is allowable.\n            A subsequent activation of this row will bring it into\n            the active state.  If the instance is not allowable,\n            the row will be created and put in the notReady state.\n            A subsequent activation of this row will fail.  Since\n            the inappropriate information is always contained in the\n            indexing leaves, activation will never succeed and the\n            row should be removed by the management station.  When\n            a row is in the notReady state, the ctVlanClassifyRowInfo\n            may be retrieved to obtain a plain English explanation\n            of why this row cannot be activated.  createAndWait is\n            the preferred method for this reason.\n        \n        Both methods described above leave ctVlanClassifyIngressList\n        in it's default state, requiring an additional set operation\n        in order to modify it.  An even more optimal twist on the\n        createAndWait method is to set the ctVlanClassifyIngressList\n        to it's desired value as a method for row creation.  This\n        will essentially cause an implicit createAndWait since it\n        too will leave the row in either the notInService or\n        notReady state.  This leaves only activation or error\n        analysis as the last step.\n\n        Any rows left in the notReady or notInService state for\n        more than 5 minutes should be automatically removed by\n        the agent implementation.")
ctVlanClassifyRowInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 4, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctVlanClassifyRowInfo.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyRowInfo.setDescription("This object provides info about this row in the form of\n        an ASCII string, suitable for display purposes.  The\n        intended purpose of this object is to provide an\n        'agent-specific' explanation as to why the\n        ctVlanClassifyRowStatus for this conceptual row is in\n        the 'notReady' state.  A management station should read\n        this object and display it to the user in this case.\n\n        A conceptual row that does not fall into this category may\n        simply return a single NULL, but may also provide any useful\n        info of its choice.  A management station may attempt to\n        display such info if it so chooses, but is under no burden\n        to do so.")
ctVlanClassifyAbilityTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 5), )
if mibBuilder.loadTexts: ctVlanClassifyAbilityTable.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyAbilityTable.setDescription('A table containing information for each of the VLAN\n        classification types.  Types for which there is no\n        corresponding row are not supported by this device.')
ctVlanClassifyAbilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 5, 1), ).setIndexNames((0, "CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyAbility"))
if mibBuilder.loadTexts: ctVlanClassifyAbilityEntry.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyAbilityEntry.setDescription('Describes a particular entry of ctVlanClassifyAbilityTable.')
ctVlanClassifyAbility = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 5, 1, 1), CtVlanClassifyType())
if mibBuilder.loadTexts: ctVlanClassifyAbility.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyAbility.setDescription('The VLAN classification type associated with this entry.')
ctVlanClassifyPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 5, 1, 2), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctVlanClassifyPorts.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyPorts.setDescription('The set of ports on which the classification type\n        specified by ctVlanClassifyAbility is supported.')
ctVlanClassifyActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwardNoFrames", 1), ("forwardAllFrames", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctVlanClassifyActionStatus.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyActionStatus.setDescription("The action taken for all frames which apply this entry's\n        associated classification rule.\n\n        When this object is forwardNoFrames(1), the device will\n        drop all frames which apply this classification rule.\n\n        When this object is forwardAllFrames(2), the device will\n        forward all applicable frames to this classification entry's\n        VLAN.")
ctVlanClassifyConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 2))
ctVlanClassifyGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 2, 1))
ctVlanClassifyCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 2, 2))
ctVlanClassifyBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 2, 1, 1)).setObjects(("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyStatus"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyMaxEntries"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyNumEntries"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyIngressList"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyRowStatus"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyRowInfo"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyPorts"), ("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyActionStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ctVlanClassifyBaseGroup = ctVlanClassifyBaseGroup.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyBaseGroup.setDescription('A collection of objects providing device level control\n        and status information for VLAN classification.')
ctVlanClassifyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 16, 6, 2, 2, 1)).setObjects(("CTRON-VLAN-CLASSIFY-MIB", "ctVlanClassifyBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ctVlanClassifyCompliance = ctVlanClassifyCompliance.setStatus('current')
if mibBuilder.loadTexts: ctVlanClassifyCompliance.setDescription('The compliance statement for devices that support\n        VLAN classification.')
mibBuilder.exportSymbols("CTRON-VLAN-CLASSIFY-MIB", ctVlanClassifyIngressList=ctVlanClassifyIngressList, ctVlanClassifyConformance=ctVlanClassifyConformance, ctVlanClassifyAbilityEntry=ctVlanClassifyAbilityEntry, ctVlanClassifyDataMeaning=ctVlanClassifyDataMeaning, ctVlanClassifyRowInfo=ctVlanClassifyRowInfo, ctVlanClassifyGroups=ctVlanClassifyGroups, ctVlanClassifyStatus=ctVlanClassifyStatus, CtVlanClassifyType=CtVlanClassifyType, ctVlanClassifyNumEntries=ctVlanClassifyNumEntries, ctVlanClassifyCompliances=ctVlanClassifyCompliances, ctVlanClassifyEntry=ctVlanClassifyEntry, ctVlanClassifyDataVal=ctVlanClassifyDataVal, ctVlanClassifyBaseGroup=ctVlanClassifyBaseGroup, ctVlanClassifyMaxEntries=ctVlanClassifyMaxEntries, VlanIndex=VlanIndex, PYSNMP_MODULE_ID=ctVlanClassify, ctVlanClassifyCompliance=ctVlanClassifyCompliance, ctVlanClassifyDataMask=ctVlanClassifyDataMask, ctVlanClassifyRowStatus=ctVlanClassifyRowStatus, ctVlanClassifyAbility=ctVlanClassifyAbility, ctVlanClassifyObjects=ctVlanClassifyObjects, ctVlanClassifyActionStatus=ctVlanClassifyActionStatus, ctVlanClassifyPorts=ctVlanClassifyPorts, ctVlanClassify=ctVlanClassify, ctVlanClassifyVlanIndex=ctVlanClassifyVlanIndex, ctVlanClassifyAbilityTable=ctVlanClassifyAbilityTable, ctVlanClassifyTable=ctVlanClassifyTable)
