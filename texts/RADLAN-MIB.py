#
# PySNMP MIB module RADLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source https://pysnmp.github.io:443/mibs/asn1/RADLAN-MIB
# Produced by pysmi-1.1.10 at Fri Nov 10 11:11:14 2023
# On host fv-az1251-57 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
dot1dBasePortEntry, MacAddress, dot1dBasePort, Timeout, BridgeId = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry", "MacAddress", "dot1dBasePort", "Timeout", "BridgeId")
PaeControlledPortStatus, dot1xAuthSessionStatsEntry, dot1xPaePortNumber = mibBuilder.importSymbols("IEEE8021-PAE-MIB", "PaeControlledPortStatus", "dot1xAuthSessionStatsEntry", "dot1xPaePortNumber")
InterfaceIndexOrZero, ifIndex, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex", "InterfaceIndex")
EnabledStatus, = mibBuilder.importSymbols("P-BRIDGE-MIB", "EnabledStatus")
PortList, dot1qFdbId, VlanIndex = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList", "dot1qFdbId", "VlanIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, Unsigned32, Bits, Gauge32, Integer32, IpAddress, iso, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises, NotificationType, ModuleIdentity, ObjectIdentity, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "Bits", "Gauge32", "Integer32", "IpAddress", "iso", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises", "NotificationType", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "Counter32")
Counter_32, Unsigned_32, Integer_32 = mibBuilder.importSymbols("SNMPv2-SMI-v1", "Counter-32", "Unsigned-32", "Integer-32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
DateAndTime, TimeInterval, PhysAddress, TruthValue, RowStatus, DisplayString, RowPointer = mibBuilder.importSymbols("SNMPv2-TC-v1", "DateAndTime", "TimeInterval", "PhysAddress", "TruthValue", "RowStatus", "DisplayString", "RowPointer")
class Percents(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 100)

class NetNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class VlanPriority(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class RlStormCtrlRateUnit(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("packetsPerSecond", 1), ("bytesPerSecond", 2), ("framesPerBuffer", 3), ("precentages", 4), ("kiloBytesPerSecond", 5), ("kiloBitsPerSecond", 6))

rnd = MibIdentifier((1, 3, 6, 1, 4, 1, 89))
rndNotifications = ObjectIdentity((1, 3, 6, 1, 4, 1, 89, 0))
if mibBuilder.loadTexts: rndNotifications.setStatus('current')
if mibBuilder.loadTexts: rndNotifications.setDescription(" All the rnd notifications will reside under this branch\n                         as specified in\n                         RFC2578 'Structure of Management Information Version 2 (SMIv2)' 8.5")
rndMng = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 1))
rndDeviceParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2))
rndBridgeType = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48))).clone(namedValues=NamedValues(("reb", 1), ("ceb", 2), ("ceblb", 3), ("xeb", 4), ("xeb1", 5), ("rebsx", 6), ("rtb", 7), ("ltb", 8), ("tre", 9), ("rtre", 10), ("xtb", 11), ("ete", 12), ("rete", 13), ("ielb", 30), ("leb", 31), ("openGate12", 32), ("openGate4", 33), ("ran", 34), ("itlb", 35), ("gatelinx", 36), ("openGate2", 37), ("ogRanTR", 38), ("rdapter", 39), ("ogVan", 40), ("wanGate", 41), ("ogRubE", 42), ("ogRubT", 43), ("wanGateI", 44), ("vGate4", 45), ("lre", 46), ("mrt", 47), ("vGate2", 48)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBridgeType.setStatus('mandatory')
if mibBuilder.loadTexts: rndBridgeType.setDescription('Identification of the RND bridge type.')
rndInactiveArpTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndInactiveArpTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rndInactiveArpTimeOut.setDescription('This variable defines the maximum time period that can pass\n       between ARP requests concerning an entry in the ARP table.\n       After this time period, the entry is deleted from the table.')
rndBridgeAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 3))
rndErrorDesc = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: rndErrorDesc.setDescription('A textual description of the enterprise-specific trap sent\n        to the Network Management Station by the RND managed device.')
rndErrorSeverity = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("info", 0), ("warning", 1), ("error", 2), ("fatal-error", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndErrorSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: rndErrorSeverity.setDescription('The severity type of the enterprise-specific trap sent to the\n      Network Management Station by the RND managed device.')
rndBrgVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBrgVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgVersion.setDescription('The bridge version.')
rndBrgFeatures = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBrgFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgFeatures.setDescription('A bit mask that defines the features supported by a particular configuration\n       of this network element:\n       __________________________________________\n       |  Byte 1|Byte 2 |Byte 3 | ....|Byte 20  |\n       |87654321|                     | 87654321|\n       |________|_______________________________|\n\n Byte1 :\n      bit1: TX Block mask\n      bit2: Source Routing Encapulation\n      bit3: SNA/SDLC\n      bit4: Frame Relay\n      bit5: SNMP\n      bit6: LAN Manager\n      bit7: High Performance\n      bit8: Translation\n Byte2 :\n      bit1: DEC Router\n      bit2: IPX Router\n      bit3: IP  Router\n Byte3 :\n      bit1: Dial Up Backup\n      bit2: COD\n      bit3: FACS\n      bit4: Load Balance\n      bit5: Remote Configuration\n      bit6: RIP 2\n      bit7: OSPF\n      bit8: IPX RIP/SAP Filter\n Byte4 :\n      bit1: BootP Server\n      bit2: BootP Client\n      bit3: Compression\n      bit4: V25.bis\n      bit5: ISDN\n      bit6: CODv2\n      bit7: NSPF\n      bit8: UDP Relay\n\n Byte5\n      bit1:VirtualLAN\n      bit2:Static IP Multicast\n      bit3:IP Redundancy\n      bit4:CCM2\n      bit5:ISDN Bonding\n      bit6:Backup Link Selection -- for the  VAN/Rdapter ver 4.0\n      bit7:IP/IPX Forwarding     -- for the  WANgate ver 4.0\n      bit8:Improved COD\n\n Byte6\n      bit1: Server Disptacher\n      bit2: ISDN_US             -- for the  VANSX/WANGATE ver 5.0\n      bit3: PPP\n      bit4: IP Rip Filter       -- for Vgate3\n      bit5: Zero Hop Routing    -- for Vgate3\n      bit6: ISDN Japan\n      bit7: PPP-Security\n\n Byte7\n     bit1: With unmanaged Switch\n     bit2: 2 LANs\n     bit3: OSPF Ver 2.0\n     bit4: FACS Ver 2.0\n     bit5: Multiple WEB Farm\n     bit6: Backup Server\n     bit7: Check Connectivity\n     bit8: WSD multiplexing\n\nByte8\n     bit1: MRT3\n     bit2: WSD Redundancy\n     bit3: DHCP Server\n     bit4: WSD Connection Limit\n     bit5: WSD Distributed System\n     bit6: WSD Load Report\n     bit7: WSD super farm\n     bit8: RadWiz leased line\n\nByte9\n     bit1: PPP IP address negotiaton\n     bit2: DNS\n     bit3: Nat\n     bit4: WSD Static proximity\n     bit5: WSD Dynamic proximity\n     bit6: WSD Proxy\n     bit7: WSD Proximity client\n     bit8: MAC Load balancing\n\nByte10\n     bit1: Unnum Inf\n     bit2: Power Supply redundancy\n     bit3: MRT PPP Compression\n     bit4: ZHR Apolo\n     bit5: Copy port\n     bit6: UDP Relay 2.0\n     bit7: NVRAM\n     bit8: URL table\n\nByte11\n     bit1: URL super farm\n     bit2: NAT on LAN\n     bit3: Remote Con\n     bit4: AP5000\n     bit5: Session tracking\n     bit6: Mirroring\n     bit7: Alias IP\n     bit8: CSD Nat\n\nByte12\n     bit1: content check\n     bit2: mlb virtual ip\n     bit3: reserved RadLan\n     bit4: csd nat exception\n     bit5: statistics monitor\n     bit6: reserved-for-radware          ')
rndBrgLicense = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBrgLicense.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgLicense.setDescription('This parameter is used for entering a s/w license number for a device.\n        A separate license number is supplied for each device.')
rndIpHost = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 7))
rndCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 89, 2, 7, 2), )
if mibBuilder.loadTexts: rndCommunityTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityTable.setDescription('The community table of the agent')
rndCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rndCommunityMngStationAddr"), (1, "RADLAN-MIB", "rndCommunityString"))
if mibBuilder.loadTexts: rndCommunityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityEntry.setDescription(' The row definition for this table.')
rndCommunityMngStationAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityMngStationAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityMngStationAddr.setDescription('The management station that will be allowed to\n    communicate with the agent IP address')
rndCommunityString = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityString.setDescription('The community string with which the management\n     station will communicate with the agent')
rndCommunityAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2), ("super", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityAccess.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityAccess.setDescription('The allowed access to this management station')
rndCommunityTrapsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("snmpV1", 1), ("snmpV2", 2), ("snmpV3", 3), ("trapsDisable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityTrapsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityTrapsEnable.setDescription('Should the agent send traps to the management station,\n     and what version is required')
rndCommunityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityStatus.setDescription('The status of this entry. If the status is invalid the\n    community entry will be deleted')
rndCommunityPortSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityPortSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityPortSecurity.setDescription('If enabled the device will only receive SNMP messages from the port,\n     through which this NMS is reachable from the device.')
rndCommunityOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityOwner.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityOwner.setDescription('The owner of this community')
rndCommunityTrapDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(162)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityTrapDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityTrapDestPort.setDescription('The transport protocol (usually UDP) port to which traps to the\n    management station represebted by this entry will be sent. The default\n    is the well-known IANA assigned port number for SNMP traps.\n    This object is relevant only if rndCommunityTrapsEnable has a value\n    different from trapsDisable.')
rlMridTable = MibTable((1, 3, 6, 1, 4, 1, 89, 2, 7, 3), )
if mibBuilder.loadTexts: rlMridTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMridTable.setDescription('The MRID related configurations table of the agent')
rlMridEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 2, 7, 3, 1), ).setIndexNames((0, "RADLAN-MIB", "rndCommunityMngStationAddr"), (1, "RADLAN-MIB", "rndCommunityString"))
if mibBuilder.loadTexts: rlMridEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMridEntry.setDescription(' The row definition for this table.')
rlMridConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 3, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMridConnection.setStatus('mandatory')
if mibBuilder.loadTexts: rlMridConnection.setDescription('The router instance connecting the NMS who accessed the agent\n     through the community table entry corresponding to the keys of this entry.')
rlManagedMrid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlManagedMrid.setStatus('mandatory')
if mibBuilder.loadTexts: rlManagedMrid.setDescription('The router instance currently managed by the NMS who accessed the agent\n     through the community table entry corresponding to the keys of this entry ')
rndManagedTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndManagedTime.setStatus('mandatory')
if mibBuilder.loadTexts: rndManagedTime.setDescription('The time will be sent in the format hhmmss')
rndManagedDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndManagedDate.setStatus('mandatory')
if mibBuilder.loadTexts: rndManagedDate.setDescription('The date will be sent in the format ddmmyy')
rndBaseBootVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBaseBootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rndBaseBootVersion.setDescription('Defines the boot version of the product.')
rndIpHostManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 7, 4))
rndIpHostManagementSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 7, 4, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIpHostManagementSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rndIpHostManagementSupported.setDescription('ifindex manage supported.')
rndIpHostManagementIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 7, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIpHostManagementIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndIpHostManagementIfIndex.setDescription('if supported manage , indicate ifindex, if 0 thaen disable')
genGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 11))
genGroupHWVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWVersion.setDescription('Defines the HW version of the product.')
genGroupConfigurationSymbol = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setDescription('Defines the Configuration Symbol attached to any hardware module\n      manufactured by LANNET. One single character A..Z defines the CS\n      version.')
genGroupHWStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("hardwareProblems", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWStatus.setDescription('This attribute describes the status of the group hardware as detected\n      by the sensors software.')
rndBasePhysicalAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 12), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBasePhysicalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rndBasePhysicalAddress.setDescription('The Base physical (MAC) address of the device.')
rndSoftwareFile = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 13))
rndActiveSoftwareFileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 2, 13, 1), )
if mibBuilder.loadTexts: rndActiveSoftwareFileTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndActiveSoftwareFileTable.setDescription(' The (conceptual) table listing the active software file of the\n          requested unit.')
rndActiveSoftwareFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 2, 13, 1, 1), ).setIndexNames((0, "RADLAN-MIB", "rndUnitNumber"))
if mibBuilder.loadTexts: rndActiveSoftwareFileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndActiveSoftwareFileEntry.setDescription(' An entry (conceptual row) in the rndActiveSoftwareFileTable.')
rndUnitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 13, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndUnitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rndUnitNumber.setDescription("The unit number (for stackable devices) or 1 for 'stand alone' device.")
rndActiveSoftwareFile = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("image1", 1), ("image2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndActiveSoftwareFile.setStatus('mandatory')
if mibBuilder.loadTexts: rndActiveSoftwareFile.setDescription('Indicates the current active software file, image1 or image2.')
rndActiveSoftwareFileAfterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("image1", 1), ("image2", 2), ("invalidImage", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndActiveSoftwareFileAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rndActiveSoftwareFileAfterReset.setDescription("Indicates the software file that will be active after reset (image1 or image2).\n         If an error occurred in the download process, resulting in the corruption\n         of the single software file, The value 'invalidImage' will be returned.\n         This value can not be set by the user.")
rndImageSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImageSize.setStatus('mandatory')
if mibBuilder.loadTexts: rndImageSize.setDescription('Max number of sectors currently allocated for image(s).')
rndBackupConfigurationEnabled = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBackupConfigurationEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: rndBackupConfigurationEnabled.setDescription('Specifies whether the device supports backup-config parameters in lcli commands.')
rndImageInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 16))
rndImageInfoTable = MibTable((1, 3, 6, 1, 4, 1, 89, 2, 16, 1), )
if mibBuilder.loadTexts: rndImageInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndImageInfoTable.setDescription(' The table contains information about images.')
rndImageInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1), ).setIndexNames((0, "RADLAN-MIB", "rndStackUnitNumber"))
if mibBuilder.loadTexts: rndImageInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndImageInfoEntry.setDescription(' An entry in the rndImageInfoTable.')
rndStackUnitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndStackUnitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rndStackUnitNumber.setDescription("The unit number (for stackable devices) or 1 for 'stand alone' device.")
rndImage1Name = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage1Name.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage1Name.setDescription('Indicates the file name of image-1 in the system.')
rndImage2Name = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage2Name.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage2Name.setDescription("Indicates the file name of image-2 (if present) in the system.If image-2 is not present show 'no info' text")
rndImage1Version = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage1Version.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage1Version.setDescription('Indicates the version of image-1 in the system.')
rndImage2Version = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage2Version.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage2Version.setDescription("Indicates the version of image-2 (if present) in the system.If image-2 is not present show 'no info' text")
rndImage1Date = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage1Date.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage1Date.setDescription('Indicates the compilation date of image-1 in the system.')
rndImage2Date = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage2Date.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage2Date.setDescription("Indicates the compilation date of image-2 (if present) in the system.If image-2 is not present show 'no info' text")
rndImage1Time = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage1Time.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage1Time.setDescription('Indicates the compilation time of image-1 in the system.')
rndImage2Time = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 16, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndImage2Time.setStatus('mandatory')
if mibBuilder.loadTexts: rndImage2Time.setDescription("Indicates the compilation time of image-2 (if present) in the system.If image-2 is not present show 'no info' text")
rndBootP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 24))
rndBootPServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 24, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBootPServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rndBootPServerAddress.setDescription(' The IPAddress of the BOOTP server. the OpenGate will act as a BootP relay if\n       this parameter is not equale to 0.0.0.0.')
rndBootPRelaySecThreshold = MibScalar((1, 3, 6, 1, 4, 1, 89, 24, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBootPRelaySecThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rndBootPRelaySecThreshold.setDescription('BootP requests are relayed only if their SEC field is greater or\n        equal to the threshold value in order to allow local BootP Servers\n        to answer first.')
ipSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26))
rsTunning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29))
rndApplications = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35))
rsUDP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 42))
swInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 43))
rlIPmulticast = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 46))
rlFFT = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 47))
vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 48))
rlRmonControl = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 49))
rlBrgMacSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 50))
rlBrgMacSwVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwVersion.setDescription("MIB's version, the current version is 2.")
rlBrgMacSwMaxTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwMaxTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwMaxTableNumber.setDescription('Maximum number of MAC Tables supported by the device.')
rlBrgMacSwDynamicTables = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwDynamicTables.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwDynamicTables.setDescription('Specifies whether the device supports port dynamic MAC tables.')
rlBrgMacSwOldEntryDeleteMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("refreshFlag", 1), ("agingFlag", 2), ("agingTime", 3), ("boundaries", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwOldEntryDeleteMode.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwOldEntryDeleteMode.setDescription("The method used to delete old unused entries\n         refresh_flag:\n            The high level sets a flag when it adds or updates an entry,\n            the Switch clears the flag each time, when it learns the\n            station once more.\n        aging_flag:\n            The high level clears a flag when it adds or updates an entry,\n            the Switch sets the flag each time, when it learns the station\n            once more.\n        aging_time:\n            The high level defines a timeout, the Switch sends a message\n            to the high level each time when the station doesn't send\n            messages during interval between timeout and 2*timeout.\n        Boundaries:\n            The Switch doesn't support any mechanism, and the high level\n            uses two boundaries: red and yellow. When the number of entries\n            exceeds the red boundary, the high level deletes the oldest entries.")
rlBrgMacSwSpanningTree = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwSpanningTree.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwSpanningTree.setDescription('Specifies whether the device supports port the Spanning Tree Protocol.')
rlBrgMacSwKeyType = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("macOnly", 1), ("tagAndMac", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwKeyType.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwKeyType.setDescription('Specified the used MAC Address Table kye format:\n         macOnly:\n            One global MAC Address Table per device (leaky VLANs).\n         tagAndMac:\n            MAC Address Table per each VLAN (strick VLANs).')
rlBrgMacSwYellowBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwYellowBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwYellowBoundary.setDescription('The yellow boundary.')
rlBrgMacSwRedBoundary = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwRedBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwRedBoundary.setDescription('The yellow boundary.')
rlBrgMacSwTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwTrapEnable.setDescription('This variable indicates whether to create a SNMP trap\n         if adding dynamic mac failed due to full hash chain.')
rlBrgMacSwOperTrapCount = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlBrgMacSwOperTrapCount.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwOperTrapCount.setDescription("This variable indicates the trap counter status\n         (i.e. number of received MAC addresses since the last trap\n         sent that haven't been inserted into the hash).\n         It is relevant only when trap is enabled.")
rlBrgMacSwAdminTrapFrequency = MibScalar((1, 3, 6, 1, 4, 1, 89, 50, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 86400)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlBrgMacSwAdminTrapFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: rlBrgMacSwAdminTrapFrequency.setDescription('This variable indicates the minimal frequency (in seconds)\n         of sending a trap.\n         It is relevant only when trap is enabled.')
rlExperience = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 51))
rlCli = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 52))
rlCliMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 52, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCliMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlCliMibVersion.setDescription("MIB's version, the current version is 1.")
rlCliPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 52, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCliPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlCliPassword.setDescription('CLI Password')
rlCliTimer = MibScalar((1, 3, 6, 1, 4, 1, 89, 52, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCliTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rlCliTimer.setDescription('CLI Timer')
rlCliFileEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 52, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlCliFileEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlCliFileEnable.setDescription('CLI File Enable/Disable')
rlCliFileEnableAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 52, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlCliFileEnableAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rlCliFileEnableAfterReset.setDescription('CLI File Enable/Disable After Reset')
rlPhysicalDescription = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 53))
rlIfInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 54))
rlMacMulticast = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 55))
rlGalileo = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 56))
rlpBridgeMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57))
rldot1dPriority = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 1))
rldot1dPriorityMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dPriorityMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dPriorityMibVersion.setDescription("MIB's version, the current version is 1.")
rldot1dPriorityPortGroupTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 1, 2), )
if mibBuilder.loadTexts: rldot1dPriorityPortGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dPriorityPortGroupTable.setDescription('A list of PortGroupNumber for each port.')
rldot1dPriorityPortGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 1, 2, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rldot1dPriorityPortGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dPriorityPortGroupEntry.setDescription('All ports belonging to a same group have\n         the same User Priority to Traffic Class mapping.')
rldot1dPriorityPortGroupNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dPriorityPortGroupNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dPriorityPortGroupNumber.setDescription('A group, that port belongs to. All ports belonging\n         to a same group have the same User Priority to\n         Traffic Class mapping.')
rldot1dStp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 2))
rldot1dStpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpMibVersion.setDescription("MIB's version, the current version is 2.")
rldot1dStpType = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("perDevice", 1), ("mstp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpType.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpType.setDescription('Specifies whether the device supports Spanning Tree per device,\n         or per group.')
rldot1dStpEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpEnable.setDescription('Enable / Disable spanning tree. When working in per vlan mode\n         enable / disable STP per all vlans.')
rldot1dStpPortMustBelongToVlan = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortMustBelongToVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortMustBelongToVlan.setDescription('Specifies whether a port must belong to a VLAN in order\n         to participate in the STP.')
rldot1dStpExtendedPortNumberFormat = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpExtendedPortNumberFormat.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpExtendedPortNumberFormat.setDescription('Specifies whether the STP uses the extended port fnumber format.')
rldot1dStpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 2, 6), )
if mibBuilder.loadTexts: rldot1dStpVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanTable.setDescription('A table that contains vlan-specific information\n            for the Spanning Tree Protocol.')
rldot1dStpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1dStpVlan"))
if mibBuilder.loadTexts: rldot1dStpVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanEntry.setDescription('A list of information maintained by every Vlan\n         about the Spanning Tree Protocol state for that\n         Vlan.')
rldot1dStpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlan.setDescription('The Vlan index.')
rldot1dStpVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 2), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpVlanEnable.setReference(' ??  ')
if mibBuilder.loadTexts: rldot1dStpVlanEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanEnable.setDescription('Specifies whether this vlan is STP enable or disable')
rldot1dStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpTimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: rldot1dStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the\n         last time a topology change was detected by the\n         bridge entity.')
rldot1dStpTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpTopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: rldot1dStpTopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTopChanges.setDescription('The total number of topology changes detected by\n         this bridge since the management entity was last\n         reset or initialized.')
rldot1dStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.3.1')
if mibBuilder.loadTexts: rldot1dStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning\n         tree as determined by the Spanning Tree Protocol\n         as executed by this node.  This value is used as\n         the Root Identifier parameter in all Configuration\n         Bridge PDUs originated by this node.')
rldot1dStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpRootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: rldot1dStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpRootCost.setDescription('The cost of the path to the root as seen from\n         this bridge.')
rldot1dStpRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpRootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: rldot1dStpRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpRootPort.setDescription('The port number of the port which offers the\n         lowest cost path from this bridge to the root\n         bridge.')
rldot1dStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 8), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.4')
if mibBuilder.loadTexts: rldot1dStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol\n         information learned from the network on any port\n         before it is discarded, in units of hundredths of\n         a second.  This is the actual value that this\n         bridge is currently using.')
rldot1dStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 9), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.5')
if mibBuilder.loadTexts: rldot1dStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpHelloTime.setDescription('The amount of time between the transmission of\n         Configuration bridge PDUs by this node on any port\n         when it is the root of the spanning tree or trying\n         to become so, in units of hundredths of a second.\n         This is the actual value that this bridge is\n         currently using.')
rldot1dStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpHoldTime.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: rldot1dStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpHoldTime.setDescription('This time value determines the interval length\n         during which no more than two Configuration bridge\n         PDUs shall be transmitted by this node, in units\n         of hundredths of a second.')
rldot1dStpForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 6, 1, 11), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.6')
if mibBuilder.loadTexts: rldot1dStpForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpForwardDelay.setDescription('This time value, measured in units of hundredths\n         of a second, controls how fast a port changes its\n         spanning state when moving towards the Forwarding\n         state.  The value determines how long the port\n         stays in each of the Listening and Learning\n         states, which precede the Forwarding state.  This\n         value is also used, when a topology change has\n         been detected and is underway, to age all dynamic\n         entries in the Forwarding Database.  [Note that\n         this value is the one that this bridge is\n         currently using, in contrast to\n         dot1dStpBridgeForwardDelay which is the value that\n         this bridge and all others would start using\n         if/when this bridge were to become the root.]')
rldot1dStpVlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 2, 7), )
if mibBuilder.loadTexts: rldot1dStpVlanPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortTable.setDescription('A table that contains pair <vlan, port> specific information\n         for the Spanning Tree Protocol.')
rldot1dStpVlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1dStpVlanPortVlan"), (0, "RADLAN-MIB", "rldot1dStpVlanPortPort"))
if mibBuilder.loadTexts: rldot1dStpVlanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortEntry.setDescription('A list of information maintained by every pair <vlan, port>\n         about the Spanning Tree Protocol state for that pair.')
rldot1dStpVlanPortVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortVlan.setReference('IEEE 802.1s/D2-1999 ')
if mibBuilder.loadTexts: rldot1dStpVlanPortVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortVlan.setDescription('The Vlan number that the port belongs to, and for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1dStpVlanPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortPort.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1dStpVlanPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortPort.setDescription('The port number of the port for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1dStpVlanPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpVlanPortPriority.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1dStpVlanPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortPriority.setDescription('The value of the priority field which is\n         contained in the more significant  4 bits of the most\n         significant octet of the (2 octet long) Port ID.\n         The other octet of the Port ID is given by the value\n         of rldot1dStpVlanPort.')
rldot1dStpVlanPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortState.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: rldot1dStpVlanPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortState.setDescription("The port's current state as defined by application of\n         the Spanning Tree Protocol. This state controls what\n         action a port takes on reception of a frame.\n         If the bridge has detected a port that is malfunctioning\n         it will place that port into the broken(6) state.  For ports\n         which are disabled (see dot1dStpVlanPortEnable), this object\n         will have a value of disabled(1).")
rldot1dStpVlanPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpVlanPortEnable.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: rldot1dStpVlanPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortEnable.setDescription('The enabled/disabled status of the port.')
rldot1dStpVlanPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpVlanPortPathCost.setReference('IEEE 802.1D-1990: Section 4.5.5.3')
if mibBuilder.loadTexts: rldot1dStpVlanPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortPathCost.setDescription('The contribution of this port to the path cost of\n         paths towards the spanning tree root which include\n         this port.  802.1D-1990 recommends that the\n         default value of this parameter be in inverse\n         proportion to the speed of the attached LAN.')
rldot1dStpVlanPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 7), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.5.4')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge\n         recorded as the Root in the Configuration BPDUs\n         transmitted by the Designated Bridge for the\n         segment to which the port is attached.')
rldot1dStpVlanPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedCost.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedCost.setDescription('The path cost of the Designated Port of the\n         segment connected to this port.  This value is\n         compared to the Root Path Cost field in received\n         bridge PDUs.')
rldot1dStpVlanPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedBridge.setReference('IEEE 802.1D-1990: Section 4.5.5.6')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this\n         port considers to be the Designated Bridge for\n         this port's segment.")
rldot1dStpVlanPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedPort.setReference('IEEE 802.1D-1990: Section 4.5.5.7')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated\n         Bridge for this port's segment.")
rldot1dStpVlanPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpVlanPortForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpVlanPortForwardTransitions.setDescription('The number of times this port has transitioned\n         from the Learning state to the Forwarding state.')
rldot1dStpTrapVariable = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 2, 8))
rldot1dStpTrapVrblifIndex = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 8, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpTrapVrblifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTrapVrblifIndex.setDescription('The ifIndex of port which STP status was changed')
rldot1dStpTrapVrblVID = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpTrapVrblVID.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTrapVrblVID.setDescription('The VID of VLAN to which the port belongs which STP status was changed')
rldot1dStpTypeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("perDevice", 1), ("mstp", 4))).clone('perDevice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpTypeAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTypeAfterReset.setDescription('New mode of spaning tree supported by the device after the next reset.')
rldot1dStpMonitorTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpMonitorTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpMonitorTime.setDescription('Factor of hello-time during which a port is monotored to determine if it is stable.')
rldot1dStpBpduCount = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpBpduCount.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpBpduCount.setDescription('The number of bpdu that need to received for the link to be considered stable.')
rldot1dStpLastChanged = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpLastChanged.setReference('')
if mibBuilder.loadTexts: rldot1dStpLastChanged.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpLastChanged.setDescription('The last time any object in this table was changed\n          by SNMP or other local management means.')
rldot1dStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 2, 13), )
if mibBuilder.loadTexts: rldot1dStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortTable.setDescription('A table that contains extended pair port specific information.')
rldot1dStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1dStpPortPort"))
if mibBuilder.loadTexts: rldot1dStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortEntry.setDescription('A list of information maintained by every port\n         about the Spanning Tree Protocol state for that port.')
rldot1dStpPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortPort.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1dStpPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortPort.setDescription('The port number of the port for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1dStpPortDampEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortDampEnable.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortDampEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortDampEnable.setDescription('Specified if dampening is enabled on this port.')
rldot1dStpPortDampStable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 3), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortDampStable.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortDampStable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortDampStable.setDescription('Specified if the port is stable.')
rldot1dStpPortFilterBpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortFilterBpdu.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortFilterBpdu.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortFilterBpdu.setDescription('Specified if this port should filter bpdus when stp is disabled.')
rldot1dStpPortBpduSent = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 5), Counter_32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortBpduSent.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortBpduSent.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBpduSent.setDescription('Specified the number of bpdu sent from this port.')
rldot1dStpPortBpduReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 6), Counter_32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortBpduReceived.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortBpduReceived.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBpduReceived.setDescription('Specified the number of bpdu received in this port.')
rldot1dStpPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 0), ("disabled", 1), ("alternate", 2), ("backup", 3), ("root", 4), ("designated", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortRole.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortRole.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortRole.setDescription('Specified the role of this this port.')
rldot1dStpBpduType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("stp", 0), ("rstp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpBpduType.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpBpduType.setDescription('Specified the type of BPDU transmitted by this port.')
rldot1dStpPortRestrictedRole = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortRestrictedRole.setReference('IEEE 802.1ad-D3-1: Section 13.24.29')
if mibBuilder.loadTexts: rldot1dStpPortRestrictedRole.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortRestrictedRole.setDescription('If TRUE causes the Port not to be selected as Root Port for the CIST or\n         any MSTI, even if it has the best spanning tree priority vector.\n         Such a Port will be selected as an Alternate Port after the Root Port\n         has been selected.')
rldot1dStpPortAutoEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortAutoEdgePort.setReference('IEEE 802.1D-2004: Section 17.13.3')
if mibBuilder.loadTexts: rldot1dStpPortAutoEdgePort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortAutoEdgePort.setDescription("If TRUE causes the Port when become up, to enter the blocking state,\n         and if during 3 seconds it doesn't receive a BPDU, it will enter\n         the forwarding state.")
rldot1dStpPortLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 13, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortLoopback.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortLoopback.setDescription('Specified loopback was detected on port.')
rldot1dStpPortsEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 14), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortsEnable.setDescription('Enable / Disable spanning tree on ports by default .')
rldot1dStpTaggedFlooding = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpTaggedFlooding.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpTaggedFlooding.setDescription('flooding can be done in tagged bpdu .')
rldot1dStpPortBelongToVlanDefault = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpPortBelongToVlanDefault.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBelongToVlanDefault.setDescription('The default value of rldot1dStpPortMustBelongToVlan .')
rldot1dStpEnableByDefault = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpEnableByDefault.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpEnableByDefault.setDescription('The default value of rldot1dStpEnable .')
rldot1dStpPortToDefault = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortToDefault.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortToDefault.setDescription('To order port/s to revert to default setings .')
rldot1dStpSupportedType = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("perDevice", 1), ("perVlan", 2), ("mstp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpSupportedType.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSupportedType.setDescription('The type of stp supported by the device.')
rldot1dStpEdgeportSupportInStp = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dStpEdgeportSupportInStp.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpEdgeportSupportInStp.setDescription('If EdgePort is supported in stpCompatible mode .')
rldot1dStpFilterBpdu = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpFilterBpdu.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpFilterBpdu.setDescription('Specified if the device should filter BPDUs when STP is disabled.')
rldot1dStpFloodBpduMethod = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("classic", 0), ("bridging", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpFloodBpduMethod.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpFloodBpduMethod.setDescription('Specified flooding method:\n        1 - classic - untagged to all stp disabled ports\n        2 - bridging -normal bridging.')
rldot1dStpSeparatedBridges = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 2, 23))
rldot1dStpPortBpduGuardTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 2, 24), )
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardTable.setDescription('A table that contains for each port whether it is bpdu guard .')
rldot1dStpPortBpduGuardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 2, 24, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardEntry.setDescription('A list of information maintained by every port\n         whether it is bpdu guard.')
rldot1dStpPortBpduGuardEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 24, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardEnable.setReference('')
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpPortBpduGuardEnable.setDescription('Specified if bpdu guard is enabled on this port.')
rldot1dStpSeparatedBridgesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 2, 23, 1), )
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesTable.setDescription('Define if separated bridges feature is enabled  for each interface.')
rldot1dStpSeparatedBridgesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 2, 23, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesEntry.setDescription('Defines the contents of each line in the rlSeparatedBridgesTable table.')
rldot1dStpSeparatedBridgesPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 2, 23, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesPortEnable.setDescription('This variable indicates whether the separated bridge feature is enabled on a specified ifIndex.')
rldot1dStpSeparatedBridgesEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 23, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesEnable.setDescription('Enable / Disable Separated Bridges Feature.')
rldot1dStpSeparatedBridgesAutoConfig = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 2, 23, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesAutoConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dStpSeparatedBridgesAutoConfig.setDescription('Enable / Disable Separated Bridges Automatic Configuration.')
rldot1dExtBase = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 3))
rldot1dExtBaseMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dExtBaseMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dExtBaseMibVersion.setDescription("MIB's version, the current version is 1.")
rldot1dDeviceCapabilities = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 3, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dDeviceCapabilities.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dDeviceCapabilities.setDescription('Indicates the optional parts of private extension of\n         IEEE 802.1D and 802.1Q that are implemented by this\n         device and are manageable through this MIB.\n         Capabilities that are allowed on a per-port basis are\n         indicated in dot1dPortCapabilities.')
rldot1wRStp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 4))
rldot1wRStpVlanEdgePortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 4, 1), )
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortTable.setDescription('A table that contains pair <vlan, port> specific information\n         for the Rapid Spanning Tree Protocol.')
rldot1wRStpVlanEdgePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 4, 1, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1wRStpVlanEdgePortVlan"), (0, "RADLAN-MIB", "rldot1wRStpVlanEdgePortPort"))
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortEntry.setDescription('A list of information maintained by every pair <vlan, port>\n         about the RAPID Spanning Tree Protocol state for that pair.')
rldot1wRStpVlanEdgePortVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortVlan.setDescription('The Vlan number that the port belongs to, and for which this entry\n         contains Spanning Tree Protocol management information,\n         If STP per device then only one value of 1 is allowed.\n         If STP per a VLAN then all value of 1..4095 are allowed.')
rldot1wRStpVlanEdgePortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpVlanEdgePortPort.setDescription('The port number of the port for which this entry\n         contains Spanning Tree Protocol management information.')
rldot1wRStpEdgePortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 4, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1wRStpEdgePortStatus.setReference('IEEE 802.1wd6-2000: Section 17.13.3.1 ')
if mibBuilder.loadTexts: rldot1wRStpEdgePortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpEdgePortStatus.setDescription('Specifies whether this port is an Edge Port or not')
rldot1wRStpForceVersionTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 4, 2), )
if mibBuilder.loadTexts: rldot1wRStpForceVersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpForceVersionTable.setDescription('A table that contains  <vlan> specific information\n         for the Rapid Spanning Tree Protocol.')
rldot1wRStpForceVersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 4, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1wRStpForceVersionVlan"))
if mibBuilder.loadTexts: rldot1wRStpForceVersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpForceVersionEntry.setDescription('A list of information maintained by every  <vlan>\n         about the RAPID Spanning Tree Protocol state for that pair.')
rldot1wRStpForceVersionVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1wRStpForceVersionVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpForceVersionVlan.setDescription('The Vlan number that the port belongs to, and for which this entry\n         contains Spanning Tree Protocol management information,\n         If STP per device then only one value of 1 is allowed.\n         If STP per a VLAN then all value of 1..4095 are allowed.')
rldot1wRStpForceVersionState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 4, 2, 1, 2), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1wRStpForceVersionState.setReference('IEEE 802.1wd9-2000: Section 17.16.1 ')
if mibBuilder.loadTexts: rldot1wRStpForceVersionState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1wRStpForceVersionState.setDescription('Specifies whether this Bridge uses the normal RSTP algorithm,\n         or STP Compatibility algorythm:\n         0 - STP Compatibility\n         2 - Normal RSTP')
rldot1pPriorityMap = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 5))
rldot1pPriorityMapState = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1pPriorityMapState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapState.setDescription('enable / disable')
rldot1pPriorityMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 5, 2), )
if mibBuilder.loadTexts: rldot1pPriorityMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapTable.setDescription('This table hold information the priority maps')
rldot1pPriorityMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1pPriorityMapName"))
if mibBuilder.loadTexts: rldot1pPriorityMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapEntry.setDescription('The row definition for this table.')
rldot1pPriorityMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1pPriorityMapName.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapName.setDescription('The map name')
rldot1pPriorityMapPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1pPriorityMapPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapPriority.setDescription('The map holding the queue')
rldot1pPriorityMapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1pPriorityMapPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapPort.setDescription('the port that the map, is applied on in config')
rldot1pPriorityMapPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1, 4), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1pPriorityMapPortList.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapPortList.setDescription('the ports that the map, is applied on in actual')
rldot1pPriorityMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 5, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1pPriorityMapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1pPriorityMapStatus.setDescription("The status of the  table entry. It's used to delete an entry")
rldot1sMstp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 6))
rldot1sMstpInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 6, 1), )
if mibBuilder.loadTexts: rldot1sMstpInstanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceTable.setDescription('A table that contains Mstp instance specific information\n            for the Multiple Spanning Tree Protocol.')
rldot1sMstpInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1sMstpInstanceId"))
if mibBuilder.loadTexts: rldot1sMstpInstanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceEntry.setDescription('A list of information maintained by every instance\n         about the multiple Spanning Tree Protocol state for\n         that instance.')
rldot1sMstpInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceId.setDescription('The Instance index.')
rldot1sMstpInstanceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceEnable.setReference(' ??  ')
if mibBuilder.loadTexts: rldot1sMstpInstanceEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceEnable.setDescription('Specifies whether this Instance is STP enable or disable')
rldot1sMstpInstanceTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceTimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: rldot1sMstpInstanceTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the\n         last time a topology change was detected by the\n         Mstp Instance .')
rldot1sMstpInstanceTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceTopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: rldot1sMstpInstanceTopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceTopChanges.setDescription('The total number of topology changes detected by\n         this Instance since the management entity was last\n         reset or initialized.')
rldot1sMstpInstanceDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.3.1')
if mibBuilder.loadTexts: rldot1sMstpInstanceDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceDesignatedRoot.setDescription('The bridge identifier of the root of the spanning\n         tree as determined by the Muliple Spanning Tree Protocol\n         as executed by this node.  This value is used as\n         the Root Identifier parameter in all Configuration\n         Bridge PDUs originated by this node.')
rldot1sMstpInstanceRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceRootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: rldot1sMstpInstanceRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceRootCost.setDescription('The cost of the path to the root as seen from\n         this bridge.')
rldot1sMstpInstanceRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceRootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: rldot1sMstpInstanceRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceRootPort.setDescription('The port number of the port which offers the\n         lowest cost path from this bridge to the root\n         bridge.')
rldot1sMstpInstanceMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 8), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.4')
if mibBuilder.loadTexts: rldot1sMstpInstanceMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceMaxAge.setDescription('The maximum age of Spanning Tree Protocol\n         information learned from the network on any port\n         before it is discarded, in units of hundredths of\n         a second.  This is the actual value that this\n         bridge is currently using.')
rldot1sMstpInstanceHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 9), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.5')
if mibBuilder.loadTexts: rldot1sMstpInstanceHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceHelloTime.setDescription('The amount of time between the transmission of\n         Configuration bridge PDUs by this node on any port\n         when it is the root of the spanning tree or trying\n         to become so, in units of hundredths of a second.\n         This is the actual value that this bridge is\n         currently using.')
rldot1sMstpInstanceHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceHoldTime.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: rldot1sMstpInstanceHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceHoldTime.setDescription('This time value determines the interval length\n         during which no more than two Configuration bridge\n         PDUs shall be transmitted by this node, in units\n         of hundredths of a second.')
rldot1sMstpInstanceForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 11), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.6')
if mibBuilder.loadTexts: rldot1sMstpInstanceForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceForwardDelay.setDescription('This time value, measured in units of hundredths\n         of a second, controls how fast a port changes its\n         spanning state when moving towards the Forwarding\n         state.  The value determines how long the port\n         stays in each of the Listening and Learning\n         states, which precede the Forwarding state.  This\n         value is also used, when a topology change has\n         been detected and is underway, to age all dynamic\n         entries in the Forwarding Database.  [Note that\n         this value is the one that this bridge is\n         currently using, in contrast to\n         dot1dStpBridgeForwardDelay which is the value that\n         this bridge and all others would start using\n         if/when this bridge were to become the root.]')
rldot1sMstpInstancePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpInstancePriority.setReference('IEEE 802.1S-2001: Section 13.24.2')
if mibBuilder.loadTexts: rldot1sMstpInstancePriority.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePriority.setDescription('The value of the write-able portion of the Bridge\n            ID, i.e., the first four bits of the first octet\n            of the (8 octet long) Bridge ID.The value is a product\n            of 4096. The next 12 bit are the msti id .\n            The other (last) 6 octets of the Bridge ID are given\n            by the value of dot1dBaseBridgeAddress.')
rldot1sMstpInstanceRemainingHopes = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstanceRemainingHopes.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: rldot1sMstpInstanceRemainingHopes.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstanceRemainingHopes.setDescription('This count value determines the amount of hopes\n         the information transmited by this bridge on this\n         instance can travel.')
rldot1sMstpInstancePortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 6, 2), )
if mibBuilder.loadTexts: rldot1sMstpInstancePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortTable.setDescription('A table that contains pair <msti, port> specific information\n         for the Spanning Tree Protocol.')
rldot1sMstpInstancePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1sMstpInstancePortMstiId"), (0, "RADLAN-MIB", "rldot1sMstpInstancePortPort"))
if mibBuilder.loadTexts: rldot1sMstpInstancePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortEntry.setDescription('A list of information maintained by every pair <msti, port>\n         about the Spanning Tree Protocol state for that pair.')
rldot1sMstpInstancePortMstiId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortMstiId.setReference('IEEE 802.1s/D11-2001 ')
if mibBuilder.loadTexts: rldot1sMstpInstancePortMstiId.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortMstiId.setDescription('The Vlan group number that the port belongs to, and for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1sMstpInstancePortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortPort.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPort.setDescription('The port number of the port for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1sMstpInstancePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpInstancePortPriority.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPriority.setDescription('The value of the priority field which is\n         contained in the more significant  4 bits of the most\n         significant octet of the (2 octet long) Port ID.\n         The value is a product of 16.\n         The other octet of the Port ID is given by the value\n         of rldot1dStpVlanGroupPort.')
rldot1sMstpInstancePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortState.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: rldot1sMstpInstancePortState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortState.setDescription("The port's current state as defined by application of\n         the Spanning Tree Protocol. This state controls what\n         action a port takes on reception of a frame.\n         If the bridge has detected a port that is malfunctioning\n         it will place that port into the broken(6) state.  For ports\n         which are disabled (see dot1dStpVlanPortEnable), this object\n         will have a value of disabled(1).")
rldot1sMstpInstancePortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortEnable.setReference('IEEE 802.1D-1990: Section 4.5.5.2')
if mibBuilder.loadTexts: rldot1sMstpInstancePortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortEnable.setDescription('The enabled/disabled status of the port.')
rldot1sMstpInstancePortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortPathCost.setReference('IEEE 802.1D-1990: Section 4.5.5.3')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortPathCost.setDescription('The contribution of this port to the path cost of\n         paths towards the spanning tree root which include\n         this port.  802.1D-1990 recommends that the\n         default value of this parameter be in inverse\n         proportion to the speed of the attached LAN.')
rldot1sMstpInstancePortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 7), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.5.4')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge\n         recorded as the Root in the Configuration BPDUs\n         transmitted by the Designated Bridge for the\n         segment to which the port is attached.')
rldot1sMstpInstancePortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedCost.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedCost.setDescription('The path cost of the Designated Port of the\n         segment connected to this port.  This value is\n         compared to the Root Path Cost field in received\n         bridge PDUs.')
rldot1sMstpInstancePortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedBridge.setReference('IEEE 802.1D-1990: Section 4.5.5.6')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this\n         port considers to be the Designated Bridge for\n         this port's segment.")
rldot1sMstpInstancePortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedPort.setReference('IEEE 802.1D-1990: Section 4.5.5.7')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortDesignatedPort.setDescription("The Port Identifier of the port on the Designated\n         Bridge for this port's segment.")
rldot1sMstpInstancePortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpInstancePortForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpInstancePortForwardTransitions.setDescription('The number of times this port has transitioned\n         from the Learning state to the Forwarding state.')
rldot1sMStpInstancePortAdminPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMStpInstancePortAdminPathCost.setReference('IEEE 802.1D-1998: Section 8.5.5.3')
if mibBuilder.loadTexts: rldot1sMStpInstancePortAdminPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMStpInstancePortAdminPathCost.setDescription("The administratively assigned value for the contribution\n         of this port to the path cost of paths towards the spanning\n         tree root.\n\n         Writing a value of '0' assigns the automatically calculated\n         default Path Cost value to the port.  If the default Path\n         Cost is being used, this object returns '0' when read.\n\n         This complements the object dot1dStpPortPathCost, which\n         returns the operational value of the path cost.")
rldot1sMStpInstancePortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("disabled", 1), ("alternate", 2), ("backup", 3), ("root", 4), ("designated", 5), ("master", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMStpInstancePortRole.setReference('')
if mibBuilder.loadTexts: rldot1sMStpInstancePortRole.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMStpInstancePortRole.setDescription('Specify the role of this this port.')
rldot1sMstpMaxHopes = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpMaxHopes.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpMaxHopes.setDescription('Max number of hopes that an MST BPDU will travel inside a region.')
rldot1sMstpConfigurationName = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpConfigurationName.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpConfigurationName.setDescription("The active configuration name as will be caried in MST BPDU's.")
rldot1sMstpRevisionLevel = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpRevisionLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpRevisionLevel.setDescription('The active revision level.')
rldot1sMstpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 6, 6), )
if mibBuilder.loadTexts: rldot1sMstpVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpVlanTable.setDescription('A table that contains information about the alocation of vlans to groups.')
rldot1sMstpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 6, 6, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1sMstpVlan"))
if mibBuilder.loadTexts: rldot1sMstpVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpVlanEntry.setDescription('A list of information maintained by every vlan\n         about the group it belongs to.')
rldot1sMstpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpVlan.setReference('IEEE 802.1s/D11-2001: Section 13.7')
if mibBuilder.loadTexts: rldot1sMstpVlan.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpVlan.setDescription('The vlan number of the vlan for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1sMstpGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpGroup.setReference('')
if mibBuilder.loadTexts: rldot1sMstpGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpGroup.setDescription('Specifid the active group number this vlan belonges to.')
rldot1sMstpPendingGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpPendingGroup.setReference('')
if mibBuilder.loadTexts: rldot1sMstpPendingGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpPendingGroup.setDescription('Specifid the pending group number this vlan belonges to.')
rldot1sMstpExtPortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 57, 6, 7), )
if mibBuilder.loadTexts: rldot1sMstpExtPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortTable.setDescription('A table that contains MSTP information about ports of the CIST.')
rldot1sMstpExtPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1sMstpExtPortPort"))
if mibBuilder.loadTexts: rldot1sMstpExtPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortEntry.setDescription('A list of information maintained by every port\n         of the CIST.')
rldot1sMstpExtPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpExtPortPort.setReference('IEEE 802.1t/D2-1999: Section 9.2.6')
if mibBuilder.loadTexts: rldot1sMstpExtPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortPort.setDescription('The port number of the port for which this entry\n         contains Spanning Tree Protocol management\n         information.')
rldot1sMstpExtPortInternalOperPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpExtPortInternalOperPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortInternalOperPathCost.setDescription('The contribution of this port to the path cost of\n         paths towards the spanning tree regional root which\n         include this port.  802.1S-2002 recommends that the\n         default value of this parameter be in inverse\n         proportion to the speed of the attached LAN.')
rldot1sMstpExtPortDesignatedRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 3), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalRoot.setReference('IEEE 802.1D-1990: Section 4.5.5.4')
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalRoot.setDescription('The unique Bridge Identifier of the Bridge\n         recorded as the Root in the Configuration BPDUs\n         transmitted by the Designated Bridge for the\n         segment to which the port is attached.')
rldot1sMstpExtPortDesignatedRegionalCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalCost.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortDesignatedRegionalCost.setDescription('The regional path cost of the Designated Port of the\n         segment connected to this port.  This value is\n         compared to the Root Path Cost field in received\n         bridge PDUs.')
rldot1sMstpExtPortBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpExtPortBoundary.setReference('IEEE 802.1D-1990: Section 4.5.5.5')
if mibBuilder.loadTexts: rldot1sMstpExtPortBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortBoundary.setDescription('Indication if the port is conented to to a lan segment\n         outside or inside the region.')
rldot1sMstpExtPortInternalAdminPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 57, 6, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpExtPortInternalAdminPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpExtPortInternalAdminPathCost.setDescription("The administratively assigned value for the contribution\n         of this port to the path cost of paths towards the spanning\n         tree root.\n\n         Writing a value of '0' assigns the automatically calculated\n         default Path Cost value to the port.  If the default Path\n         Cost is being used, this object returns '0' when read.\n\n         This complements the object dot1dStpPortPathCost, which\n         returns the operational value of the path cost.")
rldot1sMstpDesignatedMaxHopes = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpDesignatedMaxHopes.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpDesignatedMaxHopes.setDescription('Max number of hopes that an MST BPDU will travel inside a region.')
rldot1sMstpRegionalRoot = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpRegionalRoot.setReference('IEEE 802.1S-2002: Section 13.16.4')
if mibBuilder.loadTexts: rldot1sMstpRegionalRoot.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpRegionalRoot.setDescription('CIST Regional Root Identifier (13.16.4).\n            The Bridge Identifier of the current CIST Regional Root.')
rldot1sMstpRegionalRootCost = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpRegionalRootCost.setReference('IEEE 802.1S-2002: Section 12.8.1.1.3')
if mibBuilder.loadTexts: rldot1sMstpRegionalRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpRegionalRootCost.setDescription('The CIST path cost from the transmitting Bridge to the\n            CIST Regional Root.')
rldot1sMstpPendingConfigurationName = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpPendingConfigurationName.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpPendingConfigurationName.setDescription('The pending configuration name.')
rldot1sMstpPendingRevisionLevel = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpPendingRevisionLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpPendingRevisionLevel.setDescription('The pending revision level.')
rldot1sMstpPendingAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("copyPendingActive", 1), ("copyActivePending", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1sMstpPendingAction.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpPendingAction.setDescription('The action to be done with the pending configuration.\n         copyPendingActive - to copy the pending mst configuration to the active one.\n         copyActivePending - to copy the active mst configuration to the pending one. ')
rldot1sMstpRemainingHops = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 6, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1sMstpRemainingHops.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1sMstpRemainingHops.setDescription('This count value determines the amount of hops\n         the information transmitted by this bridge can travel.')
rldot1dTpAgingTime = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 57, 7))
rldot1dTpAgingTimeMin = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dTpAgingTimeMin.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: rldot1dTpAgingTimeMin.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dTpAgingTimeMin.setDescription('The min timeout period in seconds for aging out\n         dynamically learned forwarding information.')
rldot1dTpAgingTimeMax = MibScalar((1, 3, 6, 1, 4, 1, 89, 57, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1dTpAgingTimeMax.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: rldot1dTpAgingTimeMax.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1dTpAgingTimeMax.setDescription('The max timeout period in seconds for aging out\n         dynamically learned forwarding information.')
rlTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 58))
rlTelnetMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 58, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTelnetMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetMibVersion.setDescription("MIB's version, the current version is 1.")
rlTelnetPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 58, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTelnetPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetPassword.setDescription('Telnet Password')
rlTelnetTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 58, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTelnetTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetTimeout.setDescription('The number of minutes after which the TCP connection is closed\n         if no activity is detected from the Client')
rlTelnetUsersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 58, 4), )
if mibBuilder.loadTexts: rlTelnetUsersTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetUsersTable.setDescription('This table hold information about current telnet sessions')
rlTelnetUsersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 58, 4, 1), ).setIndexNames((0, "RADLAN-MIB", "rlTelnetSessionId"))
if mibBuilder.loadTexts: rlTelnetUsersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetUsersEntry.setDescription('The row definition for this table.')
rlTelnetSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 58, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTelnetSessionId.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetSessionId.setDescription('Telnet Session ID')
rlTelnetSessionClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 58, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTelnetSessionClientAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetSessionClientAddress.setDescription('Telnet Session Client IP address')
rlTelnetSessionLoginTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 58, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTelnetSessionLoginTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetSessionLoginTime.setDescription('Telnet Session Login Time string')
rlTelnetSessionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 58, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTelnetSessionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetSessionStatus.setDescription('Telnet Session status. After status has been set to diconnect the\n         sessions is closed and the matching entry is deleted from the table.')
rlTelnetLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 89, 58, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTelnetLoginBanner.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetLoginBanner.setDescription('Telnet Login Banner. When telnet connection is established,\n         the banner is the concatanation of this MIB and rlTelnetSecondLoginBanner.')
rlTelnetSecondLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 89, 58, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTelnetSecondLoginBanner.setStatus('mandatory')
if mibBuilder.loadTexts: rlTelnetSecondLoginBanner.setDescription('Telnet Login Banner Extension. When telnet connection is established,\n         the banner is the concatanation of rlTelnetLoginBanner and this MIB')
rlPolicy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 59))
rlArpSpoofing = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 60))
rlArpSpoofingMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 60, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlArpSpoofingMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingMibVersion.setDescription("MIB's version, the current version is 1.")
rlArpSpoofingTable = MibTable((1, 3, 6, 1, 4, 1, 89, 60, 2), )
if mibBuilder.loadTexts: rlArpSpoofingTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingTable.setDescription('A list of the ifIndexes, IP addresses and corresponding MAC addresses.')
rlArpSpoofingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 60, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rlArpSpoofingIfIndex"), (0, "RADLAN-MIB", "rlArpSpoofingLocalIpAddr"))
if mibBuilder.loadTexts: rlArpSpoofingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingEntry.setDescription('An entry of this table specifis ifIndex,IP Address and\n         MAC address.')
rlArpSpoofingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingIfIndex.setDescription('The physical interface for which this entry contains information.')
rlArpSpoofingLocalIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingLocalIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingLocalIpAddr.setDescription('Ip addres for which the device will send ARP reply (ARP spoofing).')
rlArpSpoofingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingMacAddr.setDescription("MAC addres with which the device will send ARP reply.\n        If the field is ommited or its value 0.0.0.0 the device will\n        send with the interface's MAC address.")
rlArpSpoofingRemoteIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingRemoteIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingRemoteIpAddr.setDescription('Ip addres for which the device will send periodically ARP requests\n         if its value differs from 0.0.0.0.')
rlArpSpoofingOutPhysIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingOutPhysIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingOutPhysIfIndex.setDescription("The physical interface to which the device will send periodically\n         ARP requests if its value differs from 0. If its value is 0 then ARP\n         requests will send to all the VLAN's ports.")
rlArpSpoofingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 60, 2, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlArpSpoofingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlArpSpoofingStatus.setDescription('It is used to insert, update or delete an entry')
rlMir = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 61))
rlMirMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 61, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMirMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirMibVersion.setDescription("MIB's version, the current version is 1.")
rlMirMaxNumOfMRIsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 61, 2), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirMaxNumOfMRIsAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirMaxNumOfMRIsAfterReset.setDescription('The maximun instanses of IP Multi Instance Routers after the\n         following reset.')
rlMirMaxNumOfMRIs = MibScalar((1, 3, 6, 1, 4, 1, 89, 61, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMirMaxNumOfMRIs.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirMaxNumOfMRIs.setDescription('The maximun instanses of IP Multi Instance Routers.')
rlMirCurMriNum = MibScalar((1, 3, 6, 1, 4, 1, 89, 61, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirCurMriNum.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirCurMriNum.setDescription('The number of the MRI of which MIB variables are treated at\n        the same time by the SNMP agent.')
rlMirInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 89, 61, 5), )
if mibBuilder.loadTexts: rlMirInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirInterfaceTable.setDescription('A list of the assignment ifinterfaces to IP Router instances.')
rlMirInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 61, 5, 1), ).setIndexNames((0, "RADLAN-MIB", "rlMirInterfaceIfIndex"))
if mibBuilder.loadTexts: rlMirInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirInterfaceEntry.setDescription('An entry of this table specifies the MRID assignement to a L2\n        interfrace.')
rlMirInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 5, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirInterfaceIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirInterfaceIfIndex.setDescription('The L2 interface for which this entry contains information.')
rlMirInterfaceMrid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirInterfaceMrid.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirInterfaceMrid.setDescription('Multi IP Router Instance Identifier to which the\n         interface is assgned.')
rlMirVlanBaseReservedPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 61, 6), )
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsTable.setDescription('A list VLAN based reserved physical ports.')
rlMirVlanBaseReservedPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 61, 6, 1), ).setIndexNames((0, "RADLAN-MIB", "rlMirVlanBaseReservedPortsIfIndex"))
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsEntry.setDescription('A VLAN based reserved physical port.')
rlMirVlanBaseReservedPortsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 6, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsIfIndex.setDescription('IfIndex of VLAN based reserved physical port.')
rlMirVlanBaseReservedPortsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 6, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseReservedPortsStatus.setDescription('It is used to delete an entry')
rlMirVlanBaseLogicalPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 61, 7), )
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsTable.setDescription('A list VLAN based logical ports.')
rlMirVlanBaseLogicalPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 61, 7, 1), ).setIndexNames((0, "RADLAN-MIB", "rlMirVlanBaseLogicalPortsIfIndex"))
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsEntry.setDescription('A VLAN based logical point-to-point port.')
rlMirVlanBaseLogicalPortsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 7, 1, 1), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsIfIndex.setDescription('IfIndex of VLAN based Logical point-to-point port.')
rlMirVlanBaseLogicalPortsReservedIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 7, 1, 2), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsReservedIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsReservedIfIndex.setDescription('IfIndex of VLAN based reserved physical port on which the logical\n         port is defined.')
rlMirVlanBaseLogicalPortsVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsVlanTag.setDescription('VLAN tag.')
rlMirVlanBaseLogicalPortsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 61, 7, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlMirVlanBaseLogicalPortsStatus.setDescription('It is used to add, update and delete an entry')
rlIpMRouteStdMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 62))
rl3sw2swTables = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 63))
rl3sw2swTablesPollingInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 63, 1), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rl3sw2swTablesPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rl3sw2swTablesPollingInterval.setDescription('The polling interval for dynamic 3SW/2SW tables in seconds.')
rlGvrp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 64))
rlPortGvrpTimersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 64, 1), )
if mibBuilder.loadTexts: rlPortGvrpTimersTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpTimersTable.setDescription('A table of GVRP timer values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGvrpTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 64, 1, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGvrpTimersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpTimersEntry.setDescription('GVRP timer values for a bridge port.')
rlPortGvrpJoinTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 1, 1, 1), TimeInterval().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpJoinTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpJoinTime.setDescription('The GVRP Join time, in centiseconds.')
rlPortGvrpLeaveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 1, 1, 2), TimeInterval().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpLeaveTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpLeaveTime.setDescription('The GVRP Leave time, in centiseconds.')
rlPortGvrpLeaveAllTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 1, 1, 3), TimeInterval().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpLeaveAllTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpLeaveAllTime.setDescription('The GVRP LeaveAll time, in centiseconds.')
rlPortGvrpOverrideGarp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 1, 1, 4), EnabledStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpOverrideGarp.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpOverrideGarp.setDescription('If enabled{1}, GVRP timer values for this port are\n         determined by the values in this entry. Otherwise, they\n         are determined by the values in dot1dPortGarpTable.')
rlGvrpSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 64, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlGvrpSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rlGvrpSupported.setDescription('Is GVRP supported in this device or not')
rlGvrpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 64, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlGvrpMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlGvrpMibVersion.setDescription("MIB's version, the current version is 3.")
rlPortGvrpStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 64, 4), )
if mibBuilder.loadTexts: rlPortGvrpStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsTable.setDescription('A table of GVRP statistics values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGvrpStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 64, 4, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGvrpStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsEntry.setDescription('GVRP statistics values for a bridge port.')
rlPortGvrpStatisticsRJE = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsRJE.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsRJE.setDescription('The number of Join Empty  Received  on the port,\n         since the last clearance.')
rlPortGvrpStatisticsRJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsRJIn.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsRJIn.setDescription('The number of Join In  Received  on the port,\n         since the last clearance.')
rlPortGvrpStatisticsREmp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsREmp.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsREmp.setDescription('The number of Empty  Received  on the port,\n         since the last clearance.')
rlPortGvrpStatisticsRLIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLIn.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLIn.setDescription('The number of Leave In Received on the port,\n         since the last clearance.')
rlPortGvrpStatisticsRLE = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLE.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLE.setDescription('The number of Leave Empty Received on the port,\n         since the last clearance.')
rlPortGvrpStatisticsRLA = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLA.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsRLA.setDescription('The number of Leave All Received on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSJE = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSJE.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSJE.setDescription('The number of Join Empty Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSJIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSJIn.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSJIn.setDescription('The number of Join In Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSEmp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSEmp.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSEmp.setDescription('The number of Empty Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSLIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLIn.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLIn.setDescription('The number of Leave In Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSLE = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLE.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLE.setDescription('The number of Leave Empty Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsSLA = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLA.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsSLA.setDescription('The number of Leave All Sent on the port,\n         since the last clearance.')
rlPortGvrpStatisticsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activate", 1), ("passive", 2))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpStatisticsClear.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpStatisticsClear.setDescription("activate - the signal/trigger to clear ALL\n                    the rlPortGvrpStatisticsEntry's fields.\n         passive  - specify that the rlPortGvrpStatisticsClear field is not\n                    activate, or finshed the clearnce process.\n                    the rlPortGvrpStatisticsClear return automatically to\n                    passive after it was activate.")
rlPortGvrpErrorStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 64, 5), )
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsTable.setDescription('A table of GVRP ErrorStatistics values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGvrpErrorStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 64, 5, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsEntry.setDescription('GVRP ErrorStatistics values for a bridge port.')
rlPortGvrpErrorStatisticsInvProt = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvProt.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvProt.setDescription('The number of Invalid Protocol Id encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsInvAtyp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAtyp.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAtyp.setDescription('The number of Invalid Attribute Type encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsInvAval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAval.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAval.setDescription('The number of Invalid Attribute Value encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsInvPlen = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvPlen.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvPlen.setDescription('The number of Invalid PDU Length encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsInvAlen = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAlen.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvAlen.setDescription('The number of Invalid Attribute Length encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsInvEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvEvent.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsInvEvent.setDescription('The number of Invalid Event encountered by\n         the GVRP port. (since the last clearance)')
rlPortGvrpErrorStatisticsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("activate", 1), ("passive", 2))).clone('passive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsClear.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpErrorStatisticsClear.setDescription("activate - the signal/trigger to clear ALL\n                    the rlPortGvrpErrorStatisticsEntry's fields.\n         passive  - specify that the rlPortGvrpErrorStatisticsClear field is not\n                    activate, or finshed the clearnce process.\n                    the rlPortGvrpErrorStatisticsClear return automatically to\n                    passive after it was activate.")
rlPortGvrpApplicantStatusTable = MibTable((1, 3, 6, 1, 4, 1, 89, 64, 6), )
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusTable.setDescription('A table of GVRP Applicant Status values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGvrpApplicantStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 64, 6, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusEntry.setDescription('GVRP Applicant Status value for a bridge port.')
rlPortGvrpApplicantStatusValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("participant", 1), ("nonParticipant", 2))).clone('participant')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusValue.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpApplicantStatusValue.setDescription('participant -  the Gvrp enabled port sending GARP PDUs.\n         nonParticipant - preventing the Gvrp enabled port from sending GARP PDUs.')
rlPortGvrpRegistrationModeTable = MibTable((1, 3, 6, 1, 4, 1, 89, 64, 8), )
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeTable.setDescription('A table of GVRP Registration Mode values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGvrpRegistrationModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 64, 8, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeEntry.setDescription('GVRP  Registration Mode value for a bridge port.')
rlPortGvrpRegistrationModeForbidden = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 64, 8, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeForbidden.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGvrpRegistrationModeForbidden.setDescription('true -  deregisters all VLANS on the specified port and prevents any\n                 VLAN creation or registration on that port.\n         false - the registration operation on this port behaves normally.')
rlDot3adAgg = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 65))
rlEmbWeb = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 66))
rlSwPackageVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 67))
rlSwPackageVersionTable = MibTable((1, 3, 6, 1, 4, 1, 89, 67, 1), )
if mibBuilder.loadTexts: rlSwPackageVersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlSwPackageVersionTable.setDescription('The table listing the current versions of packages\n         that are included in the running software.')
rlSwPackageVersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 67, 1, 1), ).setIndexNames((1, "RADLAN-MIB", "rlSwPackageVersionName"))
if mibBuilder.loadTexts: rlSwPackageVersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlSwPackageVersionEntry.setDescription('The row definition for this table.')
rlSwPackageVersionName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 67, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSwPackageVersionName.setStatus('mandatory')
if mibBuilder.loadTexts: rlSwPackageVersionName.setDescription('The Package name.')
rlSwPackageVersionVesrion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 67, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSwPackageVersionVesrion.setStatus('mandatory')
if mibBuilder.loadTexts: rlSwPackageVersionVesrion.setDescription('The Package version.')
rlBroadcom = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 68))
rlMultiSessionTerminal = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 69))
rlTerminalDebugModePassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 69, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTerminalDebugModePassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlTerminalDebugModePassword.setDescription('When a user wants to change the terminal mode\n            from debug mode to ASCII he must enter this password first')
rlRCli = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 70))
rlRCliMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlRCliMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlRCliMibVersion.setDescription("MIB's version, the current version is 1.")
rlRCliUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRCliUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlRCliUserPassword.setDescription('RCLI User mode Password')
rlRCliEnablePassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRCliEnablePassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlRCliEnablePassword.setDescription('RCLI Enable mode Password')
rlRCliConfigPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRCliConfigPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rlRCliConfigPassword.setDescription('RCLI Config mode Password')
rlRCliTimer = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRCliTimer.setStatus('mandatory')
if mibBuilder.loadTexts: rlRCliTimer.setDescription('RCLI Timeout')
rlRcliFileAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 70, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notUsedAfterReset", 1), ("usedAfterReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlRcliFileAction.setStatus('mandatory')
if mibBuilder.loadTexts: rlRcliFileAction.setDescription('RCLI Configuration File action determines whether\n        The device configuration after reset will be set by\n        the configuration file content or not.')
rlBgp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 71))
rlAgentsCapabilitiesGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 72))
rlAggregateVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 73))
rlAggregateVlanMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 73, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlAggregateVlanMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanMibVersion.setDescription("MIB's version, the current version is 1.")
rlAggregateVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 73, 2), )
if mibBuilder.loadTexts: rlAggregateVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanTable.setDescription('The table creates an aggregateVlans, the IfIndex is from 10000')
rlAggregateVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 73, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rlAggregateVlanIndex"))
if mibBuilder.loadTexts: rlAggregateVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanEntry.setDescription('The row definition for this table.')
rlAggregateVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlAggregateVlanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanIndex.setDescription('This index indicate the aggrigateVlan id, the aggregate\n        vlan index is starting from 10000 ')
rlAggregateVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlAggregateVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanName.setDescription('The name of the aggregateVlan ')
rlAggregateVlanPhysAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("reserve", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlAggregateVlanPhysAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanPhysAddressType.setDescription(' This variable indicates whether the physical address assigned to this\n          VLAN should be the default one or be chosen from the set of\n          reserved physical addresses of the device.')
rlAggregateVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlAggregateVlanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanStatus.setDescription("The status of the aggregateVlan table entry. It's used to delete an entry")
rlAggregateSubVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 73, 3), )
if mibBuilder.loadTexts: rlAggregateSubVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateSubVlanTable.setDescription('The table indicates all the allocated sub-vlans to the\n        aggregateVlans, an entry in the rlAggregateVlanTable must\n        be exist before allocating the subVlans')
rlAggregateSubVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 73, 3, 1), ).setIndexNames((0, "RADLAN-MIB", "rlAggregateVlanIndex"), (0, "RADLAN-MIB", "rlAggregateSubVlanIfIndex"))
if mibBuilder.loadTexts: rlAggregateSubVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateSubVlanEntry.setDescription('The row definition for this table.')
rlAggregateSubVlanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlAggregateSubVlanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateSubVlanIfIndex.setDescription('Indicate the subVlan that allocated to the aggregate vlan')
rlAggregateSubVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 73, 3, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlAggregateSubVlanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateSubVlanStatus.setDescription("The status of the aggregateSubVlan table entry.\n        It's used to delete an entry")
rlAggregateVlanArpProxy = MibScalar((1, 3, 6, 1, 4, 1, 89, 73, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlAggregateVlanArpProxy.setStatus('mandatory')
if mibBuilder.loadTexts: rlAggregateVlanArpProxy.setDescription('When ARP Proxy is enabled, the router can respond to\n          ARP requests for nodes located on different sub-vlans,\n          which belong to the same Super VLAN.The router responds\n          with its own MAC address.\n          When ARP Proxy is disabled, the router responds only\n          to ARP requests for its own IP addresses.')
rlGmrp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 75))
rlGmrpSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 75, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlGmrpSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpSupported.setDescription('Is Gmrp supported in the device or not.')
rlGmrpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 75, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlGmrpMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpMibVersion.setDescription("MIB's version, the current version is 1.")
rlPortGmrpTimersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 75, 3), )
if mibBuilder.loadTexts: rlPortGmrpTimersTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpTimersTable.setDescription('A table of Gmrp timer values for every bridge\n         port.  This is indexed by dot1dBasePort.')
rlPortGmrpTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 75, 3, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortGmrpTimersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpTimersEntry.setDescription('Gmrp timer values for a bridge port.')
rlPortGmrpJoinTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 3, 1, 1), TimeInterval().clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGmrpJoinTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpJoinTime.setDescription('The Gmrp Join time, in centiseconds.')
rlPortGmrpLeaveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 3, 1, 2), TimeInterval().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGmrpLeaveTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpLeaveTime.setDescription('The Gmrp Leave time, in centiseconds.')
rlPortGmrpLeaveAllTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 3, 1, 3), TimeInterval().clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGmrpLeaveAllTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpLeaveAllTime.setDescription('The Gmrp LeaveAll time, in centiseconds.')
rlPortGmrpOverrideGarp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 3, 1, 4), EnabledStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortGmrpOverrideGarp.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortGmrpOverrideGarp.setDescription('If enabled{1}, Gmrp timer values for this port are\n         determined by the values in this entry. Otherwise, they\n         are determined by the values in dot1dPortGarpTable.')
rlGmrpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 75, 4), )
if mibBuilder.loadTexts: rlGmrpVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpVlanTable.setDescription('This table is to Enable/Disable Gmrp in the vlan.')
rlGmrpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 75, 4, 1), ).setIndexNames((0, "RADLAN-MIB", "rlGmrpVlanTag"))
if mibBuilder.loadTexts: rlGmrpVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpVlanEntry.setDescription('An entry in the rlGmrpVlanTable.')
rlGmrpVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlGmrpVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpVlanTag.setDescription('The tag of the VLAN for which this entry contains information.')
rlGmrpVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 75, 4, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlGmrpVlanEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlGmrpVlanEnable.setDescription('Enable/Disable Gmrp in the vlan.')
rlDhcpCl = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 76))
rlDhcpClActionTable = MibTable((1, 3, 6, 1, 4, 1, 89, 76, 3), )
if mibBuilder.loadTexts: rlDhcpClActionTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClActionTable.setDescription(' The (conceptual) table mentione IP address which must be\n              released/renewed on the interface.')
rlDhcpClActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 76, 3, 1), ).setIndexNames((0, "RADLAN-MIB", "rlDhcpClActionIfIndex"))
if mibBuilder.loadTexts: rlDhcpClActionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClActionEntry.setDescription('An entry (conceptual row) in dhcpClActionTable.')
rlDhcpClActionIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpClActionIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClActionIfIndex.setDescription(' The interface which the action is implemented for\n        or NULL if it implemented for all device. ')
rlDhcpClActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 3, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDhcpClActionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClActionStatus.setDescription('The status of this entry.  Creating the entry renewing Dhcp\n              address on the interface; destroying the entry release Dhcp\n              address on the interface.')
rlDhcpClActionHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 3, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDhcpClActionHostName.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClActionHostName.setDescription(' This option specifies the name of the client.')
rlDhcpApprovalEnabled = MibScalar((1, 3, 6, 1, 4, 1, 89, 76, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalEnabled.setDescription('DHCP Approval feature status - enable (True) or desable (False).\n                Must be True only if DHCP Approval supported, device has only one\n                ip interface and default ip exist.')
rlDhcpApprovalWaitingTable = MibTable((1, 3, 6, 1, 4, 1, 89, 76, 5), )
if mibBuilder.loadTexts: rlDhcpApprovalWaitingTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingTable.setDescription('IP addresses waiting for approval.')
rlDhcpApprovalWaitingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 76, 5, 1), ).setIndexNames((0, "RADLAN-MIB", "rlDhcpApprovalWaitingIfIndex"))
if mibBuilder.loadTexts: rlDhcpApprovalWaitingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingEntry.setDescription('An entry in rlDhcpApprovalWaitingTable.')
rlDhcpApprovalWaitingIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 5, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalWaitingIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingIfIndex.setDescription('IP interface ifIndex.')
rlDhcpApprovalWaitingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalWaitingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingAddress.setDescription('IP Address waiting for approval.')
rlDhcpApprovalWaitingMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalWaitingMask.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingMask.setDescription('Mask waiting for approval.')
rlDhcpApprovalWaitingGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalWaitingGateway.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalWaitingGateway.setDescription('Default gateway of received address.')
rlDhcpApprovalActionTable = MibTable((1, 3, 6, 1, 4, 1, 89, 76, 6), )
if mibBuilder.loadTexts: rlDhcpApprovalActionTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionTable.setDescription('Action for waiting ip address (approve/decline).')
rlDhcpApprovalActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 76, 6, 1), ).setIndexNames((0, "RADLAN-MIB", "rlDhcpApprovalActionIfIndex"), (0, "RADLAN-MIB", "rlDhcpApprovalActionAddress"), (0, "RADLAN-MIB", "rlDhcpApprovalActionMask"))
if mibBuilder.loadTexts: rlDhcpApprovalActionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionEntry.setDescription('An entry in rlDhcpApprovalActionTable.')
rlDhcpApprovalActionIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 6, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalActionIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionIfIndex.setDescription('IP interface ifIndex.')
rlDhcpApprovalActionAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalActionAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionAddress.setDescription('IP Address.')
rlDhcpApprovalActionMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpApprovalActionMask.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionMask.setDescription('IP Address mask.')
rlDhcpApprovalActionApprove = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 6, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDhcpApprovalActionApprove.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpApprovalActionApprove.setDescription('Approve or decline ip address.')
rlDhcpClCommandTable = MibTable((1, 3, 6, 1, 4, 1, 89, 76, 7), ).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDhcpClCommandTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClCommandTable.setDescription('Action MIB for DHCP Renew command.')
rlDhcpClCommandEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 76, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rlDhcpClCommandEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClCommandEntry.setDescription('The row definition for this table.')
rlDhcpClCommandAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 76, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("renew", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDhcpClCommandAction.setStatus('mandatory')
if mibBuilder.loadTexts: rlDhcpClCommandAction.setDescription('Action to apply.')
rlStormCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 77))
rlStormCtrlSupport = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlSupport.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSupport.setDescription('Identify if the strom control protection is supported')
rlStormCtrlMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlMibVersion.setDescription("MIB's version, the current version is 3.")
rlStormCtrlRateUnitTypeSupport = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlRateUnitTypeSupport.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlRateUnitTypeSupport.setDescription('the supported rate unit type for the storm rate control')
rlStormCtrlTypeSupport = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlTypeSupport.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlTypeSupport.setDescription('the supported frame type for the storm control protection')
rlStormCtrlRateSupportPerType = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlRateSupportPerType.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlRateSupportPerType.setDescription('identify if rate control is supported for each frame type')
rlStormCtrlEnbaleDependencyBetweenTypes = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlEnbaleDependencyBetweenTypes.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlEnbaleDependencyBetweenTypes.setDescription('indicate enable limitation of dependency between frame types,\n         such as enabling of multicast should be with the enabling of\n         broadcast type (bcm 5632)')
rlStormCtrlRateDependencyBetweenTypes = MibScalar((1, 3, 6, 1, 4, 1, 89, 77, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlRateDependencyBetweenTypes.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlRateDependencyBetweenTypes.setDescription('indicate limitation of dependency between frame types for\n         rate assignment, for example: assigning of rate limit for unicast\n         frame must assigning the same rate for multicast and bradcast\n         frame (bcm 5615), in case the device support enbale per each frame\n         type but with the same rate limitation.')
rlStormCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 89, 77, 8), )
if mibBuilder.loadTexts: rlStormCtrlTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlTable.setDescription('The table contains the storm control protection per port')
rlStormCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 77, 8, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlStormCtrlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlEntry.setDescription('storm control protection, defined per port,frame type and rate')
rlStormCtrlRateType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 1), RlStormCtrlRateUnit()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlRateType.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlRateType.setDescription('indicate the rate unit type')
rlStormCtrlUnknownUnicastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlUnknownUnicastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlUnknownUnicastEnable.setDescription('enable or disable the storm control for unknown unicast frames')
rlStormCtrlUnknownUnicastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 3), Unsigned_32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlUnknownUnicastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlUnknownUnicastRate.setDescription('set the storm control rate limit for the unknown unicast frames,\n        0 indicate blocking of frames from this type.')
rlStormCtrlUnknownMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlUnknownMulticastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlUnknownMulticastEnable.setDescription('enable or disable the storm control for unknown multicast frames')
rlStormCtrlUnknownMulticastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 5), Unsigned_32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlUnknownMulticastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlUnknownMulticastRate.setDescription('set the storm control rate limit for the unknown multicast frames,\n        0 indicate blocking of frames from this type.')
rlStormCtrlBroadcastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlBroadcastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlBroadcastEnable.setDescription('enable or disable the storm control for Broadcast frames')
rlStormCtrlBroadcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 7), Unsigned_32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlBroadcastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlBroadcastRate.setDescription('set the storm control rate limit for the Broadcast frames,\n        0 indicate blocking of frames from this type.')
rlStormCtrlMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlMulticastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlMulticastEnable.setDescription('enable or disable the storm control for multicast frames')
rlStormCtrlMulticastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 9), Unsigned_32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlMulticastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlMulticastRate.setDescription('set the storm control rate limit for the multicast frames,\n        0 indicate blocking of frames from this type.')
rlStormCtrlSetDefaultRateType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultRateType.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultRateType.setDescription('indicate if return the rate unit type to its default.')
rlStormCtrlSetDefaultUnknownUnicastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownUnicastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownUnicastEnable.setDescription('indicate if return the storm control enable for unknown unicast frames\n         to its default.')
rlStormCtrlSetDefaultUnknownUnicastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownUnicastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownUnicastRate.setDescription('indicate if return the storm control rate limit for the unknown unicast frames\n         to its default.')
rlStormCtrlSetDefaultUnknownMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownMulticastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownMulticastEnable.setDescription('indicate if return the storm control enable for unknown multicast frames\n         to its default.')
rlStormCtrlSetDefaultUnknownMulticastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownMulticastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultUnknownMulticastRate.setDescription('indicate if return the storm control rate limit for the unknown multicast frames\n         to its default.')
rlStormCtrlSetDefaultBroadcastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultBroadcastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultBroadcastEnable.setDescription('indicate if return the storm control enable for Broadcast frames\n         to its default.')
rlStormCtrlSetDefaultBroadcastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultBroadcastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultBroadcastRate.setDescription('indicate if return the storm control rate limit for the Broadcast frames\n         to its default.')
rlStormCtrlSetDefaultMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 17), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultMulticastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultMulticastEnable.setDescription('indicate if return the storm control for multicast frames\n         to its default.')
rlStormCtrlSetDefaultMulticastRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 8, 1, 18), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlStormCtrlSetDefaultMulticastRate.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlSetDefaultMulticastRate.setDescription('indicate if return the storm control rate limit for the multicast frames\n         to its default.')
rlStormCtrlGroupTable = MibTable((1, 3, 6, 1, 4, 1, 89, 77, 9), )
if mibBuilder.loadTexts: rlStormCtrlGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupTable.setDescription('The table contains per port for each supported frame type\n        to which group it belongs.')
rlStormCtrlGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 77, 9, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlStormCtrlGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupEntry.setDescription('group id for each supported frame type defined per port.')
rlStormCtrlGroupUnknownUnicastId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlGroupUnknownUnicastId.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupUnknownUnicastId.setDescription('Indicates the id of the group for unknown unicast frame type that\n        the port belongs to,\n        0 indicates that unknown unicast frame type is not supported.')
rlStormCtrlGroupUnknownMulticastId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlGroupUnknownMulticastId.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupUnknownMulticastId.setDescription('Indicates the id of the group for unknown multicast frame type that\n        the port belongs to,\n        0 indicates that unknown multicast frame type is not supported.')
rlStormCtrlGroupBroadcastId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlGroupBroadcastId.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupBroadcastId.setDescription('Indicates the id of the group for broadcast frame type that\n        the port belongs to,\n        0 indicates that broadcast frame type is not supported.')
rlStormCtrlGroupMulticastId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 77, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStormCtrlGroupMulticastId.setStatus('mandatory')
if mibBuilder.loadTexts: rlStormCtrlGroupMulticastId.setDescription('Indicates the id of the group for multicast frame type that\n        the port belongs to,\n        0 indicates that multicast frame type is not supported.')
rlSsh = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 78))
rlAAA = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 79))
rlRadius = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 80))
rlTraceRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 81))
rlTraceRouteMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 81, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTraceRouteMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlTraceRouteMibVersion.setDescription("MIB's version, the current version is 1.")
rlSyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 82))
rlEnv = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 83))
rlSmon = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 84))
rlPortCopyMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 84, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortCopyMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortCopyMibVersion.setDescription("MIB's version, the current version is 1.")
rlPortCopySupport = MibScalar((1, 3, 6, 1, 4, 1, 89, 84, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlPortCopySupport.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortCopySupport.setDescription('supported - The standard portCopy is supported.\n        notSupported - the standard portCopy is not supported.\n                       only basic portCopy operation is supported. ')
rlPortCopyVlanTaggingTable = MibTable((1, 3, 6, 1, 4, 1, 89, 84, 3), )
if mibBuilder.loadTexts: rlPortCopyVlanTaggingTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortCopyVlanTaggingTable.setDescription('A supplementing table for portCopyTable.\n         For every portCopyDest a vlan-tagging option is available.')
rlPortCopyVlanTaggingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 84, 3, 1), ).setIndexNames((0, "BRIDGE-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: rlPortCopyVlanTaggingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortCopyVlanTaggingEntry.setDescription('Each entry specify how  mirrored packets will transmit from\n         the portCopyDest:   Tagged or unTagged.\n         The values in this entry will be valid only when the\n         dot1dBasePort will be configured as a portCopyDest\n         in the portCopyTable.')
rlPortCopyVlanTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 84, 3, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlPortCopyVlanTagging.setStatus('mandatory')
if mibBuilder.loadTexts: rlPortCopyVlanTagging.setDescription('TRUE  - Mirrored packets will transmit from portCopyDest - Tagged\n         FALSE - Mirrored packets will transmit from portCopyDest - unTagged')
rlSocket = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 85))
rlSocketMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 85, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketMibVersion.setDescription("MIB's version, the current version is 1.")
rlSocketTable = MibTable((1, 3, 6, 1, 4, 1, 89, 85, 2), )
if mibBuilder.loadTexts: rlSocketTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketTable.setDescription('The (conceptual) table listing the sockets which are currently\n        open in the system.')
rlSocketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 85, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rlSocketId"))
if mibBuilder.loadTexts: rlSocketEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketEntry.setDescription('An entry (conceptual row) in the SocketTable.')
rlSocketId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 85, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketId.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketId.setDescription('The value of the id of the socket. ')
rlSocketType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 85, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stream", 1), ("dgram", 2), ("raw", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketType.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketType.setDescription('Specifies the type of the socket. ')
rlSocketState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 85, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("connected", 1), ("notConnected", 2), ("recvClosed", 3), ("sendClosed", 4), ("closed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketState.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketState.setDescription('Specifies the state in which the socket is in. ')
rlSocketBlockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 85, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("blocking", 1), ("nonBlocking", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketBlockMode.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketBlockMode.setDescription('Specifies the blocking mode of the socket. ')
rlSocketUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 85, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSocketUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: rlSocketUpTime.setDescription('The time elapsed since this socket was created.')
rlDigitalKeyManage = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 86))
rlMD5KeyChainTable = MibTable((1, 3, 6, 1, 4, 1, 89, 86, 1), )
if mibBuilder.loadTexts: rlMD5KeyChainTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyChainTable.setDescription("Key-chains and key ID's")
rlMD5KeyChainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 86, 1, 1), ).setIndexNames((0, "RADLAN-MIB", "rlMD5KeyChainName"), (0, "RADLAN-MIB", "rlMD5KeyChainKeyId"))
if mibBuilder.loadTexts: rlMD5KeyChainEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyChainEntry.setDescription('Key-chain with key ID that belongs to this chain')
rlMD5KeyChainName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMD5KeyChainName.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyChainName.setDescription('Name of the key-chain to which belongs\n         the secret authentication key')
rlMD5KeyChainKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMD5KeyChainKeyId.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyChainKeyId.setDescription('A 8-bit identifier for the secret authentication key.\n         This identifier is the same as key ID used in rlMD5KeyTable.')
rlMD5KeyChainKeyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyChainKeyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyChainKeyRowStatus.setDescription('It is used to insert, update or delete an entry')
rlMD5KeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 86, 2), )
if mibBuilder.loadTexts: rlMD5KeyTable.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyTable.setDescription('Secret authentication keys\n         used by MD5 Authentication Algorithm')
rlMD5KeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 86, 2, 1), ).setIndexNames((0, "RADLAN-MIB", "rlMD5KeyId"))
if mibBuilder.loadTexts: rlMD5KeyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyEntry.setDescription('Secret authentication key with all related parameters')
rlMD5KeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMD5KeyId.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyId.setDescription('A 8-bit identifier for the secret authentication key')
rlMD5Key = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5Key.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5Key.setDescription('The 128-bit secret authentication key.\n         The key can get value only once and cannot be modified.\n         When read, rlMD5KeyChainKey always returns an\n         Octet String of length zero.')
rlMD5KeyStartAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 3), DateAndTime().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyStartAccept.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyStartAccept.setDescription('The time that the router will start accepting packets\n          that have been created with the given key')
rlMD5KeyStartGenerate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 4), DateAndTime().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyStartGenerate.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyStartGenerate.setDescription('The time that the router will start using the key\n         for packet generation')
rlMD5KeyStopGenerate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 5), DateAndTime().clone(hexValue="FFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyStopGenerate.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyStopGenerate.setDescription('The time that the router will stop using the key\n         for packet generation')
rlMD5KeyStopAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 6), DateAndTime().clone(hexValue="FFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyStopAccept.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyStopAccept.setDescription('The time that the router will stop accepting packets\n          that have been created with the given key')
rlMD5KeyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 86, 2, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMD5KeyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlMD5KeyRowStatus.setDescription('It is used to insert, update or delete an entry')
rlCopy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 87))
rlQosCliMib = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 88))
rlMngInf = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 89))
rlPhy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 90))
rlJumboFrames = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 91))
rlJumboFramesCurrentStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 91, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlJumboFramesCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rlJumboFramesCurrentStatus.setDescription('Show the current Jumbo Frames status')
rlJumboFramesStatusAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 91, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlJumboFramesStatusAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rlJumboFramesStatusAfterReset.setDescription('Set the Jumbo Frames status after reset')
rlTimeSynchronization = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92))
rlDnsCl = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 93))
rlCDB = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 94))
rlStartupCDBChanged = MibScalar((1, 3, 6, 1, 4, 1, 89, 94, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlStartupCDBChanged.setStatus('mandatory')
if mibBuilder.loadTexts: rlStartupCDBChanged.setDescription("Indicates whether the startup CDB has changed between the router's\n         last two reboots")
rlManualReboot = MibScalar((1, 3, 6, 1, 4, 1, 89, 94, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlManualReboot.setStatus('mandatory')
if mibBuilder.loadTexts: rlManualReboot.setDescription('Indicates whether the device was shutdown orderly before reboot or\n         not (i.e. power failure)')
rldot1x = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 95))
rldot1xMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xMibVersion.setDescription("MIB's version, the current version is 1.")
rldot1xExtAuthSessionStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 2), )
if mibBuilder.loadTexts: rldot1xExtAuthSessionStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xExtAuthSessionStatsTable.setDescription('A table that contains the session statistics objects\n        for the Authenticator PAE associated with each Port.\n        An entry appears in this table for each port that may\n        authenticate access to itself.')
rldot1xExtAuthSessionStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 2, 1), )
dot1xAuthSessionStatsEntry.registerAugmentions(("RADLAN-MIB", "rldot1xExtAuthSessionStatsEntry"))
rldot1xExtAuthSessionStatsEntry.setIndexNames(*dot1xAuthSessionStatsEntry.getIndexNames())
if mibBuilder.loadTexts: rldot1xExtAuthSessionStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xExtAuthSessionStatsEntry.setDescription('The session statistics information for an Authenticator\n        PAE.  This shows the current values being collected for\n        each session that is still in progress, or the final\n        values for the last valid session on each port where\n        there is no session currently active.')
rlDot1xAuthSessionAuthenticMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("remoteAuthServer", 1), ("localAuthServer", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDot1xAuthSessionAuthenticMethod.setStatus('mandatory')
if mibBuilder.loadTexts: rlDot1xAuthSessionAuthenticMethod.setDescription('The authentication method used to establish the\n        session.')
rldot1xGuestVlanSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xGuestVlanSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xGuestVlanSupported.setDescription('indicate if guest vlan is supported.')
rldot1xGuestVlanVID = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 4), VlanIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xGuestVlanVID.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xGuestVlanVID.setDescription('specify the guest vlan tag , 0 for non exiting.')
rldot1xGuestVlanPorts = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 5), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xGuestVlanPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xGuestVlanPorts.setDescription('the ports that can be members in the guest vlan')
rldot1xUnAuthenticatedVlanSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanSupported.setDescription('indicate if unauthenticated Vlan is supported.')
rldot1xUnAuthenticatedVlanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 7), )
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanTable.setDescription('port belong to vlan in all port authenticated state except force unauthenticated table')
rldot1xUnAuthenticatedVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 7, 1), ).setIndexNames((0, "Q-BRIDGE-MIB", "dot1qFdbId"))
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanEntry.setDescription(' port belong to vlan in all port authenticated state except force unauthenticated entry')
rldot1xUnAuthenticatedVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 7, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUnAuthenticatedVlanStatus.setDescription('The row status variable, used according to\n       row installation and removal conventions.')
rldot1xUserBasedVlanSupported = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xUserBasedVlanSupported.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUserBasedVlanSupported.setDescription('indicate if user based Vlan is supported.')
rldot1xUserBasedVlanPorts = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 9), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xUserBasedVlanPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xUserBasedVlanPorts.setDescription('the ports that can be members in the user based vlan')
rldot1xAuthenticationPortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 10), )
if mibBuilder.loadTexts: rldot1xAuthenticationPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthenticationPortTable.setDescription('A table of system level information for each port\n        supported by the Port Access Entity.  An entry appears\n        in this table for each port of this system.')
rldot1xAuthenticationPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 10, 1), ).setIndexNames((0, "IEEE8021-PAE-MIB", "dot1xPaePortNumber"))
if mibBuilder.loadTexts: rldot1xAuthenticationPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthenticationPortEntry.setDescription('The Port number and mac method')
rldot1xAuthenticationPortMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eapolOnly", 1), ("macAndEapol", 2), ("macOnly", 3))).clone('eapolOnly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xAuthenticationPortMethod.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthenticationPortMethod.setDescription('The value of the mac based authenication.')
rldot1xAuthMultiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 11), )
if mibBuilder.loadTexts: rldot1xAuthMultiStatsTable.setReference('9.4.2 Authenticator Statistics')
if mibBuilder.loadTexts: rldot1xAuthMultiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiStatsTable.setDescription('A table that contains the statistics objects for the\n         Authenticator PAE associated with each Port and MAC for\n         multisession 802.1x mode of operation.\n         An entry appears in this table for each port and MAC that have an\n         authentication session currently running under way for them.')
rldot1xAuthMultiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 11, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1xAuthMultiStatsPortNumber"), (0, "RADLAN-MIB", "rldot1xAuthMultiStatsSourceMac"))
if mibBuilder.loadTexts: rldot1xAuthMultiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiStatsEntry.setDescription('The statistics information for an Authenticator PAE.')
rldot1xAuthMultiStatsPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiStatsPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiStatsPortNumber.setDescription('Port Number.')
rldot1xAuthMultiStatsSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiStatsSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiStatsSourceMac.setDescription('Mac of the authentication session.')
rldot1xAuthMultiEapolFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesRx.setReference('9.4.2, EAPOL frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesRx.setDescription('The number of valid EAPOL frames of any type\n        that have been received by this Authenticator.')
rldot1xAuthMultiEapolFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesTx.setReference('9.4.2, EAPOL frames transmitted')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolFramesTx.setDescription('The number of EAPOL frames of any type\n        that have been transmitted by this Authenticator.')
rldot1xAuthMultiEapolStartFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolStartFramesRx.setReference('9.4.2, EAPOL Start frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolStartFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolStartFramesRx.setDescription('The number of EAPOL Start frames that have\n        been received by this Authenticator.')
rldot1xAuthMultiEapolLogoffFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolLogoffFramesRx.setReference('9.4.2, EAPOL Logoff frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolLogoffFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolLogoffFramesRx.setDescription('The number of EAPOL Logoff frames that have\n        been received by this Authenticator.')
rldot1xAuthMultiEapolRespIdFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespIdFramesRx.setReference('9.4.2, EAPOL Resp/Id frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespIdFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespIdFramesRx.setDescription('The number of EAP Resp/Id frames that have\n        been received by this Authenticator.')
rldot1xAuthMultiEapolRespFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespFramesRx.setReference('9.4.2, EAPOL Response frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolRespFramesRx.setDescription('The number of valid EAP Response frames\n        (other than Resp/Id frames) that have been\n        received by this Authenticator.')
rldot1xAuthMultiEapolReqIdFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqIdFramesTx.setReference('9.4.2, EAPOL Req/Id frames transmitted')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqIdFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqIdFramesTx.setDescription('The number of EAP Req/Id frames that have been\n        transmitted by this Authenticator.')
rldot1xAuthMultiEapolReqFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqFramesTx.setReference('9.4.2, EAPOL Request frames transmitted')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapolReqFramesTx.setDescription('The number of EAP Request frames\n        (other than Rq/Id frames) that have been\n        transmitted by this Authenticator.')
rldot1xAuthMultiInvalidEapolFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiInvalidEapolFramesRx.setReference('9.4.2, Invalid EAPOL frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiInvalidEapolFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiInvalidEapolFramesRx.setDescription('The number of EAPOL frames that have been\n        received by this Authenticator in which the\n        frame type is not recognized.')
rldot1xAuthMultiEapLengthErrorFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEapLengthErrorFramesRx.setReference('9.4.2, EAP length error frames received')
if mibBuilder.loadTexts: rldot1xAuthMultiEapLengthErrorFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEapLengthErrorFramesRx.setDescription('The number of EAPOL frames that have been received\n        by this Authenticator in which the Packet Body\n        Length field is invalid.')
rldot1xAuthMultiDiagTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 12), )
if mibBuilder.loadTexts: rldot1xAuthMultiDiagTable.setReference('9.4.3 Authenticator Diagnostics')
if mibBuilder.loadTexts: rldot1xAuthMultiDiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiDiagTable.setDescription('A table that contains the diagnostics objects for the\n         Authenticator PAE associated with each Port and MAC.\n         An entry appears in this table for each port and MAC that have an\n         authentication session currently running under way for them.')
rldot1xAuthMultiDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 12, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1xAuthMultiDiagPortNumber"), (0, "RADLAN-MIB", "rldot1xAuthMultiDiagSourceMac"))
if mibBuilder.loadTexts: rldot1xAuthMultiDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiDiagEntry.setDescription('The diagnostics information for an Authenticator PAE.')
rldot1xAuthMultiDiagPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiDiagPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiDiagPortNumber.setDescription('Port Number.')
rldot1xAuthMultiDiagSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiDiagSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiDiagSourceMac.setDescription('Mac of the authentication session.')
rldot1xAuthMultiEntersConnecting = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEntersConnecting.setReference('9.4.2, 8.5.4.2.1')
if mibBuilder.loadTexts: rldot1xAuthMultiEntersConnecting.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEntersConnecting.setDescription('Counts the number of times that the state machine\n        transitions to the CONNECTING state from any other\n        state.')
rldot1xAuthMultiEntersAuthenticating = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiEntersAuthenticating.setReference('9.4.2, 8.5.4.2.3')
if mibBuilder.loadTexts: rldot1xAuthMultiEntersAuthenticating.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiEntersAuthenticating.setDescription('Counts the number of times that the state machine\n        transitions from CONNECTING to AUTHENTICATING, as a\n        result of an EAP-Response/Identity message being\n        received from the Supplicant.')
rldot1xAuthMultiAuthSuccessWhileAuthenticating = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthSuccessWhileAuthenticating.setReference('9.4.2, 8.5.4.2.4')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthSuccessWhileAuthenticating.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthSuccessWhileAuthenticating.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATING to AUTHENTICATED, as a\n        result of the Backend Authentication state machine\n        indicating successful authentication of the Supplicant\n        (authSuccess = TRUE).')
rldot1xAuthMultiAuthFailWhileAuthenticating = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthFailWhileAuthenticating.setReference('9.4.2, 8.5.4.2.6')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthFailWhileAuthenticating.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthFailWhileAuthenticating.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATING to HELD, as a result\n        of the Backend Authentication state machine indicating\n        authentication failure (authFail = TRUE).')
rldot1xAuthMultiAuthReauthsWhileAuthenticating = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticating.setReference('9.4.2, 8.5.4.2.7')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticating.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticating.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATING to ABORTING, as a result\n        of a reauthentication request (reAuthenticate = TRUE).')
rldot1xAuthMultiAuthEapStartsWhileAuthenticating = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticating.setReference('9.4.2, 8.5.4.2.8')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticating.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticating.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATING to ABORTING, as a result\n        of an EAPOL-Start message being received\n        from the Supplicant.')
rldot1xAuthMultiAuthReauthsWhileAuthenticated = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticated.setReference('9.4.2, 8.5.4.2.10')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticated.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthReauthsWhileAuthenticated.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATED to CONNECTING, as a\n        result of a reauthentication request\n        (reAuthenticate = TRUE).')
rldot1xAuthMultiAuthEapStartsWhileAuthenticated = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticated.setReference('9.4.2, 8.5.4.2.11')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticated.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiAuthEapStartsWhileAuthenticated.setDescription('Counts the number of times that the state machine\n        transitions from AUTHENTICATED to CONNECTING, as a\n        result of an EAPOL-Start message being received from the\n        Supplicant.')
rldot1xAuthMultiBackendResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendResponses.setReference('9.4.2, 8.5.6.2.1')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendResponses.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendResponses.setDescription('Counts the number of times that the state machine sends\n        an initial Access-Request packet to the Authentication\n        server (i.e., executes sendRespToServer on entry to the\n        RESPONSE state). Indicates that the Authenticator\n        attempted communication with the Authentication Server.')
rldot1xAuthMultiBackendAccessChallenges = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAccessChallenges.setReference('9.4.2, 8.5.6.2.2')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAccessChallenges.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAccessChallenges.setDescription('Counts the number of times that the state machine\n        receives an initial Access-Challenge packet from the\n        Authentication server (i.e., aReq becomes TRUE,\n        causing exit from the RESPONSE state). Indicates that\n        the Authentication Server has communication with\n        the Authenticator.')
rldot1xAuthMultiBackendOtherRequestsToSupplicant = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendOtherRequestsToSupplicant.setReference('9.4.2, 8.5.6.2.3')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendOtherRequestsToSupplicant.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendOtherRequestsToSupplicant.setDescription('Counts the number of times that the state machine\n        sends an EAP-Request packet (other than an Identity,\n        Notification, Failure or Success message) to the\n        Supplicant (i.e., executes txReq on entry to the\n        REQUEST state). Indicates that the Authenticator chose\n        an EAP-method.')
rldot1xAuthMultiBackendNonNakResponsesFromSupplicant = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendNonNakResponsesFromSupplicant.setReference('9.4.2, 8.5.6.2.4')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendNonNakResponsesFromSupplicant.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendNonNakResponsesFromSupplicant.setDescription('Counts the number of times that the state machine\n        receives a response from the Supplicant to an initial\n        EAP-Request, and the response is something other than\n        EAP-NAK (i.e., rxResp becomes TRUE, causing the state\n        machine to transition from REQUEST to RESPONSE,\n        and the response is not an EAP-NAK). Indicates that\n        the Supplicant can respond to the Authenticators\n        chosen EAP-method.')
rldot1xAuthMultiBackendAuthSuccesses = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthSuccesses.setReference('9.4.2, 8.5.6.2.5')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthSuccesses.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthSuccesses.setDescription('Counts the number of times that the state machine\n        receives an EAP-Success message from the Authentication\n        Server (i.e., aSuccess becomes TRUE, causing a\n        transition from RESPONSE to SUCCESS). Indicates that\n        the Supplicant has successfully authenticated to\n        the Authentication Server.')
rldot1xAuthMultiSessionStatsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 13), )
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsTable.setReference('9.4.4')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsTable.setDescription('A table that contains the session statistics objects\n        for the Authenticator PAE associated with each Port.\n        An entry appears in this table for each port that may\n        authenticate access to itself.')
rldot1xAuthMultiSessionStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 13, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1xAuthMultiSessionStatsPortNumber"), (0, "RADLAN-MIB", "rldot1xAuthMultiSessionStatsSourceMac"))
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsEntry.setDescription('The session statistics information for an Authenticator\n        PAE.  This shows the mandatory values being collected for\n        each session that is still in progress, or the final\n        values for the last valid session on each port where\n        there is no session currently active.')
rldot1xAuthMultiSessionStatsPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsPortNumber.setDescription('Port Number.')
rldot1xAuthMultiSessionStatsSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionStatsSourceMac.setDescription('Mac of the authentication session.')
rldot1xAuthMultiSessionOctetsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsRx.setReference('9.4.4, Session Octets Received')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsRx.setDescription('The number of octets received in user data\n        frames on this Port during the session.')
rldot1xAuthMultiSessionOctetsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsTx.setReference('9.4.4, Session Octets Transmitted')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsTx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionOctetsTx.setDescription('The number of octets transmitted in user data\n        frames on this Port during the session.')
rldot1xAuthMultiSessionFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesRx.setReference('9.4.4, Session Frames Received')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesRx.setDescription('The number of user data frames received\n        on this Port during the session.')
rldot1xAuthMultiSessionFramesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesTx.setReference('9.4.4, Session Frames Transmitted')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesTx.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionFramesTx.setDescription('The number of user data frames transmitted\n        on this Port during the session.')
rldot1xAuthMultiSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionId.setReference('9.4.4, Session Identifier')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionId.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionId.setDescription('A unique identifier for the session, in the\n        form of a printable ASCII string of at least\n        three characters.')
rldot1xAuthMultiSessionTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionTime.setReference('9.4.4, Session Time')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionTime.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionTime.setDescription('The duration of the session in seconds.')
rldot1xAuthMultiSessionUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 13, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSessionUserName.setReference('9.4.4, Session User Name')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionUserName.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSessionUserName.setDescription('The User-Name representing the identity of the\n        Supplicant PAE.')
rldot1xAuthMultiConfigTable = MibTable((1, 3, 6, 1, 4, 1, 89, 95, 14), )
if mibBuilder.loadTexts: rldot1xAuthMultiConfigTable.setReference('9.4.1 Authenticator Configuration')
if mibBuilder.loadTexts: rldot1xAuthMultiConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiConfigTable.setDescription('A table that contains the configuration objects for the\n        Authenticator PAE associated with each port and MAC.\n        An entry appears in this table for each port and MAC that may\n        authenticate access to itself.')
rldot1xAuthMultiConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 95, 14, 1), ).setIndexNames((0, "RADLAN-MIB", "rldot1xAuthMultiPortNumber"), (0, "RADLAN-MIB", "rldot1xAuthMultiSourceMac"))
if mibBuilder.loadTexts: rldot1xAuthMultiConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiConfigEntry.setDescription('The configuration information for an Authenticator\n        PAE.')
rldot1xAuthMultiPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiPortNumber.setDescription('Port Number.')
rldot1xAuthMultiSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 14, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiSourceMac.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiSourceMac.setDescription('Mac of the authentication session.')
rldot1xAuthMultiPaeState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initialize", 1), ("disconnected", 2), ("connecting", 3), ("authenticating", 4), ("authenticated", 5), ("aborting", 6), ("held", 7), ("forceAuth", 8), ("forceUnauth", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiPaeState.setReference('9.4.1, Authenticator PAE state')
if mibBuilder.loadTexts: rldot1xAuthMultiPaeState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiPaeState.setDescription('The current value of the Authenticator PAE state\n        machine.')
rldot1xAuthMultiBackendAuthState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("request", 1), ("response", 2), ("success", 3), ("fail", 4), ("timeout", 5), ("idle", 6), ("initialize", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthState.setReference('9.4.1, Backend Authentication state')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthState.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiBackendAuthState.setDescription('The current state of the Backend Authentication\n        state machine.')
rldot1xAuthMultiControlledPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 95, 14, 1, 5), PaeControlledPortStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rldot1xAuthMultiControlledPortStatus.setReference('9.4.1, AuthControlledPortStatus')
if mibBuilder.loadTexts: rldot1xAuthMultiControlledPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xAuthMultiControlledPortStatus.setDescription('The current value of the controlled Port\n        status parameter for the Port.')
rldot1xBpduFilteringEnabled = MibScalar((1, 3, 6, 1, 4, 1, 89, 95, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rldot1xBpduFilteringEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: rldot1xBpduFilteringEnabled.setDescription('Specify that when 802.1x is globally disabled,\n        802.1x BPDU packets would be filtered or bridged.')
rlFile = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 96))
rlAAAEap = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 97))
rlSNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 98))
rlSsl = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 100))
rlMacBasePrio = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 101))
rlWlanAccessPoint = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 102))
rlLocalization = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 103))
rlRs232 = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 104))
rlNicRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 105))
rlAmap = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 106))
rlStack = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 107))
rlPoe = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 108))
rlUPnP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 109))
rlLldp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 110))
rlOib = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 111))
rlBridgeSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 112))
rlDhcpSpoofing = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 113))
rlBonjour = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 114))
rlLinksysSmartMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 115))
rlBrgMulticast = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 116))
rlBrgMcMngr = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 117))
rlGlobalIpAddrTable = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 118))
dlPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 119))
rlSecuritySuiteMib = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 120))
rlIntel = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 121))
rlAutoUpdate = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 123))
rlCpuCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 124))
rlWlanMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 200))
rndEndOfMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 1000))
rndEndOfMib = MibScalar((1, 3, 6, 1, 4, 1, 89, 1000, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndEndOfMib.setStatus('mandatory')
if mibBuilder.loadTexts: rndEndOfMib.setDescription(' This variable indicates this is the end of RND MIB.')
rxOverflowHWFault = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,3)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rxOverflowHWFault.setDescription('An RX buffer overflow has occurred in one of the LAN or link\n         interfaces. The bound variable rndErrorDesc provides the\n         interface number.')
txOverflowHWFault = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,4)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: txOverflowHWFault.setDescription('Interport queue overflow has occurred in one of the LAN or link interfaces.\n         The bound variable rndErrorDesc provides the interface number.')
routeTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,5)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: routeTableOverflow.setDescription('An overflow condition has occurred in the Routing Table. The Routing\n         Table is used for IP routing algorithm (RIP).')
resetRequired = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,10)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: resetRequired.setDescription('This trap indicates that in order to perform the last SET request, a reset operation\n         of the router/bridge is required. This occurs when the layer 2 routing algorithm is\n         changed between SPF and Spanning Tree. The reset can be performed manually or\n         using the variable rndAction.')
endTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,12)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: endTftp.setDescription('This trap indicates that in the device finished a TFTP\n         transaction with the management station.\n         variable rndErrorDesc and rndErrorSeverity provides the actual message\n         text and severity respectively.')
abortTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,13)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: abortTftp.setDescription('This trap indicates that in the device aborted a TFTP session with\n        the management station. Variable rndErrorDesc  and rndErrorSeverity\n        provides the actual  message text  and severity  respectively.')
startTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,14)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: startTftp.setDescription('Informational trap indicating that the device has intiated a\n         TFTP session. rndErrorDesc will contain the file type in\n         question')
faultBackUp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,23)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: faultBackUp.setDescription('Automantic switchover to backup link because of main link fault.')
mainLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,24)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: mainLinkUp.setDescription('Communication returened to main link.')
ipxRipTblOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,36)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: ipxRipTblOverflow.setDescription('This trap indicates that in an OpenGate IPX RIP table overflow.\n         The bound variable rndErrorDesc, rndErrorSeverity\n         provides the actual  message text and severity respectively.')
ipxSapTblOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,37)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: ipxSapTblOverflow.setDescription('This trap indicates that in an OpenGate IPX SAP table overflow.\n         The bound variable rndErrorDesc, rndErrorSeverity\n         provides the actual  message text and severity respectively.')
facsAccessVoilation = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,49)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: facsAccessVoilation.setDescription('This trap indicates that message that fits FACS statenebt with\n         operation blockAndReport was forward to the interface. The bound\n         variable rndErrorDesc, rndErrorSeverity(== info ) and\n         interface Number.')
autoConfigurationCompleted = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,50)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: autoConfigurationCompleted.setDescription('This trap indicates that auto comfiguration completetd succssefully.\n         The bound variable rndErrorDesc, rndErrorSeverity(== info )')
forwardingTabOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,51)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: forwardingTabOverflow.setDescription('This trap indicates that an overflow condition has occurred in the\n         layer II Forward Table.\n         The bound variable rndErrorDesc, rndErrorSeverity(== warning )')
framRelaySwitchConnectionUp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,53)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: framRelaySwitchConnectionUp.setDescription('This trap indicates that a connection establish between the Frame\n         relay Switch and the WanGate.\n         The bound variable rndErrorDesc, rndErrorSeverity(== warning )')
framRelaySwitchConnectionDown = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,54)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: framRelaySwitchConnectionDown.setDescription('This trap indicates that a connection between the Frame Relay Switch\n         and the WanGate failed.\n         The bound variable rndErrorDesc, rndErrorSeverity(== warning )')
errorsDuringInit = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,61)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: errorsDuringInit.setDescription('This trap indicates that the an error occured during initialization\n         The bound variable rndErrorDesc, rndErrorSeverity(== error )')
vlanDynPortAdded = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,66)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynPortAdded.setDescription('')
vlanDynPortRemoved = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,67)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynPortRemoved.setDescription('')
rsSDclientsTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,68)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSDclientsTableOverflow.setDescription('This warning is generated when an overflow occurs in the clients table.')
rsSDinactiveServer = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,69)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSDinactiveServer.setDescription('This warning is generated when a server does not respond to the dispatchers polling\n         and is thought to be inactive.')
rsIpZhrConnectionsTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,70)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrConnectionsTableOverflow.setDescription('The Zero Hop Routing connections Table has been overflown.')
rsIpZhrReqStaticConnNotAccepted = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,71)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrReqStaticConnNotAccepted.setDescription('The requested static connection was not accepted because there is\n          no available IP virtual address to allocate to it.')
rsIpZhrVirtualIpAsSource = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,72)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrVirtualIpAsSource.setDescription('The virtual IP address appeared as a source IP.\n          All the connections using it will be deleted and\n          it will not be further allocated to new connections.')
rsIpZhrNotAllocVirtualIp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,73)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrNotAllocVirtualIp.setDescription('The source IP address sent an ARP specifying a virtual IP\n          which was not allocated for this source.\n          This virtual IP will not be allocated to connections of this\n          specific source IP.')
rsSnmpSetRequestInSpecialCfgState = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,74)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSnmpSetRequestInSpecialCfgState.setDescription('An incoming SNMP SET request was rejected because no such\n          requests (except action requests) are accepted after start of\n          new configuration reception or during sending the current\n          configuration to an NMS.')
rsPingCompletion = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,136)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsPingCompletion.setDescription('A rsPingCompleted trap is sent at the completion\n         of a sequence of pings if such a trap was requested\n         when the sequence was initiated. The trap severity is info.\n         The trap text will specify the following information:\n         rsPingCompletionStatus, rsPingSentPackets, rsPingReceivedPackets\n         In addition to the above listed objects (which are always present),\n         the message will also specify the following quantities:\n         if any responses were received:\n            rsPingMinReturnTime\n            rsPingAvgReturnTime\n            rsPingMaxReturnTime')
pppSecurityViolation = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,137)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: pppSecurityViolation.setDescription('This trap indicates that a PPP link got an unrecognized secret.\n         The bound variables rndErrorDesc,\n         rndErrorSeverity(== warning ), interface Number. and pppSecurityIdentity')
frDLCIStatudChange = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,138)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: frDLCIStatudChange.setDescription('')
papFailedCommunication = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,139)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: papFailedCommunication.setDescription('')
chapFailedCommunication = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,140)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: chapFailedCommunication.setDescription('')
rsWSDRedundancySwitch = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,141)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDRedundancySwitch.setDescription('Whenever main server fails and backup takes over or server comes\n         up after failure a trap of this type is issued.')
rsDhcpAllocationFailure = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,142)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsDhcpAllocationFailure.setDescription('DHCP failed to allocate an IP address to a requesting host\n         because of memory shortage or inadequate configuration of\n         available IP addresses.')
rlIpFftStnOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,145)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIpFftStnOverflow.setDescription('The IP SFFT overflow.')
rlIpFftSubOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,146)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIpFftSubOverflow.setDescription('The IP NFFT overflow.')
rlIpxFftStnOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,147)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIpxFftStnOverflow.setDescription('The IPX SFFT overflow.')
rlIpxFftSubOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,148)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIpxFftSubOverflow.setDescription('The IPX NFFT overflow.')
rlIpmFftOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,149)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIpmFftOverflow.setDescription('The IPM FFT overflow.')
rlPhysicalDescriptionChanged = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,150)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlPhysicalDescriptionChanged.setDescription('Indicates that the physical decription of the device has\n         changed')
rldot1dStpPortStateForwarding = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,151)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"), ("RADLAN-MIB", "rldot1dStpTrapVrblifIndex"), ("RADLAN-MIB", "rldot1dStpTrapVrblVID"))
if mibBuilder.loadTexts: rldot1dStpPortStateForwarding.setDescription('The trap is sent by a bridge when any of its configured ports\n         transitions from the Learning state to the Forwarding state.')
rldot1dStpPortStateNotForwarding = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,152)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"), ("RADLAN-MIB", "rldot1dStpTrapVrblifIndex"), ("RADLAN-MIB", "rldot1dStpTrapVrblVID"))
if mibBuilder.loadTexts: rldot1dStpPortStateNotForwarding.setDescription('The trap is sent by a bridge when any of its configured ports\n         transitions from the Forwarding state to the Blocking state.')
rlPolicyDropPacketTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,153)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlPolicyDropPacketTrap.setDescription('Indicates that the packet drop due to the policy ')
rlPolicyForwardPacketTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,154)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlPolicyForwardPacketTrap.setDescription('Indicates that the packet has forward based on policy')
rlIgmpProxyTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,156)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIgmpProxyTableOverflow.setDescription('An IGMP PROXY Table overflow.')
rlIgmpV1MsgReceived = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,157)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlIgmpV1MsgReceived.setDescription('An IGMP Message of v1 received on ifIndex. ')
rlVrrpEntriesDeleted = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,158)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlVrrpEntriesDeleted.setDescription('One or more VRRP entries deleted due to IP interface deletion or transition. ')
rlHotSwapTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,159)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlHotSwapTrap.setDescription('Hot swap trap.')
rlTrunkPortAddedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,160)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlTrunkPortAddedTrap.setDescription('Informational trap indicating that a port is added to a trunk')
rlTrunkPortRemovedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,161)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlTrunkPortRemovedTrap.setDescription('This warning is generated when a port removed from a trunk.')
rlTrunkPortNotCapableTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,162)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlTrunkPortNotCapableTrap.setDescription('Informational trap indicating that a port can not be added to\n         a trunk because of device limitations or diffrent swIfType.')
rlLockPortTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,170)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlLockPortTrap.setDescription('Informational trap indicating that a locked port receive\n        a frame with new source Mac Address.')
vlanDynVlanAdded = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,171)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynVlanAdded.setDescription('add gvrp dynamic vlan')
vlanDynVlanRemoved = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,172)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynVlanRemoved.setDescription('remove gvrp dynamic vlan')
vlanDynamicToStatic = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,173)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynamicToStatic.setDescription('vlan status was changed from dynamic to static')
vlanStaticToDynamic = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,174)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanStaticToDynamic.setDescription('vlan status was changed from static to dynamic')
dstrSysLog = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,175)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: dstrSysLog.setDescription('Master receive trap from slave , and forward it as trap')
rlEnvMonFanStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,176)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlEnvMonFanStateChange.setDescription('Trap indicating the fan state.\n         rndErrorSeverity will be:\n                0 for fan state  nomal, notPresent\n                1 for fan state warning, notFunctioning\n                2 for fan state critical\n                3 for fan state fatal\n         The error text will specify the fan index, fan description and the exact fan state')
rlEnvMonPowerSupplyStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,177)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlEnvMonPowerSupplyStateChange.setDescription('Trap indicating the power supply state.\n         rndErrorSeverity will be:\n                0 for power supply state  nomal, notPresent\n                1 for power supply state warning, notFunctioning\n                2 for power supply state critical\n                3 for power supply state fatal\n         The error text will specify the power supply index, power supply description and the exact power supply state')
rlStackStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,178)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlStackStateChange.setDescription('Trap indicating the stack connection state\n                0 for stack state connected,\n                1 for stack state disconnected ')
rlEnvMonTemperatureRisingAlarm = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,179)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlEnvMonTemperatureRisingAlarm.setDescription('Trap indicating that the temperature in the device has exceeded the\n         device specific safe temperature threshold.')
rlBrgMacAddFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,183)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlBrgMacAddFailedTrap.setDescription('Informational trap indicating that adding dynamic mac/s\n         failed due to full hash chain.')
rldot1xPortStatusAuthorizedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,184)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rldot1xPortStatusAuthorizedTrap.setDescription('Informational trap indicating that port 802.1x status is authorized.')
rldot1xPortStatusUnauthorizedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,185)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rldot1xPortStatusUnauthorizedTrap.setDescription('Warning trap is indicating that port 802.1x status is unAuthorized.')
swIfTablePortLock = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,192)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: swIfTablePortLock.setDescription('Warning trap is indicating port lock hase began.')
swIfTablePortUnLock = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,193)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: swIfTablePortUnLock.setDescription('Warning trap is indicating port lock has ended.')
rlAAAUserLocked = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,194)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rlAAAUserLocked.setDescription('Warning trap indicating that the user was locked after\n         number of consecutives unsuccessful login attempts.')
bpduGuardPortSuspended = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,202)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: bpduGuardPortSuspended.setDescription('Warning trap indicating - Port was suspended because there was BPDU Guard violation.')
rldot1xSupplicantMacAuthorizedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,203)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rldot1xSupplicantMacAuthorizedTrap.setDescription('Informational trap indicating that MAC authentication supplicant\n         is authenticated and is allowed to access the network.')
rldot1xSupplicantMacUnauthorizedTrap = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,204)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rldot1xSupplicantMacUnauthorizedTrap.setDescription('Warning trap is indicating that Radius server rejects\n         MAC authentication supplicant.')
stpLoopbackDetection = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,205)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: stpLoopbackDetection.setDescription('Warning trap indicating - A loopback was detected on port.')
stpLoopbackDetectionResolved = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,206)).setObjects(("RADLAN-MIB", "rndErrorDesc"), ("RADLAN-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: stpLoopbackDetectionResolved.setDescription('Warning trap indicating - A loopback detection resolved on port.')
mibBuilder.exportSymbols("RADLAN-MIB", rlSwPackageVersionEntry=rlSwPackageVersionEntry, rlExperience=rlExperience, dlPrivate=dlPrivate, rlStormCtrlTypeSupport=rlStormCtrlTypeSupport, rlBrgMacAddFailedTrap=rlBrgMacAddFailedTrap, rldot1sMstpInstanceHoldTime=rldot1sMstpInstanceHoldTime, framRelaySwitchConnectionDown=framRelaySwitchConnectionDown, rsIpZhrConnectionsTableOverflow=rsIpZhrConnectionsTableOverflow, mainLinkUp=mainLinkUp, rlPortGvrpErrorStatisticsClear=rlPortGvrpErrorStatisticsClear, rlMultiSessionTerminal=rlMultiSessionTerminal, rlStormCtrlGroupBroadcastId=rlStormCtrlGroupBroadcastId, rldot1dStpHoldTime=rldot1dStpHoldTime, rlMD5KeyChainName=rlMD5KeyChainName, rlStormCtrlRateSupportPerType=rlStormCtrlRateSupportPerType, rndImageInfo=rndImageInfo, rndBootP=rndBootP, rlCDB=rlCDB, rldot1dStpTypeAfterReset=rldot1dStpTypeAfterReset, rlGmrpSupported=rlGmrpSupported, rlAutoUpdate=rlAutoUpdate, rldot1sMstpPendingGroup=rldot1sMstpPendingGroup, rlJumboFramesCurrentStatus=rlJumboFramesCurrentStatus, rldot1sMstpVlan=rldot1sMstpVlan, rlMirVlanBaseLogicalPortsVlanTag=rlMirVlanBaseLogicalPortsVlanTag, rlIPmulticast=rlIPmulticast, rldot1dStpVlanPortEnable=rldot1dStpVlanPortEnable, rlIpxFftSubOverflow=rlIpxFftSubOverflow, routeTableOverflow=routeTableOverflow, rlArpSpoofingOutPhysIfIndex=rlArpSpoofingOutPhysIfIndex, rlPortGvrpErrorStatisticsTable=rlPortGvrpErrorStatisticsTable, rlStormCtrlUnknownMulticastEnable=rlStormCtrlUnknownMulticastEnable, vlanStaticToDynamic=vlanStaticToDynamic, rlPolicyForwardPacketTrap=rlPolicyForwardPacketTrap, rldot1sMstpRegionalRootCost=rldot1sMstpRegionalRootCost, rlGmrpVlanTag=rlGmrpVlanTag, rlStack=rlStack, rlTrunkPortNotCapableTrap=rlTrunkPortNotCapableTrap, rndCommunityPortSecurity=rndCommunityPortSecurity, genGroup=genGroup, rlBrgMacSwOperTrapCount=rlBrgMacSwOperTrapCount, rldot1xAuthenticationPortTable=rldot1xAuthenticationPortTable, ipSpec=ipSpec, rldot1xAuthMultiPortNumber=rldot1xAuthMultiPortNumber, rlStormCtrlSupport=rlStormCtrlSupport, endTftp=endTftp, rlPortCopyMibVersion=rlPortCopyMibVersion, rlMridEntry=rlMridEntry, rlPortGvrpStatisticsEntry=rlPortGvrpStatisticsEntry, rlPortGvrpStatisticsTable=rlPortGvrpStatisticsTable, rldot1xAuthMultiAuthReauthsWhileAuthenticated=rldot1xAuthMultiAuthReauthsWhileAuthenticated, rlStormCtrlUnknownMulticastRate=rlStormCtrlUnknownMulticastRate, rlTelnetLoginBanner=rlTelnetLoginBanner, rldot1dStpEdgeportSupportInStp=rldot1dStpEdgeportSupportInStp, rlMirVlanBaseLogicalPortsTable=rlMirVlanBaseLogicalPortsTable, rldot1dStpPortBelongToVlanDefault=rldot1dStpPortBelongToVlanDefault, rlLockPortTrap=rlLockPortTrap, rlPortGmrpLeaveTime=rlPortGmrpLeaveTime, rldot1sMstpDesignatedMaxHopes=rldot1sMstpDesignatedMaxHopes, rldot1sMstpVlanEntry=rldot1sMstpVlanEntry, rldot1dStpTrapVrblifIndex=rldot1dStpTrapVrblifIndex, rsSnmpSetRequestInSpecialCfgState=rsSnmpSetRequestInSpecialCfgState, rldot1xAuthMultiSessionStatsPortNumber=rldot1xAuthMultiSessionStatsPortNumber, rldot1pPriorityMap=rldot1pPriorityMap, rldot1sMstpInstancePortMstiId=rldot1sMstpInstancePortMstiId, rlTelnetSessionLoginTime=rlTelnetSessionLoginTime, rlRcliFileAction=rlRcliFileAction, rldot1sMstpInstanceMaxAge=rldot1sMstpInstanceMaxAge, rldot1xAuthMultiBackendOtherRequestsToSupplicant=rldot1xAuthMultiBackendOtherRequestsToSupplicant, rlMirMaxNumOfMRIs=rlMirMaxNumOfMRIs, rlAggregateVlanMibVersion=rlAggregateVlanMibVersion, rlMacMulticast=rlMacMulticast, rldot1sMstpInstancePortForwardTransitions=rldot1sMstpInstancePortForwardTransitions, papFailedCommunication=papFailedCommunication, rldot1xAuthMultiStatsTable=rldot1xAuthMultiStatsTable, rlAggregateVlanPhysAddressType=rlAggregateVlanPhysAddressType, rldot1xAuthMultiBackendNonNakResponsesFromSupplicant=rldot1xAuthMultiBackendNonNakResponsesFromSupplicant, rlTelnetSecondLoginBanner=rlTelnetSecondLoginBanner, rldot1sMstpExtPortInternalOperPathCost=rldot1sMstpExtPortInternalOperPathCost, rldot1sMstpExtPortDesignatedRegionalRoot=rldot1sMstpExtPortDesignatedRegionalRoot, rlAggregateVlanArpProxy=rlAggregateVlanArpProxy, rlSocket=rlSocket, rldot1dStpPortStateForwarding=rldot1dStpPortStateForwarding, rlMirInterfaceIfIndex=rlMirInterfaceIfIndex, rlMirVlanBaseLogicalPortsStatus=rlMirVlanBaseLogicalPortsStatus, rlGvrpMibVersion=rlGvrpMibVersion, rlMD5KeyChainKeyId=rlMD5KeyChainKeyId, rsIpZhrVirtualIpAsSource=rsIpZhrVirtualIpAsSource, rldot1xAuthMultiSessionOctetsTx=rldot1xAuthMultiSessionOctetsTx, rlMD5KeyId=rlMD5KeyId, rldot1dStpPortLoopback=rldot1dStpPortLoopback, VlanPriority=VlanPriority, rndManagedTime=rndManagedTime, rlHotSwapTrap=rlHotSwapTrap, rlStormCtrlBroadcastEnable=rlStormCtrlBroadcastEnable, rldot1xUnAuthenticatedVlanTable=rldot1xUnAuthenticatedVlanTable, rlStormCtrlSetDefaultRateType=rlStormCtrlSetDefaultRateType, rldot1pPriorityMapPortList=rldot1pPriorityMapPortList, rlTerminalDebugModePassword=rlTerminalDebugModePassword, rldot1pPriorityMapPort=rldot1pPriorityMapPort, rldot1xAuthMultiDiagPortNumber=rldot1xAuthMultiDiagPortNumber, vlanDynVlanRemoved=vlanDynVlanRemoved, rlDhcpApprovalActionAddress=rlDhcpApprovalActionAddress, rlStormCtrlMulticastRate=rlStormCtrlMulticastRate, rndIpHostManagement=rndIpHostManagement, rndCommunityTable=rndCommunityTable, rlStormCtrlBroadcastRate=rlStormCtrlBroadcastRate, rlSocketEntry=rlSocketEntry, rlAggregateVlanEntry=rlAggregateVlanEntry, rlSecuritySuiteMib=rlSecuritySuiteMib, rldot1xUnAuthenticatedVlanSupported=rldot1xUnAuthenticatedVlanSupported, rlBroadcom=rlBroadcom, rldot1wRStpVlanEdgePortVlan=rldot1wRStpVlanEdgePortVlan, rldot1pPriorityMapName=rldot1pPriorityMapName, rlDhcpClCommandEntry=rlDhcpClCommandEntry, rlStormCtrlSetDefaultMulticastEnable=rlStormCtrlSetDefaultMulticastEnable, rlPortGvrpStatisticsSJE=rlPortGvrpStatisticsSJE, faultBackUp=faultBackUp, rlStormCtrlSetDefaultUnknownMulticastEnable=rlStormCtrlSetDefaultUnknownMulticastEnable, rndCommunityMngStationAddr=rndCommunityMngStationAddr, rlDnsCl=rlDnsCl, rldot1xAuthMultiEntersConnecting=rldot1xAuthMultiEntersConnecting, rldot1dPriorityPortGroupEntry=rldot1dPriorityPortGroupEntry, rlBonjour=rlBonjour, rndCommunityOwner=rndCommunityOwner, rlNicRedundancy=rlNicRedundancy, rldot1xUserBasedVlanPorts=rldot1xUserBasedVlanPorts, rldot1dStpPortBpduGuardEntry=rldot1dStpPortBpduGuardEntry, txOverflowHWFault=txOverflowHWFault, rldot1wRStpVlanEdgePortTable=rldot1wRStpVlanEdgePortTable, rlStormCtrlGroupUnknownMulticastId=rlStormCtrlGroupUnknownMulticastId, rlAAAEap=rlAAAEap, rlOib=rlOib, rlStormCtrlUnknownUnicastRate=rlStormCtrlUnknownUnicastRate, rldot1xSupplicantMacUnauthorizedTrap=rldot1xSupplicantMacUnauthorizedTrap, rldot1sMstpInstancePortDesignatedRoot=rldot1sMstpInstancePortDesignatedRoot, rldot1xAuthMultiSourceMac=rldot1xAuthMultiSourceMac, rldot1sMStpInstancePortAdminPathCost=rldot1sMStpInstancePortAdminPathCost, rldot1xAuthenticationPortEntry=rldot1xAuthenticationPortEntry, rlPortGmrpLeaveAllTime=rlPortGmrpLeaveAllTime, rldot1dStpVlanTable=rldot1dStpVlanTable, rlDhcpApprovalActionMask=rlDhcpApprovalActionMask, rndEndOfMibGroup=rndEndOfMibGroup, rndIpHost=rndIpHost, rldot1dStp=rldot1dStp, rldot1dStpSeparatedBridgesTable=rldot1dStpSeparatedBridgesTable, rlMirInterfaceTable=rlMirInterfaceTable, rlDhcpApprovalEnabled=rlDhcpApprovalEnabled, rldot1pPriorityMapStatus=rldot1pPriorityMapStatus, rlMirVlanBaseReservedPortsTable=rlMirVlanBaseReservedPortsTable, rndImage1Date=rndImage1Date, rlStormCtrlMibVersion=rlStormCtrlMibVersion, rlIpMRouteStdMIB=rlIpMRouteStdMIB, rlPortGvrpJoinTime=rlPortGvrpJoinTime, rldot1dStpVlanPortDesignatedRoot=rldot1dStpVlanPortDesignatedRoot, rlAgentsCapabilitiesGroups=rlAgentsCapabilitiesGroups, rlPortGvrpStatisticsSEmp=rlPortGvrpStatisticsSEmp, rldot1xAuthMultiPaeState=rldot1xAuthMultiPaeState, rldot1sMstpVlanTable=rldot1sMstpVlanTable, rlMirVlanBaseLogicalPortsIfIndex=rlMirVlanBaseLogicalPortsIfIndex, rlArpSpoofing=rlArpSpoofing, rldot1dStpPortBpduReceived=rldot1dStpPortBpduReceived, rlBrgMcMngr=rlBrgMcMngr, rlStormCtrlSetDefaultUnknownUnicastRate=rlStormCtrlSetDefaultUnknownUnicastRate, rlDhcpApprovalWaitingMask=rlDhcpApprovalWaitingMask, rlPortGvrpLeaveTime=rlPortGvrpLeaveTime, rlDhcpApprovalWaitingIfIndex=rlDhcpApprovalWaitingIfIndex, rlBrgMacSwTrapEnable=rlBrgMacSwTrapEnable, rldot1sMstpInstanceRemainingHopes=rldot1sMstpInstanceRemainingHopes, rlStormCtrlSetDefaultUnknownMulticastRate=rlStormCtrlSetDefaultUnknownMulticastRate, rlDhcpApprovalActionEntry=rlDhcpApprovalActionEntry, rlGvrpSupported=rlGvrpSupported, rlStormCtrlMulticastEnable=rlStormCtrlMulticastEnable, resetRequired=resetRequired, rlLldp=rlLldp, rldot1pPriorityMapTable=rldot1pPriorityMapTable, rlIpFftStnOverflow=rlIpFftStnOverflow, rldot1xMibVersion=rldot1xMibVersion, rldot1xAuthenticationPortMethod=rldot1xAuthenticationPortMethod, rlPortGvrpApplicantStatusEntry=rlPortGvrpApplicantStatusEntry, ipxSapTblOverflow=ipxSapTblOverflow, rldot1sMstpInstancePortDesignatedCost=rldot1sMstpInstancePortDesignatedCost, rlMD5KeyStartGenerate=rlMD5KeyStartGenerate, rlBrgMacSwDynamicTables=rlBrgMacSwDynamicTables, rldot1dStpVlanPortForwardTransitions=rldot1dStpVlanPortForwardTransitions, rlStormCtrlUnknownUnicastEnable=rlStormCtrlUnknownUnicastEnable, rlDhcpClActionHostName=rlDhcpClActionHostName, rlGmrpVlanEnable=rlGmrpVlanEnable, rlDhcpClCommandTable=rlDhcpClCommandTable, rlMirMaxNumOfMRIsAfterReset=rlMirMaxNumOfMRIsAfterReset, rlGvrp=rlGvrp, rlPortGvrpErrorStatisticsInvAval=rlPortGvrpErrorStatisticsInvAval, rldot1dExtBaseMibVersion=rldot1dExtBaseMibVersion, rlTelnetSessionClientAddress=rlTelnetSessionClientAddress, rndManagedDate=rndManagedDate, rlDhcpApprovalWaitingTable=rlDhcpApprovalWaitingTable, rlPolicyDropPacketTrap=rlPolicyDropPacketTrap, rldot1sMstpExtPortEntry=rldot1sMstpExtPortEntry, rldot1sMstpInstancePortPathCost=rldot1sMstpInstancePortPathCost, rldot1xAuthMultiStatsPortNumber=rldot1xAuthMultiStatsPortNumber, rlMD5KeyTable=rlMD5KeyTable, rldot1dStpTimeSinceTopologyChange=rldot1dStpTimeSinceTopologyChange, rlPortGvrpStatisticsSLA=rlPortGvrpStatisticsSLA, rlDhcpApprovalActionApprove=rlDhcpApprovalActionApprove, abortTftp=abortTftp, rlMridTable=rlMridTable, rlMD5KeyStopGenerate=rlMD5KeyStopGenerate, rndBootPRelaySecThreshold=rndBootPRelaySecThreshold, rlUPnP=rlUPnP, rldot1xUnAuthenticatedVlanStatus=rldot1xUnAuthenticatedVlanStatus, rldot1dStpType=rldot1dStpType, rldot1xAuthMultiStatsEntry=rldot1xAuthMultiStatsEntry, rlPortGvrpStatisticsREmp=rlPortGvrpStatisticsREmp, rldot1dStpPortTable=rldot1dStpPortTable, rldot1wRStp=rldot1wRStp, rldot1xSupplicantMacAuthorizedTrap=rldot1xSupplicantMacAuthorizedTrap, rlStormCtrlSetDefaultBroadcastEnable=rlStormCtrlSetDefaultBroadcastEnable, rlSsh=rlSsh, rlDot3adAgg=rlDot3adAgg, rldot1xAuthMultiAuthReauthsWhileAuthenticating=rldot1xAuthMultiAuthReauthsWhileAuthenticating, rlWlanAccessPoint=rlWlanAccessPoint, rldot1dStpFloodBpduMethod=rldot1dStpFloodBpduMethod, rlTelnetMibVersion=rlTelnetMibVersion, rldot1dStpRootPort=rldot1dStpRootPort, rldot1sMstpInstanceEnable=rldot1sMstpInstanceEnable, rldot1sMstpConfigurationName=rldot1sMstpConfigurationName, rlMirVlanBaseLogicalPortsEntry=rlMirVlanBaseLogicalPortsEntry, rlMD5KeyStartAccept=rlMD5KeyStartAccept, rndNotifications=rndNotifications, rndSoftwareFile=rndSoftwareFile, rlBridgeSecurity=rlBridgeSecurity, rlPortGvrpRegistrationModeTable=rlPortGvrpRegistrationModeTable, rlLinksysSmartMIB=rlLinksysSmartMIB, rlIpxFftStnOverflow=rlIpxFftStnOverflow, RlStormCtrlRateUnit=RlStormCtrlRateUnit, rldot1dStpPortStateNotForwarding=rldot1dStpPortStateNotForwarding, rlMD5KeyRowStatus=rlMD5KeyRowStatus, rldot1xAuthMultiSessionStatsTable=rldot1xAuthMultiSessionStatsTable, rsTunning=rsTunning, rlPortGmrpTimersEntry=rlPortGmrpTimersEntry, rlMirCurMriNum=rlMirCurMriNum, rlRCliConfigPassword=rlRCliConfigPassword, rldot1dStpBpduType=rldot1dStpBpduType, rldot1xAuthMultiEapolReqIdFramesTx=rldot1xAuthMultiEapolReqIdFramesTx, rldot1xGuestVlanPorts=rldot1xGuestVlanPorts, rldot1xAuthMultiDiagTable=rldot1xAuthMultiDiagTable, rlMirVlanBaseReservedPortsStatus=rlMirVlanBaseReservedPortsStatus, vlanDynamicToStatic=vlanDynamicToStatic, rlStormCtrlEnbaleDependencyBetweenTypes=rlStormCtrlEnbaleDependencyBetweenTypes, rlBrgMacSwAdminTrapFrequency=rlBrgMacSwAdminTrapFrequency, rlSocketMibVersion=rlSocketMibVersion, rsWSDRedundancySwitch=rsWSDRedundancySwitch, rlPortGvrpRegistrationModeForbidden=rlPortGvrpRegistrationModeForbidden, rlCliFileEnableAfterReset=rlCliFileEnableAfterReset)
mibBuilder.exportSymbols("RADLAN-MIB", rlMD5Key=rlMD5Key, rldot1sMstpInstancePortPriority=rldot1sMstpInstancePortPriority, rldot1xAuthMultiSessionUserName=rldot1xAuthMultiSessionUserName, rndActiveSoftwareFileEntry=rndActiveSoftwareFileEntry, rldot1dStpVlan=rldot1dStpVlan, rldot1dStpPortAutoEdgePort=rldot1dStpPortAutoEdgePort, rlPortCopyVlanTaggingTable=rlPortCopyVlanTaggingTable, rldot1dStpDesignatedRoot=rldot1dStpDesignatedRoot, rndBrgFeatures=rndBrgFeatures, rldot1xAuthMultiControlledPortStatus=rldot1xAuthMultiControlledPortStatus, rldot1xAuthMultiEapolFramesRx=rldot1xAuthMultiEapolFramesRx, rlStormCtrlSetDefaultMulticastRate=rlStormCtrlSetDefaultMulticastRate, rlFFT=rlFFT, rldot1xAuthMultiAuthSuccessWhileAuthenticating=rldot1xAuthMultiAuthSuccessWhileAuthenticating, rldot1dStpPortDampStable=rldot1dStpPortDampStable, rldot1dStpPortEntry=rldot1dStpPortEntry, rldot1xPortStatusUnauthorizedTrap=rldot1xPortStatusUnauthorizedTrap, rlBrgMacSwVersion=rlBrgMacSwVersion, rlTelnetSessionId=rlTelnetSessionId, rlStormCtrlRateType=rlStormCtrlRateType, rlPortGvrpErrorStatisticsInvAtyp=rlPortGvrpErrorStatisticsInvAtyp, rlManagedMrid=rlManagedMrid, rldot1xAuthMultiSessionId=rldot1xAuthMultiSessionId, rldot1dStpEnable=rldot1dStpEnable, rlAggregateSubVlanIfIndex=rlAggregateSubVlanIfIndex, rndImageInfoTable=rndImageInfoTable, rlCliTimer=rlCliTimer, rlDhcpApprovalWaitingAddress=rlDhcpApprovalWaitingAddress, rlPortCopyVlanTaggingEntry=rlPortCopyVlanTaggingEntry, rldot1dStpPortToDefault=rldot1dStpPortToDefault, rldot1dStpVlanPortEntry=rldot1dStpVlanPortEntry, rlSsl=rlSsl, rlJumboFramesStatusAfterReset=rlJumboFramesStatusAfterReset, errorsDuringInit=errorsDuringInit, rlBrgMacSwSpanningTree=rlBrgMacSwSpanningTree, rldot1dStpSupportedType=rldot1dStpSupportedType, rlArpSpoofingEntry=rlArpSpoofingEntry, rldot1dStpEnableByDefault=rldot1dStpEnableByDefault, rlGmrpVlanEntry=rlGmrpVlanEntry, rlBrgMacSwMaxTableNumber=rlBrgMacSwMaxTableNumber, vlanDynVlanAdded=vlanDynVlanAdded, rldot1sMstp=rldot1sMstp, rlStormCtrlEntry=rlStormCtrlEntry, rndActiveSoftwareFileTable=rndActiveSoftwareFileTable, rldot1dStpSeparatedBridgesAutoConfig=rldot1dStpSeparatedBridgesAutoConfig, rlMD5KeyChainKeyRowStatus=rlMD5KeyChainKeyRowStatus, rndImage2Date=rndImage2Date, rldot1xAuthMultiEapolLogoffFramesRx=rldot1xAuthMultiEapolLogoffFramesRx, bpduGuardPortSuspended=bpduGuardPortSuspended, rldot1sMstpInstanceDesignatedRoot=rldot1sMstpInstanceDesignatedRoot, rlMD5KeyEntry=rlMD5KeyEntry, rlPortGvrpErrorStatisticsInvAlen=rlPortGvrpErrorStatisticsInvAlen, rldot1dStpSeparatedBridges=rldot1dStpSeparatedBridges, rlLocalization=rlLocalization, pppSecurityViolation=pppSecurityViolation, rldot1sMstpInstancePriority=rldot1sMstpInstancePriority, rldot1dStpMibVersion=rldot1dStpMibVersion, rldot1xExtAuthSessionStatsTable=rldot1xExtAuthSessionStatsTable, rldot1sMstpInstancePortDesignatedPort=rldot1sMstpInstancePortDesignatedPort, rlTrunkPortRemovedTrap=rlTrunkPortRemovedTrap, rndBridgeAlarm=rndBridgeAlarm, rlCliMibVersion=rlCliMibVersion, rsIpZhrReqStaticConnNotAccepted=rsIpZhrReqStaticConnNotAccepted, rldot1dDeviceCapabilities=rldot1dDeviceCapabilities, vlanDynPortRemoved=vlanDynPortRemoved, rldot1wRStpVlanEdgePortEntry=rldot1wRStpVlanEdgePortEntry, rlStormCtrl=rlStormCtrl, rldot1wRStpForceVersionVlan=rldot1wRStpForceVersionVlan, rldot1dStpVlanPortDesignatedPort=rldot1dStpVlanPortDesignatedPort, rlPortGvrpApplicantStatusValue=rlPortGvrpApplicantStatusValue, rndUnitNumber=rndUnitNumber, rlDhcpClActionStatus=rlDhcpClActionStatus, rlStormCtrlSetDefaultBroadcastRate=rlStormCtrlSetDefaultBroadcastRate, stpLoopbackDetection=stpLoopbackDetection, rlBrgMacSwYellowBoundary=rlBrgMacSwYellowBoundary, rlPortGvrpTimersTable=rlPortGvrpTimersTable, rldot1xAuthMultiSessionStatsSourceMac=rldot1xAuthMultiSessionStatsSourceMac, rndBaseBootVersion=rndBaseBootVersion, rlArpSpoofingStatus=rlArpSpoofingStatus, rlSwPackageVersionVesrion=rlSwPackageVersionVesrion, rldot1xAuthMultiConfigEntry=rldot1xAuthMultiConfigEntry, rlRCliMibVersion=rlRCliMibVersion, rndImageSize=rndImageSize, rlMirInterfaceEntry=rlMirInterfaceEntry, rldot1dStpForwardDelay=rldot1dStpForwardDelay, rndCommunityTrapsEnable=rndCommunityTrapsEnable, rldot1xAuthMultiBackendAuthSuccesses=rldot1xAuthMultiBackendAuthSuccesses, rlPolicy=rlPolicy, rlMir=rlMir, rldot1sMstpInstanceRootCost=rldot1sMstpInstanceRootCost, rndApplications=rndApplications, rlRs232=rlRs232, rldot1dPriorityMibVersion=rldot1dPriorityMibVersion, rlCpuCounters=rlCpuCounters, rsSDinactiveServer=rsSDinactiveServer, rlPortGvrpStatisticsSLIn=rlPortGvrpStatisticsSLIn, swIfTablePortUnLock=swIfTablePortUnLock, rlDot1xAuthSessionAuthenticMethod=rlDot1xAuthSessionAuthenticMethod, rldot1dStpBpduCount=rldot1dStpBpduCount, rldot1dStpVlanPortDesignatedBridge=rldot1dStpVlanPortDesignatedBridge, rldot1dStpTopChanges=rldot1dStpTopChanges, rlGmrpMibVersion=rlGmrpMibVersion, rlMngInf=rlMngInf, rldot1sMstpInstanceEntry=rldot1sMstpInstanceEntry, rndImage2Name=rndImage2Name, rlAggregateVlanTable=rlAggregateVlanTable, rlGalileo=rlGalileo, framRelaySwitchConnectionUp=framRelaySwitchConnectionUp, rlTimeSynchronization=rlTimeSynchronization, rlSwPackageVersionTable=rlSwPackageVersionTable, rndImageInfoEntry=rndImageInfoEntry, rlPortGvrpStatisticsRLIn=rlPortGvrpStatisticsRLIn, rlAggregateVlan=rlAggregateVlan, rsSDclientsTableOverflow=rsSDclientsTableOverflow, autoConfigurationCompleted=autoConfigurationCompleted, rldot1dStpExtendedPortNumberFormat=rldot1dStpExtendedPortNumberFormat, rlSyslog=rlSyslog, rlArpSpoofingTable=rlArpSpoofingTable, rlEnvMonTemperatureRisingAlarm=rlEnvMonTemperatureRisingAlarm, swIfTablePortLock=swIfTablePortLock, rlGlobalIpAddrTable=rlGlobalIpAddrTable, ipxRipTblOverflow=ipxRipTblOverflow, rlSocketState=rlSocketState, rldot1dStpPortMustBelongToVlan=rldot1dStpPortMustBelongToVlan, rlAmap=rlAmap, rldot1xAuthMultiBackendAuthState=rldot1xAuthMultiBackendAuthState, rlStackStateChange=rlStackStateChange, rldot1dStpVlanEnable=rldot1dStpVlanEnable, rldot1sMstpRemainingHops=rldot1sMstpRemainingHops, rndBrgVersion=rndBrgVersion, rlRmonControl=rlRmonControl, rldot1dStpVlanEntry=rldot1dStpVlanEntry, rlPhysicalDescriptionChanged=rlPhysicalDescriptionChanged, rldot1sMstpRevisionLevel=rldot1sMstpRevisionLevel, rldot1sMstpInstancePortDesignatedBridge=rldot1sMstpInstancePortDesignatedBridge, rldot1xUnAuthenticatedVlanEntry=rldot1xUnAuthenticatedVlanEntry, rlArpSpoofingIfIndex=rlArpSpoofingIfIndex, rlBgp=rlBgp, rldot1xExtAuthSessionStatsEntry=rldot1xExtAuthSessionStatsEntry, rldot1dPriorityPortGroupTable=rldot1dPriorityPortGroupTable, rldot1dStpVlanPortTable=rldot1dStpVlanPortTable, rldot1dStpVlanPortPriority=rldot1dStpVlanPortPriority, rldot1dStpMaxAge=rldot1dStpMaxAge, rlPortGvrpErrorStatisticsEntry=rlPortGvrpErrorStatisticsEntry, rsDhcpAllocationFailure=rsDhcpAllocationFailure, frDLCIStatudChange=frDLCIStatudChange, rlAAAUserLocked=rlAAAUserLocked, rlMirVlanBaseReservedPortsIfIndex=rlMirVlanBaseReservedPortsIfIndex, rlVrrpEntriesDeleted=rlVrrpEntriesDeleted, rlRCli=rlRCli, rlTelnetTimeout=rlTelnetTimeout, rlEmbWeb=rlEmbWeb, rlDhcpApprovalWaitingGateway=rlDhcpApprovalWaitingGateway, rndImage2Version=rndImage2Version, rldot1xAuthMultiEapLengthErrorFramesRx=rldot1xAuthMultiEapLengthErrorFramesRx, rldot1sMstpExtPortInternalAdminPathCost=rldot1sMstpExtPortInternalAdminPathCost, rldot1dExtBase=rldot1dExtBase, rldot1xAuthMultiEntersAuthenticating=rldot1xAuthMultiEntersAuthenticating, rlFile=rlFile, rlSwPackageVersionName=rlSwPackageVersionName, rldot1sMstpInstanceTable=rldot1sMstpInstanceTable, rldot1xAuthMultiEapolReqFramesTx=rldot1xAuthMultiEapolReqFramesTx, rldot1sMStpInstancePortRole=rldot1sMStpInstancePortRole, rlWlanMIB=rlWlanMIB, rlTelnetUsersEntry=rlTelnetUsersEntry, rlPortGvrpTimersEntry=rlPortGvrpTimersEntry, rlDigitalKeyManage=rlDigitalKeyManage, rlBrgMulticast=rlBrgMulticast, rlAggregateVlanStatus=rlAggregateVlanStatus, rlDhcpClActionIfIndex=rlDhcpClActionIfIndex, rlPortGvrpStatisticsSJIn=rlPortGvrpStatisticsSJIn, rlGmrpVlanTable=rlGmrpVlanTable, rlGmrp=rlGmrp, rldot1xAuthMultiSessionTime=rldot1xAuthMultiSessionTime, rldot1sMstpInstancePortEntry=rldot1sMstpInstancePortEntry, rlArpSpoofingLocalIpAddr=rlArpSpoofingLocalIpAddr, rldot1dStpPortRole=rldot1dStpPortRole, rlPortGmrpTimersTable=rlPortGmrpTimersTable, rlMD5KeyChainTable=rlMD5KeyChainTable, rldot1dStpVlanPortDesignatedCost=rldot1dStpVlanPortDesignatedCost, rldot1sMstpInstancePortEnable=rldot1sMstpInstancePortEnable, rlRCliTimer=rlRCliTimer, rndErrorDesc=rndErrorDesc, rldot1dStpTrapVrblVID=rldot1dStpTrapVrblVID, vlan=vlan, rldot1wRStpEdgePortStatus=rldot1wRStpEdgePortStatus, rldot1pPriorityMapEntry=rldot1pPriorityMapEntry, rldot1xAuthMultiSessionFramesRx=rldot1xAuthMultiSessionFramesRx, rlPortCopySupport=rlPortCopySupport, rldot1dTpAgingTimeMax=rldot1dTpAgingTimeMax, rlIpmFftOverflow=rlIpmFftOverflow, rlCli=rlCli, rlPortGvrpLeaveAllTime=rlPortGvrpLeaveAllTime, rldot1sMstpPendingConfigurationName=rldot1sMstpPendingConfigurationName, rlIpFftSubOverflow=rlIpFftSubOverflow, rlPoe=rlPoe, rldot1sMstpExtPortTable=rldot1sMstpExtPortTable, rldot1dStpTaggedFlooding=rldot1dStpTaggedFlooding, rlAggregateVlanName=rlAggregateVlanName, rlDhcpClActionEntry=rlDhcpClActionEntry, rlPortGvrpStatisticsRLE=rlPortGvrpStatisticsRLE, rndInactiveArpTimeOut=rndInactiveArpTimeOut, rlTelnet=rlTelnet, rlAggregateSubVlanEntry=rlAggregateSubVlanEntry, rldot1xAuthMultiEapolRespFramesRx=rldot1xAuthMultiEapolRespFramesRx, rlAggregateVlanIndex=rlAggregateVlanIndex, rldot1dStpPortRestrictedRole=rldot1dStpPortRestrictedRole, rndEndOfMib=rndEndOfMib, rlPortGvrpRegistrationModeEntry=rlPortGvrpRegistrationModeEntry, rndImage1Version=rndImage1Version, rlRCliEnablePassword=rlRCliEnablePassword, rndBackupConfigurationEnabled=rndBackupConfigurationEnabled, rlMirInterfaceMrid=rlMirInterfaceMrid, Percents=Percents, rlRadius=rlRadius, rlSocketType=rlSocketType, rlDhcpApprovalActionIfIndex=rlDhcpApprovalActionIfIndex, rldot1sMstpPendingAction=rldot1sMstpPendingAction, rlBrgMacSwOldEntryDeleteMode=rlBrgMacSwOldEntryDeleteMode, rlStormCtrlGroupMulticastId=rlStormCtrlGroupMulticastId, rldot1dTpAgingTime=rldot1dTpAgingTime, rlCliFileEnable=rlCliFileEnable, facsAccessVoilation=facsAccessVoilation, rlStormCtrlSetDefaultUnknownUnicastEnable=rlStormCtrlSetDefaultUnknownUnicastEnable, rlPortGvrpStatisticsClear=rlPortGvrpStatisticsClear, rlTrunkPortAddedTrap=rlTrunkPortAddedTrap, rndBrgLicense=rndBrgLicense, rldot1dStpRootCost=rldot1dStpRootCost, rndMng=rndMng, rldot1dStpPortBpduSent=rldot1dStpPortBpduSent, rldot1xAuthMultiSessionFramesTx=rldot1xAuthMultiSessionFramesTx, rlPortGvrpStatisticsRLA=rlPortGvrpStatisticsRLA, rlTraceRouteMibVersion=rlTraceRouteMibVersion, rlEnvMonFanStateChange=rlEnvMonFanStateChange, rndImage2Time=rndImage2Time, rldot1pPriorityMapPriority=rldot1pPriorityMapPriority, rlCopy=rlCopy, rl3sw2swTables=rl3sw2swTables, rldot1xPortStatusAuthorizedTrap=rldot1xPortStatusAuthorizedTrap, rlpBridgeMIBObjects=rlpBridgeMIBObjects, rldot1dStpSeparatedBridgesEnable=rldot1dStpSeparatedBridgesEnable, rldot1sMstpInstancePortState=rldot1sMstpInstancePortState, rndActiveSoftwareFileAfterReset=rndActiveSoftwareFileAfterReset, rndCommunityTrapDestPort=rndCommunityTrapDestPort, rldot1xAuthMultiAuthEapStartsWhileAuthenticated=rldot1xAuthMultiAuthEapStartsWhileAuthenticated, rldot1dStpPortsEnable=rldot1dStpPortsEnable, rndImage1Name=rndImage1Name, rndBridgeType=rndBridgeType, rndErrorSeverity=rndErrorSeverity, rldot1xBpduFilteringEnabled=rldot1xBpduFilteringEnabled, rlMirMibVersion=rlMirMibVersion, rlStormCtrlGroupUnknownUnicastId=rlStormCtrlGroupUnknownUnicastId, rldot1dStpFilterBpdu=rldot1dStpFilterBpdu, rldot1pPriorityMapState=rldot1pPriorityMapState)
mibBuilder.exportSymbols("RADLAN-MIB", rldot1xAuthMultiAuthEapStartsWhileAuthenticating=rldot1xAuthMultiAuthEapStartsWhileAuthenticating, rlMridConnection=rlMridConnection, rndCommunityEntry=rndCommunityEntry, rlPortGvrpErrorStatisticsInvProt=rlPortGvrpErrorStatisticsInvProt, rldot1dStpHelloTime=rldot1dStpHelloTime, rlTelnetSessionStatus=rlTelnetSessionStatus, rldot1dStpSeparatedBridgesPortEnable=rldot1dStpSeparatedBridgesPortEnable, rlSocketBlockMode=rlSocketBlockMode, vlanDynPortAdded=vlanDynPortAdded, rlDhcpCl=rlDhcpCl, rlPortGvrpStatisticsRJIn=rlPortGvrpStatisticsRJIn, rlPhysicalDescription=rlPhysicalDescription, rsPingCompletion=rsPingCompletion, rldot1x=rldot1x, rndCommunityAccess=rndCommunityAccess, rlSNMP=rlSNMP, genGroupConfigurationSymbol=genGroupConfigurationSymbol, rlMirVlanBaseLogicalPortsReservedIfIndex=rlMirVlanBaseLogicalPortsReservedIfIndex, rndCommunityString=rndCommunityString, rlDhcpApprovalActionTable=rlDhcpApprovalActionTable, rlSocketTable=rlSocketTable, rlMacBasePrio=rlMacBasePrio, rndDeviceParams=rndDeviceParams, rlQosCliMib=rlQosCliMib, rlPortGmrpOverrideGarp=rlPortGmrpOverrideGarp, rlRCliUserPassword=rlRCliUserPassword, rndStackUnitNumber=rndStackUnitNumber, rlSwPackageVersion=rlSwPackageVersion, chapFailedCommunication=chapFailedCommunication, rldot1xAuthMultiEapolStartFramesRx=rldot1xAuthMultiEapolStartFramesRx, rldot1sMstpInstancePortPort=rldot1sMstpInstancePortPort, rldot1dStpPortBpduGuardEnable=rldot1dStpPortBpduGuardEnable, rlAAA=rlAAA, rldot1xUserBasedVlanSupported=rldot1xUserBasedVlanSupported, genGroupHWVersion=genGroupHWVersion, rldot1dPriority=rldot1dPriority, rlDhcpClActionTable=rlDhcpClActionTable, rlStormCtrlTable=rlStormCtrlTable, rldot1xAuthMultiBackendAccessChallenges=rldot1xAuthMultiBackendAccessChallenges, rldot1dStpVlanPortPathCost=rldot1dStpVlanPortPathCost, rlBrgMacSwitch=rlBrgMacSwitch, rlPortGvrpErrorStatisticsInvEvent=rlPortGvrpErrorStatisticsInvEvent, rlDhcpClCommandAction=rlDhcpClCommandAction, rlIfInterfaces=rlIfInterfaces, rldot1xAuthMultiDiagSourceMac=rldot1xAuthMultiDiagSourceMac, rndCommunityStatus=rndCommunityStatus, rlMD5KeyChainEntry=rlMD5KeyChainEntry, rlSocketUpTime=rlSocketUpTime, rldot1dStpPortPort=rldot1dStpPortPort, rlManualReboot=rlManualReboot, rldot1xGuestVlanSupported=rldot1xGuestVlanSupported, rldot1xAuthMultiBackendResponses=rldot1xAuthMultiBackendResponses, rldot1sMstpInstanceTimeSinceTopologyChange=rldot1sMstpInstanceTimeSinceTopologyChange, rldot1xAuthMultiDiagEntry=rldot1xAuthMultiDiagEntry, rlAggregateSubVlanTable=rlAggregateSubVlanTable, rldot1xAuthMultiSessionOctetsRx=rldot1xAuthMultiSessionOctetsRx, rldot1sMstpExtPortPort=rldot1sMstpExtPortPort, rlDhcpSpoofing=rlDhcpSpoofing, rlTraceRoute=rlTraceRoute, rldot1wRStpForceVersionEntry=rldot1wRStpForceVersionEntry, rldot1sMstpGroup=rldot1sMstpGroup, rlIgmpProxyTableOverflow=rlIgmpProxyTableOverflow, rndBootPServerAddress=rndBootPServerAddress, rlSmon=rlSmon, rldot1dPriorityPortGroupNumber=rldot1dPriorityPortGroupNumber, rlPortGvrpOverrideGarp=rlPortGvrpOverrideGarp, rlCliPassword=rlCliPassword, rndIpHostManagementIfIndex=rndIpHostManagementIfIndex, rldot1dStpSeparatedBridgesEntry=rldot1dStpSeparatedBridgesEntry, rldot1xAuthMultiConfigTable=rldot1xAuthMultiConfigTable, genGroupHWStatus=genGroupHWStatus, rldot1wRStpForceVersionState=rldot1wRStpForceVersionState, rlJumboFrames=rlJumboFrames, rldot1sMstpMaxHopes=rldot1sMstpMaxHopes, rldot1xAuthMultiInvalidEapolFramesRx=rldot1xAuthMultiInvalidEapolFramesRx, rlArpSpoofingMacAddr=rlArpSpoofingMacAddr, rldot1dTpAgingTimeMin=rldot1dTpAgingTimeMin, rlBrgMacSwRedBoundary=rlBrgMacSwRedBoundary, rldot1dStpVlanPortPort=rldot1dStpVlanPortPort, rldot1dStpMonitorTime=rldot1dStpMonitorTime, rldot1dStpVlanPortState=rldot1dStpVlanPortState, rldot1sMstpRegionalRoot=rldot1sMstpRegionalRoot, rlEnv=rlEnv, rxOverflowHWFault=rxOverflowHWFault, rlPhy=rlPhy, rldot1xAuthMultiEapolRespIdFramesRx=rldot1xAuthMultiEapolRespIdFramesRx, dstrSysLog=dstrSysLog, rl3sw2swTablesPollingInterval=rl3sw2swTablesPollingInterval, rldot1dStpPortBpduGuardTable=rldot1dStpPortBpduGuardTable, stpLoopbackDetectionResolved=stpLoopbackDetectionResolved, rndIpHostManagementSupported=rndIpHostManagementSupported, rndImage1Time=rndImage1Time, rldot1xAuthMultiSessionStatsEntry=rldot1xAuthMultiSessionStatsEntry, rlArpSpoofingRemoteIpAddr=rlArpSpoofingRemoteIpAddr, rldot1sMstpInstanceRootPort=rldot1sMstpInstanceRootPort, rlPortGvrpStatisticsSLE=rlPortGvrpStatisticsSLE, rldot1dStpTrapVariable=rldot1dStpTrapVariable, rldot1xAuthMultiAuthFailWhileAuthenticating=rldot1xAuthMultiAuthFailWhileAuthenticating, rndBasePhysicalAddress=rndBasePhysicalAddress, rldot1sMstpInstanceHelloTime=rldot1sMstpInstanceHelloTime, rlPortGvrpErrorStatisticsInvPlen=rlPortGvrpErrorStatisticsInvPlen, rldot1dStpVlanPortVlan=rldot1dStpVlanPortVlan, rldot1wRStpForceVersionTable=rldot1wRStpForceVersionTable, swInterfaces=swInterfaces, rldot1sMstpExtPortDesignatedRegionalCost=rldot1sMstpExtPortDesignatedRegionalCost, rlEnvMonPowerSupplyStateChange=rlEnvMonPowerSupplyStateChange, startTftp=startTftp, rldot1sMstpPendingRevisionLevel=rldot1sMstpPendingRevisionLevel, rlStormCtrlGroupTable=rlStormCtrlGroupTable, NetNumber=NetNumber, rlArpSpoofingMibVersion=rlArpSpoofingMibVersion, rlPortGvrpApplicantStatusTable=rlPortGvrpApplicantStatusTable, rlTelnetPassword=rlTelnetPassword, rlMirVlanBaseReservedPortsEntry=rlMirVlanBaseReservedPortsEntry, forwardingTabOverflow=forwardingTabOverflow, rldot1sMstpInstanceId=rldot1sMstpInstanceId, rlPortGmrpJoinTime=rlPortGmrpJoinTime, rlSocketId=rlSocketId, rldot1sMstpInstanceForwardDelay=rldot1sMstpInstanceForwardDelay, rsUDP=rsUDP, rldot1xGuestVlanVID=rldot1xGuestVlanVID, rldot1wRStpVlanEdgePortPort=rldot1wRStpVlanEdgePortPort, rlIntel=rlIntel, rldot1dStpPortDampEnable=rldot1dStpPortDampEnable, rldot1sMstpInstancePortTable=rldot1sMstpInstancePortTable, rldot1dStpLastChanged=rldot1dStpLastChanged, rlStormCtrlRateDependencyBetweenTypes=rlStormCtrlRateDependencyBetweenTypes, rlIgmpV1MsgReceived=rlIgmpV1MsgReceived, rlBrgMacSwKeyType=rlBrgMacSwKeyType, rlPortGvrpStatisticsRJE=rlPortGvrpStatisticsRJE, rlMD5KeyStopAccept=rlMD5KeyStopAccept, rldot1sMstpExtPortBoundary=rldot1sMstpExtPortBoundary, rlStormCtrlGroupEntry=rlStormCtrlGroupEntry, rsIpZhrNotAllocVirtualIp=rsIpZhrNotAllocVirtualIp, rlStartupCDBChanged=rlStartupCDBChanged, rlStormCtrlRateUnitTypeSupport=rlStormCtrlRateUnitTypeSupport, rlPortCopyVlanTagging=rlPortCopyVlanTagging, rldot1dStpPortFilterBpdu=rldot1dStpPortFilterBpdu, rlDhcpApprovalWaitingEntry=rlDhcpApprovalWaitingEntry, rldot1xAuthMultiStatsSourceMac=rldot1xAuthMultiStatsSourceMac, rlTelnetUsersTable=rlTelnetUsersTable, rnd=rnd, rndActiveSoftwareFile=rndActiveSoftwareFile, rlAggregateSubVlanStatus=rlAggregateSubVlanStatus, rldot1sMstpInstanceTopChanges=rldot1sMstpInstanceTopChanges, rldot1xAuthMultiEapolFramesTx=rldot1xAuthMultiEapolFramesTx)
