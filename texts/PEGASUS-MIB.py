#
# PySNMP MIB module PEGASUS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/pegasus/PEGASUS-MIB
# Produced by pysmi-1.1.10 at Fri Oct 27 07:49:04 2023
# On host fv-az178-832 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Unsigned32, Counter32, TimeTicks, iso, MibIdentifier, Integer32, Counter64, IpAddress, enterprises, ModuleIdentity, NotificationType, ObjectIdentity, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Unsigned32", "Counter32", "TimeTicks", "iso", "MibIdentifier", "Integer32", "Counter64", "IpAddress", "enterprises", "ModuleIdentity", "NotificationType", "ObjectIdentity", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "RowStatus", "TruthValue")
pegasusMibModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6368, 2))
pegasusMibModule.setRevisions(('2004-12-17 00:00', '2004-06-14 00:00', '2004-04-08 00:00', '2003-12-11 00:00', '2003-10-30 00:00', '2003-10-24 00:00', '2003-10-02 00:00', '2003-03-14 00:00', '2003-03-11 00:00', '2002-10-09 00:00', '2002-09-19 00:00', '2002-08-23 00:00', '2002-07-16 00:00', '2002-07-03 00:00', '2002-06-24 00:00', '2002-06-20 00:00', '2002-06-07 00:00', '2002-05-22 00:00', '2002-05-10 00:00', '2002-04-25 00:00', '2002-04-16 00:00', '2002-04-03 00:00', '2002-03-19 00:00', '2002-03-14 00:00', '2002-03-01 00:00', '2002-02-28 00:00', '2002-02-18 00:00', '2002-02-14 00:00', '2002-01-25 00:00', '2002-01-23 00:00', '2000-12-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pegasusMibModule.setRevisionsDescriptions(('A new table dslLinkCosTable has been added to the dsl branch to allow \n    the configuration of the Class of Service (COS) attributes. Each row \n    within this table corresponds to a DSL link.\n    Besides, some missing type and variable descriptions have been added.', 'Line identifiers are have been added for ISDN user ports and V5 links.', 'Maximum size of dslLinkAddress and trapDestination have been increased.', 'Improved the description of DslLinkLoopEnum. The variables \n    v5IsdnPortActiveLoop and authRespEnabled are now obsolete. The agent never \n    sends an error message if the request contains a wrong community string.', 'Corrected the value range of perfSweepCyclePeriod. The new maximum value \n    is 604800 seconds (1 week).', 'Declared perfControlEffectiveUpdatePeriod as obsolete. The definition \n    would be now redundant to perfControlUpdatePeriod.\n    The behaviour of v5LccPccV5LinkNumber/v5LccPccTimeslot has been modified.\n    The assignment of a PCC becomes active after both attributes have been set.\n    To erase the PCC, only one of these attributes has to be set to 0. Write \n    access is allowed for RowStatus active now. The comments of attributes and \n    table habe been aapted.', 'Declared hwAdaptionPolicy as obsolete. The definition of DataPortSpeedEnum\n    and DataPortFlowConrtolEnum has been moved within the MIB file to make \n    possible the compilation without errors using the MG-Soft MIB Compiles.\n    This revision of the MIB is compatible with the preceeding revision.', 'Deleted all IP base address objects: dslCardIPBaseAddress,\n    dataCardIPBaseAddress, and v5CardIPBaseAddress.  The base address of a\n    card can no longer be set through Pegasus Management, but only through\n    the CLI on the card itself.\n    The remaining objects were renumbered to keep the numbering compact, so\n    this revision of the MIB is again NOT COMPATIBLE with preceeding revisions!\n    Changed the type of perfControlIndex and perfDataIndex from INTEGER to\n    Integer32, with range (1..2147483647), which is the set of positive values\n    possible for an Integer32.  This change is rather formal (Integer32 is\n    indistinguishable from INTEGER, as SNMPv2-SMI puts it, that is, its\n    serialisation is identical to INTEGER), but it makes certain parsers happy.\n    In fact, the value is always chosen by the client, and the agent gladly\n    takes what it gets - including 0 and negative values.', 'Deleted all config version objects: dslCardConfigVersion,\n    v5CardConfigVersion, and dataCardConfigVersion.  These objects were never\n    really useful for customers, and so have been removed.  Objects following\n    them were renumbered, so this revision of the MIB is NOT COMPATIBLE with\n    preceeding revisions!\n    Added new literals at end of DataPortSpeedEnum and DataPortFlowControlEnum\n    to convey that the value of a (read-only) status variable is currently\n    unknown (for example because a sub-device like the Iad cannot be queried\n    because is not connected).\n    Added four new objects to the Iad table, to describe configuration and\n    corresponding status of the Ethernet port on the Iad.  This was mandated\n    by the Iad Rev. B, which can control its Ethernet port and also report its\n    status.  For the older Iad Rev. B, control and status of the Ethernet port\n    are not available, and the new objects will read with fixed values. The\n    objects are: iadEthPortSpeed, iadEthCurrentPortSpeed, iadEthFlowControl,\n    iadEthCurrentFlowControl.', 'SignalQuality and Attenuation were prefixed with dslLink in\n    dslInterfaceEntry sequence, changed to dslInterface.\n    Type DslLinkNumber was defined as 1..8, but V5 configurations already hold\n    user port parameters for future DSL cards with 16 DSL links. This caused\n    problems with some clients, so the definition was changed to 1..16.\n    Revamped description of writeCommunity.', 'The following objects were added or changed:\n\n    dataPortSpeed         New literal autoCrossoverAndPortSpeed(1) was added to\n                          type DataPortSpeedEnum. Warning: existing literals\n                          have changed their ordinal numbers.\n                          Revamped description, added reference.\n\n    v5CardFlags           Four new objects added to table v5CardTable, and\n    v5CardETSIRelease     the new type V5CardFlagSet.\n    v5CardE1LineCode\n    v5CardFrameFormat\n\n    v5LinkAlarmStatus     New literal v5LinkAlarmIdFailure(6) was added to type\n                          V5LinkAlarmStatusElem (at the end, without changing\n                          the ordinal numbers of existing literals).\n\n    iadAlarmStatus        New literal dcContinuity(2) was added to type\n                          IadAlarmStatusElem (at the end, without changing the\n                          ordinal numbers of existing literals).\n\n    dslInterfaceSignalQuality  Three new objects added to dslInterfaceTable.\n    dslInterfaceAttenuation\n    v5InterfaceAlarmStatus', 'Fixed a number of typos and formatting problems. Renamed l2 group to data\n    group. (Input from BBe).', 'Changed all type assignments with BITS to textual conventions (BITS is part\n    of the OBJECT-TYPE and TEXTUAL-CONVENTION macros (for SMI v2 only), but not\n    a ASN.1 builtin or DefinedType, and so cannot be used in a type assignment\n    or sequence definition). The types are:\n    AvailabilityStatusElem, DslLinkAlarmElem, DslCardAlarmStatus,\n    IadAlarmStatusElem, DslPerformanceStatusElem, V5LinkAlarmStatusElem,\n    V5IsdnPortAlarmStatusElem, RackAlarmStatusElem, PerfControlStatus.\n    Added import clause for TEXTUAL-CONVENTION.\n    Changed dataCardAvailabilityStatus in DataCardEntry from BITS to\n    AvailabilityStatusElem.\n    Changed spelling bit-names of AvailabilityStatusElem to agree with ASN.1\n    definitions in X.721.\n    Added description for the AvailabilityStatusElem textual convention (taken\n    from attributes, with updates).\n    In v5CardTable and v5LccTable, changed all read-write access clauses to\n    read-create.\n    Improved list of references in initial comment.\n    Added list of tools tested with this MIB to initial comment.\n    Constrained type Priority to (0..7).\n    Constrained dslLinkNumberOfZBits to (0..1).', 'dslLinkAssignedTrunk was TrunkNumber in its Object-Type definition, fixed\n    to TrunkNumberOrZero. For dslCardIPBaseAddress, v5CardIPBaseAddress and\n    dataCardIPBaseAddress: corrected descriptions and examples to have plausible\n    slot-numbers. ipBaseAddress adapted, with general examples.', 'User manual realignment with syntax errors fixed, raw version.', "Changed all ...IPAddressPrefix variable names to ...IPBaseAddress (dslCard,\n    v5Card, dataCard, pegasusSystem. Changed the variable in pegasusSystem from\n    DisplayString to IpAddress, to agree with other variables.\n    Renamed dataCardAlarmStatus to rackAlarmStatus (also renamed the associated\n    BITS type to RackAlarmStatusElem). Moved to pegasusSystem.\n    Renamed dslLinkAssociatedTrunk to dslLinkAssignedTrunk, to realign with\n    PEMClient.\n    Eliminated type DataPortNumber, used TrunkNumber in its place. Also created\n    type TrunkNumberOrZero, to allow reference to 'no trunk'.\n    Renamed ...ProgramVersion to ...FirmwareVersion: dslCard, dslCardM16, iad,\n    v5Card, dataCard.\n    Removed dataPortVLAN (and its type VLanId): is automatically computed as\n    part of the enhanced switching configuration. For future general VLAN\n    switching, it will be configured through standard MIBs.\n    Removed FilterBroadcast and FilterUnknown for both dslLink and dataPort:\n    present in the devices, but not in the PEMClient. It was not clear if these\n    are useful, and according to PSt it was decided to 'hide' them.\n    Removed special(4) from DslLinkLoopEnum - no longer supported.", "Removed ProceduralStatus and its enumeration type from all three cards and\n    IAD. Fixed spelling of 'v5LccIsProteced' to 'v5LccIsProtected'. Improved\n    various descriptions.", 'Changed Gauge32 in perfData to Integer32, removed import for Gauge32.\n    Added description for v5CardRowStatus.', 'Improved descriptions for dslLink{DataRate,LinkRate,NumberOfBRA} and\n    dslLinkDynamicSlotAllocation.\n    Added 6 remaining objects for SNMP configuration to group pegasusSystem\n    (read/write/trapCommunity, agentPort, authRespEnabled, trapDestination).\n    Improved description of objects in perf group.\n    DslCard, dataCard: removed AdminState, renumbered attributes contiguously.\n    v5Lcc: renumbered objects contiguously, starting at 1.\n    v5Interface: added RowStatus, changed all read-write objects to read-create,\n    renumbered objects contigously, starting at 1.\n    v5Link: added RowStatus, changed all read-write objects to read-create.\n    iad: removed AdminState, renumbered attributes contiguously.', 'Added group for performance history of V5 links and DSL interfaces.\n    Added description for dslLinkNumberOfBRA, dslLinkDataRate, and\n    dslLinkLineRate.', 'Changed numbering scheme. { schmidtelecom 1 } is now reserved for a\n    centralized registry, and the pegasusMibModule is { schmidtelecom 2 }.\n    All groups and objects in this and other Pegasus MIBs are below\n    pegasusMibModule.', 'v5CardTable and V5LccTable (LogCommChan) now have a RowStatus. For \n    v5CardTable, this controls provisioning mode, but it does not yet\n    support creation. For v5LccTable, it controls verification of the\n    v5LccPccV5LinkNumber and and v5LccPccTimeslot columns, which define\n    the Pcc (PhysCommChan) (i.e. the RowStatus supports transactions on\n    these values). Again, creation is not yet supported for v5LccTable.\n    The new object mibRevision holds the revision number of the MIB with\n    which the agent was compiled.', 'Added missing import of DisplayString. Changed definitions of dslInterface\n    counter values to Counter32 consistently. Added one missing variable to\n    V5IsdnPortEntry sequence.', 'Initial comments updated and moved to the module description, where they\n    are more useful for typical browsers.', 'Added PegasusSystem.', 'Removed dslInterfaceIsRestartEnabled. Renumbered dslInterfaceEntry and\n    dslLinkEntry columns to start with one and form a compact sequence.', 'Added initial comment with overview and additional hints.\n    Corrected spelling of CommStateEnum literals to comply with SNMPv2 (dashes\n    were replaced by mixed-case spelling).\n    Added VLAN support (DSL link and data card port). Presently only for\n    enhanced mode, transparent and VLAN modes to come.\n    Removed some VLAN related definitions which are not yet used.', 'Added definitions for data switch and data switch port.', 'Added object-type definition of v5IsdnPortAlarmStatus. Renumbered\n     remaining objects.', 'Changed all occurrences of NetworkAddress to IpAddress (imported\n    from SNMPv2-SMI). NetworkAddress was in SNMPv1, but was replaced\n    by IpAddress for SNMPv2.\n\n    Corrected dataCardVLANMode to SYNTAX TruthValue - it erronously\n    used NetworkAddress.\n\n    Correct the year on the previous revision clause.', 'Initial revision.',))
if mibBuilder.loadTexts: pegasusMibModule.setLastUpdated('200412170000Z')
if mibBuilder.loadTexts: pegasusMibModule.setOrganization('Schmid Telecom, Zurich')
if mibBuilder.loadTexts: pegasusMibModule.setContactInfo('Schmid Telecom AG\n     Binzstrasse 35, CH-8048 Zurich\n     Switzerland\n\n     Email: xdslsupport@schmid-telecom.ch')
if mibBuilder.loadTexts: pegasusMibModule.setDescription('This MIB applies to the PEGASUS SDSL product manufactured by Schmid\n    Telecom Zurich. The MIB is modelled after the PEM management model, so\n    object hierarchy and individual variables agree with the PEM client.\n\n    The overall structure is five groups, one for each of DSL, V5 and Data\n    cards, one with global parameters for the whole rack, and finally one group\n    for performance history measurement.\n\n    The DSL group contains four tables:\n\n    - dslCardTable       one entry for each DSL card (line card) configured.\n    - dslLinkTable       one entry for each DSL link.\n    - dslInterfaceTable  one entry per DSL interface, i.e. two per DSL link.\n    - iadTable           one entry per DSL link.\n    - dslLinkCosTable    one entry per DSL link.\n\n    The V5 group contains five tables:\n\n    - v5CardTable        one entry for each V5 card configured.\n    - v5LinkTable        one entry for each V5 link.\n    - v5InterfaceTable   one entry for each V5 interface.\n    - v5IsdnPortTable    one entry per ISDN User Port (S0 interface on IAD).\n    - v5LccTable         one entry per Logical Communication Channel.\n\n    The data switch group contains two tables:\n\n    - dataCardTable      one entry per data card (normally one)\n    - dataPortTable      one entry per trunk interface.\n\n    The Pegasus System group contains individual variables related to the\n    rack as a whole.\n\n    The perf group for performance histories contains two tables and one extra\n    variable:\n\n    - perfSweeperCyclePeriod  how soon are unused perfDataTable entries cleared\n    - perfControlTable        configuration of performance history monitoring\n    - perfDataTable           performance history registers\n\n    Note\n\n    - Notification definitions are singled out to their own MIB, to allow for\n      alternative sets of notification styles.\n    - Tables in this MIB are indexed hierarchically with physical attributes.\n      E.g. all cards are indexed by the slot number. DSL links are indexed by\n      two variables: first the slot number of the DSL card which carries the\n      link, then the number of the link within that card.\n    - Unlike the PEM client, this MIB does not model V5 Physical Communication\n      Channels explicitely. They have no interesting variables of their own.\n      Rather, the user allots a range of these objects through the V5 link\n      configuration, and then maps the Logical Communication Channels to them\n      (using indexes within the alloted range, of course). These objects are\n      then created, deleted and managed under the hood.\n    - V5 interfaces are logical entities, unlike DSL interfaces.\n    - ISDN user ports are physically part of the IAD, and are indexed by DSL\n      attributes. Their configuration, though, belongs to V5, so the user port\n      tables are in the V5 group, not in the DSL group.')
schmidtelecom = MibIdentifier((1, 3, 6, 1, 4, 1, 6368))
dsl = MibIdentifier((1, 3, 6, 1, 4, 1, 6368, 2, 1))
v5 = MibIdentifier((1, 3, 6, 1, 4, 1, 6368, 2, 2))
data = MibIdentifier((1, 3, 6, 1, 4, 1, 6368, 2, 3))
pegasusSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 6368, 2, 4))
perf = MibIdentifier((1, 3, 6, 1, 4, 1, 6368, 2, 7))
class AdminStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("locked", 1), ("unlocked", 2), ("shutdown", 3))

class OperStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class AvailabilityStatusElem(TextualConvention, Bits):
    reference = 'X.731, section 8.1.2.3 (explanation)\n           X.721, section 14.2 (formal definition of values)'
    description = 'The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          inTest        The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          powerOff      The device requires power to be applied and is not \n                        powered on.\n          offLine       The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          offDuty       The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          notInstalled  The device is not present, or incomplete.\n          logFull       The log is full.'
    status = 'current'
    namedValues = NamedValues(("inTest", 0), ("failed", 1), ("powerOff", 2), ("offLine", 3), ("offDuty", 4), ("dependency", 5), ("degraded", 6), ("notInstalled", 7), ("logFull", 8))

class CommStateEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("disconnected", 1), ("init", 2), ("identification", 3), ("checkHw", 4), ("hwAdaption", 5), ("checkHwVers", 6), ("wrongProgram", 7), ("checkConfig", 8), ("downloadConfig", 9), ("uploadConfig", 10), ("statusSynch", 11), ("resetting", 12), ("inactive", 13), ("active", 14))

class DataPortSpeedEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("autoCrossoverAndPortSpeed", 1), ("autoNegotiationPortSpeed", 2), ("base100TFullDuplex", 3), ("base100THalfDuplex", 4), ("base10TFullDuplex", 5), ("base10THalfDuplex", 6), ("unknown", 7))

class DataPortFlowControlEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("autoNegotiationFlowControl", 1), ("onFlowControl", 2), ("offFlowControl", 3), ("unknown", 4))

class SlotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 12)

class DataCardSlotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2)

class V5SlotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(3, 4)

class DslSlotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(5, 12)

class DslLinkNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 16)

class TrunkNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 5)

class TrunkNumberOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 5)

class Priority(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class DslLinkLoopEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("loop1", 2), ("loop2", 3))

class DslLinkAlarmElem(TextualConvention, Bits):
    description = 'Bitset to represent alarms on a DSL link.'
    status = 'current'
    namedValues = NamedValues(("config", 0), ("service", 1))

class DslLinkPSDMaskEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("symmetric", 1), ("asymmetric", 2))

class DslCardAlarmStatus(TextualConvention, Bits):
    description = 'Bitset to represent alarms on a DSL card.'
    status = 'current'
    namedValues = NamedValues(("intercom", 0))

dslCardTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1), )
if mibBuilder.loadTexts: dslCardTable.setStatus('current')
if mibBuilder.loadTexts: dslCardTable.setDescription('A table containing line card specific information.')
dslCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1), ).setIndexNames((0, "PEGASUS-MIB", "dslCardSlotNumber"))
if mibBuilder.loadTexts: dslCardEntry.setStatus('current')
if mibBuilder.loadTexts: dslCardEntry.setDescription('Row and index definition for line card table.')
dslCardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 1), DslSlotNumber())
if mibBuilder.loadTexts: dslCardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: dslCardSlotNumber.setDescription('Slot number for line card.')
dslCardAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 2), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: dslCardAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
dslCardHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: dslCardHardwareVersion.setDescription("Hardware version of the Line card. This is also called CHM-number (it\n          always starts with the letters 'CHM'). Example: CHM40510WA0A2. The\n          number '405' after the 'CHM' identifies the card as a line card.")
dslCardManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardManufacturer.setStatus('current')
if mibBuilder.loadTexts: dslCardManufacturer.setDescription('Name of company which manufactured this line card/ltu.')
dslCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardName.setStatus('current')
if mibBuilder.loadTexts: dslCardName.setDescription('User defined ame of line card.')
dslCardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 6), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardOperState.setStatus('current')
if mibBuilder.loadTexts: dslCardOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
dslCardFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: dslCardFirmwareVersion.setDescription("Version number and build date of the firmware running on the line\n          card. This applies to the PPC part, the M16 firmware part has its own\n          version attribute, dslCardM16FirmwareVersion.\n          Example:\n            '1.3 20020607 16:34'\n          The format is 'major.minor YYYYMMDD hh:mm', where the fields are:\n          major     Major and minor version numbers, separated by a dot. Take at\n          minor     most 5 characters together, including the space. Both major\n                    and minor consist of digits only.\n          YYYYMMDD  Date (year YYYY, month MM 1-12 and day DD 1-31) of firmware\n                    build. Preceded and followed by exactly one space to\n                    separate it from the version numbers and time.\n          hh:mm     Time (hour hh 0-23 and minute mm 0-59) of firmware build.")
dslCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: dslCardSerialNumber.setDescription("Serial number of the line card. Also called HM-number, as it always\n          starts with 'HM'. Example: HMVSS014810294.")
dslCardCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 9), CommStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardCommState.setStatus('current')
if mibBuilder.loadTexts: dslCardCommState.setDescription("The Management Comm State indicates the state of the management\n          connection between the PEM Server and the line card.\n          disconnected            No connection has been established.\n          init                    A connection has freshly been established on\n                                  the underlying protocol, but no management\n                                  information has been transmitted so far.\n          identification          The connected device is being identified.\n          check hardware          The connected hardware is compared to the one\n                                  stored in the configuration.\n          hardware adaptation     If the configured and the existing device do\n                                  not match, an adoption is made. The behaviour\n                                  in this case can be configured with the 'HW\n                                  Adaptation Policy' option.\n          check program version   The program version of the connected hardware\n                                  is compared to the one stored in the\n                                  configuration.\n          check config version    The configuration version of the connected\n                                  hardware is compared to the one stored in the\n                                  configuration.\n          download config         If a configuration version mismatch has been\n                                  detected and the 'Config Priority' of 'PEGASUS\n                                  system' is set to 'Device', the configuration\n                                  is downloaded from the device to the PEM\n                                  Server.\n          upload config           If a configuration version mismatch has been\n                                  detected and the 'Config Priority' of 'PEGASUS\n                                  system' is set to 'Server', the configuration\n                                  is uploaded from the PEM Server to the device.\n          status synch            The values of the status properties are being\n                                  synchronised.\n          resetting               The device is resetting.\n          inactive                The device is connected, but it is inactive,\n                                  that is not operational. This may be due to a\n                                  hardware mismatch.\n          active                  The management connection between the device\n                                  and the PEM Server is fully established and\n                                  the device is active.")
dslCardAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 10), DslCardAlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: dslCardAlarmStatus.setDescription('Alarm status of the line card. Bits assigned as follows:\n           bit 0    intercom    The intercom line between the PPC and M16\n                                has failed.')
dslCardM16FirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslCardM16FirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: dslCardM16FirmwareVersion.setDescription("Version number and build date of the firmware running on the line\n          card. This applies to the M16 part, the PPC firmware part has its own\n          version attribute, dslCardFirmwareVersion.\n          Example:\n            '1.3 20020607 16:34'\n          The format is 'major.minor YYYYMMDD hh:mm', where the fields are:\n          major     Major and minor version numbers, separated by a dot. Take at\n          minor     most 5 characters together, including the space. Both major\n                    and minor consist of digits only.\n          YYYYMMDD  Date (year YYYY, month MM 1-12 and day DD 1-31) of firmware\n                    build. Preceded and followed by exactly one space to\n                    separate it from the version numbers and time.\n          hh:mm     Time (hour hh 0-23 and minute mm 0-59) of firmware build.")
dslLinkTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2), )
if mibBuilder.loadTexts: dslLinkTable.setStatus('current')
if mibBuilder.loadTexts: dslLinkTable.setDescription('A table containing dsl link specific information.')
dslLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1), ).setIndexNames((0, "PEGASUS-MIB", "dslCardSlotNumber"), (0, "PEGASUS-MIB", "dslLinkNumber"))
if mibBuilder.loadTexts: dslLinkEntry.setStatus('current')
if mibBuilder.loadTexts: dslLinkEntry.setDescription('Information about a particular dsl link.')
dslLinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 1), DslLinkNumber())
if mibBuilder.loadTexts: dslLinkNumber.setStatus('current')
if mibBuilder.loadTexts: dslLinkNumber.setDescription('Number 1-8 of link on line card.')
dslLinkActiveLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 2), DslLinkLoopEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkActiveLoop.setStatus('current')
if mibBuilder.loadTexts: dslLinkActiveLoop.setDescription('Loop back (test) setup currently active. Disconnect the DSL link \n          before activating the maintenance loop on the LTU (loop1).')
dslLinkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkAddress.setStatus('current')
if mibBuilder.loadTexts: dslLinkAddress.setDescription('Customer address stored in configuration file of agent.')
dslLinkAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 4), AdminStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkAdminState.setStatus('current')
if mibBuilder.loadTexts: dslLinkAdminState.setDescription('This configuration attribute allows the administrator to enable or\n         disable the operability of a device.\n         unlocked   The device is administratively permitted to perform services\n                    for its users.\n         locked     The device is administratively prohibited from performing\n                    services for users.')
dslLinkAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 5), DslLinkAlarmElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslLinkAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: dslLinkAlarmStatus.setDescription('Alarms on the link. Bit assignments as follows:\n           Bit 0    Configuration Alarm present on link. Some configuration\n                    attribute is invalid.\n           Bit 1    User Service Alarm present on link. This could be for\n                    example the IAD being locked (admin-state), or a mis-\n                    configuration which keeps the LTU-NTU from operating.')
dslLinkAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 6), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslLinkAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: dslLinkAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
dslLinkContact = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkContact.setStatus('current')
if mibBuilder.loadTexts: dslLinkContact.setDescription('A contact person, address or phone number.')
dslLinkCustomerId = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCustomerId.setStatus('current')
if mibBuilder.loadTexts: dslLinkCustomerId.setDescription('An identification number which has been assigned to this customer.')
dslLinkDynamicSlotAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkDynamicSlotAllocation.setStatus('current')
if mibBuilder.loadTexts: dslLinkDynamicSlotAllocation.setDescription('If set to true(1), the link allows timeslots reserved for voice but\n          currently unused for usage by data. This can improve utilization\n          of the link by increasing the effective data rate. If set to false(2),\n          reserved and unused voice timeslots are not released for data usage.')
dslLinkIsRemotePower = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkIsRemotePower.setStatus('current')
if mibBuilder.loadTexts: dslLinkIsRemotePower.setDescription('LTU puts dc supply voltage onto link. IAD uses this if local power\n          fails.')
dslLinkLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 36))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkLineRate.setStatus('current')
if mibBuilder.loadTexts: dslLinkLineRate.setDescription("Number of 64Kbit timeslots per second. The signal on the DSL link is\n          structured as 166 2/3 frames with 48 blocks each, for a total of 8000\n          blocks per second. Each block contains 3 to 36 bytes (also called\n          timeslots), as configured by this object. The bit rate of the DSL link\n          is derived from this value.\n          Individual timeslots can be used for data, for voice, or for voice\n          related signalling data (D-channels). The number of data and voice\n          timeslots is configured with dslLinkDataRate and dslLinkNumberOfBRA.\n          The value of this variable cannot be set outside the range of 3..36,\n          inclusive. It should be chosen such that the following conditions\n          hold:\n              if dslLinkNumberOfBRA is zero\n                  dslLinkLineRate >= dslLinkDataRate\n              if dslLinkNumberOfBRA is not zero\n                  dslLinkLineRate >= dslLinkDataRate + 2*dslLinkNumberOfBRA + 1\n          If the value violates this condition, the DSL link raises a\n          'configuration' alarm.")
dslLinkDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 36))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkDataRate.setStatus('current')
if mibBuilder.loadTexts: dslLinkDataRate.setDescription("Number of timeslots per block reserved for data. The value of this\n          object cannot be set outside of the range 0..36, inclusive. It should\n          be chosen such that the following conditions hold:\n              if dslLinkNumberOfBRA is zero\n                  dslLinkDataRate <= dslLinkLineRate\n              if dslLinkNumberOfBRA is not zero\n                  dslLinkDataRate <= dslLinkLineRate - 2*dslLinkNumberOfBRA - 1\n          If the value violates this condition, the DSL link raises a\n          'configuration' alarm.\n          The value of this object gives the guaranteed capacity available for\n          data. If dslLinkDynamicSlotAllocation is true(1), the effective data\n          rate may be higher.")
dslLinkName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkName.setStatus('current')
if mibBuilder.loadTexts: dslLinkName.setDescription('User defined name of the DSL link.')
dslLinkNotes = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkNotes.setStatus('current')
if mibBuilder.loadTexts: dslLinkNotes.setDescription('Notes stored in the configuration file of the agent.')
dslLinkNumberOfBRA = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkNumberOfBRA.setStatus('current')
if mibBuilder.loadTexts: dslLinkNumberOfBRA.setDescription("Number of basic rate interfaces on the IAD for which capacity is\n          reserved on the DSL link. The capacity is reserved in units of\n          timeslots, and the table below shows the number of timeslots reserved\n          as a function of dslLinkNumberOfBRA.\n\n                                 voice       dslLinkDynamicSlotAllocation\n          dslLinkNumberOfBRA   reservation       true(1)     false(2)\n          ---------------------------------------------------------------\n                  0                0               0           0\n                  1                3              1-3          3\n                  2                5              1-5          5\n                  3                7              1-7          7\n                  4                9              1-9          9\n\n          If dslLinkNumberOfBRA is 0, no timeslots are reserved in the DSL link.\n          If dslLinkNumberOfBRA is non-zero, one timeslot is always reserved\n          and used for D-channel signalling. For each BRA allowed, exactly\n          two timeslots are reserved (one each for the two B-channels of the\n          basic rate interface). When dynamic (time)slot allocation is off,\n          reserved timeslots are unavailable for data. If dynamic slot\n          allocation is in effect, reserved voice timeslots are used only on\n          demand, that is when a phone call is being made. Reserved but unused\n          voice timeslots are then used for data, increasing the data rate.\n          The timeslot for the D-channel is not dynamically allocated. If a\n          D-channel is reserved, it is unavailable for data.\n          The value of this object cannot be set outside of the range 0..4. It\n          should be chosen such that the following conditions hold:\n              dslLinkNumberOrBRA <= (dslLinkLineRate - dslLinkDataRate - 1) / 2\n              dslLinkNumberOrBRA <= number of basic rate interfaces on the IAD\n          where the division should round towards zero. If the value violates\n          either of these conditions, the DSL link raises a 'configuration'\n          alarm.\n\n          Note that if the IAD is not connected, the link may raise the alarm\n          only when the IAD connects. It is allowed to set a value less than the\n          actual number of basic rate interfaces present on the IAD.")
dslLinkOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 16), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslLinkOperState.setStatus('current')
if mibBuilder.loadTexts: dslLinkOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
dslLinkNumberOfZBits = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkNumberOfZBits.setStatus('current')
if mibBuilder.loadTexts: dslLinkNumberOfZBits.setDescription('Number of Z bits on the DSL link.')
dslLinkPSDMask = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 18), DslLinkPSDMaskEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkPSDMask.setStatus('current')
if mibBuilder.loadTexts: dslLinkPSDMask.setDescription('PSD (Power Spectral Density) Mask of DSL link. Asymmetric PSD offers \n          a 5 - 10% longer DSL range. PSD symmetric is default setting. PSD \n          asymmetric is only possible with line rates n = 32 or 36.')
dslLinkAssignedTrunk = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 19), TrunkNumberOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkAssignedTrunk.setStatus('current')
if mibBuilder.loadTexts: dslLinkAssignedTrunk.setDescription('Determines the data trunk (aggregate side) on which the all data \n          traffic of this DSL Link is mapped.')
dslLinkPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 2, 1, 20), Priority()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkPriority.setStatus('current')
if mibBuilder.loadTexts: dslLinkPriority.setDescription('Determines the priority according to IEEE 802.3x for data traffic \n          coming from this DSL Link. Value range is 0 .. 7. 0 lowest priority, \n          7 highest priority.')
class IadAlarmStatusElem(TextualConvention, Bits):
    description = 'Bitset to represent alarms on a IAD.'
    status = 'current'
    namedValues = NamedValues(("powerdown", 0), ("lifeline", 1), ("dcContinuity", 2))

class IadISDNPoweringEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("off", 1), ("normal", 2), ("lifeline", 3), ("always", 4))

class IadPOTSPoweringEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("off", 1), ("always", 2))

iadTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3), )
if mibBuilder.loadTexts: iadTable.setStatus('current')
if mibBuilder.loadTexts: iadTable.setDescription('IAD table. IAD is for Integrated Access Device. The IAD contains the\n          DSL NTU, and depending on the model, ISDN Adapters, POTS Terminal\n          Adapters (TA) and Ethernet interfaces. The IAD is also called just\n          modem or NTU.\n          The table contains one entry per DSL link. The entry exists even if\n          the IAD is offline (that is disconnected).')
iadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1), )
dslLinkEntry.registerAugmentions(("PEGASUS-MIB", "iadEntry"))
iadEntry.setIndexNames(*dslLinkEntry.getIndexNames())
if mibBuilder.loadTexts: iadEntry.setStatus('current')
if mibBuilder.loadTexts: iadEntry.setDescription('Carry index for iad table.')
iadAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 1), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: iadAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
iadHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: iadHardwareVersion.setDescription("Hardware version of the IAD. This is also called CHM-number (it\n          always starts with the letters 'CHM'). Example: CHM415080WAAA2. The\n          number '415' after the 'CHM' identifies the device as an IAD.")
iadManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadManufacturer.setStatus('current')
if mibBuilder.loadTexts: iadManufacturer.setDescription('Name of company which manufactured this IAD.')
iadName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadName.setStatus('current')
if mibBuilder.loadTexts: iadName.setDescription('User defined name of IAD.')
iadOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 5), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadOperState.setStatus('current')
if mibBuilder.loadTexts: iadOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
iadFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: iadFirmwareVersion.setDescription("Version number and build date of the firmware running on the IAD.\n          Example:\n            '1.3 20020607 16:34'\n          The format is 'major.minor YYYYMMDD hh:mm', where the fields are:\n          major     Major and minor version numbers, separated by a dot. Take at\n          minor     most 5 characters together, including the space. Both major\n                    and minor consist of digits only.\n          YYYYMMDD  Date (year YYYY, month MM 1-12 and day DD 1-31) of firmware\n                    build. Preceded and followed by exactly one space to\n                    separate it from the version numbers and time.\n          hh:mm     Time (hour hh 0-23 and minute mm 0-59) of firmware build.")
iadSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadSerialNumber.setStatus('current')
if mibBuilder.loadTexts: iadSerialNumber.setDescription("Serial number of the IAD. Also called HM-number, as it always\n          starts with 'HM'. Example: HMHMZ014432064.")
iadAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 8), IadAlarmStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: iadAlarmStatus.setDescription('Alarm Status of IAD. Individual alarms show that specific\n           (usually adverse) conditions are present. Bits are assigned\n           as follows:\n           bit 0      powerdown    The IAD has no local power.\n           bit 1      lifeline     The IAD is operating on lifeline, i.e.\n                                   is taking power from the DSL line, not\n                                   from the local power supply.')
iadISDNPowering = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 9), IadISDNPoweringEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iadISDNPowering.setStatus('current')
if mibBuilder.loadTexts: iadISDNPowering.setDescription('State of the powering of the ISDN S-Bus port 0.\n          no power        No powering of ISDN S0 Bus at all.\n          normal power    Powering of ISDN S0 Bus, normal mode.\n          lifeline power  Lifeline mode\n          always power    Supporting  normal operation and lifeline operation.')
iadPOTSPowering = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 10), IadPOTSPoweringEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iadPOTSPowering.setStatus('current')
if mibBuilder.loadTexts: iadPOTSPowering.setDescription('Defines how the IAD powers the POTS line, i.e. the analog telephone\n          line on the integrated TA. This feature is not reliable on older IAD\n          models.')
iadEthPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 11), DataPortSpeedEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iadEthPortSpeed.setStatus('current')
if mibBuilder.loadTexts: iadEthPortSpeed.setDescription("Configuration of the desired speed for the IAD's Ethernet port.")
iadEthCurrentPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 12), DataPortSpeedEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadEthCurrentPortSpeed.setStatus('current')
if mibBuilder.loadTexts: iadEthCurrentPortSpeed.setDescription("Displays the currently active speed of a IAD's Ethernet port.")
iadEthFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 13), DataPortFlowControlEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iadEthFlowControl.setStatus('current')
if mibBuilder.loadTexts: iadEthFlowControl.setDescription('Configuration of the desired flow control.')
iadEthCurrentFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 3, 1, 14), DataPortFlowControlEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iadEthCurrentFlowControl.setStatus('current')
if mibBuilder.loadTexts: iadEthCurrentFlowControl.setDescription('Displays the currently used flow control.')
class DslInterfaceTypeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ltu", 1), ("ntu", 2))

class DslPerformanceStatusElem(TextualConvention, Bits):
    description = 'Possible status values or alarms for a DSL interface.'
    status = 'current'
    namedValues = NamedValues(("att", 0), ("losw", 1))

dslInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4), )
if mibBuilder.loadTexts: dslInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceTable.setDescription('DSL Interface table.')
dslInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1), ).setIndexNames((0, "PEGASUS-MIB", "dslCardSlotNumber"), (0, "PEGASUS-MIB", "dslLinkNumber"), (0, "PEGASUS-MIB", "dslInterfaceType"))
if mibBuilder.loadTexts: dslInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceEntry.setDescription('Row/index definition for dslInterfaceTable.')
dslInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 1), DslInterfaceTypeEnum())
if mibBuilder.loadTexts: dslInterfaceType.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceType.setDescription('The type of device on which the interface sits: LTU (linecard) or\n           Ntu (IAD, modem).')
dslInterfaceAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 2), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslInterfaceAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
dslInterfaceOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 3), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslInterfaceOperState.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
dslInterfacePerformanceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 4), DslPerformanceStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslInterfacePerformanceStatus.setStatus('current')
if mibBuilder.loadTexts: dslInterfacePerformanceStatus.setDescription('Displays the current status of the DSL interface')
dslInterfacePerfControlIndexOrZero = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslInterfacePerfControlIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: dslInterfacePerfControlIndexOrZero.setDescription('If the value of this variable is set to a non-zero value, there must\n          be a row in perfControlTable with this value in perfControlIndex. The\n          perfControlEntry thus identified controls the performance history\n          entries in perfDataTable for the DSL interface referencing the\n          perfControlEntry.\n          If the value is set to zero, performance history for this interface\n          is removed from the perfDataTable.')
dslInterfaceSignalQuality = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: dslInterfaceSignalQuality.setReference('ETSI TS 101 524 [SDSL], clauses 10.5.5.7.15-16.')
if mibBuilder.loadTexts: dslInterfaceSignalQuality.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceSignalQuality.setDescription('This object gives the signal quality, expressed as the\n          signal-to-noise ratio (SNR) in decibels (dB).\n          The value 127 shows that the real value is currently unavailable.')
dslInterfaceAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: dslInterfaceAttenuation.setReference('ETSI TS 101 524 [SDSL], clauses 10.5.5.7.5 and 10.5.5.7.15-16.')
if mibBuilder.loadTexts: dslInterfaceAttenuation.setStatus('current')
if mibBuilder.loadTexts: dslInterfaceAttenuation.setDescription('This object shows how much the signal has been weakened (attenuated)\n          on the DSL line. It is expressed in decibels (dB) relative to the\n          transmit power.\n          The value -128 shows that the real value is currently not available.\n          The value normally increases with the line length.')
class CosClassifierEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("vlanPriority", 1), ("dscpPriority", 2))

class CosClassmap(TextualConvention, OctetString):
    description = 'Meaning and length of the octet string depends on the value of \n        dslLinkCOSClassifier. If vlanPriority(1) is used, only the first \n        octet is valid. Each bit represents the number of a vlan that is \n        used for the particular queue (EF, AF2 or AF1). In case of \n        dscpPriority(2), 8 octets represent the 64 priorities.\n        Within each octet, the most significant bit represents the lowest \n        numbered vlan/priority, and the least significant bit represents \n        the highest numbered vlan/priority. \n        \n        octet-to-vlan/prio mappings (1st number = value for MSB):\n                 octet1 octet2 octet3 octet4 octet5 octet6 octet7 octet8\n        vlan(1):  0..7    -      -      -      -      -      -      -\n        dscp(2):  0..7  8..15  16..23 24..31 32..39 40..47 48..55 56..64'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 8)

dslLinkCosTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5), )
if mibBuilder.loadTexts: dslLinkCosTable.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosTable.setDescription('Class of Service (COS) table for a DSL link. The table allows \n          to assign vlans or priorities to the queues EF (Expedited \n          Forwarding) and AF1/AF2 (Assured Forwarding). The last queue, \n          BE (Best Effort) gets the bandwidth that is left.\n\n            queue: priority:  bandwidth:\n             EF     highest    configurable\n             AF2    higher     configurable\n             AF1    lower      configurable\n             BE     lowesr     left-over')
dslLinkCosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1), )
dslLinkEntry.registerAugmentions(("PEGASUS-MIB", "dslLinkCosEntry"))
dslLinkCosEntry.setIndexNames(*dslLinkEntry.getIndexNames())
if mibBuilder.loadTexts: dslLinkCosEntry.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosEntry.setDescription('Row/index definition for dslLinkCosTable.')
dslLinkCosAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dslLinkCosAvailable.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosAvailable.setDescription(' If true(1), COS is supported by the LineCard.')
dslLinkCosEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosEnabled.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosEnabled.setDescription('Enabling and disabling of COS for the specified link.')
dslLinkCosClassifier = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 3), CosClassifierEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosClassifier.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosClassifier.setDescription('Configuration of the desired classifier. Possible values are \n          VLAN priority and DSCP (Differentiated Services Code Point) \n          priority.')
dslLinkCosClassmapEF = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 4), CosClassmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosClassmapEF.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosClassmapEF.setDescription('Classmap for the EF (Expedited Forwarding) queue. See \n          description of CosClassmap for further information.')
dslLinkCosClassmapAF2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 5), CosClassmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosClassmapAF2.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosClassmapAF2.setDescription('Classmap for the AF2 (Assured Forwarding) queue. See \n          description of CosClassmap for further information.')
dslLinkCosClassmapAF1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 6), CosClassmap()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosClassmapAF1.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosClassmapAF1.setDescription('Classmap for the AF1 (Assured Forwarding) queue. See \n          description of CosClassmap for further information.')
dslLinkCosRateLimitEF = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2312))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosRateLimitEF.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosRateLimitEF.setDescription('Maximum rate in kB that the EF queue is allowed to use.\n          Note: The sum of the maxima of EF, AF1 and AF2 queue cannot \n          exceed the configured maximum data rate od the DSL link.')
dslLinkCosRateLimitAF2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2312))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosRateLimitAF2.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosRateLimitAF2.setDescription('Maximum rate in kB that the AF2 queue is allowed to use.\n          Note: The sum of the maxima of EF, AF1 and AF2 queue cannot \n          exceed the configured maximum data rate od the DSL link.')
dslLinkCosRateLimitAF1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2312))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dslLinkCosRateLimitAF1.setStatus('current')
if mibBuilder.loadTexts: dslLinkCosRateLimitAF1.setDescription('Maximum rate in kB that the AF1 queue is allowed to use.\n          Note: The sum of the maxima of EF, AF1 and AF2 queue cannot \n          exceed the configured maximum data rate od the DSL link.')
class V5ClockModeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("v5ClockMaster", 1), ("v5ClockSlave", 2))

class V5ClockSourceEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("v5ClockExternal", 1), ("v5ClockLink1", 2), ("v5ClockLink2", 3), ("v5ClockLink3", 4), ("v5ClockLink4", 5), ("v5ClockLink5", 6), ("v5ClockLink6", 7), ("v5ClockLink7", 8), ("v5ClockLink8", 9))

class V5ProtocolVersionEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("v51", 1), ("v52", 2))

class V5CardFlagSet(TextualConvention, Bits):
    description = 'Possible configuration flags that can be applied to the V5 card.'
    status = 'current'
    namedValues = NamedValues(("noFastAlign", 0), ("noLinkId", 1), ("autoPortUnblock", 2), ("retryAutoPortUnblock", 3), ("rejectLinkId", 4), ("forcePSTNDL", 5), ("slowStart", 6), ("deallocBlockedPort", 7))

v5CardTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1), )
if mibBuilder.loadTexts: v5CardTable.setStatus('current')
if mibBuilder.loadTexts: v5CardTable.setDescription('A table containing V5 card specific information')
v5CardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1), ).setIndexNames((0, "PEGASUS-MIB", "v5CardSlotNumber"))
if mibBuilder.loadTexts: v5CardEntry.setStatus('current')
if mibBuilder.loadTexts: v5CardEntry.setDescription('Row and index definition for V5 card table.')
v5CardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 1), V5SlotNumber())
if mibBuilder.loadTexts: v5CardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: v5CardSlotNumber.setDescription('Slot number for v5 card.')
v5CardAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 2), AdminStateEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardAdminState.setStatus('current')
if mibBuilder.loadTexts: v5CardAdminState.setDescription('This configuration attribute allows the administrator to enable or\n         disable the operability of a device.\n         unlocked   The device is administratively permitted to perform services\n                    for its users.\n         locked     The device is administratively prohibited from performing \n                    services for users.')
v5CardAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 3), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: v5CardAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
v5CardHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: v5CardHardwareVersion.setDescription("Hardware version of the V5 card. This is also called CHM-number (it\n          always starts with the letters 'CHM'). Example: CHM40210WA0A2. The\n          number '402' after the 'CHM' identifies the card as a V5 card.")
v5CardManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardManufacturer.setStatus('current')
if mibBuilder.loadTexts: v5CardManufacturer.setDescription('Name of company which manufactured this V5 card.')
v5CardName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardName.setStatus('current')
if mibBuilder.loadTexts: v5CardName.setDescription('User defined name of the V5 card.')
v5CardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 7), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardOperState.setStatus('current')
if mibBuilder.loadTexts: v5CardOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
v5CardFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: v5CardFirmwareVersion.setDescription("Version number and build date of the firmware running on the V5 card.\n          Example:\n            '1.3 20020607 16:34'\n          The format is 'major.minor YYYYMMDD hh:mm', where the fields are:\n          major     Major and minor version numbers, separated by a dot. Take at\n          minor     most 5 characters together, including the space. Both major\n                    and minor consist of digits only.\n          YYYYMMDD  Date (year YYYY, month MM 1-12 and day DD 1-31) of firmware\n                    build. Preceded and followed by exactly one space to\n                    separate it from the version numbers and time.\n          hh:mm     Time (hour hh 0-23 and minute mm 0-59) of firmware build.")
v5CardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: v5CardSerialNumber.setDescription("Serial number of the V5 card. Also called HM-number, as it always\n          starts with 'HM'. Example: HMHMZ014532139.")
v5CardCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 10), CommStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardCommState.setStatus('current')
if mibBuilder.loadTexts: v5CardCommState.setDescription("The Management Comm State indicates the state of the management \n          connection between the PEM Server and the Data Card.\n          disconnected            No connection has been established.\n          init                    A connection has freshly been established on \n                                  the underlying protocol, but no management \n                                  information has been transmitted so far.\n          identification          The connected device is being identified.\n          check hardware          The connected hardware is compared to the one \n                                  stored in the configuration.\n          hardware adaptation     If the configured and the existing device do \n                                  not match, an adoption is made. The behaviour \n                                  in this case can be configured with the 'HW \n                                  Adaptation Policy' option.\n\n          check program version   The program version of the connected hardware \n                                  is compared to the one stored in the configura-\n                                  tion.\n          check config version    The configuration version of the connected \n                                  hardware is compared to the one stored in the \n                                  configuration.\n          download config         If a configuration version mismatch has bee \n                                  detected and the 'Config Priority' of 'PEGASUS \n                                  system' is set to 'Device', the configuration \n                                  is downloaded from the device to the PEM Server.\n          upload config           If a configuration version mismatch has been \n                                  detected and the 'Config Priority' of 'PEGASUS \n                                  system' is set to 'Server', the configuration \n                                  is uploaded from the PEM Server to the device.\n          status synch            The values of the status properties are being \n                                  synchronised.\n          resetting               The device is resetting.\n          inactive                The device is connected, but it is inactive,\n                                  i.e. not operational. This may be due to a\n                                  hardware mismatch.\n          active                  The management connection between the device \n                                  and the PEM Server is fully established and the \n                                  device is active.")
v5CardIsProvisioning = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5CardIsProvisioning.setStatus('current')
if mibBuilder.loadTexts: v5CardIsProvisioning.setDescription('The V5 Card is in provisioning mode. Only if this flag is true,\n          re-configuration of the V5 Card is possible.')
v5CardClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 12), V5ClockModeEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardClockMode.setStatus('current')
if mibBuilder.loadTexts: v5CardClockMode.setDescription('Clock mode of the V5 Card\n          Master  This card is the clock master.\n          Slave   This card is a clock slave.')
v5CardClockSource1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 13), V5ClockSourceEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardClockSource1.setStatus('current')
if mibBuilder.loadTexts: v5CardClockSource1.setDescription('If the card is configured to be the clock master (v5CardClockMode),\n          this property determines the source of the clock. Values range is \n          1 .. 8 or external clock (from plug on front panel).')
v5CardClockSource2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 14), V5ClockSourceEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardClockSource2.setStatus('current')
if mibBuilder.loadTexts: v5CardClockSource2.setDescription('If the card is configured to be the clock master (v5CardClockMode),\n          this property determines the source of the clock in case clock source\n          1 is not available. Value range is 1 .. 8 or external clock (from plug\n          on front panel).')
v5CardProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 15), V5ProtocolVersionEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardProtocolVersion.setReference('G.964 for the V5.1 protocol\n           G.965 for the V5.2 protocol')
if mibBuilder.loadTexts: v5CardProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: v5CardProtocolVersion.setDescription('The version of the V5 protocol. Can be either V5.1 or V5.2')
v5CardRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardRowStatus.setStatus('current')
if mibBuilder.loadTexts: v5CardRowStatus.setDescription("This object allows creation and deletion of V5 card table entries.\n          The card can only be deleted when it is disconnected. V5 cards are\n          always created with 512 user ports. All other objects (V5 interfaces,\n          V5 links, and log comm channels) must be created separately.\n          If the card is deleted, all objects related to it are also deleted.\n          To configure the card, or any object associated with it, the card\n          must be disconnected or v5CardRowStatus must not be 'active'.\n          Setting v5CardRowStatus to 'notInService' while the card is connected\n          puts the card into provisioning mode. Setting v5CardRowStatus to\n          'active' while the card is connected commits provisioning, that is\n          ends provisioning mode (or fails if the card finds the configuration\n          incorrect or incomplete).")
v5CardFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 17), V5CardFlagSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardFlags.setStatus('current')
if mibBuilder.loadTexts: v5CardFlags.setDescription('This object holds various flags which can be set to modify the\n          behaviour of the V5 protocol stack.')
v5CardETSIRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardETSIRelease.setStatus('current')
if mibBuilder.loadTexts: v5CardETSIRelease.setDescription('The ETSI release (version) of the V5 standard used for the V5\n          protocol on all V5 interface of the V5 card. This must not be\n          confused with the choice of the V5 protocol (V5.1 or V5.2).')
v5CardE1LineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hdb3", 1), ("ami", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardE1LineCode.setStatus('current')
if mibBuilder.loadTexts: v5CardE1LineCode.setDescription('The E1 line code used on all V5 links of the V5 card.')
v5CardE1FrameFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("crc4", 1), ("crc4e", 2), ("dff", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5CardE1FrameFormat.setStatus('current')
if mibBuilder.loadTexts: v5CardE1FrameFormat.setDescription('The frame format of E1 frames used on all V5 links of the V5 card.')
class V5LinkNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 8)

class V5LinkNumberOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 8)

class V5InterfaceNumber(V5LinkNumber):
    pass

class V5InterfaceNumberOrZero(V5LinkNumberOrZero):
    pass

class V5PccCount(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 3)

class V5LinkAlarmStatusElem(TextualConvention, Bits):
    description = 'Bitset that represents all possible alarms for a V5 link.'
    status = 'current'
    namedValues = NamedValues(("v5LinkAlarmLOS", 0), ("v5LinkAlarmLFA", 1), ("v5LinkAlarmAIS", 2), ("v5LinkAlarmBERH", 3), ("v5LinkAlarmEXTLOC", 4), ("v5LinkAlarmRAI", 5), ("v5LinkAlarmIdFailure", 6))

class V5LinkTypeEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("primary", 1), ("secondary", 2), ("normal", 3))

v5LinkTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2), )
if mibBuilder.loadTexts: v5LinkTable.setStatus('current')
if mibBuilder.loadTexts: v5LinkTable.setDescription('A table containing V5 link specific information')
v5LinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1), ).setIndexNames((0, "PEGASUS-MIB", "v5CardSlotNumber"), (0, "PEGASUS-MIB", "v5LinkNumber"))
if mibBuilder.loadTexts: v5LinkEntry.setStatus('current')
if mibBuilder.loadTexts: v5LinkEntry.setDescription('Row and index definition for V5 link table.')
v5LinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 1), V5LinkNumber())
if mibBuilder.loadTexts: v5LinkNumber.setStatus('current')
if mibBuilder.loadTexts: v5LinkNumber.setDescription('Number of the link on the V5 card (used for table indexing).')
v5LinkAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 2), AdminStateEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkAdminState.setStatus('current')
if mibBuilder.loadTexts: v5LinkAdminState.setDescription('This configuration attribute allows the administrator to enable or\n          disable the operability of a device.\n          unlocked   The device is administratively permitted to perform\n                     services for its users.\n          locked     The device is administratively prohibited from performing \n                     services for users.')
v5LinkAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 3), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5LinkAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: v5LinkAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
v5LinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkId.setStatus('current')
if mibBuilder.loadTexts: v5LinkId.setDescription('V5 Link Identifier. Value range is 0 .. 255')
v5LinkOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 5), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5LinkOperState.setStatus('current')
if mibBuilder.loadTexts: v5LinkOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
v5LinkInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 6), V5InterfaceNumberOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkInterface.setStatus('current')
if mibBuilder.loadTexts: v5LinkInterface.setDescription('Identifies to which V5 interface this V5 link is related.')
v5LinkAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 7), V5LinkAlarmStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5LinkAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: v5LinkAlarmStatus.setDescription('Alarm status of the V5 link. Bits assigned as follows:\n           bit 0    LOS         Loss of signal\n           bit 1    LFA         Loss of frame alignment\n           bit 2    AIS         Alarm indication signal\n           bit 3    BERH        Bit error rate to high\n           bit 4    EXTLOC      Loss of external clock\n           bit 5    RAI         Remote alarm indication')
v5LinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 8), V5LinkTypeEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkType.setStatus('current')
if mibBuilder.loadTexts: v5LinkType.setDescription("Specifies the type of V5 Link\n          Primary     The primary link carries all the important V5 Protocols.\n                      Therefore it needs to have at least one Physical Communi-\n                      cation Channel on timeslot 16. There must be exactly one \n                      primary link per V5 interface.\n          Secondary   The secondary link acts as 'standby' link for the primary \n                      link; i.e. if the primary link fails, the secondary link \n                      will transport the V5 Protocols instead. Therefore it needs \n                      to have an unused PhysComm Channel on timeslot 16. If more \n                      than one links are available, there must be exactly one \n                      secondary link per V5 interface.\n          Normal      All other links are 'normal' links and do not take any \n                      predefined responsibility concerning protection mechanisms.")
v5LinkNumberOfPcc = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 9), V5PccCount()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkNumberOfPcc.setStatus('current')
if mibBuilder.loadTexts: v5LinkNumberOfPcc.setDescription("The number of Physical Communication Channel (Physcommchan or\n          PCC) configured on this V5 link. V5 links are structured as 8000\n          frames per second of 32 timeslots each. A timeslot can carry voice\n          data, or alternatively signalling, e.g. synchronization data, CRC's,\n          or D-channel data. Timeslot 0 is always used for signalling by lower\n          level layers of E1. For higher level signalling like D-channels,\n          additional timeslots must be explicitly allocated - these are called\n          physcommchans. Timeslots 16, 15 and 31 are available for this purpose.\n          So, a V5 link can have from zero to three physcommchans. Timeslots\n          are always allocated in the order mentioned above, that is the\n          following configurations are possible:\n\n                                 Timeslots allocated to\n          v5LinkNumberOfPcc      higher level signalling\n                  0              -\n                  1              16\n                  2              16,15\n                  3              16,15,31\n\n          Timeslots that are not used for signalling are available for voice\n          data. So, a link can have from 28 to 31 voice data channels.")
v5LinkPerfControlIndexOrZero = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkPerfControlIndexOrZero.setStatus('current')
if mibBuilder.loadTexts: v5LinkPerfControlIndexOrZero.setDescription('The value of this variable represents the index of a row within \n          the perfControlTable. If the value is not 0, performance data \n          (statistics) concerning this link are captured.')
v5LinkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LinkRowStatus.setStatus('current')
if mibBuilder.loadTexts: v5LinkRowStatus.setDescription('RowStatis variable that allows creation and deletion of V5 links.')
v5LinkLineIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5LinkLineIdentifier.setStatus('current')
if mibBuilder.loadTexts: v5LinkLineIdentifier.setDescription('An idenifier assigned to the subscriber (customer).')
class V5InterfaceAlarmSet(TextualConvention, Bits):
    description = 'Bitset that contains the possible alarms for a V5 interface'
    status = 'current'
    namedValues = NamedValues(("idFailure", 0), ("provisioningMismatch", 1))

v5InterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3), )
if mibBuilder.loadTexts: v5InterfaceTable.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceTable.setDescription('A table containing V5 interface specific information. Only AN\n           side interfaces are present.')
v5InterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1), ).setIndexNames((0, "PEGASUS-MIB", "v5CardSlotNumber"), (0, "PEGASUS-MIB", "v5InterfaceNumber"))
if mibBuilder.loadTexts: v5InterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceEntry.setDescription('Row and index definition for V5 interface table.')
v5InterfaceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 1), V5InterfaceNumber())
if mibBuilder.loadTexts: v5InterfaceNumber.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceNumber.setDescription('interface number, used for table indexing')
v5InterfaceAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 2), AdminStateEnum()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5InterfaceAdminState.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceAdminState.setDescription('This configuration attribute allows the administrator to enable or\n          disable the operability of a device.\n          unlocked   The device is administratively permitted to perform\n                     services for its users.\n          locked     The device is administratively prohibited from performing \n                     services for users.')
v5InterfaceAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 3), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5InterfaceAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
v5InterfaceId = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5InterfaceId.setReference('G.964, section 14.4.2.5.7')
if mibBuilder.loadTexts: v5InterfaceId.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceId.setDescription('V5 Interface Identifier. Value range is 0 .. 16777215.')
v5InterfaceOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 5), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5InterfaceOperState.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
v5InterfaceVariantId = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5InterfaceVariantId.setReference('G.964, section 14.4.2.5.6')
if mibBuilder.loadTexts: v5InterfaceVariantId.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceVariantId.setDescription('Indicates the V5 provisioning variant, which is currently valid. \n          This is used to decide if the configuration is compliant with the LE. \n          Value range is 0 .. 127.')
v5InterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5InterfaceRowStatus.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceRowStatus.setDescription('Variable to create and delete V5 interfaces.')
v5InterfaceAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 3, 1, 8), V5InterfaceAlarmSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5InterfaceAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: v5InterfaceAlarmStatus.setDescription('Displays the currently active alarms of the V5 interface.')
class V5LccNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 21)

class V5LccNumberOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 21)

class V5PccNumberOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 3)

v5LccTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4), )
if mibBuilder.loadTexts: v5LccTable.setStatus('current')
if mibBuilder.loadTexts: v5LccTable.setDescription('table containing all LCC (Logical Communication Channels) \n          for a V5 interface')
v5LccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1), ).setIndexNames((0, "PEGASUS-MIB", "v5CardSlotNumber"), (0, "PEGASUS-MIB", "v5InterfaceNumber"), (0, "PEGASUS-MIB", "v5LccNumber"))
if mibBuilder.loadTexts: v5LccEntry.setStatus('current')
if mibBuilder.loadTexts: v5LccEntry.setDescription('row defintion for the v5LccTable')
v5LccNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 1), V5LccNumber())
if mibBuilder.loadTexts: v5LccNumber.setStatus('current')
if mibBuilder.loadTexts: v5LccNumber.setDescription('index of the LCC; number in the range of 1..21')
v5LccIsProtected = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 2), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LccIsProtected.setStatus('current')
if mibBuilder.loadTexts: v5LccIsProtected.setDescription('If true, all information transported over this LCC is protected by \n          the V5 Protection protocol (V5.2 only).')
v5LccId = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LccId.setStatus('current')
if mibBuilder.loadTexts: v5LccId.setDescription('Unique L3 address per Logical Communication Channel. Value range is \n          0 .. 65535.')
v5LccOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 4), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5LccOperState.setStatus('current')
if mibBuilder.loadTexts: v5LccOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
v5LccPccV5LinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 5), V5LinkNumberOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LccPccV5LinkNumber.setStatus('current')
if mibBuilder.loadTexts: v5LccPccV5LinkNumber.setDescription('Identify (together with v5LccPccTimeslot) the Physical Communication\n          Channel used for the signalling data of this Logical Communication\n          Channel.')
v5LccPccTimeslot = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 6), V5PccNumberOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LccPccTimeslot.setStatus('current')
if mibBuilder.loadTexts: v5LccPccTimeslot.setDescription('Identify (together with v5LccPccV5LinkNumber) the Physical\n          Communication Channel used for the signalling data of this Logical\n          Communication Channel.\n          The value of this variable is a code with the following value:\n          v5LccPccTimeslot   Timeslot\n            0                  none\n            1                  16\n            2                  15\n            3                  31\n          A value of 0 cannot be set explicitly, and can only appear while the\n          LCC object is being initialized. Once a non-zero value has been set\n          (either through SNMP or by other means of management, a value of\n          0 can never again appear.')
v5LccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: v5LccRowStatus.setStatus('current')
if mibBuilder.loadTexts: v5LccRowStatus.setDescription('The value of this object can be active(1) in order for the value\n          of v5LccPccV5LinkNumber or v5LccPccTimeslot to be modified. To set \n          the PCC both attributes v5LccPccV5LinkNumber and v5LccPccTimeslot \n          must be set before the values become active. \n          The values become only active if v5LccPccV5LinkNumber and \n          v5LccPccTimeslot specify an existing Physical Communication Channel \n          on the V5 card identified by the instance of v5CardSlotNumber used \n          to index this v5LccEntry.')
class V5IsdnPortLoopEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("loop1", 2), ("loop2", 3))

class V5IsdnPortBlockingStatusEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("local", 2), ("remote", 3), ("both", 4))

class V5IsdnPortAlarmStatusElem(TextualConvention, Bits):
    description = 'Bitset representing the possible alarms for a ISDN port.'
    status = 'current'
    namedValues = NamedValues(("l1ActivationFault", 0), ("losTref", 1), ("losDsig", 2))

class V5TimeslotNumber(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(1, 15), ValueRangeConstraint(17, 31), )
class V5EnvelopeFuncAddress(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 8175)

v5IsdnPortTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5), )
if mibBuilder.loadTexts: v5IsdnPortTable.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortTable.setDescription('A table containing information specific to V5 ISDN user ports,\n           i.e. S0 interfaces on IADs.')
v5IsdnPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1), ).setIndexNames((0, "PEGASUS-MIB", "dslCardSlotNumber"), (0, "PEGASUS-MIB", "dslLinkNumber"), (0, "PEGASUS-MIB", "v5IsdnPortBRANumber"))
if mibBuilder.loadTexts: v5IsdnPortEntry.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortEntry.setDescription('Row and index definition for V5 ISDN user port table. Sometimes,\n           user ports are numbered 0..511 (8 cards @ 16 ltus @ 4 bras/ntu),\n           with an implicit assignment of\n           linecard  = port/(8*16).\n           dsl link  = port%(8*16)/4\n           bra       = port%(8*16*4).')
v5IsdnPortBRANumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: v5IsdnPortBRANumber.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortBRANumber.setDescription('index number for this port')
v5IsdnPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 4), AdminStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortAdminState.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortAdminState.setDescription('This configuration attribute allows the administrator to enable or\n          disable the operability of a device.\n          unlocked   The device is administratively permitted to perform\n                     services for its users.\n          locked     The device is administratively prohibited from performing \n                     services for users.')
v5IsdnPortOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 5), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5IsdnPortOperState.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
v5IsdnPortBlockingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 6), V5IsdnPortBlockingStatusEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5IsdnPortBlockingStatus.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortBlockingStatus.setDescription('In the case of an unlocked/disabled status, this attribute \n          indicates, if the disabled-state is due to local or remote reasons \n          (ETS 300 376-1, A.2), (Definition in ETS 300 377-1)\n          None    The User Port is unblocked.\n          Local   The User Port is blocked on the Access Network side only\n          Remote  The User Port is blocked on the Local Exchange side only\n          Both    The User Port is blocked both on the AN and on the LE side.')
v5IsdnPortBearer1Timeslot = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 7), V5TimeslotNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortBearer1Timeslot.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortBearer1Timeslot.setDescription('Assigned bearer time slot number to port B1 channel. No assignment \n          for V5.2 interfaces because the BCC protocol is used for dynamic \n          assignment. In V5.1 the association between V5Interface and V5Link \n          is one to one. The link associated to this user port is fully \n          determined by the UserPort-V5Interface association. Value range is \n          1 .. 15 or 17 .. 31.')
v5IsdnPortBearer2Timeslot = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 8), V5TimeslotNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortBearer2Timeslot.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortBearer2Timeslot.setDescription('Assigned bearer time slot number to port B2 channel. No assignment \n          for V5.2 interfaces because the BCC protocol is used for dynamic \n          assignment. In V5.1 the association between V5Interface and V5Link \n          is one to one. The link associated to this user port is fully \n          determined by the UserPort-V5Interface association. Value range is \n          1 .. 15 or 17 .. 31.')
v5IsdnPortEnvelopeFuncAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 9), V5EnvelopeFuncAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortEnvelopeFuncAddress.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortEnvelopeFuncAddress.setDescription('Layer 3 Address of this User Port. Value range is 0 .. 8175.')
v5IsdnPortIsActivated = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5IsdnPortIsActivated.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortIsActivated.setDescription('Layer 1 activation status')
v5IsdnPortAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 11), V5IsdnPortAlarmStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5IsdnPortAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortAlarmStatus.setDescription('displays the currently active alarms for the ISDN port')
v5IsdnPortActiveLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 12), V5IsdnPortLoopEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortActiveLoop.setStatus('obsolete')
if mibBuilder.loadTexts: v5IsdnPortActiveLoop.setDescription('')
v5IsdnPortV5CardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 13), V5SlotNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: v5IsdnPortV5CardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortV5CardSlotNumber.setDescription('Slot number of V5 card which owns this user port configuration.\n          Physically, user ports are on IAD devices. Logically, their\n          configuration is part of the V5 configuration, so it is the V5\n          card which owns the configuration, not the DSL card.\n          For this reason, user ports are created in the context of a V5\n          card, which is why the V5 card cannot be changed.')
v5IsdnPortV5InterfaceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 14), V5InterfaceNumberOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortV5InterfaceNumber.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortV5InterfaceNumber.setDescription('The V5 interface whose V5 links provide signalling and B channel\n          capacity for this user port. The value zero appears only after\n          creation. Once a non-zero value has been set here, it is no more\n          possible to reset the value to zero.')
v5IsdnPortDSignallingCommChan = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 15), V5LccNumberOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortDSignallingCommChan.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortDSignallingCommChan.setDescription('The ISDN Communication Path over which the D-Signalling control \n          information of this User Port is transported.')
v5IsdnPortFrameCommChan = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 16), V5LccNumberOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortFrameCommChan.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortFrameCommChan.setDescription('The ISDN Communication Path over which the Frame control information \n          of this User Port is transported.')
v5IsdnPortPacketCommChan = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 17), V5LccNumberOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortPacketCommChan.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortPacketCommChan.setDescription('The ISDN Communication Path over which the Packet control information\n          of this User Port is transported.')
v5IsdnPortLineIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 2, 5, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: v5IsdnPortLineIdentifier.setStatus('current')
if mibBuilder.loadTexts: v5IsdnPortLineIdentifier.setDescription('An idenifier assigned to the subscriber (customer).')
dataCardTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1), )
if mibBuilder.loadTexts: dataCardTable.setStatus('current')
if mibBuilder.loadTexts: dataCardTable.setDescription('attributes concerning the data switch (slot 1)')
dataCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1), ).setIndexNames((0, "PEGASUS-MIB", "dataCardSlotNumber"))
if mibBuilder.loadTexts: dataCardEntry.setStatus('current')
if mibBuilder.loadTexts: dataCardEntry.setDescription('entry/row within the dataCardTable')
dataCardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 1), DataCardSlotNumber())
if mibBuilder.loadTexts: dataCardSlotNumber.setStatus('current')
if mibBuilder.loadTexts: dataCardSlotNumber.setDescription('Position of the slot card in the rack.')
dataCardAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 2), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: dataCardAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
dataCardHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: dataCardHardwareVersion.setDescription("Hardware Version Number of the data card. This is also called CHM-number\n      (it always starts with the letters 'CHM'). Example: CHM40310WA0A2. The\n      number '403' after the 'CHM' identifies the card as a data card.")
dataCardManufacturer = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardManufacturer.setStatus('current')
if mibBuilder.loadTexts: dataCardManufacturer.setDescription('Manufacturer of the data card.')
dataCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardName.setStatus('current')
if mibBuilder.loadTexts: dataCardName.setDescription('User defined name of the data card.')
dataCardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 6), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardOperState.setStatus('current')
if mibBuilder.loadTexts: dataCardOperState.setDescription('The operational state is a status property indicating whether or not a\n      device is physically installed and working.\n      enabled   The device is partially or fully operable and available for use.\n      disabled  The device is totally inoperable and unavailable to provide \n                service.')
dataCardFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: dataCardFirmwareVersion.setDescription("Version number and build date of the firmware running on the data card.\n      Example:\n        '1.3 20020607 16:34'\n      The format is 'major.minor YYYYMMDD hh:mm', where the fields are:\n      major     Major and minor version numbers, separated by a dot. Take at\n      minor     most 5 characters together, including the space. Both major\n                and minor consist of digits only.\n      YYYYMMDD  Date (year YYYY, month MM 1-12 and day DD 1-31) of firmware\n                build. Preceded and followed by exactly one space to\n                separate it from the version numbers and time.\n      hh:mm     Time (hour hh 0-23 and minute mm 0-59) of firmware build.")
dataCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: dataCardSerialNumber.setDescription("Serial number of the data card. Also called HM-number, as it always\n      starts with 'HM'. Example: HMHMZ014332080.")
dataCardCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 9), CommStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCardCommState.setStatus('current')
if mibBuilder.loadTexts: dataCardCommState.setDescription("The Management Comm State indicates the state of the management \n          connection between the PEM Server and the Data Card.\n          disconnected            No connection has been established.\n          init                    A connection has freshly been established on \n                                  the underlying protocol, but no management \n                                  information has been transmitted so far.\n          identification          The connected device is being identified.\n          check hardware          The connected hardware is compared to the one \n                                  stored in the configuration.\n          hardware adaptation     If the configured and the existing device do \n                                  not match, an adoption is made. The behaviour \n                                  in this case can be configured with the 'HW \n                                  Adaptation Policy' option.\n\n          check program version   The program version of the connected hardware \n                                  is compared to the one stored in the configura-\n                                  tion.\n          check config version    The configuration version of the connected \n                                  hardware is compared to the one stored in the \n                                  configuration.\n          download config         If a configuration version mismatch has bee \n                                  detected and the 'Config Priority' of 'PEGASUS \n                                  system' is set to 'Device', the configuration \n                                  is downloaded from the device to the PEM Server.\n          upload config           If a configuration version mismatch has been \n                                  detected and the 'Config Priority' of 'PEGASUS \n                                  system' is set to 'Server', the configuration \n                                  is uploaded from the PEM Server to the device.\n          status synch            The values of the status properties are being \n                                  synchronised.\n          resetting               The device is resetting.\n          inactive                The device is connected, but it is inactive,\n                                  i.e. not operational. This may be due to a\n                                  hardware mismatch.\n          active                  The management connection between the device \n                                  and the PEM Server is fully established and the \n                                  device is active.")
dataCardVLANMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataCardVLANMode.setStatus('current')
if mibBuilder.loadTexts: dataCardVLANMode.setDescription('If true(1), enhanced switching (trunk assignment according to setting in \n      DSL link configuration) is enabled. Otherwise transparent switching (any \n      DSL link to any trunk) is used.')
dataPortTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2), )
if mibBuilder.loadTexts: dataPortTable.setStatus('current')
if mibBuilder.loadTexts: dataPortTable.setDescription('The table contains an entry for each Ethernet trunk on the \n      data switch (card).')
dataPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1), ).setIndexNames((0, "PEGASUS-MIB", "dataCardSlotNumber"), (0, "PEGASUS-MIB", "dataPortNumber"))
if mibBuilder.loadTexts: dataPortEntry.setStatus('current')
if mibBuilder.loadTexts: dataPortEntry.setDescription('entry within the dataPortTable')
dataPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 1), TrunkNumber())
if mibBuilder.loadTexts: dataPortNumber.setStatus('current')
if mibBuilder.loadTexts: dataPortNumber.setDescription('index of the (ethernet) trunk on the data switch')
dataPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 2), AdminStateEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortAdminState.setStatus('current')
if mibBuilder.loadTexts: dataPortAdminState.setDescription('This configuration attribute allows the administrator to enable or\n      disable the operability of a device.\n      unlocked   The device is administratively permitted to perform services \n                 for its users.\n      locked     The device is administratively prohibited from performing \n                 services for users.')
dataPortOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 3), OperStateEnum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortOperState.setStatus('current')
if mibBuilder.loadTexts: dataPortOperState.setDescription('The operational state is a status property indicating whether or \n          not a device is physically installed and working.\n          enabled   The device is partially or fully operable and available \n                    for use.\n          disabled  The device is totally inoperable and unavailable to provide \n                    service.')
dataPortAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 4), AvailabilityStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortAvailabilityStatus.setStatus('current')
if mibBuilder.loadTexts: dataPortAvailabilityStatus.setDescription('The availability status gives more detailed information about\n          failures within a device. An empty status set means that no error\n          exists. Possible status are:\n          in test       The device is under test.\n          failed        The device has an internal fault that prevents it from \n                        operating.\n          power off     The device requires power to be applied and is not \n                        powered on.\n          off line      The device requires a routine operation to be performed\n                        to place it online and make it available for use.\n          off duty      The device has been made inactive by an internal control\n                        process in accordance with a predetermined time\n                        schedule.\n          dependency    The device can not operate because some other resource \n                        on which it depends is unavailable.\n          degraded      The device is partially defective but still operable.\n          not installed The device is not present, or incomplete.\n          log full      The log is full.')
dataPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 5), DataPortSpeedEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortSpeed.setReference('IEEE 802.3, section 14.5.2: The Crossover Function.')
if mibBuilder.loadTexts: dataPortSpeed.setStatus('current')
if mibBuilder.loadTexts: dataPortSpeed.setDescription('This object allows specification of options for three areas:\n\n      crossover    Normally, DTE and hub sockets are wired such that they can\n                   connect with a straight-through cable, that is the hub has\n                   RX and TX circuits swapped (it has internal crossover). If\n                   a DTE must be connected directly to another DTE (or hub port\n                   to a port on another hub), a crossover cable must be used.\n                   The data card trunk interfaces have an automatic crossover\n                   function, which turns on or off crossover. Any sort of cable\n                   can then be used to connect to any sort of device (DTE\n                   or hub).\n\n      duplex mode  If duplex mode is full duplex, transmission is allowed while\n                   data are received. With half duplex, transmission must wait\n                   until the receiver is idle.\n\n      speed        The port can operate in 10 or 100 MBits per second.\n\n\n      The values possible for this variable are:\n\n      autoCrossoverAndPortSpeed(1)   Allows the port to negotiate speed,\n                                     duplex mode, and to enable or disable\n                                     the internal crossover function.\n\n      autoNegotiationPortSpeed(2)    Allows the port to negotiate speed and\n                                     and duplex mode. Internal crossover is on\n                                     - a straight-through cable is needed to\n                                     connect to a DTE (PC), a crossover cable\n                                     is needed to connect to a repeater or hub.\n\n      base100TFullDuplex(3)          Speed is set to 100 MBits per second, with\n                                     full duplex. Internal crossover is on.\n\n      base100THalfDuplex(4)          Speed is set to 100 MBits per second, with\n                                     half duplex. Internal crossover is on.\n\n      base10TFullDuplex(5)           Speed is set to 10 MBits per second, with\n                                     full duplex. Internal crossover is on.\n\n      base10THalfDuplex(6)           Speed is set to 10 MBits per second, with\n                                     half duplex. Internal crossover is on.')
dataPortFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 3, 2, 1, 6), DataPortFlowControlEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortFlowControl.setStatus('current')
if mibBuilder.loadTexts: dataPortFlowControl.setDescription('Setting of Flow Control according to IEEE 802.3x.\n      Auto  Enables auto negotiation of IEEE 802.3x flow control when in\n            full-duplex mode.\n      On    Force flow control operation\n      Off   No flow control.')
class ConfigPriorityEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("server", 1), ("device", 2))

class HWAdaptionPolicyEnum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("device", 1), ("server", 2))

class RackAlarmStatusElem(TextualConvention, Bits):
    description = 'possible alarms concerning the Pegasus rack'
    status = 'current'
    namedValues = NamedValues(("psu1Failure", 0), ("psu2Failure", 1), ("fanFailure", 2), ("urgentExt", 3), ("nonUrgentExt", 4))

autoPersistDelay = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoPersistDelay.setStatus('current')
if mibBuilder.loadTexts: autoPersistDelay.setDescription('If Auto Persist Config is enabled, this is the delay (in seconds) after \n      which the configuration is persisted on the PEM Server. The default value \n      is: 10s.')
autoPersistEnabled = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoPersistEnabled.setStatus('current')
if mibBuilder.loadTexts: autoPersistEnabled.setDescription('Determines, whether configuration changes are made persistent \n      automatically (a certain interval after the last change of a configuration\n      attribute) or explicitly by a corresponding message from the PEM Client.')
configPriority = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 3), ConfigPriorityEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPriority.setStatus('current')
if mibBuilder.loadTexts: configPriority.setDescription('Determines, which configuration is used in case of a configuration \n      mismatch. Possible values: Server or device. Device: The device config is \n      used (replaces server config). Server: The server config is used (replaces\n      device config)')
hwAdaptionPolicy = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 4), HWAdaptionPolicyEnum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hwAdaptionPolicy.setStatus('obsolete')
if mibBuilder.loadTexts: hwAdaptionPolicy.setDescription('In case of a hardware mismatch (the configured device does not match with\n      the one detected in the rack): shall the PEM Server be reconfigured with\n      the new device or shall the device be taken out of operation? Possible\n      Values: Server or Device. Device: The device config is used (replaces\n      server config). Server: The server config is used (replaces device\n      config)')
ipBaseAddress = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipBaseAddress.setReference('RFC 1597, Section 3, Private Address Space')
if mibBuilder.loadTexts: ipBaseAddress.setStatus('current')
if mibBuilder.loadTexts: ipBaseAddress.setDescription('Base address for the computation of the IP addresses for the management\n      interfaces of the cards. When the PEMServer wants to connect to a card\n      in the rack, it computes the card IP address from ipBaseAddress, the slot\n      number of the card, and the systemNumber of the rack (also in\n      pegasusSystem), as follows: the slot number is added to the last byte\n      of ipBaseAddress, modulo 256, and the systemNumber is added to the next\n      to last byte of ipBaseAddress, again modulo 256.\n\n      Example                      1               2               3\n      iPBaseAddress        |192.168.  0.  0|192.168.244.231|192.168.  0.  0\n      systemNumber         |         +4    |         +4    |         +4\n      slot number          |             +1|             +3|             +5\n      sum                  |          4   1|          4 234|          4   5\n      sum modulo 256       |          4   1|          4 234|          4   5\n      Resulting mgmt IP-#  |192.168.  4.  1|192.168.248.234|192.168.  4.  5\n\n      The slot cards compute their own management interface IP addresses in\n      a similar way, using their own ip base addresses.  These base addresses\n      are not visible through the PEM Client or SNMP. To read or change them\n      on a card, the CLI must be used.\n\n      All slot cards within a PEGASUS system must have the management IP\n      addresses in the same network in order to communicate with each other.\n      They must then have the same base address (with the exception\n      of biasing, as explained below).\n      The base addresses of all cards are usually chosen such that the\n      management IP addresses end up in a non-routable (private) networks.\n\n      Biasing: cards read slot and rack numbers through dedicated pins on\n      their backplane plugs.  If such a pin is damaged, cards read bad\n      numbers and compute bad (possibly conflicting) IP addresses.\n      In this case, the CLI can be used to set the base address such that the\n      resulting address is still correct.')
javaRuntimeVersion = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: javaRuntimeVersion.setStatus('current')
if mibBuilder.loadTexts: javaRuntimeVersion.setDescription('Version of the installed Java Runtime.')
javaVMName = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: javaVMName.setStatus('current')
if mibBuilder.loadTexts: javaVMName.setDescription('Name of the installed Java virtual machine.')
javaVMVersion = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: javaVMVersion.setStatus('current')
if mibBuilder.loadTexts: javaVMVersion.setDescription('Version of the installed Java virtual machine on the work-station.')
mgmtIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtIPAddress.setStatus('current')
if mibBuilder.loadTexts: mgmtIPAddress.setDescription('The IP Address of the PEGASUS system through which the PEM Server is \n      accessible.')
osArchitecture = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osArchitecture.setStatus('current')
if mibBuilder.loadTexts: osArchitecture.setDescription('Displays information about the operating system where the PEM server\n      is running.')
osNameAndVersion = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: osNameAndVersion.setStatus('current')
if mibBuilder.loadTexts: osNameAndVersion.setDescription('Name and version of the operating system that is running on the\n      workstation where the PEM server is running.')
pemVersion = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pemVersion.setStatus('current')
if mibBuilder.loadTexts: pemVersion.setDescription('The version of the PEM Software that is installed on the PEGASUS system.')
startedBy = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: startedBy.setStatus('current')
if mibBuilder.loadTexts: startedBy.setDescription('The username of the person that started the PEM server.')
systemNumber = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemNumber.setStatus('current')
if mibBuilder.loadTexts: systemNumber.setDescription('A number between 0 and 31 which uniquely identifies a PEGASUS system \n      within a subnet. The system number is identified by the HW.')
mibRevision = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 16), DisplayString().clone('$Workfile: PEGASUS.mib $ $Revision: 48 $ $Date: 12/17/04 1:16p $')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mibRevision.setStatus('current')
if mibBuilder.loadTexts: mibRevision.setDescription('The version number assigned by the version control system. You can query\n      this from the agent, to find out with which version of the MIB was built\n      into the agent. The value is also present in copies of the MIB to feed\n      into SNMP managers. Comparing the version numbers from both sources can\n      help to detect mismatches. The revision string for this version is:\n      $Workfile: PEGASUS.mib $ $Revision: 48 $ $Date: 12/17/04 1:16p $')
readCommunity = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readCommunity.setStatus('current')
if mibBuilder.loadTexts: readCommunity.setDescription('SNMP operations with this community name are given read access to all\n      variables in the MIB.')
writeCommunity = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: writeCommunity.setStatus('current')
if mibBuilder.loadTexts: writeCommunity.setDescription('SNMP operations with this community name are given read access to all\n      variables in the MIB, and write access to all writable variables in the\n      MIB. Note that you can write this value provided you know the old value.\n      For requests with a protocol offering no privacy, this variable always\n      reads as three stars (***).\n      Setting this to the empty string effectively turns off all SNMP write\n      access.')
trapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapCommunity.setStatus('current')
if mibBuilder.loadTexts: trapCommunity.setDescription('This community name is used for SNMPv1 or SNMPv2c traps sent by the\n      Pegasus system.')
trapDestination = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestination.setStatus('current')
if mibBuilder.loadTexts: trapDestination.setDescription('IP number of the system to receive traps from the Pegasus system. If this\n      variable is set to the empty string, the Pegasus system sends no traps.')
agentPort = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: agentPort.setStatus('current')
if mibBuilder.loadTexts: agentPort.setDescription('UDP port number of the SNMP agent on the Pegasus system. The initial\n      value is the standard SNMP port number for SNMP, 161. If this variable\n      is set to a non-zero value different from the old value, the agent is\n      immediately restarted with the new port number. If the value is set to\n      zero, the agent is turned off.')
authRespEnabled = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: authRespEnabled.setStatus('obsolete')
if mibBuilder.loadTexts: authRespEnabled.setDescription('If authentication/authorization fails for an SNMP request, the agent\n      normally replies with an SNMP standard error message. If this variable is\n      set to false(2), the agent sends no error message. The initial value is\n      true(1).')
rackAlarmStatus = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 4, 23), RackAlarmStatusElem()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rackAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: rackAlarmStatus.setDescription('Shows the alarms currently set for the Pegasus rack.')
class PerfControlStatus(TextualConvention, Bits):
    description = 'status of a performance control entry'
    status = 'current'
    namedValues = NamedValues(("busy", 0), ("offline", 1), ("data", 2), ("marked", 3))

perfSweepCyclePeriod = MibScalar((1, 3, 6, 1, 4, 1, 6368, 2, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 604800)).clone(300)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfSweepCyclePeriod.setStatus('current')
if mibBuilder.loadTexts: perfSweepCyclePeriod.setDescription('Time in seconds between attempts to clear unused performance history\n      data. Performance history can take a lot of memory. If the manager fails\n      to delete entries in the perfControlTable, the memory will never be\n      recovered. To avoid this, the agent periodically removes entries which\n      have not been used recently. This is done through a mark-and-sweep\n      method, as follows:\n      - each perfControEntry has a mark\n      - reading perfDataEntries sets the mark on associated perfControlEntry\n      - the sweeper sweeps all perfControlEntries periodically. If an entry is\n        not marked, it is deleted. If an entry is marked, it is unmarked, and\n        will be deleted in the next sweep, if not used (marked) before.\n      This value is volatile')
perfControlTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2), )
if mibBuilder.loadTexts: perfControlTable.setStatus('current')
if mibBuilder.loadTexts: perfControlTable.setDescription("The table is used to control the gathering of G.826 statistics. This \n      is currently possible for DSL interfaces and V5 links. If it's desired \n      to get statstic samples, a row within this table must be created. Then \n      link between subject and this entry must be established using the \n      variables dslInterface- and v5LinkPerfControlIndexOrZero. Afterwards \n      the perfDataTable is filled and can be read.")
perfControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1), ).setIndexNames((0, "PEGASUS-MIB", "perfControlIndex"))
if mibBuilder.loadTexts: perfControlEntry.setStatus('current')
if mibBuilder.loadTexts: perfControlEntry.setDescription('Definition of a row within the perfControlTable. Such a row contains \n      information about the monitored subject (currently DSL interfaces and \n      V5 links) and the status of the monitoring.')
perfControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: perfControlIndex.setStatus('current')
if mibBuilder.loadTexts: perfControlIndex.setDescription('index of perfControlEntries')
perfControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 2), PerfControlStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfControlStatus.setStatus('current')
if mibBuilder.loadTexts: perfControlStatus.setDescription('This is a set of bits giving information on the status of this entry of\n      the perfControlTable. The meaning of the individual bits is as follows:\n\n      bit   name          Description\n\n       0    busy          This bit is one if there is a DSL interface or\n                          V5 link referencing this perfControlEntry through\n                          a dslInterfacePerfControlIndexOrZero or a\n                          v5LinkPerfControlIndexOrZero value.\n                          This indicates that this perfControlEntry is busy, and\n                          its perfControlIndex value cannot be used in another\n                          DSL interface or V5 link.\n                          If the ...PerfControlIndexOrZero of the referencing\n                          interface or link is set to zero, this bit is also\n                          set to zero to show that this perfControlEntry is no\n                          longer busy - it can be used in another interface\n                          or link.\n\n       1    offline       Device is offline, data may be absent or out of date.\n                          This bit is 0 if the last attempt to get performance\n                          history data from the device succeeded. In this case,\n                          the data bit (see below) is also 1. This bit (offline)\n                          is 1 if the last attempt to get performance history\n                          data failed. In this case, if no data have been \n                          received from the device, the data bit is 0, and no\n                          perfDataEntries are associated with this\n                          perfControlEntry. If some data was received from the\n                          device before the device went offline, the data bit\n                          may be 1, but the data may be out of date.\n\n       2    data          Data is present. If this perfControlEntry is active,\n                          busy, and the device is not offline, this bit is to 1,\n                          which indicates that the perfDataEntries associated\n                          with this perfControlEntry are present and can be read\n                          from the perfDataTable.\n\n       3    marked        This perfControlEntry has been used recently. The\n                          sweeper periodically sweeps all perfControlEntries,\n                          deleting entries with 0 in this bit. For entries with\n                          1 in this bit, the bit is set to 0. Reading\n                          perfDataEntries sets the marked bit of the associated\n                          perfControlEntries to 1.')
perfControlLinkDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfControlLinkDescr.setStatus('current')
if mibBuilder.loadTexts: perfControlLinkDescr.setDescription('Description of the interface or link using this perfControlEntry.\n      If the perfControlEntry is busy, the value is a textual description of\n      the object referencing this entry through its ...PerfControlIndexOrZero\n      instance. Example:\n       dslInterface 8.1.ltu   (DSL interface on card in slot 8, link 1, on ltu)\n       v5Link 3.8             (V5 link 8 on V5 card in slot 3)\n      If the perfControlEntry is not busy, the value is the empty string (length\n      zero).\n      This object helps to find the interface or link using this entry.')
perfControlUpdatePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 180))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: perfControlUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: perfControlUpdatePeriod.setDescription('Time interval in seconds to wait between querying the performance history\n       data from the device. Minimum value is 1 second. Shorter values yield\n       more accurate/up-to-date figures, at higher communication cost. A value\n       of 0 turns off online reporting.')
perfControlEffectiveUpdatePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 180))).setMaxAccess("readonly")
if mibBuilder.loadTexts: perfControlEffectiveUpdatePeriod.setStatus('obsolete')
if mibBuilder.loadTexts: perfControlEffectiveUpdatePeriod.setDescription('If several clients monitor the same V5 link or DSL interface, each sets\n      its own update period. The server then computes the greatest common\n      divisor of all values. For example, if a PEM client wants to have an\n      update every 15 seconds, and the SNMP agent wants an update every 21\n      seconds, the server will produce updates every 3 seconds (15=3*5,\n      21=3*7). The subsequence of every fifth update than has a period of 15\n      seconds, and the subsequence of every seventh has a period of 21 seconds.')
perfControlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: perfControlRowStatus.setStatus('current')
if mibBuilder.loadTexts: perfControlRowStatus.setDescription('Attribute to create and delete rows dynamically.')
class PerfHistoryType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("history15m", 1), ("history24h", 2))

perfDataTable = MibTable((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3), )
if mibBuilder.loadTexts: perfDataTable.setStatus('current')
if mibBuilder.loadTexts: perfDataTable.setDescription('G.826 statistics table for DSL interfaces and V5 links. Each entry is \n      associated to exactly one perfControlEntry that represents the link \n      between the DSL interface or V5 link and the data entry.')
perfDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1), ).setIndexNames((0, "PEGASUS-MIB", "perfControlIndex"), (0, "PEGASUS-MIB", "perfDataKind"), (0, "PEGASUS-MIB", "perfDataIndex"))
if mibBuilder.loadTexts: perfDataEntry.setStatus('current')
if mibBuilder.loadTexts: perfDataEntry.setDescription('Each perfDataEntry is associated with exactly one perfControlEntry\n      row through the perfControlIndex instance which is part of the index.')
perfDataKind = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 1), PerfHistoryType())
if mibBuilder.loadTexts: perfDataKind.setStatus('current')
if mibBuilder.loadTexts: perfDataKind.setDescription("The second position in the index, shows the type of history - either\n      'history15m' (15 minute history) or 'history24h' (24 hour history).")
perfDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: perfDataIndex.setStatus('current')
if mibBuilder.loadTexts: perfDataIndex.setDescription('Register number. Each register has 5 values (ES/SES/UAS/CV/LOSWS). The\n      15 minute history has 32 history registers, indexed from 1 to 32. Each\n      accumulates its measures over 15 minutes. The register with index 1 is the\n      oldest register (numerical equals chronological order). The 15 minute\n      history has an additional entry (index 33) for the current register (which\n      is only updated when perfControlUpdatePeriod of the associated\n      perfControlEntry is not zero).\n      The 24 hour history has 7 true history registers, indexed 1 to 7. These\n      accumulate there measures over 24 hours. Again, the register with index 1\n      is the oldest, and again, there is a current register with index 8. This\n      current register is updated every 15 minutes, no matter what the value of\n      perfControlUpdatePeriod of the associated perfControlEntry is.')
perfDataES = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 3), Integer32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: perfDataES.setReference("ETSI TS 101 524 'Symmetrical single pair high bitrate Digital Subscriber\n      Line (SDSL)'. Clause 10.3, 'SDSL Line Related Performance Parameters'.")
if mibBuilder.loadTexts: perfDataES.setStatus('current')
if mibBuilder.loadTexts: perfDataES.setDescription('Number of errored seconds. An errored second is one with at least one\n      CRC anomaly (see perfDataCV below) and/or at least one LOSW defect (see\n      perfDataLOSWS below). In the 15 minute history, this register ranges from\n      0 to 900. In the 24 hour history, it ranges from 0 to 86400 (=24*3600)\n      seconds).\n      This register is inhibited, that is not counted while UAS is counting.\n      Due to variations in the communication delay, sampling periods can\n      slightly deviate from their ideal length of 15 minutes or 24 hours. This\n      can cause the register to show values somewhat above 900 (86400 resp.)\n      seconds.')
perfDataSES = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 4), Integer32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: perfDataSES.setReference("ETSI TS 101 524 'Symmetrical single pair high bitrate Digital Subscriber\n      Line (SDSL)'. Clause 10.3, 'SDSL Line Related Performance Parameters'.")
if mibBuilder.loadTexts: perfDataSES.setStatus('current')
if mibBuilder.loadTexts: perfDataSES.setDescription('Number of severely errored seconds. A severely errored second is one with\n      50 or more CRC anomalies (see perfDataCV below) or at least one LOSW\n      defect (see perfDataLOSWS below). In the 15 minute history, this register\n      ranges from -9 to about 450. In the 24 hour history, it ranges from -9 to\n      about 43200. (These limits may seem strange, but are a result of the UAS\n      derivation and SES inhibition rules of the ETSI standard.\n      This register is inhibited, that is not counted while UAS is counting.\n      Deviations in the sampling period length can cause this register to\n      deviate from its true value (see perfDataES).')
perfDataUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 5), Integer32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: perfDataUAS.setReference("ETSI TS 101 524 'Symmetrical single pair high bitrate Digital Subscriber\n      Line (SDSL)'. Clause 10.3, 'SDSL Line Related Performance Parameters'.")
if mibBuilder.loadTexts: perfDataUAS.setStatus('current')
if mibBuilder.loadTexts: perfDataUAS.setDescription('Number of unavailable seconds. Seconds from the beginning of 10 or more\n      SES (perfDataSES) to the beginning of 10 or more non-SES are considered\n      as unavailable. In the 15 minute history, this register ranges from -9 to\n      900. In the 24 hour history, it ranges from -9 to 86400 (24*3600).\n      Deviations in the sampling period length can cause this register to\n      deviate from the true value (see perfDataES).')
perfDataCV = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 6), Integer32()).setUnits('Frames with CRC faults').setMaxAccess("readonly")
if mibBuilder.loadTexts: perfDataCV.setReference("ETSI TS 101 524 'Symmetrical single pair high bitrate Digital Subscriber\n      Line (SDSL)'. Clause 10.3, 'SDSL Line Related Performance Parameters'.")
if mibBuilder.loadTexts: perfDataCV.setStatus('current')
if mibBuilder.loadTexts: perfDataCV.setDescription('Number of error checking code faults (the usual error checking code is\n      CRC). DSL links are structured as 166 2/3 frames per second, each with a\n      CRC value.\n      This register is subject to inhibition, that is it counts at most 50 CRC\n      faults per second.')
perfDataLOSWS = MibTableColumn((1, 3, 6, 1, 4, 1, 6368, 2, 7, 3, 1, 7), Integer32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: perfDataLOSWS.setReference("ETSI TS 101 524 'Symmetrical single pair high bitrate Digital Subscriber\n      Line (SDSL)'. Clause 10.3, 'SDSL Line Related Performance Parameters'.")
if mibBuilder.loadTexts: perfDataLOSWS.setStatus('current')
if mibBuilder.loadTexts: perfDataLOSWS.setDescription('Number of seconds with one or more LOSW defects (loss of frame\n      synchronization word).')
mibBuilder.exportSymbols("PEGASUS-MIB", iadSerialNumber=iadSerialNumber, dslCardAvailabilityStatus=dslCardAvailabilityStatus, iadEthPortSpeed=iadEthPortSpeed, V5LinkAlarmStatusElem=V5LinkAlarmStatusElem, pegasusSystem=pegasusSystem, dslCardM16FirmwareVersion=dslCardM16FirmwareVersion, dslLinkDynamicSlotAllocation=dslLinkDynamicSlotAllocation, dslLinkNumberOfZBits=dslLinkNumberOfZBits, V5SlotNumber=V5SlotNumber, V5PccCount=V5PccCount, v5InterfaceAvailabilityStatus=v5InterfaceAvailabilityStatus, trapDestination=trapDestination, dataCardVLANMode=dataCardVLANMode, dslCardTable=dslCardTable, dslLinkDataRate=dslLinkDataRate, V5IsdnPortBlockingStatusEnum=V5IsdnPortBlockingStatusEnum, dataPortAvailabilityStatus=dataPortAvailabilityStatus, v5CardEntry=v5CardEntry, v5IsdnPortV5CardSlotNumber=v5IsdnPortV5CardSlotNumber, hwAdaptionPolicy=hwAdaptionPolicy, V5TimeslotNumber=V5TimeslotNumber, dataPortNumber=dataPortNumber, ConfigPriorityEnum=ConfigPriorityEnum, dslLinkAddress=dslLinkAddress, v5LccId=v5LccId, v5IsdnPortBearer1Timeslot=v5IsdnPortBearer1Timeslot, v5CardClockSource2=v5CardClockSource2, V5IsdnPortLoopEnum=V5IsdnPortLoopEnum, V5EnvelopeFuncAddress=V5EnvelopeFuncAddress, v5CardRowStatus=v5CardRowStatus, dslInterfaceEntry=dslInterfaceEntry, CosClassmap=CosClassmap, CommStateEnum=CommStateEnum, DslLinkPSDMaskEnum=DslLinkPSDMaskEnum, V5ClockModeEnum=V5ClockModeEnum, DslLinkLoopEnum=DslLinkLoopEnum, V5LinkNumberOrZero=V5LinkNumberOrZero, dslLinkActiveLoop=dslLinkActiveLoop, v5LccPccTimeslot=v5LccPccTimeslot, DslPerformanceStatusElem=DslPerformanceStatusElem, autoPersistDelay=autoPersistDelay, iadISDNPowering=iadISDNPowering, v5CardSerialNumber=v5CardSerialNumber, perfDataTable=perfDataTable, V5InterfaceNumber=V5InterfaceNumber, PerfControlStatus=PerfControlStatus, IadPOTSPoweringEnum=IadPOTSPoweringEnum, dataPortFlowControl=dataPortFlowControl, perfControlEntry=perfControlEntry, pegasusMibModule=pegasusMibModule, systemNumber=systemNumber, v5IsdnPortActiveLoop=v5IsdnPortActiveLoop, DataPortFlowControlEnum=DataPortFlowControlEnum, v5InterfaceAlarmStatus=v5InterfaceAlarmStatus, V5LinkNumber=V5LinkNumber, v5IsdnPortBlockingStatus=v5IsdnPortBlockingStatus, v5LinkLineIdentifier=v5LinkLineIdentifier, dslLinkPSDMask=dslLinkPSDMask, v5LinkId=v5LinkId, iadFirmwareVersion=iadFirmwareVersion, RackAlarmStatusElem=RackAlarmStatusElem, v5InterfaceRowStatus=v5InterfaceRowStatus, iadEntry=iadEntry, HWAdaptionPolicyEnum=HWAdaptionPolicyEnum, dslLinkOperState=dslLinkOperState, v5LccEntry=v5LccEntry, perfControlStatus=perfControlStatus, perfDataUAS=perfDataUAS, Priority=Priority, dataCardCommState=dataCardCommState, v5IsdnPortDSignallingCommChan=v5IsdnPortDSignallingCommChan, DataCardSlotNumber=DataCardSlotNumber, perfControlEffectiveUpdatePeriod=perfControlEffectiveUpdatePeriod, javaVMName=javaVMName, V5LccNumberOrZero=V5LccNumberOrZero, DslCardAlarmStatus=DslCardAlarmStatus, v5CardFirmwareVersion=v5CardFirmwareVersion, AdminStateEnum=AdminStateEnum, v5CardIsProvisioning=v5CardIsProvisioning, v5CardManufacturer=v5CardManufacturer, v5IsdnPortBRANumber=v5IsdnPortBRANumber, osNameAndVersion=osNameAndVersion, dataCardTable=dataCardTable, dslLinkCosClassmapEF=dslLinkCosClassmapEF, v5InterfaceNumber=v5InterfaceNumber, autoPersistEnabled=autoPersistEnabled, dslLinkCosClassmapAF1=dslLinkCosClassmapAF1, schmidtelecom=schmidtelecom, dataCardHardwareVersion=dataCardHardwareVersion, dsl=dsl, V5InterfaceNumberOrZero=V5InterfaceNumberOrZero, agentPort=agentPort, v5IsdnPortOperState=v5IsdnPortOperState, v5LinkNumberOfPcc=v5LinkNumberOfPcc, CosClassifierEnum=CosClassifierEnum, dataCardSlotNumber=dataCardSlotNumber, perfDataES=perfDataES, dataPortSpeed=dataPortSpeed, v5LinkType=v5LinkType, v5LccTable=v5LccTable, dataCardFirmwareVersion=dataCardFirmwareVersion, dslInterfaceType=dslInterfaceType, v5CardETSIRelease=v5CardETSIRelease, dslLinkCosClassifier=dslLinkCosClassifier, DataPortSpeedEnum=DataPortSpeedEnum, v5IsdnPortV5InterfaceNumber=v5IsdnPortV5InterfaceNumber, v5LinkAlarmStatus=v5LinkAlarmStatus, v5LccIsProtected=v5LccIsProtected, dslLinkAlarmStatus=dslLinkAlarmStatus, dslCardSlotNumber=dslCardSlotNumber, v5LccOperState=v5LccOperState, dataPortTable=dataPortTable, rackAlarmStatus=rackAlarmStatus, dataCardName=dataCardName, PerfHistoryType=PerfHistoryType, v5CardClockSource1=v5CardClockSource1, iadEthCurrentFlowControl=iadEthCurrentFlowControl, dslInterfacePerformanceStatus=dslInterfacePerformanceStatus, iadManufacturer=iadManufacturer, V5PccNumberOrZero=V5PccNumberOrZero, IadISDNPoweringEnum=IadISDNPoweringEnum, iadAvailabilityStatus=iadAvailabilityStatus, v5CardHardwareVersion=v5CardHardwareVersion, perfDataKind=perfDataKind, ipBaseAddress=ipBaseAddress, v5InterfaceAdminState=v5InterfaceAdminState, startedBy=startedBy, dslLinkAdminState=dslLinkAdminState, V5ClockSourceEnum=V5ClockSourceEnum, dslLinkAvailabilityStatus=dslLinkAvailabilityStatus, v5IsdnPortBearer2Timeslot=v5IsdnPortBearer2Timeslot, v5CardName=v5CardName, v5CardOperState=v5CardOperState, dslLinkCustomerId=dslLinkCustomerId, readCommunity=readCommunity, DslInterfaceTypeEnum=DslInterfaceTypeEnum, dslInterfaceAttenuation=dslInterfaceAttenuation, v5InterfaceOperState=v5InterfaceOperState, OperStateEnum=OperStateEnum, dslLinkLineRate=dslLinkLineRate, dslInterfaceOperState=dslInterfaceOperState, v5LinkAdminState=v5LinkAdminState, v5IsdnPortTable=v5IsdnPortTable, perfDataCV=perfDataCV, v5InterfaceEntry=v5InterfaceEntry, perfControlLinkDescr=perfControlLinkDescr, dataCardEntry=dataCardEntry, dslLinkAssignedTrunk=dslLinkAssignedTrunk, v5InterfaceId=v5InterfaceId, iadTable=iadTable, dslLinkCosRateLimitAF1=dslLinkCosRateLimitAF1, mibRevision=mibRevision, perfControlRowStatus=perfControlRowStatus, v5=v5, v5LccPccV5LinkNumber=v5LccPccV5LinkNumber, v5CardAdminState=v5CardAdminState, dslLinkCosRateLimitEF=dslLinkCosRateLimitEF, dataPortEntry=dataPortEntry, perfSweepCyclePeriod=perfSweepCyclePeriod, dslLinkIsRemotePower=dslLinkIsRemotePower, perfDataEntry=perfDataEntry, dslCardManufacturer=dslCardManufacturer, iadAlarmStatus=iadAlarmStatus, v5CardAvailabilityStatus=v5CardAvailabilityStatus, v5IsdnPortPacketCommChan=v5IsdnPortPacketCommChan, iadHardwareVersion=iadHardwareVersion, iadEthCurrentPortSpeed=iadEthCurrentPortSpeed, v5CardFlags=v5CardFlags, dslInterfacePerfControlIndexOrZero=dslInterfacePerfControlIndexOrZero, perfDataSES=perfDataSES, v5LccNumber=v5LccNumber, perfDataIndex=perfDataIndex, dataPortAdminState=dataPortAdminState, dslLinkCosEntry=dslLinkCosEntry, dslCardHardwareVersion=dslCardHardwareVersion, v5CardE1FrameFormat=v5CardE1FrameFormat, v5CardCommState=v5CardCommState, v5LinkTable=v5LinkTable, v5LinkInterface=v5LinkInterface, v5IsdnPortEntry=v5IsdnPortEntry, dataCardOperState=dataCardOperState, V5ProtocolVersionEnum=V5ProtocolVersionEnum, javaVMVersion=javaVMVersion, DslLinkNumber=DslLinkNumber, dslCardAlarmStatus=dslCardAlarmStatus, dslLinkCosEnabled=dslLinkCosEnabled, dslLinkCosRateLimitAF2=dslLinkCosRateLimitAF2, V5LccNumber=V5LccNumber, configPriority=configPriority, SlotNumber=SlotNumber, v5CardProtocolVersion=v5CardProtocolVersion, iadPOTSPowering=iadPOTSPowering, IadAlarmStatusElem=IadAlarmStatusElem, iadEthFlowControl=iadEthFlowControl, dataCardManufacturer=dataCardManufacturer, dslLinkCosTable=dslLinkCosTable, osArchitecture=osArchitecture, dslLinkTable=dslLinkTable, dslInterfaceTable=dslInterfaceTable, perfControlIndex=perfControlIndex, v5IsdnPortFrameCommChan=v5IsdnPortFrameCommChan, perfDataLOSWS=perfDataLOSWS, v5LccRowStatus=v5LccRowStatus, AvailabilityStatusElem=AvailabilityStatusElem, PYSNMP_MODULE_ID=pegasusMibModule, dslCardCommState=dslCardCommState, dslLinkContact=dslLinkContact, dslLinkCosClassmapAF2=dslLinkCosClassmapAF2, v5LinkEntry=v5LinkEntry, v5InterfaceTable=v5InterfaceTable, v5LinkNumber=v5LinkNumber, v5LinkPerfControlIndexOrZero=v5LinkPerfControlIndexOrZero, V5IsdnPortAlarmStatusElem=V5IsdnPortAlarmStatusElem, dslLinkNotes=dslLinkNotes, dslLinkPriority=dslLinkPriority, iadName=iadName, trapCommunity=trapCommunity, V5CardFlagSet=V5CardFlagSet, DslLinkAlarmElem=DslLinkAlarmElem, dslLinkNumberOfBRA=dslLinkNumberOfBRA, data=data, v5LinkOperState=v5LinkOperState, authRespEnabled=authRespEnabled, perfControlUpdatePeriod=perfControlUpdatePeriod, v5LinkAvailabilityStatus=v5LinkAvailabilityStatus, mgmtIPAddress=mgmtIPAddress, dataCardAvailabilityStatus=dataCardAvailabilityStatus, V5LinkTypeEnum=V5LinkTypeEnum, dataPortOperState=dataPortOperState, perfControlTable=perfControlTable, v5CardClockMode=v5CardClockMode, v5IsdnPortAlarmStatus=v5IsdnPortAlarmStatus, dslLinkEntry=dslLinkEntry, pemVersion=pemVersion, v5IsdnPortAdminState=v5IsdnPortAdminState, dslCardSerialNumber=dslCardSerialNumber, TrunkNumberOrZero=TrunkNumberOrZero, dslCardFirmwareVersion=dslCardFirmwareVersion, dataCardSerialNumber=dataCardSerialNumber, v5InterfaceVariantId=v5InterfaceVariantId, dslCardOperState=dslCardOperState, v5CardE1LineCode=v5CardE1LineCode, TrunkNumber=TrunkNumber, v5CardTable=v5CardTable, v5IsdnPortEnvelopeFuncAddress=v5IsdnPortEnvelopeFuncAddress, dslLinkCosAvailable=dslLinkCosAvailable, perf=perf, dslCardName=dslCardName, dslInterfaceAvailabilityStatus=dslInterfaceAvailabilityStatus, dslLinkName=dslLinkName, iadOperState=iadOperState, v5IsdnPortIsActivated=v5IsdnPortIsActivated, javaRuntimeVersion=javaRuntimeVersion, v5LinkRowStatus=v5LinkRowStatus)
mibBuilder.exportSymbols("PEGASUS-MIB", V5InterfaceAlarmSet=V5InterfaceAlarmSet, writeCommunity=writeCommunity, dslCardEntry=dslCardEntry, dslLinkNumber=dslLinkNumber, v5CardSlotNumber=v5CardSlotNumber, DslSlotNumber=DslSlotNumber, v5IsdnPortLineIdentifier=v5IsdnPortLineIdentifier, dslInterfaceSignalQuality=dslInterfaceSignalQuality)
