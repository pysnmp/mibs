#
# PySNMP MIB module ATM-FORUM-ILMI40-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/atmforum/ATM-FORUM-ILMI40-MIB
# Produced by pysmi-1.1.12 at Mon Sep 16 15:02:24 2024
# On host fv-az1272-448 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Bits, iso, Integer32, TimeTicks, enterprises, NotificationType, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ModuleIdentity, ObjectIdentity, IpAddress, Counter32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Bits", "iso", "Integer32", "TimeTicks", "enterprises", "NotificationType", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ModuleIdentity", "ObjectIdentity", "IpAddress", "Counter32", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class ClnpAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 21)

class AtmServiceCategory(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6))

atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1))
atmfTransmissionTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2))
atmfMediaTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3))
atmfTrafficDescrTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4))
atmfSrvcRegTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 5))
atmForumUni = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2))
atmfPhysicalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 1))
atmfAtmLayerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 2))
atmfAtmStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 3))
atmfVpcGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 4))
atmfVccGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 5))
atmfAddressGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 6))
atmfNetPrefixGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 7))
atmfSrvcRegistryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 8))
atmfVpcAbrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 9))
atmfVccAbrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 10))
atmfAddressRegistrationAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 2, 11))
atmfUnknownType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 1))
atmfSonetSTS3c = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 2))
atmfDs3 = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 3))
atmf4B5B = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 4))
atmf8B10B = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 5))
atmfSonetSTS12c = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 6))
atmfE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 7))
atmfT1 = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 8))
atmfE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 2, 9))
atmfMediaUnknownType = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 1))
atmfMediaCoaxCable = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 2))
atmfMediaSingleMode = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 3))
atmfMediaMultiMode = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 4))
atmfMediaStp = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 5))
atmfMediaUtp = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 3, 6))
atmfNoDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 1))
atmfPeakRate = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 2))
atmfNoClpNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 3))
atmfClpNoTaggingNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 4))
atmfClpTaggingNoScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 5))
atmfNoClpScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 6))
atmfClpNoTaggingScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 7))
atmfClpTaggingScr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 8))
atmfClpNoTaggingMcr = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 4, 9))
atmfPortTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 1, 1), )
if mibBuilder.loadTexts: atmfPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortTable.setDescription("A table of physical layer status and parameter\n                information for the ATM Interface's physical interface.")
atmfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfPortIndex"))
if mibBuilder.loadTexts: atmfPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortEntry.setDescription('An entry in the table, containing information about\n                the physical layer of an ATM Interface.')
atmfPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortIndex.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfPortAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 2), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortAddress.setStatus('obsolete')
if mibBuilder.loadTexts: atmfPortAddress.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 2.0\n                of the UNI specification. The Address Group, defined\n                in theAddress Registration MIB should be used instead.')
atmfPortTransmissionType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortTransmissionType.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortTransmissionType.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification. Appropriate Network Management\n                MIBs should be used instead.')
atmfPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMediaType.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortMediaType.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification. Appropriate Network Management\n                MIBs should be used instead.')
atmfPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("inService", 2), ("outOfService", 3), ("loopBack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortOperStatus.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortOperStatus.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification. Appropriate Network Management\n                MIBs should be used instead.')
atmfPortSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortSpecific.setStatus('deprecated')
if mibBuilder.loadTexts: atmfPortSpecific.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification. Appropriate Network Management\n                MIBs should be used instead.')
atmfPortMyIfName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMyIfName.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMyIfName.setDescription('A textual name of this interface. If this system is\n                manageable through SNMP, and supports the object\n                ifName, the value of this object must be identical\n                with that of ifName for the ifEntry of the lowest\n                level physical interface for this port. This interface\n                must be uniquely named on this system to distinguish\n                parallel links with a neighboring system.  If this\n                interface does not have a textual name, the value of\n                this object is a zero length string.')
atmfPortMyIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfPortMyIfIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmfPortMyIfIdentifier.setDescription('A unique value for each ATM interface. The scheme used to\n                number the ATM interfaces on an ATM device is\n                implementation specific. One way to generate this value is\n                to use the ifIndex that an SNMP manager would use to\n                identify the port. This interface must be uniquely numbered\n                on this system to distinguish parallel links with a\n                neighboring system.')
atmfMyIpNmAddress = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMyIpNmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMyIpNmAddress.setDescription('An IP Address to which a Network Management Station\n                can send Network Management protocol messages, e.g. SNMP\n                messages to UDP port 161, in order to access network\n                management information concerning the operation of the\n                ATM device local to this IME. If this object is supported,\n                but the Network Management Agent has not been configured with\n                an IP Address, the IME should return 0.0.0.0.')
atmfMyOsiNmNsapAddress = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 3), ClnpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMyOsiNmNsapAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMyOsiNmNsapAddress.setDescription('An NSAP Address to which a Network Management Station\n                can send Network Management protocol messages in order\n                to access network management information concerning\n                the operation of the ATM device local to this IME.\n                If this object is supported,\n                but the Network Management Agent has not been configured with\n                an NSAP Address, the IME should return 0.0.0.0')
atmfMySystemIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 353, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfMySystemIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmfMySystemIdentifier.setDescription('A 48 bit identifier, taken from the IEEE universally\n                administered MAC address space, which uniquely\n                identifies the ATM device local to this IME.')
atmfAtmLayerTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 2, 1), )
if mibBuilder.loadTexts: atmfAtmLayerTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerTable.setDescription('A table of ATM layer status and parameter information\n                for the ATM Interface.')
atmfAtmLayerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfAtmLayerIndex"))
if mibBuilder.loadTexts: atmfAtmLayerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerEntry.setDescription('An entry in the table, containing information about\n                the ATM layer of an ATM Interface.')
atmfAtmLayerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerIndex.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfAtmLayerMaxVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVPCs.setDescription('The maximum number of switched and permanent VPCs\n                supported on this ATM Interface. For virtual interfaces\n                (i.e. Virtual Path Connections), the maximum number of VPCs\n                PNNI may communicate over is set to zero.')
atmfAtmLayerMaxVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435456))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVCCs.setDescription('The maximum number of switched and permanent VCCs\n                supported on this ATM Interface.')
atmfAtmLayerConfiguredVPCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVPCs.setDescription('The number of permanent VPCs configured for use on\n                this ATM Interface. For virtual interfaces (i.e. Virtual Path\n                Connections used by PNNI), the maximum number of VPCs\n                is set to zero.')
atmfAtmLayerConfiguredVCCs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435456))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerConfiguredVCCs.setDescription('The number of permanent VCCs configured for use on\n                this ATM Interface.')
atmfAtmLayerMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVpiBits.setDescription('The maximum number of active VPI bits on this ATM Interface.\n                For virtual interfaces (i.e. Virtual Path Connections used by PNNI),\n                this value has no meaning and is set to zero.')
atmfAtmLayerMaxVciBits = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxVciBits.setDescription('The maximum number of active VCI bits on this ATM Interface.')
atmfAtmLayerUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniType.setDescription('The type of the ATM device, either public or private.')
atmfAtmLayerUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("version2point0", 1), ("version3point0", 2), ("version3point1", 3), ("version4point0", 4), ("unsupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerUniVersion.setDescription("An indication of the latest version of the ATM Forum UNI\n                Signalling Specification that is supported on this ATM\n                Interface.  If this value is not present, a version of the UNI\n                earlier than 3.1 is supported.\n\n                If the peer IME's value of this object is the same as,\n                or later than the local IME's value, then the version\n                corresponding to the local IME's value should be\n                attempted.  Otherwise, if the peer IME's value of this\n                object is earlier, and supported locally, then the\n                local IME should attempt the version corresponding to\n                the peer IME's value.  Otherwise, compatibility of the\n                two IMEs cannot be assumed.")
atmfAtmLayerDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("node", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerDeviceType.setDescription('This object determines the type of the ATM device. This\n                object is used in automatic ATM Interface-Type determination\n                procedure such that a correct operational ATM\n                Interface-type can be determined. An ATM End System\n                shall take the value of user(1), and an ATM network\n                node shall take the value of node(2).')
atmfAtmLayerIlmiVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unsupported", 1), ("version4point0", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerIlmiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerIlmiVersion.setDescription("An indication of the latest version of the ATM Forum\n                ILMI Specification that is supported on this ATM Interface.\n\n                If the peer IME's value of this object is the same as,\n                or later than the local IME's value, then the version\n                corresponding to the local IME's value should be\n                attempted.  Otherwise, if the peer IME's value of this\n                object is earlier, and supported locally, then the\n                local IME should attempt the version corresponding to\n                the peer IME's value.  Otherwise, compatibility of the\n                two IMEs cannot be assumed.\n\n                If this object is not present, a version of the ILMI earlier\n                than 4.0 is supported.")
atmfAtmLayerNniSigVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unsupported", 1), ("iisp", 2), ("pnniVersion1point0", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerNniSigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerNniSigVersion.setDescription("An indication of the latest version of the ATM Forum\n                PNNI Signalling Specification that is supported on this\n                ATM Interface. Note that the PNNI routing version is not\n                determined through ILMI.\n\n                If the peer IME's value of this object is the same as,\n                or later than the local IME's value, then the version\n                corresponding to the local IME's value should be\n                attempted.  Otherwise, if the peer IME's value of this\n                object is earlier, and supported locally, then the\n                local IME should attempt the version corresponding to\n                the peer IME's value.  Otherwise, compatibility of the\n                two IMEs cannot be assumed.")
atmfAtmLayerMaxSvpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxSvpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxSvpcVpi.setDescription('The maximum VPI that the signalling stack on the ATM\n                interface is configured to support for allocation to\n                switched virtual path connections.')
atmfAtmLayerMaxSvccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMaxSvccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMaxSvccVpi.setDescription('The maximum VPI that the signalling stack on the ATM\n                interface is configured to support for allocation to\n                switched virtual channel connections.')
atmfAtmLayerMinSvccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmLayerMinSvccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAtmLayerMinSvccVci.setDescription('This is the minimum VCI value that the\n                signalling stack is configured to support for\n                allocation to switched virtual channel connections.  The same\n                value applies to all SVCC VPI values for which the\n                signalling stack is configured.')
atmfAtmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 3, 1), )
if mibBuilder.loadTexts: atmfAtmStatsTable.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsTable.setDescription('This group is deprecated and should not be implemented\n                 except as required for backward compatibility with version\n                 3.1 of the UNI specification.')
atmfAtmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfAtmStatsIndex"))
if mibBuilder.loadTexts: atmfAtmStatsEntry.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsEntry.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfAtmStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsIndex.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsIndex.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfAtmStatsReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsReceivedCells.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfAtmStatsDroppedReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsDroppedReceivedCells.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfAtmStatsTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setStatus('deprecated')
if mibBuilder.loadTexts: atmfAtmStatsTransmittedCells.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 4, 1), )
if mibBuilder.loadTexts: atmfVpcTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTable.setDescription('A table of status and parameter information on the\n                virtual path connections which cross this ATM\n                Interface. There is one entry in this table for each\n                permanent virtual path connection.')
atmfVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfVpcPortIndex"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVpcVpi"))
if mibBuilder.loadTexts: atmfVpcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcEntry.setDescription('An entry in the table, containing information about a\n                particular virtual path connection.')
atmfVpcPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcPortIndex.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfVpcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcVpi.setDescription('The VPI value of this Virtual Path Connection at the\n                local ATM Interface.')
atmfVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcOperStatus.setDescription('The present actual operational status of the VPC.\n\n                A value of end2endUp(2) or end2endDown(3) would be\n                used if the end-to-end status is known. If only local\n                status information is available, a value of\n                localUpEnd2endUnknown(4) or localDown(5) would be\n                used.')
atmfVpcTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the\n                transmit direction of this VPC. The type may indicate\n                none, or a type with one or more parameters. These\n                parameters are specified as a parameter vector, in the\n                corresponding instances of the objects:\n                        atmfVpcTransmitTrafficDescriptorParam1,\n                        atmfVpcTransmitTrafficDescriptorParam2,\n                        atmfVpcTransmitTrafficDescriptorParam3,\n                        atmfVpcTransmitTrafficDescriptorParam4, and\n                        atmfVpcTransmitTrafficDescriptorParam5.')
atmfVpcTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector\n                for this VPC, used according to the value of\n                atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector\n                for this VPC, used according to the value of\n                atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector\n                for this VPC, used according to the value of\n                atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector\n                for this VPC, used according to the value of\n                atmfVpcTransmitTrafficDescriptorType.')
atmfVpcTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector\n                for this VPC, used according to the value of\n                atmfVpcTransmitTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 10), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the\n                traffic in the receive direction of this VPC. The type\n                may indicate none, or a type with one or more\n                parameters. These parameters are specified as a\n                parameter vector, in the corresponding instances of\n                the objects:\n                        atmfVpcReceiveTrafficDescriptorParam1,\n                        atmfVpcReceiveTrafficDescriptorParam2,\n                        atmfVpcReceiveTrafficDescriptorParam3,\n                        atmfVpcReceiveTrafficDescriptorParam4, and\n                        atmfVpcReceiveTrafficDescriptorParam5.')
atmfVpcReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector\n                for this VPC, used according to the value of\n                atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector\n                for this VPC, used according to the value of\n                atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector\n                for this VPC, used according to the value of\n                atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector\n                for this VPC, used according to the value of\n                atmfVpcReceiveTrafficDescriptorType.')
atmfVpcReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector\n                for this VPC, used according to the value of\n                atmfVpcReceiveTrafficDescriptorType.')
atmfVpcQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcQoSCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmfVpcQoSCategory.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 2.0\n                of the UNI specification.')
atmfVpcTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVpcTransmitQoSClass.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfVpcReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVpcReceiveQoSClass.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfVpcBestEffortIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcBestEffortIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcBestEffortIndicator.setDescription('The object is examined when\n                atmfVpcTransmitTrafficDescriptorType or\n                atmfVpcReceiveTrafficDescriptorType for the associated\n                connection is equal to atmfNoClpNoScr.\n                If this object is set to false(2), the network is requested\n                to apply the CBR.1 conformance definition. If this object\n                is set to true(1), the network is requested to apply the\n                UBR.1 conformance definition.')
atmfVpcServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 4, 1, 1, 20), AtmServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcServiceCategory.setDescription('The service category of this virtual path connection.')
atmfVpcAbrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 9, 1), )
if mibBuilder.loadTexts: atmfVpcAbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTable.setDescription('A table of operational parameters related to the ABR\n                virtual path connections which cross this ATM\n                Interface. There is one entry in this table for each\n                ABR virtual path connection.\n\n                Each virtual path connection represented\n                in this table must also be represented by\n                an entry in the atmfVpcTable.')
atmfVpcAbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfVpcAbrPortIndex"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVpcAbrVpi"))
if mibBuilder.loadTexts: atmfVpcAbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrEntry.setDescription('An entry in the table, containing information about a \n                particular ABR virtual path connection.')
atmfVpcAbrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrPortIndex.setDescription('The value of 0 which has the special meaning of identifying \n                the ATM Interface over which this message was received.')
atmfVpcAbrVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrVpi.setDescription('The VPI value of this ABR Virtual Path Connection at the \n                local ATM Interface.')
atmfVpcAbrTransmitIcr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitIcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitIcr.setDescription('Initial Cell Rate: This is the rate at which the\n                source starts, both initially and after an idle period.\n                The unit is cells per second.  The value must not be\n                larger than PCR, and is usually lower.')
atmfVpcAbrTransmitNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("nrm2", 1), ("nrm4", 2), ("nrm8", 3), ("nrm16", 4), ("nrm32", 5), ("nrm64", 6), ("nrm128", 7), ("nrm256", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitNrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitNrm.setDescription('The maximum number of data cells a source may send\n                for each forward RM-cell.  The default value is nrm32(5).')
atmfVpcAbrTransmitTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("trm0point78125", 1), ("trm1point5625", 2), ("trm3point125", 3), ("trm6point25", 4), ("trm12point5", 5), ("trm25", 6), ("trm50", 7), ("trm100", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitTrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitTrm.setDescription('Upper bound on the time between forward RM-cells for\n                an active source (in milliseconds). The default value\n                is trm100(8).')
atmfVpcAbrTransmitCdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cdf0", 1), ("cdfOneOver64", 2), ("cdfOneOver32", 3), ("cdfOneOver16", 4), ("cdfOneOver8", 5), ("cdfOneOver4", 6), ("cdfOneOver2", 7), ("cdfOne", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitCdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitCdf.setDescription('Cutoff Decrease Factor: This field controls the rate\n                decrease associated with lost or delayed backward RM\n                cells.  Larger values result in faster rate decrease.\n                The default value is cdfOneOver16(4).')
atmfVpcAbrTransmitRif = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rifOneOver32768", 1), ("rifOneOver16384", 2), ("rifOneOver8192", 3), ("rifOneOver4096", 4), ("rifOneOver2048", 5), ("rifOneOver1024", 6), ("rifOneOver512", 7), ("rifOneOver256", 8), ("rifOneOver128", 9), ("rifOneOver64", 10), ("rifOneOver32", 11), ("rifOneOver16", 12), ("rifOneOver8", 13), ("rifOneOver4", 14), ("rifOneOver2", 15), ("rifOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitRif.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitRif.setDescription('Rate Increment Factor: Controls the rate at which the rate\n                increases, when a backward RM-cell is received with CI=0 and\n                NI=0.  Larger values lead to faster rate increase.  The default\n                value is rifOneOver16(12).')
atmfVpcAbrTransmitRdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rdfOneOver32768", 1), ("rdfOneOver16384", 2), ("rdfOneOver8192", 3), ("rdfOneOver4096", 4), ("rdfOneOver2048", 5), ("rdfOneOver1024", 6), ("rdfOneOver512", 7), ("rdfOneOver256", 8), ("rdfOneOver128", 9), ("rdfOneOver64", 10), ("rdfOneOver32", 11), ("rdfOneOver16", 12), ("rdfOneOver8", 13), ("rdfOneOver4", 14), ("rdfOneOver2", 15), ("rdfOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitRdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitRdf.setDescription('Rate Decrease Factor: Controls the rate decrease\n                which occurs when backward RM-cells with CI=1, are\n                received.  Larger values lead to faster rate\n                decrease.  The default value is rdfOneOver16(12).')
atmfVpcAbrTransmitAdtf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitAdtf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitAdtf.setDescription('ACR Decrease Time Factor: Time permitted between\n                sending RM-cells, before the allowed rate (ACR) is\n                decreased to ICR.  Range is 10 ms to 10.23 seconds.\n                The unit is 10 milliseconds.  For example, the default\n                value of 50 corresponds to a time factor of 500 ms.\n                Larger values allow a source to retain its current\n                rate longer, during periods of relative inactivity.\n                The default is 50 (0.5 seconds).')
atmfVpcAbrTransmitCrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVpcAbrTransmitCrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVpcAbrTransmitCrm.setDescription('RM Cells Before Cutoff: Limits the number of forward\n                RM-cells which may be sent in the absence of received\n                backward RM-cells.')
atmfVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 5, 1), )
if mibBuilder.loadTexts: atmfVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTable.setDescription('A table of status and parameter information on the\n                virtual channel connections which are visible at this\n                ATM Interface. There is one entry in this table for\n                each permanent virtual channel connection, including\n                reserved VCCs that are supported; e.g., signalling,\n                OAM flows, and ILMI, but not unassigned cells.')
atmfVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfVccPortIndex"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVccVpi"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVccVci"))
if mibBuilder.loadTexts: atmfVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccEntry.setDescription('An entry in the table, containing information about a\n                particular virtual channel connection.')
atmfVccPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccPortIndex.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfVccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVpi.setDescription('The VPI value of this Virtual Channel Connection at\n                the local ATM Interface. For virtual interfaces (i.e.\n                Virtual Path Connections), this value has no meaning\n                and is set to zero ')
atmfVccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccVci.setDescription('The VCI value of this Virtual Channel Connection at\n                the local ATM Interface.')
atmfVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("end2endUp", 2), ("end2endDown", 3), ("localUpEnd2endUnknown", 4), ("localDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccOperStatus.setDescription('The present actual operational status of the VCC. A\n                value of end2endUp(2) or end2endUp(3) is used if the\n                end to end status is known.\n\n                If only local status is known a value of\n                localUpEnd2endUnknown(4) or localDown(5) is used.')
atmfVccTransmitTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorType.setDescription('The type of traffic management, applicable to the\n                transmit direction of this VCC. The type may indicate\n                none, or a type with one or more parameters. These\n                parameters are specified as a parameter vector, in the\n                corresponding instances of the objects:\n                        atmfVccTransmitTrafficDescriptorParam1,\n                        atmfVccTransmitTrafficDescriptorParam2,\n                        atmfVccTransmitTrafficDescriptorParam3,\n                        atmfVccTransmitTrafficDescriptorParam4, and\n                        atmfVccTransmitTrafficDescriptorParam5.')
atmfVccTransmitTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam1.setDescription('The first parameter of the transmit parameter vector\n                for this VCC, used according to the value of\n                atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam2.setDescription('The second parameter of the transmit parameter vector\n                for this VCC, used according to the value of\n                atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam3.setDescription('The third parameter of the transmit parameter vector\n                for this VCC, used according to the value of\n                atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam4.setDescription('The fourth parameter of the transmit parameter vector\n                for this VCC, used according to the value of\n                atmfVccTransmitTrafficDescriptorType.')
atmfVccTransmitTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitTrafficDescriptorParam5.setDescription('The fifth parameter of the transmit parameter vector\n                for this VCC, used according to the value of\n                atmfVccTransmitTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 11), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorType.setDescription('The type of traffic management, applicable to the\n                traffic in the receive direction of this VCC. The type\n                may indicate none, or a type with one or more\n                parameters. These parameters are specified as a\n                parameter vector, in the corresponding instances of\n                the objects:\n                        atmfVccReceiveTrafficDescriptorParam1,\n                        atmfVccReceiveTrafficDescriptorParam2,\n                        atmfVccReceiveTrafficDescriptorParam3,\n                        atmfVccReceiveTrafficDescriptorParam4, and\n                        atmfVccReceiveTrafficDescriptorParam5.')
atmfVccReceiveTrafficDescriptorParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam1.setDescription('The first parameter of the receive parameter vector\n                for this VCC, used according to the value of\n                atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam2.setDescription('The second parameter of the receive parameter vector\n                for this VCC, used according to the value of\n                atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam3.setDescription('The third parameter of the receive parameter vector\n                for this VCC, used according to the value of\n                atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam4.setDescription('The fourth parameter of the receive parameter vector\n                for this VCC, used according to the value of\n                atmfVccReceiveTrafficDescriptorType.')
atmfVccReceiveTrafficDescriptorParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveTrafficDescriptorParam5.setDescription('The fifth parameter of the receive parameter vector\n                for this VCC, used according to the value of\n                atmfVccReceiveTrafficDescriptorType.')
atmfVccQoSCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("deterministic", 2), ("statistical", 3), ("unspecified", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccQoSCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmfVccQoSCategory.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 2.0\n                of the UNI specification.')
atmfVccTransmitQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVccTransmitQoSClass.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfVccReceiveQoSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setStatus('deprecated')
if mibBuilder.loadTexts: atmfVccReceiveQoSClass.setDescription('This object should not be implemented except as\n                required for backward compatibility with version 3.1\n                of the UNI specification.')
atmfVccBestEffortIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccBestEffortIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccBestEffortIndicator.setDescription('The object is examined when\n                atmfVccTransmitTrafficDescriptorType or\n                atmfVccReceiveTrafficDescriptorType for the associated\n                connection is equal to atmfNoClpNoScr.\n                If this object is set to false(2), the network is requested\n                to apply the CBR.1 conformance definition. If this object\n                is set to true(1), the network is requested to apply the\n                UBR.1 conformance definition.')
atmfVccTransmitFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 21), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccTransmitFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccTransmitFrameDiscard.setDescription("If set to true(1), this object indicates that the network\n                is requested to treat data for this connection (in the\n                transmit direction) as frames (e.g. AAL5 CPCS_PDU's) rather\n                than as individual cells.  While the precise\n                implementation is network-specific, this treatment may\n                for example involve discarding entire frames during\n                congestion, rather than a few cells from many frames.\n                The default value is false(2).")
atmfVccReceiveFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 22), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccReceiveFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccReceiveFrameDiscard.setDescription("If set to true(1), this object indicates that the network\n                is requested to treat data for this connection (in the\n                receive direction) as frames (e.g. AAL5 CPCS_PDU's) rather\n                than as individual cells.  While the precise\n                implementation is network-specific, this treatment may\n                for example involve discarding entire frames during\n                congestion, rather than a few cells from many frames.\n                The default value is false(2).")
atmfVccServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 5, 1, 1, 23), AtmServiceCategory()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccServiceCategory.setDescription('The service category of this virtual channel connection.')
atmfVccAbrTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 10, 1), )
if mibBuilder.loadTexts: atmfVccAbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTable.setDescription('A table of operational parameters related to the ABR\n                virtual channel connections which cross this ATM\n                Interface. There is one entry in this table for each\n                ABR virtual channel connection.\n\n                Each virtual channel connection represented\n                in this table must also be represented by\n                an entry in the atmfVccTable.')
atmfVccAbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfVccAbrPortIndex"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVccAbrVpi"), (0, "ATM-FORUM-ILMI40-MIB", "atmfVccAbrVci"))
if mibBuilder.loadTexts: atmfVccAbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrEntry.setDescription('An entry in the table, containing information about a \n                particular ABR virtual channel connection.')
atmfVccAbrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrPortIndex.setDescription('The value of 0 which has the special meaning of identifying \n                the ATM Interface over which this message was received.')
atmfVccAbrVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrVpi.setDescription('The VPI value of this ABR Virtual Channel Connection at the \n                local ATM Interface. For virtual interfaces (i.e. Virtual Path\n                Connections), this value has no meaning and is set to zero ')
atmfVccAbrVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrVci.setDescription('The VCI value of this ABR Virtual Channel Connection at the \n                local ATM Interface.')
atmfVccAbrTransmitIcr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitIcr.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitIcr.setDescription('Initial Cell Rate: This is the rate at which the\n                source starts, both initially and after an idle period.\n                The unit is cells per second.  The value must not be\n                larger than PCR, and is usually lower.')
atmfVccAbrTransmitNrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("nrm2", 1), ("nrm4", 2), ("nrm8", 3), ("nrm16", 4), ("nrm32", 5), ("nrm64", 6), ("nrm128", 7), ("nrm256", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitNrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitNrm.setDescription('The maximum number of data cells a source may send\n                for each forward RM-cell.  The default value is nrm32(5).')
atmfVccAbrTransmitTrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("trm0point78125", 1), ("trm1point5625", 2), ("trm3point125", 3), ("trm6point25", 4), ("trm12point5", 5), ("trm25", 6), ("trm50", 7), ("trm100", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitTrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitTrm.setDescription('Upper bound on the time between forward RM-cells for\n                an active source (in milliseconds). The default value\n                is trm100(8).')
atmfVccAbrTransmitCdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("cdf0", 1), ("cdfOneOver64", 2), ("cdfOneOver32", 3), ("cdfOneOver16", 4), ("cdfOneOver8", 5), ("cdfOneOver4", 6), ("cdfOneOver2", 7), ("cdfOne", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitCdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitCdf.setDescription('Cutoff Decrease Factor: This field controls the rate\n                decrease associated with lost or delayed backward RM\n                cells.  Larger values result in faster rate decrease.\n                The default value is cdfOneOver16(4).')
atmfVccAbrTransmitRif = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rifOneOver32768", 1), ("rifOneOver16384", 2), ("rifOneOver8192", 3), ("rifOneOver4096", 4), ("rifOneOver2048", 5), ("rifOneOver1024", 6), ("rifOneOver512", 7), ("rifOneOver256", 8), ("rifOneOver128", 9), ("rifOneOver64", 10), ("rifOneOver32", 11), ("rifOneOver16", 12), ("rifOneOver8", 13), ("rifOneOver4", 14), ("rifOneOver2", 15), ("rifOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitRif.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitRif.setDescription('Rate Increment Factor: Controls the rate at which the rate\n                increases, when a backward RM-cell is received with CI=0 and\n                NI=0.  Larger values lead to faster rate increase.  The default\n                value is rifOneOver16(12).')
atmfVccAbrTransmitRdf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("rdfOneOver32768", 1), ("rdfOneOver16384", 2), ("rdfOneOver8192", 3), ("rdfOneOver4096", 4), ("rdfOneOver2048", 5), ("rdfOneOver1024", 6), ("rdfOneOver512", 7), ("rdfOneOver256", 8), ("rdfOneOver128", 9), ("rdfOneOver64", 10), ("rdfOneOver32", 11), ("rdfOneOver16", 12), ("rdfOneOver8", 13), ("rdfOneOver4", 14), ("rdfOneOver2", 15), ("rdfOne", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitRdf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitRdf.setDescription('Rate Decrease Factor: Controls the rate decrease\n                which occurs when backward RM-cells with CI=1, are\n                received.  Larger values lead to faster rate\n                decrease.  The default value is rdfOneOver16(12).')
atmfVccAbrTransmitAdtf = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitAdtf.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitAdtf.setDescription('ACR Decrease Time Factor: Time permitted between\n                sending RM-cells, before the allowed rate (ACR) is\n                decreased to ICR.  Range is 10 ms to 10.23 seconds.\n                The unit is 10 milliseconds.  For example, the default\n                value of 50 corresponds to a time factor of 500 ms.\n                Larger values allow a source to retain its current\n                rate longer, during periods of relative inactivity.\n                The default is 50 (0.5 seconds).')
atmfVccAbrTransmitCrm = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8388608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfVccAbrTransmitCrm.setStatus('mandatory')
if mibBuilder.loadTexts: atmfVccAbrTransmitCrm.setDescription('RM Cells Before Cutoff: Limits the number of forward\n                RM-cells which may be sent in the absence of received\n                backward RM-cells.')
atmfVpcChange = NotificationType((1, 3, 6, 1, 4, 1, 353) + (0,1)).setObjects(("ATM-FORUM-ILMI40-MIB", "atmfVpcPortIndex"), ("ATM-FORUM-ILMI40-MIB", "atmfVpcVpi"), ("ATM-FORUM-ILMI40-MIB", "atmfVpcOperStatus"))
if mibBuilder.loadTexts: atmfVpcChange.setDescription('An atmfVpcChange trap indicates that a permanent VPC has been\n                added or deleted at this ATM Interface or that the attributes\n                of an existing VPC have been modified. The variables\n                included in the trap identify the VPI value of the\n                reconfigured VPC at this ATM Interface.')
atmfVccChange = NotificationType((1, 3, 6, 1, 4, 1, 353) + (0,2)).setObjects(("ATM-FORUM-ILMI40-MIB", "atmfVccPortIndex"), ("ATM-FORUM-ILMI40-MIB", "atmfVccVci"), ("ATM-FORUM-ILMI40-MIB", "atmfVccVpi"), ("ATM-FORUM-ILMI40-MIB", "atmfVccOperStatus"))
if mibBuilder.loadTexts: atmfVccChange.setDescription('An atmfVccChange trap indicates that a permanent VCC has been \n                added or deleted at this ATM Interface or that the attributes\n                of an existing VCC have been modified.. The variables\n                included in the trap identify the VCI and VPI values\n                of the reconfigured VCC at this ATM\n                Interface.')
atmfAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 6, 1), )
if mibBuilder.loadTexts: atmfAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressTable.setDescription('A table implemented by the network-side IME, containing the\n                ATM-layer addresses in effect on the user side of the UNI.')
atmfAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfAddressPort"), (0, "ATM-FORUM-ILMI40-MIB", "atmfAddressAtmAddress"))
if mibBuilder.loadTexts: atmfAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressEntry.setDescription('Information about a single ATM-layer address in effect\n                on the user-side IME.  Note that the index variable\n                atmAddressAtmAddress is a variable-length string, and as\n                such the rule for variable-length strings in section\n                 4.1.6 of RFC 1212 applies.')
atmfAddressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: atmfAddressPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressPort.setDescription('A unique value which identifies the UNI port for\n                which the ATM address is in effect.  The value of 0\n                has the special meaning of identifying the local UNI.')
atmfAddressAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 2), AtmAddress())
if mibBuilder.loadTexts: atmfAddressAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressAtmAddress.setDescription('The ATM address which is in effect on the user side\n                of the ATM UNI port.')
atmfAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressStatus.setDescription('An indication of the validity of the ATM address at\n                the user side of the UNI port.  To configure a new\n                address in this table, the user-side IME must set the\n                appropriate instance of this object to the value\n                valid(1).  To delete an existing address in this table,\n                the user-side IME must set the appropriate instance of\n                this object to the value invalid(2).\n\n                If circumstances occur on the network-side IME which cause\n                an address to become invalid, the network-side IME\n                modifies the value of the appropriate instance of this\n                object to invalid(2).\n\n                Whenever the value of this object for a particular\n                address becomes invalid(2), the conceptual row for\n                that address may be removed from the table at any\n                time, either immediately or subsequently.')
atmfAddressOrgScope = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("localNetwork", 1), ("localNetworkPlusOne", 2), ("localNetworkPlusTwo", 3), ("siteMinusOne", 4), ("intraSite", 5), ("sitePlusOne", 6), ("organizationMinusOne", 7), ("intraOrganization", 8), ("organizationPlusOne", 9), ("communityMinusOne", 10), ("intraCommunity", 11), ("communityPlusOne", 12), ("regional", 13), ("interRegional", 14), ("global", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmfAddressOrgScope.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressOrgScope.setDescription("This object indicates the organizational\n                scope for the referenced address. The information of\n                the referenced address shall not be distributed\n                outside the indicated scope. If the user-side IME does\n                not specify a value for the atmfAddressOrgScope object,\n                the network shall set the value of this object to\n                localNetwork(1), if the registered address is an ATM group\n                address, or to global(15), if the registered address is \n                an individual address.  Refer to Annex 6.0\n                of ATM Forum UNI Signalling 4.0 for guidelines regarding\n                the use of organizational scopes.\n\n                This organization hierarchy may be mapped to ATM network's\n                routing hierarchy such as PNNI's routing level and\n                the mapping shall be configurable in\n                nodes. Use of this object in a public network is for\n                further study.\n                The default values for organizational scope are\n                localNetwork(1) for ATM group addresses, and global(15)\n                for individual addresses.")
atmfAddressRegistrationAdminTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 11, 1), )
if mibBuilder.loadTexts: atmfAddressRegistrationAdminTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressRegistrationAdminTable.setDescription('A table of Address Registration administrative\n                information for the ATM Interface.')
atmfAddressRegistrationAdminEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 11, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfAddressRegistrationAdminIndex"))
if mibBuilder.loadTexts: atmfAddressRegistrationAdminEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressRegistrationAdminEntry.setDescription('An entry in the table, containing Address\n                Registration administrative information for the ATM\n                Interface.')
atmfAddressRegistrationAdminIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAddressRegistrationAdminIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressRegistrationAdminIndex.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfAddressRegistrationAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("unsupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfAddressRegistrationAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmfAddressRegistrationAdminStatus.setDescription('An indication of whether or not Address Registration\n                is supported on this ATM Interface. Supported(1)\n                indicates that this ATM Interface supports address\n                registration. Unsupported(2) indicates that this ATM\n                Interface does not support address registration.')
atmfSrvcRegLecs = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 5, 1))
atmfSrvcRegAns = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 1, 5, 2))
atmfSrvcRegTable = MibTable((1, 3, 6, 1, 4, 1, 353, 2, 8, 1), )
if mibBuilder.loadTexts: atmfSrvcRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegTable.setDescription('The table implemented by the IME on the network side of\n                the ATM UNI port contains all of the services that are\n                available to the user-side IME indexed by service\n                identifier.')
atmfSrvcRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1), ).setIndexNames((0, "ATM-FORUM-ILMI40-MIB", "atmfSrvcRegPort"), (0, "ATM-FORUM-ILMI40-MIB", "atmfSrvcRegServiceID"), (0, "ATM-FORUM-ILMI40-MIB", "atmfSrvcRegAddressIndex"))
if mibBuilder.loadTexts: atmfSrvcRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegEntry.setDescription('Information about a single service provider that is \n                available to the user-side IME.')
atmfSrvcRegPort = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: atmfSrvcRegPort.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegPort.setDescription('The value of 0 which has the special meaning of\n                identifying the ATM Interface over which this message\n                was received.')
atmfSrvcRegServiceID = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1, 2), ObjectIdentifier())
if mibBuilder.loadTexts: atmfSrvcRegServiceID.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegServiceID.setDescription('This is the service identifier which uniquely identifies\n                the type of service at the address provided in the table.')
atmfSrvcRegATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1, 3), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfSrvcRegATMAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegATMAddress.setDescription('This is the full address of the service.  The user-side\n                IME may use this address to establish a connection\n                with the service.')
atmfSrvcRegAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: atmfSrvcRegAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegAddressIndex.setDescription('An arbitrary integer to differentiate multiple rows\n                containing different ATM addresses for the same service\n                on the same port.')
atmfSrvcRegParm1 = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 2, 8, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmfSrvcRegParm1.setStatus('mandatory')
if mibBuilder.loadTexts: atmfSrvcRegParm1.setDescription('An octet string whose size and meaning is determined\n                by the value of atmfSrvcRegServiceID.')
mibBuilder.exportSymbols("ATM-FORUM-ILMI40-MIB", atmfPeakRate=atmfPeakRate, atmfVpcTransmitTrafficDescriptorParam1=atmfVpcTransmitTrafficDescriptorParam1, atmfVccAbrTransmitAdtf=atmfVccAbrTransmitAdtf, atmfMediaSingleMode=atmfMediaSingleMode, atmfAtmLayerIndex=atmfAtmLayerIndex, atmfPortMediaType=atmfPortMediaType, atmfVpcAbrTable=atmfVpcAbrTable, atmfAddressRegistrationAdminGroup=atmfAddressRegistrationAdminGroup, atmfAtmStatsTable=atmfAtmStatsTable, atmfVpcAbrTransmitCdf=atmfVpcAbrTransmitCdf, atmfVccAbrTransmitCrm=atmfVccAbrTransmitCrm, atmfAddressRegistrationAdminTable=atmfAddressRegistrationAdminTable, atmfVccGroup=atmfVccGroup, atmfAtmLayerDeviceType=atmfAtmLayerDeviceType, atmfPortMyIfName=atmfPortMyIfName, atmfPortIndex=atmfPortIndex, atmfVccAbrTransmitTrm=atmfVccAbrTransmitTrm, atmfAtmLayerUniVersion=atmfAtmLayerUniVersion, atmfVccReceiveTrafficDescriptorParam3=atmfVccReceiveTrafficDescriptorParam3, atmfSrvcRegEntry=atmfSrvcRegEntry, atmfVccReceiveTrafficDescriptorParam4=atmfVccReceiveTrafficDescriptorParam4, atmf4B5B=atmf4B5B, atmfSrvcRegServiceID=atmfSrvcRegServiceID, atmfClpNoTaggingNoScr=atmfClpNoTaggingNoScr, atmfVccTransmitFrameDiscard=atmfVccTransmitFrameDiscard, atmfSrvcRegTable=atmfSrvcRegTable, atmfMySystemIdentifier=atmfMySystemIdentifier, atmfSrvcRegParm1=atmfSrvcRegParm1, atmfSonetSTS3c=atmfSonetSTS3c, atmfVpcPortIndex=atmfVpcPortIndex, atmfVccAbrTable=atmfVccAbrTable, atmfVccVci=atmfVccVci, atmfPhysicalGroup=atmfPhysicalGroup, atmfPortOperStatus=atmfPortOperStatus, atmfVpcAbrTransmitCrm=atmfVpcAbrTransmitCrm, atmfVccAbrVpi=atmfVccAbrVpi, atmfVpcAbrTransmitAdtf=atmfVpcAbrTransmitAdtf, atmfAtmStatsIndex=atmfAtmStatsIndex, atmfE1=atmfE1, atmfVpcAbrTransmitRdf=atmfVpcAbrTransmitRdf, atmfVpcReceiveTrafficDescriptorType=atmfVpcReceiveTrafficDescriptorType, atmfVccAbrEntry=atmfVccAbrEntry, atmfVpcAbrTransmitTrm=atmfVpcAbrTransmitTrm, atmfNoDescriptor=atmfNoDescriptor, atmfVpcTransmitTrafficDescriptorParam3=atmfVpcTransmitTrafficDescriptorParam3, atmfPortTransmissionType=atmfPortTransmissionType, atmfPortSpecific=atmfPortSpecific, atmfMyOsiNmNsapAddress=atmfMyOsiNmNsapAddress, atmfVpcChange=atmfVpcChange, atmfNoClpScr=atmfNoClpScr, atmfClpNoTaggingMcr=atmfClpNoTaggingMcr, atmfAddressPort=atmfAddressPort, atmfVccAbrTransmitRif=atmfVccAbrTransmitRif, atmfVccQoSCategory=atmfVccQoSCategory, atmfVccPortIndex=atmfVccPortIndex, atmfVpcOperStatus=atmfVpcOperStatus, atmfVccTable=atmfVccTable, atmForum=atmForum, atmfPortMyIfIdentifier=atmfPortMyIfIdentifier, atmfVccTransmitTrafficDescriptorParam1=atmfVccTransmitTrafficDescriptorParam1, atmfAtmLayerMaxVciBits=atmfAtmLayerMaxVciBits, atmfVpcReceiveQoSClass=atmfVpcReceiveQoSClass, atmfVccTransmitTrafficDescriptorParam5=atmfVccTransmitTrafficDescriptorParam5, atmfVccTransmitTrafficDescriptorParam2=atmfVccTransmitTrafficDescriptorParam2, atmfVpcTransmitTrafficDescriptorParam2=atmfVpcTransmitTrafficDescriptorParam2, atmfVpcAbrVpi=atmfVpcAbrVpi, atmfVpcTransmitTrafficDescriptorParam4=atmfVpcTransmitTrafficDescriptorParam4, atmfMediaCoaxCable=atmfMediaCoaxCable, atmfVccServiceCategory=atmfVccServiceCategory, atmfSonetSTS12c=atmfSonetSTS12c, atmfAtmStatsDroppedReceivedCells=atmfAtmStatsDroppedReceivedCells, atmfSrvcRegPort=atmfSrvcRegPort, atmfMediaUtp=atmfMediaUtp, atmfVccReceiveTrafficDescriptorParam1=atmfVccReceiveTrafficDescriptorParam1, atmfAddressStatus=atmfAddressStatus, atmfAtmLayerMaxVPCs=atmfAtmLayerMaxVPCs, TruthValue=TruthValue, atmfPortTable=atmfPortTable, atmfVpcVpi=atmfVpcVpi, atmfVccAbrPortIndex=atmfVccAbrPortIndex, atmfAtmStatsReceivedCells=atmfAtmStatsReceivedCells, atmfAtmLayerTable=atmfAtmLayerTable, atmfVpcAbrPortIndex=atmfVpcAbrPortIndex, atmfVpcAbrTransmitRif=atmfVpcAbrTransmitRif, atmfVpcTable=atmfVpcTable, atmfAddressRegistrationAdminIndex=atmfAddressRegistrationAdminIndex, atmfNoClpNoScr=atmfNoClpNoScr, atmfSrvcRegTypes=atmfSrvcRegTypes, atmfVpcReceiveTrafficDescriptorParam5=atmfVpcReceiveTrafficDescriptorParam5, atmfVccEntry=atmfVccEntry, atmfAtmStatsTransmittedCells=atmfAtmStatsTransmittedCells, atmfAtmLayerIlmiVersion=atmfAtmLayerIlmiVersion, atmfTransmissionTypes=atmfTransmissionTypes, atmForumAdmin=atmForumAdmin, atmfAtmStatsGroup=atmfAtmStatsGroup, atmfClpTaggingScr=atmfClpTaggingScr, atmfVpcBestEffortIndicator=atmfVpcBestEffortIndicator, atmfAtmLayerNniSigVersion=atmfAtmLayerNniSigVersion, atmfAtmLayerMinSvccVci=atmfAtmLayerMinSvccVci, ClnpAddress=ClnpAddress, atmfClpNoTaggingScr=atmfClpNoTaggingScr, atmfVccTransmitTrafficDescriptorParam4=atmfVccTransmitTrafficDescriptorParam4, atmfSrvcRegAddressIndex=atmfSrvcRegAddressIndex, atmfVpcTransmitTrafficDescriptorParam5=atmfVpcTransmitTrafficDescriptorParam5, atmfVccReceiveTrafficDescriptorParam2=atmfVccReceiveTrafficDescriptorParam2, atmfVpcReceiveTrafficDescriptorParam3=atmfVpcReceiveTrafficDescriptorParam3, AtmServiceCategory=AtmServiceCategory, atmfVpcReceiveTrafficDescriptorParam1=atmfVpcReceiveTrafficDescriptorParam1, atmfSrvcRegLecs=atmfSrvcRegLecs, atmForumUni=atmForumUni, atmfAtmLayerMaxSvpcVpi=atmfAtmLayerMaxSvpcVpi, atmfVpcTransmitQoSClass=atmfVpcTransmitQoSClass, atmfVccReceiveTrafficDescriptorType=atmfVccReceiveTrafficDescriptorType, atmfSrvcRegATMAddress=atmfSrvcRegATMAddress, atmfVccAbrVci=atmfVccAbrVci, atmfVccVpi=atmfVccVpi, atmfAddressEntry=atmfAddressEntry, atmfAtmStatsEntry=atmfAtmStatsEntry, atmfVccOperStatus=atmfVccOperStatus, atmfVccTransmitQoSClass=atmfVccTransmitQoSClass, atmfAddressAtmAddress=atmfAddressAtmAddress, atmfAddressTable=atmfAddressTable, atmfClpTaggingNoScr=atmfClpTaggingNoScr, atmfVpcAbrTransmitIcr=atmfVpcAbrTransmitIcr, atmfT1=atmfT1, atmfVpcReceiveTrafficDescriptorParam4=atmfVpcReceiveTrafficDescriptorParam4, atmfVccAbrTransmitRdf=atmfVccAbrTransmitRdf, atmfAtmLayerUniType=atmfAtmLayerUniType, atmfVpcGroup=atmfVpcGroup, atmfVpcReceiveTrafficDescriptorParam2=atmfVpcReceiveTrafficDescriptorParam2, atmfVccAbrTransmitIcr=atmfVccAbrTransmitIcr, atmfVpcQoSCategory=atmfVpcQoSCategory, atmfAtmLayerEntry=atmfAtmLayerEntry, atmfVccReceiveQoSClass=atmfVccReceiveQoSClass, AtmAddress=AtmAddress, atmfE3=atmfE3, atmfVccTransmitTrafficDescriptorParam3=atmfVccTransmitTrafficDescriptorParam3, atmfSrvcRegAns=atmfSrvcRegAns, atmfMediaStp=atmfMediaStp, atmfMediaTypes=atmfMediaTypes, atmfPortEntry=atmfPortEntry, atmfVccReceiveFrameDiscard=atmfVccReceiveFrameDiscard, atmfAtmLayerGroup=atmfAtmLayerGroup, atmfVpcEntry=atmfVpcEntry, atmfDs3=atmfDs3, atmfVccReceiveTrafficDescriptorParam5=atmfVccReceiveTrafficDescriptorParam5, atmf8B10B=atmf8B10B, atmfAddressGroup=atmfAddressGroup, atmfVpcAbrGroup=atmfVpcAbrGroup, atmfNetPrefixGroup=atmfNetPrefixGroup, atmfVccAbrGroup=atmfVccAbrGroup, atmfAtmLayerConfiguredVPCs=atmfAtmLayerConfiguredVPCs, atmfVpcServiceCategory=atmfVpcServiceCategory, atmfMediaUnknownType=atmfMediaUnknownType, atmfUnknownType=atmfUnknownType, atmfVpcAbrTransmitNrm=atmfVpcAbrTransmitNrm, atmfAddressOrgScope=atmfAddressOrgScope, atmfVccTransmitTrafficDescriptorType=atmfVccTransmitTrafficDescriptorType, atmfAtmLayerMaxSvccVpi=atmfAtmLayerMaxSvccVpi, atmfPortAddress=atmfPortAddress, atmfAtmLayerConfiguredVCCs=atmfAtmLayerConfiguredVCCs, atmfAtmLayerMaxVpiBits=atmfAtmLayerMaxVpiBits, atmfVccAbrTransmitCdf=atmfVccAbrTransmitCdf, atmfVpcTransmitTrafficDescriptorType=atmfVpcTransmitTrafficDescriptorType, atmfAddressRegistrationAdminEntry=atmfAddressRegistrationAdminEntry, atmfVccBestEffortIndicator=atmfVccBestEffortIndicator, atmfMyIpNmAddress=atmfMyIpNmAddress, atmfVpcAbrEntry=atmfVpcAbrEntry, atmfVccAbrTransmitNrm=atmfVccAbrTransmitNrm, atmfVccChange=atmfVccChange, atmfMediaMultiMode=atmfMediaMultiMode, atmfAtmLayerMaxVCCs=atmfAtmLayerMaxVCCs, atmfTrafficDescrTypes=atmfTrafficDescrTypes, atmfAddressRegistrationAdminStatus=atmfAddressRegistrationAdminStatus, atmfSrvcRegistryGroup=atmfSrvcRegistryGroup)
