#
# PySNMP MIB module SIAE-PTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/siae/SIAE-PTP-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 13:08:03 2024
# On host fv-az1108-994 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
AlarmStatus, AlarmSeverityCode = mibBuilder.importSymbols("SIAE-ALARM-MIB", "AlarmStatus", "AlarmSeverityCode")
siaeMib, = mibBuilder.importSymbols("SIAE-TREE-MIB", "siaeMib")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, NotificationType, MibIdentifier, TimeTicks, Counter64, IpAddress, Bits, iso, Gauge32, Unsigned32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "NotificationType", "MibIdentifier", "TimeTicks", "Counter64", "IpAddress", "Bits", "iso", "Gauge32", "Unsigned32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32")
TruthValue, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "RowStatus")
ptp = ModuleIdentity((1, 3, 6, 1, 4, 1, 3373, 1103, 100))
if mibBuilder.loadTexts: ptp.setLastUpdated('201605050000Z')
if mibBuilder.loadTexts: ptp.setOrganization('SIAE MICROELETTRONICA spa')
if mibBuilder.loadTexts: ptp.setContactInfo('SIAE MICROELETTONICA s.p.a.\n             Via Michelangelo Buonarroti, 21\n             20093 - Cologno Monzese\n             Milano - ITALY\n             Phone :  +39-02-27325-1\n             E-mail: help@siaemic.com\n            ')
if mibBuilder.loadTexts: ptp.setDescription("SIAE's Precision Time Protocol MIB.\n            For details see:\n            [1] IEEE Std 1588(TM)-2008, Standard for a Precision Clock\n                Synchronization Protocol for Networked Measurement and\n                Control Systems, 2008.\n            [2] Recommendation ITU-T G.8275.1/Y1369.1, Precision time protocol\n                telecom profile for phase/time synchronization with full timing\n                support from the network, draft 4 Apr 2014 . ")
class ClockDomainType(TextualConvention, Unsigned32):
    reference = 'Section 7.1 Domains and Table 2 of [1]'
    description = 'The Domain is identified by an integer, the domainNumber, in\n            the range of 0 to 255. An integer value that is used to assign\n            each PTP device to a particular domain. The following values\n            define the valid domains. [1] Section 7.1 Domains Table 2\n\n                     Value       definition.\n                     ---------   -------------------\n                     0           Default domain\n                     1           Alternate domain 1\n                     2           Alternate domain 2\n                     3           Alternate domain 3\n                     4 - 23      User-defined domains\n                     24 - 43     Telecom Profile domains\n                     44 - 127    User-defined domains\n                     128 - 255   Reserved'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(24, 43)

class ClockProfileType(TextualConvention, Integer32):
    reference = 'Section 3.1.30 and 19.3 PTP profiles of\n                         [IEEE 1588-2008]'
    description = 'Clock Profile used. A profile is the set of allowed Precision\n            Time Protocol (PTP) features applicable to a device.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("default", 1), ("telecom", 2), ("vendorspecific", 3))

class ClockQualityAccuracyType(TextualConvention, Integer32):
    reference = 'Section 5.3.7, 7.6.2.5 and Table 6 of [1]'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.5 and\n            Table 6 of [1].\n\n            The following values are not represented in the enumerated\n            values.\n\n                     0x01-0x1F Reserved\n                     0x32-0x7F Reserved\n\n            It is important to note that section 7.1.1 RFC2578 allows for\n            gaps and enumerate values to start with zero when indicated by\n            the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254, 255))
    namedValues = NamedValues(("reserved00", 1), ("nanoSecond25", 32), ("nanoSecond100", 33), ("nanoSecond250", 34), ("microSec1", 35), ("microSec2dot5", 36), ("microSec10", 37), ("microSec25", 38), ("microSec100", 39), ("microSec250", 40), ("milliSec1", 41), ("milliSec2dot5", 42), ("milliSec10", 43), ("milliSec25", 44), ("milliSec100", 45), ("milliSec250", 46), ("second1", 47), ("second10", 48), ("secondGreater10", 49), ("unknown", 254), ("reserved255", 255))

class ClockQualityClassType(TextualConvention, Integer32):
    reference = 'section 5.3.7, 7.6.2.4 and Table 5 of [1].\n                         section 6.4 and Table 2 of [2]'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.4 and\n            Table 5 of [1].\n\n             Value    Description\n             ------\n            ----------------------------------------------------------\n                   0  Reserved to enable compatibility with future\n                      versions.\n                 1-5  Reserved\n                   6  Shall designate a clock that is synchronized\n                      to a primary reference time source.  The\n                      timescale distributed shall be PTP.  A\n                      clockClass 6 clock shall not be a slave to\n                      another clock in the domain.\n                   7  Shall designate a clock that has previously\n                      been designated as clockClass 6 but that has\n                      lost the ability to synchronize to a primary\n                      reference time source and is in holdover mode\n                      and within holdover specifications. The\n                      timescale distributed shall be PTP.  A\n                      clockClass 7 clock shall not be a slave to\n                      another clock in the domain.\n                   8  Reserved.\n                9-10  Reserved to enable compatibility with future\n                      versions.\n               11-12  Reserved.\n                  13  Shall designate a clock that is synchronized\n                      to an application-specific source of time.\n                      The timescale distributed shall be ARB.  A\n                      clockClass 13 clock shall not be a slave to\n                      another clock in the domain.\n                  14  Shall designate a clock that has previously\n                      been designated as clockClass 13 but that\n                      has lost the ability to synchronize to an\n                      application-specific source of time and is\n                      in holdover mode and within holdover\n                      specifications. The timescale distributed\n                      shall be ARB.  A clockClass 14 clock shall\n                      not be a slave to another clock in the domain.\n               15-51  Reserved.\n                  52  Degradation alternative A for a clock of\n                      clockClass 7 that is not within holdover\n                      specification.  A clock of clockClass 52\n                      shall not be a slave to another clock in\n                      the domain.\n               53-57  Reserved.\n                  58  Degradation alternative A for a clock of\n                      clockClass 14 that is not within holdover\n                      specification. A clock of clockClass 58 shall\n                      not be a slave to another clock in the domain.\n               59-67  Reserved.\n              68-122  For use by alternate PTP profiles.\n             123-127  Reserved.\n             128-132  Reserved.\n             133-170  For use by alternate PTP profiles.\n             171-186  Reserved.\n\n                 187  Degradation alternative B for a clock of\n                      clockClass 7 that is not within holdover\n                      specification. A clock of clockClass 187 may\n                      be a slave to another clock in the domain.\n             188-192 Reserved.\n                 193 Degradation alternative B for a clock of\n                     clockClass 14 that is not within holdover\n                     specification. A clock of clockClass 193 may\n                     be a slave to another clock in the domain.\n             194-215 Reserved.\n             216-232 For use by alternate PTP profiles.\n             233-247 Reserved.\n                 248 Default. This clockClass shall be used if\n                     none of the other clockClass definitions apply.\n             249-250 Reserved.\n                 251 Reserved for version 1 compatibility; see Clause 18.\n             252-254 Reserved.\n                 255 Shall be the clockClass of a slave-only clock; see\n            9.2.2.\n\n            The ClockQuality as specified in section 6.4 and\n            Table 2 of [2].\n\n             Value    Description\n             ------\n            ----------------------------------------------------------\n                   6 T-GM connected to a PRTC in locked mode\n                     (e.g. PRTC traceable to GNSS)\n                 140 T-GM in holdover, out of holdover specification,\n                     traceable to Category 1 frequency source\n                 150 T-GM in holdover, out of holdover specification,\n                     traceable to Category 2 frequency source\n                 160 T-GM in holdover, out of holdover specification,\n                     traceable to Category 3 frequency source\n                 165 T-BC in holdover, out of holdover specification,\n                     using unspecified frequency source\n                 255 Slave only OC (does not send Announce messages)\n\n            '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockStateType(TextualConvention, Integer32):
    description = 'The clock state returned by PTP engine.\n\n            Clock State             Value   Description\n            --------------------------------------------------------------\n            Freerun state           1       The PTP clock has never been synchronized\n                                            to a time source and is not in the process\n                                            of synchronizing to a time source.\n                                            As it relates to the PTP port state defined\n                                            in [IEEE 1588], a clock is in Free-Run state\n                                            if there are no PTP ports in: MASTER,\n                                            PRE-MASTER, PASSIVE, UNCALIBRATED,\n                                            or SLAVE states.\n\n            Acquiring state         2       The PTP clock is in process of synchronizing\n                                            to a time source. The duration and functionality\n                                            of this state is implementation specific. This\n                                            state is not required in an implementation.\n                                            As it relates to the PTP port state defined in\n                                            [IEEE 1588], a clock is in Acquiring state if\n                                            there is a PTP port in UNCALIBRATED state.\n\n            Locked state            3       The PTP clock is synchronized to a time source\n                                            and is within some internal acceptable accuracy.\n                                            As it relates to the PTP port state defined in\n                                            [IEEE 1588], a clock is in Locked state if there\n                                            is a PTP port in SLAVE state.\n\n            HoldoverInSpec state    4       The PTP clock is no longer synchronized to a\n                                            time source and is using information obtained\n                                            while it was previously synchronized or other\n                                            information sources were still available, to\n                                            maintain performance within desired specification.\n                                            The node may be relying solely on its own\n                                            facilities for holdover or may use something\n                                            like a frequency input from the network to\n                                            achieve a holdover of time and/or phase.\n                                            As it relates to the PTP port state defined in\n                                            [IEEE 1588], a clock is in HoldoverInSpec\n                                            state if there are no PTP ports in: INITIALIZING,\n                                            LISTENING, UNCALIBRATED or SLAVE states, and\n                                            performance is within desired specification.\n\n            HoldoverOutOfSpec state 5       The PTP clock is no longer synchronized to a time\n                                            source and, while it may be using information\n                                            obtained while it was previously synchronized or\n                                            other information sources were still available,\n                                            it is unable to maintain performance within\n                                            desired specification.\n                                            As it relates to the PTP port state defined in\n                                            [IEEE 1588], a clock is in HoldoverOutOfSpec\n                                            state if there are no PTP ports in: INITIALIZING,\n                                            LISTENING, UNCALIBRATED or SLAVE states, and\n                                            performance is not within desired specification.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("freerun", 1), ("acquiring", 2), ("locked", 3), ("holdoverInSpec", 4), ("holdoverOutOfSpec", 5))

class ClockTimeSourceType(TextualConvention, Integer32):
    reference = 'section 5.3.7, 7.6.2.6 and Table 7 of [1].'
    description = 'The ClockQuality as specified in section 5.3.7, 7.6.2.6 and\n            Table 7 of [1].\n\n            The following values are not represented in the enumerated\n            values.\n\n            0xF0-0xFE  For use by alternate PTP profiles\n            0xFF       Reserved\n\n            It is important to note that section 7.1.1 RFC2578 allows for\n            gaps and enumerate values to start with zero when indicated by\n            the protocol.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160, 255))
    namedValues = NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOscillator", 160), ("reserved", 255))

class ClockInstanceType(TextualConvention, Unsigned32):
    description = 'The instance of the Clock of a given clock type in a given\n            domain.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockPPSInstanceType(TextualConvention, Unsigned32):
    description = 'The instance of the PPS (and ToD) socket.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ClockPortNumber(TextualConvention, Unsigned32):
    reference = 'Section 7.5.2.3 Port Number and 5.3.5 of [1]'
    description = 'An index identifying a specific Precision Time Protocol (PTP)\n            port on a PTP node.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class ClockPortState(TextualConvention, Integer32):
    reference = 'Section 8.2.5.3.1 portState and 9.2.5 of [1]'
    description = 'This is the value of the current state of the protocol engine\n            associated with this port.\n            Port state      Value     Description\n            -----------------------------------------------------------\n            initializing      1       In this state a port initializes\n                                      its data sets, hardware, and\n                                      communication facilities.\n            faulty            2       The fault state of the protocol.\n            disabled          3       The port shall not place any\n                                      messages on its communication path.\n            listening         4       The port is waiting for the\n                                      announceReceiptTimeout to expire or\n                                      to receive an Announce message from\n                                      a master.\n            preMaster         5       The port shall behave in all respects\n                                      as though it were in the MASTER state\n                                      except that it shall not place any\n                                      messages on its communication path\n                                      except for Pdelay_Req, Pdelay_Resp,\n                                      Pdelay_Resp_Follow_Up, signaling, or\n                                      management messages.\n            master            6       The port is behaving as a master\n                                      port.\n            passive           7       The port shall not place any\n                                      messages on its communication path\n                                      except for Pdelay_Req, Pdelay_Resp,\n                                      Pdelay_Resp_Follow_Up, or signaling\n                                      messages, or management messages\n                                      that are a required response to\n                                      another management message\n            uncalibrated      8       The local port is preparing to\n                                      synchronize to the master port.\n            slave             9       The port is synchronizing to the\n                                      selected master port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("preMaster", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9))

class ClockMechanismType(TextualConvention, Integer32):
    reference = 'Sections 8.2.5.4.4, 6.6.4 and 7.4.2 of [1].'
    description = 'The clock type based on whether End to End or peer to peer\n            mechanisms are used. The mechanism used to calculate the Mean\n            Path Delay as indicated in Table 9 of IEEE 1588-2008.\n\n            Delay mechanism       Value(hex) Specification\n            E2E                    01        The port is configured to use\n                                             the delay request-response\n                                             mechanism.\n\n            P2P                    02        The port is configured to use\n                                             the peer delay mechanism.\n\n            DISABLED               FE        The port does not implement\n                                             the delay mechanism.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1))
    namedValues = NamedValues(("e2e", 1))

class ClockTimeInterval(TextualConvention, OctetString):
    reference = 'Section 5.3.2 and setion 7.7.2.1 Timer interval\n            specification of [1]'
    description = 'This textual convention corresponds to the TimeInterval\n            structure indicated in section 5.3.2 of [1]. It will be\n            presented in the form of a character array.\n\n            The TimeInterval type represents time intervals.\n\n                 struct TimeInterval\n                 {\n                      Integer64 scaledNanoseconds;\n                 };\n\n            The scaledNanoseconds member is the time interval expressed in\n            units of nanoseconds and multiplied by 2**16.\n\n            Positive or negative time intervals outside the maximum range\n            of this data type shall be encoded as the largest positive and\n            negative values of the data type, respectively.\n\n            For example, 2.5 ns is expressed as 0000 0000 0002 8000 in\n            Base16.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class ClockType(TextualConvention, Integer32):
    reference = 'section 6.5.1 of [1].'
    description = 'The clock types as defined in the MIB module description.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2))
    namedValues = NamedValues(("boundaryClock", 2))

class PtpClockToDFormatType(TextualConvention, Integer32):
    description = 'This is the format used for ToD signal in input or in output direcdtion.\n\n            -----------------------------------------------------------\t\t\t\n            Format              Value  Description\n            -----------------------------------------------------------\n            telecomTimeEvent      1    \n            telecomTimeAnnounce   2    \n            telecomGNSSstatus     3    \n\t\t\tNMEAzda               4    ASCII format (eg: $GPZDA,003157.00,01,01,1970,00,00*69)\n\t\t\tISO8601               5    ASCII format (eg: 1970-01-01T00:32:47Z)\n\t\t\tNTP                   6    ASCII format (eg: 70 001 00:30:51.000  S)\n\t\t\tUblox                 7    Not ASCII\n\t\t\tChinaMobile           8    Not ASCII\n\t\t\tChinaTelecom          9    Not ASCII (standard ITU G.8271 is derived from this)\n\t\t\tBCM                  10    Not ASCII\n\t\t\tBCMTS                11    Not ASCII\n            -----------------------------------------------------------'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("telecomTimeEvent", 1), ("telecomTimeAnnounce", 2), ("telecomGNSSstatus", 3), ("nmeazda", 4), ("iso8601", 5), ("ntp", 6), ("ublox", 7), ("chinaMobile", 8), ("chinaTelecom", 9), ("bcm", 10), ("bcmts", 11))

ptpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 1), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpMibVersion.setStatus('current')
if mibBuilder.loadTexts: ptpMibVersion.setDescription('Numerical version of this module.\n             The string version of this MIB have the following format:\n                XX.YY.ZZ\n             so, for example, the value 1 should be interpreted as 00.00.01\n             and the value 10001 should be interpreted as 01.00.01.')
ptpProfileDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2))
ptpSpecificDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3))
ptpDefaultDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4))
ptpCurrentDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5))
ptpParentDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6))
ptpTimePropertiesDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7))
ptpPortDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8))
ptpClockPPSDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9))
ptpRadioAsymmetryDataSet = MibIdentifier((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 10))
ptpSystemProfile = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2, 1), ClockProfileType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpSystemProfile.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: ptpSystemProfile.setStatus('current')
if mibBuilder.loadTexts: ptpSystemProfile.setDescription('This object specifies the PTP Profile implemented on the\n            system.')
ptpProfileName = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpProfileName.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: ptpProfileName.setStatus('current')
if mibBuilder.loadTexts: ptpProfileName.setDescription('This object describes the PTP Profile implemented on the system.')
ptpProfilePrimaryVersion = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpProfilePrimaryVersion.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: ptpProfilePrimaryVersion.setStatus('current')
if mibBuilder.loadTexts: ptpProfilePrimaryVersion.setDescription('The version of the profile consist of two fields: a primaryVersion\n            and a revisionNumber. The profileVersion shall be printed as\n                primaryVersion.revisionNumber\n            ')
ptpProfileRevisionNumber = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpProfileRevisionNumber.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: ptpProfileRevisionNumber.setStatus('current')
if mibBuilder.loadTexts: ptpProfileRevisionNumber.setDescription('The version of the profile consist of two fields: a primaryVersion\n            and a revisionNumber. The profileVersion shall be printed as\n                primaryVersion.revisionNumber\n            ')
ptpProfileIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 2, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="0019A7010100")).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpProfileIdentifier.setReference('Section 19.3 PTP profiles of [1]')
if mibBuilder.loadTexts: ptpProfileIdentifier.setStatus('current')
if mibBuilder.loadTexts: ptpProfileIdentifier.setDescription('This object show the PTP Profile version on the system.')
ptpClockDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1), )
if mibBuilder.loadTexts: ptpClockDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockDataSetTable.setDescription('Table of information about the PTP clock Default Datasets for\n         all domains.')
ptpClockDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpClockDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockDataSetEntry.setDescription('Contains the information of the clock on a particular doamin. This\n          table will be initialised with default values if the clock is\n          operating as a boundary or ordinary clock in the domain.')
ptpClockDomainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 1), ClockDomainType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDomainIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockDomainIndex.setDescription('This object specifies the domain number used to create logical\n        group of PTP devices. The Clock Domain is a logical group of\n        clocks and devices that synchronize with each other using the\n        PTP protocol.')
ptpClockTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 2), ClockType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTypeIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockTypeIndex.setDescription('This object specifies the clock type as defined in the\n        Textual convention description.')
ptpClockInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 3), ClockInstanceType().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockInstanceIndex.setDescription('This object specifies the instance of the Clock for this clock\n        type for the given domain.')
ptpClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpClockIdentity.setDescription('This is the unique identity of the local clock or management node.\n         This should be the smptpDomainClockIdentity of the domain indicated\n         by the ptpDomainNumber. Configuration of this value will take effect\n         only when the PTP module is enabled.')
ptpClockTwoStepFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockTwoStepFlag.setStatus('current')
if mibBuilder.loadTexts: ptpClockTwoStepFlag.setDescription('This value is TRUE if the clock is two step clock, otherwise it is\n        FALSE. If this value is configured as TRUE, then PTP will transmit the\n        originTimeStamp only through follow-up messages.')
ptpClockNumberPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)).clone(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockNumberPorts.setStatus('current')
if mibBuilder.loadTexts: ptpClockNumberPorts.setDescription('This indicates the number of PTP ports on the device. For an ordinary\n         clock this value should be 1.')
ptpClockClass = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 7), ClockQualityClassType().clone(248)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockClass.setStatus('current')
if mibBuilder.loadTexts: ptpClockClass.setDescription('This object specifies the default dataset Quality Class.')
ptpClockAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 8), ClockQualityAccuracyType().clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpClockAccuracy.setDescription('This object specifies the default dataset Quality Accurarcy.')
ptpClockOffsetScaledLogVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: ptpClockOffsetScaledLogVariance.setDescription('This value is an estimate of the variations of the local clock\n         from a linear timescale when it is not synchronized to another\n         clock using the protocol. The initialization value depends on the\n         inherent characteristics of the clock during initialization. This\n         value is used by the BMC algorithm to select the best master clock')
ptpClockPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(128, 128)).clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpClockPriority1.setStatus('current')
if mibBuilder.loadTexts: ptpClockPriority1.setDescription('This value is used by BMC algorithm to select the best master\n         clock. Lower values take precedence.')
ptpClockPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpClockPriority2.setStatus('current')
if mibBuilder.loadTexts: ptpClockPriority2.setDescription('This value is used by BMC algorithm to select the best master clock.\n        This is used as a tiebreaker when the BMC failes to order the clock\n        using  ptpClockPriority1, ptpClockClass, ptpClockAccuracy and\n        ptpClockOffsetScaledLogVariance.\n        Lower values take precedence')
ptpClockSlaveOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpClockSlaveOnly.setStatus('current')
if mibBuilder.loadTexts: ptpClockSlaveOnly.setDescription('Configuring this value as true will make the clock to behave as slave\n        clock.\n        A boundary clock can not be a slave only clock.')
ptpClockLocalPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpClockLocalPriority.setReference('Section 6.3.1 and 6.3.2 of [2]')
if mibBuilder.loadTexts: ptpClockLocalPriority.setStatus('current')
if mibBuilder.loadTexts: ptpClockLocalPriority.setDescription('This attribute is used in the alternate BMCA as a tie-breaker in the\n         dataset comparison algorithm, in the event that all other previous\n         attributes of the datasets being compared are equal.')
ptpClockRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 4, 1, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpClockRowStatus.setStatus('current')
if mibBuilder.loadTexts: ptpClockRowStatus.setDescription('RowStatus for creating the entries into this table.\n         This object support only destroy and createAndGo values.')
ptpSpecificDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1), )
if mibBuilder.loadTexts: ptpSpecificDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpSpecificDataSetTable.setDescription('Table of vendor specific information about the PTP clock\n         for all domains.')
ptpSpecificDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpSpecificDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpSpecificDataSetEntry.setDescription('Contains vendor specific information for a particular PTP clock.\n         Where not otherwise specified, every object of this entry can \n         be modified with the conceptual row active.')
ptpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ptpAdminStatus.setDescription('This object states if PTP is enabled or disabled for this PTP Clock\n         in order to switch on/off the PTP protocol.')
ptpStaticPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpStaticPortRole.setStatus('current')
if mibBuilder.loadTexts: ptpStaticPortRole.setDescription('This object states that in the PTP Clock the A-BMCA is disabled and\n         it is working in Static PTP Port Role mode.')
ptpClockState = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1, 1, 3), ClockStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockState.setStatus('current')
if mibBuilder.loadTexts: ptpClockState.setDescription('This object shows the current state of the PTP Clock State Machine')
ptpCompliance = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strictCompatibility", 1), ("looseCompatibility", 2))).clone('looseCompatibility')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpCompliance.setStatus('current')
if mibBuilder.loadTexts: ptpCompliance.setDescription('This object states if the clock is strictly profile compliant. The\n         meaning of looseCompatibility is application dependent.')
ptpSpecificAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 2), )
if mibBuilder.loadTexts: ptpSpecificAlarmTable.setStatus('current')
if mibBuilder.loadTexts: ptpSpecificAlarmTable.setDescription('Table of vendor specific information about the PTP clock\n         for all domains.')
ptpSpecificAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 2, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpSpecificAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: ptpSpecificAlarmEntry.setDescription('Contains vendor specific alarm information for a particular PTP clock.')
ptpFreeRunningAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 2, 1, 1), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpFreeRunningAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpFreeRunningAlarm.setDescription('This alarm is raised when ptpClockState is set to freerun(1).\n            ')
ptpHoldoverInSpecAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 2, 1, 2), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpHoldoverInSpecAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpHoldoverInSpecAlarm.setDescription('This alarm is raised when ptpClockState is set to\n             holdoverInSpec(4).\n            ')
ptpHoldoverOutOfSpecAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 2, 1, 3), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpHoldoverOutOfSpecAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpHoldoverOutOfSpecAlarm.setDescription('This alarm is raised when ptpClockState is set to \n             holdoverOutOfSpec(5).\n            ')
ptpFreeRunningAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 3), AlarmSeverityCode().clone('warningTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpFreeRunningAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpFreeRunningAlarmSeverityCode.setDescription('This object defines the severity associated to \n             ptpFreeRunningAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpHoldoverInSpecAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 4), AlarmSeverityCode().clone('warningTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpHoldoverInSpecAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpHoldoverInSpecAlarmSeverityCode.setDescription('This object defines the severity associated to \n             ptpHoldoverInSpecAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpHoldoverOutOfSpecAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 3, 5), AlarmSeverityCode().clone('majorTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpHoldoverOutOfSpecAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpHoldoverOutOfSpecAlarmSeverityCode.setDescription('This object defines the severity associated to \n             ptpHoldoverOutOfSpecAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpCurrentDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5, 1), )
if mibBuilder.loadTexts: ptpCurrentDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpCurrentDataSetTable.setDescription('Table of information about the PTP clock Current Datasets for\n         all domains.')
ptpCurrentDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpCurrentDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpCurrentDataSetEntry.setDescription(' Contains synchronization information on a particular domain.')
ptpCurrentStepsRemoved = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpCurrentStepsRemoved.setReference('1588 Version 2.0 Section 8.2.2.2 stepsRemoved')
if mibBuilder.loadTexts: ptpCurrentStepsRemoved.setStatus('current')
if mibBuilder.loadTexts: ptpCurrentStepsRemoved.setDescription('This object specifies the distance measured by the number of\n         Boundary clocks between the local clock and the Foreign master\n         as indicated in the stepsRemoved field of Announce messages.\n         Slave clock will update this field once port is selected as slave.')
ptpCurrentOffsetFromMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5, 1, 1, 2), ClockTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpCurrentOffsetFromMaster.setReference('1588 Version 2.0 Section 8.2.2.3 of [1]')
if mibBuilder.loadTexts: ptpCurrentOffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: ptpCurrentOffsetFromMaster.setDescription('This object specifies the current clock dataset ClockOffset\n         value. The value of the computation of the offset in time\n         between a slave and a master clock.')
ptpCurrentMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 5, 1, 1, 3), ClockTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpCurrentMeanPathDelay.setReference('1588 Version 2.0 Section 8.2.2.4 mean path delay')
if mibBuilder.loadTexts: ptpCurrentMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: ptpCurrentMeanPathDelay.setDescription('This object specifies the current clock dataset\n         MeanPathDelay value.\n         The mean path delay between a pair of ports as measure by the\n         delay request-response mechanism.')
ptpParentDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1), )
if mibBuilder.loadTexts: ptpParentDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpParentDataSetTable.setDescription('Table of information about the PTP clock Parent Datasets for\n         all domains.')
ptpParentDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpParentDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpParentDataSetEntry.setDescription('Contains parent clock information on a particular domain. ')
ptpParentClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentClockIdentity.setReference('section 8.2.3.2 parentDS.parentPortIdentity of [1]')
if mibBuilder.loadTexts: ptpParentClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpParentClockIdentity.setDescription('This is the clock identity of the port on the master that issues\n         sync messages used in synchronizing this clock. The initial value\n         of this field is the value of ptpClockIdentity')
ptpParentPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 2), ClockPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentPortNumber.setReference('section 8.2.3.2 parentDS.parentPortIdentity of [1]')
if mibBuilder.loadTexts: ptpParentPortNumber.setStatus('current')
if mibBuilder.loadTexts: ptpParentPortNumber.setDescription('This is the port number identity of the port on the master that issues\n         sync message used in synchronizing this clock. Combination of\n         ptpParentClockIdentity and ptpParentPortNumber gives the port identity\n         of the parent clock.')
ptpParentGMClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMClockIdentity.setReference('section 8.2.3.6 parentDS.grandmasterIdentity of [1]')
if mibBuilder.loadTexts: ptpParentGMClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMClockIdentity.setDescription('This is the clock identity attribute of the grand master clock.\n         The initial value is ptpClockIdentity.')
ptpParentGMClockClass = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 4), ClockQualityClassType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMClockClass.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: ptpParentGMClockClass.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMClockClass.setDescription('This is the clock class of the grandmaster. The\n         initialization value of this variable is ptpClockClass.')
ptpParentGMClockAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 5), ClockQualityAccuracyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMClockAccuracy.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: ptpParentGMClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMClockAccuracy.setDescription('This is the clock accuracy of the grandmaster. The\n         initialization value of this variable is ptpClockAccuracy')
ptpParentGMClockOffsetScaledLogVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMClockOffsetScaledLogVariance.setReference('section 8.2.3.7 parentDS.grandmasterClockQuality of [1]')
if mibBuilder.loadTexts: ptpParentGMClockOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMClockOffsetScaledLogVariance.setDescription('This is the offset scaled log variance of the grandmaster. The\n         initialization value of this variable is\n         ptpClockOffsetScaledLogVariance')
ptpParentGMPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMPriority1.setReference('section 8.2.3.8 parentDS.grandmasterPriority1 of [1]')
if mibBuilder.loadTexts: ptpParentGMPriority1.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMPriority1.setDescription('This is the priority1 of the grandmaster clock. The\n         initialization value of this variable is ptpClockPriority1')
ptpParentGMPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpParentGMPriority2.setReference('section 8.2.3.9 parentDS.grandmasterPriority2 of [1]')
if mibBuilder.loadTexts: ptpParentGMPriority2.setStatus('current')
if mibBuilder.loadTexts: ptpParentGMPriority2.setDescription('This is the priority2 of the grandmaster clock. The\n             initialization value of this variable is ptpClockPriority2')
ptpTimeDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1), )
if mibBuilder.loadTexts: ptpTimeDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpTimeDataSetTable.setDescription('Table of information about the PTP clock Timeproperties\n        Datasets for all domains.')
ptpTimeDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"))
if mibBuilder.loadTexts: ptpTimeDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpTimeDataSetEntry.setDescription('Contains parent Time properties information of the\n                 clock on a particular domain.')
ptpTimeCurrentUTCOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffset.setReference('section 8.2.4.2 timePropertiesDS.currentUtcOffset of [1]')
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffset.setStatus('current')
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffset.setDescription('If systems epoch is the PTP epoch then this value indicates the offset\n        in seconds between TAI and UTC.')
ptpTimeCurrentUTCOffsetValid = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffsetValid.setReference('section 8.2.4.3 timePropertiesDS.currentUtcOffsetValid of [1]')
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffsetValid.setStatus('current')
if mibBuilder.loadTexts: ptpTimeCurrentUTCOffsetValid.setDescription('Value of this variable is TRUE if the ptpTimeCurrentUTCOffset is\n        known to be correct.')
ptpTimeLeap59 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeLeap59.setReference('section 8.2.4.4 timePropertiesDS.leap59 of [1]')
if mibBuilder.loadTexts: ptpTimeLeap59.setStatus('current')
if mibBuilder.loadTexts: ptpTimeLeap59.setDescription('If the systems epoch is PTP epoch then TRUE value of this variable\n        indicates that the last minute of the current UTC day contains 59\n        seconds.')
ptpTimeLeap61 = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeLeap61.setReference('section 8.2.4.5 timePropertiesDS.leap61 of [1]')
if mibBuilder.loadTexts: ptpTimeLeap61.setStatus('current')
if mibBuilder.loadTexts: ptpTimeLeap61.setDescription('If the systems epoch is PTP epoch then TRUE value of this variable\n        indicates that the last minute of the current UTC day contains 61\n        seconds.')
ptpTimeTimeTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeTimeTraceable.setReference('section  8.2.4.6 timePropertiesDS.timeTraceable of [1]')
if mibBuilder.loadTexts: ptpTimeTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpTimeTimeTraceable.setDescription('This variable is TRUE if the timescale and value of\n        ptpTimeCurrentUTCOffset are traceable to a primary reference\n        otherwise, the value shall be FALSE.')
ptpTimeFrequencyTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeFrequencyTraceable.setReference('section 8.2.4.7 timePropertiesDS.frequencyTraceable of [1]')
if mibBuilder.loadTexts: ptpTimeFrequencyTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpTimeFrequencyTraceable.setDescription('This variable is TRUE if the frequecy determining the timescale is\n        traceable to a primary reference otherwise, the value shall be FALSE.')
ptpTimescale = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimescale.setReference('section 8.2.4.8 timePropertiesDS.ptpTimescale of [1]')
if mibBuilder.loadTexts: ptpTimescale.setStatus('current')
if mibBuilder.loadTexts: ptpTimescale.setDescription('This variable is TRUE if the clock timescale of the grandmaster clock\n        is PTP otherwise, the value shall be FALSE.')
ptpTimeTimeSource = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 7, 1, 1, 8), ClockTimeSourceType().clone('internalOscillator')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeTimeSource.setReference('section 8.2.4.9 timePropertiesDS.timeSource of [1]')
if mibBuilder.loadTexts: ptpTimeTimeSource.setStatus('current')
if mibBuilder.loadTexts: ptpTimeTimeSource.setDescription('This is the source of time used by the grandmaster clock. If the time\n        source is known at the time of initialization then the value will be set\n        to that otherwise the initial value is INTERNAL_OSCILLATOR(160).')
ptpClockPPSDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1), )
if mibBuilder.loadTexts: ptpClockPPSDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSDataSetTable.setDescription('Table of information about the PTP clock PPS and ToD properties.')
ptpClockPPSDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"), (0, "SIAE-PTP-MIB", "ptpClockPPSInstanceIndex"))
if mibBuilder.loadTexts: ptpClockPPSDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSDataSetEntry.setDescription('Contains PPS and ToD properties information of the\n                 specific domain and clock on a specific PPS socket.')
ptpClockPPSInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 1), ClockPPSInstanceType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockPPSInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSInstanceIndex.setDescription('This object specifies the id of PPS interface socket.\n         It represents the id of ToD interface socket too.')
ptpClockPPSInstanceCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPPSInstanceCapability.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSInstanceCapability.setDescription('This object is a bitmap and each bit represents \n         a specific capability of the PPS or ToD interface.\n         Bit 0 : 1 = the interface can be used either in input or in output\n                     and the user can select the direction using ptpClockPPSDirection object; \n                 0 = the interface can have one direction specified by the system, \n                     in this case the ptpClockPPSDirection object is read only.\n         Bit 1 : 1 = the ToD interface allows more baudrate;\n                 0 = the ToD interface allows one only baudrate, fixed by system.   ')
ptpClockPPSDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("input", 1), ("output", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockPPSDirection.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSDirection.setDescription('This object specifies the direction (input or output) \n         of PPS signal and ToD data')
ptpClockPPSLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('PPS')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockPPSLabel.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSLabel.setDescription('This object specifies the label as appears near the PPS signal socket')
ptpClockPPSAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockPPSAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSAdminStatus.setDescription('This object is the administrive status of PPS interface and\n         specifies whether the node is enabled for PTP input/output \n         clocking using the PPS interface.')
ptpClockPPSOffsetEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockPPSOffsetEnabled.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSOffsetEnabled.setDescription('This object specifies whether an offset is configured \n\t\tin order to compensate for a known phase error \n\t\tsuch as network asymmetry.')
ptpClockPPSOffsetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockPPSOffsetValue.setStatus('current')
if mibBuilder.loadTexts: ptpClockPPSOffsetValue.setDescription('This object specifies the fixed offset signed value in nanoseconds \n\t\tconfigured to be added for the PPS output or input.')
ptpClockToDLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone('ToD')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockToDLabel.setStatus('current')
if mibBuilder.loadTexts: ptpClockToDLabel.setDescription('This object specifies the label as appears near the ToD socket')
ptpClockToDAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2))).clone('down')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockToDAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ptpClockToDAdminStatus.setDescription('This object is the administrive status of PPS interface and \n         specifies whether the ToD interface is enabled.')
ptpClockToDDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockToDDelay.setStatus('current')
if mibBuilder.loadTexts: ptpClockToDDelay.setDescription('This object specifies microseconds of delay between PPS edge \n\t\tand ToD data emitted, used only in output direction.')
ptpClockToDBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(300, 300), ValueRangeConstraint(600, 600), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(1800, 1800), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ValueRangeConstraint(230400, 230400), )).clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockToDBaudrate.setStatus('current')
if mibBuilder.loadTexts: ptpClockToDBaudrate.setDescription('This object specifies the Baudrate of ToD signal in input or output direction.')
ptpClockToDFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 9, 1, 1, 12), PtpClockToDFormatType().clone('telecomTimeEvent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpClockToDFormat.setStatus('current')
if mibBuilder.loadTexts: ptpClockToDFormat.setDescription('This object specifies the format of ToD signal in input or output direction.')
ptpPortDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1), )
if mibBuilder.loadTexts: ptpPortDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetTable.setDescription('Table Contains PTP configuration information\n                 for a particular port of boundary or an ordinary clock')
ptpPortDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"), (0, "SIAE-PTP-MIB", "ptpPortIndex"))
if mibBuilder.loadTexts: ptpPortDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetEntry.setDescription('Contains PTP configuration information for a particular port.\n                 Valid ptpPortIfIndex need to be given to make this entry active.\n                 Where not otherwise specified, every object of this entry \n                 can be modified with the conceptual row active.')
ptpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 1), ClockPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortIndex.setStatus('current')
if mibBuilder.loadTexts: ptpPortIndex.setDescription('The index value used to identify the port component on the device.\n        The value of this object is used as a port index to the\n        ptpPortConfigDataSetTable.')
ptpPortClockIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortClockIdentity.setReference('section 8.2.5.2.1 portDS.portIdentity of [1]')
if mibBuilder.loadTexts: ptpPortClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ptpPortClockIdentity.setDescription('This is the clock Identity of the port')
ptpPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 3), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: ptpPortIfIndex.setDescription("This is the index in ifTable of this port.\n         This object can't be modified.")
ptpPortStaticRole = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 7, 9))).clone(namedValues=NamedValues(("master", 6), ("passive", 7), ("slave", 9))).clone('master')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortStaticRole.setStatus('current')
if mibBuilder.loadTexts: ptpPortStaticRole.setDescription('Role of this port. This object forces the role of the port if\n         ptpStaticPortRole is true.')
ptpPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("down", 1), ("up", 2))).clone('down')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ptpPortAdminStatus.setDescription('Administrive status of the port. The value down turns off the PTP\n         protocol on the ethernet port.')
ptpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 6), ClockPortState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortState.setReference('section 8.2.5.3.1 portDS.portState of [1]')
if mibBuilder.loadTexts: ptpPortState.setStatus('current')
if mibBuilder.loadTexts: ptpPortState.setDescription('This denotes the PTP State of the PTP port as computed by the PTP State\n        event machine.\n\n        initializing:\n        While a port is in the INITIALIZING state, the port initializes its data\n        sets, hardware, and communication facilities. No port of the clock shall\n        place any PTP messages on its communication path. If one port of a\n        boundary clock is in the INITIALIZING state, then all ports shall be in\n        the INITIALIZING state.\n\n        faulty:\n        The fault state of the protocol. A port in this state shall not place any\n        PTP messages except for management messages that are a required response\n        to another management message on its communication path.\n\n        disabled:\n        The port shall not place any messages on its communication path. In a\n        boundary clock, no activity at the port shall be allowed to affect the\n        activity at any other port of the boundary clock. A port in this state\n        shall discard all PTP received messages except for management messages.\n\n        listening:\n        The port is waiting for the announceReceiptTimeout to expire or to\n        receive an Announce message from a master. The purpose of this state is\n        to allow orderly addition of clocks to a domain. A port in this state\n        shall not place any PTP messages on its communication path except for\n        Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, or signaling messages,\n        or management messages that are a required response to another\n        management message.\n\n        premaster:\n        The port shall behave in all respects as though it were in the MASTER\n        state except that it shall not place any messages on its communication\n        path except for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, signaling\n        or management messages.\n\n        master:\n        The port is behaving as a master port. It will periodically send announce\n        and sync messages.\n\n        passive:\n        The port shall not place any messages on its communication path except\n        for Pdelay_Req, Pdelay_Resp, Pdelay_Resp_Follow_Up, or signaling messages\n        or management messages that are a required response to another management\n        message.\n\n        uncalibrated:\n        This is a transient state to allow initialization of synchronization\n        servos, updating of data sets when a new master port has been selected,\n        and other implementation-specific activity.\n\n        slave:\n        The port is synchronizing to the selected master port.')
ptpPortMinDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7)).clone(-4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortMinDelayReqInterval.setReference('section 8.2.5.3.2 portDS.logMinDelayReqInterval of [1]')
if mibBuilder.loadTexts: ptpPortMinDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: ptpPortMinDelayReqInterval.setDescription('This is the log to the base 2 of the delay request interval\n        in seconds. This speifies the time to the members devices to\n        send delay request messages when the port is in the master.\n        It specify the minimum permitted mean time interval between\n        successive Delay_Req messages, min delay request interval value is\n        a compromise between the fluctuation in link delay and startup time\n        and the communication and computation load imposed by transmission\n        of these messages.')
ptpPortLogAnnounceInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-3, 6)).clone(-3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortLogAnnounceInterval.setReference('section 8.2.5.4.1 portDS.logAnnounceInterval of [1]')
if mibBuilder.loadTexts: ptpPortLogAnnounceInterval.setStatus('current')
if mibBuilder.loadTexts: ptpPortLogAnnounceInterval.setDescription('This is the log to the base 2 of the mean Announce message interval\n           in seconds.')
ptpPortAnnounceReceiptTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortAnnounceReceiptTimeout.setReference('section 8.2.5.4.2 portDS.announceReceiptTimeout of [1]')
if mibBuilder.loadTexts: ptpPortAnnounceReceiptTimeout.setStatus('current')
if mibBuilder.loadTexts: ptpPortAnnounceReceiptTimeout.setDescription('This is the Announce receipt time out value.\n           This should be an integral multiple of announce interval\n           in seconds')
ptpPortSyncInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 0)).clone(-4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortSyncInterval.setReference('section 8.2.5.4.3 portDS.logSyncInterval of [1]')
if mibBuilder.loadTexts: ptpPortSyncInterval.setStatus('current')
if mibBuilder.loadTexts: ptpPortSyncInterval.setDescription('This is the logarithm to the base 2 of the sync message interval\n         in seconds')
ptpPortDelayMechanism = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 11), ClockMechanismType().clone('e2e')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortDelayMechanism.setStatus('current')
if mibBuilder.loadTexts: ptpPortDelayMechanism.setDescription('This indicates the propagation delay measuring option used by the\n           port in computing meanpathDelay.')
ptpPortVersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortVersionNumber.setStatus('current')
if mibBuilder.loadTexts: ptpPortVersionNumber.setDescription('This indicates the PTP version in use on the port.')
ptpPortNotSlave = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortNotSlave.setReference('Section 6.3.1 and 6.3.2 of [2]')
if mibBuilder.loadTexts: ptpPortNotSlave.setStatus('current')
if mibBuilder.loadTexts: ptpPortNotSlave.setDescription('This attribute is used in the alternate BMCA to prevent that a port\n         can be placed in the SLAVE state.')
ptpPortLocalPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortLocalPriority.setReference('Section 6.3.1 and 6.3.2 of [2]')
if mibBuilder.loadTexts: ptpPortLocalPriority.setStatus('current')
if mibBuilder.loadTexts: ptpPortLocalPriority.setDescription('This attribute is used in the alternate BMCA as a tie-breaker in the\n         dataset comparison algorithm, in the event that all other previous\n         attributes of the datasets being compared are equal.')
ptpPortDestMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwardable", 1), ("nonForwardable", 2))).clone('nonForwardable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortDestMacAddress.setReference('Section 6.2.6 of [3]')
if mibBuilder.loadTexts: ptpPortDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: ptpPortDestMacAddress.setDescription('This attribute is used in to select the destination MAC address\n         inserted in the outgoing packets:\n           forwardable:    01-1B-19-00-00-00\n           nonForwardable: 01-80-C2-00-00-0E\n        ')
ptpPortTxAsymmetryCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortTxAsymmetryCompensation.setStatus('current')
if mibBuilder.loadTexts: ptpPortTxAsymmetryCompensation.setDescription('This attribute is used to compensate in nanoseconds the asymmetric\n         delay. It works in TX direction.')
ptpPortRxAsymmetryCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortRxAsymmetryCompensation.setStatus('current')
if mibBuilder.loadTexts: ptpPortRxAsymmetryCompensation.setDescription('This attribute is used to compensate in nanoseconds the asymmetric\n         delay. It works in RX direction.')
ptpPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ptpPortRowStatus.setStatus('current')
if mibBuilder.loadTexts: ptpPortRowStatus.setDescription("RowStatus for creating the entries into this table.\n         This object can't be modified.")
ptpPortAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2), )
if mibBuilder.loadTexts: ptpPortAlarmTable.setStatus('current')
if mibBuilder.loadTexts: ptpPortAlarmTable.setDescription('Table Contains PTP alarm information\n                 for a particular port of boundary or an ordinary clock.')
ptpPortAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"), (0, "SIAE-PTP-MIB", "ptpPortIndex"))
if mibBuilder.loadTexts: ptpPortAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: ptpPortAlarmEntry.setDescription('Contains PTP alarm information for a particular port.')
ptpPortFaultyAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1, 1), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortFaultyAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpPortFaultyAlarm.setDescription('This alarm is raised when ptpPortState is set to faulty(2).')
ptpPortInitializingAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1, 2), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortInitializingAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpPortInitializingAlarm.setDescription('This alarm is raised when ptpPortState is set to initializing(1).\n            ')
ptpPortUncalibratedAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1, 3), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortUncalibratedAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpPortUncalibratedAlarm.setDescription('This alarm is raised when ptpPortState is set to uncalibrated(8).\n            ')
ptpPortListeningAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1, 4), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortListeningAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpPortListeningAlarm.setDescription('This alarm is raised when ptpPortState is set to listening(4).\n            ')
ptpPortActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 2, 1, 5), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortActiveStatus.setStatus('current')
if mibBuilder.loadTexts: ptpPortActiveStatus.setDescription('This alarm is raised when ptpPortState is set to slave(9).\n            ')
ptpPortRadioAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 3), )
if mibBuilder.loadTexts: ptpPortRadioAlarmTable.setStatus('current')
if mibBuilder.loadTexts: ptpPortRadioAlarmTable.setDescription('Table Contains PTP alarm information\n                 for a radio port of boundary or an ordinary clock.')
ptpPortRadioAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 3, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpClockDomainIndex"), (0, "SIAE-PTP-MIB", "ptpClockTypeIndex"), (0, "SIAE-PTP-MIB", "ptpClockInstanceIndex"), (0, "SIAE-PTP-MIB", "ptpPortIndex"))
if mibBuilder.loadTexts: ptpPortRadioAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: ptpPortRadioAlarmEntry.setDescription('Contains PTP alarm information for a radio port.')
ptpPortRadioCapacityAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 3, 1, 1), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortRadioCapacityAlarm.setStatus('current')
if mibBuilder.loadTexts: ptpPortRadioCapacityAlarm.setDescription('This alarm is raised when the capacity of a radio link\n             is not big enough to transport PTP packets.')
ptpPortFaultyAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 4), AlarmSeverityCode().clone('majorTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortFaultyAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortFaultyAlarmSeverityCode.setDescription('This object defines the severity associated to\n             ptpPortFaultyAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpPortInitializingAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 5), AlarmSeverityCode().clone('warningTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortInitializingAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortInitializingAlarmSeverityCode.setDescription('This object defines the severity associated to\n             ptpPortInitializingAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpPortUncalibratedAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 6), AlarmSeverityCode().clone('warningTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortUncalibratedAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortUncalibratedAlarmSeverityCode.setDescription('This object defines the severity associated to\n             ptpPortUncalibratedAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpPortListeningAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 7), AlarmSeverityCode().clone('warningTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortListeningAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortListeningAlarmSeverityCode.setDescription('This object defines the severity associated to\n             ptpPortListeningAlarm and enables or disables the\n             sending of the SNMP Trap on the alarm status transition.\n            ')
ptpPortActiveStatusSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 8), AlarmSeverityCode().clone('statusTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortActiveStatusSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortActiveStatusSeverityCode.setDescription('This object enables or disables the sending of the SNMP Trap\n             on ptpPortActiveStatus transition.\n            ')
ptpPortRadioCapacityAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 8, 9), AlarmSeverityCode().clone('majorTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpPortRadioCapacityAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: ptpPortRadioCapacityAlarmSeverityCode.setDescription('This object enables or disables the sending of the SNMP Trap\n             on ptpPortRadioCapacityAlarm transition.\n            ')
ptpRadioAsymmetryDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 10, 1), )
if mibBuilder.loadTexts: ptpRadioAsymmetryDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpRadioAsymmetryDataSetTable.setDescription('Table contains delay offset for asymmetries compensation for the Radio unit.')
ptpRadioAsymmetryDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 10, 1, 1), ).setIndexNames((0, "SIAE-PTP-MIB", "ptpRadioBrIndex"))
if mibBuilder.loadTexts: ptpRadioAsymmetryDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpRadioAsymmetryDataSetEntry.setDescription('Each ntry contains delay offset for asymmetries compensation for a specific Radio unit.')
ptpRadioBrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpRadioBrIndex.setStatus('current')
if mibBuilder.loadTexts: ptpRadioBrIndex.setDescription("This is the index in radioTable of this unit.\n         This object can't be modified.")
ptpRadioOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 100, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpRadioOffset.setStatus('current')
if mibBuilder.loadTexts: ptpRadioOffset.setDescription('This object is an offset in nanoseconds for asymmetry compensation and \n\t\tcan have both positive and negative values.')
mibBuilder.exportSymbols("SIAE-PTP-MIB", ptpTimePropertiesDataSet=ptpTimePropertiesDataSet, ptpParentGMClockIdentity=ptpParentGMClockIdentity, ptpPortSyncInterval=ptpPortSyncInterval, ptpHoldoverOutOfSpecAlarmSeverityCode=ptpHoldoverOutOfSpecAlarmSeverityCode, ptpCurrentDataSetEntry=ptpCurrentDataSetEntry, ptpSpecificDataSet=ptpSpecificDataSet, ptpTimeCurrentUTCOffset=ptpTimeCurrentUTCOffset, ptpPortClockIdentity=ptpPortClockIdentity, ptpParentGMClockOffsetScaledLogVariance=ptpParentGMClockOffsetScaledLogVariance, ptpParentDataSetTable=ptpParentDataSetTable, ptpClockTypeIndex=ptpClockTypeIndex, ptpParentGMPriority1=ptpParentGMPriority1, ptpPortFaultyAlarm=ptpPortFaultyAlarm, ptpClockLocalPriority=ptpClockLocalPriority, ptpProfilePrimaryVersion=ptpProfilePrimaryVersion, ptpClockAccuracy=ptpClockAccuracy, ptpClockPPSAdminStatus=ptpClockPPSAdminStatus, ptpTimeDataSetEntry=ptpTimeDataSetEntry, ptpProfileName=ptpProfileName, ptpPortUncalibratedAlarm=ptpPortUncalibratedAlarm, ptpProfileRevisionNumber=ptpProfileRevisionNumber, ClockPortState=ClockPortState, ptpClockIdentity=ptpClockIdentity, ptpTimeTimeSource=ptpTimeTimeSource, ptpPortIndex=ptpPortIndex, PYSNMP_MODULE_ID=ptp, ptpRadioAsymmetryDataSetEntry=ptpRadioAsymmetryDataSetEntry, ptpClockPPSDataSetTable=ptpClockPPSDataSetTable, ptpSpecificDataSetEntry=ptpSpecificDataSetEntry, ClockType=ClockType, ptpPortRadioAlarmTable=ptpPortRadioAlarmTable, ptpCurrentOffsetFromMaster=ptpCurrentOffsetFromMaster, ptpProfileDataSet=ptpProfileDataSet, ptpClockPPSLabel=ptpClockPPSLabel, ptpPortState=ptpPortState, ptpClockState=ptpClockState, ptpParentPortNumber=ptpParentPortNumber, ptpClockToDFormat=ptpClockToDFormat, ptpClockOffsetScaledLogVariance=ptpClockOffsetScaledLogVariance, ptpPortFaultyAlarmSeverityCode=ptpPortFaultyAlarmSeverityCode, ptpFreeRunningAlarm=ptpFreeRunningAlarm, ptpPortUncalibratedAlarmSeverityCode=ptpPortUncalibratedAlarmSeverityCode, ptpParentClockIdentity=ptpParentClockIdentity, ptpPortDataSetTable=ptpPortDataSetTable, ptpPortListeningAlarmSeverityCode=ptpPortListeningAlarmSeverityCode, ptpClockPPSDataSetEntry=ptpClockPPSDataSetEntry, ptpCurrentDataSet=ptpCurrentDataSet, ptpCurrentStepsRemoved=ptpCurrentStepsRemoved, ptpClockToDDelay=ptpClockToDDelay, ptpPortNotSlave=ptpPortNotSlave, ptpRadioOffset=ptpRadioOffset, ptpTimeLeap61=ptpTimeLeap61, ptpPortDestMacAddress=ptpPortDestMacAddress, ptpClockInstanceIndex=ptpClockInstanceIndex, ClockQualityClassType=ClockQualityClassType, ptpHoldoverInSpecAlarm=ptpHoldoverInSpecAlarm, ptpHoldoverInSpecAlarmSeverityCode=ptpHoldoverInSpecAlarmSeverityCode, ptpParentDataSet=ptpParentDataSet, ptpClockRowStatus=ptpClockRowStatus, ptpSpecificAlarmEntry=ptpSpecificAlarmEntry, ptpCompliance=ptpCompliance, ptpPortDelayMechanism=ptpPortDelayMechanism, ClockDomainType=ClockDomainType, ptpRadioAsymmetryDataSet=ptpRadioAsymmetryDataSet, ptpParentGMClockClass=ptpParentGMClockClass, ptpTimeTimeTraceable=ptpTimeTimeTraceable, ptpProfileIdentifier=ptpProfileIdentifier, ptpTimeFrequencyTraceable=ptpTimeFrequencyTraceable, ptpParentGMPriority2=ptpParentGMPriority2, ptpClockPPSInstanceCapability=ptpClockPPSInstanceCapability, ptpClockPPSOffsetEnabled=ptpClockPPSOffsetEnabled, ptpTimeLeap59=ptpTimeLeap59, ptpClockClass=ptpClockClass, ptpClockPPSDataSet=ptpClockPPSDataSet, ptpClockPPSOffsetValue=ptpClockPPSOffsetValue, ptpPortTxAsymmetryCompensation=ptpPortTxAsymmetryCompensation, ptpClockTwoStepFlag=ptpClockTwoStepFlag, ClockMechanismType=ClockMechanismType, ptpRadioAsymmetryDataSetTable=ptpRadioAsymmetryDataSetTable, ClockTimeInterval=ClockTimeInterval, ClockStateType=ClockStateType, ptpPortIfIndex=ptpPortIfIndex, ptpPortInitializingAlarm=ptpPortInitializingAlarm, ptpSpecificDataSetTable=ptpSpecificDataSetTable, ptpTimeCurrentUTCOffsetValid=ptpTimeCurrentUTCOffsetValid, ptpPortStaticRole=ptpPortStaticRole, ptpClockSlaveOnly=ptpClockSlaveOnly, ptp=ptp, ptpPortRowStatus=ptpPortRowStatus, ptpClockPriority1=ptpClockPriority1, ptpPortAnnounceReceiptTimeout=ptpPortAnnounceReceiptTimeout, ptpPortRadioCapacityAlarmSeverityCode=ptpPortRadioCapacityAlarmSeverityCode, ptpSystemProfile=ptpSystemProfile, ptpPortRxAsymmetryCompensation=ptpPortRxAsymmetryCompensation, ptpClockPPSInstanceIndex=ptpClockPPSInstanceIndex, ptpClockToDLabel=ptpClockToDLabel, ptpPortDataSetEntry=ptpPortDataSetEntry, ptpAdminStatus=ptpAdminStatus, ptpClockPPSDirection=ptpClockPPSDirection, ptpHoldoverOutOfSpecAlarm=ptpHoldoverOutOfSpecAlarm, ptpPortRadioAlarmEntry=ptpPortRadioAlarmEntry, ptpPortLogAnnounceInterval=ptpPortLogAnnounceInterval, ptpCurrentDataSetTable=ptpCurrentDataSetTable, ptpPortActiveStatusSeverityCode=ptpPortActiveStatusSeverityCode, ClockTimeSourceType=ClockTimeSourceType, ptpClockToDBaudrate=ptpClockToDBaudrate, ptpDefaultDataSet=ptpDefaultDataSet, ptpPortActiveStatus=ptpPortActiveStatus, ptpClockPriority2=ptpClockPriority2, ptpClockNumberPorts=ptpClockNumberPorts, ptpClockDomainIndex=ptpClockDomainIndex, ptpMibVersion=ptpMibVersion, ptpTimeDataSetTable=ptpTimeDataSetTable, ptpPortRadioCapacityAlarm=ptpPortRadioCapacityAlarm, ptpPortListeningAlarm=ptpPortListeningAlarm, ClockPPSInstanceType=ClockPPSInstanceType, ptpPortMinDelayReqInterval=ptpPortMinDelayReqInterval, ptpRadioBrIndex=ptpRadioBrIndex, ptpPortVersionNumber=ptpPortVersionNumber, ClockPortNumber=ClockPortNumber, ptpParentGMClockAccuracy=ptpParentGMClockAccuracy, ptpClockDataSetEntry=ptpClockDataSetEntry, ptpParentDataSetEntry=ptpParentDataSetEntry, ptpPortAdminStatus=ptpPortAdminStatus, ptpClockDataSetTable=ptpClockDataSetTable, ptpFreeRunningAlarmSeverityCode=ptpFreeRunningAlarmSeverityCode, ptpPortAlarmTable=ptpPortAlarmTable, ptpCurrentMeanPathDelay=ptpCurrentMeanPathDelay, ptpPortInitializingAlarmSeverityCode=ptpPortInitializingAlarmSeverityCode, ptpTimescale=ptpTimescale, ClockQualityAccuracyType=ClockQualityAccuracyType, ptpClockToDAdminStatus=ptpClockToDAdminStatus, ptpPortAlarmEntry=ptpPortAlarmEntry, ptpPortDataSet=ptpPortDataSet, ClockInstanceType=ClockInstanceType, ptpStaticPortRole=ptpStaticPortRole, ptpPortLocalPriority=ptpPortLocalPriority, PtpClockToDFormatType=PtpClockToDFormatType, ClockProfileType=ClockProfileType, ptpSpecificAlarmTable=ptpSpecificAlarmTable)
