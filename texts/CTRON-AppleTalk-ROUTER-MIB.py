#
# PySNMP MIB module CTRON-AppleTalk-ROUTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-AppleTalk-ROUTER-MIB
# Produced by pysmi-1.1.12 at Wed May 29 10:05:21 2024
# On host fv-az775-27 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
nwRouter, nwRtrProtoSuites = mibBuilder.importSymbols("ROUTER-OIDS", "nwRouter", "nwRtrProtoSuites")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, iso, ObjectIdentity, Bits, TimeTicks, Integer32, ModuleIdentity, Counter64, IpAddress, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "iso", "ObjectIdentity", "Bits", "TimeTicks", "Integer32", "ModuleIdentity", "Counter64", "IpAddress", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Counter32")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
nwRtrExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4))
nwAtRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4))
nwAtMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 1))
nwAtComponents = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2))
nwAtSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1))
nwAtForwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2))
nwAtTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4))
nwAtFib = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5))
nwAtEndSystems = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6))
nwAtAccessControl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7))
nwAtFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 8))
nwAtRedirector = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 9))
nwAtEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10))
nwAtWorkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 11))
nwAtNetDiag = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12))
nwAtSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 1))
nwAtSysAdministration = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2))
nwAtFwdSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1))
nwAtFwdInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2))
nwAtFwdCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1))
nwAtFwdIfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1))
nwAtFwdIfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2))
nwAtDistanceVector = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1))
nwAtLinkState = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 2))
nwAtProto = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1))
nwAtProtoSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1))
nwAtProtoInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2))
nwAtProtoConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1))
nwAtProtoCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2))
nwAtProtoIfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1))
nwAtProtoIfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2))
nwAtHostsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 1))
nwAtHostsInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2))
nwAtHostsToMedia = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3))
nwAtEventLogConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 1))
nwAtEventLogFilterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2))
nwAtEventLogTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3))
nwAtNetDiagPing = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 1))
nwAtNetDiagTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 2))
nwAtNetDiagOutbound = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3))
class AtNetworkNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class AtDdpNodeAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class AtName(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 32)

nwAtMibRevText = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtMibRevText.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtMibRevText.setDescription('Indicates the current revision level of the Cabletron at\n         Routing Services MIB in textual format.')
nwAtSysRouterId = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 1, 1), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtSysRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysRouterId.setDescription('The AppleTalk node address used to uniquely identify the\n        host (device) running the AppleTalk Routing Services. The\n        value of nwAtSysRouterId is equal to the highest AppleTalk\n        node address assigned to any router port.')
nwAtSysAdminSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtSysAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysAdminSTATUS.setDescription('Sets the administrative state of AppleTalk Routing\n        Services system wide. Enabled (3) causes AppleTalk Routing\n        Services to become active on all router ports configured\n        and enabled for AppleTalk Routing Services. Disabled (2)\n        causes AppleTalk Routing Services to become inactive\n        system-wide.')
nwAtSysOperSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtSysOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysOperSTATUS.setDescription('Indicates the operating condition of AppleTalk Routing\n        Services system- wide. The value of nwAtSysOperStatus\n        indicates any problem with your AppleTalk Routing Services\n        configuration. A value of 6 indicates that regardless of\n        the value of nwAtSysAdminStatus, AppleTalk Routing\n        Services is not operating because of an invalid\n        configuration.')
nwAtSysAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtSysAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysAdminReset.setDescription('Resets AppleTalk Routing Services system-wide. Reset (2)\n        forces a restart of AppleTalk Routing Services without a\n        graceful shutdown on any active router ports and without\n        affecting any other routing services.')
nwAtSysOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtSysOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwAtSysOperStatus has been in its current state.')
nwAtSysVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 1, 2, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtSysVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtSysVersion.setDescription('Indicates the current revision level of the AppleTalk\n        Routing Services firmware, in textual format.')
nwAtFwdCtrAdminSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdCtrAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrAdminSTATUS.setDescription('Sets the administrative state of the aggregate\n        (system-wide) AppleTalk packet and byte counters. \n        Enabled (3) causes these counters to become active. \n        Disabled (2) causes these counters to become inactive.')
nwAtFwdCtrReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrReset.setDescription('Reset(2) resets the aggregate (system-wide) AppleTalk\n        packet and byte counters. Reset (2) resets the AppleTalk\n        aggregate counters to 0.nwAtFwdCtrOperationalTime is also\n        reset to 0.')
nwAtFwdCtrOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwAtFwdCtrAdminStatus has been in the current state.')
nwAtFwdCtrInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrInPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been received, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrOutPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been transmitted, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrFwdPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrFwdPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been forwarded, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrFilteredPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been administratively filtered, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrDiscardPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrAddrErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrAddrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrAddrErrPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded, system-wide, during\n        nwAtFwdCtrOperationalTime because of addressing errors\n        in the AppleTalk header.')
nwAtFwdCtrLenErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrLenErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrLenErrPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded, system-wide, during\n        nwAtFwdCtrOperationalTime, because an invalid packet\n        length is contained in the AppleTalk header.')
nwAtFwdCtrHdrErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHdrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHdrErrPkts.setDescription('Indicates the total number of at packets that have been\n         discarded, device-wide, during nwAtFwdCtrOperationalTime,\n         because of an invalid at header.')
nwAtFwdCtrInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrInBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been received, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been transmitted, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrFwdBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrFwdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrFwdBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been forwarded, system-wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrFilteredBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrFilteredBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been administratively filtered,\n        system-wide, during nwAtFwdCtrOperationalTime.')
nwAtFwdCtrDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been discarded, system wide, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrHostInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostInPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been successfully delivered to the local host, \n        during nwAtFwdCtrOperationalTime.')
nwAtFwdCtrHostOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostOutPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been transmitted by the local host, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrHostDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostDiscardPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded by the local host, during\n        nwAtFwdCtrOperationalTiime, due to a lack of host\n        resources.')
nwAtFwdCtrHostInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostInBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been received by the local host, during\n        nwAtFwdCtrOperationalTime.')
nwAtFwdCtrHostOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been transmitted by the local host,\n        during nwAtFwdCtrOperationalTime.')
nwAtFwdCtrHostDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdCtrHostDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdCtrHostDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been discarded by the local host,\n        during nwAtFwdCtrOperationalTime, due to a lack of host\n        resources.')
nwAtFwdIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1), )
if mibBuilder.loadTexts: nwAtFwdIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfTable.setDescription('This table contains an entry for each router port.\n        This table is indexed by nwAtFwdIfIndex, which indicates\n        the value of MIB 2 ifindex, which identifies the router\n        port for which each entry exists.')
nwAtFwdIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtFwdIfIndex"))
if mibBuilder.loadTexts: nwAtFwdIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfEntry.setDescription('Each entry specifies the AppeTalk Routing Services\n        configuration for the router port for which the entry\n        exists.')
nwAtFwdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfIndex.setDescription('Indicates the value of the MIB 2 ifIndex, which\n        identifies the router port for which the entry exists.')
nwAtFwdIfAdminSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfAdminSTATUS.setDescription('Sets the administrative state of AppleTalk Routing\n        Services on the router port for which the entry exists.\n        Enabled (3) causes AppleTalk Routing Services to become\n        active. Disabled (2) causes it to become inactive.')
nwAtFwdIfOperSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfOperSTATUS.setDescription('Indicates the current operating condition of AppleTalk\n        Routing Services on the AppleTalk router port for which\n        the entry exists. The value of nwAtFwdIfOperStatus\n        indicates any problem with the configuration of AppleTalk\n        Routing Services on the router port. A value of 6 \n        indicates that regardless of the state of\n        nwAtFwdIfAdminStatus AppleTalk Routing Services is not\n        operating because of an invalid port-level configuration.')
nwAtFwdIfOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwAtFwdIfOper Status has been in its current state.')
nwAtFwdIfControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("add", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfControl.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol-specific MIBs. Setting this \n        object has no effect.')
nwAtFwdIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfMtu.setDescription('Specifies the Maximum Transmissions Unit (MTU) for\n        AppleTalk packets on the router port for which the entry\n        exists. This includes the AppleTalk header and data, but\n        does not include framing.')
nwAtFwdIfForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfForwarding.setDescription('Controls forwarding of AppleTalk packets on the \n        AppleTalk router port for which the entry exists.\n        Enabled (3) causes AppleTalk packets to be forwarded.\n        Disabled (2) prevents AppleTalk packets from being\n        forwarded.')
nwAtFwdIfFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 9, 11, 16, 17))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("snap", 3), ("nativewan", 8), ("encapenet", 9), ("encapenetsnap", 11), ("encapfddisnap", 16), ("canonical", 17))).clone('snap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfFrameType.setDescription('Specifies the framing type for AppleTalk packets forwarded on the\n        router port for which the entry exists.  Some frame types are only\n        valid for specific media types.  The comments reflect those valid\n        media types.')
nwAtFwdIfAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfAclIdentifier.setDescription('Specifies the Access Control ID of the access control\n        list in effect for AppleTalk packets being routed on\n        the router port for which the entry exists. A value of 0\n        indicates that no access control list is in effect.')
nwAtFwdIfAclSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfAclSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfAclSTATUS.setDescription('Controls the operation of any access control list\n        configured for AppleTalk traffic on the router port for\n        which the entry exists. Enabled (3) applies the access\n        control list indicated by the value of\n        nwAtFwdIfAclIdentifier to all AppleTalk traffic being\n        routed on the port. Disabled (2) prevents the access \n        control list from being applied.')
nwAtFwdIfCacheControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfCacheControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCacheControl.setDescription('Controls AppleTalk Address caching on the router port\n        for which the entry exists. When AppleTalk Address\n        caching is enabled, AppleTalk Addresses used for address\n        validation, filtering, and forwarding are stored in the\n        cache. This cache is checked first before doing a full\n        route table lockup, which speeds up the switching process.\n        Enabled (3) turns on AppleTalk Address caching. \n        Disabled (2) turns it off.')
nwAtFwdIfCacheEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCacheEntries.setDescription('Indicates the number of entries in the AppleTalk Address\n        cache on the router port for which the entry exists.')
nwAtFwdIfCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCacheHits.setDescription('Indicates the number of times entries in the AppleTalk\n        Address cache have been used to provide the AppleTalk\n        address required to validate, filter, or forward an\n        AppleTalk packet on the router port.')
nwAtFwdIfCacheMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCacheMisses.setDescription('Indicates the number of times the AppleTalk Address\n        required to validate, filter, or forward an AppleTalk\n        packet on the router port was not found in the AppleTalk\n        Address cache.')
nwAtportTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2), )
if mibBuilder.loadTexts: nwAtportTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportTable.setDescription('This table contains an entry for each router port\n        configured for AppleTalk Routing Services.')
nwAtportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtportIndex"))
if mibBuilder.loadTexts: nwAtportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportEntry.setDescription('Each entry specifies the AppleTalk address information\n        for the router port for which the entry exists.')
nwAtportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportIndex.setDescription('Indicates a unique value for each router port. The value\n        of nwAtportIndex is an integer between 1 and the total\n        number of ports configured for AppleTalk Routing \n        Services.')
nwAtportDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportDescr.setDescription('This text string provides a description of the port to\n        the end-user; it must not contain anything but printable\n        ASCII characters.')
nwAtportType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("other", 1), ("localtalk", 2), ("ethertalk1", 3), ("ethertalk2", 4), ("tokentalk", 5), ("iptalk", 6), ("serialPPP", 7), ("serialNonstandard", 8), ("virtual", 9), ("fdditalk", 10), ("arctalk", 11), ("smdstalk", 12), ("aurp", 13), ("frameRelay", 14), ("x25", 15), ("ip", 16), ("osi", 17), ("decnetIV", 18), ("arap", 19), ("isdnInThePacketMode", 20), ("nonAppleTalk3Com", 21), ("ipx", 22), ("arns", 23), ("hdlc", 24)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportType.setDescription('The value of nwArPortType indicates which link-layer\n        protocol is running immediately below DDP in the protocol\n        stack on the router port for which the entry exists. The\n        value of nwAtPortType determines the format of address\n        octet stings throughout the entire AppleTalk MIB.')
nwAtportNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 4), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportNetStart.setDescription('The first AppleTalk network address in the network range\n        configured for the port. If the port is not a native\n        AppleTalk port, this object will have the value of two\n        octets of zero. Set this value to the first network \n        address in the network range configured for the port.')
nwAtportNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 5), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportNetEnd.setDescription('The last AppleTalk network address in the network range\n        configured for the port. If the network to which this\n        AppleTalk port is connected is a non-extended network, or\n        if it is not a native AppleTalk port, the value for\n        nwAtportNetEnd will be two octets of zero. Set this value\n        to the last network address in the network range\n        configured for the port.')
nwAtportNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 6), AtDdpNodeAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportNetAddress.setDescription('The AppleTalk node number configured for the port. This\n        value may be used as a hint for an initial node number\n        used during node-finding. If the port is not a native\n        AppleTalk port, this object shall have the value of \n        three octets of zero.')
nwAtportSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("routing", 1), ("unconfigured", 2), ("off", 3), ("invalid", 4), ("endNode", 5), ("offDueToConflict", 6), ("other", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportSTATUS.setDescription("Indicates the current state of the router port's\n        AppleTalk configuration. If either nwAtportNetConfig or\n        nwApportZoneConfig are set to (5), conflictAverseSeed, \n        and either the configured network number range or zone\n        name seeded by the port conflict with the settings of a\n        neighbor router, nwApPortStatus will have a value of (6),\n        offDueToConflict.")
nwAtportNetConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("conflictOrientedSeed", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4), ("conflictAverseSeed", 5), ("softSeed", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportNetConfig.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportNetConfig.setDescription('Specifies the network configuration type of the port.\n        If the port is not a native AppleTalk port, this object \n        will have an unconfigured (4) value.')
nwAtportZoneConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("conflictOrientedSeed", 1), ("garnered", 2), ("guessed", 3), ("unconfigured", 4), ("conflictAverseSeed", 5), ("softSeed", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportZoneConfig.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneConfig.setDescription('Specifies the zone information configuration type of the port. If the port is not a native AppleTalk port, this object will have an unconfigured (4) value.')
nwAtportZoneDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 10), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportZoneDefault.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneDefault.setDescription('Specifies the name of the default zone for the port. If \n        the port only has one zone, that zone is represented\n        here. If the port is not a native AppleTalk port, this\n        object will contain an octet string of zero length.')
nwAtportIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportIfIndex.setDescription('Indicates the value of MIB 2 ifIndex, which identifies\n        the router port for which the entry exists.')
nwAtportNetFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 12), AtDdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportNetFrom.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportNetFrom.setDescription('When nwAtportNetConfig is set to garnered (2), this\n        variable contains the DDP address of the entity from \n        which the AppleTalk network number was garnered. When\n        nwAtportNetConfig is set to conflictOrientedSeed (1),\n        conflictAverseSeed (5), or softSeed (6), this variable\n        contains the DDP address of an entity which supplied or\n        confirmed the AppleTalk network number. If \n        nwAtportNetConfig is set to guessed (3) or \n        unconfigured (4), or if the AppleTalk Routing\n        Services-enabled device has not received any network \n        number confirmation, this object will be set to three \n        octets of zero.')
nwAtportZoneFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 13), AtDdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportZoneFrom.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneFrom.setDescription('When nwAtportZoneConfig is set to garnered (2), this\n        variable contains the DDP address of the entity from\n        which the AppleTalk Zone List was garnered. When\n        nwAtportZoneConfig is set to conflictOrientedSeed (1),\n        conflictAverseSeed (5), or softSeed (6), this variable\n        contains the DDP address of an entity which supplied or\n        confirmed the AppleTalk zone information. If\n        nwAtportZoneConfig is set to guessed (3) or unconfigured\n        (4), or if the AppleTalk Routing Services-enabled device\n        has not received any zone confirmation, this object will\n        be set to three octets of zero.')
nwAtportInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportInPkts.setDescription('The total number of AppleTalk packets received on the\n        port.')
nwAtportOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportOutPkts.setDescription('The total number of AppleTalk packets transmitted on the\n        port.')
nwAtportHome = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("home", 1), ("notHome", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportHome.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportHome.setDescription("The value of nwAtportHome indicates whether or not the\n        AppleTalk Routing Services-enabled device, the routing\n        entity, is `homed' on the port for which the entry exists.\n        If the entity is homed on the port, then it could perform\n        NBP (Name Binding Protocol) registrations for services\n        that it chooses to advertise.")
nwAtportCurrentZone = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 17), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportCurrentZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportCurrentZone.setDescription('Specifies the current zone name for the port. In \n        general, this is the zone name in which services on the\n        port will be registered. If the port is not a native\n        AppleTalk port, this object will contain an octet string\n        of zero length.')
nwAtportConflictPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 1, 2, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportConflictPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportConflictPhysAddr.setDescription('Indicates the link-layer address of the device which\n        caused nwAtportStatus to be set to off (3). If this\n        address is not available, or if nwAtportStatus is not\n        set to off, this object will be a zero length octet\n        string.')
nwAtFwdIfCtrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1), )
if mibBuilder.loadTexts: nwAtFwdIfCtrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrTable.setDescription('This table contains an entry for each router port\n        configured and enabled for AppleTalk Routing Services.')
nwAtFwdIfCtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtFwdIfCtrIfIndex"))
if mibBuilder.loadTexts: nwAtFwdIfCtrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrEntry.setDescription('Each entry indicates the current packet and byte count\n        of AppleTalk packets on the router port for which the\n        entry exists.')
nwAtFwdIfCtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrIfIndex.setDescription('Indicates the value MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwAtFwdIfCtrAdminSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfCtrAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrAdminSTATUS.setDescription('Sets the administrative state of the per-port AppleTalk\n        packet and byte counters on the router port for which\n        the entry exists. Enabled (3) causes these counters to\n        become active. Disabled (2) causes these counters to\n        become inactive.')
nwAtFwdIfCtrReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtFwdIfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrReset.setDescription('Resets the per-port AppleTalk packet and byte counters\n        on the router port for which the entry exists. Reset (2)\n        resets the counters to 0. nwAtFwdIfCtrOperationalTime is\n        also reset to 0.')
nwAtFwdIfCtrOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrOperationalTime.setDescription('Indicates the amount of time, in hundredths of a second,\n        that nwAtFwdIfCtrAdminStatus has been in the current\n        state.')
nwAtFwdIfCtrInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrInPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been received, during nwAtFwdIfCtrOperationaltime, \n        on the router port for which the entry exists.')
nwAtFwdIfCtrOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrOutPkts.setDescription('Indicates the total number of AppleTalk packets that \n        have been transmitted, during nwAtFwdIfCtrOperationaltime,\n        on the router port for which the entry exists.')
nwAtFwdIfCtrFwdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrFwdPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been forwarded, during nwAtFwdIfCtrOperationaltime,\n        on the router port for which the entry exists.')
nwAtFwdIfCtrFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrFilteredPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been administratively filtered, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrDiscardPkts.setDescription('Indicates the total number of AppleTalk packets that \n        have been discarded (dropped), during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrAddrErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrAddrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrAddrErrPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded, because of addressing errors in the\n        AppleTalk header, during nwAtFwdIfCtrOperationalTime,\n        on the router port for which the entry exists.')
nwAtFwdIfCtrLenErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrLenErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrLenErrPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been discarded, because an invalid packet length\n        was contained in the AppleTalk header, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrHdrErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHdrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHdrErrPkts.setDescription('Indicates the total number of AppleTalk packets that \n        have been discarded, because of an invalid AppleTalk\n        header, during nwAtFwdIfCtrOperationalTime, on the router\n        port for which the entry exists.')
nwAtFwdIfCtrInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrInBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been received, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been transmitted, durin\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrFwdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrFwdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrFwdBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been forwarded, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrFilteredBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been administratively filtered, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been discarded, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrHostInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostInPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been successfully delivered to the local host during\n        nwAtFwdIfCtrOperationalTime, that were received on the\n        router port for which the entry exists.')
nwAtFwdIfCtrHostOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostOutPkts.setDescription('Indicates the total number of AppleTalk packets that\n        have been transmitted by the local host, during\n        nwAtFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwAtFwdIfCtrHostDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostDiscardPkts.setDescription('Indicates the total number of AppleTalk packets that \n        have been discarded by the local host due to a lack of\n        host resources during nwAtFwdIfCtrOperationalTime, that\n        were received on the router port for which the entry\n        exists.')
nwAtFwdIfCtrHostInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostInBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been successfully delivered to the\n        local host, during nwAtFwdIfCtrOperationalTime, that\n        were received on the router port for which the entry\n        exists.')
nwAtFwdIfCtrHostOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been transmitted by the local host,\n        during nwAtFwdIfCtrOperationalTime, on the router port\n        for which the entry exists.')
nwAtFwdIfCtrHostDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 2, 2, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFwdIfCtrHostDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFwdIfCtrHostDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        packets that have been discarded by the local host, due\n        to a lack of host resources during\n        nwAtFwdIfCtrOperationalTime, that were received on the\n        router port for which the entry exists.')
nwAtProtoAdminSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoAdminSTATUS.setDescription('Sets the administrative state of the AppleTalk\n        distance-vector based routing protocol system-wide. \n        Enabled (3) causes the routing protocol to become active\n        on all router ports configured and enabled for AppleTalk\n        Routing Services. Disabled (2) causes the routing protocol\n        to become inactive.')
nwAtProtoOperSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoOperSTATUS.setDescription('Indicates the current operating condition of the\n        AppleTalk Routing Services distance-vector-based routing\n        protocol, system-wide. The value of nwAtProtoOperStatus\n        indicates any problem with the routing protocol\n        configuration. A value of 6 indicates that regardless of \n        the value of nwAtProtoAdminStatus, the routing protocol\n        is not operating because of an invalid configuration.')
nwAtProtoAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoAdminReset.setDescription('Resets the routing protocol. Reset (2) forces a\n        system-wide restart of the protocol without a graceful\n        shutdown on any active router ports.')
nwAtProtoOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwAtProtoOperStatus has been in the current state.')
nwAtProtoVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoVersion.setDescription('Indicates the current revision level of the AppleTalk\n        routing protocol firmware, in textual format.')
nwAtProtoStackSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoStackSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoStackSize.setDescription('Specifies the stack size of the AppleTalk routing \n        protocol thread. In order for a change of this value to\n        take effect, the protocol (nwAtProtoAdminReset), \n        AppleTalk Routing Services (nwAtProtoAdminReset), or the\n        device running Routing Services must be reset.')
nwAtProtoThreadPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoThreadPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoThreadPriority.setDescription('Specifies the run-time execution priority of the\n        AppleTalk routing protocol thread. In order for a change\n        of this value to take effect, the AppleTalk protocol\n        (nwAtProtoAdminReset), AppleTalk Routing Services\n        (nwAtProtoAdminReset), or the device running Routing\n        Services must be reset.')
nwAtProtoDatabaseThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoDatabaseThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoDatabaseThreshold.setDescription('Specifies the run-time maximum number of entries that\n        can be held in the AppleTalk routing protocol route\n        table.')
nwAtProtoAgeOut = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoAgeOut.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoAgeOut.setDescription('Specifies the amount of time (in seconds) an inactive entry\n                will be allowed to remain in the AppleTalk routing protocol routing table, before it is deleted, or aged-out.')
nwAtProtoHoldDown = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoHoldDown.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol-specific MIBs. Setting this\n        object has no effect.')
nwAtProtoCtrAdminSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoCtrAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrAdminSTATUS.setDescription('Sets the administrative state of the aggregate\n        (system-wide) AppleTalk routing protocol packet and byte\n        counters. Enabled (3)causes these counters to become\n        active. Disabled (2) causes these counters to be come\n        inactive.')
nwAtProtoCtrReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrReset.setDescription('Resets the aggregate (system-wide) AppleTalk\n        distance-vector based routing protocol packet and byte\n        counters. Reset (2) resets the AppleTalk aggregate \n        counters to 0. nwAtProtoCtrOperationalTime is also reset\n        to 0.')
nwAtProtoCtrOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrOperationalTime.setDescription('Indicates the elapsed time, in hundreds of seconds, that\n        nwAtProtoCtrAdminStatus, has been in the current\n        administrative state.')
nwAtProtoCtrInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrInPkts.setDescription('Indicates the total number of AppleTalk routing protocol\n        packets that have been received, system-wide, during\n        nwAtProtoCtrOperationalTime.')
nwAtProtoCtrOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrOutPkts.setDescription('Indicates the total number of AppleTalk routing protocol\n        packets that have been transmitted, system-wide, during\n        nwAtProtoCtrOperationalTime.')
nwAtProtoCtrFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrFilteredPkts.setDescription('Indicates the total number of AppleTalk routing protocol\n        packets that have been administratively filtered,\n        system-wide, during nwAtProtoCtrOperationalTime.')
nwAtProtoCtrDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrDiscardPkts.setDescription('Indicates the total number of AppleTalk routing protocol\n        packets that have been discarded, system-wide, during\n        nwAtProtoCtrOperationalTime.')
nwAtProtoCtrInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrInBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        routing protocol packets that have been received,\n        system-wide, during nwAtProtoCtrOperationalTime.')
nwAtProtoCtrOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        routing protocol packets that have been transmitted,\n        system-wide, during nwAtProtoCtrOperationalTime.')
nwAtProtoCtrFilteredBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrFilteredBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        routing protocol packets that have been administratively\n        filtered, system-wide, during \n        nwAtProtoCtrOperationalTime.')
nwAtProtoCtrDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoCtrDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk\n        routing protocol packets that have been discarded,\n        system-wide during nwAtProtoCtrOperationalTime.')
nwAtProtoIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: nwAtProtoIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfTable.setDescription('This table contains an entry for each router port. Each\n        entry can contain different values, allowing the routing\n        protocol configuration to vary from router port to router\n        port. This table is indexed by nwAtProtoIfIndex, which\n        indicates the value of MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwAtProtoIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtProtoIfIndex"))
if mibBuilder.loadTexts: nwAtProtoIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfEntry.setDescription('Each entry contains the AppleTalk routing protocol\n        configuration for the router port for which the entry\n        exists.')
nwAtProtoIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwAtProtoIfAdminSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfAdminSTATUS.setDescription('Sets the administrative state of the AppleTalk routing\n        protocol on the router port for which the entry exists.\n        Enabled (3) causes the routing protocol to become active\n        on the router port. Disabled (2) causes it to become\n        inactive.')
nwAtProtoIfOperSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfOperSTATUS.setDescription('Indicates the current operating condition of the\n        AppleTalk routing protocol on the router port for which\n        the entry exists. The value of nwAtProtoIfOperStatus\n        indicates any problem with your AppleTalk routing \n        protocol configuration on the router port. A value of 6\n        indicates that regardless of the value of\n        nwAtProtoIfAdminStatus, the routing protocol is not\n        operating on the router port because of an invalid\n        configuration.')
nwAtProtoIfOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfOperationalTime.setDescription('Indicates the elapsed time, in hundreds of seconds, that\n        nwAtProtoIfOperStatus has been in the current state.')
nwAtProtoIfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfVersion.setDescription('Indicates the revision level of AppleTalk routing \n        protocol firmware on the router port for which the entry\n        exists, in textual format.')
nwAtProtoIfAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 6), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfAdvertisement.setDescription('This specifies the periodic interval (in seconds) that the\n                AppleTalk routing protocol agent will advertise routes on this\n        DECnet routing port.')
nwAtProtoIfFloodDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfFloodDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfFloodDelay.setDescription('This object does not apply to this protocol. It is a \n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the \n        Cabletron Routing Services protocol specific MIBs. \n        Setting this object has no effect')
nwAtProtoIfRequestDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfRequestDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfRequestDelay.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol specific MIBs. Setting this\n        object has no effect.')
nwAtProtoIfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfPriority.setDescription('Sets the priority of the AppleTalk routing protocol on\n        the router port for which the entry exists.')
nwAtProtoIfHelloTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfHelloTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfHelloTimer.setDescription('This object does not apply to this protocol. It is a \n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the \n        Cabletron Routing Services protocol specific MIBs. \n        Setting this object has no effect.')
nwAtProtoIfSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfSplitHorizon.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfSplitHorizon.setDescription('Sets the operating condition of Split Horizon on the \n        router port for which the entry exists. When Split Horizon\n        is enabled, the AppleTalk routing protocol keeps track of\n        which router port route information is received on, and\n        prevents information about a route form being sent back\n        out the same router port it was received on.')
nwAtProtoIfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfPoisonReverse.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfPoisonReverse.setDescription('Sets the operating condition of Poison Reverse on the\n        router port for which the entry exists. When Poison\n        Reverse is enabled, the AppleTalk routing protocol\n        advertises any downed routes as unreachable during the\n        period of time that it must wait before removing the \n        route from the route table.')
nwAtProtoIfSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfSnooping.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfSnooping.setDescription('Controls the operation of AppleTalk routing protocol\n        Snooping on the router port. When AppleTalk routing \n        protocol Snooping is enabled, the routing protocol \n        operates in passive mode, so that it receives route\n        information, builds and maintains a route table, but \n        does not advertise or send updates on the router port for\n        which the entry exists.')
nwAtProtoIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("bma", 2), ("nbma", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfType.setDescription('Indicates whether the directly connected network \n        segment does or does not support broadcast media access.\n        If broadcast media access is supported, AppleTalk routing\n        protocol advertisements are sent out one broadcast packet\n        per port. If broadcast media is not supported, AppleTalk\n        routing protocol advertisements are sent to each\n        neighbor.')
nwAtProtoIfXmitCost = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfXmitCost.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfXmitCost.setDescription('Sets the cost of transmitting a packet on the network\n        segment connected to router port for which the entry\n        exists.')
nwAtProtoIfAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfAclIdentifier.setDescription('Specifies the Access Control List ID of the access \n        control list in effect for AppleTalk routing protocol\n        packets on the router port for which the entry exists. A\n        value of 0 indicates that there is no access control list\n        in effect for AppleTalk routing protocol packets on the\n        router port.')
nwAtProtoIfAclSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfAclSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfAclSTATUS.setDescription('Controls the operation of the access control list\n        identified by nwAtProtoIfAclIdentifier. Enabled (3)\n        causes the access control list to be applied to all\n        AppleTalk routing protocol packet traffic on the router\n        port for which the entry exists. Disabled (2) prevents \n        the access control list from being applied.')
nwAtProtoIfCtrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: nwAtProtoIfCtrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrTable.setDescription('This table contains the AppleTalk packet and byte counters for\n                each router port on this device.')
nwAtProtoIfCtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtProtoIfCtrIfIndex"))
if mibBuilder.loadTexts: nwAtProtoIfCtrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrEntry.setDescription('Each entry specifies the DECnet Phase IV packet and byte\n         counters on a per router port basis.')
nwAtProtoIfCtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrIfIndex.setDescription('This is the primary index into the AppleTalk interface counter\n                table.  This number corresponds to the index into the mib2\n                InterfaceTable which describes the router port for which\n                the entry exists.')
nwAtProtoIfCtrAdminSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfCtrAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrAdminSTATUS.setDescription('Sets the administrative state of the AppleTalk packet and byte\n                counters on the router port for which the entry exists.\n        enabled(3) causes these counters to become active on the\n        configured AppleTalk router port. disabled(2) causes these\n        counters to become inactive on the configured AppleTalk router\n        port.')
nwAtProtoIfCtrReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtProtoIfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrReset.setDescription('Resets the AppleTalk packet and byte counters on the router\n        port for which the entry exists. reset (2) resets the\n        interface-specific counters to 0. \n        nwAtProtoIfCtrOperationalTime is also reset to 0.')
nwAtProtoIfCtrOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrOperationalTime.setDescription('Indicates the amount of time (No. of time ticks) that the\n                interface-specific AppleTalk packet and byte counters have been\n        active on the router port for which the entry exists.')
nwAtProtoIfCtrInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrInPkts.setDescription('Indicates the total number of AppleTalk packets that have been\n                received, on the router port for which the entry exists,\n        during nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrOutPkts.setDescription('Indicates the total number of AppleTalk packets that have been forwarded, on the router port for which the entry exists, during  nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrFilteredPkts.setDescription('Indicates the total number of AppleTalk packets that have been\n                administratively filtered, on the router port for which this\n                entry exists, during nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrDiscardPkts.setDescription('Indicates the total number of AppleTalk packets that have been discarded, on the router port for which the entry exists, during\nnwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrInBytes.setDescription('Indicates the total number of bytes in the AppleTalk packets that have been received, on the router port for which the entry exists, during nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrOutBytes.setDescription('Indicates the total number of bytes in the AppleTalk packets that have been forwarded, on the router port for which the entry exists, during nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrFilteredBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the AppleTalk packets that have been administratively filtered, that were received on the router port for which the entry exists, during nwAtProtoIfCtrOperationalTime.')
nwAtProtoIfCtrDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 4, 1, 1, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtProtoIfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtProtoIfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the AppleTalk packets that have been discarded, that were received on the router port for\n                which the entry exists, during nwAtIfCtrOperationalTime.')
nwAtFibTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1), )
if mibBuilder.loadTexts: nwAtFibTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibTable.setDescription('This table contains an entry for each route being used \n        to forward AppleTalk data packets.')
nwAtFibEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtFibStartNet"))
if mibBuilder.loadTexts: nwAtFibEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibEntry.setDescription('Each entry in the table describes an AppleTalk route \n        to a particular destination.')
nwAtFibStartNet = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 1), AtNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibStartNet.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibStartNet.setDescription('Indicates the start of the network range for the route.')
nwAtFibEndNet = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 2), AtNetworkNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibEndNet.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibEndNet.setDescription('Indicates the end of the network range for the route.')
nwAtFibNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 3), AtDdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibNextHop.setDescription('Indicates the full AppleTalk network address of the \n        next hop router for the route. An address of all zeros\n        indicates a directly connected net.')
nwAtFibNextHopIf = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibNextHopIf.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibNextHopIf.setDescription('Indicates the value of MIB 2 ifindex, which identifies\n        the router port through which the next hop node exists.\n        Packets destined for the network specified by the entry\n        will be forwarded on this router port.')
nwAtFibHops = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibHops.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibHops.setDescription('Indicates the number of hops required to reach the\n        destination for which the entry exists. It is considered\n        as metric 1.')
nwAtFibRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("appleTalk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtFibRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtFibRouteType.setDescription('Indicates the type of route (Allows for PPP entries\n        later).')
nwAtHostsTimeToLive = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostsTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostsTimeToLive.setDescription('Indicates the amount of time (in minutes) that an entry\n        can remain in the AARP cache.')
nwAtHostsRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostsRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostsRetryCount.setDescription('Indicates the maximum number of times AppleTalk Routing\n        Services will retry each attempt to resolve a host\n        address.')
nwAtHostCtlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1), )
if mibBuilder.loadTexts: nwAtHostCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlTable.setDescription('This table contains the control information for \n        maintaining an AARP cache on each router port. Note that\n        the cache entries are maintained by theAppleTalk Address\n        Resolution Protocol Table of the AppleTalk MIB.')
nwAtHostCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtHostCtlIfIndex"))
if mibBuilder.loadTexts: nwAtHostCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlEntry.setDescription('Each entry contains the control information for the ARP\n        cache on the router port indicated by the value\n        nwAtHostCtlIfIndex.')
nwAtHostCtlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlIfIndex.setDescription('Indicates the value of MIB2 ifindex, which identifies \n        the router port for which the entry exists.')
nwAtHostCtlAdminSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlAdminSTATUS.setDescription('Sets the administrative state of the AARP cache on the\n        router port for which the entry exists. Enabled (3) causes\n        AARP caching to become active. Disabled (2) causes AARP\n        caching to perform a graceful shutdown.')
nwAtHostCtlOperSTATUS = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlOperSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlOperSTATUS.setDescription('Indicates the current operating condition of the AARP\n        Table on the router port for which the entry exists.')
nwAtHostCtlOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlOperationalTime.setDescription('Indicates the amount of time, in hundredths of a second,\n        that nwAtHostCtlOperStatus has been in the current state.')
nwAtHostCtlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlProtocol.setDescription('Controls the operation of the AARP protocol on the\n        router port for which the entry exists.')
nwAtHostCtlSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlSnooping.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlSnooping.setDescription('Controls AARP Snooping on the router port for which the\n        entry exists. Given the AARP protocol is enabled,\n        setting nwAtHostCtlIfSnooping to enabled (3) turns on AARP Snooping.\n        When AARP Snooping is enabled the source AppleTalk and physical \n        addresses of all AARP packets received on the router port are added to\n        the AARP Table.')
nwAtHostCtlProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlProxy.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlProxy.setDescription('This object does not apply to this protocol. It is a \n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol-specific MIBs. Setting this\n        object has no effect.')
nwAtHostCtlCacheMax = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlCacheMax.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlCacheMax.setDescription('Indicates the maximum number of entry slots the AARP\n        cache can consist of. nwAtHostCtlCacheMax cannot be set\n        to less than 16. Setting this value does not allocate \n        any memory for the cache.')
nwAtHostCtlCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostCtlCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlCacheSize.setDescription('Indicates the current number of entry slots in the AARP\n        cache on the router port for which the entry exists. The\n        cache automatically resizes to accommodate all entries \n        up to the maximum number of entries set by\n        nwAtHostCtlCacheMax.')
nwAtHostCtlNumStatics = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlNumStatics.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlNumStatics.setDescription('Indicates the total number of static entries in the AARP\n        cache on the router port for which the entry exists.\n        Static entries remain in the cache until they are\n        administratively removed.')
nwAtHostCtlNumDynamics = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlNumDynamics.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlNumDynamics.setDescription('Indicates the number of dynamic entries in the AARP \n        cache on the router port for which the entry exists.\n        Dynamic entries area added and aged out by the AARP\n        protocol.')
nwAtHostCtlCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlCacheHits.setDescription('Indicates the number of times an entry in the AARP cache\n        has been used to successfully provide the physical address\n        required to forward an AppleTalk packet on the router\n        port for which the entry exists.')
nwAtHostCtlCacheMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostCtlCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostCtlCacheMisses.setDescription('Indicates the number of times the physical address\n        required to forward an AppleTalk packet has not been\n        found in the AARP cache on the router port for which the\n        entry exists.')
nwAtAclValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtAclValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclValidEntries.setDescription('Indicates the number of valid entries that exist in the\n        Access Control List Table.')
nwAtAclTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2), )
if mibBuilder.loadTexts: nwAtAclTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclTable.setDescription('This table contains the Access Control List information\n        for theAppleTalk protocol. This table contains entries,\n        each of which allows packet forwarding between\n        source/destination pairs to be permitted or denied. The\n        particular list is identified by the access control \n        list ID. Each list may contain multiple entries ordered \n        by sequence number. When a particular access control list\n        is searched, it is searched in sequence number order and\n        the first match found ends the search. If no match is\n        found, access defaults to permitted.')
nwAtAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtAclIdentifier"), (0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtAclSequence"))
if mibBuilder.loadTexts: nwAtAclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclEntry.setDescription('Each entry contains AppleTalk source/destination access\n        information.')
nwAtAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclIdentifier.setDescription('This is the primary (major) index into the AppleTalk\n        access control list table. Essentially, this identifies\n        the access control list by a unique identifier (at least 1)\n        and is arbitrarily assigned by the user. All entries that\n        have the same ID belong to the same access control list.')
nwAtAclSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtAclSequence.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclSequence.setDescription('This is the secondary (minor) index into the AppleTalk\n        access control list table. This number corresponds to a\n        sequence number used to order multiple entries within the\n        same access control list.')
nwAtAclPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permit", 3), ("deny", 4), ("permit-bidirectional", 5), ("deny-bidirectional", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtAclPermission.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclPermission.setDescription('Specifies whether access is allowed or denied between\n        the source and destination address pairs. Note that\n        source and destination are interchangeable when\n        bi-directional control is selected. To remove an existing\n        entry set invalid (2), and it will disappear after\n        reboot.')
nwAtAclMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtAclMatches.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclMatches.setDescription('Indicates the number of matches on this entry that\n        have resulted in the access restriction permit/deny \n        being applied as part of the forwarding process.')
nwAtAclDestZone = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 5), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtAclDestZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclDestZone.setDescription('Specifies the destination zone name used to compare for\n        matches on the access control list.')
nwAtAclSrcZone = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 7, 2, 1, 6), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtAclSrcZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtAclSrcZone.setDescription('Specifies the source zone to be used to compare for\n        matches on the access control list.')
nwAtEventAdminSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventAdminSTATUS.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventAdminSTATUS.setDescription('Sets the administrative state of AppleTalk event\n        logging. Enabled (3) causes the event log to become \n        active. Disabled (2) causes the event log to become\n        inactive.')
nwAtEventMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventMaxEntries.setDescription('Sets the maximum number of entries allowed in the event\n        log table. When the number of entries reaches the value\n        of nwAtEventMaxEntries the first (oldest) entry is deleted\n        to allow a new entry to be added.')
nwAtEventTraceAll = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventTraceAll.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventTraceAll.setDescription('Enabled (3) allows logging of all event types on all\n        router ports from all protocols and components. Disabled\n        (2) causes the event log filter table to specify which\n        events to log.')
nwAtEventFilterTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1), )
if mibBuilder.loadTexts: nwAtEventFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFilterTable.setDescription("This table contains an entry for each event filter\n        configured for AppleTalk Routing Service's events.")
nwAtEventFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtEventFltrProtocol"), (0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtEventFltrIfNum"))
if mibBuilder.loadTexts: nwAtEventFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFilterEntry.setDescription('Each entry describes an event filter which defines a\n        particular type of event to be logged to the event log.\n        The value of nwIpEventProtocol indicates the value used \n        in either the nwRtgProtocolTable or the nwComponentTable\n        Cabletron Routing Services MIB, which indentifies the\n        protocol to which the entry exists.')
nwAtEventFltrProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventFltrProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrProtocol.setDescription('Indicates the value of the Cabletron Routing Services\n        MIB nwRtgProtocolInstance or nwComponentRtgInstance, \n        which identifies the protocol involved in the event for\n        which the event filter exists.')
nwAtEventFltrIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventFltrIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrIfNum.setDescription('Specifies the router port involved in the event for\n        which the event filter exists.')
nwAtEventFltrControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("delete", 2), ("add", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventFltrControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrControl.setDescription('Set this value to 3 to add the entry to the event log\n        table. Set this value to 2 to remove the entry from the\n        event filter table.')
nwAtEventFltrType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("misc", 1), ("timer", 2), ("rcv", 4), ("xmit", 8), ("event", 16), ("error", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventFltrType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrType.setDescription('This 6 bit mask specifies the types of events to be \n        logged. By default all 6 bits are set to 1, indicating \n        that all types of events are to be logged. Setting any bit\n        to 0 removes an event type from this field and prevents \n        that type of event from being logged. Setting any bit to 1\n        adds an event type to this field and enables that type of\n        event to be logged. ')
nwAtEventFltrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highest", 1), ("highmed", 2), ("highlow", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventFltrSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrSeverity.setDescription("Specifies the level of severity an event must meet in\n        order to be logged. Controls the amount of event logging\n        by ignoring events of a lower priority than specified by\n        this filter value. `Highmed' ignores only events of the\n        lowest severity. `Highlow' logs all events highest priority\n        through lowest. `Highest' severity causes all events\n        except those of the highest severity to be ignored.\n        `Highmed' severity is the default setting which causes\n        only events of the lowest severity to be ignored. \n        `Highlow' severity logs all events, regardless of\n        severity.")
nwAtEventFltrAction = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("log", 1), ("trap", 2), ("log-trap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtEventFltrAction.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventFltrAction.setDescription("Specifies how the events are to be logged. Logging to \n        the `log' stores the events in the event log table\n        (nwIpEventFltrAction). Logging to `trap' sends events \n        out through the trap mechanism.")
nwAtEventTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1), )
if mibBuilder.loadTexts: nwAtEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventTable.setDescription('This table contains an entry for each event that has\n        been logged.')
nwAtEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtEventNumber"))
if mibBuilder.loadTexts: nwAtEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventEntry.setDescription('Each entry contains the information about an event that\n        has been logged to the event table.')
nwAtEventNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventNumber.setDescription('An ordinal value assigned to the event for which the\n        log entry exists. nwAtEvnetNumber is assigned so that \n        each event in the event log can be uniquely identified by\n        the value of nwAtEventNumber.')
nwAtEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventTime.setDescription('Indicates the time at which the event was logged to the\n        event log')
nwAtEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("misc", 1), ("timer", 2), ("rcv", 4), ("xmit", 8), ("event", 16), ("error", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventType.setDescription('Indicates the type of event that was logged.')
nwAtEventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highest", 1), ("highmed", 2), ("highlow", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventSeverity.setDescription('Indicates the severity that was assigned to this event.')
nwAtEventProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventProtocol.setDescription('Indicates the value of the Cabletron Routing Services\n        MIB nwRtgProtocolInstance or nwComponentInstance which\n        identifies the protocol or component that was involved in\n        the event.')
nwAtEventIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventIfNum.setDescription('Indicates the router port that was involved in the \n        event.')
nwAtEventTextString = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 10, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtEventTextString.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtEventTextString.setDescription('Contains the actual text string that was logged.')
nwAtNetDiagOutboundNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 1), AtDdpNodeAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNetAddress.setDescription('The AppleTalk Network Address of a node with which the\n        diagnostic test will directly correspond.')
nwAtNetDiagOutboundPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundPort.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundPort.setDescription('An integer representing the port through which the\n        diagnostic test will broadcast or multicast packets.')
nwAtNetDiagOutboundTimeout = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundTimeout.setDescription('An integer representing the number of seconds before a\n        diagnostic request will time out.')
nwAtNetDiagOutboundRetries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundRetries.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundRetries.setDescription('An integer representing the number of times a request\n        will be repeated before failure.')
nwAtNetDiagOutboundATEchoType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("sendEchoRequest", 2), ("other", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundATEchoType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundATEchoType.setDescription('The type of echo diagnostic function to initiate. Upon\n        setting this to send EchoRequest (2), an echo request \n        will be initiated and the value will be set to noAction\n        (1).')
nwAtNetDiagOutboundATEchoStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inactive", 1), ("inProgress", 2), ("timeout", 3), ("success", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundATEchoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundATEchoStatus.setDescription('The current status of the echo diagnostic.')
nwAtNetDiagOutboundNBPEntityObject = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 7), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityObject.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityObject.setDescription('The entity object or wildcard object used in the\n         NBP lookup diagnostic.')
nwAtNetDiagOutboundNBPEntityType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 8), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityType.setDescription('The entity type or wildcard type used in the\n         NBP lookup diagnostic.')
nwAtNetDiagOutboundNBPEntityZone = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 9), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPEntityZone.setDescription('The entity zone used in the NBP lookup diagnostic.')
nwAtNetDiagOutboundNBPType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noAction", 1), ("localRequest", 2), ("lookupMcast", 3), ("lookupBcast", 4), ("lookupDirect", 5), ("bcastRequestBcast", 6), ("bcastRequestDirect", 7), ("forwardRequestBcast", 8), ("forwardRequestDirect", 9), ("other", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPType.setDescription('Specifies the type of outbound NBP diagnostic function\n        to initiate. Upon setting this value to any value other\n        than noAction (1) or other (10), the corresponding request\n        will be made and the value will be set to noAction (1).')
nwAtNetDiagOutboundNBPStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("inProgress", 2), ("done", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundNBPStatus.setDescription('Indicates the current status of the outbound NBP\n        diagnostic.')
nwAtNetDiagOutboundRTMPType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noAction", 1), ("sendRequest", 2), ("bcastRequest", 3), ("sendRDRequestSplitHorizon", 4), ("bcastRDRequestSplitHorizon", 5), ("sendRDRequestFullTable", 6), ("bcastRDRequestFullTable", 7), ("other", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPType.setDescription('The type of outbound RTMP diagnostic function to initiate.\n         Upon setting this value to a value other than noAction(1)\n         or other(8), the corresponding request will be initiated\n         and the value will be set to noAction(1).')
nwAtNetDiagOutboundRTMPStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("inProgress", 2), ("done", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPStatus.setDescription('The current status of the outbound RTMP diagnostic.')
nwAtNetDiagOutboundRTMPNetStart = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 14), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPNetStart.setDescription('The start of the network range from the last successful\n         outbound RTMP request or route data request.')
nwAtNetDiagOutboundRTMPNetEnd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 15), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundRTMPNetEnd.setDescription('The end of the network range from the last successful\n         outbound RTMP request or route data request.')
nwAtNetDiagOutboundZIPType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("noAction", 1), ("sendQuery", 2), ("bcastQuery", 3), ("sendGetZonesList", 4), ("sendGetLocalZones", 5), ("sendGetMyZone", 6), ("sendGetNetInfo", 7), ("bcastGetNetInfo", 8), ("other", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPType.setDescription('The type of outbound ZIP diagnostic function to initiate.\n         Upon setting this value to a value other than noAction(1)\n         or other(8), the corresponding request will be initiated\n         and the value will be set to noAction(1).')
nwAtNetDiagOutboundZIPStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inactive", 1), ("queryInProgress", 2), ("atpInProgress", 3), ("gniInProgress", 4), ("done", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPStatus.setDescription('The current status of the outbound ZIP diagnostic.')
nwAtNetDiagOutboundZIPQueryNet = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 18), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPQueryNet.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPQueryNet.setDescription('The start of the network range to send ZIP query for.')
nwAtNetDiagOutboundZIPQueryZone = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 19), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPQueryZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPQueryZone.setDescription('The first zone from the last successful ZIP query.')
nwAtNetDiagOutboundZIPGetNetInfoZone = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 20), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoZone.setDescription('The zone name to be used in a ZIP get-net-info request\n         diagnostic.')
nwAtNetDiagOutboundZIPGetNetInfoNetStart = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 21), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoNetStart.setDescription('The start of the network range from the last successful\n         ZIP get-net-info request.')
nwAtNetDiagOutboundZIPGetNetInfoNetEnd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 22), AtNetworkNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoNetEnd.setDescription('The end of the network range from the last successful\n         ZIP get-net-info request.')
nwAtNetDiagOutboundZIPGetNetInfoMulticast = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 23), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoMulticast.setDescription('The data-link multicast address from the last successful\n         ZIP get-net-info request.')
nwAtNetDiagOutboundZIPGetNetInfoDefaultZone = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 12, 3, 24), AtName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoDefaultZone.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtNetDiagOutboundZIPGetNetInfoDefaultZone.setDescription('The default zone name from the last successful\n         ZIP get-net-info request.')
nwAtportZoneTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4, 1), )
if mibBuilder.loadTexts: nwAtportZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneTable.setDescription('The table of zone information for non-default\n                zones on ports.')
nwAtportZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtportZonePort"), (0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtportZoneName"))
if mibBuilder.loadTexts: nwAtportZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneEntry.setDescription('An entry of zone information for a port.')
nwAtportZonePort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportZonePort.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZonePort.setDescription('An integer representing the port to which this zone belongs.\n                The port identified by a particular value of this object\n                is the same port as identified by the same value of\n                nwAtportIndex.')
nwAtportZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4, 1, 1, 2), AtName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtportZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneName.setDescription('A zone name configured for the AppleTalk port referred to in\n                the corresponding entry of nwAtportZonePort.\n                When this value is changed in a router, the router must\n                send a zipNotify packet on the associated network.')
nwAtportZoneStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtportZoneStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtportZoneStatus.setDescription('The status of this zone entry.\n                 Setting this object to the value invalid(2) has the\n                 effect of invalidating the corresponding entry in the\n                 nwAtportZoneTable.  That is, it effectively disassociates\n                 the mapping identified with said entry.  It is an\n                 implementation-specific matter as to whether the agent\n                 removes an invalidated entry from the table.\n                 Accordingly, management stations must be prepared to\n                 receive from agents tabular information corresponding\n                 to entries not currently in use.  Proper\n                 interpretation of such entries requires examination\n                 of the relevant nwAtportZoneStatus object.')
nwAtHostMapTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1), )
if mibBuilder.loadTexts: nwAtHostMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapTable.setDescription('The Ip Address translation table used for mapping an IP\n         address to physical address, framing, port and circuit\n         identifier, if applicable.')
nwAtHostMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1), ).setIndexNames((0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtHostMapIfIndex"), (0, "CTRON-AppleTalk-ROUTER-MIB", "nwAtHostMapAtAddr"))
if mibBuilder.loadTexts: nwAtHostMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapEntry.setDescription("Each entry contains one AtNetworkNumber to 'physical'\n         address equivalence, including a circuit identifier\n          if applicable. Also provided is the framing and\n         port number required to converse with this host.")
nwAtHostMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostMapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapIfIndex.setDescription('This is the primary (major) index into the HostMap \n              table. This number corresponds to the index into the\n              MIB-2 Interfaces Group which describes the IP router \n              port for which the entry exists.')
nwAtHostMapAtAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 2), AtDdpNodeAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostMapAtAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapAtAddr.setDescription("The AtDdpNodeAddress corresponding to the\n             media-dependent 'physical' address and circuit \n             identifier (if applic).")
nwAtHostMapPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostMapPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapPhysAddr.setDescription("The media-dependent 'physical' address. The value of\n              this object is 0 for entries indicating native-wan(8)\n              framing.")
nwAtHostMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4), ("inactive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostMapType.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapType.setDescription('Setting this object to the value invalid(2) has\n             the effect of invalidating the corresponding entry\n             in the nwAtHostMapTable.  That is, it effectively\n             dissasociates the circuit identified with said\n             entry from the mapping identified with said entry.\n             It is an implementation-specific matter as to\n             whether the agent removes an invalidated entry\n             from the table.  Accordingly, management stations\n             must be prepared to receive tabular information\n             from agents that corresponds to entries not\n             currently in use.  Proper interpretation of such\n             entries requires examination of the relevant\n             nwAtHostMapType object.')
nwAtHostMapCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostMapCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapCircuitID.setDescription('The identifier for the virtual circuit present on the \n             interface. On an interface configured for Frame Relay,\n             this number is the DLCI for the IP Address at the end of\n             the circuit. For non-WAN interfaces, the value of this\n             object is zero.')
nwAtHostMapFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 9, 11, 16, 17))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("snap", 3), ("nativewan", 8), ("encapenet", 9), ("encapenetsnap", 11), ("encapfddisnap", 16), ("canonical", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwAtHostMapFraming.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapFraming.setDescription('Specifies the framing type required to converse with the\n              host for which this entry exists.')
nwAtHostMapPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 4, 2, 6, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwAtHostMapPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwAtHostMapPortNumber.setDescription("The unique value for the logical port number. It's value\n             ranges between 1 and a maximum value which is dependent on\n             both the number of interfaces in the system and the number\n             of circuits present on interfaces which are of WAN type.")
mibBuilder.exportSymbols("CTRON-AppleTalk-ROUTER-MIB", nwAtProtoIfAdminSTATUS=nwAtProtoIfAdminSTATUS, nwAtportNetFrom=nwAtportNetFrom, nwAtProtoCtrOutBytes=nwAtProtoCtrOutBytes, nwAtProtoIfCtrOperationalTime=nwAtProtoIfCtrOperationalTime, nwAtFibHops=nwAtFibHops, nwAtProtoIfAclIdentifier=nwAtProtoIfAclIdentifier, nwAtNetDiagOutboundRTMPType=nwAtNetDiagOutboundRTMPType, nwAtFwdCtrFilteredPkts=nwAtFwdCtrFilteredPkts, nwAtFwdCtrFwdBytes=nwAtFwdCtrFwdBytes, nwAtProtoCtrAdminSTATUS=nwAtProtoCtrAdminSTATUS, nwAtportIndex=nwAtportIndex, AtName=AtName, nwAtFwdIfCtrLenErrPkts=nwAtFwdIfCtrLenErrPkts, nwAtHostCtlOperationalTime=nwAtHostCtlOperationalTime, nwAtHostCtlProxy=nwAtHostCtlProxy, nwAtNetDiag=nwAtNetDiag, nwAtFwdCtrHostInPkts=nwAtFwdCtrHostInPkts, nwAtProtoThreadPriority=nwAtProtoThreadPriority, nwAtFwdCtrInPkts=nwAtFwdCtrInPkts, nwAtNetDiagOutboundZIPGetNetInfoNetStart=nwAtNetDiagOutboundZIPGetNetInfoNetStart, nwAtHostMapType=nwAtHostMapType, nwAtNetDiagOutbound=nwAtNetDiagOutbound, nwAtFwdIfFrameType=nwAtFwdIfFrameType, nwAtHostMapPhysAddr=nwAtHostMapPhysAddr, nwAtTopology=nwAtTopology, nwAtFwdIfCtrFilteredBytes=nwAtFwdIfCtrFilteredBytes, nwAtFwdSystem=nwAtFwdSystem, nwAtFwdCtrAdminSTATUS=nwAtFwdCtrAdminSTATUS, nwAtFwdIfCtrHostInBytes=nwAtFwdIfCtrHostInBytes, nwAtSysAdminSTATUS=nwAtSysAdminSTATUS, nwAtHostCtlCacheHits=nwAtHostCtlCacheHits, nwAtSysRouterId=nwAtSysRouterId, nwAtProtoIfVersion=nwAtProtoIfVersion, nwAtNetDiagOutboundATEchoStatus=nwAtNetDiagOutboundATEchoStatus, nwAtNetDiagOutboundZIPGetNetInfoDefaultZone=nwAtNetDiagOutboundZIPGetNetInfoDefaultZone, nwAtportZoneName=nwAtportZoneName, nwAtEventAdminSTATUS=nwAtEventAdminSTATUS, nwAtAclPermission=nwAtAclPermission, nwAtFwdIfCacheMisses=nwAtFwdIfCacheMisses, nwAtportNetAddress=nwAtportNetAddress, nwAtHostCtlCacheMax=nwAtHostCtlCacheMax, nwAtEventFltrControl=nwAtEventFltrControl, nwAtFwdCtrInBytes=nwAtFwdCtrInBytes, nwAtProtoOperationalTime=nwAtProtoOperationalTime, nwAtEventFltrProtocol=nwAtEventFltrProtocol, nwAtSysOperSTATUS=nwAtSysOperSTATUS, nwAtportType=nwAtportType, nwAtFwdIfCtrInPkts=nwAtFwdIfCtrInPkts, nwAtportTable=nwAtportTable, nwAtFwdIfCtrFilteredPkts=nwAtFwdIfCtrFilteredPkts, nwAtFwdIfEntry=nwAtFwdIfEntry, nwAtAclSequence=nwAtAclSequence, nwAtEventFilterEntry=nwAtEventFilterEntry, nwAtProtoIfCtrInBytes=nwAtProtoIfCtrInBytes, nwAtEventNumber=nwAtEventNumber, nwAtHostCtlNumDynamics=nwAtHostCtlNumDynamics, nwAtportZoneConfig=nwAtportZoneConfig, nwAtFwdIfTable=nwAtFwdIfTable, nwAtFwdIfControl=nwAtFwdIfControl, nwAtEventTime=nwAtEventTime, nwAtForwarding=nwAtForwarding, nwAtHostsRetryCount=nwAtHostsRetryCount, nwAtSysAdministration=nwAtSysAdministration, nwAtNetDiagOutboundNBPType=nwAtNetDiagOutboundNBPType, nwAtportZoneDefault=nwAtportZoneDefault, nwAtEvent=nwAtEvent, nwAtFwdIfCtrTable=nwAtFwdIfCtrTable, nwAtSysAdminReset=nwAtSysAdminReset, nwAtNetDiagOutboundRTMPStatus=nwAtNetDiagOutboundRTMPStatus, nwAtProtoIfHelloTimer=nwAtProtoIfHelloTimer, nwAtLinkState=nwAtLinkState, nwAtHostMapIfIndex=nwAtHostMapIfIndex, nwAtProtoIfOperSTATUS=nwAtProtoIfOperSTATUS, nwAtSysConfig=nwAtSysConfig, nwAtHostCtlCacheMisses=nwAtHostCtlCacheMisses, AtDdpNodeAddress=AtDdpNodeAddress, nwAtProtoSystem=nwAtProtoSystem, nwAtNetDiagOutboundRetries=nwAtNetDiagOutboundRetries, nwAtFwdIfCounters=nwAtFwdIfCounters, nwAtFwdIfCtrDiscardBytes=nwAtFwdIfCtrDiscardBytes, nwAtFwdInterfaces=nwAtFwdInterfaces, nwAtFwdIfAclIdentifier=nwAtFwdIfAclIdentifier, nwAtportEntry=nwAtportEntry, nwAtportHome=nwAtportHome, nwAtFwdCtrAddrErrPkts=nwAtFwdCtrAddrErrPkts, nwAtProtoDatabaseThreshold=nwAtProtoDatabaseThreshold, nwAtProtoCtrReset=nwAtProtoCtrReset, nwAtEventFltrSeverity=nwAtEventFltrSeverity, nwAtHostCtlSnooping=nwAtHostCtlSnooping, nwAtFwdIfCtrOutPkts=nwAtFwdIfCtrOutPkts, nwAtProtoAgeOut=nwAtProtoAgeOut, nwAtWorkGroup=nwAtWorkGroup, nwAtProtoIfSnooping=nwAtProtoIfSnooping, nwAtportZoneStatus=nwAtportZoneStatus, nwAtFwdIfCtrHostOutPkts=nwAtFwdIfCtrHostOutPkts, nwAtProtoCtrFilteredPkts=nwAtProtoCtrFilteredPkts, nwAtFwdCtrLenErrPkts=nwAtFwdCtrLenErrPkts, nwAtFwdCtrHdrErrPkts=nwAtFwdCtrHdrErrPkts, nwAtHostCtlNumStatics=nwAtHostCtlNumStatics, nwAtportOutPkts=nwAtportOutPkts, nwAtFwdIfCtrHdrErrPkts=nwAtFwdIfCtrHdrErrPkts, nwAtFwdIfCtrOutBytes=nwAtFwdIfCtrOutBytes, nwAtProtoCtrFilteredBytes=nwAtProtoCtrFilteredBytes, nwAtFwdIfForwarding=nwAtFwdIfForwarding, nwAtportNetStart=nwAtportNetStart, nwAtProtoIfType=nwAtProtoIfType, nwAtFwdIfCtrEntry=nwAtFwdIfCtrEntry, nwAtDistanceVector=nwAtDistanceVector, nwAtFwdCtrOutPkts=nwAtFwdCtrOutPkts, nwAtFwdIfCtrFwdBytes=nwAtFwdIfCtrFwdBytes, nwAtHostMapFraming=nwAtHostMapFraming, nwAtFwdIfCtrIfIndex=nwAtFwdIfCtrIfIndex, nwAtHostMapTable=nwAtHostMapTable, nwAtProtoIfCtrIfIndex=nwAtProtoIfCtrIfIndex, nwAtEventFltrType=nwAtEventFltrType, nwAtProtoIfAclSTATUS=nwAtProtoIfAclSTATUS, nwAtProtoIfCtrReset=nwAtProtoIfCtrReset, nwAtEventLogFilterTable=nwAtEventLogFilterTable, nwAtFilters=nwAtFilters, AtNetworkNumber=AtNetworkNumber, nwAtProtoIfCounters=nwAtProtoIfCounters, nwAtFwdIfCtrAdminSTATUS=nwAtFwdIfCtrAdminSTATUS, nwAtFibNextHopIf=nwAtFibNextHopIf, nwAtProtoCtrInPkts=nwAtProtoCtrInPkts, nwAtProtoIfRequestDelay=nwAtProtoIfRequestDelay, nwAtFwdIfCtrFwdPkts=nwAtFwdIfCtrFwdPkts, nwAtNetDiagPing=nwAtNetDiagPing, nwAtFwdIfCtrOperationalTime=nwAtFwdIfCtrOperationalTime, nwAtHostMapCircuitID=nwAtHostMapCircuitID, nwAtSysVersion=nwAtSysVersion, nwAtFwdCtrOutBytes=nwAtFwdCtrOutBytes, nwAtportDescr=nwAtportDescr, nwAtProtoIfEntry=nwAtProtoIfEntry, nwAtProtoIfCtrOutPkts=nwAtProtoIfCtrOutPkts, nwRtrExperimental=nwRtrExperimental, nwAtProtoStackSize=nwAtProtoStackSize, nwAtAclMatches=nwAtAclMatches, nwAtNetDiagOutboundNBPEntityZone=nwAtNetDiagOutboundNBPEntityZone, nwAtNetDiagOutboundZIPType=nwAtNetDiagOutboundZIPType, nwAtFwdIfCacheEntries=nwAtFwdIfCacheEntries, nwAtProtoIfCtrFilteredBytes=nwAtProtoIfCtrFilteredBytes, nwAtportZoneFrom=nwAtportZoneFrom, nwAtEventFilterTable=nwAtEventFilterTable, nwAtEventSeverity=nwAtEventSeverity, nwAtFibStartNet=nwAtFibStartNet, nwAtEventIfNum=nwAtEventIfNum, nwAtNetDiagOutboundTimeout=nwAtNetDiagOutboundTimeout, nwAtFwdIfCtrHostDiscardPkts=nwAtFwdIfCtrHostDiscardPkts, nwAtEventLogTable=nwAtEventLogTable, nwAtEventTraceAll=nwAtEventTraceAll, nwAtAclEntry=nwAtAclEntry, nwAtNetDiagOutboundZIPStatus=nwAtNetDiagOutboundZIPStatus, nwAtNetDiagTelnet=nwAtNetDiagTelnet, nwAtFwdIfCtrReset=nwAtFwdIfCtrReset, nwAtProtoIfTable=nwAtProtoIfTable, nwAtProtoCtrDiscardPkts=nwAtProtoCtrDiscardPkts, nwAtNetDiagOutboundATEchoType=nwAtNetDiagOutboundATEchoType, nwAtFwdCtrDiscardBytes=nwAtFwdCtrDiscardBytes, nwAtFwdIfOperationalTime=nwAtFwdIfOperationalTime, nwAtFwdIfIndex=nwAtFwdIfIndex, nwAtportNetEnd=nwAtportNetEnd, nwAtProtoIfCtrEntry=nwAtProtoIfCtrEntry, nwAtAclTable=nwAtAclTable, nwAtHostCtlIfIndex=nwAtHostCtlIfIndex, nwAtProto=nwAtProto, nwAtProtoCtrInBytes=nwAtProtoCtrInBytes, nwAtAclSrcZone=nwAtAclSrcZone, nwAtEventFltrIfNum=nwAtEventFltrIfNum, nwAtEventLogConfig=nwAtEventLogConfig, nwAtFib=nwAtFib, nwAtHostMapPortNumber=nwAtHostMapPortNumber, nwAtFwdCtrHostDiscardBytes=nwAtFwdCtrHostDiscardBytes, nwAtHostsTimeToLive=nwAtHostsTimeToLive, nwAtportZoneTable=nwAtportZoneTable, nwAtNetDiagOutboundZIPGetNetInfoNetEnd=nwAtNetDiagOutboundZIPGetNetInfoNetEnd, nwAtFwdIfCtrHostOutBytes=nwAtFwdIfCtrHostOutBytes, nwAtFibRouteType=nwAtFibRouteType, nwAtHostCtlTable=nwAtHostCtlTable, nwAtFwdCtrHostDiscardPkts=nwAtFwdCtrHostDiscardPkts, nwAtMibs=nwAtMibs, nwAtFwdCtrFilteredBytes=nwAtFwdCtrFilteredBytes, nwAtProtoCtrDiscardBytes=nwAtProtoCtrDiscardBytes, nwAtHostCtlProtocol=nwAtHostCtlProtocol, nwAtNetDiagOutboundNBPEntityType=nwAtNetDiagOutboundNBPEntityType, nwAtProtoIfOperationalTime=nwAtProtoIfOperationalTime, nwAtProtoIfCtrInPkts=nwAtProtoIfCtrInPkts, nwAtFwdCtrReset=nwAtFwdCtrReset, nwAtEventFltrAction=nwAtEventFltrAction, nwAtProtoIfCtrDiscardBytes=nwAtProtoIfCtrDiscardBytes, nwAtportZonePort=nwAtportZonePort, nwAtNetDiagOutboundNetAddress=nwAtNetDiagOutboundNetAddress, nwAtProtoIfIndex=nwAtProtoIfIndex, nwAtEndSystems=nwAtEndSystems, nwAtFwdIfCtrDiscardPkts=nwAtFwdIfCtrDiscardPkts, nwAtHostMapEntry=nwAtHostMapEntry, nwAtHostsSystem=nwAtHostsSystem, nwAtFibTable=nwAtFibTable, nwAtSysOperationalTime=nwAtSysOperationalTime, nwAtportZoneEntry=nwAtportZoneEntry, nwAtNetDiagOutboundZIPGetNetInfoMulticast=nwAtNetDiagOutboundZIPGetNetInfoMulticast, nwAtProtoCtrOutPkts=nwAtProtoCtrOutPkts, nwAtSystem=nwAtSystem, nwAtProtoCounters=nwAtProtoCounters, nwAtFwdCounters=nwAtFwdCounters, nwAtProtoIfCtrOutBytes=nwAtProtoIfCtrOutBytes, nwAtEventEntry=nwAtEventEntry, nwAtFwdCtrDiscardPkts=nwAtFwdCtrDiscardPkts, nwAtEventTextString=nwAtEventTextString, nwAtProtoIfXmitCost=nwAtProtoIfXmitCost, nwAtProtoIfAdvertisement=nwAtProtoIfAdvertisement, nwAtAclDestZone=nwAtAclDestZone, nwAtProtoVersion=nwAtProtoVersion, nwAtEventMaxEntries=nwAtEventMaxEntries, nwAtFwdIfCacheHits=nwAtFwdIfCacheHits, nwAtFwdIfCacheControl=nwAtFwdIfCacheControl, nwAtNetDiagOutboundZIPQueryZone=nwAtNetDiagOutboundZIPQueryZone, nwAtportCurrentZone=nwAtportCurrentZone, nwAtEventType=nwAtEventType, nwAtNetDiagOutboundNBPStatus=nwAtNetDiagOutboundNBPStatus, nwAtProtoOperSTATUS=nwAtProtoOperSTATUS, nwAtRedirector=nwAtRedirector, nwAtProtoIfCtrAdminSTATUS=nwAtProtoIfCtrAdminSTATUS, nwAtFwdIfCtrAddrErrPkts=nwAtFwdIfCtrAddrErrPkts, nwAtFwdCtrOperationalTime=nwAtFwdCtrOperationalTime, nwAtportNetConfig=nwAtportNetConfig, nwAtComponents=nwAtComponents, nwAtProtoIfCtrTable=nwAtProtoIfCtrTable, nwAtHostCtlEntry=nwAtHostCtlEntry, nwAtProtoIfCtrDiscardPkts=nwAtProtoIfCtrDiscardPkts, nwAtNetDiagOutboundRTMPNetEnd=nwAtNetDiagOutboundRTMPNetEnd, nwAtNetDiagOutboundZIPGetNetInfoZone=nwAtNetDiagOutboundZIPGetNetInfoZone, nwAtFibEndNet=nwAtFibEndNet, nwAtProtoInterface=nwAtProtoInterface, nwAtFwdIfAdminSTATUS=nwAtFwdIfAdminSTATUS, nwAtEventTable=nwAtEventTable, nwAtProtoIfConfig=nwAtProtoIfConfig, nwAtNetDiagOutboundZIPQueryNet=nwAtNetDiagOutboundZIPQueryNet, nwAtFibNextHop=nwAtFibNextHop, nwAtFwdCtrFwdPkts=nwAtFwdCtrFwdPkts, nwAtFwdIfCtrInBytes=nwAtFwdIfCtrInBytes, nwAtProtoIfCtrFilteredPkts=nwAtProtoIfCtrFilteredPkts, nwAtHostsToMedia=nwAtHostsToMedia, nwAtFwdIfCtrHostDiscardBytes=nwAtFwdIfCtrHostDiscardBytes, nwAtProtoIfSplitHorizon=nwAtProtoIfSplitHorizon, nwAtFwdCtrHostOutPkts=nwAtFwdCtrHostOutPkts, nwAtFibEntry=nwAtFibEntry, nwAtProtoHoldDown=nwAtProtoHoldDown, nwAtProtoIfPoisonReverse=nwAtProtoIfPoisonReverse, nwAtRouter=nwAtRouter, nwAtFwdIfCtrHostInPkts=nwAtFwdIfCtrHostInPkts, nwAtNetDiagOutboundRTMPNetStart=nwAtNetDiagOutboundRTMPNetStart, nwAtMibRevText=nwAtMibRevText, nwAtportIfIndex=nwAtportIfIndex, nwAtportInPkts=nwAtportInPkts)
mibBuilder.exportSymbols("CTRON-AppleTalk-ROUTER-MIB", nwAtportSTATUS=nwAtportSTATUS, nwAtAclValidEntries=nwAtAclValidEntries, nwAtAclIdentifier=nwAtAclIdentifier, nwAtFwdCtrHostOutBytes=nwAtFwdCtrHostOutBytes, nwAtHostCtlAdminSTATUS=nwAtHostCtlAdminSTATUS, nwAtEventProtocol=nwAtEventProtocol, nwAtNetDiagOutboundPort=nwAtNetDiagOutboundPort, nwAtNetDiagOutboundNBPEntityObject=nwAtNetDiagOutboundNBPEntityObject, nwAtportConflictPhysAddr=nwAtportConflictPhysAddr, nwAtFwdIfMtu=nwAtFwdIfMtu, nwAtProtoIfPriority=nwAtProtoIfPriority, nwAtAccessControl=nwAtAccessControl, nwAtHostMapAtAddr=nwAtHostMapAtAddr, nwAtFwdIfConfig=nwAtFwdIfConfig, nwAtProtoAdminReset=nwAtProtoAdminReset, nwAtHostsInterfaces=nwAtHostsInterfaces, nwAtFwdIfAclSTATUS=nwAtFwdIfAclSTATUS, nwAtProtoCtrOperationalTime=nwAtProtoCtrOperationalTime, nwAtFwdIfOperSTATUS=nwAtFwdIfOperSTATUS, nwAtFwdCtrHostInBytes=nwAtFwdCtrHostInBytes, nwAtHostCtlCacheSize=nwAtHostCtlCacheSize, nwAtProtoIfFloodDelay=nwAtProtoIfFloodDelay, nwAtHostCtlOperSTATUS=nwAtHostCtlOperSTATUS, nwAtProtoAdminSTATUS=nwAtProtoAdminSTATUS, nwAtProtoConfig=nwAtProtoConfig)
