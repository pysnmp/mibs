#
# PySNMP MIB module SSU2000-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/microsemi/SSU2000-MIB
# Produced by pysmi-1.1.8 at Thu Oct 26 09:07:24 2023
# On host fv-az1032-268 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
austron, = mibBuilder.importSymbols("DATUM-MIB", "austron")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, IpAddress, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Unsigned32, NotificationType, MibIdentifier, Bits, TimeTicks, Gauge32, Counter32, Counter64, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Unsigned32", "NotificationType", "MibIdentifier", "Bits", "TimeTicks", "Gauge32", "Counter32", "Counter64", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ssu2000 = ModuleIdentity((1, 3, 6, 1, 4, 1, 601, 3, 1, 1))
if mibBuilder.loadTexts: ssu2000.setLastUpdated('0801140000Z')
if mibBuilder.loadTexts: ssu2000.setOrganization('Symmetricom')
if mibBuilder.loadTexts: ssu2000.setContactInfo('        \n            Symmetricom Technical Support\n            1-888-367-7966 toll free USA\n            1-408-428-7907 worldwide\n            Support@symmetricom.com\n           ')
if mibBuilder.loadTexts: ssu2000.setDescription('Private MIB module for management of SSU2000.\n          This SSU2000 private MIB supports all existing \n          functions of the SSU2000 thus achieving full system\n          control via this software interface. All reports, \n          queries, autonomous messages, control, provisioning\n          and administration (except for Set User ID/password/level, \n          Set IP assignments, Reset Connection and SNMP Community \n          Settings) will be addressable via SNMP.\n          ')
inventory = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1))
mstatus = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2))
msetup = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3))
general = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4))
event = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5))
alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6))
ref = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7))
phase = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8))
freq = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9))
ntp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10))
time = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 11))
pqlTable = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12))
ioname = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13))
comm = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14))
snmpman = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15))
sys = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16))
users = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17))
who = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18))
ntpq = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19))
route = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20))
mtie = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30))
tdev = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31))
ptpclient = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36))
mTrapReq = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 50))
mTrapObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51))
mTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 52))
sInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60))
statusCom = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 1))
statusClk = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2))
statusGps = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5))
statusDs1E1Inp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7))
statusCcInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8))
statusOut = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10))
statusLrm = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11))
statusSineInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12))
statusJccInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13))
statusLrmE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14))
statusPtNtp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15))
statusPtPtp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16))
statusSynce = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17))
setupCom = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 1))
setupClk = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2))
setupGps = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5))
setupDs1E1Inp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7))
setupCcInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8))
setupDs1Out = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10))
setupE1Out = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11))
setup2048Out = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12))
setupCCOut = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13))
setup422Out = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14))
setupE12048Out = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15))
setupLrm = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16))
setupSineOut = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17))
setupSineInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18))
setupJccOut = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19))
setupJccInp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20))
setupLrmE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21))
setupPtNtp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22))
setupPtPtp = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23))
setupSynce = MibIdentifier((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24))
class OkValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ok", 1), ("fault", 2))

class OnValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("on", 1), ("off", 2))

class YesValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("yes", 1), ("no", 2))

class EnaValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ena", 1), ("dis", 2))

class ActiveValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("active", 1), ("inactive", 2))

class ValidValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("valid", 1), ("invalid", 2))

class TrueValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class DateAndTime(TextualConvention, OctetString):
    description = "A date-time specification.\n\n            field  octets  contents                  range\n            -----  ------  --------                  -----\n              1      1-2   year*                     0..65536\n              2       3    month                     1..12\n              3       4    day                       1..31\n              4       5    hour                      0..23\n              5       6    minutes                   0..59\n              6       7    seconds                   0..60\n                           (use 60 for leap-second)\n              7       8    deci-seconds              0..9\n              8       9    direction from UTC        '+' / '-'\n              9      10    hours from UTC*           0..13\n             10      11    minutes from UTC          0..59\n\n            * Notes:\n            - the value of year is in network-byte order\n            - daylight saving time in New Zealand is +13\n\n            For example, Tuesday May 26, 1992 at 1:30:15 PM EDT would be\n            displayed as:\n\n                             1992-5-26,13:30:15.0,-4:0\n\n\n            Note that if only local time is known, then timezone\n            information (fields 8-10) is not present."
    status = 'current'
    displayHint = '2d-1d-1d,1d:1d:1d.1d,1a1d:1d'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(8, 8), ValueSizeConstraint(11, 11), )
class TLocalTimeOffset(TextualConvention, OctetString):
    description = "A local time offset specification.\n\n            field  octets  contents                  range\n            -----  ------  --------                  -----\n              1       1    direction from UTC        '+' / '-'\n              2       2    hours from UTC*           0..13\n              3       3    minutes from UTC          0..59\n\n            * Notes:\n            - the value of year is in network-byte order\n            - The hours range is 0..13\n\n            For example, the -6 local time offset would be\n            displayed as:  -6:0\n            "
    status = 'current'
    displayHint = '1a1d:1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class TModuleCode(TextualConvention, Integer32):
    description = 'The module hex code\n            1001    Input  3 Port\n            1002    Input  1 Port\n            1003    Input  DS1 3 Port\n            1004    Input  DS1 1 Port \n            1005    Input  E1 3 Port \n            1006    Input  E1 1 Port \n            1008    Input  GPS\n            1010    Input  Composite Clock (1 Port)\n            1012    Input  Japanese CC (1 Port)\n            1013    Input  Japanese Sine (3 Port)\n            2001    Clock  Stratum 2E Rubidium\n            2002    Clock  Stratum 3E\n            2003    Clock  Type I\n            3001    Communication Module\n            4001    Output  DS1\n            4002    Output  E1\n            4003    Output  Composite Clock\n            4004    Output  2048 kHz\n            4007    Output  EIA 422\n            4008    Output  E1/2048 kHz\n            4009    DS1 Line Retiming Module 4 Ports\n            400A    DS1 Line Retiming Module 2 Ports\n            400B    Output   Japanese CC\n            400C    Output   Japanese Sine\n            400D    E1 Line Retiming Module 4 Ports\n            4021    NTP Blade\n            4022    PTP Blade\n            5001    Buffer Card\n            '
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class TSsm(TextualConvention, Integer32):
    description = 'The ssm hex code'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class TLatAndLon(TextualConvention, OctetString):
    description = "antenna latitude and longitude specification.\n\n            field  octets  contents                  range\n            -----  ------  --------                  -----\n              1       1    +/-180 deg                '+' / '-'\n              2       2    degree                    0..180\n              3       3    minute                    0..59\n              4       4    second                    0..59\n              5       5    second fraction           0..99\n\n            +/- dd:mm:ss.ss\n            "
    status = 'current'
    displayHint = '1a1d:1d:1d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(5, 5)
    fixedLength = 5

class TAntHeight(TextualConvention, OctetString):
    description = "antenna height specification.\n\n            field  octets  contents                  range\n            -----  ------  --------                  -----\n              1       1    +/-                       '+' / '-'\n              2      2-3   meter                     0..10000\n              3       4    meter fraction            0..99\n\n            +/- hh.hh\n\n            "
    status = 'current'
    displayHint = '1a2d.1d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

inventoryTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1), )
if mibBuilder.loadTexts: inventoryTable.setStatus('current')
if mibBuilder.loadTexts: inventoryTable.setDescription('A list containing the system inventory of installed hardware and software components contained in the SSU-2000. \n    The number of entries is given by the values of inChassis and inSlot.\n    ')
inEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "inChassis"), (0, "SSU2000-MIB", "inSlot"))
if mibBuilder.loadTexts: inEntry.setStatus('current')
if mibBuilder.loadTexts: inEntry.setDescription('The Inventory table contains inventory information for all modules installed in the SSU2000 unit.\n    System Inventory attributes.\n    ')
inChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: inChassis.setStatus('current')
if mibBuilder.loadTexts: inChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
inSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: inSlot.setStatus('current')
if mibBuilder.loadTexts: inSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
inModCode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 3), TModuleCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inModCode.setStatus('current')
if mibBuilder.loadTexts: inModCode.setDescription('Reports module type is identified with a Hex value.\n        ')
inName = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inName.setStatus('current')
if mibBuilder.loadTexts: inName.setDescription('Reports module type is identified with a Name.\n        ')
inSerial = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inSerial.setStatus('current')
if mibBuilder.loadTexts: inSerial.setDescription("Reports module's serial number.\n        ")
inService = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 6), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inService.setStatus('current')
if mibBuilder.loadTexts: inService.setDescription("Reports module's in-service time.\n        ")
inHwPart = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHwPart.setStatus('current')
if mibBuilder.loadTexts: inHwPart.setDescription("Reports module's hardware part number.\n        ")
inHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHwRev.setStatus('current')
if mibBuilder.loadTexts: inHwRev.setDescription("Reports module's hardware revision.\n        ")
inHwDate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inHwDate.setStatus('current')
if mibBuilder.loadTexts: inHwDate.setDescription("Reports module's date of manufacture.\n        ")
inSwPart = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inSwPart.setStatus('current')
if mibBuilder.loadTexts: inSwPart.setDescription("Reports module's software part number.\n        ")
inSwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inSwRev.setStatus('current')
if mibBuilder.loadTexts: inSwRev.setDescription("Reports module's main software revision.\n        ")
inRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inRevision.setStatus('current')
if mibBuilder.loadTexts: inRevision.setDescription("Reports module's software and PLD revisions.\n        ")
inShelfDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inShelfDesc.setStatus('current')
if mibBuilder.loadTexts: inShelfDesc.setDescription('Reports shelf type description.\n        ')
inShelfPart = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inShelfPart.setStatus('current')
if mibBuilder.loadTexts: inShelfPart.setDescription('Reports shelf part number.\n        ')
inInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 15), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inInstalled.setStatus('current')
if mibBuilder.loadTexts: inInstalled.setDescription('Reports if this module is physically installed in the system or not.\n        1 = module is installed.\n        2 = module is physically absent, but the configuration data is still there.\n        ')
inAction = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("remove", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inAction.setStatus('current')
if mibBuilder.loadTexts: inAction.setDescription('User Action: \n        ENABLE (1), enables the module.\n        DISABLE (2), marks a module as inactive to be removed from the system.\n        REMOVE (3), if physically absent, the module is removed from the registry.\n\n        Note: This field only is meaningful during the write operation.\t\n          When read, it always displayed as 1.\n        ')
inAdapterPart = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inAdapterPart.setStatus('current')
if mibBuilder.loadTexts: inAdapterPart.setDescription('Reports the Symmetricom input adapter part number.\n            Note: If this field is an empty string, it means the input adapter identification is not applicable for this module.\n            ')
inFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 2), )
if mibBuilder.loadTexts: inFeatureTable.setStatus('current')
if mibBuilder.loadTexts: inFeatureTable.setDescription('The SSU-2000 has two optional features, NTP and SNMP.\n    The Feature Presence table provides presence of these features.\n    ')
inFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "inFeatureIndex"))
if mibBuilder.loadTexts: inFeatureEntry.setStatus('current')
if mibBuilder.loadTexts: inFeatureEntry.setDescription('inFeatureIndex\n    The index to identify the feature\n    inFeature\n    The setting of the feature \n      ')
inFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: inFeatureIndex.setStatus('current')
if mibBuilder.loadTexts: inFeatureIndex.setDescription('A unique value for each feature table. \n        1 = NTP\n        2 = SNMP\n        ')
inFeature = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 1, 2, 1, 2), EnaValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inFeature.setStatus('current')
if mibBuilder.loadTexts: inFeature.setDescription('Reports SSU-2000 feature set:\n        1 = Enabled  \n        2 = Disabled\n        ')
staClkTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: staClkTable.setStatus('current')
if mibBuilder.loadTexts: staClkTable.setDescription('Reports Clock Module Status, loop mode, tau, and system-level priority quality level (pql).\n    ')
staCkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "staCkChassis"), (0, "SSU2000-MIB", "staCkSlot"))
if mibBuilder.loadTexts: staCkEntry.setStatus('current')
if mibBuilder.loadTexts: staCkEntry.setDescription('Clock Status Attributes:\n    ')
staCkChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staCkChassis.setStatus('current')
if mibBuilder.loadTexts: staCkChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
staCkSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staCkSlot.setStatus('current')
if mibBuilder.loadTexts: staCkSlot.setDescription('Identifies which slot is being addressed. \n        This slot number and chassis number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for Clocks are slot 1 and slot 12.\n        ')
staCkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCkStatus.setStatus('current')
if mibBuilder.loadTexts: staCkStatus.setDescription('Reports the clock module status.\n        ok(1), -- module is enabled and operating without faults\n        selected(2), -- module is enabled and selected as primary local oscillator\n        disable(3), -- module is disabled\n        fault(4) -- module is enabled and operating with fault(s)\n        ')
staCkPLLMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("failed", 1), ("warmup", 2), ("acquire", 3), ("holdover", 4), ("lock", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCkPLLMode.setStatus('current')
if mibBuilder.loadTexts: staCkPLLMode.setDescription('Reports the clock software Phase Locked Loop (PLL) Mode.\n        failed(1), -- pll hardware failure, pll unlocked\n        warmup(2), -- local oscillator is initialized and warming up\n        acquire(3), -- LO is operating in acquire or fast locked mode\n        holdover(4), -- LO is operating in holdover due to lose or reference input\n        lock(5) -- LO is operating in normal mode\n        ')
staCkTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCkTau.setStatus('current')
if mibBuilder.loadTexts: staCkTau.setDescription("Reports the clock tau value.\n        The tau is the time constant (in seconds) used by the clock's servo control loop.\n        ")
staCkPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCkPql.setStatus('current')
if mibBuilder.loadTexts: staCkPql.setDescription('Reports the system Priority Quality Level (PQL). \n        The PQL indicates the Stratum Level of the clock.\n        Zero indicates an invalid SSM was read.\n        ')
staCkUtc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 2, 1, 1, 7), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCkUtc.setStatus('current')
if mibBuilder.loadTexts: staCkUtc.setDescription('Reports the clock has been TOD synced with GPS or PackeTime..\n        ')
staGpsTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1), )
if mibBuilder.loadTexts: staGpsTable.setStatus('current')
if mibBuilder.loadTexts: staGpsTable.setDescription("The GPS Input Module Status reports the module's current status, input port phase data, \n    time status, MTIE threshold status, frequency threshold status, and TIE measurement statistics status.\n    ")
staGpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "staGpsChassis"), (0, "SSU2000-MIB", "staGpsSlot"))
if mibBuilder.loadTexts: staGpsEntry.setStatus('current')
if mibBuilder.loadTexts: staGpsEntry.setDescription('GPS Status Attributes:\n    staGpsChassis\n        Identifies which chassis is being addressed\n    stGpskSlot \n        Identifies which slot is being addressed\n    staGpsMStatus\n        Reports module status\n    staGpsStatus \n        Reports gps input port status \n    staGpsPhaseA\n        Reports phase value versus clock A in nano-seconds.\n    staGpsPhaseB\n        Reports phase value versus clock B in nano-seconds.\n    staGpsUtc\n        Reports number tells us whether the GPS module has UTC time or not.\n    staGpsMtie1A\n        Reports which MTIE limit 1 threshold was exceeded on clock A.\n    staGpsMtie2A\n        Reports which MTIE limit 2 threshold was exceeded on clock A.\n    staGpsMtie1B\n        Reports which MTIE limit 1 threshold was exceeded on clock B.\n    staGpsMtie2B\n        Reports which MTIE limit 2 threshold was exceeded on clock B.\n    staGpsFreqA\n        Reports input port frequency threshold exceeded on clock A.\n    staGpsFreqB\n        Reports input port frequency threshold exceeded on clock B.\n    staGpsPpsSigma\n        Reports sigma (statistical) calculation representing noise variation on the GPS 1PPS\n    staGps3Sigma\n        Reports 3sigma (statistical) calculation representing noise variation on the GPS 1PPS\n    ')
staGpsChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staGpsChassis.setStatus('current')
if mibBuilder.loadTexts: staGpsChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
staGpsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staGpsSlot.setStatus('current')
if mibBuilder.loadTexts: staGpsSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
staGpsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4), ("reject", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsStatus.setStatus('current')
if mibBuilder.loadTexts: staGpsStatus.setDescription('The GPS port status.\n        ok(1), -- module is enabled and operating without faults\n        selected(2), -- module is enabled and selected as input reference\n        disable(3), -- module is disabled\n        fault(4), -- module is enabled and operating with faults\n        reject(5) -- module is rejected due to antenna failure\n        ')
staGpsPhaseA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsPhaseA.setStatus('current')
if mibBuilder.loadTexts: staGpsPhaseA.setDescription('The phase value versus clock A.\n        The phaseA is the current 1 second phase value in nanoseconds on clock A.\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staGpsPhaseB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsPhaseB.setStatus('current')
if mibBuilder.loadTexts: staGpsPhaseB.setDescription('Reports phase value versus clock B.\n        The phaseB is the current 1 second phase value in nanoseconds on clock B.\n        The 1,999,999,999 is designated for invalid phase value.            \n        ')
staGpsUtc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 6), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsUtc.setStatus('current')
if mibBuilder.loadTexts: staGpsUtc.setDescription('Reports the GPS module has been set to UTC time (or not).\n        1 = time is available\n        2 = time is not available\n        ')
staGpsMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("disable", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsMStatus.setStatus('current')
if mibBuilder.loadTexts: staGpsMStatus.setDescription('Reports the GPS module status.\n        ok(1), -- module is enabled and operating normally\n        disable(2), -- module is disabled\n        fault(3) -- module is enabled, but not operational due to faults\n        ')
staGpsMtie1A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsMtie1A.setStatus('current')
if mibBuilder.loadTexts: staGpsMtie1A.setDescription('Reports which MTIE limit 1 threshold was exceeded on clock A.\n        If ok, it means no error for MTIE limit 1 on clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded on clock A.\n        ')
staGpsMtie2A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsMtie2A.setStatus('current')
if mibBuilder.loadTexts: staGpsMtie2A.setDescription('Reports which MTIE limit 2 threshold was exceeded on clock A.\n        If ok, it means no error for MTIE limit 2 on clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded on clock A.\n        ')
staGpsMtie1B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsMtie1B.setStatus('current')
if mibBuilder.loadTexts: staGpsMtie1B.setDescription('Reports which MTIE limit 1 threshold was exceeded on clock B.\n        If ok, it means no error for MTIE limit 1 on clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded on clock B.\n        ')
staGpsMtie2B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsMtie2B.setStatus('current')
if mibBuilder.loadTexts: staGpsMtie2B.setDescription('Reports which MTIE limit 2 threshold was exceeded on clock B.\n        If ok, it means no error for MTIE limit 2 on clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded on clock B.\n        ')
staGpsFreqA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 12), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsFreqA.setStatus('current')
if mibBuilder.loadTexts: staGpsFreqA.setDescription('Reports the input port frequency threshold exceeded on clock A.\n        ')
staGpsFreqB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 13), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsFreqB.setStatus('current')
if mibBuilder.loadTexts: staGpsFreqB.setDescription('Reports the input port frequency threshold exceeded on clock B.\n        ')
staGpsPpsSigma = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGpsPpsSigma.setStatus('current')
if mibBuilder.loadTexts: staGpsPpsSigma.setDescription('Reports current 1 PPS Sigma.\n        ')
staGps3Sigma = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staGps3Sigma.setStatus('current')
if mibBuilder.loadTexts: staGps3Sigma.setDescription('Reports current 3 Sigma Threshold.\n        ')
stGpsPosTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2), )
if mibBuilder.loadTexts: stGpsPosTable.setStatus('current')
if mibBuilder.loadTexts: stGpsPosTable.setDescription("The GPS attributes that report the status of the GPS engine's position and status\n    ")
stGpsPosEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "stGpsPosChassis"), (0, "SSU2000-MIB", "stGpsPosSlot"))
if mibBuilder.loadTexts: stGpsPosEntry.setStatus('current')
if mibBuilder.loadTexts: stGpsPosEntry.setDescription('The GPS position attributes:\n    stGpsPosChassis \n        Identifies which chassis is being addressed\n    stGpsPosSlot \n        Identifies which slot is being addressed\n    stGpsPosValid\n        Reports if the GPS position is valid or not.\n    stGpsPosLat\n        Reports antenna latitude position of the GPS module.\n    stGpsPosLon\n        Reports antenna longitude position of the GPS module.\n    stGpsPosHgt\n        Reports antenna height (meter) position of the GPS module.\n    stGpsPosAccurate\n        Reports antenna position accuracy\n    stGpsPosPdop\n        Reports PDOP assigns a value of accuracy to the calculated position.\n    stGpsPosAvg\n        Reports position averaging value indicates how many position values are used to determine position. \n    ')
stGpsPosChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: stGpsPosChassis.setStatus('current')
if mibBuilder.loadTexts: stGpsPosChassis.setDescription('Identifies which shelf is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
stGpsPosSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: stGpsPosSlot.setStatus('current')
if mibBuilder.loadTexts: stGpsPosSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
stGpsPosValid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 3), ValidValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosValid.setStatus('current')
if mibBuilder.loadTexts: stGpsPosValid.setDescription('Reports if the GPS position is valid or not.\n\n        1 = valid\n        2 = invalid\n        ')
stGpsPosLat = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 4), TLatAndLon()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosLat.setStatus('current')
if mibBuilder.loadTexts: stGpsPosLat.setDescription('Reports antenna latitude position of the GPS module.\n\n        The format is +dd:mm:ss.ss or -dd:mm:ss.ss\n        The latitude is +/- 90 deg.\n        ')
stGpsPosLon = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 5), TLatAndLon()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosLon.setStatus('current')
if mibBuilder.loadTexts: stGpsPosLon.setDescription('Reports antenna longitude position of the GPS module.\n\n        The format is +dd:mm:ss.ss or -dd:mm:ss.ss\n        The longitude is +/- 180 deg.\n        ')
stGpsPosHgt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 6), TAntHeight()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosHgt.setStatus('current')
if mibBuilder.loadTexts: stGpsPosHgt.setDescription('Reports antenna height (meter) position of the GPS module.\n\n        The format is +hh.hh or -hh.hh\n        The height is +/- 10000.0 meters.\n        ')
stGpsPosAccurate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("approx", 1), ("d2", 2), ("d3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosAccurate.setStatus('current')
if mibBuilder.loadTexts: stGpsPosAccurate.setDescription('Reports antenna position accuracy\n        APPROX - position is not accurate\n        D2 - position is accurate, 2D, height is not valid\n        D3 - position is accurate, 3D, height is valid\n        ')
stGpsPosPdop = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosPdop.setStatus('current')
if mibBuilder.loadTexts: stGpsPosPdop.setDescription('Reports PDOP indicates position precision as an integer representation of value in tenths.\n        For example, the value 19 means 1.9 pdop.\n        if zero, it means invalid.\n        ')
stGpsPosAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsPosAvg.setStatus('current')
if mibBuilder.loadTexts: stGpsPosAvg.setDescription('Reports satellite position averaging value. \n        If zero, the satellite position is user entered.\n        ')
stGpsAvailTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3), )
if mibBuilder.loadTexts: stGpsAvailTable.setStatus('current')
if mibBuilder.loadTexts: stGpsAvailTable.setDescription('A list of GPS satellite availability, reports the location of visible satellites.\n        ')
stGpsAvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "stGpsAvChassis"), (0, "SSU2000-MIB", "stGpsAvSlot"), (0, "SSU2000-MIB", "stGpsAvChnl"))
if mibBuilder.loadTexts: stGpsAvEntry.setStatus('current')
if mibBuilder.loadTexts: stGpsAvEntry.setDescription('GPS Availability attributes:\n    ')
stGpsAvChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: stGpsAvChassis.setStatus('current')
if mibBuilder.loadTexts: stGpsAvChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
stGpsAvSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: stGpsAvSlot.setStatus('current')
if mibBuilder.loadTexts: stGpsAvSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
stGpsAvChnl = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: stGpsAvChnl.setStatus('current')
if mibBuilder.loadTexts: stGpsAvChnl.setDescription('Reports satellite channel number.\n        ')
stGpsAvPNCode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsAvPNCode.setStatus('current')
if mibBuilder.loadTexts: stGpsAvPNCode.setDescription('Reports satellite PN code.\n        ')
stGpsAvElevation = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsAvElevation.setStatus('current')
if mibBuilder.loadTexts: stGpsAvElevation.setDescription('Reports calculated elevation (in degrees) of the satellite.\n        ')
stGpsAvAzimuth = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 360))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsAvAzimuth.setStatus('current')
if mibBuilder.loadTexts: stGpsAvAzimuth.setDescription('Reports calculated Azimuth (in degrees) of the satellite.\n        ')
stGpsAvHealthy = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 3, 1, 7), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsAvHealthy.setStatus('current')
if mibBuilder.loadTexts: stGpsAvHealthy.setDescription('Reports current health of the satellite.\n\n        1 = healthy\n        2 = unhealthy\n        ')
stGpsTrackTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5), )
if mibBuilder.loadTexts: stGpsTrackTable.setStatus('current')
if mibBuilder.loadTexts: stGpsTrackTable.setDescription('A list of GPS satellites being tracked show with visibility, signal strength, & health information. \n    ')
stGpsTkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "stGpsTkChassis"), (0, "SSU2000-MIB", "stGpsTkSlot"), (0, "SSU2000-MIB", "stGpsTkChnl"))
if mibBuilder.loadTexts: stGpsTkEntry.setStatus('current')
if mibBuilder.loadTexts: stGpsTkEntry.setDescription('A entry GPS attributes. \n    ')
stGpsTkChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: stGpsTkChassis.setStatus('current')
if mibBuilder.loadTexts: stGpsTkChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
stGpsTkSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: stGpsTkSlot.setStatus('current')
if mibBuilder.loadTexts: stGpsTkSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
stGpsTkChnl = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: stGpsTkChnl.setStatus('current')
if mibBuilder.loadTexts: stGpsTkChnl.setDescription('Reports satellite channel number.\n        ')
stGpsTkSv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 32), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsTkSv.setStatus('current')
if mibBuilder.loadTexts: stGpsTkSv.setDescription('Reports satellite vehicle number being tracked.\n        if zero, it is invalid\n        ')
stGpsTkSnr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsTkSnr.setStatus('current')
if mibBuilder.loadTexts: stGpsTkSnr.setDescription('Reports signal-to-noise ration number being reported\n        if zero, it is invalid\n        ')
stGpsTkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("src", 1), ("acq", 2), ("agc", 3), ("frq", 4), ("cod", 5), ("msg", 6), ("tim", 7), ("eph", 8), ("ok", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stGpsTkStatus.setStatus('current')
if mibBuilder.loadTexts: stGpsTkStatus.setDescription('Reports tracking status.\n        src (1), -- search\n        acq (2), -- acquire\n        agc (3), -- automatic gain control\n        frq (4), -- frequency locking\n        cod (5), -- code locking\n        msg (6), -- messaging\n        tim (7), -- setting time\n        eph (8), -- retriving ephemeris data\n        ok  (9)  -- satellite being used in the timing solution\n        ')
staDs1E1InpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2), )
if mibBuilder.loadTexts: staDs1E1InpTable.setStatus('current')
if mibBuilder.loadTexts: staDs1E1InpTable.setDescription('A list of DS1/E1 Input status entries. \n        ')
staDiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staDiChassis"), (0, "SSU2000-MIB", "staDiSlot"), (0, "SSU2000-MIB", "staDiPort"))
if mibBuilder.loadTexts: staDiEntry.setStatus('current')
if mibBuilder.loadTexts: staDiEntry.setDescription('Input port status attributes.\n    ')
staDiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staDiChassis.setStatus('current')
if mibBuilder.loadTexts: staDiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one.\n        (i.e. in the main chassis)\n        ')
staDiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staDiSlot.setStatus('current')
if mibBuilder.loadTexts: staDiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staDiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: staDiPort.setStatus('current')
if mibBuilder.loadTexts: staDiPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staDiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiStatus.setStatus('current')
if mibBuilder.loadTexts: staDiStatus.setDescription('Reports input port status.\n        ok(1), -- port is enabled & operating without faults\n        selected(2), -- port is selected as system reference\n        disable(3), -- port is diabled\n        fault(4) -- port is enabled & operating with fault(s)\n        ')
staDiPhaseA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiPhaseA.setStatus('current')
if mibBuilder.loadTexts: staDiPhaseA.setDescription('Reports input phase value versus clock A. \n        The phaseA is the current 1 second phase value in nanoseconds on clock A.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staDiPhaseB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiPhaseB.setStatus('current')
if mibBuilder.loadTexts: staDiPhaseB.setDescription('Reports input phase value versus clock B. \n        The phaseB is the current 1 second phase value in nanoseconds on clock B.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staDiPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiPql.setStatus('current')
if mibBuilder.loadTexts: staDiPql.setDescription('Reports input port Priority Quality Level (PQL). \n        The PQL is the current stratum level (read or provisioned) being reported by the port.\n        If zero, it is invalid.\n        ')
staDiPqlRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 8), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiPqlRcv.setStatus('current')
if mibBuilder.loadTexts: staDiPqlRcv.setDescription('Reports receiving Sync Status Message (SSM) for the input port state.\n\n        1 = enabled\n        2 = disabled\n        ')
staDiLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 9), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiLOS.setStatus('current')
if mibBuilder.loadTexts: staDiLOS.setDescription('Reports input port has LOS fault.\n        ')
staDiAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 10), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiAIS.setStatus('current')
if mibBuilder.loadTexts: staDiAIS.setDescription('Reports input port has AIS fault.\n        ')
staDiOOF = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 11), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiOOF.setStatus('current')
if mibBuilder.loadTexts: staDiOOF.setDescription('Reports input port has OOF fault.\n        ')
staDiBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 12), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiBPV.setStatus('current')
if mibBuilder.loadTexts: staDiBPV.setDescription('Reports input port has BPV fault.\n        ')
staDiCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 13), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiCRC.setStatus('current')
if mibBuilder.loadTexts: staDiCRC.setDescription('Reports input port CRC fault.\n        ')
staDiMtie1A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiMtie1A.setStatus('current')
if mibBuilder.loadTexts: staDiMtie1A.setDescription('Reports which MTIE limit 1 threshold was exceeded versus clock A.\n\n        If ok, it means no error for MTIE limit 1 on clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded versus clock A.\n        ')
staDiMtie2A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiMtie2A.setStatus('current')
if mibBuilder.loadTexts: staDiMtie2A.setDescription('Reports which MTIE limit 2 threshold was exceeded versus clock A.\n\n        If ok, it means no error for MTIE limit 2 versus clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded versus clock A.\n        ')
staDiMtie1B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiMtie1B.setStatus('current')
if mibBuilder.loadTexts: staDiMtie1B.setDescription('Reports which MTIE limit 1 threshold was exceeded verus clock B.\n\n        If ok, it means no error for MTIE limit 1 versus clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded versus clock B.\n        ')
staDiMtie2B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiMtie2B.setStatus('current')
if mibBuilder.loadTexts: staDiMtie2B.setDescription('Reports which MTIE limit 2 threshold was exceeded versus clock B.\n\n        If ok, it means no error for MTIE limit 2 versus clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded versus clock B.\n        ')
staDiFreqA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 18), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiFreqA.setStatus('current')
if mibBuilder.loadTexts: staDiFreqA.setDescription('Reports input port frequency threshold exceeded versus clock A.\n        ')
staDiFreqB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 19), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiFreqB.setStatus('current')
if mibBuilder.loadTexts: staDiFreqB.setDescription('Reports input port frequency threshold exceeded versus clock B.\n        ')
staLOSErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLOSErCnt.setStatus('current')
if mibBuilder.loadTexts: staLOSErCnt.setDescription('Reports input port LOS error count.\n        ')
staLOSClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLOSClCnt.setStatus('current')
if mibBuilder.loadTexts: staLOSClCnt.setDescription('Reports input port LOS clear count.\n        ')
staAISErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staAISErCnt.setStatus('current')
if mibBuilder.loadTexts: staAISErCnt.setDescription('Reports input port AIS error count.\n        ')
staAISClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staAISClCnt.setStatus('current')
if mibBuilder.loadTexts: staAISClCnt.setDescription('Reports input port AIS clear count.\n        ')
staOOFErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOOFErCnt.setStatus('current')
if mibBuilder.loadTexts: staOOFErCnt.setDescription('Reports input port OOF error count.\n        ')
staOOFClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOOFClCnt.setStatus('current')
if mibBuilder.loadTexts: staOOFClCnt.setDescription('Reports input port OOF clear count.\n        ')
staBPVErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staBPVErCnt.setStatus('current')
if mibBuilder.loadTexts: staBPVErCnt.setDescription('Reports input port BPV error count.\n        ')
staBPVClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staBPVClCnt.setStatus('current')
if mibBuilder.loadTexts: staBPVClCnt.setDescription('Reports input port BPV clear count.\n        ')
staCRCErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCRCErCnt.setStatus('current')
if mibBuilder.loadTexts: staCRCErCnt.setDescription('Reports input port CRC error count.\n        ')
staCRCClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCRCClCnt.setStatus('current')
if mibBuilder.loadTexts: staCRCClCnt.setDescription('Reports input port CRC clear count.\n        ')
staDiMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 7, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("disable", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staDiMStatus.setStatus('current')
if mibBuilder.loadTexts: staDiMStatus.setDescription('The input module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(2), -- module is disabled\n        fault(3) -- module is enabled and operating with fault(s)\n        ')
staCcInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2), )
if mibBuilder.loadTexts: staCcInpTable.setStatus('current')
if mibBuilder.loadTexts: staCcInpTable.setDescription('A list of Composite Clock Input status information. \n        ')
staCiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staCiChassis"), (0, "SSU2000-MIB", "staCiSlot"), (0, "SSU2000-MIB", "staCiPort"))
if mibBuilder.loadTexts: staCiEntry.setStatus('current')
if mibBuilder.loadTexts: staCiEntry.setDescription('Input port status attributes.\n    ')
staCiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staCiChassis.setStatus('current')
if mibBuilder.loadTexts: staCiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one.\n        (i.e. in the main chassis)\n        ')
staCiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staCiSlot.setStatus('current')
if mibBuilder.loadTexts: staCiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staCiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: staCiPort.setStatus('current')
if mibBuilder.loadTexts: staCiPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staCiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiStatus.setStatus('current')
if mibBuilder.loadTexts: staCiStatus.setDescription('Reports input port status.\n        ok(1), -- port is enabled & operating without faults\n        selected(2), -- port is selected as system reference\n        disable(3), -- port is diabled\n        fault(4) -- port is enabled & operating with fault(s)\n        ')
staCiPhaseA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiPhaseA.setStatus('current')
if mibBuilder.loadTexts: staCiPhaseA.setDescription('Reports input phase value versus clock A. \n        The phaseA is the current 1 second phase value in nanoseconds on clock A.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staCiPhaseB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiPhaseB.setStatus('current')
if mibBuilder.loadTexts: staCiPhaseB.setDescription('Reports input phase value versus clock B. \n        The phaseB is the current 1 second phase value in nanoseconds on clock B.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staCiLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 9), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiLOS.setStatus('current')
if mibBuilder.loadTexts: staCiLOS.setDescription('Reports input port has LOS fault.\n        ')
staCiBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 12), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiBPV.setStatus('current')
if mibBuilder.loadTexts: staCiBPV.setDescription('Reports input port has BPV fault.\n        ')
staCiLOSErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiLOSErCnt.setStatus('current')
if mibBuilder.loadTexts: staCiLOSErCnt.setDescription('Reports input port LOS error count.\n        ')
staCiLOSClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiLOSClCnt.setStatus('current')
if mibBuilder.loadTexts: staCiLOSClCnt.setDescription('Reports input port LOS clear count.\n        ')
staCiBPVErCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiBPVErCnt.setStatus('current')
if mibBuilder.loadTexts: staCiBPVErCnt.setDescription('Reports input port BPV error count.\n        ')
staCiBPVClCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiBPVClCnt.setStatus('current')
if mibBuilder.loadTexts: staCiBPVClCnt.setDescription('Reports input port BPV clear count.\n        ')
staCiMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 8, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("disable", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staCiMStatus.setStatus('current')
if mibBuilder.loadTexts: staCiMStatus.setDescription('Reports input module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(2), -- module is disabled\n        fault(3) -- module is enabled and operating with fault(s)\n        ')
staSineInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2), )
if mibBuilder.loadTexts: staSineInpTable.setStatus('current')
if mibBuilder.loadTexts: staSineInpTable.setDescription('A list of Sine Input status information.\n    ')
staSineiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staSineiChassis"), (0, "SSU2000-MIB", "staSineiSlot"), (0, "SSU2000-MIB", "staSineiPort"))
if mibBuilder.loadTexts: staSineiEntry.setStatus('current')
if mibBuilder.loadTexts: staSineiEntry.setDescription('Input port status attributes.\n    ')
staSineiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staSineiChassis.setStatus('current')
if mibBuilder.loadTexts: staSineiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one.\n        (i.e. in the main chassis)\n        ')
staSineiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staSineiSlot.setStatus('current')
if mibBuilder.loadTexts: staSineiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staSineiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: staSineiPort.setStatus('current')
if mibBuilder.loadTexts: staSineiPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staSineiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiStatus.setStatus('current')
if mibBuilder.loadTexts: staSineiStatus.setDescription('Reports input port status.\n        ok(1), -- port is enabled & operating without faults\n        selected(2), -- port is selected as system reference\n        disable(3), -- port is diabled\n        fault(4) -- port is enabled & operating with fault(s)\n        ')
staSineiPhaseA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiPhaseA.setStatus('current')
if mibBuilder.loadTexts: staSineiPhaseA.setDescription('Reports input phase value versus clock A. \n        The phaseA is the current 1 second phase value in nanoseconds on clock A.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staSineiPhaseB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiPhaseB.setStatus('current')
if mibBuilder.loadTexts: staSineiPhaseB.setDescription('Reports input phase value versus clock B. \n        The phaseB is the current 1 second phase value in nanoseconds on clock B.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staSineiLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 7), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiLOS.setStatus('current')
if mibBuilder.loadTexts: staSineiLOS.setDescription('Reports input port has LOS fault.\n        ')
staSineiMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("disable", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiMStatus.setStatus('current')
if mibBuilder.loadTexts: staSineiMStatus.setDescription('Reports input module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(2), -- module is disabled\n        fault(3) -- module is enabled and operating with fault(s)\n        ')
staSineiPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiPql.setStatus('current')
if mibBuilder.loadTexts: staSineiPql.setDescription('Reports input port Priority Quality Level (PQL). \n        The PQL is the current stratum level (read or provisioned) being reported by the port.\n        If zero, it is invalid.\n        ')
staSineiMtie1A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiMtie1A.setStatus('current')
if mibBuilder.loadTexts: staSineiMtie1A.setDescription('Reports which MTIE limit 1 threshold was exceeded versus clock A.\n\n        If ok, it means no error for MTIE limit 1 on clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded versus clock A.\n        ')
staSineiMtie2A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiMtie2A.setStatus('current')
if mibBuilder.loadTexts: staSineiMtie2A.setDescription('Reports which MTIE limit 2 threshold was exceeded versus clock A.\n\n        If ok, it means no error for MTIE limit 2 versus clock A.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded versus clock A.\n        ')
staSineiMtie1B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiMtie1B.setStatus('current')
if mibBuilder.loadTexts: staSineiMtie1B.setDescription('Reports which MTIE limit 1 threshold was exceeded verus clock B.\n\n        If ok, it means no error for MTIE limit 1 versus clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 1 threshold was exceeded versus clock B.\n        ')
staSineiMtie2B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 100, 1000, 10000, 100000))).clone(namedValues=NamedValues(("ok", 1), ("mtie10", 10), ("mtie100", 100), ("mtie1000", 1000), ("mtie10000", 10000), ("mtie100000", 100000)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiMtie2B.setStatus('current')
if mibBuilder.loadTexts: staSineiMtie2B.setDescription('Reports which MTIE limit 2 threshold was exceeded versus clock B.\n\n        If ok, it means no error for MTIE limit 2 versus clock B.\n        If not, one of the 10/ 100/ 1000/ 10000/ 100000 seconds\n        MTIE limit 2 threshold was exceeded versus clock B.\n        ')
staSineiFreqA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 14), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiFreqA.setStatus('current')
if mibBuilder.loadTexts: staSineiFreqA.setDescription('Reports input port frequency threshold exceeded versus clock A.\n        ')
staSineiFreqB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 12, 2, 1, 15), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSineiFreqB.setStatus('current')
if mibBuilder.loadTexts: staSineiFreqB.setDescription('Reports input port frequency threshold exceeded versus clock B.\n        ')
staJccInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2), )
if mibBuilder.loadTexts: staJccInpTable.setStatus('current')
if mibBuilder.loadTexts: staJccInpTable.setDescription('A list of Composite Clock Input status information. \n        ')
staJcciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staCiChassis"), (0, "SSU2000-MIB", "staCiSlot"), (0, "SSU2000-MIB", "staCiPort"))
if mibBuilder.loadTexts: staJcciEntry.setStatus('current')
if mibBuilder.loadTexts: staJcciEntry.setDescription('Input port status attributes.\n    ')
staJcciChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: staJcciChassis.setStatus('current')
if mibBuilder.loadTexts: staJcciChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one.\n        (i.e. in the main chassis)\n        ')
staJcciSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staJcciSlot.setStatus('current')
if mibBuilder.loadTexts: staJcciSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staJcciPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: staJcciPort.setStatus('current')
if mibBuilder.loadTexts: staJcciPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
staJcciStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("selected", 2), ("disable", 3), ("fault", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciStatus.setStatus('current')
if mibBuilder.loadTexts: staJcciStatus.setDescription('Reports input port status.\n        ok(1), -- port is enabled & operating without faults\n        selected(2), -- port is selected as system reference\n        disable(3),  -- port is diabled\n        fault(4) -- port is enabled & operating with fault(s)\n        ')
staJcciPhaseA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciPhaseA.setStatus('current')
if mibBuilder.loadTexts: staJcciPhaseA.setDescription('Reports input phase value versus clock A. \n        The phaseA is the current 1 second phase value in nanoseconds on clock A.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staJcciPhaseB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1999999998, 1999999998), ValueRangeConstraint(1999999999, 1999999999), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciPhaseB.setStatus('current')
if mibBuilder.loadTexts: staJcciPhaseB.setDescription('Reports input phase value versus clock B. \n        The phaseB is the current 1 second phase value in nanoseconds on clock B.\n\n        The 1,999,999,999 is designated for invalid phase value.\n        ')
staJcciLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 7), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciLOS.setStatus('current')
if mibBuilder.loadTexts: staJcciLOS.setDescription('Reports input port has LOS fault.\n        ')
staJcciBPV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 8), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciBPV.setStatus('current')
if mibBuilder.loadTexts: staJcciBPV.setDescription('Reports input port has BPV fault.\n        ')
staJcci400Hz = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 9), OnValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcci400Hz.setStatus('current')
if mibBuilder.loadTexts: staJcci400Hz.setDescription('Reports input port has 400Hz Sync Signal or not.\n        ')
staJcciMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 13, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("disable", 2), ("fault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staJcciMStatus.setStatus('current')
if mibBuilder.loadTexts: staJcciMStatus.setDescription('Reports input module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(2), -- module is disabled\n        fault(3) -- module is enabled and operating with fault(s)\n        ')
staOutTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2), )
if mibBuilder.loadTexts: staOutTable.setStatus('current')
if mibBuilder.loadTexts: staOutTable.setDescription('The list of Generic Output status information.\n    ')
staOtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staOtChassis"), (0, "SSU2000-MIB", "staOtSlot"))
if mibBuilder.loadTexts: staOtEntry.setStatus('current')
if mibBuilder.loadTexts: staOtEntry.setDescription('Output port status attributes.\n    ')
staOtChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staOtChassis.setStatus('current')
if mibBuilder.loadTexts: staOtChassis.setDescription('Identifies which shelf is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The output module can reside on any chassis (1-5).\n        ')
staOtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staOtSlot.setStatus('current')
if mibBuilder.loadTexts: staOtSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staOtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("disable", 3), ("fault", 4), ("reject", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtStatus.setStatus('current')
if mibBuilder.loadTexts: staOtStatus.setDescription('Reports output port status.\n        ok(1), -- modlule is enabled & operating without faults\n        disable(3), -- module is diabled\n        fault(4) -- module is enabled & operating with fault(s)\n        reject(5) -- module type is mismatched with redundant module\n        ')
staOtClkSel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("clkc", 3), ("clkd", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtClkSel.setStatus('current')
if mibBuilder.loadTexts: staOtClkSel.setDescription('Reports which clock is selected for generating the output.\n        clka(1), -- Clock A is selected as the Primary clock\n        clkb(2), -- Clock B is selected as the Primary clock\n        clkc(3), -- Clock C is selected as the Primary clock\n        clkd(4), -- Clock D is selected as the Primary clock\n        none(5) -- no clock is selected\n        ')
staOtClka = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 5), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtClka.setStatus('current')
if mibBuilder.loadTexts: staOtClka.setDescription('Reports that clock A is available.\n        ')
staOtClkb = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 6), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtClkb.setStatus('current')
if mibBuilder.loadTexts: staOtClkb.setDescription('Reports that clock B is available.\n        ')
staOtClkc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 7), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtClkc.setStatus('current')
if mibBuilder.loadTexts: staOtClkc.setDescription('Reports that clock C is available.\n        ')
staOtClkd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 8), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtClkd.setStatus('current')
if mibBuilder.loadTexts: staOtClkd.setDescription('Reports that clock D is available.\n            ')
staOtRednt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtRednt.setStatus('current')
if mibBuilder.loadTexts: staOtRednt.setDescription('Reports the adjacent slot number if this module is the output module redundant pair. \n        If this module is not redundant, zero is reported.\n            ')
staOtPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtPql.setStatus('current')
if mibBuilder.loadTexts: staOtPql.setDescription('Reports the Priority Quality Level (PQL) being generated.\n        If zero, it is invalid or Not Applicable.\n        ')
staOtPortSta = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 10, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: staOtPortSta.setStatus('current')
if mibBuilder.loadTexts: staOtPortSta.setDescription('Reports the status for ports 1-20.\n        1st digit represents port 1, 20th digit represents port 20\n        1 = ok\n        2 = not used\n        3 = internal port fault\n        4 = external port fault\n        5 = fault\n        6 = squelch\n        ')
staLrmMTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2), )
if mibBuilder.loadTexts: staLrmMTable.setStatus('current')
if mibBuilder.loadTexts: staLrmMTable.setDescription('A list of DS1 LRM module status information.\n    ')
staLrmMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staLrmMChassis"), (0, "SSU2000-MIB", "staLrmMSlot"))
if mibBuilder.loadTexts: staLrmMEntry.setStatus('current')
if mibBuilder.loadTexts: staLrmMEntry.setDescription('DS1 LRM module status attributes.\n    ')
staLrmMChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staLrmMChassis.setStatus('current')
if mibBuilder.loadTexts: staLrmMChassis.setDescription('Identifies which shelf is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The output module can reside on any chassis (1-5).\n        ')
staLrmMSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staLrmMSlot.setStatus('current')
if mibBuilder.loadTexts: staLrmMSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrmMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmMStatus.setStatus('current')
if mibBuilder.loadTexts: staLrmMStatus.setDescription('Reports the LRM module state.\n        enable(1),  -- module is enabled\n        disable(2), -- module is disabled\n        ')
staLrmMRefSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("clkc", 3), ("clkd", 4), ("none", 5), ("pllflt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmMRefSrc.setStatus('current')
if mibBuilder.loadTexts: staLrmMRefSrc.setDescription("Reports which clock is selected for generating the output and status.\n        clka(1), -- clock A is selected\n        clkb(2), -- clock B is selected\n        clkc(3), -- clock C is selected\n        clkd(4), -- clock D is selected\n        none(5), -- no clock is selected\n        pllflt(6) -- clock selected, but module's clock PLL is unlocked\n            ")
staLrmMCtaId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dual", 1), ("quad", 2), ("none", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmMCtaId.setStatus('current')
if mibBuilder.loadTexts: staLrmMCtaId.setDescription('Reports if CTA is installed or not, if installed it reports which type, 2 ports or quad (4) ports.\n        If not installed, none is shown. \n        If id is not recognized, unknown is shown.\n        ')
staLrmPTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3), )
if mibBuilder.loadTexts: staLrmPTable.setStatus('current')
if mibBuilder.loadTexts: staLrmPTable.setDescription('A list of DS1 LRM port status information.\n    ')
staLrmPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "staLrmPChassis"), (0, "SSU2000-MIB", "staLrmPSlot"), (0, "SSU2000-MIB", "staLrmPPort"))
if mibBuilder.loadTexts: staLrmPEntry.setStatus('current')
if mibBuilder.loadTexts: staLrmPEntry.setDescription('DS1 LRM module status attributes.\n    ')
staLrmPChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staLrmPChassis.setStatus('current')
if mibBuilder.loadTexts: staLrmPChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The output module can reside on any chassis (1-5).\n        ')
staLrmPSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staLrmPSlot.setStatus('current')
if mibBuilder.loadTexts: staLrmPSlot.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrmPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: staLrmPPort.setStatus('current')
if mibBuilder.loadTexts: staLrmPPort.setDescription('Identifies which port is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrmPStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("cut", 2), ("disable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPStatus.setStatus('current')
if mibBuilder.loadTexts: staLrmPStatus.setDescription('Reports LRM Port status.\n\t\tok(1), -- port is functioning\n\t\tcut(2), -- port is in cut-through mode\n\t\tdisable(3) -- port is disabled\n        ')
staLrmPFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("d4", 1), ("esf", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPFrame.setStatus('current')
if mibBuilder.loadTexts: staLrmPFrame.setDescription('Reports LRM Port frame status.\n\t\td4(1), -- D4 signal\n\t\tesf(2), -- ESF signal\n\t\tnone(3) -- indicate Loss Of Frame\n        ')
staLrmPLos = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 6), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPLos.setStatus('current')
if mibBuilder.loadTexts: staLrmPLos.setDescription('Reports LRM Port LOS status.\n        ')
staLrmPAis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 7), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPAis.setStatus('current')
if mibBuilder.loadTexts: staLrmPAis.setDescription('Reports LRM Port AIS status.\n        ')
staLrmPLof = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 8), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPLof.setStatus('current')
if mibBuilder.loadTexts: staLrmPLof.setDescription('Reports LRM Port LOF status.\n        ')
staLrmPBpv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 9), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpv.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpv.setDescription('Reports LRM Port BPV status.\n        ')
staLrmPSlip = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 10), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPSlip.setStatus('current')
if mibBuilder.loadTexts: staLrmPSlip.setDescription('Reports LRM Port SLIP status.\n            If over the past 24 hours period, the slip count exceeds the threshold, the slip alarm is set.\n            ')
staLrmPSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPSlips.setStatus('current')
if mibBuilder.loadTexts: staLrmPSlips.setDescription('Reports LRM Port slip counts.\n            ')
staLrmPLosSide2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 12), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPLosSide2.setStatus('current')
if mibBuilder.loadTexts: staLrmPLosSide2.setDescription('Reports LRM Port LOS on SIDE2 status.\n        ')
staLrmPBpvTestTime = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpvTestTime.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpvTestTime.setDescription('Reports length of time (in seconds) the BPV has been under tested.\n        ')
staLrmPBpv60SRate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpv60SRate.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpv60SRate.setDescription('Reports BPV Error Rate per second in 60-second window.\n        The format is an ascii text string in float number.\n        ')
staLrmPBpv24HRate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpv24HRate.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpv24HRate.setDescription('Reports BPV Error Rate per second in 86400-second (24 hours) window.\n        The format is an ascii text string in float number.\n        ')
staLrmPBpvErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpvErrSecs.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpvErrSecs.setDescription('Reports accumulated BPV Errored Seconds.\n        ')
staLrmPBpvSevErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpvSevErrSecs.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpvSevErrSecs.setDescription('Reports accumulated BPV Severely Errored Seconds.\n        ')
staLrmPBpvSevErrRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 11, 3, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrmPBpvSevErrRatio.setStatus('current')
if mibBuilder.loadTexts: staLrmPBpvSevErrRatio.setDescription('Reports BPV Severely Error Ratio.\n        The format is an ascii text string in float number.\n        ')
staLrme1MTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2), )
if mibBuilder.loadTexts: staLrme1MTable.setStatus('current')
if mibBuilder.loadTexts: staLrme1MTable.setDescription('A list of E1 LRM port status information.\n    ')
staLrme1MEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "staLrme1MChassis"), (0, "SSU2000-MIB", "staLrme1MSlot"))
if mibBuilder.loadTexts: staLrme1MEntry.setStatus('current')
if mibBuilder.loadTexts: staLrme1MEntry.setDescription('E1 LRM module status attributes.\n    ')
staLrme1MChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staLrme1MChassis.setStatus('current')
if mibBuilder.loadTexts: staLrme1MChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The output module can reside on any chassis (1-5).\n        ')
staLrme1MSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staLrme1MSlot.setStatus('current')
if mibBuilder.loadTexts: staLrme1MSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrme1MStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1MStatus.setStatus('current')
if mibBuilder.loadTexts: staLrme1MStatus.setDescription('Reports the LRM module state.\n        enable(1),  -- module is enabled\n        disable(2), -- module is disabled\n        ')
staLrme1MRefSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("clkc", 3), ("clkd", 4), ("none", 5), ("pllflt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1MRefSrc.setStatus('current')
if mibBuilder.loadTexts: staLrme1MRefSrc.setDescription("Reports which clock is selected for generating the output and status.\n        clka(1), -- clock A is selected\n        clkb(2), -- clock B is selected\n        clkc(3), -- clock C is selected\n        clkd(4), -- clock D is selected\n        none(5), -- no clock is selected\n        pllflt(6) -- clock selected, but module's clock PLL is unlocked\n\t\t")
staLrme1MCtaId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dual", 1), ("quad", 2), ("none", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1MCtaId.setStatus('current')
if mibBuilder.loadTexts: staLrme1MCtaId.setDescription('Reports if CTA is installed or not.\n        If installed it reports which type, 2 ports or quad (4) ports.\n        If not installed, none is shown. \n        If id is not recognized, unknown is shown.\n        ')
staLrme1PTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3), )
if mibBuilder.loadTexts: staLrme1PTable.setStatus('current')
if mibBuilder.loadTexts: staLrme1PTable.setDescription('A list of E1 LRM port status information.\n    ')
staLrme1PEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "staLrme1PChassis"), (0, "SSU2000-MIB", "staLrme1PSlot"), (0, "SSU2000-MIB", "staLrme1PPort"))
if mibBuilder.loadTexts: staLrme1PEntry.setStatus('current')
if mibBuilder.loadTexts: staLrme1PEntry.setDescription('E1 LRM module status attributes.\n    ')
staLrme1PChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staLrme1PChassis.setStatus('current')
if mibBuilder.loadTexts: staLrme1PChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The output module can reside on any chassis (1-5).\n        ')
staLrme1PSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staLrme1PSlot.setStatus('current')
if mibBuilder.loadTexts: staLrme1PSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrme1PPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: staLrme1PPort.setStatus('current')
if mibBuilder.loadTexts: staLrme1PPort.setDescription('Identifies which port is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staLrme1PStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("cut", 2), ("disable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PStatus.setStatus('current')
if mibBuilder.loadTexts: staLrme1PStatus.setDescription('Reports LRM Port status.\n\t\tok(1), -- port is functioning\n\t\tcut(2), -- port is in cut-through mode\n\t\tdisable(3) -- port is disabled\n        ')
staLrme1PFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 5), OnValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PFrame.setStatus('current')
if mibBuilder.loadTexts: staLrme1PFrame.setDescription('Reports LRM Port frame status.\n\t\tcas(1), -- CAS signal\n\t\tccs(2), -- CCS signal\n\t\tnone(3) -- indicate Loss Of Frame\n        ')
staLrme1PLos = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 6), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PLos.setStatus('current')
if mibBuilder.loadTexts: staLrme1PLos.setDescription('Reports LRM Port LOS status.\n            ')
staLrme1PAis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 7), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PAis.setStatus('current')
if mibBuilder.loadTexts: staLrme1PAis.setDescription('Reports LRM Port AIS status.\n            ')
staLrme1PLof = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 8), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PLof.setStatus('current')
if mibBuilder.loadTexts: staLrme1PLof.setDescription('Reports LRM Port LOF status.\n            ')
staLrme1PBpv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 9), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpv.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpv.setDescription('Reports LRM Port BPV status.\n            ')
staLrme1PSlip = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 10), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PSlip.setStatus('current')
if mibBuilder.loadTexts: staLrme1PSlip.setDescription('Reports LRM Port SLIP status.\n            If over the past 24 hours period, the slip count exceeds the threshold, the slip alarm is set.\n            ')
staLrme1PSlips = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PSlips.setStatus('current')
if mibBuilder.loadTexts: staLrme1PSlips.setDescription('Reports LRM Port slip counts.\n            ')
staLrme1PLosSide2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 12), OkValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PLosSide2.setStatus('current')
if mibBuilder.loadTexts: staLrme1PLosSide2.setDescription('Reports LRM Port LOS on SIDE2 status.\n            ')
staLrme1PBpv60SRate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpv60SRate.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpv60SRate.setDescription('Reports length of time (in seconds) the BPV has been under tested.\n        The format is an ascii text string in float number.\n        ')
staLrme1PBpv24HRate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpv24HRate.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpv24HRate.setDescription('Reports BPV Error Rate per second in 86400-second (24 hours) window.\n        The format is an ascii text string in float number.\n        ')
staLrme1PBpvErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpvErrSecs.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpvErrSecs.setDescription('Reports accumulated BPV Errored Seconds.\n        ')
staLrme1PBpvSevErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpvSevErrSecs.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpvSevErrSecs.setDescription('Reports accumulated BPV Severely Errored Seconds.\n        ')
staLrme1PBpvSevErrRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 14, 3, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staLrme1PBpvSevErrRatio.setStatus('current')
if mibBuilder.loadTexts: staLrme1PBpvSevErrRatio.setDescription('Reports BPV Severely Error Ratio.\n        The format is an ascii text string in float number.\n        ')
staPtNtpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1), )
if mibBuilder.loadTexts: staPtNtpTable.setStatus('current')
if mibBuilder.loadTexts: staPtNtpTable.setDescription('A list of PackeTime NTP status information.\n    ')
staPtNtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "staPtNtpChassis"), (0, "SSU2000-MIB", "staPtNtpSlot"))
if mibBuilder.loadTexts: staPtNtpEntry.setStatus('current')
if mibBuilder.loadTexts: staPtNtpEntry.setDescription('PackeTime NTP status attributes.\n    ')
staPtNtpChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staPtNtpChassis.setStatus('current')
if mibBuilder.loadTexts: staPtNtpChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staPtNtpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staPtNtpSlot.setStatus('current')
if mibBuilder.loadTexts: staPtNtpSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staPtNtpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("disable", 3), ("fault", 4), ("reject", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpStatus.setStatus('current')
if mibBuilder.loadTexts: staPtNtpStatus.setDescription('The PackeTime NTP module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(3), -- module is disabled\n        fault(4), -- module is enabled and operating with fault(s)\n        reject(5) -- module type between redundant modules do not agree\n        ')
staPtNtpClkSel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("clkc", 3), ("clkd", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpClkSel.setStatus('current')
if mibBuilder.loadTexts: staPtNtpClkSel.setDescription('Reports which clock reference is selected to generate the output reference.\n        clka(1), -- Clock A is selected as the Primary clock\n        clkb(2), -- Clock B is selected as the Primary clock\n        clkc(3), -- Clock C is selected as the Primary clock\n        clkd(4), -- Clock D is selected as the Primary clock\n        none(5) -- no clock is selected\n        ')
staPtNtpClka = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 5), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpClka.setStatus('current')
if mibBuilder.loadTexts: staPtNtpClka.setDescription('Reports that clock A is available.\n        ')
staPtNtpClkb = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 6), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpClkb.setStatus('current')
if mibBuilder.loadTexts: staPtNtpClkb.setDescription('Reports that clock B is available.\n        ')
staPtNtpClkc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 7), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpClkc.setStatus('current')
if mibBuilder.loadTexts: staPtNtpClkc.setDescription('Reports that clock C is available.\n        ')
staPtNtpClkd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 8), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpClkd.setStatus('current')
if mibBuilder.loadTexts: staPtNtpClkd.setDescription('Reports that clock D is available.\n        ')
staPtNtpRednt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpRednt.setStatus('current')
if mibBuilder.loadTexts: staPtNtpRednt.setDescription('Reports the adjacent slot number if this module is the redundant pair. \n        If this module is not redundant, zero is reported.\n        ')
staPtNtpModState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("stdby", 2), ("fault", 3), ("stdalone", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpModState.setStatus('current')
if mibBuilder.loadTexts: staPtNtpModState.setDescription('Reports the current operational mode.\n        active(1), --If the module is in redundant pair and selected, it shall return active.\n        stdby(2), --If the module is in redundant pair but not selected, it shall return stdby (standby).\n        fault(3), --If the module disabled, it will return fault.\n        stdalone(4) --If the module is not redundant pair, it shall return stdalone (standalone).\n        ')
staPtNtpPAState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("stdby", 2), ("fault", 3), ("stdalone", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpPAState.setStatus('current')
if mibBuilder.loadTexts: staPtNtpPAState.setDescription('Reports the current operational mode.\n        active(1), --If service ports are bonded and selected, it shall return active.\n        stdby(2), --If service ports are bonded but not selected, it shall return stdby (standby).\n        fault(3), --Service port is faulted.\n        stdalone(4) --If service ports are not bonded , it shall return stdalone (standalone).\n        ')
staPtNtpPBState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("stdby", 2), ("fault", 3), ("stdalone", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpPBState.setStatus('current')
if mibBuilder.loadTexts: staPtNtpPBState.setDescription('Reports the current operational mode.\n        active(1), --If service ports are bonded and selected, it shall return active.\n        stdby(2), --If service ports are bonded but not selected, it shall return stdby (standby).\n        fault(3), --Service port is faulted.\n        stdalone(4) --If service ports are not bonded , it shall return stdalone (standalone).\n        ')
staPtNtpTod = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 13), OnValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpTod.setStatus('current')
if mibBuilder.loadTexts: staPtNtpTod.setDescription('Reports if the NTP Time of Day is valid or invalid.\n        ')
staPtNtpCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 15, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("done", 1), ("prog", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtNtpCommit.setStatus('current')
if mibBuilder.loadTexts: staPtNtpCommit.setDescription('Reports the Commit command status.\n        1 = done\n        2 = in progress\n        ')
setCmId = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: setCmId.setStatus('current')
if mibBuilder.loadTexts: setCmId.setDescription("The system identifier, the value is always 'SSU2000'.\n        ")
setCmInfo = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: setCmInfo.setStatus('current')
if mibBuilder.loadTexts: setCmInfo.setDescription('Symmetricom contact information.\n        This displays the Symmetricom address, phone, and fax numbers.\n        ')
setCmVer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: setCmVer.setStatus('current')
if mibBuilder.loadTexts: setCmVer.setDescription("Reports Communication module's software version\n        ")
setCmName = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCmName.setStatus('current')
if mibBuilder.loadTexts: setCmName.setDescription('Set the user assigned name for the SSU2000.\n\n        Note: Use caution when changing this, TL1 sessions use the unit name as the target id (tid).\n        ')
setClkTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1), )
if mibBuilder.loadTexts: setClkTable.setStatus('current')
if mibBuilder.loadTexts: setClkTable.setDescription('A list of clock status and setting information.\n    ')
setCkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "setCkChassis"), (0, "SSU2000-MIB", "setCkSlot"))
if mibBuilder.loadTexts: setCkEntry.setStatus('current')
if mibBuilder.loadTexts: setCkEntry.setDescription('Clock status and setting attributes.\n    ')
setCkChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setCkChassis.setStatus('current')
if mibBuilder.loadTexts: setCkChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setCkSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setCkSlot.setStatus('current')
if mibBuilder.loadTexts: setCkSlot.setDescription('Identifies which slot is being addressed. \n        This slot number and chassis number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for Clocks are slot 1 and slot 12.\n        ')
setCkWarmup = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(900, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkWarmup.setStatus('current')
if mibBuilder.loadTexts: setCkWarmup.setDescription('Set the clock warmup time in seconds.\n        ')
setCkMinTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(150, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkMinTau.setStatus('current')
if mibBuilder.loadTexts: setCkMinTau.setDescription('Set the clock minimum tau. \n        The mintau is the starting time constant value during Locked mode.\n        ')
setCkMaxTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(150, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkMaxTau.setStatus('current')
if mibBuilder.loadTexts: setCkMaxTau.setDescription('Set the clock max tau. \n        The maxtau is the final time constant value during Locked mode.\n        ')
setCkPLLMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("acq", 2), ("lock", 3), ("hold", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkPLLMode.setStatus('current')
if mibBuilder.loadTexts: setCkPLLMode.setDescription('Set the clock operating mode to ACQ/ LOCK/ HOLD.\n         Note: When WRITE is to request Clock to change its operating mode, but\n           when READ, it returns status of current operating mode. If current is \n\t\t   operating mode is Warmup, it will return as HOLD.\n        ')
setCkTodTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkTodTimeout.setStatus('current')
if mibBuilder.loadTexts: setCkTodTimeout.setDescription('Set the TODSRC Timeout. \n        The TOD Traceability Timeout shall allow the system to operate without a valid \n        TOD source for some amount of time before indicating the ToD source is invalid.  \n        The timer shall have a user settable range from 60 to 10000 minutes,  \n        with a default value of 1440.           \n        ')
setCkFreqTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCkFreqTimeout.setStatus('current')
if mibBuilder.loadTexts: setCkFreqTimeout.setDescription('Set the Frequency Timeout. \n        The Frequency Traceability Timeout shall allow the system to operate without a valid \n        input reference for some amount of time before indicating the frequency source is invalid.  \n        The timer shall have a user settable range from 60 to 10000 minutes,  \n        with a default value of 1440.           \n        ')
setGpsTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1), )
if mibBuilder.loadTexts: setGpsTable.setStatus('current')
if mibBuilder.loadTexts: setGpsTable.setDescription('A list of GPS status and setting information.\n        ')
setGpsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "setGpsChassis"), (0, "SSU2000-MIB", "setGpsSlot"))
if mibBuilder.loadTexts: setGpsEntry.setStatus('current')
if mibBuilder.loadTexts: setGpsEntry.setDescription('GPS status and setting attributes.\n    ')
setGpsChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setGpsChassis.setStatus('current')
if mibBuilder.loadTexts: setGpsChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setGpsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setGpsSlot.setStatus('current')
if mibBuilder.loadTexts: setGpsSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
setGpsEngine = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("na", 1), ("unknown", 2), ("mot", 3), ("nvs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: setGpsEngine.setStatus('current')
if mibBuilder.loadTexts: setGpsEngine.setDescription('Reports the GPS engine manufacturer.\n        na(1), -- not available\n        unknown(2), -- unknown\n        mot(3) -- motorola (or motorola compatible)\n        nvs(4) -- NVS engine (or GLONASS compatible)\n        ')
setGpsProvPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsProvPql.setStatus('current')
if mibBuilder.loadTexts: setGpsProvPql.setDescription('Set the input port provisioned Priority Quality Level (PQL) value.\n        Note: Valid values are 1 - 9.\n        ')
setGpsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsPriority.setStatus('current')
if mibBuilder.loadTexts: setGpsPriority.setDescription('Set the input port priority level.\n        The 0 is for monitor-only mode. \n        The 1 is the highest priority.\n        The 10 is the lowest priority.\n        ')
setGpsPdop = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsPdop.setStatus('current')
if mibBuilder.loadTexts: setGpsPdop.setDescription('Set the PDOP mask [3 to 10].\n        ')
setGpsPosel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsPosel.setStatus('current')
if mibBuilder.loadTexts: setGpsPosel.setDescription('Set the minimum satellite elevation mask for positioning [0 to 90 deg].\n        ')
setGpsTimel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsTimel.setStatus('current')
if mibBuilder.loadTexts: setGpsTimel.setDescription('Set the minimum satellite elevation mask for timing [0 to 90 deg].\n        ')
setGpsAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsAvg.setStatus('current')
if mibBuilder.loadTexts: setGpsAvg.setDescription('Set satellite position averaging value [20-3600].\n\t\tMot GPS:  (20 - 3600) of averages for the calculated position fixes\n\t\tNVS GNSS: (20 - 1440) of averaging minutes\n        ')
setGpsLat = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 10), TLatAndLon()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsLat.setStatus('current')
if mibBuilder.loadTexts: setGpsLat.setDescription('Set the antenna latitude of the GPS antenna.\n\n        The format is +dd:mm:ss.ss or -dd:mm:ss.ss\n        The latitude is +/- 90 deg.\n        ')
setGpsLon = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 11), TLatAndLon()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsLon.setStatus('current')
if mibBuilder.loadTexts: setGpsLon.setDescription('Set the antenna longitude of the GPS antenna.\n\n        The format is +dd:mm:ss.ss or -dd:mm:ss.ss\n        The longitude  is +/- 180 deg.\n        ')
setGpsHgt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 12), TAntHeight()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsHgt.setStatus('current')
if mibBuilder.loadTexts: setGpsHgt.setDescription('Set the antenna height (meter) of the GPS antenna.\n\n        The format is +hh.hh or -hh.hh\n        The height is +/- 10000.0 meters.\n        ')
setGpsZeroPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zeroPhA", 1), ("zeroPhB", 2), ("zeroPhAB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsZeroPhase.setStatus('current')
if mibBuilder.loadTexts: setGpsZeroPhase.setDescription('Set phase error to zero for this GPS port.\n        ZEROPHA - set phase A error to zero,\n        ZEROPHB - set phase B error to zero,\n        ZEROPHAB - set phase A and B to zero.\n\n        Note: This field only is meaningful during the write operation.\n        ')
setGpsTodsrcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsTodsrcPriority.setStatus('current')
if mibBuilder.loadTexts: setGpsTodsrcPriority.setDescription('Set the TODSRC (Time-Of-Day Source) priority.\n            The priority is the for the specified module as the TOD Source, default is 0, range can be 0 through 8. \n            Value 1 is the highest and 8 is the lowest. \n            If the value is zero, the specified module cannot be TOD Source.\n            ')
setGpsTodsrcCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGpsTodsrcCompensation.setStatus('current')
if mibBuilder.loadTexts: setGpsTodsrcCompensation.setDescription('Set the Antenna cable delay compensation {0  250} in the case of GPS \n        TOD Source(s) or the delay induced by the cable(s) used to connect \n        expansion shelves where the PackeTime ToD Source(s) is located in \n        relationship to the Main shelf. The time offset shall have a 100nS \n        resolution, thus the Delay value shall be multiplied by 100nS to \n        provide 1PPS compensation. \n\n        Valid user compensation values range is 0 thru 250 for a total compensation range of 0 to 25000nS (25uS). \n        ')
setGnssConsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("gps", 1), ("glonass", 2), ("gpsGlonass", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setGnssConsMode.setStatus('current')
if mibBuilder.loadTexts: setGnssConsMode.setDescription('Set constellation mode of GNSS engine.\n        gps(1), -- The constellation mode of gnss engine is gps.\n        glonass(2), -- The constellation mode of gnss engine is glonass\n        gpsGlonass(3), -- The constellation mode of gnss engine is gps+glonass.\n        ')
setAlmThGpsInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2), )
if mibBuilder.loadTexts: setAlmThGpsInpTable.setStatus('current')
if mibBuilder.loadTexts: setAlmThGpsInpTable.setDescription('A list of GPS input alarm attribute setup information. \n        ')
setMgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setMgChassis"), (0, "SSU2000-MIB", "setMgSlot"))
if mibBuilder.loadTexts: setMgEntry.setStatus('current')
if mibBuilder.loadTexts: setMgEntry.setDescription('Input alarm attributes and settings.\n    setMgChassis\n        Identifies which chassis is being addressed. \n    setMgSlot\n        Identifies which slot position is being addressed. \n    setMgMtieStd\n        Set the input port setting of the MTIE limits to predefined values.\n    setMgMtie10EL1\n        Set the input port MTIE 10 seconds error threshold for the first limit setting.\n    setMgMtie10EL2\n        Set the input port MTIE 10 seconds error threshold for the second limit setting.\n    setMgMtie10CL1\n        Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n    setMgMtie10CL2\n        Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n    setMgMtie100EL1\n        Set the input port MTIE 100 seconds error threshold for the first limit setting.\n    setMgMtie100EL2\n        Set the input port MTIE 100 seconds error threshold for the second limit setting.\n    setMgMtie100CL1\n        Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n    setMgMtie100CL2\n        Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n    setMgMtie1000EL1\n        Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n    setMgMtie1000EL2\n        Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n    setMgMtie1000CL1\n        Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n    setMgMtie1000CL2\n        Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n    setMgMtie10000EL1\n        Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n    setMgMtie10000EL2\n        Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n    setMgMtie10000CL1\n        Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n    setMgMtie10000CL2\n        Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n    setMgMtie100000EL1\n        Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n    setMgMtie100000EL2\n        Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n    setMgMtie100000CL1\n        Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n    setMgMtie100000CL2\n        Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n    setMgFreqAErrLmt\n        Set the input port frequency error threshold for clock A.\n    setMgFreqAClrLmt\n        Set the input port frequency clear threshold for clock A.\n    setMgFreqATau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock A.\n    setMgFreqBErrLmt\n        Set the input port frequency error threshold for clock B.\n    setMgFreqBClrLmt\n        Set the input port frequency clear threshold for clock B.\n    setMgFreqBTau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock B.\n    ')
setMgChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setMgChassis.setStatus('current')
if mibBuilder.loadTexts: setMgChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setMgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setMgSlot.setStatus('current')
if mibBuilder.loadTexts: setMgSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, valid slots for GPS are slot 3 and slot 5.\n        ')
setMgMtieStd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("prs", 1), ("ds1", 2), ("g811", 3), ("g823", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtieStd.setStatus('current')
if mibBuilder.loadTexts: setMgMtieStd.setDescription('Set the input port setting of the MTIE limits to predefined values.\n        prs(1), -- ANSI T1.101 PRS MTIE MASK\n        ds1(2), -- ANSI T1.101 DS1 MTIE MASK\n        g811(3), -- G.811 (PRC) MTIE MASK\n        g823(4) -- G.823 (SSU) MTIE MASK\n\n        This field is only meaningful for a write operation. \n        ')
setMgMtie10EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10EL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10EL1.setDescription('Set the input port MTIE 10 seconds error threshold for the first limit setting.\n        ')
setMgMtie10EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10EL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10EL2.setDescription('Set the input port MTIE 10 seconds error threshold for the second limit setting.\n        ')
setMgMtie10CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10CL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10CL1.setDescription('Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n        ')
setMgMtie10CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10CL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10CL2.setDescription('Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n            ')
setMgMtie100EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100EL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100EL1.setDescription('Set the input port MTIE 100 seconds error threshold for the first limit setting.\n        ')
setMgMtie100EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100EL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100EL2.setDescription('Set the input port MTIE 100 seconds error threshold for the second limit setting.\n        ')
setMgMtie100CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100CL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100CL1.setDescription('Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n        ')
setMgMtie100CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100CL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100CL2.setDescription('Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n        ')
setMgMtie1000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie1000EL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie1000EL1.setDescription('Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n        ')
setMgMtie1000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie1000EL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie1000EL2.setDescription('Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n        ')
setMgMtie1000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie1000CL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie1000CL1.setDescription('Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n        ')
setMgMtie1000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie1000CL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie1000CL2.setDescription('Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n        ')
setMgMtie10000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10000EL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10000EL1.setDescription('Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n        ')
setMgMtie10000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10000EL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10000EL2.setDescription('Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n        ')
setMgMtie10000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10000CL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10000CL1.setDescription('Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n        ')
setMgMtie10000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie10000CL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie10000CL2.setDescription('Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n        ')
setMgMtie100000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100000EL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100000EL1.setDescription('Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n        ')
setMgMtie100000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100000EL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100000EL2.setDescription('Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n        ')
setMgMtie100000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100000CL1.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100000CL1.setDescription('Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n        ')
setMgMtie100000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgMtie100000CL2.setStatus('current')
if mibBuilder.loadTexts: setMgMtie100000CL2.setDescription('Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n        ')
setMgFreqAErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqAErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMgFreqAErrLmt.setDescription('Set the input port frequency error threshold for clock A.\n        ')
setMgFreqAClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqAClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMgFreqAClrLmt.setDescription('Set the input port frequency clear threshold for clock A.\n        ')
setMgFreqATau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqATau.setStatus('current')
if mibBuilder.loadTexts: setMgFreqATau.setDescription('Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock A.\n        ')
setMgFreqBErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqBErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMgFreqBErrLmt.setDescription('Set the input port frequency error threshold for clock B.\n        ')
setMgFreqBClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqBClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMgFreqBClrLmt.setDescription('Set the input port frequency clear threshold for clock B.\n        ')
setMgFreqBTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 5, 2, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMgFreqBTau.setStatus('current')
if mibBuilder.loadTexts: setMgFreqBTau.setDescription('Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock B.\n        ')
setDs1E1InpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2), )
if mibBuilder.loadTexts: setDs1E1InpTable.setStatus('current')
if mibBuilder.loadTexts: setDs1E1InpTable.setDescription('The list of DS1/E1 attribute setup information. \n        ')
setDiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setDiChassis"), (0, "SSU2000-MIB", "setDiSlot"), (0, "SSU2000-MIB", "setDiPort"))
if mibBuilder.loadTexts: setDiEntry.setStatus('current')
if mibBuilder.loadTexts: setDiEntry.setDescription('Input status and settings attributes.\n    ')
setDiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setDiChassis.setStatus('current')
if mibBuilder.loadTexts: setDiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The input module can only reside in chassis 1 (main chassis).\n        ')
setDiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setDiSlot.setStatus('current')
if mibBuilder.loadTexts: setDiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setDiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setDiPort.setStatus('current')
if mibBuilder.loadTexts: setDiPort.setDescription('Identifies which port is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setDiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiEnable.setStatus('current')
if mibBuilder.loadTexts: setDiEnable.setDescription('Set the input port to enabled or disabled.\n        ')
setDiFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("esf", 1), ("d4", 2), ("ccs", 3), ("cas", 4), ("mhz1", 5), ("khz1544", 6), ("khz2048", 7), ("mhz5", 8), ("mhz10", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiFrame.setStatus('current')
if mibBuilder.loadTexts: setDiFrame.setDescription('Set the input framing type or clock frequency. \n        esf(1), -- T1 ESF \n        d4(2), -- T1 D4\n        ccs(3), -- E1 CCS\n        cas(4), -- E1 CAS\n        mhz1(5), -- Clock 1MHz\n        khz1544(6), -- Clock 1544kHz\n        khz2048(7), -- Clock 2048kHz\n        mhz5(8), -- Clock 5MHz\n        mhz10(9) -- Clock 10MHz\n        ')
setDiZS = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 6), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiZS.setStatus('current')
if mibBuilder.loadTexts: setDiZS.setDescription('Set Zero Supression (ZS) on the input port to enabled or disabled.\n        ')
setDiCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 7), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiCRC.setStatus('current')
if mibBuilder.loadTexts: setDiCRC.setDescription('Set CRC verificaiton on the input port to enabled or disabled.\n        ')
setDiSSM = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 8), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiSSM.setStatus('current')
if mibBuilder.loadTexts: setDiSSM.setDescription('Set Sync Status Messaging (SSM) on the input port to enabled or disabled..\n        ')
setDiProvPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiProvPql.setStatus('current')
if mibBuilder.loadTexts: setDiProvPql.setDescription('Set the input port provisioned Priority Quality Level (PQL).\n\n        Note: Valid values are 1 - 9.\n        ')
setDiPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiPriority.setStatus('current')
if mibBuilder.loadTexts: setDiPriority.setDescription("Set the input port priority level.\n        '0' = monitoring, \n        '1' = highest priority,\n        '10' = lowest priority.\n        ")
setDiGain = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 11), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiGain.setStatus('current')
if mibBuilder.loadTexts: setDiGain.setDescription('Set the input port gain setting to enabled or disabled.\n        ')
setDiCSFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("low", 2), ("high", 3), ("na", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiCSFlt.setStatus('current')
if mibBuilder.loadTexts: setDiCSFlt.setDescription('Set input Port 1 for external Cesium (CS) fault alarm logic level. \n        off(1), -- function is disabled\n        low(2), -- function is enabled, will trigger on low (0V) level\n        high(3), -- function is enabled, will trigger on high (+5v) level\n        na(4) -- not applicable\n\n        Note: only available for port one.\n        ')
setDiE1SsmBit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiE1SsmBit.setStatus('current')
if mibBuilder.loadTexts: setDiE1SsmBit.setDescription('Set the input port E1 Sync Status Message (SSM) bit position.\n\n        This command is only meaningful for the E1 input module.\n        For DS1, this value is always 4, and has no meaning (i.e. not used).\n        ')
setDiZeroPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zeroPhA", 1), ("zeroPhB", 2), ("zeroPhAB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiZeroPhase.setStatus('current')
if mibBuilder.loadTexts: setDiZeroPhase.setDescription('Set the phase error to zero for this input port.\n        ZEROPHA - set phase A error to zero,\n        ZEROPHB - set phase B error to zero,\n        ZEROPHAB - set phase A and B to zero.\n\n        Note: This field only is meaningful during the write operation.\n        ')
setDiMtieCalc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hz40", 1), ("hz1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDiMtieCalc.setStatus('current')
if mibBuilder.loadTexts: setDiMtieCalc.setDescription('Reports MTIE calculator (40Hz or 1Hz) being used\n\n        The number represents the input port setting for MTIE Calculator measurement. \n        - 40Hz - Selects the 40Hz MTIE values to set/clear MTIE alarms\n        - 1Hz - Selects the 1Hz MTIE values to set/clear MTIE alarms\n\n        Note: only available for port one.\n        ')
setAlmThDs1E1InpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4), )
if mibBuilder.loadTexts: setAlmThDs1E1InpTable.setStatus('current')
if mibBuilder.loadTexts: setAlmThDs1E1InpTable.setDescription('A list of DS1/E1 input alarm attributes and settings information.\n    ')
setMiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "setMiChassis"), (0, "SSU2000-MIB", "setMiSlot"), (0, "SSU2000-MIB", "setMiPort"))
if mibBuilder.loadTexts: setMiEntry.setStatus('current')
if mibBuilder.loadTexts: setMiEntry.setDescription('Input alarm attributes and settings.\n    setMiChassis\n        Identifies which chassis is being addressed. \n    setMiSlot\n        Identifies which slot position is being addressed. \n    setMiPort\n        Identifies which port position is being addressed. \n    setMiMtieStd\n        Set the input port setting of the MTIE limits to predefined values.\n    setMiMtie10EL1\n        Set the input port MTIE 10 seconds error threshold for the first limit setting.\n    setMiMtie10EL2\n        Set the input port MTIE 10 seconds error threshold for the second limit setting.\n    setMiMtie10CL1\n        Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n    setMiMtie10CL2\n        Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n    setMiMtie100EL1\n        Set the input port MTIE 100 seconds error threshold for the first limit setting.\n    setMiMtie100EL2\n        Set the input port MTIE 100 seconds error threshold for the second limit setting.\n    setMiMtie100CL1\n        Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n    setMiMtie100CL2\n        Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n    setMiMtie1000EL1\n        Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n    setMiMtie1000EL2\n        Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n    setMiMtie1000CL1\n        Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n    setMiMtie1000CL2\n        Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n    setMiMtie10000EL1\n        Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n    setMiMtie10000EL2\n        Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n    setMiMtie10000CL1\n        Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n    setMiMtie10000CL2\n        Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n    setMiMtie100000EL1\n        Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n    setMiMtie100000EL2\n        Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n    setMiMtie100000CL1\n        Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n    setMiMtie100000CL2\n        Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n    setMiFreqAErrLmt\n        Set the input port frequency error threshold for clock A.\n    setMiFreqAClrLmt\n        Set the input port frequency clear threshold for clock A.\n    setMiFreqATau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock A.\n    setMiFreqBErrLmt\n        Set the input port frequency error threshold for clock B.\n    setMiFreqBClrLmt\n        Set the input port frequency clear threshold for clock B.\n    setMiFreqBTau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock B.\n    setMiLOSErrCnt\n        Set the input port error count threshold for LOS signal faults.\n    setMiLOSClrCnt\n        Set the input port clear count threshold for LOS signal faults.\n    setMiAISErrCnt\n        Set the input port error count threshold for AIS signal faults.\n    setMiAISClrCnt\n        Set the input port clear count threshold for AIS signal faults.\n    setMiOOFErrCnt\n        Set the input port error count threshold for OOF signal faults.\n    setMiOOFClrCnt\n        Set the input port clear count threshold for OOF signal faults.\n    setMiBPVErrCnt\n        Set the input port error count threshold for BPV signal faults.\n    setMiBPVClrCnt\n        Set the input port clear count threshold for BPV signal faults.\n    setMiCRCErrCnt\n        Set the input port error count threshold for CRC signal faults.\n    setMiCRCClrCnt\n        Set the input port clear count threshold for CRC signal faults.\n    ')
setMiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setMiChassis.setStatus('current')
if mibBuilder.loadTexts: setMiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setMiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setMiSlot.setStatus('current')
if mibBuilder.loadTexts: setMiSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setMiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setMiPort.setStatus('current')
if mibBuilder.loadTexts: setMiPort.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setMiMtieStd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("prs", 1), ("ds1", 2), ("g811", 3), ("g823", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtieStd.setStatus('current')
if mibBuilder.loadTexts: setMiMtieStd.setDescription('Set the input port setting of the MTIE limits to predefined values.\n        prs(1), -- ANSI T1.101 PRS MTIE MASK\n        ds1(2), -- ANSI T1.101 DS1 MTIE MASK\n        g811(3), -- G.811 (PRC) MTIE MASK\n        g823(4) -- G.823 (SSU) MTIE MASK\n\n        This field is only meaningful for a write operation. \n        ')
setMiMtie10EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10EL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10EL1.setDescription('Set the input port MTIE 10 seconds error threshold for the first limit setting.\n        ')
setMiMtie10EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10EL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10EL2.setDescription('Set the input port MTIE 10 seconds error threshold for the second limit setting.\n        ')
setMiMtie10CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10CL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10CL1.setDescription('Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n            ')
setMiMtie10CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10CL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10CL2.setDescription('Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n        ')
setMiMtie100EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100EL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100EL1.setDescription('Set the input port MTIE 100 seconds error threshold for the first limit setting.\n        ')
setMiMtie100EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100EL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100EL2.setDescription('Set the input port MTIE 100 seconds error threshold for the second limit setting.\n        ')
setMiMtie100CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100CL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100CL1.setDescription('Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n        ')
setMiMtie100CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100CL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100CL2.setDescription('Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n        ')
setMiMtie1000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie1000EL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie1000EL1.setDescription('Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n        ')
setMiMtie1000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie1000EL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie1000EL2.setDescription('Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n        ')
setMiMtie1000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie1000CL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie1000CL1.setDescription('Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n        ')
setMiMtie1000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie1000CL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie1000CL2.setDescription('Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n        ')
setMiMtie10000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10000EL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10000EL1.setDescription('Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n        ')
setMiMtie10000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10000EL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10000EL2.setDescription('Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n        ')
setMiMtie10000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10000CL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10000CL1.setDescription('Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n        ')
setMiMtie10000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie10000CL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie10000CL2.setDescription('Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n        ')
setMiMtie100000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100000EL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100000EL1.setDescription('Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n        ')
setMiMtie100000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100000EL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100000EL2.setDescription('Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n        ')
setMiMtie100000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100000CL1.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100000CL1.setDescription('Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n        ')
setMiMtie100000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiMtie100000CL2.setStatus('current')
if mibBuilder.loadTexts: setMiMtie100000CL2.setDescription('Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n        ')
setMiFreqAErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqAErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMiFreqAErrLmt.setDescription('Set the input port frequency error threshold for clock A.\n        ')
setMiFreqAClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqAClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMiFreqAClrLmt.setDescription('Set the input port frequency clear threshold for clock A.\n        ')
setMiFreqATau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqATau.setStatus('current')
if mibBuilder.loadTexts: setMiFreqATau.setDescription('Set the time constant (tau), in seconds, used for the calculation of the Average Frequency for clock A.\n        ')
setMiFreqBErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqBErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMiFreqBErrLmt.setDescription('Set the input port frequency error threshold for clock B.\n        ')
setMiFreqBClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqBClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMiFreqBClrLmt.setDescription('Set the input port frequency clear threshold for clock B.\n        ')
setMiFreqBTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiFreqBTau.setStatus('current')
if mibBuilder.loadTexts: setMiFreqBTau.setDescription('Set the time constant (tau), in seconds, used for the calculation of the Average Frequency for clock B.\n        ')
setMiLOSErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiLOSErrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiLOSErrCnt.setDescription('Set the input port error count threshold for LOS signal faults.\n        ')
setMiLOSClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiLOSClrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiLOSClrCnt.setDescription('Set the input port clear count threshold for LOS signal faults.\n        ')
setMiAISErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiAISErrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiAISErrCnt.setDescription('Set the input port error count threshold for AIS signal faults.\n        ')
setMiAISClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiAISClrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiAISClrCnt.setDescription('Set the input port clear count threshold for AIS signal faults.\n        ')
setMiOOFErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiOOFErrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiOOFErrCnt.setDescription('Set the input port error count threshold for OOF signal faults.\n        ')
setMiOOFClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiOOFClrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiOOFClrCnt.setDescription('Set the input port clear count threshold for OOF signal faults.\n        ')
setMiBPVErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiBPVErrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiBPVErrCnt.setDescription('Set the input port error count threshold for BPV signal faults.\n        ')
setMiBPVClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiBPVClrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiBPVClrCnt.setDescription('Set the input port clear count threshold for BPV signal faults.\n        ')
setMiCRCErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiCRCErrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiCRCErrCnt.setDescription('Set the input port error count hreshold for CRC signal faults.\n        ')
setMiCRCClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 7, 4, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMiCRCClrCnt.setStatus('current')
if mibBuilder.loadTexts: setMiCRCClrCnt.setDescription('Set the input port clear count threshold for CRC signal faults.\n        ')
setCcInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2), )
if mibBuilder.loadTexts: setCcInpTable.setStatus('current')
if mibBuilder.loadTexts: setCcInpTable.setDescription('The list of CC Input attribute setup information. \n        ')
setCiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setCiChassis"), (0, "SSU2000-MIB", "setCiSlot"), (0, "SSU2000-MIB", "setCiPort"))
if mibBuilder.loadTexts: setCiEntry.setStatus('current')
if mibBuilder.loadTexts: setCiEntry.setDescription('Input status and settings attributes.\n    ')
setCiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setCiChassis.setStatus('current')
if mibBuilder.loadTexts: setCiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The input module can only reside in chassis 1 (main chassis).\n        ')
setCiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setCiSlot.setStatus('current')
if mibBuilder.loadTexts: setCiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setCiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setCiPort.setStatus('current')
if mibBuilder.loadTexts: setCiPort.setDescription('Identifies which port position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setCiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCiEnable.setStatus('current')
if mibBuilder.loadTexts: setCiEnable.setDescription('Set the input port to enabled or disabled.\n        ')
setCiProvPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCiProvPql.setStatus('current')
if mibBuilder.loadTexts: setCiProvPql.setDescription('Set the input port provisioned Priority Quality Level (PQL).\n\n        Note: Valid values are 1 - 9.\n        ')
setCiPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCiPriority.setStatus('current')
if mibBuilder.loadTexts: setCiPriority.setDescription("Set the input port priority level.\n        '0' = monitoring, \n        '1' = highest priority,\n        '10' = lowest priority.\n        ")
setCiZeroPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zeroPhA", 1), ("zeroPhB", 2), ("zeroPhAB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCiZeroPhase.setStatus('current')
if mibBuilder.loadTexts: setCiZeroPhase.setDescription('Set the phase error to zero for this input port.\n        ZEROPHA - set phase A error to zero,\n        ZEROPHB - set phase B error to zero,\n        ZEROPHAB - set phase A and B to zero.\n\n        Note: This field only is meaningful during the write operation.\n        ')
setAlmThCcInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4), )
if mibBuilder.loadTexts: setAlmThCcInpTable.setStatus('current')
if mibBuilder.loadTexts: setAlmThCcInpTable.setDescription('A list of CC input alarm attributes and settings information.\n    ')
setCimEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "setCimChassis"), (0, "SSU2000-MIB", "setCimSlot"), (0, "SSU2000-MIB", "setCimPort"))
if mibBuilder.loadTexts: setCimEntry.setStatus('current')
if mibBuilder.loadTexts: setCimEntry.setDescription('Input alarm attributes and settings.\n    setMiChassis\n        Identifies which chassis is being addressed. \n    setMiSlot\n        Identifies which slot position is being addressed. \n    setMiPort\n        Identifies which port position is being addressed. \n    setCimLOSErrCnt\n        Set the input port error count threshold for LOS signal faults.\n    setCimLOSClrCnt\n        Set the input port clear count threshold for LOS signal faults.\n    setCimBPVErrCnt\n        Set the input port error count threshold for BPV signal faults.\n    setCimBPVClrCnt\n        Set the input port clear count threshold for BPV signal faults.\n    ')
setCimChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setCimChassis.setStatus('current')
if mibBuilder.loadTexts: setCimChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setCimSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setCimSlot.setStatus('current')
if mibBuilder.loadTexts: setCimSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setCimPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setCimPort.setStatus('current')
if mibBuilder.loadTexts: setCimPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setCimLOSErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCimLOSErrCnt.setStatus('current')
if mibBuilder.loadTexts: setCimLOSErrCnt.setDescription('Set the input port error count threshold for LOS signal faults.\n        ')
setCimLOSClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCimLOSClrCnt.setStatus('current')
if mibBuilder.loadTexts: setCimLOSClrCnt.setDescription('Set the input port clear count threshold for LOS signal faults.\n        ')
setCimBPVErrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCimBPVErrCnt.setStatus('current')
if mibBuilder.loadTexts: setCimBPVErrCnt.setDescription('Set the input port error count threshold for BPV signal faults.\n        ')
setCimBPVClrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 8, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCimBPVClrCnt.setStatus('current')
if mibBuilder.loadTexts: setCimBPVClrCnt.setDescription('Set the input port clear count threshold for BPV signal faults.\n        ')
setSineInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2), )
if mibBuilder.loadTexts: setSineInpTable.setStatus('current')
if mibBuilder.loadTexts: setSineInpTable.setDescription('The list of Sine Input attribute setup information. \n        ')
setSineiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setSineiChassis"), (0, "SSU2000-MIB", "setSineiSlot"), (0, "SSU2000-MIB", "setSineiPort"))
if mibBuilder.loadTexts: setSineiEntry.setStatus('current')
if mibBuilder.loadTexts: setSineiEntry.setDescription('Input status and settings attributes.\n    ')
setSineiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setSineiChassis.setStatus('current')
if mibBuilder.loadTexts: setSineiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The input module can only reside in chassis 1 (main chassis).\n        ')
setSineiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setSineiSlot.setStatus('current')
if mibBuilder.loadTexts: setSineiSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setSineiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setSineiPort.setStatus('current')
if mibBuilder.loadTexts: setSineiPort.setDescription('Identifies which port position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setSineiEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiEnable.setStatus('current')
if mibBuilder.loadTexts: setSineiEnable.setDescription('Set the input port to enabled or disabled.\n        ')
setSineiFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1544, 1544), ValueRangeConstraint(6312, 6312), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiFrequency.setStatus('current')
if mibBuilder.loadTexts: setSineiFrequency.setDescription('Set input signal frequency. \n            The frequency can be set: 1.544MHZ/ 6.312MHz.\n            ')
setSineiProvPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiProvPql.setStatus('current')
if mibBuilder.loadTexts: setSineiProvPql.setDescription('Set the input port provisioned Priority Quality Level (PQL).\n\n        Note: Valid values are 1 - 9.\n        ')
setSineiPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiPriority.setStatus('current')
if mibBuilder.loadTexts: setSineiPriority.setDescription("Set the input port priority level.\n        '0' = monitoring, \n        '1' = highest priority,\n        '10' = lowest priority.\n        ")
setSineiCSFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("low", 2), ("high", 3), ("na", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiCSFlt.setStatus('current')
if mibBuilder.loadTexts: setSineiCSFlt.setDescription('Set input Port 1 for external Cesium (CS) fault alarm logic level. \n        off(1), -- function is disabled\n        low(2), -- function is enabled, will trigger on low (0V) level\n        high(3), -- function is enabled, will trigger on high (+5v) level\n        na(4) -- not applicable\n\n        Note: only available for port one.\n        ')
setSineiZeroPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zeroPhA", 1), ("zeroPhB", 2), ("zeroPhAB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineiZeroPhase.setStatus('current')
if mibBuilder.loadTexts: setSineiZeroPhase.setDescription('Set the phase error to zero for this input port.\n        ZEROPHA - set phase A error to zero,\n        ZEROPHB - set phase B error to zero,\n        ZEROPHAB - set phase A and B to zero.\n\n        Note: This field only is meaningful during the write operation.\n        ')
setAlmThSineInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4), )
if mibBuilder.loadTexts: setAlmThSineInpTable.setStatus('current')
if mibBuilder.loadTexts: setAlmThSineInpTable.setDescription('A list of Sine input alarm attributes and settings information.\n    ')
setMsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "setMsiChassis"), (0, "SSU2000-MIB", "setMsiSlot"), (0, "SSU2000-MIB", "setMsiPort"))
if mibBuilder.loadTexts: setMsiEntry.setStatus('current')
if mibBuilder.loadTexts: setMsiEntry.setDescription('Input alarm attributes and settings.\n    setMsiChassis\n        Identifies which chassis is being addressed. \n    setMsiSlot\n        Identifies which slot position is being addressed. \n    setMsiPort\n        Identifies which port position is being addressed. \n    setMsiMtieStd\n        Set the input port setting of the MTIE limits to predefined values.\n    setMsiMtie10EL1\n        Set the input port MTIE 10 seconds error threshold for the first limit setting.\n    setMsiMtie10EL2\n        Set the input port MTIE 10 seconds error threshold for the second limit setting.\n    setMsiMtie10CL1\n        Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n    setMsiMtie10CL2\n        Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n    setMsiMtie100EL1\n        Set the input port MTIE 100 seconds error threshold for the first limit setting.\n    setMsiMtie100EL2\n        Set the input port MTIE 100 seconds error threshold for the second limit setting.\n    setMsiMtie100CL1\n        Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n    setMsiMtie100CL2\n        Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n    setMsiMtie1000EL1\n        Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n    setMsiMtie1000EL2\n        Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n    setMsiMtie1000CL1\n        Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n    setMsiMtie1000CL2\n        Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n    setMsiMtie10000EL1\n        Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n    setMsiMtie10000EL2\n        Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n    setMsiMtie10000CL1\n        Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n    setMsiMtie10000CL2\n        Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n    setMsiMtie100000EL1\n        Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n    setMsiMtie100000EL2\n        Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n    setMsiMtie100000CL1\n        Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n    setMsiMtie100000CL2\n        Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n    setMsiFreqAErrLmt\n        Set the input port frequency error threshold for clock A.\n    setMsiFreqAClrLmt\n        Set the input port frequency clear threshold for clock A.\n    setMsiFreqATau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock A.\n    setMsiFreqBErrLmt\n        Set the input port frequency error threshold for clock B.\n    setMsiFreqBClrLmt\n        Set the input port frequency clear threshold for clock B.\n    setMsiFreqBTau\n        Set the Time constant (tau), in seconds, used for the calculation of the Average Frequency versus clock B.\n    ')
setMsiChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setMsiChassis.setStatus('current')
if mibBuilder.loadTexts: setMsiChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n\n        Note: In the SSU2000, this number is always one. (i.e. in the main chassis)\n        ')
setMsiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setMsiSlot.setStatus('current')
if mibBuilder.loadTexts: setMsiSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setMsiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setMsiPort.setStatus('current')
if mibBuilder.loadTexts: setMsiPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot number, and port number uniquely identify each inventory entry.\n        ')
setMsiMtieStd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("prs", 1), ("ds1", 2), ("g811", 3), ("g823", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtieStd.setStatus('current')
if mibBuilder.loadTexts: setMsiMtieStd.setDescription('Set the input port setting of the MTIE limits to predefined values.\n        prs(1), -- ANSI T1.101 PRS MTIE MASK\n        ds1(2), -- ANSI T1.101 DS1 MTIE MASK\n        g811(3), -- G.811 (PRC) MTIE MASK\n        g823(4) -- G.823 (SSU) MTIE MASK\n\n        This field is only meaningful for a write operation. \n        ')
setMsiMtie10EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10EL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10EL1.setDescription('Set the input port MTIE 10 seconds error threshold for the first limit setting.\n        ')
setMsiMtie10EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10EL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10EL2.setDescription('Set the input port MTIE 10 seconds error threshold for the second limit setting.\n        ')
setMsiMtie10CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10CL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10CL1.setDescription('Set the input port MTIE 10 seconds clear threshold for the first limit setting.\n        ')
setMsiMtie10CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10CL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10CL2.setDescription('Set the input port MTIE 10 seconds clear threshold for the second limit setting.\n        ')
setMsiMtie100EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100EL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100EL1.setDescription('Set the input port MTIE 100 seconds error threshold for the first limit setting.\n        ')
setMsiMtie100EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100EL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100EL2.setDescription('Set the input port MTIE 100 seconds error threshold for the second limit setting.\n        ')
setMsiMtie100CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100CL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100CL1.setDescription('Set the input port MTIE 100 seconds clear threshold for the first limit setting.\n        ')
setMsiMtie100CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100CL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100CL2.setDescription('Set the input port MTIE 100 seconds clear threshold for the second limit setting.\n        ')
setMsiMtie1000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie1000EL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie1000EL1.setDescription('Set the input port MTIE 1000 seconds error threshold for the first limit setting.\n        ')
setMsiMtie1000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie1000EL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie1000EL2.setDescription('Set the input port MTIE 1000 seconds error threshold for the second limit setting.\n        ')
setMsiMtie1000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie1000CL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie1000CL1.setDescription('Set the input port MTIE 1000 seconds clear threshold for the first limit setting.\n        ')
setMsiMtie1000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie1000CL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie1000CL2.setDescription('Set the input port MTIE 1000 seconds clear threshold for the second limit setting.\n        ')
setMsiMtie10000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10000EL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10000EL1.setDescription('Set the input port MTIE 10000 seconds error threshold for the first limit setting.\n        ')
setMsiMtie10000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10000EL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10000EL2.setDescription('Set the input port MTIE 10000 seconds error threshold for the second limit setting.\n        ')
setMsiMtie10000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10000CL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10000CL1.setDescription('Set the input port MTIE 10000 seconds clear threshold for the first limit setting.\n        ')
setMsiMtie10000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie10000CL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie10000CL2.setDescription('Set the input port MTIE 10000 seconds clear threshold for the second limit setting.\n        ')
setMsiMtie100000EL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100000EL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100000EL1.setDescription('Set the input port MTIE 100000 seconds error threshold for the first limit setting.\n        ')
setMsiMtie100000EL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100000EL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100000EL2.setDescription('Set the input port MTIE 100000 seconds error threshold for the second limit setting.\n        ')
setMsiMtie100000CL1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100000CL1.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100000CL1.setDescription('Set the input port MTIE 100000 seconds clear threshold for the first limit setting.\n        ')
setMsiMtie100000CL2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiMtie100000CL2.setStatus('current')
if mibBuilder.loadTexts: setMsiMtie100000CL2.setDescription('Set the input port MTIE 100000 seconds clear threshold for the second limit setting.\n        ')
setMsiFreqAErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqAErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqAErrLmt.setDescription('Sets input port frequency error threshold for clock A.\n            ')
setMsiFreqAClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqAClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqAClrLmt.setDescription('Sets input port frequency clear threshold for clock A.\n            ')
setMsiFreqATau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqATau.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqATau.setDescription('Sets the time constant (tau), in seconds, used for the calculation of the Average Frequency for clock A.\n        ')
setMsiFreqBErrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqBErrLmt.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqBErrLmt.setDescription('Sets input port frequency error threshold for clock B.\n            ')
setMsiFreqBClrLmt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqBClrLmt.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqBClrLmt.setDescription('Sets input port frequency clear threshold for clock B.\n            ')
setMsiFreqBTau = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 18, 4, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setMsiFreqBTau.setStatus('current')
if mibBuilder.loadTexts: setMsiFreqBTau.setDescription('Sets the time constant (tau), in seconds, used for the calculation of the Average Frequency for clock B.\n        ')
setJccInpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2), )
if mibBuilder.loadTexts: setJccInpTable.setStatus('current')
if mibBuilder.loadTexts: setJccInpTable.setDescription('The list of CC Input attribute setup information. \n        ')
setJcciEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setJcciChassis"), (0, "SSU2000-MIB", "setJcciSlot"), (0, "SSU2000-MIB", "setJcciPort"))
if mibBuilder.loadTexts: setJcciEntry.setStatus('current')
if mibBuilder.loadTexts: setJcciEntry.setDescription('Input status and settings attributes.\n    ')
setJcciChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: setJcciChassis.setStatus('current')
if mibBuilder.loadTexts: setJcciChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n\n        Note: The input module can only reside in chassis 1 (main chassis).\n        ')
setJcciSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setJcciSlot.setStatus('current')
if mibBuilder.loadTexts: setJcciSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setJcciPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setJcciPort.setStatus('current')
if mibBuilder.loadTexts: setJcciPort.setDescription('Identifies which port position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setJcciEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcciEnable.setStatus('current')
if mibBuilder.loadTexts: setJcciEnable.setDescription('Set the input port to enabled or disabled.\n        ')
setJcciProvPql = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcciProvPql.setStatus('current')
if mibBuilder.loadTexts: setJcciProvPql.setDescription('Set the input port provisioned Priority Quality Level (PQL).\n\n        Note: Valid values are 1 - 9.\n        ')
setJcciPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcciPriority.setStatus('current')
if mibBuilder.loadTexts: setJcciPriority.setDescription("Set the input port priority level.\n        '0' = monitoring, \n        '1' = highest priority,\n        '10' = lowest priority.\n        ")
setJcci400Hz = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 7), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcci400Hz.setStatus('current')
if mibBuilder.loadTexts: setJcci400Hz.setDescription('Set the input port 400Hz signal attribute.\n        ')
setJcciZeroPhase = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 20, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("zeroPhA", 1), ("zeroPhB", 2), ("zeroPhAB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcciZeroPhase.setStatus('current')
if mibBuilder.loadTexts: setJcciZeroPhase.setDescription('Set the phase error to zero for this input port.\n        ZEROPHA - set phase A error to zero,\n        ZEROPHB - set phase B error to zero,\n        ZEROPHAB - set phase A and B to zero.\n\n        Note: This field only is meaningful during the write operation.\n        ')
setDsTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2), )
if mibBuilder.loadTexts: setDsTable.setStatus('current')
if mibBuilder.loadTexts: setDsTable.setDescription('A list of DS1 output module status and settings.\n        ')
setDsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setDsChassis"), (0, "SSU2000-MIB", "setDsSlot"))
if mibBuilder.loadTexts: setDsEntry.setStatus('current')
if mibBuilder.loadTexts: setDsEntry.setDescription('Set DS1 output attributes.\n    ')
setDsChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setDsChassis.setStatus('current')
if mibBuilder.loadTexts: setDsChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setDsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setDsSlot.setStatus('current')
if mibBuilder.loadTexts: setDsSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setDsFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("esf", 1), ("d4", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDsFrame.setStatus('current')
if mibBuilder.loadTexts: setDsFrame.setDescription('Set the output signal framing mode. \n        The T1 framing mode is ESF or D4.\n        ')
setDsBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDsBypass.setStatus('current')
if mibBuilder.loadTexts: setDsBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setDsZs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 5), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDsZs.setStatus('current')
if mibBuilder.loadTexts: setDsZs.setDescription('Set the Zero Suppression to enable or disable.\n        ')
setDsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDsEnable.setStatus('current')
if mibBuilder.loadTexts: setDsEnable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setDsLength = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 10, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setDsLength.setStatus('current')
if mibBuilder.loadTexts: setDsLength.setDescription('Set the cable length compensation for the output port.\n\n        Cable length definitions:\n        1 = 133 ft\n        2 = 266 ft\n        3 = 399 ft\n        4 = 533 ft\n        5 = 655 ft\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setE1Table = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2), )
if mibBuilder.loadTexts: setE1Table.setStatus('current')
if mibBuilder.loadTexts: setE1Table.setDescription('A list of DS1 output module status and settings.\n        ')
setE1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setE1Chassis"), (0, "SSU2000-MIB", "setE1Slot"))
if mibBuilder.loadTexts: setE1Entry.setStatus('current')
if mibBuilder.loadTexts: setE1Entry.setDescription('Set DS1 output attributes.\n    ')
setE1Chassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setE1Chassis.setStatus('current')
if mibBuilder.loadTexts: setE1Chassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setE1Slot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setE1Slot.setStatus('current')
if mibBuilder.loadTexts: setE1Slot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setE1Frame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ccs", 1), ("cas", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1Frame.setStatus('current')
if mibBuilder.loadTexts: setE1Frame.setDescription('Set the output signal framing mode. \n        1=ccs\n        2=cas\n        ')
setE1Bypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1Bypass.setStatus('current')
if mibBuilder.loadTexts: setE1Bypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setE1Zs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 5), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1Zs.setStatus('current')
if mibBuilder.loadTexts: setE1Zs.setDescription('Set the Zero Suppression to enable or disable.\n        ')
setE1Crc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 6), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1Crc.setStatus('current')
if mibBuilder.loadTexts: setE1Crc.setDescription('Set the CRC error checking to enable or disable.\n        ')
setE1SsmBit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1SsmBit.setStatus('current')
if mibBuilder.loadTexts: setE1SsmBit.setDescription('Set output module E1 SSM bit position.\n        bit=4 - 8\n\n        Note: This field is only valid for E1 output module.\n        ')
setE1Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 11, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE1Enable.setStatus('current')
if mibBuilder.loadTexts: setE1Enable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setCoTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2), )
if mibBuilder.loadTexts: setCoTable.setStatus('current')
if mibBuilder.loadTexts: setCoTable.setDescription('A list of 2048kHz output module status and settings.\n        ')
setCoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setCoChassis"), (0, "SSU2000-MIB", "setCoSlot"))
if mibBuilder.loadTexts: setCoEntry.setStatus('current')
if mibBuilder.loadTexts: setCoEntry.setDescription('Set 2048kHz output attributes.\n    ')
setCoChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setCoChassis.setStatus('current')
if mibBuilder.loadTexts: setCoChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setCoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setCoSlot.setStatus('current')
if mibBuilder.loadTexts: setCoSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setCoBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCoBypass.setStatus('current')
if mibBuilder.loadTexts: setCoBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setCoFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCoFltMode.setStatus('current')
if mibBuilder.loadTexts: setCoFltMode.setDescription('Set the signal fault mode for low level output signals\n            off(1), -- will turn off the output and requires user issued command to turn it back on\n            on(2), -- will not turn off when fault detected\n            auto(3) -- will turn off the output and automatically turn back on when fault clears\n            ')
setCoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCoEnable.setStatus('current')
if mibBuilder.loadTexts: setCoEnable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setCoSquelch = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 12, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCoSquelch.setStatus('current')
if mibBuilder.loadTexts: setCoSquelch.setDescription('Set PQL threshold to turn port off.\n            If the system PQL is below the PWL threshold the port is turned off (i.e. squelched).   \n            \n            Note: Byte 1 = port 1, byte 20 = port 20.\n            The PQL value of each byte defined as follows:\n            0 = disabled\n            1-16 = Provision PQL value\n            ')
setCcTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2), )
if mibBuilder.loadTexts: setCcTable.setStatus('current')
if mibBuilder.loadTexts: setCcTable.setDescription('A list of Composite Clock (CC) output module status and settings.\n        ')
setCcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setCcChassis"), (0, "SSU2000-MIB", "setCcSlot"))
if mibBuilder.loadTexts: setCcEntry.setStatus('current')
if mibBuilder.loadTexts: setCcEntry.setDescription('Set CC output attributes.\n    ')
setCcChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setCcChassis.setStatus('current')
if mibBuilder.loadTexts: setCcChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each CC Output entry.\n        ')
setCcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setCcSlot.setStatus('current')
if mibBuilder.loadTexts: setCcSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each CC Output entry.\n        ')
setCcBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCcBypass.setStatus('current')
if mibBuilder.loadTexts: setCcBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setCcEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCcEnable.setStatus('current')
if mibBuilder.loadTexts: setCcEnable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setCcDuty = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCcDuty.setStatus('current')
if mibBuilder.loadTexts: setCcDuty.setDescription('Set the output duty cycle for the output ports.\n        1 = 63/37 duty cycle.\n        2 = 50/50 duty cycle.\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setCcComp = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 13, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setCcComp.setStatus('current')
if mibBuilder.loadTexts: setCcComp.setDescription('Set the output phase (cable) compensation for the output ports.\n\n        The equivalent cable length:\n        1 = 2200 ft,\n        2 = 1925 ft,\n        3 = 1650 ft, \n        4 = 1375 ft,\n        5 = 1100 ft,\n        6 = 825 ft,\n        7 = 550 ft,\n        8 = 275 ft.\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
set422oTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2), )
if mibBuilder.loadTexts: set422oTable.setStatus('current')
if mibBuilder.loadTexts: set422oTable.setDescription('A list of 2048kHz output module status and settings.\n        ')
set422oEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "set422oChassis"), (0, "SSU2000-MIB", "set422oSlot"))
if mibBuilder.loadTexts: set422oEntry.setStatus('current')
if mibBuilder.loadTexts: set422oEntry.setDescription('Set 422 output attributes.\n    ')
set422oChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: set422oChassis.setStatus('current')
if mibBuilder.loadTexts: set422oChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
set422oSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: set422oSlot.setStatus('current')
if mibBuilder.loadTexts: set422oSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
set422oBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: set422oBypass.setStatus('current')
if mibBuilder.loadTexts: set422oBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
set422oFltMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: set422oFltMode.setStatus('current')
if mibBuilder.loadTexts: set422oFltMode.setDescription('Set the signal fault mode for low level output signals\n            off(1), -- will turn off the output and requires user issued command to turn it back on\n            on(2), -- will not turn off when fault detected\n            auto(3) -- will turn off the output and automatically turn back on when fault clears\n            ')
set422oEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: set422oEnable.setStatus('current')
if mibBuilder.loadTexts: set422oEnable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
set422oFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 14, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: set422oFrequency.setStatus('current')
if mibBuilder.loadTexts: set422oFrequency.setDescription('Set frequency for each port on an RS422 output module.\n\n           word 1 = port 1, word 10 = port 10.\n           The frequency value of each port defined as follows:\n           0 = 4kHz, 1-512 = 8kHz to 4096kHz with 8kHz per step.\n\n         Note: each port use 2-bytes to set frequency.\n           User can only set frequency on port 1 thru port 10.\n           The port 1 and 11, port 2 and 12,.., port 10 and 20 have the same frequency setting.\n           For example, when you set port1, you are set the same frequency for port 11.\n       ')
setE12048oTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2), )
if mibBuilder.loadTexts: setE12048oTable.setStatus('current')
if mibBuilder.loadTexts: setE12048oTable.setDescription('A list of E1/2048 output module status and settings.\n        ')
setE12048oEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setE12048oChassis"), (0, "SSU2000-MIB", "setE12048oSlot"))
if mibBuilder.loadTexts: setE12048oEntry.setStatus('current')
if mibBuilder.loadTexts: setE12048oEntry.setDescription('Set E1/2048 output attributes.\n    ')
setE12048oChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setE12048oChassis.setStatus('current')
if mibBuilder.loadTexts: setE12048oChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setE12048oSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setE12048oSlot.setStatus('current')
if mibBuilder.loadTexts: setE12048oSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setE12048oBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oBypass.setStatus('current')
if mibBuilder.loadTexts: setE12048oBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setE12048oZs = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oZs.setStatus('current')
if mibBuilder.loadTexts: setE12048oZs.setDescription('Set the Zero Suppression to enable or disable.\n        ')
setE12048oSignal = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oSignal.setStatus('current')
if mibBuilder.loadTexts: setE12048oSignal.setDescription('Set the output ports to E1 or 2048kHz.\n        1 = E1\n        2 = 2048 kHz\n\n        Note: byte 1 = port 1, byte 20 = port 20.\n        ')
setE12048oEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oEnable.setStatus('current')
if mibBuilder.loadTexts: setE12048oEnable.setDescription('Set the output ports to enabled or disabled.\n        1 = enabled\n        2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setE12048oSquelch = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oSquelch.setStatus('current')
if mibBuilder.loadTexts: setE12048oSquelch.setDescription('Set the PQL squelch threshold for each port.\n        If a PQL threshold is below the system PQL, this port is turned off (i.e. squelched).   \n        0 = disabled\n        1-16 = Provision PQL value\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setE12048oFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ccs", 1), ("cas", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oFrame.setStatus('current')
if mibBuilder.loadTexts: setE12048oFrame.setDescription('Set E1 output signal framer mode.\n        1 = CCS\n        2 = CAS\n        ')
setE12048oCrc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 9), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oCrc.setStatus('current')
if mibBuilder.loadTexts: setE12048oCrc.setDescription('Set E1 output CRC error checking to on or off.\n        ')
setE12048oSsm = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 10), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oSsm.setStatus('current')
if mibBuilder.loadTexts: setE12048oSsm.setDescription('Set E1 output SSM generation to on or off.\n        ')
setE12048oSsmBit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 15, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setE12048oSsmBit.setStatus('current')
if mibBuilder.loadTexts: setE12048oSsmBit.setDescription('Set E1 output SSM bit position.\n        bit position = 4 - 8\n\n        Note: This field is only valid for E1 output module.\n        ')
setLrmPTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2), )
if mibBuilder.loadTexts: setLrmPTable.setStatus('current')
if mibBuilder.loadTexts: setLrmPTable.setDescription('A list of DS1 LRM ports status and settings.\n        ')
setLrmPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setLrmPChassis"), (0, "SSU2000-MIB", "setLrmPSlot"), (0, "SSU2000-MIB", "setLrmPPort"))
if mibBuilder.loadTexts: setLrmPEntry.setStatus('current')
if mibBuilder.loadTexts: setLrmPEntry.setDescription('Set DS1 LRM attributes.\n    ')
setLrmPChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setLrmPChassis.setStatus('current')
if mibBuilder.loadTexts: setLrmPChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot and port number uniquely identify each inventory entry.\n        ')
setLrmPSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setLrmPSlot.setStatus('current')
if mibBuilder.loadTexts: setLrmPSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
setLrmPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: setLrmPPort.setStatus('current')
if mibBuilder.loadTexts: setLrmPPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
setLrmPEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPEnable.setStatus('current')
if mibBuilder.loadTexts: setLrmPEnable.setDescription('Set the LRM ports to enabled or disabled.\n        ')
setLrmPLbo = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("lbo133ft", 1), ("lbo266ft", 2), ("lbo399ft", 3), ("lbo533ft", 4), ("lbo655ft", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPLbo.setStatus('current')
if mibBuilder.loadTexts: setLrmPLbo.setDescription('Set the Line Build-Out for the LRM port.\n            1=lbo133ft\n            2=lbo266ft\n            3=lbo399ft\n            4=lbo533ft\n            5=lbo655ft\n           ')
setLrmPSlip = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPSlip.setStatus('current')
if mibBuilder.loadTexts: setLrmPSlip.setDescription('Set the slip error threshold in 24 hours period and the value zero shall clear the slip accumulated errors.\n            ')
setLrmPBpv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clr", 1), ("nop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPBpv.setStatus('current')
if mibBuilder.loadTexts: setLrmPBpv.setDescription('Clear the accumulated BPV errors\n            clr(1),     -- clear the accumulated BPV errors\n            nop(2)      -- no operation\n\n            Note: This field only has meaning for a write operation.\n            ')
setLrmPFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("squelch", 1), ("ais", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPFlt.setStatus('current')
if mibBuilder.loadTexts: setLrmPFlt.setDescription('Set the Side 1 fault strategy\n            ')
setLrmPCid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 16, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 43))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrmPCid.setStatus('current')
if mibBuilder.loadTexts: setLrmPCid.setDescription('Set the circuit id for LRM port\n            The circuit id is an 0-43 character string with all ascii printable characters.\n            ')
setLrme1PTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2), )
if mibBuilder.loadTexts: setLrme1PTable.setStatus('current')
if mibBuilder.loadTexts: setLrme1PTable.setDescription('A list of E1 LRM ports status and settings.\n        ')
setLrme1PEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setLrme1PChassis"), (0, "SSU2000-MIB", "setLrme1PSlot"), (0, "SSU2000-MIB", "setLrme1PPort"))
if mibBuilder.loadTexts: setLrme1PEntry.setStatus('current')
if mibBuilder.loadTexts: setLrme1PEntry.setDescription('Set E1 LRM attributes.\n    ')
setLrme1PChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setLrme1PChassis.setStatus('current')
if mibBuilder.loadTexts: setLrme1PChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot and port number uniquely identify each inventory entry.\n        ')
setLrme1PSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setLrme1PSlot.setStatus('current')
if mibBuilder.loadTexts: setLrme1PSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot and port number uniquely identify each inventory entry.\n        ')
setLrme1PPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: setLrme1PPort.setStatus('current')
if mibBuilder.loadTexts: setLrme1PPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot and port number uniquely identify each inventory entry.\n        ')
setLrme1PEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrme1PEnable.setStatus('current')
if mibBuilder.loadTexts: setLrme1PEnable.setDescription('Set the LRM ports to enabled or disabled.\n        ')
setLrme1PSlip = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrme1PSlip.setStatus('current')
if mibBuilder.loadTexts: setLrme1PSlip.setDescription('Set the slip error threshold in 24 hours period and the value zero shall clear the slip accumulated errors.\n            ')
setLrme1PBpv = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clr", 1), ("nop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrme1PBpv.setStatus('current')
if mibBuilder.loadTexts: setLrme1PBpv.setDescription('Clear the accumulated BPV errors\n            clr(1),     -- clear the accumulated BPV errors\n            nop(2)      -- no operation\n\n            Note: This field only has meaning for a write operation.\n            ')
setLrme1PFlt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("squelch", 1), ("ais", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrme1PFlt.setStatus('current')
if mibBuilder.loadTexts: setLrme1PFlt.setDescription('Set the Side 1 fault strategy\n            ')
setLrme1PCid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 21, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 43))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setLrme1PCid.setStatus('current')
if mibBuilder.loadTexts: setLrme1PCid.setDescription('Set the circuit id for LRM port\n            The circuit id is an 0-43 character string with all ascii printable characters.\n            ')
setSineoTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2), )
if mibBuilder.loadTexts: setSineoTable.setStatus('current')
if mibBuilder.loadTexts: setSineoTable.setDescription('A list of Sine output status and settings.\n        ')
setSineoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setSineoChassis"), (0, "SSU2000-MIB", "setSineoSlot"))
if mibBuilder.loadTexts: setSineoEntry.setStatus('current')
if mibBuilder.loadTexts: setSineoEntry.setDescription('Set E1 LRM attributes.\n    ')
setSineoChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setSineoChassis.setStatus('current')
if mibBuilder.loadTexts: setSineoChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setSineoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setSineoSlot.setStatus('current')
if mibBuilder.loadTexts: setSineoSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
setSineoBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineoBypass.setStatus('current')
if mibBuilder.loadTexts: setSineoBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setSineoFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1544, 1544), ValueRangeConstraint(6312, 6312), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineoFrequency.setStatus('current')
if mibBuilder.loadTexts: setSineoFrequency.setDescription('Set the output frequency 1.544 or 6.312 MHz.\n            ')
setSineoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineoEnable.setStatus('current')
if mibBuilder.loadTexts: setSineoEnable.setDescription('Set the output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setSineoSquelch = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 17, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSineoSquelch.setStatus('current')
if mibBuilder.loadTexts: setSineoSquelch.setDescription('Set PQL threshold to turn port off.\n            If the system PQL is below the PWL threshold the port is turned off (i.e. squelched).   \n            \n            Note: Byte 1 = port 1, byte 20 = port 20.\n            The PQL value of each byte defined as follows:\n            0 = disabled\n            1-16 = Provision PQL value\n            ')
setJccoTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2), )
if mibBuilder.loadTexts: setJccoTable.setStatus('current')
if mibBuilder.loadTexts: setJccoTable.setDescription('A list of JCC output status and settings.\n        ')
setJccoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setJccoChassis"), (0, "SSU2000-MIB", "setJccoSlot"))
if mibBuilder.loadTexts: setJccoEntry.setStatus('current')
if mibBuilder.loadTexts: setJccoEntry.setDescription('Set JCC output attributes.\n    ')
setJccoChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setJccoChassis.setStatus('current')
if mibBuilder.loadTexts: setJccoChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each JCC Output entry.\n        ')
setJccoSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setJccoSlot.setStatus('current')
if mibBuilder.loadTexts: setJccoSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each JCC Output entry.\n        ')
setJccoBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJccoBypass.setStatus('current')
if mibBuilder.loadTexts: setJccoBypass.setDescription('Set Clock C, or bypass mode, to enable or disable.\n        ')
setJcco400Hz = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 4), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJcco400Hz.setStatus('current')
if mibBuilder.loadTexts: setJcco400Hz.setDescription('Set the 400Hz BPV removal. \n            A setting OFF removes this 400Hz component, and a setting ON  includes it.\n            ')
setJccoEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJccoEnable.setStatus('current')
if mibBuilder.loadTexts: setJccoEnable.setDescription('Set the JCC output ports to enabled or disabled.\n           1 = enabled\n           2 = disabled\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        ')
setJccoComp = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 19, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setJccoComp.setStatus('current')
if mibBuilder.loadTexts: setJccoComp.setDescription('The array represents the output phase compensation\n        for all ports on an output module.\n\n        Note: Byte 1 = port 1, byte 20 = port 20.\n        The specifed byte value is 1 thru 8. \n        1 = no delay, 8 = highest delay.\n\n        The equivalent cable length:\n        1 = 2200 ft,\n        2 = 1925 ft,\n        3 = 1650 ft, \n        4 = 1375 ft,\n        5 = 1100 ft,\n        6 = 825 ft,\n        7 = 550 ft,\n        8 = 275 ft.\n        ')
setPtNtpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1), )
if mibBuilder.loadTexts: setPtNtpTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpTable.setDescription('A list of PackeTime NTP status and settings.\n        ')
setPtNtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpChassis"), (0, "SSU2000-MIB", "setPtNtpSlot"))
if mibBuilder.loadTexts: setPtNtpEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpEntry.setDescription('PackeTime NTP settings and attributes.\n    ')
setPtNtpChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setPtNtpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setPtNtpCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpCommit.setStatus('current')
if mibBuilder.loadTexts: setPtNtpCommit.setDescription('Commit all provisioned parameters, this action makes the parameters active. \n        This command will also store the parameters to non-volatile memory.\n\n        Note: This field only has meaning for a writing (1).\n        ')
setPtNtpProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpProbe.setStatus('current')
if mibBuilder.loadTexts: setPtNtpProbe.setDescription('Set the PackeTime Maintenance Port state; Enable or Disable.\n\n        This node is obsolete, The setting is NOP.         \n        ')
setPtNtpBond = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 5), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpBond.setStatus('current')
if mibBuilder.loadTexts: setPtNtpBond.setDescription('Set Service port bonding state.\n        1 = Enabled  \n        2 = Disabled\n        ')
setPtNtpNTPd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 6), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpNTPd.setStatus('current')
if mibBuilder.loadTexts: setPtNtpNTPd.setDescription('Set the NTP daemon state.\n        1 = Enabled  \n        2 = Disabled\n        ')
setPtNtpTodsrcPrefer = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("todsrc", 1), ("peer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpTodsrcPrefer.setStatus('current')
if mibBuilder.loadTexts: setPtNtpTodsrcPrefer.setDescription("Set the module's preferred time-source to be either TODSRC (1) or PEER (2). \n        TOD Source, either the TODSRC (GPS) or a NTP Peer if operating in Client mode\n        ")
setPtNtpTodsrcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpTodsrcPriority.setStatus('current')
if mibBuilder.loadTexts: setPtNtpTodsrcPriority.setDescription('Set the Todsrc priority.\n        The priority is the for the specified module as the TOD Source, \n        default is 0, range can be 0 through 8. Value 1 is the highest, \n        and 8 is the lowest. If the value is zero, the specified module \n        cannot be TOD Source.\n        ')
setPtNtpWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpWeight.setStatus('current')
if mibBuilder.loadTexts: setPtNtpWeight.setDescription('Set the load distribution between portA/B in percent.\n        For example, 70 means port-A get 70% of total bandwidth, \n        port-B gets remaining 30%. If port-A reaches 70% of total \n        bandwidth but port-B has no traffic, the 30% of bandwidth \n        will be wasted, port-A cannot use it. To allow either port \n        to use all the bandwidth, portAWeight  can be set to -1, \n        indicating no limit between port-A and port-B (either port-A \n        or port-B can get all the bandwidth, based on first come \n        first serve). Thus the range of this parameter -1 to 100. \n        For bonding mode, this parameter must be forced to -1, \n        so the active port can use 100% of the bandwidth. \n        For non-bonding mode, user can set any value between -1 to 100.\n        ')
setPtNtpCompensation = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 250))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpCompensation.setStatus('current')
if mibBuilder.loadTexts: setPtNtpCompensation.setDescription('Set the Antenna cable delay compensation \n        in the case of GPS ToD Source(s) or the delay induced by the cable(s) used to connect \n        expansion shelves where the PackeTime ToD Source(s) is located in relationship to the Main shelf. \n        The time offset shall have a 100nS resolution, thus the Delay value shall be multiplied \n        by 100nS to provide 1PPS compensation. \n        Valid user compensation values range is 0 thru 250 for a total compensation range of 0 to 25000nS (25uS). \n        ')
setPtNtpPeerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerTimeout.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerTimeout.setDescription('Set the Peer Availability Timeout \n        The timer shall have a user settable range from 60 minutes to 10000 minutes, \n        with a default value of 1440 minutes\n        ')
setPtNtpPeerPrefer = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerPrefer.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerPrefer.setDescription('Set the preferred peer from the peer list.\n        The valid value is 0-8. The value zero means, there is no prefer. \n        This value has meaning, only when the specified peer is in the peer list.\n        ')
setPtNtpBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 13), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpBypass.setStatus('current')
if mibBuilder.loadTexts: setPtNtpBypass.setDescription('Set the clock C state, or bypass clock, to enabled or disabled.\n        ')
setPtNtpModActive = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 14), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpModActive.setStatus('current')
if mibBuilder.loadTexts: setPtNtpModActive.setDescription("Set the specified module in the redundant pair to be Active. \n        Note1: This command only applies when the module in the redundant pair.\n        Note2: This field only has meaning for a writing (1).\n        Note3: Don't apply COMMIT after this command.\n        ")
setPtNtpPAActive = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 15), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPAActive.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPAActive.setDescription("Set Port A is being manually selected as the active port. \n        Note1: This command only applies when the bonding mode is enabled and both ports are in network and Ethernet link up.\n        Note2: This field only has meaning for a writing (1).\n        Note3: Don't apply COMMIT after this command.\n        ")
setPtNtpPBActive = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 1, 1, 16), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPBActive.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPBActive.setDescription("Set Port B is being manually selected as the active port. \n        Note1: This command only applies when the bonding mode is enabled and both ports are in network and Ethernet link up.\n        Note2: This field only has meaning for a writing (1).\n        Note3: Don't apply COMMIT after this command.\n        ")
setPtNtpPortTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2), )
if mibBuilder.loadTexts: setPtNtpPortTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortTable.setDescription('PackeTime NTP ethernet port information.\n          ')
setPtNtpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpPortChassis"), (0, "SSU2000-MIB", "setPtNtpPortSlot"), (0, "SSU2000-MIB", "setPtNtpPortNum"))
if mibBuilder.loadTexts: setPtNtpPortEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortEntry.setDescription('PackeTime NTP ethernet port state and settings information.\n    setPtNtpPortChassis\n        Identifies which chassis is being addressed. \n    setPtNtpPortSlot\n        Identifies which slot is being addressed. \n    setPtNtpPortNum\n        Identifies which port is being addressed. \n    setPtNtpPortAddr\n        Set the port IP address         \n    setPtNtpPortMask\n        Set the port network mask           \n    setPtNtpPortGate\n        Set the port gateway address            \n    ')
setPtNtpPortChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpPortChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n        ')
setPtNtpPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpPortSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n        ')
setPtNtpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: setPtNtpPortNum.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortNum.setDescription('Identifies which port is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n\n        PTNTP ethernet interface number. \n        1 = Service Port A \n        2 = Service Port B \n        3 = Maintenance Port\n        ')
setPtNtpPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPortAddr.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortAddr.setDescription('Set the port IP address            \n        ')
setPtNtpPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPortMask.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortMask.setDescription('Set the port network mask          \n        ')
setPtNtpPortGate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPortGate.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPortGate.setDescription('Set the port gateway address           \n        ')
setPtNtpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3), )
if mibBuilder.loadTexts: setPtNtpPeerTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerTable.setDescription('List of PackeTime NTP Peer entries. \n    Entries are indexed by the values of setPtNtpPeerChassis, setPtNtpPeerSlot  and setPtNtpPortNum.\n    ')
setPtNtpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpPeerChassis"), (0, "SSU2000-MIB", "setPtNtpPeerSlot"), (0, "SSU2000-MIB", "setPtNtpPeerNum"))
if mibBuilder.loadTexts: setPtNtpPeerEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerEntry.setDescription('Set PackeTime NTP peer state and settings.\n    setPtNtpPeerChassis\n        Identifies which chassis is being addressed. \n    setPtNtpPeerSlot\n        Identifies which slot is being addressed. \n    setPtNtpPeerNum\n        Identifies which ntp peer is being addressed. \n    setPtNtpPeerAddr\n        Set Peer IP address in peer table.\n    setPtNtpPeerPmin\n        Set the minimum request rate in seconds for CLIENT mode. \n    setPtNtpPeerPmax\n        Set the maximum request rate in seconds for CLIENT mode. \n    setPtNtpPeerKeyId\n        Set keyId to be used to lookup authentication key, \n    ')
setPtNtpPeerChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpPeerChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and peer number uniquely identify each entry.\n        ')
setPtNtpPeerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpPeerSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and peer number uniquely identify each entry.\n        ')
setPtNtpPeerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: setPtNtpPeerNum.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerNum.setDescription('Identifies which ntp peer is being addressed. \n        This chassis, slot, and peer number uniquely identify each entry.\n        ')
setPtNtpPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerAddr.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerAddr.setDescription('Set Peer IP address in peer table.\n        Write zero IP address will delete this IP address from peer table.\n        ')
setPtNtpPeerPmin = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerPmin.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerPmin.setDescription('Set the minimum request rate in seconds for CLIENT mode, \n        the default is 16, the range is 16, 32, 64, 128, 256, 512, and 1024.\n        ')
setPtNtpPeerPmax = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerPmax.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerPmax.setDescription('Set the maximum request rate in seconds for CLIENT mode, \n        the default is 64, the range is 16, 32, 64, 128, 256, 512, and 1024.\n        ')
setPtNtpPeerKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpPeerKeyId.setStatus('current')
if mibBuilder.loadTexts: setPtNtpPeerKeyId.setDescription('Set keyId to be used to lookup authentication key, \n        the default is 0 (no authentication), the range is 0 through 65534\n        ')
setPtNtpAuthTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4), )
if mibBuilder.loadTexts: setPtNtpAuthTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthTable.setDescription('A list of PackeTime NTP authentication entries. \n    The number of entries are given by the values of setPtNtpAuthChassis, setPtNtpAuthSlot and setPtNtpAuthNum.\n    ')
setPtNtpAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpAuthChassis"), (0, "SSU2000-MIB", "setPtNtpAuthSlot"), (0, "SSU2000-MIB", "setPtNtpAuthNum"))
if mibBuilder.loadTexts: setPtNtpAuthEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthEntry.setDescription('Set PackeTime NTP authentication state and settings.\n    PackeTime NTP authentication attributes.\n    setPtNtpAuthChassis\n        Identifies which chassis is being addressed. \n    setPtNtpAuthSlot\n        Identifies which slot is being addressed. \n    setPtNtpAuthNum\n        Identifies which authentication key is being addressed. \n    setPtNtpAuthKeyId\n        Set the authentication key ID, \n    setPtNtpAuthKeyValue\n        Set the NTP authentication key used to create the MD5 hash associated with the keyid. \n    ')
setPtNtpAuthChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpAuthChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and authentication key number uniquely identify each entry.\n        ')
setPtNtpAuthSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpAuthSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and authentication key number uniquely identify each entry.\n        ')
setPtNtpAuthNum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: setPtNtpAuthNum.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthNum.setDescription('Identifies which authentication key is being addressed. \n        This chassis, slot, and authentication key number uniquely identify each entry.\n        ')
setPtNtpAuthKeyId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpAuthKeyId.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthKeyId.setDescription('Set KeyId is the authentication key ID, \n        default is 0 (no authentication), range 0 to 65534.\n        Note: If this value is zero, no authentication is used.\n        ')
setPtNtpAuthKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 4, 1, 5), DisplayString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 32), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpAuthKeyValue.setStatus('current')
if mibBuilder.loadTexts: setPtNtpAuthKeyValue.setDescription('Set the key is the NTP authentication key used to create the MD5 hash associated with the keyid. \n        The key is a comprised of up to 32 ASCII characters, a minimum of 8 characters is required.\n        Note: the key value will not display and it is always displayed as null string.\n        ')
setPtNtpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5), )
if mibBuilder.loadTexts: setPtNtpRouteTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteTable.setDescription('A list of PackeTime NTP route table entries. \n\n    Static routing describes a system that does not implement adaptive routing. In these systems routes through a data \n    network are described by fixed paths (statically). These routes are usually entered into the host by the system \n    administrator.        \n    ')
setPtNtpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpRouteChassis"), (0, "SSU2000-MIB", "setPtNtpRouteSlot"), (0, "SSU2000-MIB", "setPtNtpRouteNum"))
if mibBuilder.loadTexts: setPtNtpRouteEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteEntry.setDescription("A PackeTime NTP route attributes and settings.\n    setPtNtpRouteChassis\n        Identifies which chassis is being addressed. \n    setPtNtpRouteSlot\n        Identifies which slot is being addressed. \n    setPtNtpRouteNum\n        Identifies which route number (index) is being addressed. \n    setPtNtpRouteAddr\n        Set the route destination network or destination host.          \n    setPtNtpRouteMask\n        Set the netmask for the destination network.  \n    setPtNtpRouteGate\n        Set the gateway ip for the destination network.  \n    setPtNtpRouteIface\n        Set the module's network interface number.\n    ")
setPtNtpRouteChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpRouteChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and route number (index) uniquely identify each entry.\n        ')
setPtNtpRouteSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpRouteSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and route number (index) uniquely identify each entry.\n        ')
setPtNtpRouteNum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: setPtNtpRouteNum.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteNum.setDescription('Identifies which route number is being addressed. \n        This chassis, slot, and route number (index) uniquely identify each entry.\n        ')
setPtNtpRouteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpRouteAddr.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteAddr.setDescription('Set the route destination network or destination host.         \n        Write a new Route IP address will put this new IP into table.\n        Write zero IP address will delete this IP address from table.\n        ')
setPtNtpRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpRouteMask.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteMask.setDescription("Set the netmask for the destination network;  \n        '255.255.255.255' for a host destination and \n        '0.0.0.0' for the default route\n        ")
setPtNtpRouteGate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpRouteGate.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteGate.setDescription('Set the gateway for the destination network.\n        ')
setPtNtpRouteIface = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpRouteIface.setStatus('current')
if mibBuilder.loadTexts: setPtNtpRouteIface.setDescription("Set the module's network interface number:\n        1 = Service Port A \n        2 = Service Port B \n        3 = Bond0 (bonding of PortA and Port B) \n        ")
setPtNtpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6), )
if mibBuilder.loadTexts: setPtNtpVlanTable.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanTable.setDescription('List of PackeTime NTP vlan attributes.\n    The Virtural Local Area Network is implemented per IEEE 802.1Q.\n    ')
setPtNtpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtNtpVlanChassis"), (0, "SSU2000-MIB", "setPtNtpVlanSlot"))
if mibBuilder.loadTexts: setPtNtpVlanEntry.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanEntry.setDescription('A PackeTime NTP vlan attributes and settings:\n    setPtNtpVlanChassis\n        Identifies which chassis is being addressed. \n    setPtNtpVlanSlot\n        Identifies which slot is being addressed. \n    setPtNtpVlan\n        Set the VLAN state.\n    setPtNtpVlanPAId\n        Set the VLAN ID for Service Port A.\n    setPtNtpVlanPAPriority\n        Set the VLAN priority for Service Port A.\n    setPtNtpVlanPBId\n        Set the VLAN ID for Service Port B.\n    setPtNtpVlanPBPriority\n        Set the VLAN priority for Service Port B.\n    setPtNtpVlanBondId\n        Set the VLAN ID for Bonding of Service Ports of A and B \n    setPtNtpVlanBondPriority\n        Set the VLAN priority for Bonding of Service Ports of A and B \n    ')
setPtNtpVlanChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtNtpVlanChassis.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis and slot number uniquely identify each entry.\n        ')
setPtNtpVlanSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtNtpVlanSlot.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanSlot.setDescription('Identifies which slot is being addressed. \n        This chassis and slot number uniquely identify each entry.\n        ')
setPtNtpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 3), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlan.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlan.setDescription('Set the VLAN state.\n        1 = Enabled  \n        2 = Disabled\n        ')
setPtNtpVlanPAId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanPAId.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanPAId.setDescription('Set the VLAN ID for Service Port A, [0 - 4094]\n\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
setPtNtpVlanPAPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanPAPriority.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanPAPriority.setDescription('Set the VLAN Priority for Service Port A, [0 - 7]\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
setPtNtpVlanPBId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanPBId.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanPBId.setDescription('Set the VLAN ID for Service Port B, [0 - 4094]\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
setPtNtpVlanPBPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanPBPriority.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanPBPriority.setDescription('Set the VLAN Priority for Service Port B, [0 - 7]\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
setPtNtpVlanBondId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanBondId.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanBondId.setDescription('Set the VLAN ID for Bonding of Service Ports of A and B, [0 - 4094]\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
setPtNtpVlanBondPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 22, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtNtpVlanBondPriority.setStatus('current')
if mibBuilder.loadTexts: setPtNtpVlanBondPriority.setDescription('Set the VLAN Priority for Bonding of Service Ports of A and B, [0 - 7]\n        Note: The value has no meaning, only when the VLAN is enabled\n        ')
infoTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1), )
if mibBuilder.loadTexts: infoTable.setStatus('current')
if mibBuilder.loadTexts: infoTable.setDescription('A list of general information entries.')
giEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "giChassis"), (0, "SSU2000-MIB", "giSlot"))
if mibBuilder.loadTexts: giEntry.setStatus('current')
if mibBuilder.loadTexts: giEntry.setDescription('Set global module attributes.\n    ')
giChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: giChassis.setStatus('current')
if mibBuilder.loadTexts: giChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
giSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: giSlot.setStatus('current')
if mibBuilder.loadTexts: giSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
giSystime = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: giSystime.setStatus('current')
if mibBuilder.loadTexts: giSystime.setDescription('Reports length of time (in seconds) a specified module has been operational since last reboot.\n        Only apply to the CPU-based module. zero means Not Applicable.\n        ')
giElevation = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(60, 500000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: giElevation.setStatus('current')
if mibBuilder.loadTexts: giElevation.setDescription('The module alarm elevation time (in seconds).  \n        Each module in the system can be set for  elevation time from 60 seconds to 500,000 seconds. \n        A setting of 0 (zero) means no elevation for the alarm.\n        For example, when an alarm has been at MINOR level ontinuously for elevtime seconds, then it is elevated to the next level (MAJOR).\n\n        Note: 0 = disabled.\n        ')
giSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("factory", 1), ("user", 2), ("save", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: giSetup.setStatus('current')
if mibBuilder.loadTexts: giSetup.setDescription('Saves or restores the configuration of the specified module. \n\n        FACTORY - restores the module configuration to factory defaults.\n        SAVE - will save the current configuration as User.\n        USER - will restore the saved User configuration.\n\n        Note: This field only has meaning for a write operation.\n        Only apply to the CPU-based module.\n        ')
giRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 4, 1, 1, 6), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: giRestart.setStatus('current')
if mibBuilder.loadTexts: giRestart.setDescription("Restarts a module.\n        Writing a '1' to this variable restarts (reboots) the module.\n\n        Note: This field only has meaning for a write operation.\n        Only apply to the CPU-based module.\n        ")
evCount = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evCount.setStatus('current')
if mibBuilder.loadTexts: evCount.setDescription('Reports total number of events to display. \n\t    The number represents total number of events\n\t    we want to display. Its value ranges between \n\t    1 and 1000.\n        ')
evType = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alarm", 1), ("report", 2), ("all", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: evType.setStatus('current')
if mibBuilder.loadTexts: evType.setDescription('Reports which event type we want to display (functions as a display filter). \n        Set these values to the desired type you want to display:\n        ALARM - for alarm type\n        REPORT -  for event type\n        ALL - for all (alarm and event) type.\n        ')
eventTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 3), )
if mibBuilder.loadTexts: eventTable.setStatus('current')
if mibBuilder.loadTexts: eventTable.setDescription('Report of system event entries. \n    The number of entries is given by the value of evNumber. \n    The total entries are up to 1000.')
evEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "evIndex"))
if mibBuilder.loadTexts: evEntry.setStatus('current')
if mibBuilder.loadTexts: evEntry.setDescription('An event entry containing objects of each event.')
evIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)))
if mibBuilder.loadTexts: evIndex.setStatus('current')
if mibBuilder.loadTexts: evIndex.setDescription('A unique value for each event. \n        This value range from 1 to 1000.')
evT = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 116))).setMaxAccess("readonly")
if mibBuilder.loadTexts: evT.setStatus('current')
if mibBuilder.loadTexts: evT.setDescription('A OCTET STRING containing information about the event.\n\n        The string is in the TLV format, and contains\n        following information:\n        INTEGER - event id\n        INTEGER - module hex code\n        DateAndTime - timestamp\n        INTEGER - chassis number\n        INTEGER - slot number\n        INTEGER - port number\n        INTEGER - alarm code\n        INTEGER - notification code\n        INTEGER - Elevated\n        DisplayString - ascii string description of the event\n\n        event id:\n            INTEGER (0..255)\n\n        Alarm Code:\n            minor(1),\n            major(2),\n            critical(3),\n            ignore(4),\n            report(5),\n\n        Notification Code:\n            minor(1),\n            major(2),\n            critical(3),\n            ignore(4),\n            report(5),\n            clear(6)\n\n        Elevated:\n            Yes(1),\n            No(2)\n        ')
alarmTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1), )
if mibBuilder.loadTexts: alarmTable.setStatus('current')
if mibBuilder.loadTexts: alarmTable.setDescription('A list of alarm entries. \n    ')
almEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "almChassis"), (0, "SSU2000-MIB", "almSlot"), (0, "SSU2000-MIB", "almPort"), (0, "SSU2000-MIB", "almIndex"))
if mibBuilder.loadTexts: almEntry.setStatus('current')
if mibBuilder.loadTexts: almEntry.setDescription('Alarm entry attributes.\n    ')
almChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: almChassis.setStatus('current')
if mibBuilder.loadTexts: almChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
almSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: almSlot.setStatus('current')
if mibBuilder.loadTexts: almSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
almPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: almPort.setStatus('current')
if mibBuilder.loadTexts: almPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
almIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: almIndex.setStatus('current')
if mibBuilder.loadTexts: almIndex.setDescription('Reports the alarm index value.\n\n        Note: The alarm id is allowed for number zero; therefore,\n        the OID for this index is alarm id plus 1 to avoid the zero number for OID. \n        ')
almId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almId.setStatus('current')
if mibBuilder.loadTexts: almId.setDescription('Reports the alarm id.\n\n        Note: This is the actual alarm id range 0 thru 31. \n        ')
almName = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almName.setStatus('current')
if mibBuilder.loadTexts: almName.setDescription('Reports the text string to describe this alarm.\n        ')
almLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("critical", 3), ("ignore", 4), ("report", 5), ("clear", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almLevel.setStatus('current')
if mibBuilder.loadTexts: almLevel.setDescription('Reports current state of alarm indications on the units. \n        minor(1),\n        major(2),\n        critical(3),\n        ignore(4),\n        report(5),\n        clear(6)\n        ')
almElevate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 8), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: almElevate.setStatus('current')
if mibBuilder.loadTexts: almElevate.setDescription('Report alarm elevation state\n\n        1 = alarm elevated\n        2 = alarm not elevated\n        ')
almStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: almStatus.setStatus('current')
if mibBuilder.loadTexts: almStatus.setDescription('Reports the text string to describe this alarm status condition.\n        ')
setAlmLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setAlmLoc.setStatus('current')
if mibBuilder.loadTexts: setAlmLoc.setDescription("Set the module slot location.\n          It should be one module, multiple module is not allowed\n          where\n          x is the chassis number: the range is 1 to 5,\n          A is the constant letter 'A', and is chassis/slot sepearator.\n          y is the slot number. range is [1 to 20].\n\n          For example: 1A3-1 for module located in chassis 1 and slot 3, port 1.\n\n          Note: The slot location must be physically installed in the unit.\n          ")
setAlmTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3), )
if mibBuilder.loadTexts: setAlmTable.setStatus('current')
if mibBuilder.loadTexts: setAlmTable.setDescription('A list of alarm entries.\n      ')
salEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "salChassis"), (0, "SSU2000-MIB", "salSlot"), (0, "SSU2000-MIB", "salPort"), (0, "SSU2000-MIB", "salIndex"))
if mibBuilder.loadTexts: salEntry.setStatus('current')
if mibBuilder.loadTexts: salEntry.setDescription('Set alarm attributes.\n    ')
salChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: salChassis.setStatus('current')
if mibBuilder.loadTexts: salChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
salSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: salSlot.setStatus('current')
if mibBuilder.loadTexts: salSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
salPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: salPort.setStatus('current')
if mibBuilder.loadTexts: salPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
salIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: salIndex.setStatus('current')
if mibBuilder.loadTexts: salIndex.setDescription('Index value for the alarm.\n\n        Note: The alarm id is allowed for number zero; \n        therefore, the OID for this index is alarm id plus 1 to avoid the zero number for OID. \n        ')
salId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: salId.setStatus('current')
if mibBuilder.loadTexts: salId.setDescription('ID value for the alarm.\n\n        Note: This is the actual alarm id range 0 thru 31. \n        ')
salName = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: salName.setStatus('current')
if mibBuilder.loadTexts: salName.setDescription('Name/Description for the alarm.\n        ')
salSet = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 7), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: salSet.setStatus('current')
if mibBuilder.loadTexts: salSet.setDescription('Alarm state for the alarm:\n\n        1 = alarm set\n        2 = no alarm \n        ')
salElevate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 8), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: salElevate.setStatus('current')
if mibBuilder.loadTexts: salElevate.setDescription('Alarm elevation status:\n\n        1 = alarm elevated\n        2 = alarm not elevated\n        ')
salLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("critical", 3), ("ignore", 4), ("report", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: salLevel.setStatus('current')
if mibBuilder.loadTexts: salLevel.setDescription('Sets alarm severe level are:\n        MINOR - sets alarm level to MINOR\n        MAJOR - set alarm level to MAJOR\n        CRITICAL - sets alarm level to CRITICAL\n        IGNORE - ignore any alarm indication\n        REPORT - report only any alarm indication\n        ')
salDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 86400), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: salDelay.setStatus('current')
if mibBuilder.loadTexts: salDelay.setDescription('Sets the length of time in seconds an alarm must be active before generating an alarm.\n\n        Note: \n        0 = user selected immediate indication\n        -1 (when read) = forced immediate indication (i.e. not user selectable)\n        ')
refClk = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refClk.setStatus('current')
if mibBuilder.loadTexts: refClk.setDescription('Report/Set which clk is currently selected. \n        clka(1),\n        clkb(2),\n        none(3)\n\n        Note: When read, it shows which clock is currently selected. \n        When write, only clka or clkb are valid.\n        ')
refInp = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refInp.setStatus('current')
if mibBuilder.loadTexts: refInp.setDescription("Report/Set the input reference port.\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1.\n        The NULL string means there is no input reference.\n        ")
refBypass = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: refBypass.setStatus('current')
if mibBuilder.loadTexts: refBypass.setDescription("Report/Set input port designated as the input bypass clock.\n\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1.\n        The NULL string means there is no bypass clock.\n\n        Note: In the SSU2000, the input module always resides in the main chassis (i.e. 'x' is one).\n        ")
refClkSwitch = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ar", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refClkSwitch.setStatus('current')
if mibBuilder.loadTexts: refClkSwitch.setDescription('Report/Set Clock auto-return (AR) mode.\n            ar(1),\n            off(2)\n            The AR option changes the current clock selection mode to revertive operation.\n            ')
refInpSwitch = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ar", 1), ("as", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refInpSwitch.setStatus('current')
if mibBuilder.loadTexts: refInpSwitch.setDescription('Report/Set input switch mode. \n        The InpSwitch settings are:\n\n        AR = Auto Return (revertive)\n        AS = Auto Switch (but not revertive)\n        OFF = No auto switching\n        ')
refInpSelection = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("priority", 1), ("pql", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refInpSelection.setStatus('current')
if mibBuilder.loadTexts: refInpSelection.setDescription('Report/Set input selection mode. \n        The input reference selection can be PRIORITY/ PQL.\n\n        PRIORITY - the user assigned priority number is used to\n                  pick the best input port as an input reference.\n        PQL - the input Priority Quality Level (PQL) is used to \n                  select which is the best input port reference.\n        ')
refClkTodsrc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 7, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: refClkTodsrc.setStatus('current')
if mibBuilder.loadTexts: refClkTodsrc.setDescription("Report/Set TOD Source. \n        The value can be any TOD source candidate (GPS or PackeTime) indicates the TODSRC of the selected clock.\n\n        The text string of the todsrc reference port.\n        The format is defined as xAy.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n\n        For example: 1A3 means this reference located at chassis 1, slot 3.\n        The NULL string means there is no reference.\n        ")
phaseTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1), )
if mibBuilder.loadTexts: phaseTable.setStatus('current')
if mibBuilder.loadTexts: phaseTable.setDescription('A list of phase data entries. \n      ')
phEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "phChassis"), (0, "SSU2000-MIB", "phSlot"), (0, "SSU2000-MIB", "phPort"))
if mibBuilder.loadTexts: phEntry.setStatus('current')
if mibBuilder.loadTexts: phEntry.setDescription('Phase data entry attributes.\n        ')
phChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: phChassis.setStatus('current')
if mibBuilder.loadTexts: phChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: phSlot.setStatus('current')
if mibBuilder.loadTexts: phSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: phPort.setStatus('current')
if mibBuilder.loadTexts: phPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: phA.setStatus('current')
if mibBuilder.loadTexts: phA.setDescription('Current 1-second phase value in nanoseconds on clock A.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
phB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: phB.setStatus('current')
if mibBuilder.loadTexts: phB.setDescription('Current 1-second phase value in nanoseconds on clock B.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph100A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph100A.setStatus('current')
if mibBuilder.loadTexts: ph100A.setDescription('Current 100-second phase value in nanoseconds on clock A.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph100B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph100B.setStatus('current')
if mibBuilder.loadTexts: ph100B.setDescription('Current 100-second phase value in nanoseconds on clock B.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph1000A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph1000A.setStatus('current')
if mibBuilder.loadTexts: ph1000A.setDescription('Current 1000-second phase value in nanoseconds on clock A.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph1000B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph1000B.setStatus('current')
if mibBuilder.loadTexts: ph1000B.setDescription('Current 1000-second phase value in nanoseconds on clock B.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph10000A = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph10000A.setStatus('current')
if mibBuilder.loadTexts: ph10000A.setDescription('Current 10000-second phase value in nanoseconds on clock A.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
ph10000B = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ph10000B.setStatus('current')
if mibBuilder.loadTexts: ph10000B.setDescription('Current 10000-second phase value in nanoseconds on clock B.\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and contains following information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
phHisInpLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phHisInpLoc.setStatus('current')
if mibBuilder.loadTexts: phHisInpLoc.setDescription("Select input port.\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1\n\n        Note: the user must specify valid input port address.\n        The valid port must be physically installed in the system.\n\n        Note: In the SSU2000, the input is located at main chassis, the 'x' number is always one. \n        ")
phHisTimeAvg = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 1000, 10000))).clone(namedValues=NamedValues(("t100", 100), ("t1000", 1000), ("t10000", 10000)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phHisTimeAvg.setStatus('current')
if mibBuilder.loadTexts: phHisTimeAvg.setDescription('Reports time (seconds) interval of phase value.  \n        t1 (4000 second time interval),\n        t100 (1000 second time interval),\n        t1000  (1000 second time interval),\n        t10000 (10000 second time interval)\n\n        Note: T1 data is only available for ports configured for this function, maximum of 5 ports.\n        ')
phHisClk = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phHisClk.setStatus('current')
if mibBuilder.loadTexts: phHisClk.setDescription('Reports which clock is used as the reference in the phase measurement.\n            ')
phHisCnt = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: phHisCnt.setStatus('current')
if mibBuilder.loadTexts: phHisCnt.setDescription('Count of phase measurement history requested from the phase history buffer.\n        The maximum phase history in buffer are:\n        T100 = 7000,\n        T1000 = 700,\n        T10000 = 70,\n\n        Default value = 10.\n        ')
phHisTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6), )
if mibBuilder.loadTexts: phHisTable.setStatus('current')
if mibBuilder.loadTexts: phHisTable.setDescription('A list of phase history entries. The number of entries is\n      given by the value of phHisCnt. The total entries \n      are up to 7000.\n\n      Note: this table is based upon the following values:\n      phHisInpLoc  - the location of the input port \n      phHisTimeAvg - the time (seconds) interval of phase value\n      phHisCnt     - total amount of phase history to return.\n      ')
phHisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1), ).setIndexNames((0, "SSU2000-MIB", "phHisChassis"), (0, "SSU2000-MIB", "phHisSlot"), (0, "SSU2000-MIB", "phHisPort"), (0, "SSU2000-MIB", "phHisIndex"))
if mibBuilder.loadTexts: phHisEntry.setStatus('current')
if mibBuilder.loadTexts: phHisEntry.setDescription('A phase entry attributes:\n       phHisChassis\n           Identifies which chassis is being addressed. \n       phHisSlot\n           Identifies which slot is being addressed. \n       phHisPort\n           Identifies which port is being addressed. \n       phHisIndex\n           Count/ID value for each phase. \n       phHisV\n           Phase value in nanoseconds defined in phHisTimeAvg.\n    ')
phHisChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: phHisChassis.setStatus('current')
if mibBuilder.loadTexts: phHisChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phHisSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: phHisSlot.setStatus('current')
if mibBuilder.loadTexts: phHisSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phHisPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: phHisPort.setStatus('current')
if mibBuilder.loadTexts: phHisPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
phHisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7000)))
if mibBuilder.loadTexts: phHisIndex.setStatus('current')
if mibBuilder.loadTexts: phHisIndex.setDescription('Count/ID value for each phase. \n        Valid range : 1 - 7000.\n        ')
phHisV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 8, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: phHisV.setStatus('current')
if mibBuilder.loadTexts: phHisV.setDescription('Phase value in nanoseconds defined in phHisTimeAvg.\n\n        The 1,999,999,999 is designated for invalid phase value.\n\n        The string is in the TLV format, and containsfollowing information:\n        DateAndTime - timestamp\n        INTEGER - phase value\n        ')
mtInpLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtInpLoc.setStatus('current')
if mibBuilder.loadTexts: mtInpLoc.setDescription("Select input port.\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1.\n        For example: 1A3 means this input port located at chassis 1, slot 3, with all port specified.\n        ")
mtFrTime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtFrTime.setStatus('current')
if mibBuilder.loadTexts: mtFrTime.setDescription('Select starting time to measure the MTIE from. \n\n        Note: the default time is defined as last 24 hours from current time. \n        The default start-time is the current time minus 24 hours, and the default stop-time is the current time.\n        ')
mtToTime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 3), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtToTime.setStatus('current')
if mibBuilder.loadTexts: mtToTime.setDescription("Select the stop-time to measure the MTIE.\n        If the 'year' field of DateAndTime is specified as zero,  the default time is used.\n\n        The default mtToTime is the current time.\n        ")
mtTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5), )
if mibBuilder.loadTexts: mtTable.setStatus('current')
if mibBuilder.loadTexts: mtTable.setDescription('Report the MTIE measurement.\n    ')
mtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "mtChassis"), (0, "SSU2000-MIB", "mtSlot"), (0, "SSU2000-MIB", "mtPort"))
if mibBuilder.loadTexts: mtEntry.setStatus('current')
if mibBuilder.loadTexts: mtEntry.setDescription('A mtie record attributes:\n        mtChassis\n            Identifies which chassis is being addressed. \n        mtSlot\n            Identifies which slot is being addressed. \n        mtPort\n            Identifies which port is being addressed. \n        mtA\n            MTIE record versus clock A.\n        mtB\n            MTIE record versus clock B.\n        ')
mtChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: mtChassis.setStatus('current')
if mibBuilder.loadTexts: mtChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: mtSlot.setStatus('current')
if mibBuilder.loadTexts: mtSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: mtPort.setStatus('current')
if mibBuilder.loadTexts: mtPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(76, 76)).setFixedLength(76)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mtA.setStatus('current')
if mibBuilder.loadTexts: mtA.setDescription('MTIE record versus clock A.\n\n        The MTIE record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.05 second measurement value\n        INTEGER - 0.1 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 10000 second measurement value\n        INTEGER - 100000 second measurement value\n\t\tnote: if a non-deterministic value is used in this field, a \n\t\tmtie value will be displayed as -1 (i.e. invalid value).\n        ')
mtB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(76, 76)).setFixedLength(76)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mtB.setStatus('current')
if mibBuilder.loadTexts: mtB.setDescription('MTIE record versus clock B.\n\n        The MTIE record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.05 second measurement value\n        INTEGER - 0.1 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 10000 second measurement value\n        INTEGER - 100000 second measurement value\n\t\tnote: if a non-deterministic value is used in this field, a \n\t\tmtie value will be displayed as -1 (i.e. invalid value).\n        ')
mtHisInpLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtHisInpLoc.setStatus('current')
if mibBuilder.loadTexts: mtHisInpLoc.setDescription("Select the input port.\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1.\n\n        Note: the user must specify valid input port address.\n        The valid port is single port and must be physically installed in the system.  \n        Multiple ports are not valid.\n        ")
mtHisClk = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtHisClk.setStatus('current')
if mibBuilder.loadTexts: mtHisClk.setDescription('Clock reference used for reporting of MTIE History.\n        ')
mtHisCnt = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mtHisCnt.setStatus('current')
if mibBuilder.loadTexts: mtHisCnt.setDescription('Number of days of MTIE History to report.\n            The range = 1 - 100. \n            Default value for this field = 1.\n            ')
mtHisTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9), )
if mibBuilder.loadTexts: mtHisTable.setStatus('current')
if mibBuilder.loadTexts: mtHisTable.setDescription('A list of mtie history entries. \n\n    Note: this table is based upon the following values:\n    mtHisInpLoc - the location of the input port \n    mtHisCnt - total number of mtie hostory want to query.\n    ')
mtHisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1), ).setIndexNames((0, "SSU2000-MIB", "mtHisChassis"), (0, "SSU2000-MIB", "mtHisSlot"), (0, "SSU2000-MIB", "mtHisPort"), (0, "SSU2000-MIB", "mtHisIndex"))
if mibBuilder.loadTexts: mtHisEntry.setStatus('current')
if mibBuilder.loadTexts: mtHisEntry.setDescription('MTIE 24-hours history attributes.\n        mtHisChassis\n            Identifies which chassis is being addressed. \n        mtHisSlot\n            Identifies which slot is being addressed. \n        mtHisPort\n            Identifies which port is being addressed. \n        mtHisIndex\n            Index for the MTIE record. \n        mtHisV\n            MTIE record versus selected clock.\n        ')
mtHisChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: mtHisChassis.setStatus('current')
if mibBuilder.loadTexts: mtHisChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtHisSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: mtHisSlot.setStatus('current')
if mibBuilder.loadTexts: mtHisSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtHisPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: mtHisPort.setStatus('current')
if mibBuilder.loadTexts: mtHisPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
mtHisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: mtHisIndex.setStatus('current')
if mibBuilder.loadTexts: mtHisIndex.setDescription('Index for the MTIE record. \n        Valid range = 1 - 100.\n        ')
mtHisV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 30, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(76, 76)).setFixedLength(76)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mtHisV.setStatus('current')
if mibBuilder.loadTexts: mtHisV.setDescription('MTIE record versus selected clock.\n\n        The MTIE record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.05 second measurement value\n        INTEGER - 0.1 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 10000 second measurement value\n        INTEGER - 100000 second measurement value\n\t\tnote: if a non-deterministic value is used in this field, a \n\t\tmtie value will be displayed as -1 (i.e. invalid value).\n        ')
tdInpLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdInpLoc.setStatus('current')
if mibBuilder.loadTexts: tdInpLoc.setDescription("Select input port.\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1.\n        For example: 1A3 means this input port located at hassis 1, slot 3, with all port specified.\n        ")
tdFrTime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdFrTime.setStatus('current')
if mibBuilder.loadTexts: tdFrTime.setDescription('Select starting time to measure the TDEV from. \n\n        Note: the default time is defined as last 24 hours from current time. \n        The default start-time is the current time minus 24 hours, and the default stop-time is the current time.\n        ')
tdToTime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 3), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdToTime.setStatus('current')
if mibBuilder.loadTexts: tdToTime.setDescription('Select stop time to measure the TDEV from. \n\n        Note: the default time is the current time. \n        ')
tdTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5), )
if mibBuilder.loadTexts: tdTable.setStatus('current')
if mibBuilder.loadTexts: tdTable.setDescription('Report the TDEV measurement.\n    ')
tdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "tdChassis"), (0, "SSU2000-MIB", "tdSlot"), (0, "SSU2000-MIB", "tdPort"))
if mibBuilder.loadTexts: tdEntry.setStatus('current')
if mibBuilder.loadTexts: tdEntry.setDescription('A mtie record attributes:\n        tdChassis\n            Identifies which chassis is being addressed. \n        tdSlot\n            Identifies which slot is being addressed. \n        tdPort\n            Identifies which port is being addressed. \n        tdA\n            TDEV record versus clock A.\n        tdB\n            TDEV record versus clock B.\n        ')
tdChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: tdChassis.setStatus('current')
if mibBuilder.loadTexts: tdChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: tdSlot.setStatus('current')
if mibBuilder.loadTexts: tdSlot.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: tdPort.setStatus('current')
if mibBuilder.loadTexts: tdPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(124, 124)).setFixedLength(124)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tdA.setStatus('current')
if mibBuilder.loadTexts: tdA.setDescription('TDEV record versus clock A:\n\n        TDEV record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.1 second measurement value\n        INTEGER - 0.3 second measurement value\n        INTEGER - 0.6 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 3 second measurement value\n        INTEGER - 6 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 30 second measurement value\n        INTEGER - 60 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 300 second measurement value\n        INTEGER - 600 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 3000 second measurement value\n        INTEGER - 6000 second measurement value\n        INTEGER - 10000 second measurement value\n\n        Note: The value are for the time period, the value provided are multpled by 100 times, \n        to avoid floating number representaion.\n        ')
tdB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(124, 124)).setFixedLength(124)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tdB.setStatus('current')
if mibBuilder.loadTexts: tdB.setDescription('TDEV record versus clock B:\n\n        TDEV record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.1 second measurement value\n        INTEGER - 0.3 second measurement value\n        INTEGER - 0.6 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 3 second measurement value\n        INTEGER - 6 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 30 second measurement value\n        INTEGER - 60 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 300 second measurement value\n        INTEGER - 600 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 3000 second measurement value\n        INTEGER - 6000 second measurement value\n        INTEGER - 10000 second measurement value\n\n        Note: The value are for the time period, the value provided are multpled by 100 times, \n        to avoid floating number representaion.\n        ')
tdHisInpLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdHisInpLoc.setStatus('current')
if mibBuilder.loadTexts: tdHisInpLoc.setDescription("Selected input port.\n\n        The format is defined as xAy-z.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3).\n\n        For example: 1A3-1 means this input port located at chassis 1, slot 3, and port 1\n\n        Note: the user must specify valid input port address.\n        The valid port is single port and must be physically installed in the system.  \n        Multiple ports are not valid.\n        ")
tdHisClk = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdHisClk.setStatus('current')
if mibBuilder.loadTexts: tdHisClk.setDescription('Report/Set which clock is used to make the TDEV measurement.\n        ')
tdHisCnt = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tdHisCnt.setStatus('current')
if mibBuilder.loadTexts: tdHisCnt.setDescription('Report/Set the number of days of TDEV History to report.\n        The range = 1 - 100. \n        Default value for this field = 1.\n        ')
tdHisTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9), )
if mibBuilder.loadTexts: tdHisTable.setStatus('current')
if mibBuilder.loadTexts: tdHisTable.setDescription('A list of tdev history entries. \n\n    Note: this table is based upon the following values:\n    tdHisInpLoc - the location of the input port \n    tdHisCnt - total number of tdev hostory want to query.\n    ')
tdHisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1), ).setIndexNames((0, "SSU2000-MIB", "tdHisChassis"), (0, "SSU2000-MIB", "tdHisSlot"), (0, "SSU2000-MIB", "tdHisPort"), (0, "SSU2000-MIB", "tdHisIndex"))
if mibBuilder.loadTexts: tdHisEntry.setStatus('current')
if mibBuilder.loadTexts: tdHisEntry.setDescription('TDEV 24-hours history attributes.\n        tdHisChassis\n            Identifies which chassis is being addressed. \n        tdHisSlot\n            Identifies which slot is being addressed. \n        tdHisPort\n            Identifies which port is being addressed. \n        tdHisIndex\n            Index for the TDEV record. \n        tdHisV\n            TDEV record versus selected clock.\n        ')
tdHisChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: tdHisChassis.setStatus('current')
if mibBuilder.loadTexts: tdHisChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdHisSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: tdHisSlot.setStatus('current')
if mibBuilder.loadTexts: tdHisSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdHisPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: tdHisPort.setStatus('current')
if mibBuilder.loadTexts: tdHisPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
tdHisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: tdHisIndex.setStatus('current')
if mibBuilder.loadTexts: tdHisIndex.setDescription('Index value for the TDEV history record. \n        Valid range = 1 - 100.\n        ')
tdHisV = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 31, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(124, 124)).setFixedLength(124)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tdHisV.setStatus('current')
if mibBuilder.loadTexts: tdHisV.setDescription('TDEV record versus selected clock.\n\n        The TDEV record attributes:\n        INTEGER - entry valid ?, 1=valid, 2=invalid \n        DateAndTime - the staring timestamp\n        DateAndTime - the ending timestamp\n        INTEGER - which clock, 1=clka, 2=clkb\n        INTEGER - 0.1 second measurement value\n        INTEGER - 0.3 second measurement value\n        INTEGER - 0.6 second measurement value\n        INTEGER - 1 second measurement value\n        INTEGER - 3 second measurement value\n        INTEGER - 6 second measurement value\n        INTEGER - 10 second measurement value\n        INTEGER - 30 second measurement value\n        INTEGER - 60 second measurement value\n        INTEGER - 100 second measurement value\n        INTEGER - 300 second measurement value\n        INTEGER - 600 second measurement value\n        INTEGER - 1000 second measurement value\n        INTEGER - 3000 second measurement value\n        INTEGER - 6000 second measurement value\n        INTEGER - 10000 second measurement value\n        \n        Note: The value are for the time period, the value provided are multpled by 100 times, \n        to avoid floating number representaion.\n        ')
freqTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1), )
if mibBuilder.loadTexts: freqTable.setStatus('current')
if mibBuilder.loadTexts: freqTable.setDescription('A list of frequency entries for each input port.\n        ')
fqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "fqChassis"), (0, "SSU2000-MIB", "fqSlot"), (0, "SSU2000-MIB", "fqPort"))
if mibBuilder.loadTexts: fqEntry.setStatus('current')
if mibBuilder.loadTexts: fqEntry.setDescription('Frequency entry attributes:\n        fqChassis\n                INTEGER,    \n        fqSlot\n                INTEGER,    \n        fqPort\n                INTEGER,    \n        fqA\n                OCTET STRING,\n        fqB\n        ')
fqChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: fqChassis.setStatus('current')
if mibBuilder.loadTexts: fqChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
fqSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: fqSlot.setStatus('current')
if mibBuilder.loadTexts: fqSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
fqPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: fqPort.setStatus('current')
if mibBuilder.loadTexts: fqPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
fqA = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fqA.setStatus('current')
if mibBuilder.loadTexts: fqA.setDescription('Current frequency measurement versus clock A.\n        The 1,999,999,999 is designated for invalid frequency value.\n\n        DateAndTime - timestamp\n        INTEGER - frequency value\n        ')
fqB = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 9, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fqB.setStatus('current')
if mibBuilder.loadTexts: fqB.setDescription('Current frequency measurement versus clock B.\n        The 1,999,999,999 is designated for invalid frequency value.\n\n        DateAndTime - timestamp\n        INTEGER - frequency value\n        ')
ntpMode = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("server", 1), ("client", 2), ("local", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpMode.setStatus('current')
if mibBuilder.loadTexts: ntpMode.setDescription('Current NTP mode in the system.\n\n        SERVER - The system has a GPS module installed and has UTC time.\n\n        CLIENT - The system has a valid Client peer entry in the NTP Table, \n                 and is synced with its associated Server. \n\n        LOCAL - The sytem is running its own clock and has its own time. \n        ')
ntpSysPeer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPeer.setStatus('current')
if mibBuilder.loadTexts: ntpSysPeer.setDescription('This is the system peer IP address.\n        ')
ntpSysPeerOffset = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpSysPeerOffset.setStatus('current')
if mibBuilder.loadTexts: ntpSysPeerOffset.setDescription('This is the system peer offset.\n        ')
peerStaTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4), )
if mibBuilder.loadTexts: peerStaTable.setStatus('current')
if mibBuilder.loadTexts: peerStaTable.setDescription('This is the peer statistics table.')
peerStaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "peerStaIndex"))
if mibBuilder.loadTexts: peerStaEntry.setStatus('current')
if mibBuilder.loadTexts: peerStaEntry.setDescription('A peer statistics attributes:\n            peerStaIndex\n                Reports index for each peer statistics table. \n            peerStaAddress\n                Reports the peer IP address.\n            peerStaHomeMode\n                Reports the peer NTP mode.\n            peerStaParentMode   \n                Reports the parent NTP mode.\n            peerStaLeap \n                Reports leap indicator state.  \n            peerStaStratum  \n                Reports peer stratum level. \n            peerStaPrecision    \n                Reports peer precision. \n            peerStaDelay    \n                Reports peer delay. \n            peerStaDispersion   \n                Reports peer dispersion. \n            peerStaOffset   \n                Reports peer offset. \n            peerStaSentCnt  \n                Reports peer sent counter.\n            peerStaProcessCnt   \n                Reports peer process counter.\n            peerStaSanity   \n                Reports status of peer sanity.\n          ')
peerStaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: peerStaIndex.setStatus('current')
if mibBuilder.loadTexts: peerStaIndex.setDescription('Reports index for each peer statistics table. \n        This value ranges from 1 to 8.')
peerStaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaAddress.setStatus('current')
if mibBuilder.loadTexts: peerStaAddress.setDescription('Reports the peer IP address.\n            ')
peerStaHomeMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unspect", 0), ("active", 1), ("passive", 2), ("client", 3), ("server", 4), ("broadcast", 5), ("control", 6), ("private", 7), ("bclient", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaHomeMode.setStatus('current')
if mibBuilder.loadTexts: peerStaHomeMode.setDescription('Reports the peer NTP mode.\n                    unspect(0),\n                    active(1),\n                    passive(2),\n                    client(3),\n                    server(4),\n                    broadcast(5),\n                    control(6),\n                    private(7),\n                    bclient(8)\n            ')
peerStaParentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unspect", 0), ("active", 1), ("passive", 2), ("client", 3), ("server", 4), ("broadcast", 5), ("control", 6), ("private", 7), ("bclient", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaParentMode.setStatus('current')
if mibBuilder.loadTexts: peerStaParentMode.setDescription('Reports the peer parent NTP mode.\n                    unspect(0),\n                    active(1),\n                    passive(2),\n                    client(3),\n                    server(4),\n                    broadcast(5),\n                    control(6),\n                    private(7),\n                    bclient(8)\n            ')
peerStaLeap = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("nowarning", 0), ("addsec", 1), ("delsec", 2), ("notinsync", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaLeap.setStatus('current')
if mibBuilder.loadTexts: peerStaLeap.setDescription("Reports leap indicator state.  \n            Valid values are:\n            0 = sync'd, no warning\n            1 = 1 second will be added\n            2 = 1 second will be subtracted\n            3 = not sync'd\n        ")
peerStaStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaStratum.setStatus('current')
if mibBuilder.loadTexts: peerStaStratum.setDescription('Reports peer stratum level. \n        If zero, it is invalid.\n        ')
peerStaPrecision = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1000, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaPrecision.setStatus('current')
if mibBuilder.loadTexts: peerStaPrecision.setDescription('Reports peer precision.\n        ')
peerStaDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaDelay.setStatus('current')
if mibBuilder.loadTexts: peerStaDelay.setDescription('Reports peer delay.\n        ')
peerStaDispersion = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaDispersion.setStatus('current')
if mibBuilder.loadTexts: peerStaDispersion.setDescription('Reports peer dispersion.\n        ')
peerStaOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaOffset.setStatus('current')
if mibBuilder.loadTexts: peerStaOffset.setDescription('Reports peer offset.\n        ')
peerStaSentCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaSentCnt.setStatus('current')
if mibBuilder.loadTexts: peerStaSentCnt.setDescription('Reports peer sent counter.\n        ')
peerStaProcessCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaProcessCnt.setStatus('current')
if mibBuilder.loadTexts: peerStaProcessCnt.setDescription('Reports peer process counter.\n        ')
peerStaSanity = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 4, 1, 13), YesValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: peerStaSanity.setStatus('current')
if mibBuilder.loadTexts: peerStaSanity.setDescription('Reports status of peer sanity:\n            1 = passed\n            2 = rejected\n        ')
ntpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5), )
if mibBuilder.loadTexts: ntpTable.setStatus('current')
if mibBuilder.loadTexts: ntpTable.setDescription('This table provides the NTP peer statistics.\n          ')
ntpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "ntpIndex"))
if mibBuilder.loadTexts: ntpEntry.setStatus('current')
if mibBuilder.loadTexts: ntpEntry.setDescription('NTP peer attributes.\n          ntpIndex\n             Index for each NTP peer entry. \n          ntpPeer\n             Reports NTP peer IP address.\n          ntpPeerType\n             Report NTP peer mode.\n          ntpBrdTimer\n             Report NTP broadcast timer\n         ')
ntpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: ntpIndex.setStatus('current')
if mibBuilder.loadTexts: ntpIndex.setDescription('Index for each NTP peer entry. \n        This value ranges from 1 to 3.')
ntpPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpPeer.setStatus('current')
if mibBuilder.loadTexts: ntpPeer.setDescription('Reports NTP peer IP address.\n        If the ip address is zero for this entry, the whole entry has no meaning.\n        ')
ntpPeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("client", 1), ("broadcast", 2), ("bclient", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpPeerType.setStatus('current')
if mibBuilder.loadTexts: ntpPeerType.setDescription('Report NTP peer mode.\n\n        CLIENT    - The IP for NTP server in client mode.\n        BROADCAST - The subnet mask for broadcasting mode.\n        BCLIENT   - The IP for NTP server in broadcast client mode.\n        ')
ntpBrdTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 32, 64, 128, 256, 512, 1024))).clone(namedValues=NamedValues(("notuse", 0), ("t32", 32), ("t64", 64), ("t128", 128), ("t256", 256), ("t512", 512), ("t1024", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpBrdTimer.setStatus('current')
if mibBuilder.loadTexts: ntpBrdTimer.setDescription('Report NTP broadcast timer in\n        notuse(0),\n        t32 (32),\n        t64 (64),\n        t128 (128),\n        t256 (256),\n        t512 (512),\n        t1024 (1024)\n        ')
ntpAddClient = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAddClient.setStatus('current')
if mibBuilder.loadTexts: ntpAddClient.setDescription("Set NTP peers to enable client mode.\n\n            This field has meaning only during 'write' operations.\n            ")
ntpAddBrd = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAddBrd.setStatus('current')
if mibBuilder.loadTexts: ntpAddBrd.setDescription("Set NTP servers to enable broadcast mode.\n\n        This field has meaning only during 'write' operations.\n        ")
ntpAddBclient = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpAddBclient.setStatus('current')
if mibBuilder.loadTexts: ntpAddBclient.setDescription("Set NTP peers to enable broadcast client mode.\n\n        This field has meaning only during 'write' operations.\n        ")
ntpDelPeer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpDelPeer.setStatus('current')
if mibBuilder.loadTexts: ntpDelPeer.setDescription("Delete NTP servers from the peer table.\n\n        This field has meaning only during 'write' operations.\n        ")
ntpClr = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clr", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpClr.setStatus('current')
if mibBuilder.loadTexts: ntpClr.setDescription("Clear all the NTP peer addresses in the unit.\n\n        This field has meaning only during 'write' operations.\n        ")
ntpBTimer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 64, 128, 256, 512, 1024))).clone(namedValues=NamedValues(("t32", 32), ("t64", 64), ("t128", 128), ("t256", 256), ("t512", 512), ("t1024", 1024)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpBTimer.setStatus('current')
if mibBuilder.loadTexts: ntpBTimer.setDescription('Reports/Set the broadcast timer \n        t32 (32),\n        t64 (64),\n        t128 (128),\n        t256 (256),\n        t512 (512),\n        t1024 (1024)\n        ')
ntpPrefer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 10, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gps", 1), ("client", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpPrefer.setStatus('current')
if mibBuilder.loadTexts: ntpPrefer.setDescription('Report/Set the SSU time-of-day source from GPS or NTP Client.\n        ')
tmCurTime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 11, 1), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmCurTime.setStatus('current')
if mibBuilder.loadTexts: tmCurTime.setDescription('Reports the current system time.\n\n        Note: user can change the system time only when the system is in LOCAL mode. \n        If the system is SERVER or NTP CLIENT, changing system time is not allowed.\n        ')
tmLocalOffset = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 11, 2), TLocalTimeOffset()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmLocalOffset.setStatus('current')
if mibBuilder.loadTexts: tmLocalOffset.setDescription("Report/Set local time offset.\n\n        Note: This allow the users to set a local time offset.\n        The local time offset limits are (+/-)13 hours. \n        This is primarily used in systems with GPS or NTP time-of-day references. \n        where users' prefer system time to be set to local time.\n        ")
pqlDs1Table = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 1), )
if mibBuilder.loadTexts: pqlDs1Table.setStatus('current')
if mibBuilder.loadTexts: pqlDs1Table.setDescription('A list of PQL entries. \n          The total entries are 16.')
pqlDs1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "pqlDs1Index"))
if mibBuilder.loadTexts: pqlDs1Entry.setStatus('current')
if mibBuilder.loadTexts: pqlDs1Entry.setDescription('A PQL entry containing objects of each PQL.')
pqlDs1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: pqlDs1Index.setStatus('current')
if mibBuilder.loadTexts: pqlDs1Index.setDescription('A unique value for each PQL table. \n        This value ranges from 1 to 16.')
pqlDs1Ssm = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 1, 1, 2), TSsm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pqlDs1Ssm.setStatus('current')
if mibBuilder.loadTexts: pqlDs1Ssm.setDescription('This DS1 Sync Status Message (SSM) value for that Priority Quality Level (PQL) entry. \n\n        Note: If value of this entry is 0xff, the entry is not used.\n        This is the 8-bit value. If the 8th bit is set, this SSM value is not telcom standard.\n        Use caution when modifying as system characteristics will be altered.\n        ')
pqlDs1Descr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pqlDs1Descr.setStatus('current')
if mibBuilder.loadTexts: pqlDs1Descr.setDescription('Report description for the DS1 Priority Quality Level (PQL) entry.')
pqlE1Table = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 2), )
if mibBuilder.loadTexts: pqlE1Table.setStatus('current')
if mibBuilder.loadTexts: pqlE1Table.setDescription('A list of PQL entries. \n          The total entries are 16.')
pqlE1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "pqlE1Index"))
if mibBuilder.loadTexts: pqlE1Entry.setStatus('current')
if mibBuilder.loadTexts: pqlE1Entry.setDescription('A PQL entry attributes.\n            pqlE1Index\n               Index value for each PQL table. \n            pqlE1Ssm\n               Report/Set the E1 Sync Status Message (SSM) value for that Priority Quality Level (PQL) entry. \n            pqlE1Descr\n               Report/Set description for the E1 Priority Quality Level (PQL) entry.\n          ')
pqlE1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: pqlE1Index.setStatus('current')
if mibBuilder.loadTexts: pqlE1Index.setDescription('Index value for each PQL table. \n              This value ranges from 1 to 16.')
pqlE1Ssm = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 2, 1, 2), TSsm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pqlE1Ssm.setStatus('current')
if mibBuilder.loadTexts: pqlE1Ssm.setDescription('Report/Set the E1 Sync Status Message (SSM) value for that Priority Quality Level (PQL) entry. \n\n        Note: If value of this entry is 0xff, this entry is not used.\n        This is the 8-bits value. If the 8th bit is set, this SSM value is not telcom standard.\n        Use caution when modifying as system characteristics will be altered.\n        ')
pqlE1Descr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 14))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pqlE1Descr.setStatus('current')
if mibBuilder.loadTexts: pqlE1Descr.setDescription('Report/Set description for the E1 Priority Quality Level (PQL) entry.')
pqlReset = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("factory", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pqlReset.setStatus('current')
if mibBuilder.loadTexts: pqlReset.setDescription("Set DS1/E1 Priority Quality Level(PQL) tables into factory defaults. \n\n        Note: It only has meaning for 'write' operations.\n        ")
ionameTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1), )
if mibBuilder.loadTexts: ionameTable.setStatus('current')
if mibBuilder.loadTexts: ionameTable.setDescription('A list of input/output name entries.\n          ')
ionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "ionChassis"), (0, "SSU2000-MIB", "ionSlot"), (0, "SSU2000-MIB", "ionPort"))
if mibBuilder.loadTexts: ionEntry.setStatus('current')
if mibBuilder.loadTexts: ionEntry.setDescription('An io name entry attributes.\n            ionChassis\n               Identifies which chassis is being addressed. \n            ionSlot\n               Identifies which slot is being addressed. \n            ionPort\n               Identifies which port is being addressed. \n            ionName\n               Report/Set port ioname field.\n          ')
ionChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ionChassis.setStatus('current')
if mibBuilder.loadTexts: ionChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
ionSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ionSlot.setStatus('current')
if mibBuilder.loadTexts: ionSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
ionPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ionPort.setStatus('current')
if mibBuilder.loadTexts: ionPort.setDescription('Identifies which port is being addressed. \n        This chassis number, slot, and port number uniquely identify each inventory entry.\n        ')
ionName = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ionName.setStatus('current')
if mibBuilder.loadTexts: ionName.setDescription('Report/Set port ioname field.\n          If the name is a null string (zero length), this i/o name s cleared from the port.\n          ')
ionameLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ionameLoc.setStatus('current')
if mibBuilder.loadTexts: ionameLoc.setDescription("The text string of the input/output port.\n        The format is defined as xAy-z or xAy-z&&z (if specified the range of ports)\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n        - is the constant letter '-', and is slot/port sepearator\n        z is the port number (1 to 3, if input) or \n            (1 to 20, if output port).\n        && is the two constant letters '&&', and is port range sepearator\n        z is the ending port number (1 to 3, if input) or \n            (1 to 20, if output port).\n\n        For example: \n        1A3-1 means this port located at chassis 1, slot 3, and port 1.\n        2A5-2&&5 means this ports located at chassis 2, slot 5, and ports 2 thru 5.\n\n        Note: the user must specify valid port address.\n        The valid port must be physically installed in the system.\n        ")
ionameSet = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 13, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ionameSet.setStatus('current')
if mibBuilder.loadTexts: ionameSet.setDescription('Report/Set name associated input/output ports.\n\n        If the name is a null string, this i/o name is cleared from the ports.\n\n        Note: You must specify the i/o port range first, and then provide the i/o name.\n        ')
com232Table = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1), )
if mibBuilder.loadTexts: com232Table.setStatus('current')
if mibBuilder.loadTexts: com232Table.setDescription('A list of RS232 port entries. The total entries are 3.')
comEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "comIndex"))
if mibBuilder.loadTexts: comEntry.setStatus('current')
if mibBuilder.loadTexts: comEntry.setDescription('An RS232 communication entry attributes.\n            comIndex\n               Index for each communication table. \n            comMode\n               Set the specified RS232 port command parser to ICS or  TL1.\n            comEcho\n                Enable/disable echo on the specified RS232 port.\n            comEol\n                Set the specified RS232 port End Of Line (EOL) terminator.\n            comBaud\n                Set the specified RS232 port baud rate.\n\t\t')
comIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: comIndex.setStatus('current')
if mibBuilder.loadTexts: comIndex.setDescription('Index for each communication table. \n              This value ranges from 1 to 3.')
comMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ics", 1), ("tl1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comMode.setStatus('current')
if mibBuilder.loadTexts: comMode.setDescription('Set the specified RS232 port command parser to ICS or TL1.\n            ')
comEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1, 3), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comEcho.setStatus('current')
if mibBuilder.loadTexts: comEcho.setDescription('Enable/disable echo on the specified RS232 port.\n\n            Note: This only affects the ICS command mode. \n            ')
comEol = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cr", 1), ("lf", 2), ("crlf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comEol.setStatus('current')
if mibBuilder.loadTexts: comEol.setDescription('Set the specified RS232 port End Of Line (EOL) terminator.\n                    cr (1),\n                    lf (2),\n                    crlf (3)\n            ')
comBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2400, 4800, 9600, 19200))).clone(namedValues=NamedValues(("baud1200", 1200), ("baud2400", 2400), ("baud4800", 4800), ("baud9600", 9600), ("baud19200", 19200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comBaud.setStatus('current')
if mibBuilder.loadTexts: comBaud.setDescription('Set the specified RS232 port baud rate.\n            Valid baud rates are: \n                    baud1200 (1200),\n                    baud2400 (2400),\n                    baud4800 (4800),\n                    baud9600 (9600),\n                    baud19200 (19200)\n            ')
comParmTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 2), )
if mibBuilder.loadTexts: comParmTable.setStatus('current')
if mibBuilder.loadTexts: comParmTable.setDescription('A list of communication port setting entries (such as timeout). \n          The total entries are 5.')
comParmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "comParmIndex"))
if mibBuilder.loadTexts: comParmEntry.setStatus('current')
if mibBuilder.loadTexts: comParmEntry.setDescription('Communication setting entry for each logical port.\n            comParmIndex\n                Index for each communication parameter table. \n            comType\n                Specify the communication port.\n            comTimeout\n                Report/Set communication port session timeout (in seconds).\n          ')
comParmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: comParmIndex.setStatus('current')
if mibBuilder.loadTexts: comParmIndex.setDescription('Index for each communication parameter table. \n              This value ranges from 1 to 5.')
comType = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 1), ("coma", 2), ("comb", 3), ("telnet", 4), ("etl1", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: comType.setStatus('current')
if mibBuilder.loadTexts: comType.setDescription('Specify the communication port.\n        Valid values are:\n            1 = local (RS232)\n            2 = com A (RS232)\n            3 = com B (RS232)\n            4 = telnet\n            5 = telnet TL1 port\n        ')
comTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 43200), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comTimeout.setStatus('current')
if mibBuilder.loadTexts: comTimeout.setDescription('Report/Set communication port session timeout (in seconds).\n\n        Note: 0 = NEVER timeout.\n        ')
comLogoff = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 14, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("local", 1), ("coma", 2), ("comb", 3), ("telneta", 4), ("telnetb", 5), ("telnetc", 6), ("telnetd", 7), ("etl1a", 8), ("etl1b", 9), ("etl1c", 10), ("etl1d", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: comLogoff.setStatus('current')
if mibBuilder.loadTexts: comLogoff.setDescription("Logoff user on another logical communication port.\n\n        The valid communication port are: \n                    local (1),\n                    coma (2),\n                    comb (3),\n                    telneta (4),\n                    telnetb (5),\n                    telnetc (6),\n                    telnetd (7),\n                    etl1a (8),\n                    etl1b (9),\n                    etl1c (10),\n                    etl1d (11)\n\n        Note: This field only has meaning for 'write' operations.\n        ")
snmpv2manTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 1), )
if mibBuilder.loadTexts: snmpv2manTable.setStatus('current')
if mibBuilder.loadTexts: snmpv2manTable.setDescription('Reports the SNMPv2 manager(s) IP address.\n    ')
snmpv2manEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "snmpv2manIndex"))
if mibBuilder.loadTexts: snmpv2manEntry.setStatus('current')
if mibBuilder.loadTexts: snmpv2manEntry.setDescription('SNMPv2 manager table attributes.\n            snmpv2manIndex\n                Index for each SNMPv2 manager table entry. \n            snmpv2manIp\n                Set the snmpv2 manager IP address.\n          ')
snmpv2manIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: snmpv2manIndex.setStatus('current')
if mibBuilder.loadTexts: snmpv2manIndex.setDescription('Index for each SNMPv2 manager table entry. \n        This value range from 1 to 4.')
snmpv2manIp = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv2manIp.setStatus('current')
if mibBuilder.loadTexts: snmpv2manIp.setDescription('Set the snmpv2 manager IP address.\n        Write a new IP address will put this new IP into table.\n        Write zero IP address will delete this IP address from table.\n        Note: The above only apply to SNMPv2. \n        ')
snmpmanInit = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("initv2", 1), ("initv3", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpmanInit.setStatus('current')
if mibBuilder.loadTexts: snmpmanInit.setDescription("Initializes the SNMP Manager Table to null IP addresses.\n        Note: This field only has meaning when 'write' operations\n        ")
snmpmanTrap = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alarm", 1), ("all", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpmanTrap.setStatus('current')
if mibBuilder.loadTexts: snmpmanTrap.setDescription("Set the SNMP trap filter to SNMP Manager.\n        The trap filter can be set to be 'alarm' only or all traps.\n\n        1 = alarm\n        2 = all\n\n        If 'alarm' trap, only events with ID less than 32 (i.e. alarms) \n        will be sent to the SNMP Manager. All other traps will be filtered \n        out. The purpose of this command is to reduce the traffic, if \n        desired.\n        ")
snmpNotification = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v2", 1), ("v3", 2), ("all", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpNotification.setStatus('current')
if mibBuilder.loadTexts: snmpNotification.setDescription('Set SNMPv3 traps format to use.\n             v2 (1), -- traps in v2 form, address from v2 manager table\n             v3 (2), -- traps in v3 form, address from v2 manager table\n             all(3)  -- traps in v2/v3, address from v2/v3 table accordingly\n        It can V2, V3, or both forms. Each v2/v3 traps sent out are viaits own manager table accordingly.\n        Note: The above only apply to SNMPv3 load. \n        ')
snmpEnable = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v2enable", 1), ("v2disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpEnable.setStatus('current')
if mibBuilder.loadTexts: snmpEnable.setDescription('Activate/deactivate SNMPv2.\n        Note: The above only apply to SNMPv3 load. \n        ')
snmpv2userTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 6), )
if mibBuilder.loadTexts: snmpv2userTable.setStatus('current')
if mibBuilder.loadTexts: snmpv2userTable.setDescription('SNMPv2 User Table.\n    ')
snmpv2userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 6, 1), ).setIndexNames((0, "SSU2000-MIB", "snmpv2userIndex"))
if mibBuilder.loadTexts: snmpv2userEntry.setStatus('current')
if mibBuilder.loadTexts: snmpv2userEntry.setDescription('SNMPv2 user table entry attributes.\n            snmpv2userIndex\n              Index for each SNMPv2 user table entry. \n            snmpv2user\n             Reports SNMPv2 user \n    ')
snmpv2userIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: snmpv2userIndex.setStatus('current')
if mibBuilder.loadTexts: snmpv2userIndex.setDescription('Index for each SNMPv2 user entry. \n              ')
snmpv2user = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpv2user.setStatus('current')
if mibBuilder.loadTexts: snmpv2user.setDescription('Reports SNMPv2 user entry\n            It is the read community string of an SNMPv2 user\n            ')
snmpv3userTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 7), )
if mibBuilder.loadTexts: snmpv3userTable.setStatus('current')
if mibBuilder.loadTexts: snmpv3userTable.setDescription('SNMPv3 User Table.\n          ')
snmpv3userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 7, 1), ).setIndexNames((0, "SSU2000-MIB", "snmpv3userIndex"))
if mibBuilder.loadTexts: snmpv3userEntry.setStatus('current')
if mibBuilder.loadTexts: snmpv3userEntry.setDescription('SNMPv3 user table entry attributes.\n            snmpv3userIndex\n              Index for each SNMPv3 user table entry. \n            snmpv3user\n             Reports SNMPv3 user \n    ')
snmpv3userIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: snmpv3userIndex.setStatus('current')
if mibBuilder.loadTexts: snmpv3userIndex.setDescription('Index for each SNMPv3 user table entry. \n              ')
snmpv3user = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpv3user.setStatus('current')
if mibBuilder.loadTexts: snmpv3user.setDescription('Reports SNMPv3 user\n            ')
snmpv3manTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 8), )
if mibBuilder.loadTexts: snmpv3manTable.setStatus('current')
if mibBuilder.loadTexts: snmpv3manTable.setDescription('Reports SNMPv3 manager IP address.\n          ')
snmpv3manEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 8, 1), ).setIndexNames((0, "SSU2000-MIB", "snmpv3manIndex"))
if mibBuilder.loadTexts: snmpv3manEntry.setStatus('current')
if mibBuilder.loadTexts: snmpv3manEntry.setDescription('SNMPv3 manager entry attributes.\n            snmpv3manIndex\n               Index for each SNMPv3 manager entry. \n            snmpv3manIp\n               Report/Set snmpv3 manager IP address.\n            snmpv3manUser\n               Report/Set the SNMPv3 user\n          ')
snmpv3manIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: snmpv3manIndex.setStatus('current')
if mibBuilder.loadTexts: snmpv3manIndex.setDescription('Index for each SNMPv3 manager entry. \n              This value range from 1 to 4.')
snmpv3manIp = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 8, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3manIp.setStatus('current')
if mibBuilder.loadTexts: snmpv3manIp.setDescription("Report/Set snmpv3 manager IP address.\n\n        Note: No action shall be taken at this time. \n        Action shall be taken when the next field 'snmpv3manUser'is written. \n        The above only apply to SNMPv3. \n        ")
snmpv3manUser = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 15, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3manUser.setStatus('current')
if mibBuilder.loadTexts: snmpv3manUser.setDescription('Report/Set the SNMPv3 user\n\n        Note1: All user names are uppercase except the built-in user. \n        Write username will put this user along with ip into table.\n        Writing a null string will delete this entry from table.\n        Any previouly written IP has no meaning (i.e. the writing the null \n        string of username shall trigger the delete action of that entry from table.\n        Note2: There is no modify action. User need to delete an entry and then add an new entry.\n        Note3: The above only apply to SNMPv3. \n        ')
sysPbo = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("event", 1), ("report", 2), ("none", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPbo.setStatus('current')
if mibBuilder.loadTexts: sysPbo.setDescription('The input port Phase Built-Out ode (PBO). \n        1 = EVENT   : PBO enabled, PBO sent out, and stored \n                      in the event buffer.\n        2 = REPORT  : PBO enabled, PBO sent out, but not stored \n                      in the event buffer.\n        3 = NONE    : PBO enabled, but PBO event not sent out.\n        4 = DISABLE : PBO disabled.\n\n        Note: This is a system-wide command. \n        When the user writes this field, it will affect all DS1/E1 input modules in the system.\n        ')
sysResetClk = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysResetClk.setStatus('current')
if mibBuilder.loadTexts: sysResetClk.setDescription('Reset the specified clock.\n        Restarts clock without maintaining current servo control values. \n        ')
sysKeepAliveTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 3), )
if mibBuilder.loadTexts: sysKeepAliveTable.setStatus('current')
if mibBuilder.loadTexts: sysKeepAliveTable.setDescription("Set system 'keep alive' mode \n      where a trap is generated automatically on a period specified by the customer\n      This is intended to verify the upstream support that the SSU2000 and the associated communication path is functional")
sysAliveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "sysAliveIndex"))
if mibBuilder.loadTexts: sysAliveEntry.setStatus('current')
if mibBuilder.loadTexts: sysAliveEntry.setDescription("System 'keepalive' attributes for TL1 or SNMP.\n            sysAliveIndex\n                Index value for each 'keepalive' table. \n            sysAliveType\n                Keep Alive session type:\n            sysAliveTime\n                Keep alive message interval.  \n    ")
sysAliveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sysAliveIndex.setStatus('current')
if mibBuilder.loadTexts: sysAliveIndex.setDescription("Index value for each 'keepalive' table. \n        This range of the value is from 1 to 2.")
sysAliveType = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tl1", 1), ("snmp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAliveType.setStatus('current')
if mibBuilder.loadTexts: sysAliveType.setDescription('Keep Alive session type:\n        1 = TL1 session \n        2 = SNMP session\n        ')
sysAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAliveTime.setStatus('current')
if mibBuilder.loadTexts: sysAliveTime.setDescription('Keep alive message interval.  \n        Valid range = 1 - 60 (minutes).\n        0 = disabled (default)\n        ')
sysOpmode = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("subtending", 2), ("japanese", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysOpmode.setStatus('current')
if mibBuilder.loadTexts: sysOpmode.setDescription('Set the operational mode in the SSU-2000. \n            normal(1), -- Non-Subtending\n            subtending(2), -- Domestic Subtending\n            japanese(3)  -- Japanese Subtending\n            ')
sysTl1Format = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gr831", 1), ("gr833", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTl1Format.setStatus('current')
if mibBuilder.loadTexts: sysTl1Format.setDescription('Set the TL1 format in the SSU-2000.\n        Allows the system to generate GR-831 compliant or GR-833 compliant autonomous events. \n        All SSU-2000 TL1 sessions will generate either GR-831 or GR-833 autonomous events.  \n        Refer to TL1 Specification 12613127-001-2 for event formats \n        ')
sysEvtLogin = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEvtLogin.setStatus('current')
if mibBuilder.loadTexts: sysEvtLogin.setDescription('Set LOGIN and LOGOUT events from being stored in the event log.\n\n        disable(1), -- not store login and logout in the event log\n        enable(2)   -- store login and logout in the event log\n        ')
sysAco = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 16, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAco.setStatus('current')
if mibBuilder.loadTexts: sysAco.setDescription('Set ACO when writing with active.\n            It has NOP when write with inactive.\n            When read, it returns the current state of ACO.\n            ')
userTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17, 1), )
if mibBuilder.loadTexts: userTable.setStatus('current')
if mibBuilder.loadTexts: userTable.setDescription('Report valid user names and their associated user access level.\n        This user list is used for connecting the ICS and TL1 command parser via RS232 or Ethernet port (telnet or TL1 port).\n        Note: the password is not reported.\n        ')
userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "userIndex"))
if mibBuilder.loadTexts: userEntry.setStatus('current')
if mibBuilder.loadTexts: userEntry.setDescription('User table attributes:\n           userIndex\n               Index for each user entry. \n           userlevel\n               Reports user access level.\n           username\n               Reports user name.\n          ')
userIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)))
if mibBuilder.loadTexts: userIndex.setStatus('current')
if mibBuilder.loadTexts: userIndex.setDescription('Reports index for each user entry. \n              This value ranges from 1 to 25.\n              ')
userlevel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userlevel.setStatus('current')
if mibBuilder.loadTexts: userlevel.setDescription('Reports user access level.\n        The user level:\n        (1) USER - Read Only - can retrieve status information only.\n        (2) TECHNICIAN - Read and limited set ability for fault isolating and installation setup of the unit.\n        (3) SUPERVISORY - For configuration modifications.\n        (4) ADMINISTRATOR - Setup or change user access.\n        ')
username = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 17, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: username.setStatus('current')
if mibBuilder.loadTexts: username.setDescription('Reports user name.')
whoTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18, 1), )
if mibBuilder.loadTexts: whoTable.setStatus('current')
if mibBuilder.loadTexts: whoTable.setDescription('Reports which users are logged into all active communication ports (RS232, TL1, or telnet). \n    It displays the username and the communication port.\n    ')
whoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "whoIndex"))
if mibBuilder.loadTexts: whoEntry.setStatus('current')
if mibBuilder.loadTexts: whoEntry.setDescription("Report 'who' table attributes.\n            whoIndex\n                Report index of the 'who' entry. \n            whoPort\n                Report logical communication port.\n            whoName\n                Report user name.\n          ")
whoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: whoIndex.setStatus('current')
if mibBuilder.loadTexts: whoIndex.setDescription("Report index of the 'who' entry. \n              This value ranges from 1 to 11.")
whoPort = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("local", 1), ("coma", 2), ("comb", 3), ("telneta", 4), ("telnetb", 5), ("telnetc", 6), ("telnetd", 7), ("etl1a", 8), ("etl1b", 9), ("etl1c", 10), ("etl1d", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: whoPort.setStatus('current')
if mibBuilder.loadTexts: whoPort.setDescription('Report logical communication port.\n            local(1), -- serial local (craft) port\n            coma(2), -- serial port A\n            comb(3), -- serial port B\n            telneta(4), -- telnet session A\n            telnetb(5), -- telnet session B\n            telnetc(6), -- telnet session C\n            telnetd(7), -- telnet session D\n            etl1a(8), -- TL1 session A\n            etl1b(9), -- TL1 session B\n            etl1c(10), -- TL1 session C\n            etl1d(11) -- TL1 session D\n            ')
whoName = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 18, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: whoName.setStatus('current')
if mibBuilder.loadTexts: whoName.setDescription('Report user name.')
ntpqXeq = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntpqXeq.setStatus('current')
if mibBuilder.loadTexts: ntpqXeq.setDescription("Report/Set the PackeTime Module.\n        The format is defined as xAy.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n\n        For example: 1A6 means this PackeTime located at chassis 1, slot 6\n\n        Note: the user must specify valid PackeTime address.\n        The valid module must be physically installed in the system.\n        Note: Writing operation causes the system to execute the ntpq.\n        The ntpq returned value may take 2 seconds.\n        ")
ntpqSyspeer = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqSyspeer.setStatus('current')
if mibBuilder.loadTexts: ntpqSyspeer.setDescription('Report syspeer is the IP address of peer selected by server as most likely to provide best timing information.\n        ')
ntpqSysleap = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqSysleap.setStatus('current')
if mibBuilder.loadTexts: ntpqSysleap.setDescription('Report system leap indicator\n        The NTP server leap indicator (0, +1, -1, or NOSYNC).\n        2 = NOSYNC\n        ')
ntpqSysstratum = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqSysstratum.setStatus('current')
if mibBuilder.loadTexts: ntpqSysstratum.setDescription('Report system NTP server stratum level\n        ')
ntpqSysprecision = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 0))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqSysprecision.setStatus('current')
if mibBuilder.loadTexts: ntpqSysprecision.setDescription('Report measurement of a number of significant bits in NTP timestamp\n        ')
ntpqRootdelay = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqRootdelay.setStatus('current')
if mibBuilder.loadTexts: ntpqRootdelay.setDescription('Report calculated root delay value to primary source\n        ')
ntpqRootdispersion = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqRootdispersion.setStatus('current')
if mibBuilder.loadTexts: ntpqRootdispersion.setDescription('Report NTP system Root Dispersion (max error relative to the primary \n        reference source at the root of the synchronization subnet, in seconds)\n        ')
ntpqSysoffset = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqSysoffset.setStatus('current')
if mibBuilder.loadTexts: ntpqSysoffset.setDescription('Report clients calculated time offset value for the specified server\n        ')
ntpqReftime = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqReftime.setStatus('current')
if mibBuilder.loadTexts: ntpqReftime.setDescription('Report local reference time\n        ')
ntpqTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3), )
if mibBuilder.loadTexts: ntpqTable.setStatus('current')
if mibBuilder.loadTexts: ntpqTable.setDescription('PackeTime NTPQ entries.\n    ')
ntpqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "ntpqChassis"), (0, "SSU2000-MIB", "ntpqSlot"), (0, "SSU2000-MIB", "ntpqIndex"))
if mibBuilder.loadTexts: ntpqEntry.setStatus('current')
if mibBuilder.loadTexts: ntpqEntry.setDescription('Report NTPQ attributes.\n            ntpqChassis\n               Identifies which chassis is being addressed. \n            ntpqSlot\n               Identifies which slot is being addressed. \n            ntpqIndex\n               Identifies which index is being addressed. \n            ntpqValid\n               Reports validity of entry.\n            ntpqPeer\n               Reports address of NTP peer\n            ntpqRefid\n               Reports NTP peer reference ID\n            ntpqStratum\n               Reports NTP peer stratum level\n            ntpqPoll\n               Reports NTP peer poll interval\n            ntpqReach\n               Reports NTP peer reachability\n            ntpqDelay\n               Reports NTP peer delay\n            ntpqOffset\n               Reports NTP peer offset\n            ntpqJitter\n               Report  NTP peer jitter \n     ')
ntpqChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: ntpqChassis.setStatus('current')
if mibBuilder.loadTexts: ntpqChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
ntpqSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ntpqSlot.setStatus('current')
if mibBuilder.loadTexts: ntpqSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
ntpqIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: ntpqIndex.setStatus('current')
if mibBuilder.loadTexts: ntpqIndex.setDescription('Identifies which index is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
ntpqValid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 4), ValidValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqValid.setStatus('current')
if mibBuilder.loadTexts: ntpqValid.setDescription('Reports validity of entry.\n        If this entry is not valid, all info in this entry has no meaning.\n        ')
ntpqPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqPeer.setStatus('current')
if mibBuilder.loadTexts: ntpqPeer.setDescription('Reports address of NTP peer\n        ')
ntpqRefid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqRefid.setStatus('current')
if mibBuilder.loadTexts: ntpqRefid.setDescription('Reports NTP system Reference\n        ')
ntpqStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqStratum.setStatus('current')
if mibBuilder.loadTexts: ntpqStratum.setDescription('Reports NTP server stratum level\n        ')
ntpqPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqPoll.setStatus('current')
if mibBuilder.loadTexts: ntpqPoll.setDescription('Reports NTP server poll interval\n        ')
ntpqReach = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqReach.setStatus('current')
if mibBuilder.loadTexts: ntpqReach.setDescription('Reports NTP server reachability\n        ')
ntpqDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqDelay.setStatus('current')
if mibBuilder.loadTexts: ntpqDelay.setDescription('Reports calculated root delay value to primary source\n        ')
ntpqOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqOffset.setStatus('current')
if mibBuilder.loadTexts: ntpqOffset.setDescription("Reports client's calculated time offset value for the specified server\n        ")
ntpqJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 19, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntpqJitter.setStatus('current')
if mibBuilder.loadTexts: ntpqJitter.setDescription('Report jitter value\n        ')
rtXeq = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtXeq.setStatus('current')
if mibBuilder.loadTexts: rtXeq.setDescription("Write access level: level 1 or above\n\n        The text string of the PackeTime Module.\n        The format is defined as xAy.\n        where\n        x is the chassis number: in this case is 1,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 3 to 11)\n\n        For example: 1A6 means this PackeTime located at \n          chassis 1, slot 6\n\n        Note1: the user must specify valid PackeTime address.\n        The valid module must be physically installed in the system.\n        Note2: Writing operation causes the system to execute the route table.\n        The route table returned value may take 2 seconds.\n        ")
routeTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3), )
if mibBuilder.loadTexts: routeTable.setStatus('current')
if mibBuilder.loadTexts: routeTable.setDescription('PackeTime route entries. \n      ')
rtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "rtChassis"), (0, "SSU2000-MIB", "rtSlot"), (0, "SSU2000-MIB", "rtIndex"))
if mibBuilder.loadTexts: rtEntry.setStatus('current')
if mibBuilder.loadTexts: rtEntry.setDescription("PackeTime route table attributes:\n            rtChassis\n                Identifies which chassis is being addressed. \n            rtSlot\n                Identifies which slot is being addressed. \n            rtIndex\n                Identifies which index is being addressed. \n            rtValid\n                Reports validity of entry.\n            rtDest\n                Reports destination network/host\n            rtGate\n                Reports destination gateway\n            rtMask\n                Reports destination network mask\n            rtFlags\n                Reports route flags\n            rtMetric\n                Reports the 'distance' to the target (router hops). \n            rtRef\n                Reports number of references to this route.\n            rtUse\n                Report number of lookups for the route.\n            rtIface\n                Report interface associated with this route. \n    ")
rtChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: rtChassis.setStatus('current')
if mibBuilder.loadTexts: rtChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
rtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: rtSlot.setStatus('current')
if mibBuilder.loadTexts: rtSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
rtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: rtIndex.setStatus('current')
if mibBuilder.loadTexts: rtIndex.setDescription('Identifies which index is being addressed. \n        This chassis, slot, and index number uniquely identify each entry.\n        ')
rtValid = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 4), ValidValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtValid.setStatus('current')
if mibBuilder.loadTexts: rtValid.setDescription('Reports validity of entry.\n            If this entry is not valid, all info in this entry has no meaning.\n            ')
rtDest = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtDest.setStatus('current')
if mibBuilder.loadTexts: rtDest.setDescription('Reports destination network/host\n            or 0.0.0.0 is default.\n            ')
rtGate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtGate.setStatus('current')
if mibBuilder.loadTexts: rtGate.setDescription('Reports gateway address \n            or 0.0.0.0 if none set\n            ')
rtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtMask.setStatus('current')
if mibBuilder.loadTexts: rtMask.setDescription("Reports  netmask  for  the  destination  net;  \n            '255.255.255.255' for a host destination and '0.0.0.0' for the default route.\n            ")
rtFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtFlags.setStatus('current')
if mibBuilder.loadTexts: rtFlags.setDescription(' Reports route table flags \n              U (route is up)\n              H (target is a host)\n              G (use gateway)\n              R (reinstate route for dynamic routing)\n              D (dynamically installed by daemon or redirect)\n              M (modified from routing daemon or redirect)\n              A (installed by addrconf)\n              C (cache entry)\n              !  (reject route)         \n            ')
rtMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtMetric.setStatus('current')
if mibBuilder.loadTexts: rtMetric.setDescription("Reports the 'distance' to the target (router hops). \n            ")
rtRef = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtRef.setStatus('current')
if mibBuilder.loadTexts: rtRef.setDescription('Reports number of references to this route.\n            ')
rtUse = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtUse.setStatus('current')
if mibBuilder.loadTexts: rtUse.setDescription('Report number of lookups for the route.\n            ')
rtIface = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 20, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 34094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtIface.setStatus('current')
if mibBuilder.loadTexts: rtIface.setDescription('Report interface associated with this route. \n              0 = eth0 (Maintenance Port)\n              1 = eth1 (Service Port A)\n              2 = eth2 (Service Port B)\n              3 = bond0 (Service Port Bonding)\n              10000-14094 = eth1.xxxx\n              20000-24094 = eth2.xxxx\n              30000-34094 = bond0.xxxx\n              where xxxx is the VLAN ID.\n            ')
tprTag = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 50, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tprTag.setStatus('current')
if mibBuilder.loadTexts: tprTag.setDescription("This command is to ask the agent to resend a lost trap.\n            The lost trap is specified by its trap tag number.\n            The trap tag number is a 32-bit positive integer. It will \n            rollover to one, when it reaches the maximum number \n            2147483647.\n\n            If the tag number is beyond the agent's abilities to handle,\n            it will respond with an error. Otherwise, the requested trap \n            will be sent to the manager.\n             \n            Note: When resending a trap, the 'tpEvt' field of trap is set \n            to 2 (RE-SEND). In the normal trap, the'tpEvt' field of trap \n            is set to 1 (AUTONOMOUS).\n            ")
tpTag = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpTag.setStatus('current')
if mibBuilder.loadTexts: tpTag.setDescription('The trap counter which increments for each trap.\n        ')
tpEvt = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autonomous", 1), ("resend", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpEvt.setStatus('current')
if mibBuilder.loadTexts: tpEvt.setDescription('Indication of whether trap is an autonomous event or resend by user request.\n        ')
tpId = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpId.setStatus('current')
if mibBuilder.loadTexts: tpId.setDescription('The trap ID number.')
tpMCode = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 4), TModuleCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpMCode.setStatus('current')
if mibBuilder.loadTexts: tpMCode.setDescription('The trap module hex code (16-bits).')
tpTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpTimestamp.setStatus('current')
if mibBuilder.loadTexts: tpTimestamp.setDescription('This DateAndTime string contains the event timestamp.')
tpChassis = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpChassis.setStatus('current')
if mibBuilder.loadTexts: tpChassis.setDescription('The trap chassis number.\n        In SSU2000, there are some modules have to inserted in the main chassis: \n        COMM, CLOCK, INPUT, GPS modules. \n        ')
tpSlot = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpSlot.setStatus('current')
if mibBuilder.loadTexts: tpSlot.setDescription('The trap slot number.\n        In SSU2000, there are some modules have to inserted in the fixed locations: \n        COMM - 1A2\n        CLOCK - 1A1 or 1A17 (physical slot address)\n        GPS - 1A3 or 1A5.\n        ')
tpPort = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpPort.setStatus('current')
if mibBuilder.loadTexts: tpPort.setDescription("The trap port number.\n        If value 0, it means (DON'T CARE) whole module.\n        In SSU2000, most of the DS1/E1 input module alarms specify the port number (1-3). \n        The remaining modules specify the port number as either '0' or '1'.\n        ")
tpAlmCode = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("critical", 3), ("ignore", 4), ("report", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpAlmCode.setStatus('current')
if mibBuilder.loadTexts: tpAlmCode.setDescription('The trap alarm code.\n\n        Relationship between tpAlmCode and tpNtfCode. \n        For example:\n        If for the set MINOR alarm, the tpAlmCode is MINOR and the tpNtfCode is MINOR.\n        If the MINIR alarm is cleared, the tpAlmCode is MINOR and the tpNtfCode is CLEAR.\n\n        For all events:\n        The tpAlmCode and tpNtfCode are REPORT.\n        ')
tpNtfCode = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 6))).clone(namedValues=NamedValues(("minor", 1), ("major", 2), ("critical", 3), ("report", 5), ("clear", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpNtfCode.setStatus('current')
if mibBuilder.loadTexts: tpNtfCode.setDescription('The trap alarm notification code.\n\n        Relationship between tpAlmCode and tpNtfCode. \n        For example for alarms:\n        If for the set MINOR alarm, the tpAlmCode is MINOR and the tpNtfCode is MINOR.\n        If the MINOR alarm is cleared, the tpAlmCode is MINOR and the tpNtfCode is CLEAR.\n\n        For all events:\n        The tpAlmCode and tpNtfCode are REPORT.\n        ')
tpElevated = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpElevated.setStatus('current')
if mibBuilder.loadTexts: tpElevated.setDescription('This alarm if elevated.')
tpDescr = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 51, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tpDescr.setStatus('current')
if mibBuilder.loadTexts: tpDescr.setDescription('The text string description of the event.\n            ')
ssuTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 52, 0))
if mibBuilder.loadTexts: ssuTraps.setStatus('current')
if mibBuilder.loadTexts: ssuTraps.setDescription('The SSU2000 traps')
ssuEvent = NotificationType((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 52, 0, 1)).setObjects(("SSU2000-MIB", "tpTag"), ("SSU2000-MIB", "tpEvt"), ("SSU2000-MIB", "tpId"), ("SSU2000-MIB", "tpMCode"), ("SSU2000-MIB", "tpTimestamp"), ("SSU2000-MIB", "tpChassis"), ("SSU2000-MIB", "tpSlot"), ("SSU2000-MIB", "tpPort"), ("SSU2000-MIB", "tpAlmCode"), ("SSU2000-MIB", "tpNtfCode"), ("SSU2000-MIB", "tpElevated"), ("SSU2000-MIB", "tpDescr"))
if mibBuilder.loadTexts: ssuEvent.setStatus('current')
if mibBuilder.loadTexts: ssuEvent.setDescription('SSU2000 trap object which specifies trap tag number, trap id number, module hex code, timestamp, chassis number, \n        slot number, port number, alarm code, alarm notification code, and the text string description.\n        ')
sifNtpNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifNtpNumber.setStatus('current')
if mibBuilder.loadTexts: sifNtpNumber.setDescription('0 = if no NTP resource present \n         1 = if NTP presentt \n        ')
sifSnmpv2Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifSnmpv2Number.setStatus('current')
if mibBuilder.loadTexts: sifSnmpv2Number.setDescription('0 = if no SNMPv2 resource present (note: it is load resource, not enable/disable)\n         1 = if SNMPv2 present\n        ')
sifSnmpv3Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifSnmpv3Number.setStatus('current')
if mibBuilder.loadTexts: sifSnmpv3Number.setDescription('0 = if no SNMPv3 resource present (note: it is load resource, not enable/disable)\n         1 = if SNMPv3 present\n        ')
sifClkNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifClkNumber.setStatus('current')
if mibBuilder.loadTexts: sifClkNumber.setDescription('0 = if no Clock Module present \n         x = number of Clock Modules present \n        ')
sifGpsNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifGpsNumber.setStatus('current')
if mibBuilder.loadTexts: sifGpsNumber.setDescription('0 = if no GPS Module present \n         x = number of GPS Modules present \n        ')
sifInpDs1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifInpDs1Number.setStatus('current')
if mibBuilder.loadTexts: sifInpDs1Number.setDescription('0 = if no DS1 Input Module present \n         x = number of DS1 Input Modules present \n        ')
sifInpE1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifInpE1Number.setStatus('current')
if mibBuilder.loadTexts: sifInpE1Number.setDescription('0 = if no E1 Input Module present \n         x = number of E1 Input Modules present \n        ')
sifInpCcNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifInpCcNumber.setStatus('current')
if mibBuilder.loadTexts: sifInpCcNumber.setDescription('0 = if no ANSI CC Input Module present \n         x = number of ANSI CC Input Modules present \n        ')
sifOutDs1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutDs1Number.setStatus('current')
if mibBuilder.loadTexts: sifOutDs1Number.setDescription('0 = if no DS1 Output Module present \n         x = number of DS1 Output Modules present \n        ')
sifOutE1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutE1Number.setStatus('current')
if mibBuilder.loadTexts: sifOutE1Number.setDescription('0 = if no E1 Output Module present \n         x = number of E1 Output Modules present \n        ')
sifOut2048Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOut2048Number.setStatus('current')
if mibBuilder.loadTexts: sifOut2048Number.setDescription('0 = if no 2048 Output Module present \n         x = number of 2048 Output Modules present \n        ')
sifOutCcNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutCcNumber.setStatus('current')
if mibBuilder.loadTexts: sifOutCcNumber.setDescription('0 = if no ANSI CC Output Module present \n         x = number of ANSI CC Output Modules present \n        ')
sifOutE12048Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutE12048Number.setStatus('current')
if mibBuilder.loadTexts: sifOutE12048Number.setDescription('0 = if no E1/2048KHZ Output Module present \n         x = number of E1/2048KHZ Output Modules present \n        ')
sifOut422Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOut422Number.setStatus('current')
if mibBuilder.loadTexts: sifOut422Number.setDescription('0 = if no RS422 Output Module present \n         x = number of RS422 Output Modules present \n        ')
sifLrmDs1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifLrmDs1Number.setStatus('current')
if mibBuilder.loadTexts: sifLrmDs1Number.setDescription('0 = if no DS1 LRM Module present \n         x = number of DS1 LRM Modules present \n        ')
sifOutJsineNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutJsineNumber.setStatus('current')
if mibBuilder.loadTexts: sifOutJsineNumber.setDescription('0 = if no Japanese Sine (J/SW) Output Module present \n         x = number of Sine (J/SW) Output Modules present \n        ')
sifInpJsineNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifInpJsineNumber.setStatus('current')
if mibBuilder.loadTexts: sifInpJsineNumber.setDescription('0 = if no Japanese Sine (J/SW) Input Module present \n         x = number of Sine (J/SW) Input Modules present \n        ')
sifOutJccNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifOutJccNumber.setStatus('current')
if mibBuilder.loadTexts: sifOutJccNumber.setDescription('0 = if no Japanese CC (J/CC) Output Module present \n         x = number of Japanese CC (J/CC) Output Modules present \n        ')
sifInpJccNumber = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifInpJccNumber.setStatus('current')
if mibBuilder.loadTexts: sifInpJccNumber.setDescription('0 = if no Japanese CC (J/CC) Input Module present \n         x = number of Japanese CC (J/CC) Input Modules present \n        ')
sifLrmE1Number = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 60, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sifLrmE1Number.setStatus('current')
if mibBuilder.loadTexts: sifLrmE1Number.setDescription('0 = if no E1 LRM Module present \n         x = number of E1 LRM Modules present \n        ')
staPtPtpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1), )
if mibBuilder.loadTexts: staPtPtpTable.setStatus('current')
if mibBuilder.loadTexts: staPtPtpTable.setDescription('List of PackeTime PTP status information.\n    ')
staPtPtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "staPtPtpChassis"), (0, "SSU2000-MIB", "staPtPtpSlot"))
if mibBuilder.loadTexts: staPtPtpEntry.setStatus('current')
if mibBuilder.loadTexts: staPtPtpEntry.setDescription('The entries of PackeTime PTP status attributes.\n    ')
staPtPtpChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staPtPtpChassis.setStatus('current')
if mibBuilder.loadTexts: staPtPtpChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staPtPtpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staPtPtpSlot.setStatus('current')
if mibBuilder.loadTexts: staPtPtpSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staPtPtpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("disable", 3), ("fault", 4), ("reject", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpStatus.setStatus('current')
if mibBuilder.loadTexts: staPtPtpStatus.setDescription('Reports PackeTime PTP module status.\n        ok(1), -- module is enabled and operating without faults\n        disable(3), -- module is disabled\n        fault(4), -- module is enabled and operating with fault(s)\n        reject(5) -- module type between redundant modules do not agree\n        ')
staPtPtpClkSel = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clka", 1), ("clkb", 2), ("clkc", 3), ("clkd", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpClkSel.setStatus('current')
if mibBuilder.loadTexts: staPtPtpClkSel.setDescription('Reports which clock reference is selected to generate the output reference.\n        clka(1), -- Clock A is selected as the Primary clock\n        clkb(2), -- Clock B is selected as the Primary clock\n        clkc(3), -- Clock C is selected as the Primary clock\n        clkd(4), -- Clock D is selected as the Primary clock\n        none(5) -- no clock is selected\n        ')
staPtPtpClka = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 5), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpClka.setStatus('current')
if mibBuilder.loadTexts: staPtPtpClka.setDescription('Reports that clock A is available.\n        ')
staPtPtpClkb = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 6), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpClkb.setStatus('current')
if mibBuilder.loadTexts: staPtPtpClkb.setDescription('Reports that clock B is available.\n        ')
staPtPtpClkc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 7), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpClkc.setStatus('current')
if mibBuilder.loadTexts: staPtPtpClkc.setDescription('Reports that clock C is available.\n        ')
staPtPtpClkd = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 8), ActiveValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpClkd.setStatus('current')
if mibBuilder.loadTexts: staPtPtpClkd.setDescription('Reports that clock D is available.\n        ')
staPtPtpRednt = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpRednt.setStatus('current')
if mibBuilder.loadTexts: staPtPtpRednt.setDescription('Reports the adjacent slot number if this module is the redundant pair. \n        If this module is not redundant, zero is reported.\n        ')
staPtPtpModState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("stdby", 2), ("fault", 3), ("stdalone", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpModState.setStatus('current')
if mibBuilder.loadTexts: staPtPtpModState.setDescription('Reports the current operational mode.\n        active(1), --If the module is in redundant pair and selected, it shall return active.\n        stdby(2), --If the module is in redundant pair but not selected, it shall return stdby (standby).\n        fault(3), --If the module disabled, it will return fault.\n        stdalone(4) --If the module is not redundant pair, it shall return stdalone (standalone).\n        ')
staPtPtpPAState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("stdby", 2), ("fault", 3), ("stdalone", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpPAState.setStatus('current')
if mibBuilder.loadTexts: staPtPtpPAState.setDescription('Reports the current operational mode.\n        active(1), --If service ports are bonded and selected, it shall return active.\n        stdby(2), --If service ports are bonded but not selected, it shall return stdby (standby).\n        fault(3), --Service port is faulted.\n        stdalone(4) --If service ports are not bonded , it shall return stdalone (standalone).\n        ')
staPtPtpTod = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 12), OnValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpTod.setStatus('current')
if mibBuilder.loadTexts: staPtPtpTod.setDescription('Reports if the PTP Time of Day is valid or invalid.\n        ')
staPtPtpCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("done", 1), ("prog", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staPtPtpCommit.setStatus('current')
if mibBuilder.loadTexts: staPtPtpCommit.setDescription('Reports the Commit command status.\n        1 = done\n        2 = in progress\n        ')
ptpDfltDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2), )
if mibBuilder.loadTexts: ptpDfltDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetTable.setDescription('List of the PackeTime PTP Management Messages: ptpDefaultDataSet\n    ')
ptpDfltDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "ptpDfltDataSetChassis"), (0, "SSU2000-MIB", "ptpDfltDataSetSlot"))
if mibBuilder.loadTexts: ptpDfltDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetEntry.setDescription('The entries of PackeTime PTP Management Messages: ptpDefaultDataSet attributes.\n    ')
ptpDfltDataSetChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ptpDfltDataSetChassis.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpDfltDataSetSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ptpDfltDataSetSlot.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpDfltDataSetClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetClockId.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetClockId.setDescription('Reports the PTP Clock Identity (64-bit value). \n        The clock id is a hexadecimal format. \n        ')
ptpDfltDataSetClockClass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetClockClass.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetClockClass.setDescription('Reports the PTP Master Clock Class\n        ')
ptpDfltDataSetClockAccuracy = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))).clone(namedValues=NamedValues(("within25ns", 32), ("within100ns", 33), ("within250ns", 34), ("within1000ns", 35), ("within2p5us", 36), ("within10us", 37), ("within25us", 38), ("within100us", 39), ("within250us", 40), ("within1ms", 41), ("within2p5ms", 42), ("within10ms", 43), ("within25ms", 44), ("within100ms", 45), ("within250ms", 46), ("within1sec", 47), ("within10sec", 48), ("beyond10sec", 49), ("unknown", 254)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetClockAccuracy.setDescription('Reports the PTP Master Clock Accuracy\n        Following is the Clock Accuracy Table\n        32 = within 25   ns\n        33 = within 100  ns\n        34 = within 250  ns\n        35 = within 1000 ns\n        36 = within 2.5  us\n        37 = within 10   us\n        38 = within 25   us\n        39 = within 100  us\n        40 = within 250  us\n        41 = within 1    ms \n        42 = within 2.5  ms\n        43 = within 10   ms\n        44 = within 25   ms\n        45 = within 100  ms\n        46 = within 250  ms\n        47 = within 1    sec\n        48 = within 10   sec\n        49 = beyond 10   sec\n        254 = unknown       \n        ')
ptpDfltDataSetTimeTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 6), TrueValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetTimeTraceable.setDescription('Reports the PTP Master Time Traceability\n        1 = true, time traceable\n        2 = false, time not traceable\n        ')
ptpDfltDataSetFreqTraceable = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 7), TrueValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetFreqTraceable.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetFreqTraceable.setDescription('Reports the PTP Master Frequency Traceability\n        1 = true, frequency traceable\n        2 = false, frequency not traceable\n        ')
ptpDfltDataSetDomainNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpDfltDataSetDomainNumber.setStatus('current')
if mibBuilder.loadTexts: ptpDfltDataSetDomainNumber.setDescription('Reports the PTP domain number. \n        ')
ptpClockDescrTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3), )
if mibBuilder.loadTexts: ptpClockDescrTable.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrTable.setDescription('List of the PackeTime PTP Management Messages: ptpClockDescription.\n    ')
ptpClockDescrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "ptpClockDescrChassis"), (0, "SSU2000-MIB", "ptpClockDescrSlot"))
if mibBuilder.loadTexts: ptpClockDescrEntry.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrEntry.setDescription('Entries of the PackeTime PTP Management Messages: ptpClockDescription attributes.\n    ')
ptpClockDescrChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ptpClockDescrChassis.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpClockDescrSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ptpClockDescrSlot.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpClockDescrClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32768))).clone(namedValues=NamedValues(("ordinary", 32768)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDescrClockType.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrClockType.setDescription('Reports the PTP Clock Type\n        The value 0x8000 meant Ordinary Clock\n        ')
ptpClockDescrProtocolAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDescrProtocolAddress.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrProtocolAddress.setDescription('Reports the PTP IP Address of PTP port.            \n        ')
ptpClockDescrManufacturerId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDescrManufacturerId.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrManufacturerId.setDescription('Reports the PTP Manufacturer Id. \n        The format is a 3 bytes array.\n        The Manufacturer Id is 00 B0 AE\n        ')
ptpClockDescrProfileId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpClockDescrProfileId.setStatus('current')
if mibBuilder.loadTexts: ptpClockDescrProfileId.setDescription('Reports the PTP Profile ID. \n        The format is 6 bytes array.\n\t\tIf Telecom-2008, the profile_id is: 00 00 00 00 00 00\n\t\tIf ITU G8265.1,  the profile_id is: 00 19 A7 00 01 00\t\n        ')
ptpTimeMessageTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4), )
if mibBuilder.loadTexts: ptpTimeMessageTable.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageTable.setDescription('List of the PackeTime PTP Management Messages: ptpTimeMessage.\n    ')
ptpTimeMessageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4, 1), ).setIndexNames((0, "SSU2000-MIB", "ptpTimeMessageChassis"), (0, "SSU2000-MIB", "ptpTimeMessageSlot"))
if mibBuilder.loadTexts: ptpTimeMessageEntry.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageEntry.setDescription('The entries of PackeTime PTP Management Messages: ptpTimeMessage attributes\n    ')
ptpTimeMessageChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ptpTimeMessageChassis.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpTimeMessageSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ptpTimeMessageSlot.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpTimeMessageCurrentTimeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeMessageCurrentTimeSec.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageCurrentTimeSec.setDescription('Reports the PTP Current Time of seconds. \n        The current is a 6-byte a hexadecimal format.\n        ')
ptpTimeMessageCurrentTimeNSec = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpTimeMessageCurrentTimeNSec.setStatus('current')
if mibBuilder.loadTexts: ptpTimeMessageCurrentTimeNSec.setDescription('Reports the PTP fractional Current Time of nanoseconds\n        ')
ptpPortDataSetTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5), )
if mibBuilder.loadTexts: ptpPortDataSetTable.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetTable.setDescription('List of the PackeTime PTP Management Messages: ptpPortDataSet\n    ')
ptpPortDataSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1), ).setIndexNames((0, "SSU2000-MIB", "ptpPortDataSetChassis"), (0, "SSU2000-MIB", "ptpPortDataSetSlot"))
if mibBuilder.loadTexts: ptpPortDataSetEntry.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetEntry.setDescription('The entries of PackeTime PTP Management Messages: ptpPortDataSet attributes\n    ')
ptpPortDataSetChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ptpPortDataSetChassis.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpPortDataSetSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ptpPortDataSetSlot.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
ptpPortDataSetClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortDataSetClockId.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetClockId.setDescription('Reports the PTP Clock Identity (64-bit value). \n        The port clock id is a hexadecimal format. \n        ')
ptpPortDataSetPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortDataSetPortNumber.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetPortNumber.setDescription('Reports the PTP Port Number\n        ')
ptpPortDataSetPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 16, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notdefined", 0), ("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("premaster", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpPortDataSetPortState.setStatus('current')
if mibBuilder.loadTexts: ptpPortDataSetPortState.setDescription('Reports the PTP Port State\n        Following is the PTP Port State Table\n        \t0 = notdefined \n\t    \t1 = initializing\n\t    \t2 = faulty\n\t   \t3 = disabled\n\t    \t4 = listening\n\t    \t5 = premaster, it is a state before becoming a Master\n\t    \t6 = master\n\t    \t7 = passive\n\t    \t8 = uncalibrated \n\t    \t9 = slave\n        ')
setPtPtpTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1), )
if mibBuilder.loadTexts: setPtPtpTable.setStatus('current')
if mibBuilder.loadTexts: setPtPtpTable.setDescription('A list of PackeTime PTP status and settings.\n        ')
setPtPtpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtPtpChassis"), (0, "SSU2000-MIB", "setPtPtpSlot"))
if mibBuilder.loadTexts: setPtPtpEntry.setStatus('current')
if mibBuilder.loadTexts: setPtPtpEntry.setDescription('The enties of the PackeTime PTP settings and attributes.\n    ')
setPtPtpChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtPtpChassis.setStatus('current')
if mibBuilder.loadTexts: setPtPtpChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setPtPtpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtPtpSlot.setStatus('current')
if mibBuilder.loadTexts: setPtPtpSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setPtPtpCommit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpCommit.setStatus('current')
if mibBuilder.loadTexts: setPtPtpCommit.setDescription('Commit all provisioned parameters, this action makes the parameters active. \n        This command will also store the parameters to non-volatile memory.\n\n        Note: This field only has meaning for a writing (1).\n        ')
setPtPtpService = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpService.setStatus('current')
if mibBuilder.loadTexts: setPtPtpService.setDescription('Set the PTP service (daemon) to enable or disable. \n        This command is applied to both modules if redundant cards installed.\n\n        1 = Enabled  \n        2 = Disabled\n        ')
setPtPtpClockId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpClockId.setStatus('current')
if mibBuilder.loadTexts: setPtPtpClockId.setDescription('Set the clockId is the PTP Port Clock Identity (64-bit value). \n        The clockid is a hexadecimal format. \n\n        Note: users shall enter command COMMIT to take changes into effect      \n        ')
setPtPtpDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpDomain.setStatus('current')
if mibBuilder.loadTexts: setPtPtpDomain.setDescription('Set the PTP port domain. \n        Note: users shall enter command COMMIT to take changes into effect      \n        ')
setPtPtpTimescale = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptp", 1), ("arb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpTimescale.setStatus('current')
if mibBuilder.loadTexts: setPtPtpTimescale.setDescription("Set timescale to 'PTP' or 'ARB'. \n        Note: users shall enter command COMMIT to take changes into effect      \n        ")
setPtPtpSyncLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpSyncLimit.setStatus('current')
if mibBuilder.loadTexts: setPtPtpSyncLimit.setDescription('Set the unicast Sync message rate  (2^y). \n        The range of the rate value is {-7 to 7}. \n        For example, the configurable range is  -7, means 128 per second\n        ')
setPtPtpAnnounceLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpAnnounceLimit.setStatus('current')
if mibBuilder.loadTexts: setPtPtpAnnounceLimit.setDescription('Set unicast announce message rate  (2^y). \n        The range of the rate value is {-3 to 4}. \n        For example, the configurable range is  -3, means 8 per second\n        ')
setPtPtpDelayLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-7, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpDelayLimit.setStatus('current')
if mibBuilder.loadTexts: setPtPtpDelayLimit.setDescription('Set unicast delay resp message rate  (2^y). \n        The range of the rate value is {-7 to 7}. \n        For example, the configurable range is  -6, means 64 per second\n        ')
setPtPtpDscpState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 11), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpDscpState.setStatus('current')
if mibBuilder.loadTexts: setPtPtpDscpState.setDescription('Set the DSCP state to enable or disable.\n        ')
setPtPtpDscpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpDscpValue.setStatus('current')
if mibBuilder.loadTexts: setPtPtpDscpValue.setDescription('Set DSCP value.\n        ')
setPtPtpMaxClient = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpMaxClient.setStatus('current')
if mibBuilder.loadTexts: setPtPtpMaxClient.setDescription('Set the PTP max clients.\n        ')
setPtPtpPortPriority1 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpPortPriority1.setStatus('current')
if mibBuilder.loadTexts: setPtPtpPortPriority1.setDescription('Set the PTP Port Priority 1 {0 to 255}.\n        ')
setPtPtpPortPriority2 = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpPortPriority2.setStatus('current')
if mibBuilder.loadTexts: setPtPtpPortPriority2.setDescription('Set the PTP Port Priority 2 {0 to 255}.\n        ')
setPtPtpUniLeaseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpUniLeaseDuration.setStatus('current')
if mibBuilder.loadTexts: setPtPtpUniLeaseDuration.setDescription('Set the PTP Max Dynamic Unicast Lease Interval, {10 to 1000}\n        ')
setPtPtpUniNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 17), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpUniNegotiation.setStatus('current')
if mibBuilder.loadTexts: setPtPtpUniNegotiation.setDescription('Set the PTP Unicast Negotiation state: Enable or Disable\n        ')
setPtPtpTwostep = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 18), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpTwostep.setStatus('current')
if mibBuilder.loadTexts: setPtPtpTwostep.setDescription('Set the PTP Two-Step clock state: Enable or Disable\n        Note: users shall enter command COMMIT to take changes into effect      \n        ')
setPtPtpProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("telecom2008", 1), ("ituG8265dot1", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpProfile.setStatus('current')
if mibBuilder.loadTexts: setPtPtpProfile.setDescription('Set PTP profile telecom_2008 or itu_g8265_1. \n        Note: users shall enter command COMMIT to take changes into effect      \n        ')
setPtPtpSsmOption = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("option1", 1), ("option2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpSsmOption.setStatus('current')
if mibBuilder.loadTexts: setPtPtpSsmOption.setDescription('Set PTP ssm-option in Option 1 or Option 2. \n        ')
setPtPtpBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 30), OnValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpBypass.setStatus('current')
if mibBuilder.loadTexts: setPtPtpBypass.setDescription('Set the clock C state, or bypass clock, to enabled or disabled.\n        ')
setPtPtpModActive = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 31), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpModActive.setStatus('current')
if mibBuilder.loadTexts: setPtPtpModActive.setDescription("Set the specified module in the redundant pair to be Active. \n        Note1: This command only applies when the module in the redundant pair.\n        Note2: This field only has meaning for a writing (1).\n        Note3: Don't apply COMMIT after this command.\n        ")
setPtPtpEthRate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("all", 0), ("r100", 1), ("r1000", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpEthRate.setStatus('current')
if mibBuilder.loadTexts: setPtPtpEthRate.setDescription('Set the PTP port transmission rate.\n        all -  means auto negotiation capable of both 100M and 1000Mbits/s rate. \n        r100 - means auto negotiation capable of only 100Mbit/s rate.\n        r1000 - means auto negotiation capable of only 1000Mbit/s rate\n\n        Note: this setting is only applied to the copper SFP, not fiber. \n        If fiber SFP installed, this setting is ignored.\n        ')
setPtPtpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 33), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpVlan.setStatus('current')
if mibBuilder.loadTexts: setPtPtpVlan.setDescription('Set the VLAN state.\n        1 = Enabled  \n        2 = Disabled\n\n        Users must COMMIT for changes into effect.          \n        ')
setPtPtpRmvClient = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 1, 1, 34), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtPtpRmvClient.setStatus('current')
if mibBuilder.loadTexts: setPtPtpRmvClient.setDescription('This is an action command and not a configuration command.\n        This command remove a client from a ptp client list. \n        The clockid is a hexadecimal format. \n\n        Note: this field only has meansing for write action with proper clock id.\n        When it read, it always returns as all zero octet string.      \n        ')
setPtpPortTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2), )
if mibBuilder.loadTexts: setPtpPortTable.setStatus('current')
if mibBuilder.loadTexts: setPtpPortTable.setDescription('Set PackeTime PTP ethernet port information.\n          ')
setPtpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtpPortChassis"), (0, "SSU2000-MIB", "setPtpPortSlot"), (0, "SSU2000-MIB", "setPtpPortNum"))
if mibBuilder.loadTexts: setPtpPortEntry.setStatus('current')
if mibBuilder.loadTexts: setPtpPortEntry.setDescription('PackeTime PTP ethernet port state and settings information.\n    setPtPtpPortChassis\n        Identifies which chassis is being addressed. \n    setPtPtpPortSlot\n        Identifies which slot is being addressed. \n    setPtPtpPortNum\n        Identifies which port is being addressed. \n    setPtPtpPortAddr\n        Set the port IP address         \n    setPtPtpPortMask\n        Set the port network mask           \n    setPtPtpPortGate\n        Set the port gateway address            \n    ')
setPtpPortChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtpPortChassis.setStatus('current')
if mibBuilder.loadTexts: setPtpPortChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n        ')
setPtpPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtpPortSlot.setStatus('current')
if mibBuilder.loadTexts: setPtpPortSlot.setDescription('Identifies which slot is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n        ')
setPtpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: setPtpPortNum.setStatus('current')
if mibBuilder.loadTexts: setPtpPortNum.setDescription('Identifies which port is being addressed. \n        This chassis, slot, and port number uniquely identify each entry.\n\n        PTPTP ethernet interface number. \n        1 = Service Port A \n        2 = Maintenance Port\n        ')
setPtpPortAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpPortAddr.setStatus('current')
if mibBuilder.loadTexts: setPtpPortAddr.setDescription('Set the port IP address            \n        ')
setPtpPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpPortMask.setStatus('current')
if mibBuilder.loadTexts: setPtpPortMask.setDescription('Set the port network mask          \n        ')
setPtpPortGate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpPortGate.setStatus('current')
if mibBuilder.loadTexts: setPtpPortGate.setDescription('Set the port gateway address           \n        ')
setPtpVlanTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3), )
if mibBuilder.loadTexts: setPtpVlanTable.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanTable.setDescription('List of PackeTime PTP vlan attributes.\n    The Virtural Local Area Network is implemented per IEEE 802.1Q.\n        ')
setPtpVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1), ).setIndexNames((0, "SSU2000-MIB", "setPtpVlanChassis"), (0, "SSU2000-MIB", "setPtpVlanSlot"), (0, "SSU2000-MIB", "setPtpVlanIndex"))
if mibBuilder.loadTexts: setPtpVlanEntry.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanEntry.setDescription('A PackeTime PTP vlan attributes and settings:\n    setPtPtpVlanChassis\n        Identifies which chassis is being addressed. \n    setPtPtpVlanSlot\n        Identifies which slot is being addressed. \n    setPtpVlanIndex\n        Set the VLAN index number for PTPTP.\n    setPtpVlanState\n        Enable or Disable of a given VLAN Entry \n    setPtpVlanAddr\n        VLAN IP Address (If 0.0.0.0, and then SET, this will delete this entry)\n\t\tnote: This field has to set first with a valid non-zero IP address, if you want to add a new entry\n    setPtpVlanMask\n        VLAN Network Mask\n    setPtpVlanGate\n        VLAN Gateway\n    setPtpVlanId\n        VLAN ID\n    setPtpVlanPriority\n        VLAN Priority\n\tNote: The module setPtPtpVlan set must be enabled, and each of the enabled entires \n\thas meaning.\n    ')
setPtpVlanChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setPtpVlanChassis.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis and slot number uniquely identify each entry.\n        ')
setPtpVlanSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setPtpVlanSlot.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanSlot.setDescription('Identifies which slot is being addressed. \n            This chassis and slot number uniquely identify each entry.\n            ')
setPtpVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: setPtpVlanIndex.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanIndex.setDescription('Set the VLAN index number for PTP. \n        ')
setPtpVlanState = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanState.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanState.setDescription('Enable or Disable of a given VLAN entry \n        Note: The value has meaning, only when the VLAN is enabled\n        ')
setPtpVlanAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanAddr.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanAddr.setDescription('Ethernet VLAN Port IP Address\n        Note: you must have IP address in order to add or change other fields.\n        This field has to set first with a valid non-zero IP address, if you want to add a new entry         \n        If the IP is 0.0.0.0, and use the SET operation, this mean delete this entry. \n        ')
setPtpVlanMask = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanMask.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanMask.setDescription('Ethernet VLAN Port Network Mask            \n        ')
setPtpVlanGate = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanGate.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanGate.setDescription('Ethernet VLAN Port Gateway Address         \n        ')
setPtpVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanId.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanId.setDescription('Set the VLAN ID (2..4094) for Service Port A \n        Note: The value has meaning, only when the VLAN is enabled\n        ')
setPtpVlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 23, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setPtpVlanPriority.setStatus('current')
if mibBuilder.loadTexts: setPtpVlanPriority.setDescription('VLAN Priority (0..7) for Service Port A \n        Note: The value has meaning, only when the VLAN is enabled\n        ')
ptpclientTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 1), )
if mibBuilder.loadTexts: ptpclientTable.setStatus('current')
if mibBuilder.loadTexts: ptpclientTable.setDescription('Reports PackeTime PTP client list entries.\n\n    Usage: you need to specify a PTP blade address in ptpclientParmLoc, and\n    then execute the command ptpclientCmdXeq first. The PTP client list will be\n    saved. This ptpclientTable will display all the PTP client list contents \n    of this saved information.\n      ')
ptpclientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "ptpclientChassis"), (0, "SSU2000-MIB", "ptpclientSlot"))
if mibBuilder.loadTexts: ptpclientEntry.setStatus('current')
if mibBuilder.loadTexts: ptpclientEntry.setDescription('Reports PackeTime PTP client list containing each PTP client status value.\n    ptpclientChassis\n        Identifies which chassis is being addressed. \n    ptpclientSlot\n        Identifies which slot is being addressed. \n    ptpclientData\n        Reports the contents of the Client data TLV:\n    ')
ptpclientChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: ptpclientChassis.setStatus('current')
if mibBuilder.loadTexts: ptpclientChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis and slot number uniquely identify each entry.\n        ')
ptpclientSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: ptpclientSlot.setStatus('current')
if mibBuilder.loadTexts: ptpclientSlot.setDescription('Identifies which slot is being addressed. \n        This chassis and slot number uniquely identify each entry.\n        ')
ptpclientData = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ptpclientData.setStatus('current')
if mibBuilder.loadTexts: ptpclientData.setDescription('Reports the contents of the Client data TLV:\n        INTEGER - mode, 0:dynamic, 1:static\n        INTEGER - ip address\n        OCTET - clock id\n        INTEGER -  VLAN ID, if 0xffff, then there is no vlan\n        INTEGER -  VLAN Priority\n        INTEGER -  Sync Limit (signed value), if 99, the disable\n        INTEGER -  Announce Limit (signed value), if 99, the disable\n        INTEGER -  Delay Limit (signed value), if 99, the disable\n        ')
ptpclientParmLoc = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpclientParmLoc.setStatus('current')
if mibBuilder.loadTexts: ptpclientParmLoc.setDescription("Set the ports VLAN address.\n        where\n        x is the chassis number: in this case is 1-5,\n        A is the constant letter 'A', and is chassis/slot sepearator.\n        y is the slot number: (range is 1 to 14)\n\n        For example: 1A6 means this port located at chassis 1, slot 6\n\n        Note: the user must specify valid PTP address.\n        The valid port must be physically installed in the system.\n        ")
ptpclientCmdXeq = MibScalar((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 36, 3), YesValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ptpclientCmdXeq.setStatus('current')
if mibBuilder.loadTexts: ptpclientCmdXeq.setDescription('Reports the current client list in the module. \n        The max number of client is 400\n        ')
staSynceTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1), )
if mibBuilder.loadTexts: staSynceTable.setStatus('current')
if mibBuilder.loadTexts: staSynceTable.setDescription('List of SyncE status information:\n\tport_direction, ethernet_mode, rx_ssm, and tx_ssm  \n    ')
staSynceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "staSynceChassis"), (0, "SSU2000-MIB", "staSynceSlot"))
if mibBuilder.loadTexts: staSynceEntry.setStatus('current')
if mibBuilder.loadTexts: staSynceEntry.setDescription('The entries of SyncE status attributes.\n    ')
staSynceChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: staSynceChassis.setStatus('current')
if mibBuilder.loadTexts: staSynceChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staSynceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: staSynceSlot.setStatus('current')
if mibBuilder.loadTexts: staSynceSlot.setDescription('Identifies which slot position is being addressed. \n        This chassis number and slot number uniquely identify each inventory entry.\n        ')
staSyncePortDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("input", 1), ("output", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSyncePortDirection.setStatus('current')
if mibBuilder.loadTexts: staSyncePortDirection.setDescription('Reports SyncE Port Direction to be either Output or Input. \n        The output port is a SyncE master port, and input port is a SyncE slave port.\n        ')
staSynceEthernetMode = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("synchronous", 1), ("asynchronous", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSynceEthernetMode.setStatus('current')
if mibBuilder.loadTexts: staSynceEthernetMode.setDescription('Reports SyncE operated on Ethernet to be either synchronous or \n        asynchronous.  It is synchronous mode, when an optical SFP is detected \n        at an Ethernet port. It is an asynchronous mode, when an electrical SFP \n        is detected at an Ethernet port, or there is no SFP detected.\n        ')
staSynceRxSsm = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSynceRxSsm.setStatus('current')
if mibBuilder.loadTexts: staSynceRxSsm.setDescription('Reports SyncE the current rx ssm value (0 .. 15).\n        If 255, SyncE does not receive ESMC messages\n        ')
staSynceTxSsm = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 2, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: staSynceTxSsm.setStatus('current')
if mibBuilder.loadTexts: staSynceTxSsm.setDescription('Reports SyncE the current tx ssm value (0 .. 15).\n        If 255, SyncE does not transmit ESMC messages\n        ')
setSynceTable = MibTable((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1), )
if mibBuilder.loadTexts: setSynceTable.setStatus('current')
if mibBuilder.loadTexts: setSynceTable.setDescription('A list of SyncE settings.\n        ')
setSynceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1), ).setIndexNames((0, "SSU2000-MIB", "setSynceChassis"), (0, "SSU2000-MIB", "setSynceSlot"))
if mibBuilder.loadTexts: setSynceEntry.setStatus('current')
if mibBuilder.loadTexts: setSynceEntry.setDescription('The enties of the SyncE settings and attributes.\n    ')
setSynceChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: setSynceChassis.setStatus('current')
if mibBuilder.loadTexts: setSynceChassis.setDescription('Identifies which chassis is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setSynceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)))
if mibBuilder.loadTexts: setSynceSlot.setStatus('current')
if mibBuilder.loadTexts: setSynceSlot.setDescription('Identifies which slot is being addressed. \n        This chassis number and slot number uniquely identify each entry.\n          ')
setSyncePortDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("input", 1), ("output", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSyncePortDirection.setStatus('current')
if mibBuilder.loadTexts: setSyncePortDirection.setDescription('Set SyncE Port Direction to be either Output or Input. \n        The output port is a SyncE master port, and input port \n        is a SyncE slave port.\n        ')
setSynceEsmc = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 4), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSynceEsmc.setStatus('current')
if mibBuilder.loadTexts: setSynceEsmc.setDescription('Set the Ethernet Synchronization Message Channel (ESMC) \n        state is either Enable or Disable. If ESMC is enabled, \n        the ESMC is used; otherwise, it shall not be used.\n        ')
setSynceQl = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 5), EnaValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSynceQl.setStatus('current')
if mibBuilder.loadTexts: setSynceQl.setDescription('Set the Quality Level (QL, i.e. SSM) in the ESMC is either \n        Enabled or Disabled. If QL is enabled, the SSM in the ESMC \n        is used; otherwise, it shall not be used.\n        ')
setSynceOutQl = MibTableColumn((1, 3, 6, 1, 4, 1, 601, 3, 1, 1, 3, 24, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bidirectional", 1), ("unidirectional", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: setSynceOutQl.setStatus('current')
if mibBuilder.loadTexts: setSynceOutQl.setDescription('Set the Output QL mode is either unidirectional or bidirectional. \n        In the unidirectional mode, the rx ESMC from the downstream NE is \n        ignored. The tx SSM will be determined by the system clock state only. \n        In the bidirectional mode, the rx ESMC from the downstream NE is not \n        ignored but  is used for testing purposes and some interoperability cases.\n        ')
mibBuilder.exportSymbols("SSU2000-MIB", rtGate=rtGate, tpTag=tpTag, setCiProvPql=setCiProvPql, set422oEnable=set422oEnable, staLrmMEntry=staLrmMEntry, setPtNtpPeerPmax=setPtNtpPeerPmax, setMiMtie1000CL2=setMiMtie1000CL2, sifOutCcNumber=sifOutCcNumber, staCiPhaseB=staCiPhaseB, ptpDfltDataSetClockClass=ptpDfltDataSetClockClass, refBypass=refBypass, setJcciEnable=setJcciEnable, statusJccInp=statusJccInp, ptpTimeMessageCurrentTimeNSec=ptpTimeMessageCurrentTimeNSec, setDsZs=setDsZs, statusSineInp=statusSineInp, snmpmanInit=snmpmanInit, setGpsTodsrcCompensation=setGpsTodsrcCompensation, staLOSClCnt=staLOSClCnt, setPtNtpPeerPrefer=setPtNtpPeerPrefer, setJcciZeroPhase=setJcciZeroPhase, staLrme1PSlip=staLrme1PSlip, refClkTodsrc=refClkTodsrc, setCoEntry=setCoEntry, staJcciPhaseA=staJcciPhaseA, setCimEntry=setCimEntry, setE12048oSlot=setE12048oSlot, setAlmLoc=setAlmLoc, setMsiMtie1000EL2=setMsiMtie1000EL2, ntpDelPeer=ntpDelPeer, ntpqRootdispersion=ntpqRootdispersion, setE1Bypass=setE1Bypass, snmpv2userTable=snmpv2userTable, setPtPtpProfile=setPtPtpProfile, staLrmPAis=staLrmPAis, setMsiMtie10CL2=setMsiMtie10CL2, ValidValue=ValidValue, staDiLOS=staDiLOS, setMgMtieStd=setMgMtieStd, setGpsPdop=setGpsPdop, staDiEntry=staDiEntry, setE12048oBypass=setE12048oBypass, almIndex=almIndex, staOtClka=staOtClka, setAlmThDs1E1InpTable=setAlmThDs1E1InpTable, setPtNtpRouteIface=setPtNtpRouteIface, staSineiLOS=staSineiLOS, staGpsFreqB=staGpsFreqB, pqlDs1Ssm=pqlDs1Ssm, staDiPort=staDiPort, setE12048oChassis=setE12048oChassis, setCkChassis=setCkChassis, setMiBPVErrCnt=setMiBPVErrCnt, DateAndTime=DateAndTime, staBPVClCnt=staBPVClCnt, setMiMtie1000EL2=setMiMtie1000EL2, setAlmThGpsInpTable=setAlmThGpsInpTable, setSineiSlot=setSineiSlot, set422oSlot=set422oSlot, giRestart=giRestart, setLrme1PChassis=setLrme1PChassis, staGpsPpsSigma=staGpsPpsSigma, setMsiMtie10000EL2=setMsiMtie10000EL2, mtFrTime=mtFrTime, evIndex=evIndex, setPtpVlanChassis=setPtpVlanChassis, setSineoSlot=setSineoSlot, setPtpVlanTable=setPtpVlanTable, setLrme1PSlip=setLrme1PSlip, setDiPriority=setDiPriority, ptpDfltDataSetTimeTraceable=ptpDfltDataSetTimeTraceable, setAlmThSineInpTable=setAlmThSineInpTable, peerStaDelay=peerStaDelay, setPtPtpSsmOption=setPtPtpSsmOption, mtHisV=mtHisV, setPtpPortAddr=setPtpPortAddr, set422oBypass=set422oBypass, ssu2000=ssu2000, stGpsTkChassis=stGpsTkChassis, staPtNtpRednt=staPtNtpRednt, users=users, phHisEntry=phHisEntry, setLrmPCid=setLrmPCid, ptpTimeMessageTable=ptpTimeMessageTable, setMgFreqAClrLmt=setMgFreqAClrLmt, setCcTable=setCcTable, inFeatureEntry=inFeatureEntry, userlevel=userlevel, ptpDfltDataSetDomainNumber=ptpDfltDataSetDomainNumber, setMgMtie10EL2=setMgMtie10EL2, staCiPhaseA=staCiPhaseA, setSineiPriority=setSineiPriority, phB=phB, pqlE1Ssm=pqlE1Ssm, staLrmPSlot=staLrmPSlot, salEntry=salEntry, setDsSlot=setDsSlot, setPtNtpModActive=setPtNtpModActive, setPtNtpAuthNum=setPtNtpAuthNum, ptpClockDescrProfileId=ptpClockDescrProfileId, staLrme1PEntry=staLrme1PEntry, setPtNtpPeerKeyId=setPtNtpPeerKeyId, rtRef=rtRef, staPtPtpEntry=staPtPtpEntry, setMgMtie10000EL1=setMgMtie10000EL1, alarmTable=alarmTable, phPort=phPort, OnValue=OnValue, sifOutJccNumber=sifOutJccNumber, staLrmMStatus=staLrmMStatus, setMsiMtie100000EL2=setMsiMtie100000EL2, setPtNtpVlanPAPriority=setPtNtpVlanPAPriority, stGpsAvChassis=stGpsAvChassis, whoIndex=whoIndex, setJccoSlot=setJccoSlot, evEntry=evEntry, setE1Enable=setE1Enable, setPtNtpCompensation=setPtNtpCompensation, snmpv3manTable=snmpv3manTable, rtXeq=rtXeq, setCoChassis=setCoChassis, ptpDfltDataSetClockId=ptpDfltDataSetClockId, staJcci400Hz=staJcci400Hz, inventory=inventory, setCoBypass=setCoBypass, phEntry=phEntry, fqSlot=fqSlot, setSineiProvPql=setSineiProvPql, ntpAddClient=ntpAddClient, staSineiSlot=staSineiSlot, ntpqOffset=ntpqOffset, stGpsTkChnl=stGpsTkChnl, peerStaProcessCnt=peerStaProcessCnt, inEntry=inEntry, ptpClockDescrTable=ptpClockDescrTable, tpPort=tpPort, ptpDfltDataSetEntry=ptpDfltDataSetEntry, setCcEntry=setCcEntry, stGpsTrackTable=stGpsTrackTable, rtEntry=rtEntry, setMiEntry=setMiEntry, setPtNtpVlanTable=setPtNtpVlanTable, setPtpPortNum=setPtpPortNum, setPtNtpPeerTimeout=setPtNtpPeerTimeout, staPtNtpClkSel=staPtNtpClkSel, setGpsEngine=setGpsEngine, setCkMinTau=setCkMinTau, set422oFrequency=set422oFrequency, staPtNtpEntry=staPtNtpEntry, msetup=msetup, staOtEntry=staOtEntry, setSineoFrequency=setSineoFrequency, sysKeepAliveTable=sysKeepAliveTable, ph10000B=ph10000B, ntpPeer=ntpPeer, setMiFreqBTau=setMiFreqBTau, sifClkNumber=sifClkNumber, staGpsMStatus=staGpsMStatus, setE1Table=setE1Table, refInpSelection=refInpSelection, sifOut2048Number=sifOut2048Number, sifInpCcNumber=sifInpCcNumber, phHisPort=phHisPort, freq=freq, setSineoTable=setSineoTable, staLrme1PBpvSevErrSecs=staLrme1PBpvSevErrSecs, mtHisEntry=mtHisEntry, setCimChassis=setCimChassis, setPtPtpDscpValue=setPtPtpDscpValue, ssuEvent=ssuEvent, staCiPort=staCiPort, setMiMtie100000CL1=setMiMtie100000CL1, fqA=fqA, statusSynce=statusSynce, inHwPart=inHwPart, staCcInpTable=staCcInpTable, setE1Zs=setE1Zs, staLrmPFrame=staLrmPFrame, setMiAISClrCnt=setMiAISClrCnt, giEntry=giEntry, mtHisCnt=mtHisCnt, setMsiFreqATau=setMsiFreqATau, staOtRednt=staOtRednt, snmpv2manEntry=snmpv2manEntry, setCiEntry=setCiEntry, setMgMtie1000EL1=setMgMtie1000EL1, TLatAndLon=TLatAndLon, comTimeout=comTimeout, ptpclientSlot=ptpclientSlot, salIndex=salIndex, sifOut422Number=sifOut422Number, setMiOOFClrCnt=setMiOOFClrCnt, staLrmMSlot=staLrmMSlot, setMsiMtie10CL1=setMsiMtie10CL1, almSlot=almSlot, refClk=refClk, snmpv2user=snmpv2user, ntpSysPeer=ntpSysPeer, staCiStatus=staCiStatus, setMiMtie100EL2=setMiMtie100EL2, setMsiMtie1000CL2=setMsiMtie1000CL2, ptpclientChassis=ptpclientChassis, staCiLOSErCnt=staCiLOSErCnt, salPort=salPort, staGpsUtc=staGpsUtc, setDsEntry=setDsEntry, setLrme1PEntry=setLrme1PEntry, mtPort=mtPort, phaseTable=phaseTable, setupCCOut=setupCCOut, event=event, setMgMtie100CL1=setMgMtie100CL1, setMiMtie10000EL2=setMiMtie10000EL2, setMiMtie10000CL2=setMiMtie10000CL2, setPtNtpEntry=setPtNtpEntry, setMgFreqBTau=setMgFreqBTau, setCiPriority=setCiPriority, eventTable=eventTable, staPtPtpClkSel=staPtPtpClkSel, staJcciChassis=staJcciChassis, comEol=comEol, staDiCRC=staDiCRC, ntpqSysprecision=ntpqSysprecision, setMsiMtie10000CL1=setMsiMtie10000CL1, setMsiFreqBTau=setMsiFreqBTau, phHisSlot=phHisSlot, setSineiChassis=setSineiChassis, tdFrTime=tdFrTime, stGpsPosLon=stGpsPosLon, setDsLength=setDsLength, staDiMtie1B=staDiMtie1B, setJcciEntry=setJcciEntry, ntpqRootdelay=ntpqRootdelay, setPtpPortMask=setPtpPortMask, setMsiMtie10EL1=setMsiMtie10EL1, staDiMtie2A=staDiMtie2A, setDiEntry=setDiEntry, setDiGain=setDiGain, setupJccOut=setupJccOut, pqlDs1Index=pqlDs1Index, tdHisInpLoc=tdHisInpLoc, setMgMtie10000CL2=setMgMtie10000CL2, statusGps=statusGps, tpElevated=tpElevated, setDsBypass=setDsBypass, staPtPtpTod=staPtPtpTod, setPtPtpAnnounceLimit=setPtPtpAnnounceLimit, staSineiMtie1B=staSineiMtie1B, setMiFreqAClrLmt=setMiFreqAClrLmt, mtHisPort=mtHisPort, ntpMode=ntpMode, staPtPtpClkd=staPtPtpClkd, stGpsPosHgt=stGpsPosHgt, setMiMtie10CL1=setMiMtie10CL1)
mibBuilder.exportSymbols("SSU2000-MIB", sifInpDs1Number=sifInpDs1Number, setDiZS=setDiZS, tdHisClk=tdHisClk, setSynceEntry=setSynceEntry, setDiChassis=setDiChassis, setPtNtpRouteMask=setPtNtpRouteMask, tdHisCnt=tdHisCnt, pqlTable=pqlTable, peerStaPrecision=peerStaPrecision, snmpv3manIp=snmpv3manIp, staJcciSlot=staJcciSlot, YesValue=YesValue, ph100A=ph100A, pqlReset=pqlReset, whoTable=whoTable, mtHisChassis=mtHisChassis, ph1000B=ph1000B, setGpsChassis=setGpsChassis, staLrmMTable=staLrmMTable, setPtNtpPortNum=setPtNtpPortNum, ptpclientCmdXeq=ptpclientCmdXeq, statusPtNtp=statusPtNtp, setGpsHgt=setGpsHgt, sysAliveTime=sysAliveTime, ntpqDelay=ntpqDelay, statusOut=statusOut, setMiMtieStd=setMiMtieStd, stGpsAvSlot=stGpsAvSlot, ptpTimeMessageSlot=ptpTimeMessageSlot, mtB=mtB, rtDest=rtDest, staCiBPVClCnt=staCiBPVClCnt, sifOutJsineNumber=sifOutJsineNumber, setMiOOFErrCnt=setMiOOFErrCnt, setCimPort=setCimPort, setPtNtpAuthKeyId=setPtNtpAuthKeyId, staGpsMtie1B=staGpsMtie1B, staDiMtie2B=staDiMtie2B, phSlot=phSlot, setPtpPortSlot=setPtpPortSlot, fqPort=fqPort, staLrme1PAis=staLrme1PAis, setLrme1PTable=setLrme1PTable, setMgMtie10EL1=setMgMtie10EL1, route=route, ph10000A=ph10000A, setMiMtie100000EL2=setMiMtie100000EL2, setDiSlot=setDiSlot, sifLrmE1Number=sifLrmE1Number, setMsiPort=setMsiPort, staDiChassis=staDiChassis, setCmInfo=setCmInfo, setJccoChassis=setJccoChassis, tdHisTable=tdHisTable, setPtPtpModActive=setPtPtpModActive, staPtNtpCommit=staPtNtpCommit, setMiMtie100000CL2=setMiMtie100000CL2, snmpv2userEntry=snmpv2userEntry, staDiPhaseB=staDiPhaseB, setPtNtpPortTable=setPtNtpPortTable, setJccoBypass=setJccoBypass, inAction=inAction, staDiPql=staDiPql, TSsm=TSsm, staPtNtpTod=staPtNtpTod, setDiMtieCalc=setDiMtieCalc, setE1Slot=setE1Slot, setPtNtpPeerNum=setPtNtpPeerNum, setE12048oSquelch=setE12048oSquelch, setPtpVlanPriority=setPtpVlanPriority, setLrmPLbo=setLrmPLbo, setE12048oSignal=setE12048oSignal, staLrme1PBpvErrSecs=staLrme1PBpvErrSecs, setSineoSquelch=setSineoSquelch, freqTable=freqTable, username=username, ptpClockDescrEntry=ptpClockDescrEntry, setGpsLat=setGpsLat, setupE1Out=setupE1Out, ntpqSlot=ntpqSlot, tdToTime=tdToTime, setSineInpTable=setSineInpTable, pqlDs1Descr=pqlDs1Descr, tdB=tdB, ntpqStratum=ntpqStratum, sysAliveType=sysAliveType, setJccoComp=setJccoComp, setE12048oEnable=setE12048oEnable, rtChassis=rtChassis, mtInpLoc=mtInpLoc, setPtNtpPBActive=setPtNtpPBActive, staPtPtpModState=staPtPtpModState, tpEvt=tpEvt, phHisCnt=phHisCnt, setGpsProvPql=setGpsProvPql, staLrme1PLosSide2=staLrme1PLosSide2, setCimBPVClrCnt=setCimBPVClrCnt, inSlot=inSlot, setE12048oZs=setE12048oZs, setCkTodTimeout=setCkTodTimeout, setE12048oEntry=setE12048oEntry, sifNtpNumber=sifNtpNumber, stGpsPosAccurate=stGpsPosAccurate, stGpsTkStatus=stGpsTkStatus, setDiPort=setDiPort, staOtClkb=staOtClkb, ionSlot=ionSlot, staSineiMStatus=staSineiMStatus, staDiPqlRcv=staDiPqlRcv, staCRCClCnt=staCRCClCnt, setupE12048Out=setupE12048Out, tdSlot=tdSlot, tpMCode=tpMCode, setupSynce=setupSynce, phHisInpLoc=phHisInpLoc, setPtNtpPeerSlot=setPtNtpPeerSlot, tpAlmCode=tpAlmCode, staPtPtpClkb=staPtPtpClkb, setPtPtpMaxClient=setPtPtpMaxClient, setSineoEnable=setSineoEnable, staCiBPVErCnt=staCiBPVErCnt, staJcciPort=staJcciPort, setMiMtie10EL2=setMiMtie10EL2, setCiPort=setCiPort, setPtNtpPortMask=setPtNtpPortMask, comMode=comMode, staJcciLOS=staJcciLOS, setLrmPPort=setLrmPPort, setMgFreqATau=setMgFreqATau, staLrme1PTable=staLrme1PTable, setE1Frame=setE1Frame, staGpsMtie2A=staGpsMtie2A, setCmId=setCmId, setPtNtpChassis=setPtNtpChassis, setMgMtie1000CL2=setMgMtie1000CL2, evT=evT, mTrapObjs=mTrapObjs, setPtpVlanState=setPtpVlanState, staLrme1MEntry=staLrme1MEntry, mtA=mtA, setPtpPortTable=setPtpPortTable, setMsiFreqBClrLmt=setMsiFreqBClrLmt, setDs1E1InpTable=setDs1E1InpTable, setPtPtpTwostep=setPtPtpTwostep, snmpv2userIndex=snmpv2userIndex, staJcciMStatus=staJcciMStatus, setDiCSFlt=setDiCSFlt, staPtNtpTable=staPtNtpTable, staGpsSlot=staGpsSlot, ptpPortDataSetSlot=ptpPortDataSetSlot, setJccInpTable=setJccInpTable, setMsiMtie1000EL1=setMsiMtie1000EL1, ptpTimeMessageCurrentTimeSec=ptpTimeMessageCurrentTimeSec, setupLrmE1=setupLrmE1, staLrme1MSlot=staLrme1MSlot, rtIndex=rtIndex, staCiBPV=staCiBPV, inFeature=inFeature, ActiveValue=ActiveValue, snmpman=snmpman, setDsChassis=setDsChassis, setLrme1PCid=setLrme1PCid, tpNtfCode=tpNtfCode, salLevel=salLevel, stGpsPosEntry=stGpsPosEntry, staLrmPBpvErrSecs=staLrmPBpvErrSecs, staJccInpTable=staJccInpTable, staLrme1PBpvSevErrRatio=staLrme1PBpvSevErrRatio, staSynceRxSsm=staSynceRxSsm, setPtNtpRouteSlot=setPtNtpRouteSlot, setMiFreqBClrLmt=setMiFreqBClrLmt, peerStaAddress=peerStaAddress, pqlE1Entry=pqlE1Entry, ptpPortDataSetPortNumber=ptpPortDataSetPortNumber, setPtNtpPeerAddr=setPtNtpPeerAddr, staDiMStatus=staDiMStatus, setPtNtpVlanPAId=setPtNtpVlanPAId, setDsFrame=setDsFrame, ionName=ionName, setMsiFreqAErrLmt=setMsiFreqAErrLmt, fqEntry=fqEntry, giSlot=giSlot, ntpqSyspeer=ntpqSyspeer, staLrme1PSlot=staLrme1PSlot, snmpv3manUser=snmpv3manUser, setPtNtpSlot=setPtNtpSlot, setMsiMtie10000EL1=setMsiMtie10000EL1, staPtNtpSlot=staPtNtpSlot, ntpEntry=ntpEntry, setCimLOSClrCnt=setCimLOSClrCnt, staLrmPBpvSevErrRatio=staLrmPBpvSevErrRatio, peerStaOffset=peerStaOffset, setGpsTodsrcPriority=setGpsTodsrcPriority, setPtNtpPAActive=setPtNtpPAActive, setPtNtpPortChassis=setPtNtpPortChassis, tdInpLoc=tdInpLoc, tdPort=tdPort, snmpEnable=snmpEnable, tpId=tpId, alarm=alarm, userEntry=userEntry, whoName=whoName, staGpsMtie1A=staGpsMtie1A, setMsiMtie100CL2=setMsiMtie100CL2, staCRCErCnt=staCRCErCnt, ssuTraps=ssuTraps, inSwPart=inSwPart, staOtClkc=staOtClkc, staLrmPBpv60SRate=staLrmPBpv60SRate, stGpsPosChassis=stGpsPosChassis, refClkSwitch=refClkSwitch, staPtNtpModState=staPtNtpModState, setPtPtpDelayLimit=setPtPtpDelayLimit, staSynceEntry=staSynceEntry, staLOSErCnt=staLOSErCnt, ntpqSysleap=ntpqSysleap, setDiZeroPhase=setDiZeroPhase, pqlDs1Entry=pqlDs1Entry, ntpqJitter=ntpqJitter, staCiSlot=staCiSlot, setCkMaxTau=setCkMaxTau, inventoryTable=inventoryTable, staOtStatus=staOtStatus, setGpsSlot=setGpsSlot, setDiE1SsmBit=setDiE1SsmBit, stGpsTkEntry=stGpsTkEntry, userTable=userTable, setCcDuty=setCcDuty, snmpv2manTable=snmpv2manTable, statusDs1E1Inp=statusDs1E1Inp, staPtPtpPAState=staPtPtpPAState, staDiStatus=staDiStatus, tpDescr=tpDescr, setPtPtpBypass=setPtPtpBypass, stGpsAvHealthy=stGpsAvHealthy, OkValue=OkValue, setPtPtpService=setPtPtpService, fqB=fqB, setPtNtpRouteAddr=setPtNtpRouteAddr, ntpqReftime=ntpqReftime, stGpsTkSlot=stGpsTkSlot, inShelfPart=inShelfPart, setPtPtpRmvClient=setPtPtpRmvClient, setPtpVlanSlot=setPtpVlanSlot, setPtNtpRouteEntry=setPtNtpRouteEntry, snmpv2manIndex=snmpv2manIndex, setE12048oFrame=setE12048oFrame, statusClk=statusClk, setJcco400Hz=setJcco400Hz, staPtPtpTable=staPtPtpTable, tdTable=tdTable, TModuleCode=TModuleCode, staGps3Sigma=staGps3Sigma, ptpTimeMessageEntry=ptpTimeMessageEntry)
mibBuilder.exportSymbols("SSU2000-MIB", setPtPtpClockId=setPtPtpClockId, mtEntry=mtEntry, setMsiSlot=setMsiSlot, stGpsPosSlot=stGpsPosSlot, giSystime=giSystime, setPtNtpPeerTable=setPtNtpPeerTable, staOtClkSel=staOtClkSel, TLocalTimeOffset=TLocalTimeOffset, setupJccInp=setupJccInp, ptpDfltDataSetChassis=ptpDfltDataSetChassis, setE12048oSsmBit=setE12048oSsmBit, peerStaDispersion=peerStaDispersion, staBPVErCnt=staBPVErCnt, staLrme1MCtaId=staLrme1MCtaId, setSynceChassis=setSynceChassis, staLrme1PFrame=staLrme1PFrame, rtMetric=rtMetric, rtFlags=rtFlags, TrueValue=TrueValue, whoPort=whoPort, staOutTable=staOutTable, phHisTimeAvg=phHisTimeAvg, setPtNtpCommit=setPtNtpCommit, staSynceSlot=staSynceSlot, setGpsTable=setGpsTable, ref=ref, mtTable=mtTable, staLrme1MRefSrc=staLrme1MRefSrc, mstatus=mstatus, stGpsAvElevation=stGpsAvElevation, staDs1E1InpTable=staDs1E1InpTable, phHisClk=phHisClk, setupCcInp=setupCcInp, staPtNtpPBState=staPtNtpPBState, set422oChassis=set422oChassis, staSineiPhaseB=staSineiPhaseB, staCkUtc=staCkUtc, setJcciChassis=setJcciChassis, setPtNtpPeerEntry=setPtNtpPeerEntry, setE1Entry=setE1Entry, infoTable=infoTable, setPtNtpVlanSlot=setPtNtpVlanSlot, almEntry=almEntry, staCiEntry=staCiEntry, staLrme1MChassis=staLrme1MChassis, refInpSwitch=refInpSwitch, setPtPtpTimescale=setPtPtpTimescale, staSynceTxSsm=staSynceTxSsm, staJcciStatus=staJcciStatus, staLrmPSlip=staLrmPSlip, staLrme1PBpv24HRate=staLrme1PBpv24HRate, setJcciPort=setJcciPort, setCcBypass=setCcBypass, setMgFreqBErrLmt=setMgFreqBErrLmt, comBaud=comBaud, snmpv3user=snmpv3user, setCmVer=setCmVer, setLrme1PPort=setLrme1PPort, setJccoEntry=setJccoEntry, ptpPortDataSetChassis=ptpPortDataSetChassis, setMiMtie1000CL1=setMiMtie1000CL1, mTraps=mTraps, setMgChassis=setMgChassis, tmLocalOffset=tmLocalOffset, ptpClockDescrProtocolAddress=ptpClockDescrProtocolAddress, setPtPtpChassis=setPtPtpChassis, setDiFrame=setDiFrame, setMgMtie100000CL1=setMgMtie100000CL1, setPtNtpTodsrcPrefer=setPtNtpTodsrcPrefer, staSineiPort=staSineiPort, ntpAddBrd=ntpAddBrd, setPtPtpPortPriority2=setPtPtpPortPriority2, time=time, staGpsChassis=staGpsChassis, setPtNtpRouteTable=setPtNtpRouteTable, setPtPtpTable=setPtPtpTable, ionEntry=ionEntry, statusLrmE1=statusLrmE1, ntpqSysoffset=ntpqSysoffset, PYSNMP_MODULE_ID=ssu2000, setSineoEntry=setSineoEntry, setLrmPSlip=setLrmPSlip, setMiMtie10000EL1=setMiMtie10000EL1, setSynceSlot=setSynceSlot, setPtpVlanId=setPtpVlanId, setSineiPort=setSineiPort, sysAliveEntry=sysAliveEntry, setGpsPosel=setGpsPosel, staSineiMtie2A=staSineiMtie2A, pqlDs1Table=pqlDs1Table, staPtNtpClkb=staPtNtpClkb, setPtpVlanGate=setPtpVlanGate, tpTimestamp=tpTimestamp, setMgMtie10000CL1=setMgMtie10000CL1, phHisChassis=phHisChassis, who=who, setMiMtie10EL1=setMiMtie10EL1, setPtNtpPortSlot=setPtNtpPortSlot, phase=phase, staLrmMChassis=staLrmMChassis, sifGpsNumber=sifGpsNumber, setDsEnable=setDsEnable, setSineiEntry=setSineiEntry, comParmIndex=comParmIndex, staPtPtpStatus=staPtPtpStatus, stGpsAvailTable=stGpsAvailTable, setLrmPSlot=setLrmPSlot, setE12048oTable=setE12048oTable, ntpSysPeerOffset=ntpSysPeerOffset, salSlot=salSlot, tdChassis=tdChassis, setLrme1PSlot=setLrme1PSlot, pqlE1Descr=pqlE1Descr, sifSnmpv3Number=sifSnmpv3Number, staJcciEntry=staJcciEntry, comEcho=comEcho, inFeatureIndex=inFeatureIndex, setSineiCSFlt=setSineiCSFlt, setMsiMtie10EL2=setMsiMtie10EL2, staSineiStatus=staSineiStatus, setMsiMtie100000CL2=setMsiMtie100000CL2, almElevate=almElevate, setMgFreqBClrLmt=setMgFreqBClrLmt, giChassis=giChassis, ptpPortDataSetEntry=ptpPortDataSetEntry, setSineoBypass=setSineoBypass, setupPtNtp=setupPtNtp, staCiLOS=staCiLOS, setLrmPEnable=setLrmPEnable, setMiFreqBErrLmt=setMiFreqBErrLmt, pqlE1Table=pqlE1Table, tdHisSlot=tdHisSlot, ptpDfltDataSetSlot=ptpDfltDataSetSlot, staDiBPV=staDiBPV, staSineiChassis=staSineiChassis, setPtPtpSyncLimit=setPtPtpSyncLimit, setPtpPortGate=setPtpPortGate, staCkSlot=staCkSlot, staGpsStatus=staGpsStatus, inFeatureTable=inFeatureTable, ntpClr=ntpClr, staPtPtpChassis=staPtPtpChassis, mtChassis=mtChassis, ph1000A=ph1000A, staSynceTable=staSynceTable, evCount=evCount, setPtPtpCommit=setPtPtpCommit, setupGps=setupGps, setCiChassis=setCiChassis, snmpv3userTable=snmpv3userTable, snmpNotification=snmpNotification, setMgFreqAErrLmt=setMgFreqAErrLmt, setPtPtpSlot=setPtPtpSlot, mtHisInpLoc=mtHisInpLoc, setCoSquelch=setCoSquelch, snmpv3userEntry=snmpv3userEntry, sysEvtLogin=sysEvtLogin, setMiMtie100000EL1=setMiMtie100000EL1, setSineiFrequency=setSineiFrequency, setJcci400Hz=setJcci400Hz, peerStaIndex=peerStaIndex, staCkPql=staCkPql, setPtNtpVlanPBPriority=setPtNtpVlanPBPriority, setCcSlot=setCcSlot, tdEntry=tdEntry, statusLrm=statusLrm, staSynceEthernetMode=staSynceEthernetMode, setPtNtpAuthEntry=setPtNtpAuthEntry, setPtPtpDomain=setPtPtpDomain, stGpsTkSnr=stGpsTkSnr, phChassis=phChassis, ntpqSysstratum=ntpqSysstratum, setMiMtie100EL1=setMiMtie100EL1, staDiSlot=staDiSlot, setSynceOutQl=setSynceOutQl, staPtNtpPAState=staPtNtpPAState, sifLrmDs1Number=sifLrmDs1Number, setupDs1E1Inp=setupDs1E1Inp, ntpq=ntpq, staOtSlot=staOtSlot, staLrmPStatus=staLrmPStatus, setMiCRCClrCnt=setMiCRCClrCnt, salDelay=salDelay, setPtPtpPortPriority1=setPtPtpPortPriority1, setPtPtpUniLeaseDuration=setPtPtpUniLeaseDuration, setMsiFreqBErrLmt=setMsiFreqBErrLmt, setMgMtie1000CL1=setMgMtie1000CL1, setMiCRCErrCnt=setMiCRCErrCnt, mtHisClk=mtHisClk, ntpAddBclient=ntpAddBclient, staDiOOF=staDiOOF, sysTl1Format=sysTl1Format, setPtNtpRouteGate=setPtNtpRouteGate, stGpsAvChnl=stGpsAvChnl, staLrmPBpv24HRate=staLrmPBpv24HRate, setCiEnable=setCiEnable, rtUse=rtUse, staJcciPhaseB=staJcciPhaseB, setJcciProvPql=setJcciProvPql, whoEntry=whoEntry, evType=evType, staPtNtpClkd=staPtNtpClkd, setMgMtie100EL1=setMgMtie100EL1, setDiEnable=setDiEnable, set422oFltMode=set422oFltMode, staOtPql=staOtPql, mtSlot=mtSlot, ntpBTimer=ntpBTimer, setE1Crc=setE1Crc, setE12048oCrc=setE12048oCrc, staSineInpTable=staSineInpTable, ntpPrefer=ntpPrefer, setCkFreqTimeout=setCkFreqTimeout, setMiMtie10000CL1=setMiMtie10000CL1, setCimSlot=setCimSlot, setPtNtpRouteNum=setPtNtpRouteNum, staLrmPSlips=staLrmPSlips, setGnssConsMode=setGnssConsMode, staSineiFreqB=staSineiFreqB, ntpBrdTimer=ntpBrdTimer, setPtpVlanEntry=setPtpVlanEntry, stGpsAvPNCode=stGpsAvPNCode, setMsiEntry=setMsiEntry, phHisIndex=phHisIndex, ntpqTable=ntpqTable, staPtPtpRednt=staPtPtpRednt, staOtPortSta=staOtPortSta, sysResetClk=sysResetClk, TAntHeight=TAntHeight, staCkEntry=staCkEntry, snmpv3userIndex=snmpv3userIndex, setMgSlot=setMgSlot, snmpmanTrap=snmpmanTrap, setMgMtie100000EL1=setMgMtie100000EL1, setCkWarmup=setCkWarmup, comEntry=comEntry, setMsiMtie100EL2=setMsiMtie100EL2, almId=almId, setCcInpTable=setCcInpTable, peerStaTable=peerStaTable, setMsiMtie100CL1=setMsiMtie100CL1, inChassis=inChassis, ntpqChassis=ntpqChassis, setMsiFreqAClrLmt=setMsiFreqAClrLmt, setPtNtpRouteChassis=setPtNtpRouteChassis, setMgMtie1000EL2=setMgMtie1000EL2, setPtpVlanIndex=setPtpVlanIndex, tdHisPort=tdHisPort, sifOutE12048Number=sifOutE12048Number, setJcciSlot=setJcciSlot, giElevation=giElevation, setupPtPtp=setupPtPtp, rtValid=rtValid, staGpsEntry=staGpsEntry)
mibBuilder.exportSymbols("SSU2000-MIB", ionPort=ionPort, setMgEntry=setMgEntry, setPtNtpPortEntry=setPtNtpPortEntry, staCkTau=staCkTau, sifOutDs1Number=sifOutDs1Number, inHwRev=inHwRev, staCiMStatus=staCiMStatus, setMgMtie10CL2=setMgMtie10CL2, staCkChassis=staCkChassis, staGpsPhaseB=staGpsPhaseB, refInp=refInp, ptpclientData=ptpclientData, staSineiPql=staSineiPql, ntpqEntry=ntpqEntry, setPtpVlanMask=setPtpVlanMask, staLrmPLof=staLrmPLof, setGpsTimel=setGpsTimel, comType=comType, setPtNtpAuthChassis=setPtNtpAuthChassis, sifOutE1Number=sifOutE1Number, staLrme1PChassis=staLrme1PChassis, comParmEntry=comParmEntry, sifInpJccNumber=sifInpJccNumber, setupClk=setupClk, staLrme1MTable=staLrme1MTable, setCcEnable=setCcEnable, ptpclientEntry=ptpclientEntry, staOOFErCnt=staOOFErCnt, ntpqPeer=ntpqPeer, ptpPortDataSetPortState=ptpPortDataSetPortState, staCiChassis=staCiChassis, peerStaEntry=peerStaEntry, setPtNtpWeight=setPtNtpWeight, setPtPtpDscpState=setPtPtpDscpState, staGpsFreqA=staGpsFreqA, setGpsEntry=setGpsEntry, setGpsAvg=setGpsAvg, sInterfaces=sInterfaces, staLrme1PStatus=staLrme1PStatus, staLrme1MStatus=staLrme1MStatus, setCcComp=setCcComp, sifSnmpv2Number=sifSnmpv2Number, setMiLOSErrCnt=setMiLOSErrCnt, staLrme1PSlips=staLrme1PSlips, comIndex=comIndex, staSyncePortDirection=staSyncePortDirection, sysAco=sysAco, staDiFreqB=staDiFreqB, statusPtPtp=statusPtPtp, staSineiEntry=staSineiEntry, inSerial=inSerial, ptpDfltDataSetFreqTraceable=ptpDfltDataSetFreqTraceable, almChassis=almChassis, setPtpPortChassis=setPtpPortChassis, setCkSlot=setCkSlot, peerStaSanity=peerStaSanity, setAlmThCcInpTable=setAlmThCcInpTable, staLrmPEntry=staLrmPEntry, fqChassis=fqChassis, ptpClockDescrSlot=ptpClockDescrSlot, setPtNtpAuthTable=setPtNtpAuthTable, sysOpmode=sysOpmode, setPtNtpPeerPmin=setPtNtpPeerPmin, almStatus=almStatus, ptpclientParmLoc=ptpclientParmLoc, setDsTable=setDsTable, tpSlot=tpSlot, staLrme1PBpv60SRate=staLrme1PBpv60SRate, setCiZeroPhase=setCiZeroPhase, almLevel=almLevel, setMiMtie1000EL1=setMiMtie1000EL1, set422oEntry=set422oEntry, setLrme1PEnable=setLrme1PEnable, staAISErCnt=staAISErCnt, sifInpJsineNumber=sifInpJsineNumber, ptpClockDescrClockType=ptpClockDescrClockType, setPtNtpPortAddr=setPtNtpPortAddr, staLrme1PLof=staLrme1PLof, tdHisChassis=tdHisChassis, staPtPtpClka=staPtPtpClka, peerStaParentMode=peerStaParentMode, snmpv3manEntry=snmpv3manEntry, setPtPtpEthRate=setPtPtpEthRate, ntpPeerType=ntpPeerType, ptpTimeMessageChassis=ptpTimeMessageChassis, staCkStatus=staCkStatus, setGpsZeroPhase=setGpsZeroPhase, setE1SsmBit=setE1SsmBit, ntpIndex=ntpIndex, mtHisTable=mtHisTable, giSetup=giSetup, setDiProvPql=setDiProvPql, staSineiMtie1A=staSineiMtie1A, setMiMtie100CL1=setMiMtie100CL1, ioname=ioname, setMgMtie100000EL2=setMgMtie100000EL2, setLrmPFlt=setLrmPFlt, sys=sys, staPtPtpSlot=staPtPtpSlot, setCimLOSErrCnt=setCimLOSErrCnt, tdHisEntry=tdHisEntry, setJccoEnable=setJccoEnable, com232Table=com232Table, userIndex=userIndex, almPort=almPort, rtMask=rtMask, setCcChassis=setCcChassis, tdHisIndex=tdHisIndex, sysAliveIndex=sysAliveIndex, setPtNtpVlanBondPriority=setPtNtpVlanBondPriority, setLrmPChassis=setLrmPChassis, ptpDfltDataSetTable=ptpDfltDataSetTable, ptpClockDescrChassis=ptpClockDescrChassis, setSyncePortDirection=setSyncePortDirection, setMsiMtie1000CL1=setMsiMtie1000CL1, staDiMtie1A=staDiMtie1A, peerStaLeap=peerStaLeap, setPtPtpUniNegotiation=setPtPtpUniNegotiation, setMsiMtie100000EL1=setMsiMtie100000EL1, staAISClCnt=staAISClCnt, setupSineInp=setupSineInp, stGpsPosValid=stGpsPosValid, statusCcInp=statusCcInp, staOtClkd=staOtClkd, setPtNtpVlanBondId=setPtNtpVlanBondId, mtHisIndex=mtHisIndex, sysPbo=sysPbo, setLrmPBpv=setLrmPBpv, staLrmPLosSide2=staLrmPLosSide2, setClkTable=setClkTable, staSineiPhaseA=staSineiPhaseA, inShelfDesc=inShelfDesc, inRevision=inRevision, tdA=tdA, pqlE1Index=pqlE1Index, setLrmPTable=setLrmPTable, staGpsPhaseA=staGpsPhaseA, setMiMtie100CL2=setMiMtie100CL2, stGpsAvAzimuth=stGpsAvAzimuth, ntpqIndex=ntpqIndex, setLrmPEntry=setLrmPEntry, staLrmMCtaId=staLrmMCtaId, almName=almName, setCoEnable=setCoEnable, setMgMtie100CL2=setMgMtie100CL2, setMgMtie10000EL2=setMgMtie10000EL2, tdHisV=tdHisV, setPtNtpAuthKeyValue=setPtNtpAuthKeyValue, stGpsTkSv=stGpsTkSv, setMiMtie10CL2=setMiMtie10CL2, snmpv2manIp=snmpv2manIp, staLrmPTable=staLrmPTable, setSineoChassis=setSineoChassis, setCiSlot=setCiSlot, setPtNtpVlanPBId=setPtNtpVlanPBId, setMsiChassis=setMsiChassis, tprTag=tprTag, setDiSSM=setDiSSM, inSwRev=inSwRev, setGpsPriority=setGpsPriority, inModCode=inModCode, setMiFreqATau=setMiFreqATau, ntp=ntp, setPtNtpAuthSlot=setPtNtpAuthSlot, setPtNtpVlan=setPtNtpVlan, phHisTable=phHisTable, staLrmPBpv=staLrmPBpv, staPtPtpCommit=staPtPtpCommit, snmpv3manIndex=snmpv3manIndex, setLrme1PBpv=setLrme1PBpv, comm=comm, staPtNtpClkc=staPtNtpClkc, setE1Chassis=setE1Chassis, setupSineOut=setupSineOut, inAdapterPart=inAdapterPart, staPtNtpStatus=staPtNtpStatus, staJcciBPV=staJcciBPV, staLrmPChassis=staLrmPChassis, staDiAIS=staDiAIS, staCiLOSClCnt=staCiLOSClCnt, setMiAISErrCnt=setMiAISErrCnt, salName=salName, mtToTime=mtToTime, setMiFreqAErrLmt=setMiFreqAErrLmt, ph100B=ph100B, setPtNtpVlanChassis=setPtNtpVlanChassis, tpChassis=tpChassis, setCkPLLMode=setCkPLLMode, mtHisSlot=mtHisSlot, staLrmPBpvTestTime=staLrmPBpvTestTime, peerStaSentCnt=peerStaSentCnt, setDiCRC=setDiCRC, setMiLOSClrCnt=setMiLOSClrCnt, routeTable=routeTable, ptpClockDescrManufacturerId=ptpClockDescrManufacturerId, ptpclient=ptpclient, ptpPortDataSetTable=ptpPortDataSetTable, salChassis=salChassis, salElevate=salElevate, phHisV=phHisV, setLrme1PFlt=setLrme1PFlt, statusCom=statusCom, inHwDate=inHwDate, setPtNtpTable=setPtNtpTable, setPtpVlanAddr=setPtpVlanAddr, salSet=salSet, ptpclientTable=ptpclientTable, setPtNtpBond=setPtNtpBond, comParmTable=comParmTable, setPtPtpVlan=setPtPtpVlan, setSynceEsmc=setSynceEsmc, setSynceQl=setSynceQl, setPtNtpPortGate=setPtNtpPortGate, staDiPhaseA=staDiPhaseA, ntpqXeq=ntpqXeq, setSineiZeroPhase=setSineiZeroPhase, setPtNtpPeerChassis=setPtNtpPeerChassis, staLrme1PBpv=staLrme1PBpv, rtSlot=rtSlot, staLrmPLos=staLrmPLos, setCmName=setCmName, setMsiMtie100000CL1=setMsiMtie100000CL1, staGpsMtie2B=staGpsMtie2B, tmCurTime=tmCurTime, stGpsAvEntry=stGpsAvEntry, staDiFreqA=staDiFreqA, setMiChassis=setMiChassis, setCoTable=setCoTable, setGpsLon=setGpsLon, setJccoTable=setJccoTable, staLrme1PPort=staLrme1PPort, setMsiMtie10000CL2=setMsiMtie10000CL2, ntpqPoll=ntpqPoll, setMgMtie100000CL2=setMgMtie100000CL2, ionChassis=ionChassis, setupDs1Out=setupDs1Out, setPtNtpNTPd=setPtNtpNTPd, staOOFClCnt=staOOFClCnt, staLrmMRefSrc=staLrmMRefSrc, setMiBPVClrCnt=setMiBPVClrCnt, phA=phA, inService=inService, setSynceTable=setSynceTable, general=general, stGpsPosAvg=stGpsPosAvg, setMgMtie10CL1=setMgMtie10CL1, setPtNtpBypass=setPtNtpBypass, ptpPortDataSetClockId=ptpPortDataSetClockId, setupLrm=setupLrm, comLogoff=comLogoff, staSynceChassis=staSynceChassis, setup422Out=setup422Out, inInstalled=inInstalled, staLrme1PLos=staLrme1PLos)
mibBuilder.exportSymbols("SSU2000-MIB", rtIface=rtIface, setMiPort=setMiPort, staGpsTable=staGpsTable, setPtPtpEntry=setPtPtpEntry, ntpqReach=ntpqReach, staCkPLLMode=staCkPLLMode, setPtNtpProbe=setPtNtpProbe, setPtpPortEntry=setPtpPortEntry, setE12048oSsm=setE12048oSsm, peerStaStratum=peerStaStratum, mtie=mtie, ptpDfltDataSetClockAccuracy=ptpDfltDataSetClockAccuracy, tdev=tdev, setMsiMtieStd=setMsiMtieStd, ntpqRefid=ntpqRefid, staPtPtpClkc=staPtPtpClkc, sifInpE1Number=sifInpE1Number, stGpsPosTable=stGpsPosTable, staSineiFreqA=staSineiFreqA, setCkEntry=setCkEntry, salId=salId, ionameLoc=ionameLoc, staPtNtpChassis=staPtNtpChassis, mTrapReq=mTrapReq, setPtNtpVlanEntry=setPtNtpVlanEntry, staLrmPBpvSevErrSecs=staLrmPBpvSevErrSecs, ntpTable=ntpTable, setCoFltMode=setCoFltMode, inName=inName, setup2048Out=setup2048Out, setCimBPVErrCnt=setCimBPVErrCnt, peerStaHomeMode=peerStaHomeMode, setCoSlot=setCoSlot, setMiSlot=setMiSlot, setPtNtpTodsrcPriority=setPtNtpTodsrcPriority, ionameSet=ionameSet, EnaValue=EnaValue, setAlmTable=setAlmTable, staOtChassis=staOtChassis, set422oTable=set422oTable, setupCom=setupCom, stGpsPosLat=stGpsPosLat, stGpsPosPdop=stGpsPosPdop, setSineiEnable=setSineiEnable, staSineiMtie2B=staSineiMtie2B, ionameTable=ionameTable, ntpqValid=ntpqValid, staLrmPPort=staLrmPPort, setJcciPriority=setJcciPriority, staPtNtpClka=staPtNtpClka, staClkTable=staClkTable, setMgMtie100EL2=setMgMtie100EL2, setMsiMtie100EL1=setMsiMtie100EL1)
