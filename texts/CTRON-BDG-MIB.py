#
# PySNMP MIB module CTRON-BDG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-BDG-MIB
# Produced by pysmi-1.1.12 at Mon Jun  3 03:03:25 2024
# On host fv-az736-440 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
bridge, layerMgmt = mibBuilder.importSymbols("IRM-OIDS", "bridge", "layerMgmt")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, NotificationType, ObjectIdentity, MibIdentifier, Gauge32, IpAddress, ModuleIdentity, Integer32, TimeTicks, Counter64, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "NotificationType", "ObjectIdentity", "MibIdentifier", "Gauge32", "IpAddress", "ModuleIdentity", "Integer32", "TimeTicks", "Counter64", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
bridgeRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1))
bdgdevice = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1))
bdgPort = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2))
filterDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3))
trapTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 4))
bdgTables = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 5))
acqDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1))
permDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2))
specialDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3))
acqStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1))
acqOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2))
permStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1))
permOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2))
specStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1))
specFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2))
bdgdeviceDisableBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableBridge", 0), ("enableBridge", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setDescription('Indicates if the bridge will be disabled.')
bdgdeviceRestoreSettings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restoreSettings", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setDescription('Restore the following settings to their default values:\n                Bridge Name to ETHERNET_BRIDGE,\n                Location to LOCAL,\n                Port 1 Name to PORT_1,\n                Port 2 Name to PORT_2,\n                Port 1 Network Name to LAN_1,\n                Port 2 Network Name to LAN_2,\n                Ageing Time for Acquired Database to 300 seconds,\n                Erase the acquired database,\n                Erase the permanent database,\n                Place sixteen default multicast addresses into\n                the permanent and acquired databases,\n                Type of Spanning Tree to 802.1,\n                Type of Filtering to IEEE 802.1,\n                Bridge Max Age to 20 seconds,\n                Bridge Forward Delay to 15 seconds,\n                Bridge Hello Time to 2 seconds,\n                Bridge Priority to 8000,\n                Port 1 Priority to 80,\n                Port 2 Priority to 80,\n                Port 1 Path Cost to 100,\n                Port 2 Path Cost to 100,\n                Restart the bridge.')
bdgdeviceBdgName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgName.setDescription('The user-defined name (up to 32 characters long) of the bridge.\n        The default bridge name is ETHERNET_BRIDGE.')
bdgdeviceNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumPorts.setDescription('The number of ports present on the bridge.')
bdgdeviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceType.setDescription('The type of bridge, NB25E, IRBM, or NB20E.')
bdgdeviceVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceVersion.setDescription('The release version of the firmware installed in the bridge.')
bdgdeviceLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceLocation.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceLocation.setDescription('The user-defined name to indicate the location of the bridge on\n        the network. The default location name is LOCAL.')
bdgdeviceStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceStatus.setDescription('The status of the bridge, ON-LINE, STAND BY or DISABLED.')
bdgdeviceRestartBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restartBridge", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setDescription('Force the bridge to undergo a software reset.')
bdgdeviceFrFwd = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFwd.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFwd.setDescription('The number of frames forwarded by the bridge.')
bdgdeviceFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrRx.setDescription('The number of frames received by the bridge.')
bdgdeviceFrFlt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFlt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFlt.setDescription('The number of frames filtered by the bridge.')
bdgdeviceErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceErr.setDescription('The total number of network errors that have occurred.')
bdgdeviceSwitchSetting = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setDescription('Indicates the current switch settings read from the bridge\n        hardware.')
bdgdeviceNumRestarts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setDescription('The number of times the bridge has been powered up or restarted.')
bdgdeviceTypeFiltering = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("specialDB", 1), ("both", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setDescription('The type of filtering to be performed by the bridge. The default\n        is IEEE 802.1.')
bdgdeviceSTAProtocol = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("dec", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setDescription('The spanning tree algorithm under which the bridge is operating.\n        The selections are as follows:\n                - IEEE 802.1 compliant spanning tree algorithm\n                  environment (802.1)\n                - DEC LAN Bridge 100 environment (DEC)\n                - Without the spanning tree algorithm enabled (NONE)\n        The default is 802.1.')
bdgdeviceBridgeID = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceBridgeID.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBridgeID.setDescription('The unique identifier of the bridge. The first two bytes of the\n        identifier are the bridge priority and the last six bytes are the\n        Ethernet address.')
bdgdeviceTopChgCnt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setDescription("The number of times the bridge's Topology Change Flag has been\n        changed since the bridge was powered up or initialized.")
bdgdeviceRootCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootCost.setDescription('The cost of the path to the root from this bridge.')
bdgdeviceRootPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootPort.setDescription('The port identifier for the port which offers the lowest cost\n        path to the root, i.e. that port for which the sum of the values\n        of the designated cost and path cost parameters held for the port\n        is lowest.')
bdgdeviceHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHelloTime.setDescription("The time interval between the transmission of Configuration\n        BPDU's by a bridge which is attempting to become the root or is\n        the root.")
bdgdeviceBdgMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setDescription('The value of the Max Age parameter when the bridge is the root\n        or is attempting to become the root. A time of 6 to 40 seconds is\n        allowed. The default is 20 seconds.')
bdgdeviceBdgFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setDescription('The value of the forward delay parameter when the bridge is the\n        root or is attempting to become the root. A time of 4 to 30\n        seconds is allowed.')
bdgdeviceTimeTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setDescription("The time in seconds that has elapsed since the bridge's Topology\n        Change Flag last recorded the value of a topology change.")
bdgdeviceTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeInProgress", 0), ("topologyChangeInProgress", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChg.setDescription('Indicates if a bridge topology change is in progress.')
bdgdeviceDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setDescription('The unique identifier of the bridge recorded as the root.')
bdgdeviceMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceMaxAge.setDescription('The maximum age of received protocol information before it is\n        discarded.')
bdgdeviceHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHoldTime.setDescription("The minimum time period elapsing between the transmission of\n        configuration BPDU's through a given bridge port.")
bdgdeviceFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFwdDly.setDescription('The time spent in the listening state while moving from the\n        blocking state to the learning state, or the time spent in the\n        learning state while moving from the listening state to the\n        forwarding state.')
bdgdeviceBdgHello = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgHello.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgHello.setDescription('The value of the Hello Time parameter when the bridge is the\n        root or is attempting to become the root. A time of 1 to 10\n        seconds is allowed. The default is 2 seconds.')
bdgdeviceBdgPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setDescription('The part of the bridge address that contains the identifier used\n        in the spanning tree for priority comparisons. Allowed range is 0\n        through FFFF. The default is 8000.')
bdgdeviceResetCounts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("resetCounts", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceResetCounts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceResetCounts.setDescription('Reset all counters to zero.')
bdgdeviceUptime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceUptime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceUptime.setDescription('The time, in seconds, that has elapsed since the bridge was last\n        reset or initialized.')
bdgdeviceTrapType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 36), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTrapType.setDescription('Contains the object identifier of the first VarBinding in the\n        last trap generated by the bridge.')
bdgPortAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortAddress.setDescription('The Ethernet address of the port.')
bdgPortName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortName.setDescription('The user-defined name assigned to the port. The default port 1\n        name is PORT_1 and the default Port 2 name is PORT_2.')
bdgPortType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortType.setDescription('The IEEE specification the port meets, e.g. 802.3.')
bdgPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortStatus.setDescription('The status in which the port is operating. The status messages\n        for Ports 1 and 2 are:\n\n                OFF - The port is off, due to a failed network interface\n                chip associated with that port.\n\n                OK/SQE ON - The port is communicating with the network\n                and the transceiver making the connection to the network\n                has SQE enabled.\n\n                OK/SQE OFF - The port is communicating with the network\n                and the transceiver making the connection to the network\n                has SQE disabled.\n\n                CARRIER LOST - Communication with the network has not\n                been established or has been lost.')
bdgPortNetName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortNetName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortNetName.setDescription('The user-defined name assigned to a network segment connected to\n        the port. The default network name for Port 1 is LAN_1 and the\n        default network name for Port 2 is LAN_2.')
bdgPortFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrRx.setDescription('The number of frames received at the specified port.')
bdgPortDisInb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisInb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisInb.setDescription('The total number of valid frames that were received at the port\n        but then discarded by the bridge in the forwarding process.')
bdgPortFwdOutb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFwdOutb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFwdOutb.setDescription('The number of frames forwarded successfully to the appropriate\n        port.')
bdgPortDisLOB = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisLOB.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisLOB.setDescription('The number of packets that were discarded by the bridge because\n        of a lack of buffer space to maintain the data.')
bdgPortDisTDE = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisTDE.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisTDE.setDescription('The number of frames that were intended for forwarding but were\n        discarded when the maximum time period set for transmission was\n        exceeded before forwarding was possible.')
bdgPortDisErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisErr.setDescription('The number of frames that could not be transmitted because the\n        frame was too large for the attached network (1526 bytes,\n        including preamble, for 802.3 networks).')
bdgPortColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortColl.setDescription('The number of collisions that have occurred on the network at\n        the specified port.')
bdgPortTxAbrt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTxAbrt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTxAbrt.setDescription('The number of transmissions that have been aborted due to\n        excessive collisions (over 16 attempts to transmit the same\n        packet).')
bdgPortOowColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOowColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOowColl.setDescription('The number of collisions out of the standard collision window\n        (51.2 uS). This indicates a network problem.')
bdgPortCRCErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortCRCErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortCRCErr.setDescription('The number of packets detected with Cyclical Redundancy Check\n        failures.')
bdgPortFrAlErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrAlErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrAlErr.setDescription('The number of errors due to misaligned packets.')
bdgPortPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPriority.setDescription('The part of the port identifier which is used with the spanning\n        tree algorithm when determining which port in a LAN segment has\n        priority. The default is 80.')
bdgPortState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortState.setDescription('The current state of the port, DISABLED, LISTENING, LEARNING,\n        FORWARDING or BLOCKING.')
bdgPortPathCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPathCost.setDescription('The contributory cost of the applicable port to the overall cost\n        of the path when the specified port is the root port. Allowable\n        range is 1 to 65535. The default is 100.')
bdgPortDesigCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigCost.setDescription('The cost of the path of this port to the root bridge on the\n        network.')
bdgPortDesigBrdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigBrdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigBrdg.setDescription('The network address of the bridge that is assumed to be the root\n        bridge on the network.')
bdgPortDesigPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigPort.setDescription('The port identifier of the bridge port believed to be the\n        designated port for the LAN associated with the port.')
bdgPortTopChgAck = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeIsOccurring", 0), ("topologyChangeIsOccurring", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTopChgAck.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTopChgAck.setDescription('The value of the topology change acknowledgement flag in the\n        next configuration BPDU to be transmitted on the associated port.')
bdgPortDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigRoot.setDescription('The unique bridge identifier of the bridge that is assumed to be\n        the root bridge on the network.')
bdgPortRuntPackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortRuntPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortRuntPackets.setDescription('The number of packets received at the indicated bdgPort that were\n        less than the IEEE 802.3 minimum Ethernet frame size of 64 bytes.')
bdgPortOversizePackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOversizePackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOversizePackets.setDescription('The number of packets received at the indicated port that were\n        greater than the IEEE 802.3 maximum Ethernet frame size of 1518\n        bytes.')
bdgPortFrFilt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrFilt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrFilt.setDescription('The number of frames received at the indicated port that were\n        filtered by the bridge.')
acqTotalEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqTotalEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqTotalEntries.setDescription('The total number of entries in the acquired database.')
acqMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqMaxEntries.setDescription('The maximum number of entries allowed in the acquired database.')
acqStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticEntries.setDescription('The number of addresses added to the Acquired database by the\n        user or network manager.')
acqStaticAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticAgeTime.setDescription('The length of time allowed for a static entry in the Acquired\n        database to be inactive before it is dropped from the database.\n        This time is fixed at zero.')
acqDynEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDynEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynEntries.setDescription("The number of entries that have been accumulated in the Acquired\n        database through the bridge's learning process.")
acqDynAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDynAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynAgeTime.setDescription('The length of time allowed for a dynamic entry in the acquired\n        database to be inactive before it is dropped from the database. A\n        time from 10 - 1,000,000 seconds is allowed. The default is 300\n        seconds.')
acqEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("eraseAcquiredDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: acqEraseDatabase.setDescription('Set to zero to erase all entries in the acquired database.')
acqCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate00.setDescription('Add an entry to the acquired database to filter packets entering\n        ports 1 and 2 if those packets are destined for the specified\n        address.')
acqCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate20.setDescription('Add an entry to the acquired database to forward packets\n        entering port1 to port2 and filter packets entering port2 if\n        those packets are destined for the specified address.')
acqCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate01.setDescription('Add an entry to the acquired database to filter packets entering\n        port 1 and forward packets entering port 2 to port 1 if those\n        packets are destined for the specified address.')
acqCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate21.setDescription('Add an entry to the acquired database to forward packets\n        entering port 1 to port 2 and to forward packets entering port 2\n        to port 1 if those packets are destined for the specified\n        address.')
acqDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteAcquiredEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDelete.setStatus('mandatory')
if mibBuilder.loadTexts: acqDelete.setDescription('Delete an entry from the acquired database.')
acqDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispType.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
acqDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp1.setDescription('The outbound port for packets entering port 1.')
acqDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp2.setDescription('The outbound port for packets entering port 2.')
acqSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: acqSrcAddress.setDescription('The source address of this acquired database entry, i.e. the\n        instance.')
permMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permMaxEntries.setDescription('The maximum number of entries allowed in the permanent database.')
permCurrEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permCurrEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permCurrEntries.setDescription("The number of entries currently recorded in the bridge's\n        permanent database.")
permEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("erasePermanentDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: permEraseDatabase.setDescription('Erase all entries in the permanent database.')
permCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate00.setDescription('Add an entry to the permanent database to filter packets\n        entering ports 1 and 2 if those packets are destined for the\n        specified address.')
permCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate20.setDescription('Add an entry to the permanent database to forward packets\n        entering port 1 and filter packets entering port 2 if those\n        packets are destined for the specified address.')
permCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate01.setDescription('Add an entry to the permanent database to filter packets\n        entering port 1 and forward packets entering port 2 if those\n        packets are destined for the specified address.')
permCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate21.setDescription('Add an entry to the permanent database to forward packets\n        entering ports 1 and 2 if those packets are destined for the\n        specified address.')
permDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deletePermanentEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permDelete.setStatus('mandatory')
if mibBuilder.loadTexts: permDelete.setDescription('Delete an entry from the permanent database.')
permDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispType.setStatus('mandatory')
if mibBuilder.loadTexts: permDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
permDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp1.setDescription('The outbound port for packets entering port 1.')
permDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp2.setDescription('The outbound port for packets entering port 2.')
permSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: permSrcAddress.setDescription('The source address in this permanent database entry, i.e. the\n        instance.')
specNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specNumEntries.setDescription('The number of filters in the special database.')
specMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specMaxEntries.setDescription('The maximum number of filters the special database can contain.')
specNextFilterNum = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNextFilterNum.setStatus('mandatory')
if mibBuilder.loadTexts: specNextFilterNum.setDescription('The number of the next available filter that can be added to the\n        special database.')
specEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableFilter", 0), ("enableFilter", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specEnable.setStatus('mandatory')
if mibBuilder.loadTexts: specEnable.setDescription('Enable or disable the filter.')
specPort1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort1.setStatus('mandatory')
if mibBuilder.loadTexts: specPort1.setDescription('Set port 1 to filter or forward packets.')
specPort2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort2.setStatus('mandatory')
if mibBuilder.loadTexts: specPort2.setDescription('Set port 2 to filter or forward packets.')
specDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specDestAddress.setDescription('Set the special database to filter packets with a specific\n        destination address.')
specSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specSrcAddress.setDescription('Set the special database to filter packets with a specific\n        source address.')
specType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specType.setStatus('mandatory')
if mibBuilder.loadTexts: specType.setDescription('Set the special database to filter packets with a specific type\n        field.')
specDataField = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDataField.setStatus('mandatory')
if mibBuilder.loadTexts: specDataField.setDescription('Set the special database to filter packets based on the first\n        sixteen bytes of data in the packet.')
specDeleteFilter = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteFilter", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDeleteFilter.setStatus('mandatory')
if mibBuilder.loadTexts: specDeleteFilter.setDescription('Delete a filter from the special database.')
lmcommon = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 1))
mAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2))
ieee8023 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1))
pcIF = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1))
pcIfRev = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1))
pcDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeviceName.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeviceName.setDescription('Name of the PC device')
pcBoardType = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: pcBoardType.setDescription('An object  Identifier that  indicates the  type of  the  PC\n     board. This will include MAC type and Media type.')
pcOwnerName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: pcOwnerName.setDescription('The owner of this PC.')
pcLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLocation.setStatus('mandatory')
if mibBuilder.loadTexts: pcLocation.setDescription('A text description of the location of this PC.')
pcMMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACAddr.setDescription('The MAC address of the MMAC that this PC is connected to.')
pcMMACBoard = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACBoard.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACBoard.setDescription('The slot  number of  the board  in the MMAC that this PC is\nconnected to.')
pcMMACPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACPort.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACPort.setDescription('The number  of the  port on the board of the MMAC that this\nPC is connected to.')
pcApplication = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcApplication.setStatus('mandatory')
if mibBuilder.loadTexts: pcApplication.setDescription('A text  description of  the network  application running on\nthis PC.')
pcDriverRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDriverRev.setStatus('mandatory')
if mibBuilder.loadTexts: pcDriverRev.setDescription('The revision of the LAN card driver.')
pcOnboardMemory = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOnboardMemory.setStatus('mandatory')
if mibBuilder.loadTexts: pcOnboardMemory.setDescription('The number  of Kilobytes  of memory  (eg. a 16K board would\nreply 16)')
pcComment = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcComment.setStatus('mandatory')
if mibBuilder.loadTexts: pcComment.setDescription('A user-defined character string.')
pcMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMACAddr.setDescription('The MAC address of the PC card.')
pcFramesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesXmit.setDescription('The number of MAC frames transmitted by this PC card.')
pcBytesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesXmit.setDescription('The number bytes transmitted by this PC card.')
pcMcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastXmit.setDescription('The number of multicasted frames sent by this PC card.')
pcBcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastXmit.setDescription('The number of broadcast frames from this PC card.')
pcDeferXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeferXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeferXmit.setDescription('The number  of transmit  packets that  were deferred due to\nbusy media.')
pcSglColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSglColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcSglColl.setDescription('The  number   of  transmit  packet  experiencing  a  single\ncollision.')
pcMultiColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMultiColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcMultiColl.setDescription('The  number  of  transmit  packets  that  have  experienced\nmultiple collisions.')
pcTotXmitErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotXmitErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotXmitErrs.setDescription('The total number of transmit errors.')
pcLateColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLateColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcLateColls.setDescription('The  number  of  transmit  packets  that  experienced  late\ncollisions.')
pcXcessColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcXcessColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcXcessColls.setDescription('The number  of  transmit  packets  aborted  due  to  excess\ncollisions.')
pcCarrErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCarrErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcCarrErr.setDescription('The number  of transmit  packets  that  experience  carrier\nsense errors (ie. lose carrier during transmission).')
pcFramesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesRec.setDescription('The number of frames received.')
pcBytesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesRec.setDescription('The number of bytes received by this station.')
pcMcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastRec.setDescription('The number of multicasted frames received.')
pcBcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastRec.setDescription('The number of broadcast packets received.')
pcTotRecErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotRecErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotRecErrs.setDescription('The total number of receive errors.')
pcTooLong = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooLong.setDescription('The number of packets received that are too long (over 1518\nbytes).')
pcTooShort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooShort.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooShort.setDescription('The number  of packets  that are too short. (under 64 bytes\nlong).')
pcAlignErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcAlignErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcAlignErrs.setDescription('The number of alignment errors in receive packets.')
pcCRCErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCRCErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcCRCErrs.setDescription('The number of receive packets with CRC errors.')
pcLenErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcLenErrs.setDescription('The number  of packets  whose length  is not  equal to  the\nnumber of bytes received.')
pcIntRecErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcIntRecErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcIntRecErr.setDescription('The number  of receive  packets that  experienced  internal\nerrors (eg. no receive buffers).')
pcSqeErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSqeErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcSqeErr.setDescription('The number of SQE errors.')
mibBuilder.exportSymbols("CTRON-BDG-MIB", bdgPortStatus=bdgPortStatus, bdgPortRuntPackets=bdgPortRuntPackets, bdgPortColl=bdgPortColl, pcBcastXmit=pcBcastXmit, bdgPortPathCost=bdgPortPathCost, permDispOutp2=permDispOutp2, specNextFilterNum=specNextFilterNum, pcFramesRec=pcFramesRec, pcBytesRec=pcBytesRec, bdgdeviceFwdDly=bdgdeviceFwdDly, bdgdeviceRestartBdg=bdgdeviceRestartBdg, acqCreate01=acqCreate01, acqDispOutp1=acqDispOutp1, bdgPortFrFilt=bdgPortFrFilt, acqOptions=acqOptions, bdgdeviceRootCost=bdgdeviceRootCost, bdgPortDisTDE=bdgPortDisTDE, filterDB=filterDB, bdgPortOowColl=bdgPortOowColl, permDispType=permDispType, permDispOutp1=permDispOutp1, specNumEntries=specNumEntries, pcMcastXmit=pcMcastXmit, pcXcessColls=pcXcessColls, bdgPort=bdgPort, bdgdeviceHoldTime=bdgdeviceHoldTime, bdgPortOversizePackets=bdgPortOversizePackets, acqCreate21=acqCreate21, pcDeviceName=pcDeviceName, acqDynEntries=acqDynEntries, specStats=specStats, pcIfRev=pcIfRev, bridgeRev1=bridgeRev1, bdgdeviceRootPort=bdgdeviceRootPort, pcLateColls=pcLateColls, permCreate01=permCreate01, pcMMACAddr=pcMMACAddr, acqDB=acqDB, bdgdeviceNumRestarts=bdgdeviceNumRestarts, specSrcAddress=specSrcAddress, bdgdeviceVersion=bdgdeviceVersion, bdgPortName=bdgPortName, bdgPortFrAlErr=bdgPortFrAlErr, bdgdeviceBdgMaxAge=bdgdeviceBdgMaxAge, bdgdeviceRestoreSettings=bdgdeviceRestoreSettings, bdgPortTopChgAck=bdgPortTopChgAck, pcMultiColl=pcMultiColl, permCreate00=permCreate00, specEnable=specEnable, bdgdeviceDisableBdg=bdgdeviceDisableBdg, acqEraseDatabase=acqEraseDatabase, acqStaticAgeTime=acqStaticAgeTime, pcSglColl=pcSglColl, acqSrcAddress=acqSrcAddress, pcTooLong=pcTooLong, pcMcastRec=pcMcastRec, bdgdeviceLocation=bdgdeviceLocation, bdgdeviceMaxAge=bdgdeviceMaxAge, pcLenErrs=pcLenErrs, bdgdeviceTimeTopChg=bdgdeviceTimeTopChg, bdgPortDesigRoot=bdgPortDesigRoot, pcSqeErr=pcSqeErr, pcOnboardMemory=pcOnboardMemory, pcMMACPort=pcMMACPort, specDeleteFilter=specDeleteFilter, specDestAddress=specDestAddress, bdgPortType=bdgPortType, bdgdeviceFrFwd=bdgdeviceFrFwd, trapTypes=trapTypes, bdgPortDesigPort=bdgPortDesigPort, pcTotXmitErrs=pcTotXmitErrs, bdgTables=bdgTables, bdgdeviceSwitchSetting=bdgdeviceSwitchSetting, permCreate21=permCreate21, bdgdeviceBdgFwdDly=bdgdeviceBdgFwdDly, permDB=permDB, bdgdeviceTopChg=bdgdeviceTopChg, acqDispType=acqDispType, bdgdeviceType=bdgdeviceType, bdgdeviceFrFlt=bdgdeviceFrFlt, bdgPortState=bdgPortState, bdgdeviceTypeFiltering=bdgdeviceTypeFiltering, bdgdeviceHelloTime=bdgdeviceHelloTime, pcIF=pcIF, bdgPortFwdOutb=bdgPortFwdOutb, acqTotalEntries=acqTotalEntries, bdgPortDisErr=bdgPortDisErr, bdgdeviceDesigRoot=bdgdeviceDesigRoot, pcAlignErrs=pcAlignErrs, permCurrEntries=permCurrEntries, acqDelete=acqDelete, pcDeferXmit=pcDeferXmit, pcApplication=pcApplication, bdgPortDisInb=bdgPortDisInb, bdgPortFrRx=bdgPortFrRx, bdgdeviceTrapType=bdgdeviceTrapType, pcBytesXmit=pcBytesXmit, specMaxEntries=specMaxEntries, pcCRCErrs=pcCRCErrs, permSrcAddress=permSrcAddress, permEraseDatabase=permEraseDatabase, permOptions=permOptions, bdgdeviceBdgHello=bdgdeviceBdgHello, bdgPortPriority=bdgPortPriority, pcLocation=pcLocation, acqDispOutp2=acqDispOutp2, bdgPortDisLOB=bdgPortDisLOB, pcComment=pcComment, bdgPortDesigCost=bdgPortDesigCost, bdgdeviceNumPorts=bdgdeviceNumPorts, specType=specType, mAC=mAC, bdgPortNetName=bdgPortNetName, pcFramesXmit=pcFramesXmit, bdgPortCRCErr=bdgPortCRCErr, ieee8023=ieee8023, bdgPortTxAbrt=bdgPortTxAbrt, specPort1=specPort1, acqCreate00=acqCreate00, specPort2=specPort2, pcTooShort=pcTooShort, bdgdevice=bdgdevice, bdgPortDesigBrdg=bdgPortDesigBrdg, pcBoardType=pcBoardType, permStats=permStats, acqStaticEntries=acqStaticEntries, permMaxEntries=permMaxEntries, pcMMACBoard=pcMMACBoard, pcCarrErr=pcCarrErr, bdgdeviceFrRx=bdgdeviceFrRx, bdgdeviceSTAProtocol=bdgdeviceSTAProtocol, pcMACAddr=pcMACAddr, specFilters=specFilters, bdgdeviceResetCounts=bdgdeviceResetCounts, pcTotRecErrs=pcTotRecErrs, pcDriverRev=pcDriverRev, bdgdeviceBdgName=bdgdeviceBdgName, pcOwnerName=pcOwnerName, specDataField=specDataField, bdgdeviceStatus=bdgdeviceStatus, permDelete=permDelete, bdgPortAddress=bdgPortAddress, acqDynAgeTime=acqDynAgeTime, specialDB=specialDB, bdgdeviceBridgeID=bdgdeviceBridgeID, bdgdeviceBdgPriority=bdgdeviceBdgPriority, pcBcastRec=pcBcastRec, permCreate20=permCreate20, lmcommon=lmcommon, bdgdeviceTopChgCnt=bdgdeviceTopChgCnt, acqCreate20=acqCreate20, pcIntRecErr=pcIntRecErr, bdgdeviceErr=bdgdeviceErr, acqMaxEntries=acqMaxEntries, bdgdeviceUptime=bdgdeviceUptime, acqStats=acqStats)
