#
# PySNMP MIB module XF-SOFTWARE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/ericsson/XF-SOFTWARE-MIB
# Produced by pysmi-1.1.8 at Thu Jan  5 10:19:07 2023
# On host fv-az255-307 platform Linux version 5.15.0-1024-azure by user runner
# Using Python version 3.10.9 (main, Dec  7 2022, 08:16:13) [GCC 11.3.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Counter32, Counter64, IpAddress, TimeTicks, Integer32, NotificationType, Bits, ModuleIdentity, Gauge32, MibIdentifier, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "IpAddress", "TimeTicks", "Integer32", "NotificationType", "Bits", "ModuleIdentity", "Gauge32", "MibIdentifier", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso")
DateAndTime, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TextualConvention", "DisplayString")
XfProductRevision, xfPlatform, XfProductnumber = mibBuilder.importSymbols("XF-TOP-MIB", "XfProductRevision", "xfPlatform", "XfProductnumber")
xfSoftwareMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 193, 81, 2, 7))
xfSoftwareMIB.setRevisions(('2008-03-05 18:03', '2007-11-26 12:44', '2007-06-11 09:12', '2007-04-10 09:09', '2003-06-19 10:30', '2002-03-08 08:41', '2002-01-14 09:11', '2001-10-10 12:15', '2004-01-30 13:51', '2004-08-03 08:23', '2005-01-31 08:26', '2005-02-09 08:13',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: xfSoftwareMIB.setRevisionsDescriptions(('N : Removed BITS', 'M   Extended xfSwLmUpgradeOperStatus and\n\t\t\t\t    xfSwReleaseOperStatus with ftp error codes', ' K added preparingForTest(9) to\n\t\t\t\t   xfSwGlobalState', 'J Added extra value testingFromManual(8) to\n\t\t\t\t    xfSwReleaseOperStatus\n\t\t\t\t    Added xfSwGlobalState\n\t\t\t\t', 'D\n\t\t\t\tChanged description of xfSwNpuPassiveSwitch\n\t\t\t\t  to state that a warm restart is required to\n\t\t\t\t  activate the fallback\n\t\t\t\tAdded noFailure(3) to\n\t\t\t\t xfSwLoadModuleFailure', 'C\n\t\t\t\tChanged contact info\n\t\t\t\tAdded one state to the xfSWBoardStatus\n\t\t\t\tAdded objects for multiple load modules\n\t\t\t\tper board and type of the load module.\n\t\t\t\t', 'B write to xfSwReleaseAdminStatus\n\t\t\t\tfor active release has no effect\n\t\t\t\tAdded conformance\n\t\t\t\tChange syntax for product number\n\t\t\t\tand revision\n\t\t\t\tChange name to xfSwBoardStatus', 'A Initial Revision', 'E Added objects for progress indication,\n\t\t\t\tBetter fault indication.\n\t\t\t\tNew release handling.', "F   due to new scope in Neptune\n\t\t\t\tremoved ..AdditionalInfo,\n\t\t\t\txfSwLmUpgradeNewProductNumber and\n\t\t\t\txfSwLmUpgrade/xfSwLoadModuleDescription.\n\t\t\t\tadded xfSwReleaseSBLType and\n\t\t\t\txfBoardTrafficDisturbance\n\n\t\t\t\tchanged the values of xfSwLmUpgradeOper and\n\t\t\t\tAdminStatus. Removed not used values and\n\t\t\t\tremoved 'holes' in the enum values.", 'G Added xfSwLoadModuleDescription,\n\t\t\t\tminSoftwareRevision(5)to xfSwBoardStatus\n\t\t\t\tand xfSuLmUpgradeDescription', 'H reintroduced xfSwBoardLoadModuleIndex as index',))
if mibBuilder.loadTexts: xfSoftwareMIB.setLastUpdated('200803060000Z')
if mibBuilder.loadTexts: xfSoftwareMIB.setOrganization('Ericsson-Norway')
if mibBuilder.loadTexts: xfSoftwareMIB.setContactInfo(' ')
if mibBuilder.loadTexts: xfSoftwareMIB.setDescription('This MIB contains the objects which support software\n\t\t\t\tinventory information.')
class XfSwRelease(TextualConvention, Integer32):
    description = 'Indication of one of the two software releases.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2)

class XfSwEnableDisable(TextualConvention, Integer32):
    description = 'This TC is used for objects that can have these values.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enable", 1), ("disable", 2))

xfSwObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1))
xfSwLoadModuleTable = MibTable((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1), )
if mibBuilder.loadTexts: xfSwLoadModuleTable.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleTable.setDescription('This table contains information about the load modules\n\t\t\t\tthat are part of the system releases as described by\n\t\t\t\tthe xfSwReleaseTable.')
xfSwLoadModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1), ).setIndexNames((0, "XF-SOFTWARE-MIB", "xfSwRelease"), (0, "XF-SOFTWARE-MIB", "xfSwLoadModuleIndex"))
if mibBuilder.loadTexts: xfSwLoadModuleEntry.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleEntry.setDescription('Information about 1 software load module.')
xfSwRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 1), XfSwRelease()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwRelease.setStatus('current')
if mibBuilder.loadTexts: xfSwRelease.setDescription('There are two software releases present on the node:\n\t\t\t\t- an active release, normally the most recent release\n\t\t\t\t  and the one that is running\n\t\t\t\t- a passive release, that is the previous release or\n\t\t\t\t  the one that is currently being download to upgrade\n\t\t\t\t  the active release.\n\t\t\t\txfSwRelease is an index into the active or passive\n\t\t\t\trelease. xfSwActiveRelease indicates which release is\n\t\t\t\tactive.')
xfSwLoadModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleIndex.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleIndex.setDescription('Unique value within one release for each load module.')
xfSwLoadModuleProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 3), XfProductnumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleProductNumber.setDescription("Product number of the load module. Normally something\n\t\t\t\tlike 'CAXR102_012/1'.")
xfSwLoadModuleRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 4), XfProductRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleRevision.setDescription("Revision of the load module. Normally something like\n\t\t\t\t'R1A'.")
xfSwLoadModuleOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("passive", 1), ("upgradeStarted", 2), ("upgradeFinished", 3), ("upgradeFailed", 4), ("upgradeAborted", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleOperStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleOperStatus.setDescription("Indicates the status of the software upgrade process\n\t\t\t\tfor this load module.\n\t\t\t\tpassive(1)\n\t\t\t\t   the load module is not involved in a upgrade\n\t\t\t\t   process and is not active. I.e.it is part of\n\t\t\t\t   the previous software release.\n\n\t\t\t\tupgradeStarted(2)\n\t\t\t\t   a load module will have this status directly\n\t\t\t\t   after the SBDF info for this module is loaded\n\t\t\t\t   and the xfSwLoadModuleAdminStatus of the\n\t\t\t\t   release was set to upgradeStarted.\n\n\t\t\t\tupgradeFinished(3)\n\t\t\t\t   indicates that this load modules has been retrieved\n\t\t\t\t   and burned into the flash memories. This is the state\n\t\t\t\t   of load modules that are part of an active release.\n\n\t\t\t\tupgradeFailed(4)\n\t\t\t\t   upgraded has failed for a reason, e.g. file transfer\n\t\t\t\t   checksum was wrong, see xfSwLoadModuleFailure.\n\n\t\t\t\tupgradeAborted(5)\n\t\t\t\t   when the manager has aborted the upgrade of the\n\t\t\t\t   complete release whilst this load module wasn't\n\t\t\t\t   upgradedFinished yet this will be its status.\n\t\t\t\t")
xfSwLoadModuleFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("downloadFailure", 1), ("programFailure", 2), ("noFailure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleFailure.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleFailure.setDescription('The objects specifies the cause of a software upgrade\n\t\t\t\tfailure for this load module. ')
xfSwLoadModuleProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleProgress.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleProgress.setDescription('This object indicates the progress in downloading\n\t\t\t\tthe respective load module when part of an upgrade\n\t\t\t\tof an NE to a software baseline.')
xfSwLoadModuleDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 1, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLoadModuleDescription.setStatus('current')
if mibBuilder.loadTexts: xfSwLoadModuleDescription.setDescription('This object indicates a textual\n\t\t\t\tdescription of the load module, indicating PIU type\n\t\t\t\tas stated by the entPhysicalDescription MO.')
xfSwReleaseTable = MibTable((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2), )
if mibBuilder.loadTexts: xfSwReleaseTable.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseTable.setDescription('This contains the information on the active and passive\n\t\t\t\tsoftware releases.')
xfSwReleaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1), ).setIndexNames((0, "XF-SOFTWARE-MIB", "xfSwReleaseIndex"))
if mibBuilder.loadTexts: xfSwReleaseEntry.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseEntry.setDescription('Information about a software release. There are always\n\t\t\t\tonly two releases. For the active release write is\n\t\t\t\tpossible but will have no impact and will result in a\n\t\t\t\tinconsistentValue error response.')
xfSwReleaseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 1), XfSwRelease()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwReleaseIndex.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseIndex.setDescription('Indicates the Release the info for which this row is\n\t\t\t\tapplicable.')
xfSwReleaseProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 2), XfProductnumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwReleaseProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseProductNumber.setDescription("Product number of the installed software package in\n\t\t\t\tthis release. Normally something like 'CAXR102 012/1'.\n\t\t\t\tFor the active release this is a read-only object.")
xfSwReleaseRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 3), XfProductRevision()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwReleaseRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseRevision.setDescription("Revision of the installed software package in this\n\t\t\t\tRelease. Normally something like 'R1A'.\n\t\t\t\tFor the active release this is a read-only object.")
xfSwReleaseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 5, 6))).clone(namedValues=NamedValues(("upgradeStarted", 1), ("upgradeAborted", 2), ("activeAndRunning", 5), ("upgradeTest", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwReleaseAdminStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseAdminStatus.setDescription('Indicates the desired status for this release. To start\n\t\t\t\ta software upgrade the manager has to set\n\t\t\t\txfSwReleaseProductNumber and xfSwReleaseRevision. After\n\t\t\t\tthat it will set this object to upgradeStarted. Which\n\t\t\t\twill lead to downloading the SBDF-file from the FTP\n\t\t\t\tServer.\n\t\t\t\tFor the active release this is a read-only object.')
xfSwReleaseOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 50, 51, 52, 53, 54, 55, 56, 57, 58, 421, 425, 426, 450, 451, 452, 501, 502, 503, 504, 530, 532, 550, 552, 553))).clone(namedValues=NamedValues(("passive", 1), ("upgradeStarted", 2), ("upgradeFinished", 3), ("testing", 4), ("upgradeFailed", 5), ("upgradeAborted", 6), ("running", 7), ("testingFromManual", 8), ("errorInternal", 50), ("errorFileStorage", 51), ("ftpPingFailed", 52), ("ftpNoAccess", 53), ("ftpConnectionDetailsMissing", 54), ("ftpConnectionDetailsInvalid", 55), ("ftpConnectionTimeout", 56), ("ftpNoSuchRemoteFile", 57), ("ftpNoSuchRemoteDir", 58), ("ftpServiceNotAvailable", 421), ("ftpUnableToOpenDataConnection", 425), ("ftpConnectionClosed", 426), ("ftpFileBusy", 450), ("ftpLocalError", 451), ("ftpInsufficientStorageSpace", 452), ("ftpSyntaxError", 501), ("ftpCommandNotImplemented", 502), ("ftpBadSequenceCommands", 503), ("ftpParameterNotImplemented", 504), ("ftpNoLoggedIn", 530), ("ftpNeedAccount", 532), ("ftpFileUnavailable", 550), ("ftpExceededStorageAllocation", 552), ("ftpFileNameNotAllowed", 553)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwReleaseOperStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseOperStatus.setDescription("Indicates the status of this release.\n\t\t\t\tpassive(1)\n\t\t\t\t  release not involved in upgrade and currently not\n\t\t\t\t  running.\n\n\t\t\t\tupgradeStarted(2)\n\t\t\t\t  the release is in the process of being upgraded\n\n\t\t\t\tupgradeFinished(3)\n\t\t\t\t  All load modules of the release are downloaded and\n\t\t\t\t  burned in the respective flash memories.\n\n\t\t\t\ttesting(4)\n\t\t\t\t  This release is running as test and not committed yet.\n\n\t\t\t\tupgradeFailed(5)\n\t\t\t\t  The upgrade to this release failed, e.g. due to FTP\n\t\t\t\t  server failure.\n\n\t\t\t\tupgradeAborted(6)\n\t\t\t\t  The manager has order to abort the upgrade to this\n\t\t\t\t  release.\n\n\t\t\t\trunning(7)\n\t\t\t\t  This is the release that is running now and all new\n\t\t\t\t  boards should upgrade to.\n\n\t\t\t\ttestingFromManual(8)\n\t\t\t\t  Same as value testing(4) but indicating that this a test phase\n\t\t\t\t  after a SBL from Manual mode. As such a fall-back will result in manual mode,\n\t\t\t\t  i.e. no SBL.\n\n\n\t\t\t\tThe 50 series errors are reported by the FTP client on\n\t\t\t\tthe node.\n\n\n\t\t\t\terrorInternalError(50)\n\t\t\t\t   An internal error detected before FTP operation.\n\n\t\t\t\terrorFileStorage(51)\n\t\t\t\t   Error when erasing flash to store the downloaded\n\t\t\t\t   file at the node.\n\n\t\t\t\tftpPingFailed(52)\n\t\t\t\t   FTP ping failed.\n\n\t\t\t\tftpNoAccess(53)\n\t\t\t\t   Not able to send the FTP commands.\n\n\t\t\t\tftpConnectionDetailsMissing(54)\n\t\t\t\t   FTP connection details are missing.\n\n\t\t\t\tftpConnectionDetailsInvalid(55)\n\t\t\t\t   FTP connection details are invalid.\n\n\t\t\t\tftpConnectionTimeout(56)\n\t\t\t\t   FTP connection timeout is detected.\n\n\t\t\t\tftpNoSuchRemoteFile(57)\n\t\t\t\t   No such remote file exists.\n\n\t\t\t\tftpNoSuchRemoteDir(58)\n\t\t\t\t   No such remote directory exists.\n\n\n\t\t\t\tThe 400 series errors occur when the command was not accepted\n\t\t\t\tand the requested action did not take place, but the error\n\t\t\t\tcondition is temporary and the action may be requested again.\n\n\n\t\t\t\tftpServiceNotAvailable(421)\n\t\t\t\t   Service not available, closing control connection. This\n\t\t\t\t   may be a reply to any command if the service knows it\n\t\t\t\t   must shut down. Possible causes are transfer timeouts\n\t\t\t\t   and/or FTP server resets.\n\n\t\t\t\tftpUnableToOpenDataConnection(425)\n\t\t\t\t  Can't open data connection. Try changing from PASV to\n\t\t\t\t  PORT mode.\n\n\t\t\t\tftpConnectionClosed(426)\n\t\t\t\t  Connection closed and file transfer is aborted. Possible\n\t\t\t\t  causes are out of local diskspace and loss of connection.\n\n\n\t\t\t\tftpFileBusy(450)\n\t\t\t\t  Requested file action not taken. File\n\t\t\t\t  unavailable (e.g file busy).\n\n\t\t\t\tftpLocalError(451)\n\t\t\t\t  Requested action aborted due to local error in processing.\n\n\t\t\t\tftpInsufficienStorageSpace(452)\n\t\t\t\t  Requested action not taken due to insufficient\n\t\t\t\t  storage space on the server.\n\n\n\t\t\t\tThe 500 series errors occur when the command was not accepted\n\t\t\t\tand the requested action did not take place.\n\n\n\t\t\t\tftpSyntaxError(501)\n\t\t\t\t  FTP Syntax error in parameters or arguments.\n\n\t\t\t\tftpCommandNotImplemented(502)\n\t\t\t\t  FTP Command not implemented.\n\n\t\t\t\tftpBadSequenceCommands(503)\n\t\t\t\t  Bad sequence of the FTP commands.\n\n\t\t\t\tftpParameterNotImplemented(504)\n\t\t\t\t  FTP command not implemented for that parameter.\n\n\t\t\t\tftpNotLoggedIn(530)\n\t\t\t\t  Not logged in. Your username and/or password is being\n\t\t\t\t  rejected, contact the server adminstrator.\n\n\t\t\t\tftpNeedAccount(532)\n\t\t\t\t  Need account for storing files.\n\n\t\t\t\tftpFileUnavailable(550)\n\t\t\t\t  Requested action not taken. File unavailable\n\t\t\t\t  (e.g.file not found, no access). Contact the server\n\t\t\t\t  adminstrator.\n\n\t\t\t\tftpExceededStorageAllocation(552)\n\t\t\t\t  Requested file action aborted.Exceeded storage allocation (for\n\t\t\t\t  current directory or data set). Contact the server adminstrator.\n\n\t\t\t\tftpFileNameNotAllowed(553)\n\t\t\t\t  Requested action not taken. File name not allowed. Try changing\n\t\t\t\t  the file name or getting rid of spaces in the file name.")
xfSwReleaseSBLType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("definedByEricsson", 1), ("definedByOperator", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwReleaseSBLType.setStatus('current')
if mibBuilder.loadTexts: xfSwReleaseSBLType.setDescription('This object indicates whether the SBL information in\n\t\t\t\tthe SBDF is generated by Ericsson or by an operator.\n\t\t\t\tThis is based on a check of the SBDF.\n\t\t\t\tOf course this will only be a reliable object when the\n\t\t\t\tsoftware can distinguish between Ericsson and operator\n\t\t\t\tdefined SBDFs, i.e. upgrading from R2A.')
xfSwActiveRelease = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 3), XfSwRelease()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwActiveRelease.setStatus('current')
if mibBuilder.loadTexts: xfSwActiveRelease.setDescription('Indicates which of the two Releases is active at the\n\t\t\t\tmoment, i.e. active is the software actually running.')
xfSwBootTime = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 4), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwBootTime.setStatus('current')
if mibBuilder.loadTexts: xfSwBootTime.setDescription('Indicates when the XF NE will warm restart to test the\n\t\t\t\tnew software release. If all fields have value 0 an\n\t\t\t\timmediate boot will be performed.')
xfSwCommitType = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operatorCommit", 1), ("nodeCommit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwCommitType.setStatus('current')
if mibBuilder.loadTexts: xfSwCommitType.setDescription('In case of a scheduled restart, i.e. valid date and\n\t\t\t\ttime in xfSwBootTime, two different commit procedures\n\t\t\t\tcan be followed:\n\t\t\t\toperatorCommit(1)\n\t\t\t\t  The manager commits the software release\n\t\t\t\t  under test by setting the xfSwRelease-\n\t\t\t\t  AdminState to activeAndRunning.\n\n\t\t\t\tnodeCommit(2)\n\t\t\t\t  The release under test is accepted when\n\t\t\t\t  the node is able to establish contact\n\t\t\t\t  through the DCN with an external IP-address.\n\n\t\t\t\tDefault values is operatorCommit(1).')
xfSwBoardTable = MibTable((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6), )
if mibBuilder.loadTexts: xfSwBoardTable.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardTable.setDescription('This table holds the information about software present\n\t\t\t\ton the boards in the XF-NE. Boards without software will\n\t\t\t\tnot be in this table.')
xfSwBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "XF-SOFTWARE-MIB", "xfSwLoadModuleIndex"))
if mibBuilder.loadTexts: xfSwBoardEntry.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardEntry.setDescription('Entry in the table.')
xfSwBoardLoadModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardLoadModuleIndex.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardLoadModuleIndex.setDescription('Index to the load module on the board. A board may\n\t\t\t\tcontain more than one load module.\n\t\t\t\t')
xfSwBoardLoadModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardLoadModuleType.setStatus('obsolete')
if mibBuilder.loadTexts: xfSwBoardLoadModuleType.setDescription('This object indicates of what type the software is,\n\t\t\t\tlike DP (Device Processor) or FPGA (Field Programmable\n\t\t\t\tGate Array) or another type. New type can be defined by\n\t\t\t\tdefining a new OID in a other MIB.\n\t\t\t\t ')
xfSwBoardProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 3), XfProductnumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardProductNumber.setDescription('This is a string indicating the product number of the\n\t\t\t\tsoftware in the active flash memory.\n\t\t\t\t')
xfSwBoardRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 4), XfProductRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardRevision.setDescription('This is a string indicating the revision of the\n\t\t\t\tsoftware in the active flash memory.')
xfSwBoardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("upgrading", 3), ("wrongSoftware", 4), ("minSoftwareRevision", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardStatus.setDescription('Indicates the status of the software on the board:\n\t\t\t\tUnknown(1)\n\t\t\t\t  The status of the software is unknown for example\n\t\t\t\t  at startup.\n\n\t\t\t\tActive(2)\n\t\t\t\t  Software on the board is OK and running\n\n\t\t\t\tUpgrading(3)\n\t\t\t\t  Software is in the process of being upgraded\n\n\t\t\t\tWrongSoftware(4)\n\t\t\t\t  Wrong software on the board and for some reason\n\t\t\t\t  not being upgraded yet.\n\n\t\t\t\tMinSoftware revision(5)\n\t\t\t\t  The board was tried to downgrade to a software revision that\n\t\t\t\t  is not compatible with the hardware.\n\n\t\t\t\tThe xfSwBoardStatus is only of use in case version control is\n\t\t\t\tenabled. If version control is not enabled the unit will always\n\t\t\t\truns its software.')
xfSwBoardSuProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardSuProgress.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardSuProgress.setDescription('This object indicates the progress of the software\n\t\t\t\tupgrade process for each individual PIU. This indicates\n\t\t\t\tboth flash erasing and programming.\n\t\t\t\tThis object indicates this for both upgrade to a\n\t\t\t\tbaseline as well as for inserted PIUs.\n\t\t\t\tIn case the software upgrade of the board takes less\n\t\t\t\tthan 10 seconds this objects will directly go to 100%.')
xfSwBoardMinProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 7), XfProductnumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardMinProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardMinProductNumber.setDescription('This is a string indicating the product number of the\n\t\t\t\tminimally acceptable software revision for this unit\n\t\t\t\ttype/variant.\n\t\t\t\t')
xfSwBoardMinRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 8), XfProductRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardMinRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardMinRevision.setDescription('This is a string indicating the revision of the\n\t\t\t\tminimally acceptable software revision for this unit\n\t\t\t\ttype/variant.')
xfSwBoardTrafficDisturbance = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("disturbing", 2), ("notDisturbing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwBoardTrafficDisturbance.setStatus('current')
if mibBuilder.loadTexts: xfSwBoardTrafficDisturbance.setDescription('This object indicates that software upgrade of this\n\t\t\t\tload module on this unit might lead to traffic\n\t\t\t\tdisturbance. This could for example happen in the\n\t\t\t\texceptional case where the load module includes FPGA\n\t\t\t\tcode for the traffic system.')
xfSwNpuObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 7))
xfSwNpuPassiveProductNumber = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 7, 1), XfProductnumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwNpuPassiveProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwNpuPassiveProductNumber.setDescription('Product number of NPU software in passive bank.')
xfSwNpuPassiveRevision = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 7, 2), XfProductRevision()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwNpuPassiveRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwNpuPassiveRevision.setDescription('Revision of software in passive bank on NPU.')
xfSwNpuPassiveSwitch = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("switch", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwNpuPassiveSwitch.setStatus('current')
if mibBuilder.loadTexts: xfSwNpuPassiveSwitch.setDescription('This object can be used to switch the NPU passive\n\t\t\t\tsoftware.\n\t\t\t\tAs a safety precaution this object is\n\t\t\t\tonly available when the node is in installation mode\n\t\t\t\tor when the node is accessed through the USB port\n\t\t\t\t(if present).\n\t\t\t\tA warm restart is required to activate the fallback.\n\t\t\t\tA switch leads to all xfSwUpgradePreferences being set\n\t\t\t\tto their default values, i.e. no version control.')
xfSwLoadModuleTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 8))
xfDeviceProcessorSoftware = ObjectIdentity((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 8, 1))
if mibBuilder.loadTexts: xfDeviceProcessorSoftware.setStatus('obsolete')
if mibBuilder.loadTexts: xfDeviceProcessorSoftware.setDescription('Used for DP software load modules.')
xfPciFpgaCode = ObjectIdentity((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 8, 2))
if mibBuilder.loadTexts: xfPciFpgaCode.setStatus('obsolete')
if mibBuilder.loadTexts: xfPciFpgaCode.setDescription('Used for PCI FPGA load modules.')
xfSwUpgradePreferences = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 9))
xfSwVersionControl = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 9, 1), XfSwEnableDisable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwVersionControl.setStatus('current')
if mibBuilder.loadTexts: xfSwVersionControl.setDescription('Used to enable/disable version control.\n\t\t\t\tDefault: disable.')
xfSwAutoUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 9, 2), XfSwEnableDisable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwAutoUpgrade.setStatus('current')
if mibBuilder.loadTexts: xfSwAutoUpgrade.setDescription('Used to enable/disable automatic software upgrade.\n\t\t\t\tIn case xfSwVersionControl is enabled a change of the\n\t\t\t\tvalue will cause all PIUs to be checked again.\n\n\t\t\t\tDefault: disable.')
xfSwAutoDowngrade = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 9, 3), XfSwEnableDisable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwAutoDowngrade.setStatus('current')
if mibBuilder.loadTexts: xfSwAutoDowngrade.setDescription('Used to enable/disable automatic software downgrade.\n\t\t\t\tIn case xfSwVersionControl is enabled a change of the\n\t\t\t\tvalue will cause all PIUs to be checked again.\n\t\t\t\tDefault: disable.')
xfSwAcceptFailure = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 9, 4), XfSwEnableDisable()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwAcceptFailure.setStatus('current')
if mibBuilder.loadTexts: xfSwAcceptFailure.setDescription("Used to enable/disable setting of new PIUs, that fail\n\t\t\t\tto up/downgrade, in  'out of service'. PIUs that are\n\t\t\t\tout of service will not be taken into service on the\n\t\t\t\tdisable/enable transistion.\n\t\t\t\tDefault: enable.")
xfSwLmUpgradeTable = MibTable((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10), )
if mibBuilder.loadTexts: xfSwLmUpgradeTable.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeTable.setDescription('This table is used to upgrade a single load module. For\n\t\t\t\teach known load module an entry is present.')
xfSwLmUpgradeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1), ).setIndexNames((0, "XF-SOFTWARE-MIB", "xfSwLmUpgradeIndex"))
if mibBuilder.loadTexts: xfSwLmUpgradeEntry.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeEntry.setDescription('Entry in the table.')
xfSwLmUpgradeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeIndex.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeIndex.setDescription('Objects used to index the table.')
xfSwLmUpgradeProductNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 3), XfProductnumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeProductNumber.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeProductNumber.setDescription("Product number of the load module. Normally something\n\t\t\t\tlike 'CAXR102_012/1'.")
xfSwLmUpgradeRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 4), XfProductRevision()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwLmUpgradeRevision.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeRevision.setDescription("Revision to which the load module should be upgraded.\n\t\t\t\tNormally something like 'R1A'.")
xfSwLmUpgradeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("upgradeStarted", 1), ("upgradeAborted", 2), ("activeAndRunning", 3), ("upgradeTest", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xfSwLmUpgradeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeAdminStatus.setDescription('Indicates the desired status for this release. To start\n\t\t\t\ta software upgrade the manager has to set\n\t\t\t\txfSwLmUpgradeRevision. After that it will set this\n\t\t\t\tobject to upgradeStarted. Which will lead to downloading\n\t\t\t\tthe SBDF-file from the FTP Server. For the active release\n\t\t\t\twrite is possible but will have no impact.')
xfSwLmUpgradeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 50, 51, 52, 53, 54, 55, 56, 57, 58, 421, 425, 426, 450, 451, 452, 501, 502, 503, 504, 530, 532, 550, 552, 553))).clone(namedValues=NamedValues(("active", 1), ("upgradeStarted", 2), ("upgradeFinished", 3), ("upgradeTested", 4), ("upgradeFailed", 5), ("upgradeAborted", 6), ("errorInternalError", 50), ("errorFileStorage", 51), ("ftpPingFailed", 52), ("ftpNoAccess", 53), ("ftpConnectionDetailsMissing", 54), ("ftpConnectionDetailsInvalid", 55), ("ftpConnectionTimeout", 56), ("ftpNoSuchRemoteFile", 57), ("ftpNoSuchRemoteDir", 58), ("ftpServiceNotAvailable", 421), ("ftpUnableToOpenDataConnection", 425), ("ftpConnectionClosed", 426), ("ftpFileBusy", 450), ("ftpLocalError", 451), ("ftpInsufficienStorageSpace", 452), ("ftpSyntaxError", 501), ("ftpCommandNotImplemented", 502), ("ftpBadSequenceCommands", 503), ("ftpParameterNotImplemented", 504), ("ftpNotLoggedIn", 530), ("ftpNeedAccount", 532), ("ftpFileUnavailable", 550), ("ftpExceededStorageAllocation", 552), ("ftpFileNameNotAllowed", 553)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeOperStatus.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeOperStatus.setDescription("Indicates the status of the software upgrade process\n\t\t\t\tfor this load module.\n\t\t\t\tactive(1)\n\t\t\t\t   the load module is active and running on the PIU.\n\n\t\t\t\tupgradeStarted(2)\n\t\t\t\t   a load module will have this status directly\n\t\t\t\t   after the SRDF info for this module is loaded\n\t\t\t\t   and the xfSwLmUpgradeAdminStatus of the\n\t\t\t\t   release was set to upgradeStarted.\n\n\t\t\t\tupgradeFinished(3)\n\t\t\t\t   indicates that this load modules has been retreived\n\t\t\t\t   and burned into the flash memories.This is the\n\t\t\t\t   state of load modules that are part of an active\n\t\t\t\t   release.\n\n\t\t\t\tupgradeTested(4)\n\t\t\t\t  This release is running as test and not committed\n\t\t\t\t  yet.\n\n\t\t\t\tupgradeFailed(5)\n\t\t\t\t   upgraded has failed for a reason, e.g. file transfer\n\t\t\t\t   checksum was wrong, see xfSwLmUpgradeFailure.\n\n\t\t\t\tupgradeAborted(6)\n\t\t\t\t   when the manager has aborted the upgrade of the\n\t\t\t\t   complete release whilst this load module wasn't\n\t\t\t\t   upgradedFinished yet this will be its status.\n\n\n\n\t\t\t\tThe 50 series errors are reported by the FTP client on\n\t\t\t\tthe node.\n\n\n\t\t\t\terrorInternalError(50)\n\t\t\t\t   An internal error detected before FTP operation.\n\n\t\t\t\terrorFileStorage(51)\n\t\t\t\t   Error when erasing flash to store the downloaded\n\t\t\t\t   file at the node.\n\n\t\t\t\tftpPingFailed(52)\n\t\t\t\t   FTP ping failed.\n\n\t\t\t\tftpNoAccess(53)\n\t\t\t\t   Not able to send the FTP commands.\n\n\t\t\t\tftpConnectionDetailsMissing(54)\n\t\t\t\t   FTP connection details are missing.\n\n\t\t\t\tftpConnectionDetailsInvalid(55)\n\t\t\t\t   FTP connection details are invalid.\n\n\t\t\t\tftpConnectionTimeout(56)\n\t\t\t\t   FTP connection timeout is detected.\n\n\t\t\t\tftpNoSuchRemoteFile(57)\n\t\t\t\t   No such remote file exists.\n\n\t\t\t\tftpNoSuchRemoteDir(58)\n\t\t\t\t   No such remote directory exists.\n\n\n\t\t\t\tThe 400 series errors occur when the command was not accepted\n\t\t\t\tand the requested action did not take place, but the error\n\t\t\t\tcondition is temporary and the action may be requested again.\n\n\n\t\t\t\tftpServiceNotAvailable(421)\n\t\t\t\t   Service not available, closing control connection. This\n\t\t\t\t   may be a reply to any command if the service knows it\n\t\t\t\t   must shut down. Possible causes are transfer timeouts\n\t\t\t\t   and/or FTP server resets.\n\n\t\t\t\tftpUnableToOpenDataConnection(425)\n\t\t\t\t  Can't open data connection. Try changing from PASV to\n\t\t\t\t  PORT mode.\n\n\t\t\t\tftpConnectionClosed(426)\n\t\t\t\t  Connection closed and file transfer is aborted. Possible\n\t\t\t\t  causes are out of local diskspace and loss of connection.\n\n\n\t\t\t\tftpFileBusy(450)\n\t\t\t\t  Requested file action not taken. File\n\t\t\t\t  unavailable (e.g file busy).\n\n\t\t\t\tftpLocalError(451)\n\t\t\t\t  Requested action aborted due to local error in processing.\n\n\t\t\t\tftpInsufficienStorageSpace(452)\n\t\t\t\t  Requested action not taken due to insufficient\n\t\t\t\t  storage space on the server.\n\n\n\t\t\t\tThe 500 series errors occur when the command was not accepted\n\t\t\t\tand the requested action did not take place.\n\n\n\t\t\t\tftpSyntaxError(501)\n\t\t\t\t  FTP Syntax error in parameters or arguments.\n\n\t\t\t\tftpCommandNotImplemented(502)\n\t\t\t\t  FTP Command not implemented.\n\n\t\t\t\tftpBadSequenceCommands(503)\n\t\t\t\t  Bad sequence of the FTP commands.\n\n\t\t\t\tftpParameterNotImplemented(504)\n\t\t\t\t  FTP command not implemented for that parameter.\n\n\t\t\t\tftpNotLoggedIn(530)\n\t\t\t\t  Not logged in. Your username and/or password is being\n\t\t\t\t  rejected, contact the server adminstrator.\n\n\t\t\t\tftpNeedAccount(532)\n\t\t\t\t  Need account for storing files.\n\n\t\t\t\tftpFileUnavailable(550)\n\t\t\t\t  Requested action not taken. File unavailable\n\t\t\t\t  (e.g.file not found, no access). Contact the server\n\t\t\t\t  adminstrator.\n\n\t\t\t\tftpExceededStorageAllocation(552)\n\t\t\t\t  Requested file action aborted.Exceeded storage allocation (for\n\t\t\t\t  current directory or data set). Contact the server adminstrator.\n\n\t\t\t\tftpFileNameNotAllowed(553)\n\t\t\t\t  Requested action not taken. File name not allowed. Try changing\n\t\t\t\t  the file name or getting rid of spaces in the file name.\n\t\t\t\t")
xfSwLmUpgradeProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeProgress.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeProgress.setDescription('This object indicates the progress in downloading\n\t\t\t\tthe respective load module when part of an upgrade of\n\t\t\t\tan inserted PIU.')
xfSwLmUpgradeFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("downloadFailure", 1), ("programFailure", 2), ("noFailure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeFailure.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeFailure.setDescription('This object specifies the cause of a software\n\t\t\t\tupgrade failure. ')
xfSwLmUpgradeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 10, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwLmUpgradeDescription.setStatus('current')
if mibBuilder.loadTexts: xfSwLmUpgradeDescription.setDescription('This object indicates a textual\n\t\t\t\tdescription of the load module, indicating PIU type\n\t\t\t\tas stated by the entPhysicalDescription MO.')
xfSwGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 1, 11), Bits().clone(namedValues=NamedValues(("noUpgrade", 0), ("sblStarted", 1), ("sblWaitForActivate", 2), ("sblWaitForCommit", 3), ("manualStarted", 4), ("manualWaitForActivate", 5), ("manualWaitForCommit", 6), ("unitUpgrade", 7), ("cachingLoadModules", 8), ("preparingForTest", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xfSwGlobalState.setStatus('current')
if mibBuilder.loadTexts: xfSwGlobalState.setDescription('This objecty indicates the global state of the\n\t\t\t\tSoftware Upgrade process.\n\t\t\t\tnoUpgrade(0), no Software upgrade ongoing\n\n\t\t\t\tsblStarted(1), a SBL upgrade is started and SBDF and Load Modules are downloading\n\n\t\t\t\tsblWaitForActivate(2), a SBL upgrade is finished and waiting for an activation\n\n\t\t\t\tsblWaitForCommit(3), a SBL upgrade is in test phase and waiting for commit\n\n\t\t\t\tmanualStarted(4), a manual upgrade is started and Load Modules are downloading\n\n\t\t\t\tmanualWaitForActivate(5), a manual upgrade is finished and waiting for an activation\n\n\n\t\t\t\tmanualWaitForCommit(6), a manual upgrade is in test phase and waiting for commit\n\n\t\t\t\tunitUpgrade(7), an unit is inserted and in the process of upgrading\n\n\t\t\t\tcachingLoadModules(8), software upgrade is in the process of downloading the load\n\t\t\t\t                       modules for cache.\n\n\t\t\t\tpreparingForTest(9),   a period after a power-up/restart the node prepares to enter\n\t\t\t\t                       the test phase. During this period some units might restart\n\t\t\t\t                       and it is not possible to commit the software upgrade.')
xfSwConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2))
xfSwCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 1))
xfSwFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 1, 1)).setObjects(("XF-SOFTWARE-MIB", "xfSwGroup"), ("XF-SOFTWARE-MIB", "xSwGroupR2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    xfSwFullCompliance = xfSwFullCompliance.setStatus('current')
if mibBuilder.loadTexts: xfSwFullCompliance.setDescription('The compliance statement for SNMP entities which\n\t\t\t\timplement everything.')
xfSwGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 2))
xfSwGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 2, 1)).setObjects(("XF-SOFTWARE-MIB", "xfSwRelease"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleIndex"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleProductNumber"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleRevision"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleOperStatus"), ("XF-SOFTWARE-MIB", "xfSwReleaseIndex"), ("XF-SOFTWARE-MIB", "xfSwReleaseProductNumber"), ("XF-SOFTWARE-MIB", "xfSwReleaseRevision"), ("XF-SOFTWARE-MIB", "xfSwReleaseAdminStatus"), ("XF-SOFTWARE-MIB", "xfSwReleaseOperStatus"), ("XF-SOFTWARE-MIB", "xfSwActiveRelease"), ("XF-SOFTWARE-MIB", "xfSwBootTime"), ("XF-SOFTWARE-MIB", "xfSwCommitType"), ("XF-SOFTWARE-MIB", "xfSwBoardProductNumber"), ("XF-SOFTWARE-MIB", "xfSwBoardRevision"), ("XF-SOFTWARE-MIB", "xfSwNpuPassiveProductNumber"), ("XF-SOFTWARE-MIB", "xfSwNpuPassiveSwitch"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleFailure"), ("XF-SOFTWARE-MIB", "xfSwNpuPassiveRevision"), ("XF-SOFTWARE-MIB", "xfSwBoardStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    xfSwGroup = xfSwGroup.setStatus('current')
if mibBuilder.loadTexts: xfSwGroup.setDescription('Group of all software related objects.')
xSwGroupR2 = ObjectGroup((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 2, 2)).setObjects(("XF-SOFTWARE-MIB", "xfSwBoardSuProgress"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeIndex"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeProductNumber"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeRevision"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeAdminStatus"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeOperStatus"), ("XF-SOFTWARE-MIB", "xfSwBoardMinProductNumber"), ("XF-SOFTWARE-MIB", "xfSwBoardMinRevision"), ("XF-SOFTWARE-MIB", "xfSwVersionControl"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleProgress"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeFailure"), ("XF-SOFTWARE-MIB", "xfSwBoardTrafficDisturbance"), ("XF-SOFTWARE-MIB", "xfSwReleaseSBLType"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeProgress"), ("XF-SOFTWARE-MIB", "xfSwAutoUpgrade"), ("XF-SOFTWARE-MIB", "xfSwAutoDowngrade"), ("XF-SOFTWARE-MIB", "xfSwGlobalState"), ("XF-SOFTWARE-MIB", "xfSwAcceptFailure"), ("XF-SOFTWARE-MIB", "xfSwLoadModuleDescription"), ("XF-SOFTWARE-MIB", "xfSwLmUpgradeDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    xSwGroupR2 = xSwGroupR2.setStatus('current')
if mibBuilder.loadTexts: xSwGroupR2.setDescription('All objects added for MINI-LINK Traffic Node R2.')
xfSwObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 193, 81, 2, 7, 2, 2, 3)).setObjects(("XF-SOFTWARE-MIB", "xfSwBoardLoadModuleIndex"), ("XF-SOFTWARE-MIB", "xfSwBoardLoadModuleType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    xfSwObsoleteGroup = xfSwObsoleteGroup.setStatus('obsolete')
if mibBuilder.loadTexts: xfSwObsoleteGroup.setDescription('Description.')
mibBuilder.exportSymbols("XF-SOFTWARE-MIB", xfSwReleaseTable=xfSwReleaseTable, xfSwGroups=xfSwGroups, xfSwNpuPassiveSwitch=xfSwNpuPassiveSwitch, xfSwObjects=xfSwObjects, xfSwLoadModuleEntry=xfSwLoadModuleEntry, xfSwLmUpgradeProgress=xfSwLmUpgradeProgress, xfSwLmUpgradeDescription=xfSwLmUpgradeDescription, xfSwAutoUpgrade=xfSwAutoUpgrade, xfSwActiveRelease=xfSwActiveRelease, xfSwUpgradePreferences=xfSwUpgradePreferences, xfSwReleaseAdminStatus=xfSwReleaseAdminStatus, xfSwReleaseOperStatus=xfSwReleaseOperStatus, xfSwLoadModuleProgress=xfSwLoadModuleProgress, xfSwObsoleteGroup=xfSwObsoleteGroup, xfSwBoardStatus=xfSwBoardStatus, xfSwLoadModuleProductNumber=xfSwLoadModuleProductNumber, xfSwVersionControl=xfSwVersionControl, xfSwLmUpgradeIndex=xfSwLmUpgradeIndex, xfSwNpuPassiveProductNumber=xfSwNpuPassiveProductNumber, xfSwRelease=xfSwRelease, xfSwReleaseSBLType=xfSwReleaseSBLType, xfSwBoardEntry=xfSwBoardEntry, xfSwBoardSuProgress=xfSwBoardSuProgress, xfSwLoadModuleTypes=xfSwLoadModuleTypes, xfPciFpgaCode=xfPciFpgaCode, PYSNMP_MODULE_ID=xfSoftwareMIB, xfSwLmUpgradeFailure=xfSwLmUpgradeFailure, xfSwBoardLoadModuleType=xfSwBoardLoadModuleType, XfSwEnableDisable=XfSwEnableDisable, xfSwAcceptFailure=xfSwAcceptFailure, xfSwCompliances=xfSwCompliances, xfSwBootTime=xfSwBootTime, xfSwLmUpgradeEntry=xfSwLmUpgradeEntry, xfSwFullCompliance=xfSwFullCompliance, xfSwReleaseEntry=xfSwReleaseEntry, xfSwLmUpgradeTable=xfSwLmUpgradeTable, xfSwAutoDowngrade=xfSwAutoDowngrade, xfSwLoadModuleTable=xfSwLoadModuleTable, xfSwLoadModuleRevision=xfSwLoadModuleRevision, xfSwBoardRevision=xfSwBoardRevision, xfSwLoadModuleFailure=xfSwLoadModuleFailure, xfSwNpuObjects=xfSwNpuObjects, XfSwRelease=XfSwRelease, xfSwLoadModuleIndex=xfSwLoadModuleIndex, xfSwReleaseRevision=xfSwReleaseRevision, xfSwLmUpgradeAdminStatus=xfSwLmUpgradeAdminStatus, xfSwGroup=xfSwGroup, xfSwBoardMinRevision=xfSwBoardMinRevision, xfSwReleaseIndex=xfSwReleaseIndex, xfSwLmUpgradeOperStatus=xfSwLmUpgradeOperStatus, xfSwBoardProductNumber=xfSwBoardProductNumber, xfSwReleaseProductNumber=xfSwReleaseProductNumber, xfSwNpuPassiveRevision=xfSwNpuPassiveRevision, xfSwBoardTable=xfSwBoardTable, xSwGroupR2=xSwGroupR2, xfSwLmUpgradeProductNumber=xfSwLmUpgradeProductNumber, xfSwBoardTrafficDisturbance=xfSwBoardTrafficDisturbance, xfSwLoadModuleOperStatus=xfSwLoadModuleOperStatus, xfSwLmUpgradeRevision=xfSwLmUpgradeRevision, xfSwCommitType=xfSwCommitType, xfSwGlobalState=xfSwGlobalState, xfDeviceProcessorSoftware=xfDeviceProcessorSoftware, xfSwLoadModuleDescription=xfSwLoadModuleDescription, xfSoftwareMIB=xfSoftwareMIB, xfSwConformance=xfSwConformance, xfSwBoardLoadModuleIndex=xfSwBoardLoadModuleIndex, xfSwBoardMinProductNumber=xfSwBoardMinProductNumber)
