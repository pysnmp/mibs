#
# PySNMP MIB module LIEBERT-GP-POWER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/liebert/LIEBERT-GP-POWER-MIB
# Produced by pysmi-1.1.8 at Sun Jan 16 15:34:06 2022
# On host fv-az36-128 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
liebertPowerModuleReg, lgpPower = mibBuilder.importSymbols("LIEBERT-GP-REGISTRATION-MIB", "liebertPowerModuleReg", "lgpPower")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, TimeTicks, NotificationType, Integer32, ObjectIdentity, IpAddress, MibIdentifier, Gauge32, iso, ModuleIdentity, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "TimeTicks", "NotificationType", "Integer32", "ObjectIdentity", "IpAddress", "MibIdentifier", "Gauge32", "iso", "ModuleIdentity", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
liebertGlobalProductsPowerModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 1, 6, 1))
liebertGlobalProductsPowerModule.setRevisions(('2013-07-10 00:00', '2008-11-17 00:00', '2008-07-02 00:00', '2008-01-10 00:00', '2006-02-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setRevisionsDescriptions(('Added support for GXT4 economic operation mode and outlet control.', 'Added support for NXL unit.', 'Replaced INTEGER with Integer32 (SMIv2).\n     Minor spelling fixes and formatting.', 'Modified contact email address and removed redundant\n    lgpPwrMeasurementPointNumLines.', 'Added support for Liebert DS Unit.',))
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setLastUpdated('201307100000Z')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setOrganization('Liebert Corporation')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setContactInfo('Contact:   Technical Support\n\n      Postal:\n      Liebert Corporation\n      1050 Dearborn Drive\n      P.O. Box 29186\n      Columbus OH, 43229\n      US\n\n      Tel: +1 (800) 222-5877\n\n      E-mail: liebert.monitoring@vertivco.com\n      Web:    www.vertivco.com\n\n      Author:  Gregory M. Hoge')
if mibBuilder.loadTexts: liebertGlobalProductsPowerModule.setDescription("The MIB module used to register Liebert POWER related SNMP OIDs.\n\n      Copyright 2000-2008 Liebert Corporation. All rights reserved.\n      Reproduction of this document is authorized on the condition\n      that the forgoing copyright notice is included.\n\n      This Specification is supplied 'AS IS' and Liebert Corporation\n      makes no warranty, either express or implied, as to the use,\n      operation, condition, or performance of the Specification.")
lgpPwrBattery = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1))
if mibBuilder.loadTexts: lgpPwrBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBattery.setDescription('This sub-tree is used to register Liebert Power Battery object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrBattery.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Battery Group.')
lgpPwrMeasurements = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2))
if mibBuilder.loadTexts: lgpPwrMeasurements.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurements.setDescription('This sub-tree registers Liebert Power Measurement object\n        identifiers.  The sub-tree contains tables and well known power\n        measurement points.')
if mibBuilder.loadTexts: lgpPwrMeasurements.setReference('The registrations for the objects in this sub-tree are defined\n         below in the sub-section titled Liebert Power Measurement Group.')
lgpPwrStatus = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3))
if mibBuilder.loadTexts: lgpPwrStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatus.setDescription('This sub-tree registers Liebert Power Status object\n        identifiers.  This is the location of power related status information\n        that does not fit into a more specific category such as the\n        lgpPwrConversion sub-tree.')
if mibBuilder.loadTexts: lgpPwrStatus.setReference('The registrations for the objects in this sub-tree are defined\n         below in the sub-section titled Liebert Power Status Group')
lgpPwrSettings = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4))
if mibBuilder.loadTexts: lgpPwrSettings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSettings.setDescription('This sub-tree registers Liebert Power Static Switch object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrSettings.setReference('The registrations for the objects in this sub-tree are defined\n         below in the sub-section titled Liebert Power Settings Group.')
lgpPwrConversion = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5))
if mibBuilder.loadTexts: lgpPwrConversion.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConversion.setDescription('This sub-tree is used to register Liebert Power Conversion object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrConversion.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Conversion Group.')
lgpPwrControl = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6))
if mibBuilder.loadTexts: lgpPwrControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrControl.setDescription('This sub-tree is used to register Liebert Power Control object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrControl.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Control Group.')
lgpPwrTopology = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7))
if mibBuilder.loadTexts: lgpPwrTopology.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopology.setDescription('This sub-tree is used to register Liebert Power Topology object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrTopology.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Topology Group.')
lgpPwrStatistic = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8))
if mibBuilder.loadTexts: lgpPwrStatistic.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatistic.setDescription('This sub-tree is used to register Liebert Power Statistic object\n        identifiers.')
if mibBuilder.loadTexts: lgpPwrStatistic.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Statistic Group.')
lgpPwrConfig = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9))
if mibBuilder.loadTexts: lgpPwrConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConfig.setDescription('This sub-tree is used to register Liebert Power Configuration\n         Object identifiers.')
if mibBuilder.loadTexts: lgpPwrConfig.setReference('The registrations for the objects in this sub-tree are\n        defined below in the sub-section titled Liebert Power Configuration\n        Group.')
lgpPwrNumberInstalledBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberInstalledBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberInstalledBatteryModules.setDescription('The number of battery modules installed in the device.')
lgpPwrNumberFailedBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberFailedBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberFailedBatteryModules.setDescription('The number of battery modules in the device that have failed.')
lgpPwrNumberRedundantBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberRedundantBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberRedundantBatteryModules.setDescription('The number of redundant battery modules in the device.')
lgpPwrNumberActiveBatteryModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberActiveBatteryModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberActiveBatteryModules.setDescription('The number of active battery modules in the device.')
lgpPwrConfigLowBatteryWarningTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 5), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrConfigLowBatteryWarningTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrConfigLowBatteryWarningTime.setDescription("The value of the device's estimated minutes of remaining battery\n        at which a lgpEventLowBatteryWarning notification will be sent.")
lgpPwrNumberBatteryModuleWarnings = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberBatteryModuleWarnings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberBatteryModuleWarnings.setDescription('The number of battery modules in the device that have a warning.')
lgpPwrBatteryCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 7), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCount.setDescription('The number of batteries installed.')
lgpPwrBatteryTestResult = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("systemFailure", 5), ("inhibited", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryTestResult.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTestResult.setDescription('The outcome of the previous battery test.')
lgpPwrNominalBatteryCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 9), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNominalBatteryCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalBatteryCapacity.setDescription('The nominal battery capacity of the system (in minutes) at full load.')
lgpPwrBatteryFloatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 10), Integer32()).setUnits('Volt').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryFloatVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryFloatVoltage.setDescription('The battery float voltage of the system.')
lgpPwrBatteryEndOfDischargeVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryEndOfDischargeVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryEndOfDischargeVoltage.setDescription('The battery voltage threshold at which the batteries are considered\n        completely discharged.')
lgpPwrAutomaticBatteryTestInterval = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 12), Integer32()).setUnits('hours').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestInterval.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestInterval.setDescription('The automatic battery test interval.')
lgpPwrAutomaticBatteryTestCountdown = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 13), Integer32()).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestCountdown.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTestCountdown.setDescription('The time remaining before the next battery test.')
lgpPwrBatteryChargeStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fullycharged", 1), ("notfullycharged", 2), ("charging", 3), ("discharging", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeStatus.setDescription("The present state of the system's battery charge.\n        A value of 'charging' indicates the batteries are currently charging.\n        A value of 'discharging' indicates the batteries are currently\n        discharging.  A value of 'fullycharged' indicates the batteries are\n        charged to their full capacity.  A value of 'notfullycharged' indicates\n        the battery charge is neither fully charged, charging or discharging.")
lgpPwrBatteryLifeEnhancer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryLifeEnhancer.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLifeEnhancer.setDescription("The state of the battery life enhancer.  When 'on', it will\n        preserve battery life.")
lgpPwrBatteryCharger = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCharger.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCharger.setDescription('The state of the battery charger.')
lgpPwrBatteryChargeMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("float", 1), ("equalize", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeMode.setDescription("The mode of the battery charger: 'float' charging or 'equalize'\n        charging.")
lgpPwrBatteryTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 18), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTimeRemaining.setDescription('An estimate of the time to battery charge depletion under the present\n        load conditions if the utility power is off and remains off, or if it\n        were to be lost and remain off.\n\n        NOTE: A UPS is expected to provide a battery time remaining value \n        when not operating on battery. However, if the system is not capable of \n        providing this information, then this point will return 65535 to\n        indicate that the value is unavailable.')
lgpPwrBatteryCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 19), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCapacity.setDescription('The present percentage of battery capacity.')
lgpPwrBatteryCabinet = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20))
if mibBuilder.loadTexts: lgpPwrBatteryCabinet.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinet.setDescription('This sub-tree contains items related to battery cabinets.')
lgpPwrBatteryCabinetCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 1), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetCount.setDescription('The number of battery cabinets installed with this device.\n             Note some devices may not permit writing a value to this object.')
lgpPwrBatteryCabinetType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSpecified", 1), ("internal", 2), ("external", 3), ("lrt", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetType.setDescription("The type of battery cabinet(s) installed on this device.\n             Enumeration definitions:\n                 notSpecified - The type has not been specified in the\n                                device's configuration.\n                 internal     - Battery cabinets are internal to the device.\n                 external     - Device has external battery cabinets installed.\n                 lrt          - Long Run Time cabinets.\n             Note some devices may not permit writing a value to this object.")
lgpPwrBatteryCabinetRatedCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 3), Integer32()).setUnits('0.1 Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryCabinetRatedCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCabinetRatedCapacity.setDescription('Battery cabinet rated capacity (tenths of Amp-hours).\n             This assumes that each cabinet is of the same type and capacity.\n             This is not a sum of the rating for all attached cabinets.\n             Note some devices may not permit writing a value to this object.')
lgpPwrBatteryLeadAcidCellCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 4), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLeadAcidCellCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLeadAcidCellCount.setDescription('Battery cell count - lead-acid. The number of cells that comprise \n            the lead acid battery string.')
lgpPwrBatteryNiCadCellCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 20, 5), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryNiCadCellCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryNiCadCellCount.setDescription('Battery cell count - nickel-cadmium. The number of cells that \n            comprise the nickel-cadmium battery string.')
lgpPwrBatteryAmpHoursConsumed = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 21), Integer32()).setUnits('Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursConsumed.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursConsumed.setDescription('The cumulative battery Amp-hours withdrawn over the life of the\n        battery. This value persists across reboots. Typically, this value is\n        reset back to zero when the batteries are replaced.')
lgpPwrBatteryAmpHoursDischargeConsumed = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 22), Integer32()).setUnits('Amp-hour').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursDischargeConsumed.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHoursDischargeConsumed.setDescription('The battery Amp-hours withdrawn during the current/latest\n        discharge. This value does not persist across reboots.')
lgpPwrBatteryLastDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 23), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLastDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLastDischargeTime.setDescription('The date and time of the last battery discharge. Typically this is the\n        time when the discharge starts. This value persists across reboots. \n        The date and time are determined in seconds since the epoch on \n        January 1, 1970.')
lgpPwrBatteryLastCommissionTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 24), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryLastCommissionTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryLastCommissionTime.setDescription('The date and time when the battery system was put into service.\n        This information persists across system reboot events. It is the\n        responsibility of Service to reset this date/time when the batteries\n        are replaced. The date and time are determined in seconds since the \n        epoch on January 1, 1970.')
lgpPwrBatteryPresentDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 25), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryPresentDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryPresentDischargeTime.setDescription('The total time spent on battery during the current or last discharge.\n\n        NOTE: While not discharging, some systems may display zero instead of\n        the last discharge.')
lgpPwrBatteryCapacityStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("batteryNormal", 2), ("batteryLow", 3), ("batteryDepleted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCapacityStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCapacityStatus.setDescription("The indication of the capacity remaining in the UPS\n        system's batteries.\n\n        NOTE: In a single-module system, this point is intended to have the same \n        behavior as the RFC1628 point upsBatteryStatus.")
lgpPwrBatteryCircuitBreakerState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("open", 1), ("closed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryCircuitBreakerState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryCircuitBreakerState.setDescription('The state of the Battery Circuit Breaker.')
lgpPwrWellKnownMeasurementPoints = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1))
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setDescription("This sub-tree registers well known Liebert Power Measurement\n         Points.  The object identifier names usually imply locations\n         where the measurement is taken -- such as 'input', 'output'\n         and 'bypass'.")
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementPoints.setReference("These well known measurement identifiers are referenced in the\n         'lgpPwrMeasurementPointId' column in the\n         'lgpPwrMeasurementPointTable'.")
lgpPwrSource1Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 1))
if mibBuilder.loadTexts: lgpPwrSource1Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSource1Input.setDescription("This sub-tree is used to register a source 1 input as a\n            well known measurement point.  It is intended that no sub-trees\n            be created below this node.\n\n            Power input to the managed device from power source 1.\n            Many power systems contain more than one input source and\n            many of them have more than one measurement point per input\n            source.  This identifier represents one input source for the\n            system but does not necessarily represent the 'first' one.\n            The input sources' numbering with respect to\n            'lgpPwrSource1Input' etc. may depend on the physical wiring\n            of the system when it was installed.")
lgpPwrSource2Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 2))
if mibBuilder.loadTexts: lgpPwrSource2Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSource2Input.setDescription("This sub-tree is used to register a source 2 input as a\n            well known measurement point.  It is intended that no sub-trees\n            be created below this node.\n\n            Power input to the managed device from power source 2.\n            Many power systems contain more than one input source and\n            many of them have more than one measurement point per input\n            source.  This identifier represents one input source for the\n            system but does not necessarily represent the 'first' one.\n            The input sources' numbering with respect to\n            'lgpPwrSource2Input' etc. may depend on the physical wiring\n            of the system when it was installed.")
lgpPwrSourcePdu1Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 3))
if mibBuilder.loadTexts: lgpPwrSourcePdu1Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSourcePdu1Input.setDescription("This sub-tree is used to register a source PDU 1 input as a\n            well known measurement point.  It is intended that no sub-trees\n            be created below this node.\n\n            Power input to the managed device from power distribution\n            unit 1. Many power systems contain more than one input source\n            and many of them have more than one measurement point per input\n            source.  This identifier represents one input source for the\n            system but does not necessarily represent the 'first' one.\n            The input sources' numbering with respect to\n            'lgpPwrSourcePdu1Input' etc. may depend on the physical wiring\n            of the system when it was installed.")
lgpPwrSourcePdu2Input = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 4))
if mibBuilder.loadTexts: lgpPwrSourcePdu2Input.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSourcePdu2Input.setDescription("This sub-tree is used to register a source PDU 2 input as a\n            well known measurement point.  It is intended that no sub-trees\n            be created below this node.\n\n            Power input to the managed device from power distribution\n            unit 1.  Many power systems contain more than one input source\n            and many of them have more than one measurement point per input\n            source.  This identifier represents one input source for the\n            system but does not necessarily represent the 'first' one.\n            The input sources' numbering with respect to\n            'lgpPwrSourcePdu2Input' etc. may depend on the physical wiring\n            of the system when it was installed.")
lgpPwrOutputToLoad = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 5))
if mibBuilder.loadTexts: lgpPwrOutputToLoad.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoad.setDescription('This sub-tree is used to register the output to the critical\n            load as a well known measurement point.  It is intended that\n            no sub-trees be created below this node.')
lgpPwrMeasBattery = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 6))
if mibBuilder.loadTexts: lgpPwrMeasBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBattery.setDescription('This sub-tree is used to register a battery as a well known\n            measurement point.  It is intended that no sub-trees be created\n            below this node.')
lgpPwrMeasBypass = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 7))
if mibBuilder.loadTexts: lgpPwrMeasBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBypass.setDescription('This sub-tree is used to register a bypass as a well known\n            measurement point.  It is intended that no sub-trees be created\n            below this node.')
lgpPwrMeasDcBus = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 8))
if mibBuilder.loadTexts: lgpPwrMeasDcBus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasDcBus.setDescription('This sub-tree is used to register a DC bus as a well known\n            measurement point.  It is intended that no sub-trees be created\n            below this node.')
lgpPwrMeasSystemOutput = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 9))
if mibBuilder.loadTexts: lgpPwrMeasSystemOutput.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasSystemOutput.setDescription('This sub-tree is used to register the output of a\n            multi-module system as a well known measurement point.\n            It is intended that no sub-trees be created below this node.\n\n            This identifier represents the power related data of the\n            system.')
lgpPwrMeasBatteryCabinet = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 1, 10))
if mibBuilder.loadTexts: lgpPwrMeasBatteryCabinet.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasBatteryCabinet.setDescription("This sub-tree is used to register the voltage between the \n            most negative and the most postive terminals of a battery\n            cabinet. To determine the cabinet being described in a\n            multi-cabinet system, this point implements an additional\n            two indexes. The first index describes the module the cabinet\n            is located in. The second index describes the cabinet\n            number. In an SMS(Single-Module System) the first index is\n            always 1.\n\n            Example: lgpPwrMeasBatteryCabinet.2.4\n\n            'lgpPwrMeasBatteryCabinet' = Point is a battery cabinet.\n                                  '.2' = Cabinet is in the second module.\n                                  '.4' = Cabinet number 4")
lgpPwrMeasurementPointTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2), )
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setReference("The measurement points represented by 'lgpPwrMeasurementPointId'\n        can be found in the sub-tree lgpPwrWellKnownMeasurementPoints.\n        Additional measurement detail on a 'per line' basis is available in\n        the lgpPwrLineMeasurementTable")
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointTable.setDescription("This table contains a list of AC power measurement point entries.\n         The table contains zero, one, or many rows, depending upon the number\n         of power related measurement points available.  The NMS cannot\n         create or delete rows from the table. The rows are created by the\n         agent based upon the capabilities of the managed device.  Each row\n         in the table represents a series of measurements on a given point\n         or location within the system.  Measurement points/locations are\n         identified by the object identifier 'lgpPwrMeasurementPointId' in the\n         'LgpPwrMeasurementPointEntry' object.  The actual measurement being\n         taken at that identified point is identified by the other\n         corresponding columns in the LgpPwrMeasurementPointEntry for the\n         particular row of the table.")
lgpPwrMeasurementPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrMeasurementPointIndex"))
if mibBuilder.loadTexts: lgpPwrMeasurementPointEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointEntry.setDescription("This entry defines the measurements to be populated in the\n             various columns of the 'lgpPwrMeasurementPointTable'.")
lgpPwrMeasurementPointIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrMeasurementPointIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointIndex.setDescription("This is the index that indicates the row of the\n            'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrMeasurementPointId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointId.setDescription("An OID representing a well known measurement point.\n            These object identifiers indicate a point or location of power\n            measurement in a power system.  The OID's name usually\n            implies a location of the measurement point such as\n            'input', 'output', 'bypass' etc.")
lgpPwrMeasurementPointNumLines = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNumLines.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNumLines.setDescription('The number of lines on the indicated power measurement point.\n             (i.e. the number of phases on the power source being measured.)')
lgpPwrMeasurementPointNomVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVolts.setDescription('The magnitude of the nominal voltage on the power source being\n            measured.')
lgpPwrMeasurementPointNomFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 5), Integer32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomFrequency.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomFrequency.setDescription("The nominal or configured/expected frequency for the power\n             source indicated by 'lgpPwrMeasurementPointId' in the\n             corresponding row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 6), Integer32()).setUnits('Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointFrequency.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointFrequency.setDescription("The present (actual) frequency for the power source indicated\n             by 'lgpPwrMeasurementPointId' in the corresponding row in the\n             lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 7), Integer32()).setUnits('Volt-Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointApparentPower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointApparentPower.setDescription("The present apparent AC power for the power source\n             indicated by 'lgpPwrMeasurementPointId' in the corresponding row\n             in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 8), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointTruePower.setDescription("The present AC power for the power source indicated by\n            'lgpPwrMeasurementPointId' in the corresponding row in the\n             lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 9), Integer32()).setUnits('.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactor.setDescription("The present Power Factor for the power source indicated by\n            'lgpPwrMeasurementPointId' in the corresponding row in the\n             lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointWattHours = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 10), Integer32()).setUnits('Watt-Hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointWattHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointWattHours.setDescription("The present number of Watt Hours for the power source indicated by\n            'lgpPwrMeasurementPointId' in the corresponding row in the\n             lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointVAPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 11), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointVAPercent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointVAPercent.setDescription("The percentage of the rated apparent AC power of the power\n            source indicated by 'lgpPwrMeasurementPointId' in the corresponding\n            row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNeutralCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 12), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNeutralCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNeutralCurrent.setDescription("The present neutral current of the power point indicated by\n            'lgpPwrMeasurementPointId' in the corresponding row in the\n            lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointGroundCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 13), Integer32()).setUnits('0.1 Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointGroundCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointGroundCurrent.setDescription("The present ground current of the power point indicated by\n            'lgpPwrMeasurementPointId' in the corresponding row in the\n            lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 14), Integer32()).setUnits('0.1 Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomCurrent.setDescription("The nominal or configured/expected current of the power point\n            indicated by 'lgpPwrMeasurementPointId' in the corresponding row\n            in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 15), Integer32()).setUnits('.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomPowerFactor.setDescription("The nominal or configured/expected power factor of the power point\n            indicated by 'lgpPwrMeasurementPointId' in the corresponding row\n            in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 16), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVA.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomVA.setDescription("The nominal or configured/expected apparent AC power for the power\n            source indicated by 'lgpPwrMeasurementPointId' in the corresponding\n            row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointNomW = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 17), Integer32()).setUnits('Watt').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomW.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointNomW.setDescription("The nominal or configured/expected true AC power for the power\n            source indicated by 'lgpPwrMeasurementPointId' in the corresponding\n            row in the lgpPwrMeasurementPointTable.")
lgpPwrMeasurementPointPowerFactorTag = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("leading", 1), ("lagging", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactorTag.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPointPowerFactorTag.setDescription("The present description of the Power Factor for the power source\n            indicated by 'lgpPwrMeasurementPointId' in the corresponding row\n            in the lgpPwrMeasurementPointTable.  If Leading, the load is said\n            to be capacitive and the phase of the current leads the voltage.\n            If Lagging, the load is said to be inductive and the phase of the\n            current lags the voltage.")
lgpPwrLineMeasurementTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3), )
if mibBuilder.loadTexts: lgpPwrLineMeasurementTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementTable.setDescription("A list of power measurements for each phase/line for a given\n         power measurement point/location in the 'lgpPwrMeasurementPointTable'.\n         The lgpPwrMeasurementPointIndex in this table corresponds to the\n         index in the lgpPwrMeasurementPointTable.\n\n         This table contains zero, one, or\n         many rows, depending upon the number of power line source objects\n         available.  The NMS cannot create or delete rows from the table.\n         The rows are created by the agent based upon the capabilities of\n         the managed device.")
lgpPwrLineMeasurementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrMeasurementPtIndex"), (0, "LIEBERT-GP-POWER-MIB", "lgpPwrLineMeasurementIndex"))
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setReference('The lgpPwrMeasurementPointIndex can be found in the\n            lgpPwrMeasurementPointTable.  This index identifies the measurement\n            point for which the line detail measurement in the table applies.')
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementEntry.setDescription("This entry defines the contents of the columns for the table\n            'lgpPwrLineMeasurementTable'.")
lgpPwrMeasurementPtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrMeasurementPtIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPtIndex.setDescription("This is the index indicating the row of the table\n             'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrLineMeasurementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 2), Unsigned32())
if mibBuilder.loadTexts: lgpPwrLineMeasurementIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementIndex.setDescription("This is the index indicating the row of the table\n             'lgpPwrLineMeasurementTable' for a power measurement point.")
lgpPwrMeasurementPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownMeasurementPoints' and correspond to the entry in\n            the table lgpPwrMeasurementPointTable.")
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMeasurementPoint.setDescription("An OID representing a well known measurement point.\n            These object identifiers indicate a point or location of power\n            measurement in a power system.  The OID name usually\n            implies a location of the measurement point such as\n            'input', 'output', 'bypass', etc.")
lgpPwrLineMeasurementVoltsLL = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLL.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLL.setDescription('The present Line-to-Line voltage measurement for the indicated\n             source. The line being measured is given by the\n             lgpPwrLineMeasurementIndex [1 = AB, 2 = BC, 3 = CA].')
lgpPwrLineMeasurementVoltsLN = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 5), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLN.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltsLN.setDescription('The present Line-to-neutral voltage measurement for the indicated\n             source. The line being measured is given by the\n             lgpPwrLineMeasurementIndex where [1 = A, 2 = B, 3 = C].')
lgpPwrLineMeasurementCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 6), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrent.setDescription("The present current measurement for the indicated source. The line\n             being measured is given by the 'lgpPwrLineMeasurementIndex' where\n             [1 = A, 2 = B, 3 = C].")
lgpPwrLineMeasurementCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 7), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCapacity.setDescription('The percentage of the power capacity presently being used on this\n             line.')
lgpPwrLineMeasurementVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 8), Integer32()).setUnits('Volt-Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVA.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVA.setDescription('The present apparent AC line power.')
lgpPwrLineMeasurementTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 9), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementTruePower.setDescription('The present AC line power measured in watts.')
lgpPwrLineMeasurementVoltageTHD = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 10), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltageTHD.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVoltageTHD.setDescription('The present total harmonic distortion on the AC line voltage.')
lgpPwrLineMeasurementCurrentTHD = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 11), Integer32()).setUnits('0.1 Percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrentTHD.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCurrentTHD.setDescription('The present total harmonic distortion on the AC line current.')
lgpPwrLineMeasurementKFactorCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 12), Integer32()).setUnits('0.1 K Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementKFactorCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementKFactorCurrent.setDescription('The present line K Factor.')
lgpPwrLineMeasurementCrestFactorCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 13), Integer32()).setUnits('0.1 Crest Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementCrestFactorCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementCrestFactorCurrent.setDescription('The present crest factor of the line current.')
lgpPwrLineMeasurementPowerFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 14), Integer32()).setUnits('0.01 Power Factor').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactor.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactor.setDescription('The present Power Factor for the line.')
lgpPwrLineMeasurementPowerFactorTag = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("leading", 1), ("lagging", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactorTag.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPowerFactorTag.setDescription('The present description of the Power Factor for the line.  If\n            Leading, the load is said to be capacitive and the phase of the\n            current leads the voltage.  If Lagging, the load is said to be\n            inductive and the phase of the current lags the voltage.')
lgpPwrLineMeasurementMaxVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 16), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementMaxVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementMaxVolts.setDescription("The maximum voltage measurement recorded for the indicated source\n            since the command 'lgpPwrStatisticsReset' was executed.")
lgpPwrLineMeasurementMinVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 17), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementMinVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementMinVolts.setDescription("The minimum voltage measurement recorded for the\n            indicated source since the command 'lgpPwrStatisticsReset' was\n            executed.")
lgpPwrLineMeasurementVAR = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 18), Integer32()).setUnits('Volt-Amp-Reactive').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVAR.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVAR.setDescription("The present reactive AC line power of the power source indicated by\n            'lgpPwrMeasurementPoint'.")
lgpPwrLineMeasurementPercentLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 19), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementPercentLoad.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementPercentLoad.setDescription('The present percent load of the AC line power.')
lgpPwrLineMeasurementVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 20), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVolts.setDescription('The present voltage measurement for the indicated source.')
lgpPwrLineMeasurementVACapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 3, 1, 21), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLineMeasurementVACapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLineMeasurementVACapacity.setDescription('The percentage of the apparent power capacity presently being\n            used on this line.')
lgpPwrDcMeasurementPointTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4), )
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setReference("The measurement points represented by 'lgpPwrDcMeasurementPointId'\n        can be found in the sub-tree lgpPwrWellKnownMeasurementPoints.\n        Additional measurement detail on a 'per line' basis is available in\n        the lgpPwrLineMeasurementTable")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTable.setDescription("This table contains a list of DC power measurement point entries.\n         The table contains zero, one, or many rows, depending upon the number\n         of power related measurement points available.  The NMS cannot\n         create or delete rows from the table. The rows are created by the\n         agent based upon the capabilities of the managed device.  Each row\n         in the table represents a series of measurements on a given point\n         or location within the system.  Measurement points/locations are\n         identified by the object identifier 'lgpPwrDcMeasurementPointId' in the\n         'LgpPwrDcMeasurementPointEntry' object.  The actual measurement being\n         taken at that identified point is identified by the other\n         corresponding columns in the LgpPwrDcMeasurementPointEntry for the\n         particular row of the table.")
lgpPwrDcMeasurementPointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrDcMeasurementPointIndex"))
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointEntry.setDescription("This entry defines the measurements to be populated in the\n             various columns of the 'lgpPwrDcMeasurementPointTable'.")
lgpPwrDcMeasurementPointIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointIndex.setDescription("This is the index that indicates the row of the\n            'lgpPwrMeasurementPointTable' for a power measurement point.")
lgpPwrDcMeasurementPointId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointId.setDescription("An OID representing a well known measurement point.\n            These object identifiers indicate a point or location of power\n            measurement in a power system.  The OID's name usually\n            implies a location of the measurement point such as\n            'input', 'output', 'bypass' etc.")
lgpPwrDcMeasurementPointSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointSubID.setDescription('The identifier used to differentiate between identical thresholds\n            for a given point index and point ID in the DC measurements table.')
lgpPwrDcMeasurementPointVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 4), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointVolts.setDescription("The present DC voltage for the power source indicated by\n            'lgpPwrDcMeasurementPointId' in the corresponding row in the\n            lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 5), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointCurrent.setDescription("The present DC current for the power source indicated by\n            'lgpPwrDcMeasurementPointId' in the corresponding row in the\n            lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointNomVolts = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 6), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointNomVolts.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointNomVolts.setDescription("The nominal(configured/expected) DC voltage for the power source\n            indicated by 'lgpPwrDcMeasurementPointId' in the\n            corresponding row in the lgpPwrDcMeasurementPointTable.")
lgpPwrDcMeasurementPointTruePower = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 4, 1, 7), Integer32()).setUnits('Watt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTruePower.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcMeasurementPointTruePower.setDescription("The present DC power for the power source indicated by\n            'lgpPwrDcMeasurementPointId' in the corresponding row in the\n             lgpPwrDcMeasurementPointTable.")
lgpPwrWellKnownMeasurementTypes = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5))
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementTypes.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownMeasurementTypes.setDescription("This sub-tree registers well known Liebert Power Measurement\n         Types.  The object identifier names usually encompass units of\n         measure, lines of reference, and device location.  The OID's\n         name usually implies a measurement type such as 'voltsAC',\n         'current', 'voltsDc', 'VoltsLL', etc.")
lgpPwrVoltsAc = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 1))
if mibBuilder.loadTexts: lgpPwrVoltsAc.setStatus('current')
if mibBuilder.loadTexts: lgpPwrVoltsAc.setDescription('This identifier represents an AC voltage.')
lgpPwrVoltsDc = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 2))
if mibBuilder.loadTexts: lgpPwrVoltsDc.setStatus('current')
if mibBuilder.loadTexts: lgpPwrVoltsDc.setDescription('This identifier represents a DC voltage.')
lgpPwrAmpsNeutral = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 2, 5, 3))
if mibBuilder.loadTexts: lgpPwrAmpsNeutral.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAmpsNeutral.setDescription('This identifier represents a current measurement in Amps on the\n            neutral line.')
lgpPwrWellKnownControlPoints = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 1))
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setStatus('current')
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setDescription("This sub-tree registers well known Liebert Power Control\n         Points.  The object identifier names usually imply locations\n         where control of a device is available -- such 'output' or\n         'load circuits'.")
if mibBuilder.loadTexts: lgpPwrWellKnownControlPoints.setReference("These well known control identifiers are referenced in the\n         'lgpPwrLoadCircuitId' column in the\n         'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuit = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 1, 1))
if mibBuilder.loadTexts: lgpPwrLoadCircuit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuit.setDescription("The managed device's controllable load circuit.\n                 Many power systems contain more than one load circuit.\n                 This identifier represents one load circuit for the\n                 system but does not necessarily represent the 'first' one.\n                 The load circuits' numbering with respect to\n                 'lgpPwrLoadCircuit1' etc. may depend on the physical wiring\n                 of the system when it was installed.")
lgpPwrLoadCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2), )
if mibBuilder.loadTexts: lgpPwrLoadCircuitTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitTable.setDescription('A list of load circuits that can be controlled(opened or closed).\n        The NMS cannot create or delete rows from the table.\n        The rows are created by the agent based upon the capabilities of\n        the managed device.')
lgpPwrLoadCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrLoadCircuitIndex"))
if mibBuilder.loadTexts: lgpPwrLoadCircuitEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitEntry.setDescription("This entry defines the contents of the columns for the table\n            'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrLoadCircuitIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitIndex.setDescription("This is the index indicating the row of the table\n            'lgpPwrLoadCircuitTable'.")
lgpPwrLoadCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownMeasurementPoints'.")
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitId.setDescription('An OID representing a well known load circuit identifier.\n            These load circuit identifiers indicate the name or type of load\n            circuit reference in the table.')
lgpPwrLoadCircuitSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadCircuitSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitSubID.setDescription("This is a sub identifier for the 'lgpPwrLoadCircuitId'.\n            It indicates the hardware identifier of the load control circuit.")
lgpPwrLoadCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("default", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadCircuitState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitState.setDescription('This identifier indicates the state of the load circuit.\n            When read, only a closed or open response will be returned.\n            When written to, the state of the circuit will transition to\n            desired state.')
lgpPwrLoadCircuitStateAndControl = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("off", 0), ("on", 1), ("reboot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadCircuitStateAndControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadCircuitStateAndControl.setDescription('This identifier indicates the state of the load circuit.\n            When read, only a closed or open response will be returned.\n            When written to, the state of the circuit will transition to\n            desired state.')
lgpPwrAlarmSilence = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAlarmSilence.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAlarmSilence.setDescription("Audible Alarm Silence Command.  This command turns off the device's\n        audible alarm.  It will not affect the status of the alarm(s) that\n        caused the audible alarm.  This command should be sent with a\n        parameter of 1.  This variable doesn't return a value when read.")
lgpPwrBatteryTest = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("abort", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryTest.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryTest.setDescription('Battery Test Command.  This command will initiate a battery test if\n        one is not already in progress, or abort the current test if it is in\n        progress.')
lgpPwrUpsAbortCommand = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAbortCommand.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAbortCommand.setDescription("UPS Abort command.  This command will abort the pending command on the\n        device.  There is no guarantee a client using the abort command will\n        cancel a command sent moments before from the same client.\n        Another client could initiate a command and change what command is\n        actually pending on the device.  This command should be sent with a\n        parameter of 1.  This variable doesn't return a value when read.")
lgpPwrTransferToBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTransferToBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferToBypass.setDescription("Transfer to Bypass Command. This command will initiate a transfer of\n        the load to the bypass of the system.  This command should be sent with a\n        parameter of 1.  This variable doesn't return a value when read.")
lgpPwrTransferToInverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTransferToInverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferToInverter.setDescription("Transfer to Inverter Command. This command will initiate a transfer\n        of the load to the inverter of the system.  This command should be sent\n        with a parameter of 1.  This variable doesn't return a value when read.")
lgpPwrOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 8), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOnDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOnDelay.setDescription('Output On Delay Command.  This command will turn on the output of the\n        device after a user specified delay.  The number of seconds to delay\n        is subject to the precision of the device and should be kept to 10\n        second intervals.')
lgpPwrOutputOffDelayWithRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 9), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithRestart.setDescription('Output Off Delay with Restart Command.  This command will turn off the\n        output of the device after a user specified delay.  The number\n        of seconds to delay is subject to the precision of the device and\n        should be kept to 10 second intervals.  The device will then\n        turn the output on again after a specified amount of time.  ')
lgpPwrOutputOffDelayWithoutRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 6, 10), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithoutRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputOffDelayWithoutRestart.setDescription('Output Off Delay without Restart Command.  This command will turn off\n        the output of the device after a specified delay.  The number of seconds\n        to delay is subject to the precision of the device and should be kept\n        to 10 second intervals.  The device will NOT automatically turn the\n        output on following this command.')
lgpPwrTransferCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTransferCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransferCount.setDescription('Number of times that the output load has been transferred between the\n        available input sources.')
lgpPwrAutoTransferTimer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 2), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrAutoTransferTimer.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoTransferTimer.setDescription('The required wait time between output load auto transfer attempts\n         between available input sources.')
lgpPwrAutoReTransferEnabled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrAutoReTransferEnabled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoReTransferEnabled.setDescription("The ability to retransfer the output load automatically to the well\n        known measurement source from the 'lgpPwrWellKnownMeasurements'\n        sub-tree that is the preferred input source of the system")
lgpPwrSyncPhaseAngle = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-3600, 3600))).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrSyncPhaseAngle.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSyncPhaseAngle.setDescription('The phase angle difference of source 1 in relation to source 2.')
lgpPwrParallelSystemOutputToLoadSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("utility", 1), ("battery", 2), ("bypass", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrParallelSystemOutputToLoadSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelSystemOutputToLoadSource.setDescription("The source supporting the parallel system's load.")
lgpPwrDcToDcConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrDcToDcConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrDcToDcConverter.setDescription('The state of the DC to DC converter.')
lgpPwrOutputToLoadOnInverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnInverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnInverter.setDescription('The present source of output power is the Inverter.')
lgpPwrBatteryChargeCompensating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryChargeCompensating.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryChargeCompensating.setDescription('The system is adjusting the battery charging algorithm to accommodate\n        for the battery temperature.')
lgpPwrInverterReady = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInverterReady.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInverterReady.setDescription('The ability of the inverter to support the output load of the system.')
lgpPwrOutputToLoadOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnBypass.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadOnBypass.setDescription('The present source of output power is the Bypass.')
lgpPwrBoost = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBoost.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBoost.setDescription('The present state of the boost circuitry')
lgpPwrBuck = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBuck.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBuck.setDescription('The present state of the buck circuitry')
lgpPwrShutdownOverTemperature = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOverTemperature.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOverTemperature.setDescription('The system has previously shutdown due to an over temperature\n        condition.')
lgpPwrShutdownOverload = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOverload.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOverload.setDescription('The system has previously shutdown due to an over load condition.')
lgpPwrShutdownDcBusOverload = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownDcBusOverload.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownDcBusOverload.setDescription('The system has previously shutdown due to a DC bus over load\n        condition.')
lgpPwrShutdownOutputShort = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownOutputShort.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownOutputShort.setDescription('The system has previously shutdown due to an output short condition.')
lgpPwrShutdownLineSwap = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownLineSwap.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownLineSwap.setDescription('The system has previously shutdown due to a condition where the line\n        and neutral were reversed.')
lgpPwrShutdownLowBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownLowBattery.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownLowBattery.setDescription('The system has previously shutdown due to a low battery condition.')
lgpPwrShutdownRemote = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownRemote.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownRemote.setDescription('The system has previously shutdown due to a remote shutdown command.')
lgpPwrShutdownInputUnderVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownInputUnderVoltage.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownInputUnderVoltage.setDescription('The system has previously shutdown due to an under voltage condition\n        during startup.')
lgpPwrShutdownPowerFactorCorrectionFailure = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownPowerFactorCorrectionFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownPowerFactorCorrectionFailure.setDescription('The system has previously shutdown due to a power factor correction\n        startup failure.')
lgpPwrShutdownHardware = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrShutdownHardware.setStatus('current')
if mibBuilder.loadTexts: lgpPwrShutdownHardware.setDescription('The system has previously shutdown due external shutdown signal.')
lgpPwrRedundantSubModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRedundantSubModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRedundantSubModule.setDescription('The system has a redundant battery module installed.')
lgpPwrBypassReady = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassReady.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassReady.setDescription('The ability of the bypass to support the output load of the system.\n        If Yes, the bypass is available to transfer to.')
lgpPwrGeneratorStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("connected", 1), ("disconnected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrGeneratorStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrGeneratorStatus.setDescription('The state of the system generator.')
lgpPwrRotaryBreakerStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("closed", 2), ("test", 3), ("normal", 4), ("bypass", 5), ("maintenance", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRotaryBreakerStatus.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRotaryBreakerStatus.setDescription('The state of the system rotary breaker.')
lgpPwrPowerFactorCorrection = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPowerFactorCorrection.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPowerFactorCorrection.setDescription('The state of the power factor correction circuitry of the system.')
lgpPwrBypassSyncDiff = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 28), Integer32()).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassSyncDiff.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassSyncDiff.setDescription('The phase angle difference between the inverter output and bypass\n        source. A positive value means the inverter leads the bypass source.\n        A negative value means the inverter lags the bypass source.')
lgpPwrBypassOverloadShutdownTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 29), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassOverloadShutdownTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassOverloadShutdownTime.setDescription('The calculated time remaining before bypass static switch shutdown due\n        to the present overload condition. If the bypass is not in an overload\n        condition, this object returns -1.')
lgpPwrInverterOverloadShutdownTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 30), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInverterOverloadShutdownTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInverterOverloadShutdownTime.setDescription('The calculated time remaining before inverter shutdown. The calculated\n        time of inverter operation remaining for the present overload event.\n\n        Note: If the inverter is not experiencing an overload event this point\n        will return 65535 indicating this value is unavailable.')
lgpPwrStateOutputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("inverter", 2), ("bypass", 3), ("maintenanceBypass", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputSource.setDescription("The UPS's output power source (inverter, bypass, or none).\n        NOTE: It is possible that the load still has power from the \n        Maintenance Bypass.")
lgpPwrStateInputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("utility", 2), ("generator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputSource.setDescription('The system input power source (none, utility, generator).')
lgpPwrStateInputQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputQualification.setDescription("The current state of the system input. The unit may or may not operate\n        normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateBypassStaticSwitchState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassStaticSwitchState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassStaticSwitchState.setDescription('The current state of the bypass static switch.')
lgpPwrStateBypassQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassQualification.setDescription("The current operational state of the bypass static switch. The unit may \n        or may not operate normally under 'marginalLow' and 'marginalHigh'\n        states.")
lgpPwrStateDCBusQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateDCBusQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateDCBusQualification.setDescription("The current operational state of the DC bus. The unit may or may not \n        operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateOutQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutQualification.setDescription("The current operational state of the output. The unit may or may not \n        operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateInverterQualification = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fail", 1), ("marginalLow", 2), ("normal", 3), ("marginalHigh", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInverterQualification.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInverterQualification.setDescription("The current operational state of the inverter. The unit may or may not \n        operate normally under 'marginalLow' and 'marginalHigh' states.")
lgpPwrStateInverterState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInverterState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInverterState.setDescription('The current state of the inverter.')
lgpPwrStateRectifierState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateRectifierState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateRectifierState.setDescription('The current state of the rectifier.')
lgpPwrStateModuleGroup = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41))
if mibBuilder.loadTexts: lgpPwrStateModuleGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleGroup.setDescription('This group contains UPS module information.')
lgpPwrStateUpsModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41, 1), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrStateUpsModuleCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsModuleCount.setDescription('Number of UPS modules in the system. In a single module system, this\n            value is one.')
lgpPwrStateUpsModuleRedundantCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 41, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateUpsModuleRedundantCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsModuleRedundantCount.setDescription('Number of redundant UPS modules in the system. In a single module\n            system, the value is zero. This value is dependent upon the present\n            load and the number of modules (i.e. the value may change during normal\n            operation based upon a load change). This value represents the number\n            of extra modules above the minimum needed to support the load.')
lgpPwrStateBackfeedBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBackfeedBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBackfeedBrkrState.setDescription('The state of the Static Bypass Switch Line Disconnect Breaker.')
lgpPwrStateLoadDisconnectState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateLoadDisconnectState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateLoadDisconnectState.setDescription('The state of the Static Bypass Switch Load Disconnect Breaker.')
lgpPwrStateInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInputBrkrState.setDescription('The state of the Input Disconnect Breaker.')
lgpPwrStateTrapFilterBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateTrapFilterBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateTrapFilterBrkrState.setDescription('The state of the Trap Filter Disconnect Breaker.')
lgpPwrStateInvOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateInvOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateInvOutputBrkrState.setDescription('The state of the Inverter Output Disconnect Breaker.')
lgpPwrStateIntBypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateIntBypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateIntBypassBrkrState.setDescription('The state of the Internal Bypass Breaker.')
lgpPwrStateBypassIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassIsolBrkrState.setDescription('The state of the Bypass Isolation Breaker.')
lgpPwrStateRectifierIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateRectifierIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateRectifierIsolBrkrState.setDescription('The state of the Rectifier Isolation Breaker.')
lgpPwrStateMaintBypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateMaintBypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateMaintBypassBrkrState.setDescription('The state of the Maintenance Bypass Breaker.')
lgpPwrStateMaintIsolBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateMaintIsolBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateMaintIsolBrkrState.setDescription('The state of the Maintenance Isolation Breaker.')
lgpPwrStateOutStaticSwState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutStaticSwState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutStaticSwState.setDescription('The state of the Output Series Static Switch.')
lgpPwrStateModuleOutBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateModuleOutBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleOutBrkrState.setDescription('The state of the Module Output Breaker.')
lgpPwrBypassReXfrRemainTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 54), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBypassReXfrRemainTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBypassReXfrRemainTime.setDescription('The time remaining before an inverter overload or inverter fault can \n        be cleared and auto retransfer from the bypass to the inverter can take \n        place. \n\n        Note: If an inverter overload or fault is not taking place, this point\n        will return 65535.')
lgpPwrStateUpsOutputSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("normal", 3), ("bypass", 4), ("battery", 5), ("booster", 6), ("reducer", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateUpsOutputSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateUpsOutputSource.setDescription('The present source of output power.  The enumeration\n        none(2) indicates that there is no source of output\n        power (and therefore no output power), for example,\n        the system has opened the output breaker.\n\n        NOTE: In a single-module system, this point is intended to have the same \n        behavior as the RFC1628 point upsOutputSource.')
lgpPwrStateLoadBusSynchronization = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("active", 1), ("abnormal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateLoadBusSynchronization.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateLoadBusSynchronization.setDescription('The state of the Load Bus Synchronizer (LBS).')
lgpPwrStateCircuitBrkrStateGroup = ObjectIdentity((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57))
if mibBuilder.loadTexts: lgpPwrStateCircuitBrkrStateGroup.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateCircuitBrkrStateGroup.setDescription('This group contains Static Switch circuit breaker state information.')
lgpPwrStateSource1InputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1InputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1InputBrkrState.setDescription('The states of Source 1 Input Breaker.')
lgpPwrStateSource2InputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2InputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2InputBrkrState.setDescription('The states of Source 2 Input Breaker.')
lgpPwrStateSource1BypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1BypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1BypassBrkrState.setDescription('The states of Source 1 Bypass Breaker.')
lgpPwrStateSource2BypassBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2BypassBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2BypassBrkrState.setDescription('The states of Source 2 Bypass Breaker.')
lgpPwrStateOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputBrkrState.setDescription('The states of Output Breaker.')
lgpPwrStateAuxOutputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateAuxOutputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateAuxOutputBrkrState.setDescription('The states of Auxiliary Output Breaker.')
lgpPwrStateSource1PduInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource1PduInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource1PduInputBrkrState.setDescription('The states of Source 1 PDU Input Breaker.')
lgpPwrStateSource2PduInputBrkrState = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 57, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateSource2PduInputBrkrState.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateSource2PduInputBrkrState.setDescription('The states of Source 2 PDU Input Breaker.')
lgpPwrEconomicOperation = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 3, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrEconomicOperation.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperation.setDescription('The present state of ECO mode operation,\n        on(1) if system is on bypass due to ECO mode operation,\n        off(0) any other time.')
lgpPwrPreferredSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPreferredSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPreferredSource.setDescription("The well known measurement source from the\n        'lgpPwrWellKnownMeasurements' sub-tree that is the preferred\n         input source of the system.")
lgpPwrLoadOnSource = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrLoadOnSource.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadOnSource.setDescription("The well known measurement source from the\n         'lgpPwrWellKnownMeasurements' sub-tree that is currently\n          powering the output (load).")
lgpPwrNominalVoltageDeviation = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 3), Integer32()).setUnits('Volt').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviation.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviation.setDescription('The nominal voltage deviation between the well known\n        measurement source lgpPwrSource1Input and lgpPwrSource2Input.')
lgpPwrNominalVoltageDeviationPercent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 4), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviationPercent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNominalVoltageDeviationPercent.setDescription('The percentage of the nominal voltage deviation between the well known\n        measurement source lgpPwrSource1Input and lgpPwrSource2Input.')
lgpPwrPhaseDifferenceLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 5), Integer32()).setUnits('0.1 Degrees').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrPhaseDifferenceLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrPhaseDifferenceLimit.setDescription('The maximum phase difference (between the well known\n         input sources ) in which a transfer to an available input source is\n         permitted.')
lgpPwrFrequencyDeviationLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 6), Integer32()).setUnits('0.1 Hertz').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrFrequencyDeviationLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrFrequencyDeviationLimit.setDescription('The maximum frequency deviation (between the well known\n         input sources ) in which a transfer to an available input source is\n         permitted.')
lgpPwrThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7), )
if mibBuilder.loadTexts: lgpPwrThresholdTable.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdTable.setDescription("A list of power thresholds for a given power measurement at a\n        point/location in the system.\n        The lgpPwrThresholdType in this table corresponds to the\n        type of measurement the high and low thresholds applies to.\n\n        This table contains zero, one, or many rows, depending upon the number\n        of 'lgpPwrThresholdPoint' and 'lgpPwrThresholdSubID' available in the\n        table.\n        The NMS cannot create or delete rows from the table.\n        The rows are created by the agent based upon the capabilities of\n        the managed device.")
lgpPwrThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1), ).setIndexNames((0, "LIEBERT-GP-POWER-MIB", "lgpPwrThresholdIndex"))
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setReference('The lgpPwrThresholdType in this table corresponds to the\n            type of measurement the high and low thresholds applies to.')
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdEntry.setDescription("This entry defines the contents of the columns for the table\n            'lgpPwrThresholdTable'.")
lgpPwrThresholdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 1), Unsigned32())
if mibBuilder.loadTexts: lgpPwrThresholdIndex.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdIndex.setDescription("This is the index indicating the row of the table\n             'lgpPwrLineMeasurementTable' for a power measurement point.")
lgpPwrThresholdPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownMeasurementPoints' and correspond to the\n            entry in the table 'lgpPwrThresholdTable'.")
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdPoint.setDescription("An OID representing a well known measurement point.\n            These object identifiers indicate a point or location of power\n            measurement in a power system.  The OID's name usually\n            implies a location of the measurement point such as\n            'input', 'output', 'bypass' etc.")
lgpPwrThresholdSubID = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdSubID.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdSubID.setDescription("This is a sub identifier for the 'lgpPwrThresholdPoint'.\n            It indicates the instance number of the well known threshold point.")
lgpPwrThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrThresholdType.setReference("The object identifiers  in this column can be found in the sub-tree\n            'lgpPwrWellKnownThresholdTypes' and correspond to the\n            entry in the table lgpPwrThresholdTable.")
if mibBuilder.loadTexts: lgpPwrThresholdType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdType.setDescription("An OID representing a well known measurement type.\n            These object identifiers indicate the type of measurement referenced\n            by the row of the table.  These object identifiers can encompass\n            units of measure, lines of reference, and device location.\n            The OID's name usually implies a measurement type such as\n            'voltsAc', 'current', 'voltsDc', 'VoltsLL', etc.")
lgpPwrThresholdHighWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdHighWarning.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdHighWarning.setDescription("The high warning threshold of a type of measurement designated by\n            the 'lgpPwrThresholdType' at a location designated by the\n            'lgpPwrThresholdPoint'.  If multiple thresholds are available at a\n            single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType',\n            then the 'lgpPwrThresholdSubID' will differentiate between them.\n            When this threshold is met, the agent will send a notification.")
lgpPwrThresholdHighFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdHighFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdHighFailure.setDescription("The high failure threshold of a type of measurement designated by\n            the 'lgpPwrThresholdType' at a location designated by the\n            'lgpPwrThresholdPoint'.  If multiple thresholds are available at a\n            single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType',\n            then the 'lgpPwrThresholdSubID' will differentiate between them.\n            When this threshold is met, the agent will send a notification.")
lgpPwrThresholdLowWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdLowWarning.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdLowWarning.setDescription("The low warning threshold of a type of measurement designated by\n            the 'lgpPwrThresholdType' at a location designated by the\n            'lgpPwrThresholdPoint'.  If multiple thresholds are available at a\n            single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType',\n            then the 'lgpPwrThresholdSubID' will differentiate between them.\n            When this threshold is met, the agent will send a notification.")
lgpPwrThresholdLowFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrThresholdLowFailure.setStatus('current')
if mibBuilder.loadTexts: lgpPwrThresholdLowFailure.setDescription("The low failure threshold of a type of measurement designated by\n            the 'lgpPwrThresholdType' at a location designated by the\n            'lgpPwrThresholdPoint'.  If multiple thresholds are available at a\n            single 'lgpPwrThresholdPoint', of the same 'lgpPwrThresholdType',\n            then the 'lgpPwrThresholdSubID' will differentiate between them.\n            When this threshold is met, the agent will send a notification.")
lgpPwrUpsAutoRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAutoRestart.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAutoRestart.setDescription('The device will automatically restart when utility power is restored\n        following a battery discharge.')
lgpPwrUpsAutoRestartDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 9), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsAutoRestartDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsAutoRestartDelay.setDescription('The device will automatically delay a certain number of seconds and\n        then  restart after utility power is restored following a battery\n        discharge.  The number of seconds to delay is subject to the precision\n        of the device and should be kept to 10 second intervals.')
lgpPwrAutoRestartBatteryChargeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 10), Integer32()).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutoRestartBatteryChargeThreshold.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutoRestartBatteryChargeThreshold.setDescription('The battery charge percentage required before the device can\n        automatically restart.')
lgpPwrParallelModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 11), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrParallelModuleCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelModuleCount.setDescription('The number of modules in the parallel system.')
lgpPwrParallelRedundancyCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 12), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrParallelRedundancyCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrParallelRedundancyCount.setDescription('The number of redundant modules in the parallel system.')
lgpPwrLoadBusSyncMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrLoadBusSyncMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrLoadBusSyncMode.setDescription('The configuration of Load Bus Synchronization (LBS) between\n        independent systems.')
lgpPwrEconomicOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrEconomicOperationMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperationMode.setDescription('The configuration of the economic operation mode of the system.')
lgpPwrAutomaticBatteryTest = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTest.setStatus('current')
if mibBuilder.loadTexts: lgpPwrAutomaticBatteryTest.setDescription("Automatic battery test option.  If enabled, the battery will be tested\n        on a fixed interval.  If disabled, the battery test must be initiated\n        by a battery test command.  The interval at which a battery test is\n        performed is defined by 'lgpPwrAutomaticBatteryTestInterval'.")
lgpPwrMinimumRedundantPowerModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 16), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMinimumRedundantPowerModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMinimumRedundantPowerModule.setDescription('The minimum number of redundant power modules that must be present\n        before sending a loss of power redundancy alarm.  If 0, there is no\n        redundant power functionality.')
lgpPwrMinimumRedundantBatteryModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 17), Integer32()).setUnits('Count').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrMinimumRedundantBatteryModule.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMinimumRedundantBatteryModule.setDescription('The minimum number of redundant battery modules that must be present\n        before sending an alarm. If 0, the redundant battery module alarm is \n        disabled.')
lgpPwrOutputToLoadUserOverloadLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 18), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrOutputToLoadUserOverloadLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrOutputToLoadUserOverloadLimit.setDescription('This is the user specified maximum load the device can support\n        without sending an alarm.')
lgpPwrNoLoadWarningLimit = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 19), Integer32()).setUnits('Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNoLoadWarningLimit.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNoLoadWarningLimit.setDescription("The minimum current draw on the output in which the device considers\n         there to be a load present on the output.  The condition\n         lgpConditionWarningNoLoadDetected will be triggered if the output\n         current falls below this value.  If this value is '-1' then the\n         lgpConditionNoLoadDetectedWarning condition is 'disabled'.")
lgpPwrNoLoadWarningDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrNoLoadWarningDelay.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNoLoadWarningDelay.setDescription('The amount of time to delay before annunciation of the condition\n         lgpConditionNoLoadDetectedWarning after the output current load\n         falls below the threshold lgpPwrOutputNoLoadWarningLimit.')
lgpPwrEconomicOperationModeControl = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 4, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("mode1", 1), ("mode2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrEconomicOperationModeControl.setStatus('current')
if mibBuilder.loadTexts: lgpPwrEconomicOperationModeControl.setDescription('The configuration of the economic operation mode of the system.\n         Note that this supersedes lgpPwrEconomicOperationMode in newer devices.')
lgpPwrBrownOutCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBrownOutCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBrownOutCount.setDescription("The number of occurrences where the input line voltage has fallen below\n        a pre-determined threshold for a specified amount of time.  This number\n        resets when the command 'lgpPwrStatisticsReset' is executed.")
lgpPwrBlackOutCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBlackOutCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBlackOutCount.setDescription("The number of occurrences where there is a total loss of electric power.\n        This number resets when the command 'lgpPwrStatisticsReset' is\n        executed.")
lgpPwrTransientCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTransientCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTransientCount.setDescription("The number of occurrences where the input line voltage spikes above a\n        pre-determined threshold for a specified amount of time.  This number\n        resets when the command 'lgpPwrStatisticsReset' is executed.")
lgpPwrBatteryDischargeCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 4), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryDischargeCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryDischargeCount.setDescription('The number of battery discharges since the last reset.')
lgpPwrBatteryDischargeTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 5), Integer32()).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryDischargeTime.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryDischargeTime.setDescription('The total accumulated time spent on battery since the last reset.')
lgpPwrBatteryAmpHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 6), Integer32()).setUnits('Amp-hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryAmpHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryAmpHours.setDescription('The total accumulated Amp-hours removed from the battery since last\n        reset.')
lgpPwrBatteryWattHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 7), Integer32()).setUnits('Watt-Hour').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrBatteryWattHours.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryWattHours.setDescription("The total accumulated Watt-Hours removed from the battery since last\n        reset.  This command should be sent with a parameter of 1.  This\n        variable doesn't return a value when read.")
lgpPwrBatteryStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrBatteryStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: lgpPwrBatteryStatisticsReset.setDescription("Battery statistics clear command.  The command to reset all battery\n        statistics stored by the device.  This command should be sent with a\n        parameter of 1.  This variable doesn't return a value when read.")
lgpPwrStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 8, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrStatisticsReset.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStatisticsReset.setDescription("Reset Power Statistics Command.  This command will reset the power\n        statistics stored in the system.  This command should be sent with a\n        parameter of 1.  This variable doesn't return a value when read.")
lgpPwrNumberInstalledPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 1), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberInstalledPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberInstalledPowerModules.setDescription('The number of power modules installed in the device.')
lgpPwrNumberFailedPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 2), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberFailedPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberFailedPowerModules.setDescription('The number of power modules in the device that have failed.')
lgpPwrNumberRedundantPowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 3), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberRedundantPowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberRedundantPowerModules.setDescription('The number of redundant power modules installed in the device.')
lgpPwrNumberActivePowerModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 4), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberActivePowerModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberActivePowerModules.setDescription('The number of active power modules in the device.')
lgpPwrNumberPowerModuleWarnings = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 6), Integer32()).setUnits('Count').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrNumberPowerModuleWarnings.setStatus('current')
if mibBuilder.loadTexts: lgpPwrNumberPowerModuleWarnings.setDescription('The number of power modules in the device that have a warning.')
lgpPwrUpsInverterStandby = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUpsInverterStandby.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsInverterStandby.setDescription('The output to the load is supported by the bypass and the inverter is\n        on standby.')
lgpPwrUpsTopOffline = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUpsTopOffline.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsTopOffline.setDescription('The UPS has an offline topology.  Under normal operating conditions,\n        AC power from the utility passes straight through the UPS\n        to the critical load.  The inverter is used to convert the DC power\n        from the battery to create AC power to support the load when the\n        utility fails. Normally the inverter is operating in the stand-by mode,\n        keeping the batteries charged. Should the utility power go out of\n        specification, the inverter will power the load by drawing energy from\n        the battery.')
lgpPwrUpsTopLineInteractive = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUpsTopLineInteractive.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUpsTopLineInteractive.setDescription('The UPS has a line-interactive topology.  This topology\n        resembles the offline product, but inserts a transformer or inductor\n        in series between the utility power source and the load. This inline\n        inductor enables the UPS inverter to interact with incoming power\n        and provide a measure of power conditioning to the load. This\n        buck-and-boost circuitry helps with high and low input voltage\n        conditions.')
lgpPwrUPSTopDualInput = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrUPSTopDualInput.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUPSTopDualInput.setDescription('The system has separate input sources for the bypass and inverter.')
lgpPwrTopFrequencyConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopFrequencyConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopFrequencyConverter.setDescription('The system has a frequency converter.')
lgpPwrTopVoltageConverter = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopVoltageConverter.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopVoltageConverter.setDescription('The system has a voltage converter.')
lgpPwrTopMaximumFrameCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 6), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrTopMaximumFrameCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopMaximumFrameCapacity.setDescription('The maximum device system capacity.')
lgpPwrTopRedundantControlModules = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrTopRedundantControlModules.setStatus('current')
if mibBuilder.loadTexts: lgpPwrTopRedundantControlModules.setDescription('The device has a redundant control module installed.')
lgpPwrInputIsolationTransformerInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrInputIsolationTransformerInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrInputIsolationTransformerInstalled.setDescription('Indicates whether the input isolation transformer is installed.')
lgpPwrStateStaticSwitchType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 1), ("continuousDuty", 2), ("momentaryDuty", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateStaticSwitchType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateStaticSwitchType.setDescription('Static switch type (N/A, continous duty, or momentary duty).')
lgpPwrStateModuleType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("singleModuleSystem", 1), ("module1plus1", 2), ("module1plusN", 3), ("moduleNplus1", 4), ("systemControlCabinet", 5), ("mainStaticSwitch", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateModuleType.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateModuleType.setDescription('UPS module type. \n            SMS   -- Single Module System\n            1 + 1 -- Redundant system for capacity \n            1 + N -- Distributed multi-module system \n            N + 1 -- A multi-module system with one bypass for the system\n            SCC   -- System Control Cabinet used in an N+1 system to\n                     provide a single bypass for the system. \n            MSS   -- Main Static Switch')
lgpPwrStateBypassInputConfig = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singlePhase2WireL1WithReturn", 1), ("twoPhase2WireL1L2", 2), ("twoPhase3WireL1L2WithNeutral", 3), ("threePhase3WireL1L2L3", 4), ("threePhase4WireL1L2L3WithNeutral", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateBypassInputConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateBypassInputConfig.setDescription('Bypass input wire physical wiring configuration.\n            singlePhase2WireL1WithReturn\n                Single phase input with 2 wires (Line 1, and Return).\n            twoPhase2WireL1L2\n                Two phase input with 2 wires (Line 1, and Line 2).\n            twoPhase3WireL1L2WithNeutral\n                Two phase input with 3 wires (Line 1, Line 2, and Neutral)\n            threePhase3WireL1L2L3\n                Three phase input with 3 wires (Line 1, Line 2, and Line 3)\n            threePhase4WireL1L2L3WithNeutral\n                Three phase input with 4 wires (Line 1, Line 2, Line 3, and \n                Neutral).')
lgpPwrStateOutputConfig = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singlePhase2WireL1WithReturn", 1), ("twoPhase2WireL1L2", 2), ("twoPhase3WireL1L2WithNeutral", 3), ("threePhase3WireL1L2L3", 4), ("threePhase4WireL1L2L3WithNeutral", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrStateOutputConfig.setStatus('current')
if mibBuilder.loadTexts: lgpPwrStateOutputConfig.setDescription('Output wire physical wiring configuration.\n            singlePhase2WireL1WithReturn\n                Single phase output with 2 wires (Line 1, and Return).\n            twoPhase2WireL1L2\n                Two phase output with 2 wires (Line 1, and Line 2).\n            twoPhase3WireL1L2WithNeutral\n                Two phase output with 3 wires (Line 1, Line 2, and Neutral)\n            threePhase3WireL1L2L3\n                Three phase output with 3 wires (Line 1, Line 2, and Line 3)\n            threePhase4WireL1L2L3WithNeutral\n                Three phase output with 4 wires (Line 1, Line 2, Line 3, and \n                Neutral).')
lgpPwrRectifierPassiveFilterInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierPassiveFilterInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierPassiveFilterInstalled.setDescription('Indicates whether the rectifier passive filter is installed.')
lgpPwrRectifierTrapInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierTrapInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierTrapInstalled.setDescription('Indicates whether the rectifier input passive filter is installed.')
lgpPwrRectifierActiveFilterInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 7, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierActiveFilterInstalled.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierActiveFilterInstalled.setDescription('Indicates whether the rectifier active filter is installed.')
lgpPwrSysCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 1), Integer32()).setUnits('Volt-Amp').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrSysCapacity.setStatus('current')
if mibBuilder.loadTexts: lgpPwrSysCapacity.setDescription('The current device system capacity.')
lgpPwrUPSModuleMode = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("single", 1), ("parallel", 2), ("hotmaster", 3), ("hotslave", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lgpPwrUPSModuleMode.setStatus('current')
if mibBuilder.loadTexts: lgpPwrUPSModuleMode.setDescription('The module mode of the UPS.')
lgpPwrMaxRatedCurrent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 3), Integer32()).setUnits('Amp').setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrMaxRatedCurrent.setStatus('current')
if mibBuilder.loadTexts: lgpPwrMaxRatedCurrent.setDescription('System output maximum amperage rating. The maximum rated amperage for \n        the system. This value is based upon the model type and is typically \n        limited by the wiring, breakers, power devices, etc.')
lgpPwrRectifierPulseCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 42, 3, 5, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sixPulse", 1), ("twelvePulse", 2), ("eighteenPulse", 3), ("twentyFourPulse", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lgpPwrRectifierPulseCount.setStatus('current')
if mibBuilder.loadTexts: lgpPwrRectifierPulseCount.setDescription('Rectifier pulse count per waveform cycle (6-, 12-, 18-, or 24-pulse).')
mibBuilder.exportSymbols("LIEBERT-GP-POWER-MIB", lgpPwrBatteryCabinet=lgpPwrBatteryCabinet, lgpPwrBatteryLeadAcidCellCount=lgpPwrBatteryLeadAcidCellCount, lgpPwrStateOutStaticSwState=lgpPwrStateOutStaticSwState, lgpPwrLineMeasurementMinVolts=lgpPwrLineMeasurementMinVolts, lgpPwrBatteryDischargeCount=lgpPwrBatteryDischargeCount, lgpPwrBattery=lgpPwrBattery, lgpPwrBuck=lgpPwrBuck, lgpPwrStateCircuitBrkrStateGroup=lgpPwrStateCircuitBrkrStateGroup, lgpPwrSysCapacity=lgpPwrSysCapacity, lgpPwrBatteryCapacity=lgpPwrBatteryCapacity, lgpPwrStateInputBrkrState=lgpPwrStateInputBrkrState, lgpPwrBatteryCharger=lgpPwrBatteryCharger, lgpPwrNumberRedundantBatteryModules=lgpPwrNumberRedundantBatteryModules, liebertGlobalProductsPowerModule=liebertGlobalProductsPowerModule, lgpPwrAutomaticBatteryTestCountdown=lgpPwrAutomaticBatteryTestCountdown, lgpPwrStateOutputBrkrState=lgpPwrStateOutputBrkrState, lgpPwrUPSTopDualInput=lgpPwrUPSTopDualInput, lgpPwrInputIsolationTransformerInstalled=lgpPwrInputIsolationTransformerInstalled, lgpPwrLineMeasurementCrestFactorCurrent=lgpPwrLineMeasurementCrestFactorCurrent, lgpPwrStateMaintIsolBrkrState=lgpPwrStateMaintIsolBrkrState, lgpPwrStateSource2BypassBrkrState=lgpPwrStateSource2BypassBrkrState, lgpPwrLineMeasurementVA=lgpPwrLineMeasurementVA, lgpPwrStateInverterState=lgpPwrStateInverterState, lgpPwrDcMeasurementPointId=lgpPwrDcMeasurementPointId, lgpPwrUpsAutoRestartDelay=lgpPwrUpsAutoRestartDelay, lgpPwrBatteryChargeStatus=lgpPwrBatteryChargeStatus, lgpPwrMeasurementPtIndex=lgpPwrMeasurementPtIndex, lgpPwrThresholdSubID=lgpPwrThresholdSubID, lgpPwrBatteryDischargeTime=lgpPwrBatteryDischargeTime, lgpPwrNumberActivePowerModules=lgpPwrNumberActivePowerModules, lgpPwrLoadCircuitSubID=lgpPwrLoadCircuitSubID, lgpPwrStateInverterQualification=lgpPwrStateInverterQualification, lgpPwrParallelModuleCount=lgpPwrParallelModuleCount, lgpPwrBatteryTestResult=lgpPwrBatteryTestResult, lgpPwrBatteryLifeEnhancer=lgpPwrBatteryLifeEnhancer, lgpPwrThresholdHighFailure=lgpPwrThresholdHighFailure, lgpPwrLineMeasurementTable=lgpPwrLineMeasurementTable, lgpPwrMeasurementPointPowerFactorTag=lgpPwrMeasurementPointPowerFactorTag, lgpPwrConfigLowBatteryWarningTime=lgpPwrConfigLowBatteryWarningTime, PYSNMP_MODULE_ID=liebertGlobalProductsPowerModule, lgpPwrLineMeasurementCapacity=lgpPwrLineMeasurementCapacity, lgpPwrSyncPhaseAngle=lgpPwrSyncPhaseAngle, lgpPwrLineMeasurementVolts=lgpPwrLineMeasurementVolts, lgpPwrEconomicOperationMode=lgpPwrEconomicOperationMode, lgpPwrLineMeasurementPowerFactor=lgpPwrLineMeasurementPowerFactor, lgpPwrBatteryTest=lgpPwrBatteryTest, lgpPwrStateUpsOutputSource=lgpPwrStateUpsOutputSource, lgpPwrMeasurementPointNeutralCurrent=lgpPwrMeasurementPointNeutralCurrent, lgpPwrBoost=lgpPwrBoost, lgpPwrShutdownOverTemperature=lgpPwrShutdownOverTemperature, lgpPwrShutdownOutputShort=lgpPwrShutdownOutputShort, lgpPwrMeasurementPointNomPowerFactor=lgpPwrMeasurementPointNomPowerFactor, lgpPwrMeasBatteryCabinet=lgpPwrMeasBatteryCabinet, lgpPwrLoadCircuit=lgpPwrLoadCircuit, lgpPwrFrequencyDeviationLimit=lgpPwrFrequencyDeviationLimit, lgpPwrBatteryCapacityStatus=lgpPwrBatteryCapacityStatus, lgpPwrBatteryAmpHoursConsumed=lgpPwrBatteryAmpHoursConsumed, lgpPwrAmpsNeutral=lgpPwrAmpsNeutral, lgpPwrLineMeasurementVoltsLL=lgpPwrLineMeasurementVoltsLL, lgpPwrLoadCircuitState=lgpPwrLoadCircuitState, lgpPwrNominalVoltageDeviation=lgpPwrNominalVoltageDeviation, lgpPwrThresholdLowWarning=lgpPwrThresholdLowWarning, lgpPwrMeasurementPointNomVA=lgpPwrMeasurementPointNomVA, lgpPwrLoadCircuitIndex=lgpPwrLoadCircuitIndex, lgpPwrStateSource1InputBrkrState=lgpPwrStateSource1InputBrkrState, lgpPwrOutputToLoadOnBypass=lgpPwrOutputToLoadOnBypass, lgpPwrLoadCircuitTable=lgpPwrLoadCircuitTable, lgpPwrSource2Input=lgpPwrSource2Input, lgpPwrLineMeasurementVoltsLN=lgpPwrLineMeasurementVoltsLN, lgpPwrStateOutQualification=lgpPwrStateOutQualification, lgpPwrThresholdIndex=lgpPwrThresholdIndex, lgpPwrParallelRedundancyCount=lgpPwrParallelRedundancyCount, lgpPwrThresholdType=lgpPwrThresholdType, lgpPwrRectifierPassiveFilterInstalled=lgpPwrRectifierPassiveFilterInstalled, lgpPwrRectifierPulseCount=lgpPwrRectifierPulseCount, lgpPwrNominalVoltageDeviationPercent=lgpPwrNominalVoltageDeviationPercent, lgpPwrMeasBattery=lgpPwrMeasBattery, lgpPwrLineMeasurementTruePower=lgpPwrLineMeasurementTruePower, lgpPwrNumberRedundantPowerModules=lgpPwrNumberRedundantPowerModules, lgpPwrOutputToLoadUserOverloadLimit=lgpPwrOutputToLoadUserOverloadLimit, lgpPwrMinimumRedundantBatteryModule=lgpPwrMinimumRedundantBatteryModule, lgpPwrBatteryPresentDischargeTime=lgpPwrBatteryPresentDischargeTime, lgpPwrThresholdLowFailure=lgpPwrThresholdLowFailure, lgpPwrTransferToInverter=lgpPwrTransferToInverter, lgpPwrRedundantSubModule=lgpPwrRedundantSubModule, lgpPwrStateUpsModuleCount=lgpPwrStateUpsModuleCount, lgpPwrUpsTopLineInteractive=lgpPwrUpsTopLineInteractive, lgpPwrDcMeasurementPointTable=lgpPwrDcMeasurementPointTable, lgpPwrLineMeasurementCurrent=lgpPwrLineMeasurementCurrent, lgpPwrLoadOnSource=lgpPwrLoadOnSource, lgpPwrAutomaticBatteryTest=lgpPwrAutomaticBatteryTest, lgpPwrThresholdEntry=lgpPwrThresholdEntry, lgpPwrLineMeasurementKFactorCurrent=lgpPwrLineMeasurementKFactorCurrent, lgpPwrBatteryAmpHoursDischargeConsumed=lgpPwrBatteryAmpHoursDischargeConsumed, lgpPwrBatteryCabinetRatedCapacity=lgpPwrBatteryCabinetRatedCapacity, lgpPwrMeasurementPointPowerFactor=lgpPwrMeasurementPointPowerFactor, lgpPwrWellKnownControlPoints=lgpPwrWellKnownControlPoints, lgpPwrTopVoltageConverter=lgpPwrTopVoltageConverter, lgpPwrBatteryLastCommissionTime=lgpPwrBatteryLastCommissionTime, lgpPwrMeasurementPointEntry=lgpPwrMeasurementPointEntry, lgpPwrWellKnownMeasurementTypes=lgpPwrWellKnownMeasurementTypes, lgpPwrBlackOutCount=lgpPwrBlackOutCount, lgpPwrStateModuleType=lgpPwrStateModuleType, lgpPwrStateOutputSource=lgpPwrStateOutputSource, lgpPwrStateDCBusQualification=lgpPwrStateDCBusQualification, lgpPwrUpsTopOffline=lgpPwrUpsTopOffline, lgpPwrMeasurementPointId=lgpPwrMeasurementPointId, lgpPwrStateLoadDisconnectState=lgpPwrStateLoadDisconnectState, lgpPwrShutdownPowerFactorCorrectionFailure=lgpPwrShutdownPowerFactorCorrectionFailure, lgpPwrStateInputQualification=lgpPwrStateInputQualification, lgpPwrBatteryStatisticsReset=lgpPwrBatteryStatisticsReset, lgpPwrStatistic=lgpPwrStatistic, lgpPwrStateMaintBypassBrkrState=lgpPwrStateMaintBypassBrkrState, lgpPwrDcMeasurementPointVolts=lgpPwrDcMeasurementPointVolts, lgpPwrLineMeasurementCurrentTHD=lgpPwrLineMeasurementCurrentTHD, lgpPwrStateUpsModuleRedundantCount=lgpPwrStateUpsModuleRedundantCount, lgpPwrUpsAutoRestart=lgpPwrUpsAutoRestart, lgpPwrNoLoadWarningLimit=lgpPwrNoLoadWarningLimit, lgpPwrStateAuxOutputBrkrState=lgpPwrStateAuxOutputBrkrState, lgpPwrOutputOffDelayWithRestart=lgpPwrOutputOffDelayWithRestart, lgpPwrDcToDcConverter=lgpPwrDcToDcConverter, lgpPwrPhaseDifferenceLimit=lgpPwrPhaseDifferenceLimit, lgpPwrNumberFailedPowerModules=lgpPwrNumberFailedPowerModules, lgpPwrMeasurements=lgpPwrMeasurements, lgpPwrNumberInstalledPowerModules=lgpPwrNumberInstalledPowerModules, lgpPwrOutputOnDelay=lgpPwrOutputOnDelay, lgpPwrVoltsDc=lgpPwrVoltsDc, lgpPwrBatteryCabinetType=lgpPwrBatteryCabinetType, lgpPwrConfig=lgpPwrConfig, lgpPwrNumberInstalledBatteryModules=lgpPwrNumberInstalledBatteryModules, lgpPwrLineMeasurementVoltageTHD=lgpPwrLineMeasurementVoltageTHD, lgpPwrUpsAbortCommand=lgpPwrUpsAbortCommand, lgpPwrBypassReady=lgpPwrBypassReady, lgpPwrBatteryEndOfDischargeVoltage=lgpPwrBatteryEndOfDischargeVoltage, lgpPwrBatteryCabinetCount=lgpPwrBatteryCabinetCount, lgpPwrStateLoadBusSynchronization=lgpPwrStateLoadBusSynchronization, lgpPwrTopFrequencyConverter=lgpPwrTopFrequencyConverter, lgpPwrInverterOverloadShutdownTime=lgpPwrInverterOverloadShutdownTime, lgpPwrStateOutputConfig=lgpPwrStateOutputConfig, lgpPwrAlarmSilence=lgpPwrAlarmSilence, lgpPwrWellKnownMeasurementPoints=lgpPwrWellKnownMeasurementPoints, lgpPwrStateStaticSwitchType=lgpPwrStateStaticSwitchType, lgpPwrThresholdTable=lgpPwrThresholdTable, lgpPwrDcMeasurementPointSubID=lgpPwrDcMeasurementPointSubID, lgpPwrStateModuleOutBrkrState=lgpPwrStateModuleOutBrkrState, lgpPwrLineMeasurementIndex=lgpPwrLineMeasurementIndex, lgpPwrDcMeasurementPointNomVolts=lgpPwrDcMeasurementPointNomVolts, lgpPwrRotaryBreakerStatus=lgpPwrRotaryBreakerStatus, lgpPwrBypassReXfrRemainTime=lgpPwrBypassReXfrRemainTime, lgpPwrStateSource1BypassBrkrState=lgpPwrStateSource1BypassBrkrState, lgpPwrLoadBusSyncMode=lgpPwrLoadBusSyncMode, lgpPwrMeasurementPointTable=lgpPwrMeasurementPointTable, lgpPwrBatteryWattHours=lgpPwrBatteryWattHours, lgpPwrTopMaximumFrameCapacity=lgpPwrTopMaximumFrameCapacity, lgpPwrUPSModuleMode=lgpPwrUPSModuleMode, lgpPwrStateBypassStaticSwitchState=lgpPwrStateBypassStaticSwitchState, lgpPwrEconomicOperation=lgpPwrEconomicOperation, lgpPwrControl=lgpPwrControl, lgpPwrMeasurementPointGroundCurrent=lgpPwrMeasurementPointGroundCurrent, lgpPwrMeasurementPoint=lgpPwrMeasurementPoint, lgpPwrMeasurementPointNomCurrent=lgpPwrMeasurementPointNomCurrent, lgpPwrDcMeasurementPointEntry=lgpPwrDcMeasurementPointEntry, lgpPwrBatteryChargeMode=lgpPwrBatteryChargeMode, lgpPwrEconomicOperationModeControl=lgpPwrEconomicOperationModeControl, lgpPwrStatus=lgpPwrStatus, lgpPwrMeasurementPointTruePower=lgpPwrMeasurementPointTruePower, lgpPwrThresholdHighWarning=lgpPwrThresholdHighWarning, lgpPwrDcMeasurementPointTruePower=lgpPwrDcMeasurementPointTruePower, lgpPwrOutputOffDelayWithoutRestart=lgpPwrOutputOffDelayWithoutRestart, lgpPwrStateBackfeedBrkrState=lgpPwrStateBackfeedBrkrState, lgpPwrBrownOutCount=lgpPwrBrownOutCount, lgpPwrStateBypassInputConfig=lgpPwrStateBypassInputConfig, lgpPwrStateBypassIsolBrkrState=lgpPwrStateBypassIsolBrkrState, lgpPwrBypassSyncDiff=lgpPwrBypassSyncDiff, lgpPwrLoadCircuitStateAndControl=lgpPwrLoadCircuitStateAndControl, lgpPwrBatteryChargeCompensating=lgpPwrBatteryChargeCompensating, lgpPwrGeneratorStatus=lgpPwrGeneratorStatus, lgpPwrUpsInverterStandby=lgpPwrUpsInverterStandby, lgpPwrAutoRestartBatteryChargeThreshold=lgpPwrAutoRestartBatteryChargeThreshold, lgpPwrStateSource2PduInputBrkrState=lgpPwrStateSource2PduInputBrkrState, lgpPwrBatteryAmpHours=lgpPwrBatteryAmpHours, lgpPwrMeasDcBus=lgpPwrMeasDcBus, lgpPwrMinimumRedundantPowerModule=lgpPwrMinimumRedundantPowerModule, lgpPwrMeasurementPointNomFrequency=lgpPwrMeasurementPointNomFrequency, lgpPwrTransferCount=lgpPwrTransferCount, lgpPwrMeasBypass=lgpPwrMeasBypass, lgpPwrBatteryNiCadCellCount=lgpPwrBatteryNiCadCellCount, lgpPwrLineMeasurementVACapacity=lgpPwrLineMeasurementVACapacity, lgpPwrRectifierTrapInstalled=lgpPwrRectifierTrapInstalled, lgpPwrTopRedundantControlModules=lgpPwrTopRedundantControlModules, lgpPwrStatisticsReset=lgpPwrStatisticsReset, lgpPwrStateBypassQualification=lgpPwrStateBypassQualification, lgpPwrMeasurementPointFrequency=lgpPwrMeasurementPointFrequency, lgpPwrTopology=lgpPwrTopology, lgpPwrShutdownInputUnderVoltage=lgpPwrShutdownInputUnderVoltage, lgpPwrNumberFailedBatteryModules=lgpPwrNumberFailedBatteryModules, lgpPwrStateSource2InputBrkrState=lgpPwrStateSource2InputBrkrState, lgpPwrMeasurementPointWattHours=lgpPwrMeasurementPointWattHours, lgpPwrSource1Input=lgpPwrSource1Input, lgpPwrBypassOverloadShutdownTime=lgpPwrBypassOverloadShutdownTime, lgpPwrLineMeasurementVAR=lgpPwrLineMeasurementVAR, lgpPwrLoadCircuitId=lgpPwrLoadCircuitId, lgpPwrThresholdPoint=lgpPwrThresholdPoint, lgpPwrMeasurementPointIndex=lgpPwrMeasurementPointIndex, lgpPwrPreferredSource=lgpPwrPreferredSource, lgpPwrMeasurementPointNumLines=lgpPwrMeasurementPointNumLines, lgpPwrNumberPowerModuleWarnings=lgpPwrNumberPowerModuleWarnings, lgpPwrMaxRatedCurrent=lgpPwrMaxRatedCurrent, lgpPwrPowerFactorCorrection=lgpPwrPowerFactorCorrection, lgpPwrNumberBatteryModuleWarnings=lgpPwrNumberBatteryModuleWarnings, lgpPwrInverterReady=lgpPwrInverterReady, lgpPwrShutdownHardware=lgpPwrShutdownHardware, lgpPwrOutputToLoad=lgpPwrOutputToLoad, lgpPwrLineMeasurementPowerFactorTag=lgpPwrLineMeasurementPowerFactorTag, lgpPwrAutoReTransferEnabled=lgpPwrAutoReTransferEnabled, lgpPwrShutdownDcBusOverload=lgpPwrShutdownDcBusOverload, lgpPwrDcMeasurementPointIndex=lgpPwrDcMeasurementPointIndex, lgpPwrLineMeasurementMaxVolts=lgpPwrLineMeasurementMaxVolts, lgpPwrMeasurementPointVAPercent=lgpPwrMeasurementPointVAPercent, lgpPwrDcMeasurementPointCurrent=lgpPwrDcMeasurementPointCurrent, lgpPwrShutdownOverload=lgpPwrShutdownOverload, lgpPwrTransferToBypass=lgpPwrTransferToBypass, lgpPwrRectifierActiveFilterInstalled=lgpPwrRectifierActiveFilterInstalled, lgpPwrStateInvOutputBrkrState=lgpPwrStateInvOutputBrkrState, lgpPwrMeasurementPointApparentPower=lgpPwrMeasurementPointApparentPower, lgpPwrMeasurementPointNomVolts=lgpPwrMeasurementPointNomVolts, lgpPwrConversion=lgpPwrConversion, lgpPwrSourcePdu1Input=lgpPwrSourcePdu1Input, lgpPwrBatteryLastDischargeTime=lgpPwrBatteryLastDischargeTime, lgpPwrShutdownRemote=lgpPwrShutdownRemote, lgpPwrOutputToLoadOnInverter=lgpPwrOutputToLoadOnInverter, lgpPwrStateIntBypassBrkrState=lgpPwrStateIntBypassBrkrState, lgpPwrNominalBatteryCapacity=lgpPwrNominalBatteryCapacity, lgpPwrStateInputSource=lgpPwrStateInputSource, lgpPwrBatteryFloatVoltage=lgpPwrBatteryFloatVoltage, lgpPwrLineMeasurementEntry=lgpPwrLineMeasurementEntry, lgpPwrStateModuleGroup=lgpPwrStateModuleGroup, lgpPwrStateTrapFilterBrkrState=lgpPwrStateTrapFilterBrkrState, lgpPwrStateSource1PduInputBrkrState=lgpPwrStateSource1PduInputBrkrState, lgpPwrBatteryCircuitBreakerState=lgpPwrBatteryCircuitBreakerState, lgpPwrNoLoadWarningDelay=lgpPwrNoLoadWarningDelay, lgpPwrAutoTransferTimer=lgpPwrAutoTransferTimer, lgpPwrBatteryCount=lgpPwrBatteryCount, lgpPwrLoadCircuitEntry=lgpPwrLoadCircuitEntry, lgpPwrShutdownLineSwap=lgpPwrShutdownLineSwap, lgpPwrBatteryTimeRemaining=lgpPwrBatteryTimeRemaining, lgpPwrSourcePdu2Input=lgpPwrSourcePdu2Input, lgpPwrNumberActiveBatteryModules=lgpPwrNumberActiveBatteryModules, lgpPwrAutomaticBatteryTestInterval=lgpPwrAutomaticBatteryTestInterval, lgpPwrVoltsAc=lgpPwrVoltsAc, lgpPwrStateRectifierIsolBrkrState=lgpPwrStateRectifierIsolBrkrState, lgpPwrSettings=lgpPwrSettings, lgpPwrMeasurementPointNomW=lgpPwrMeasurementPointNomW, lgpPwrParallelSystemOutputToLoadSource=lgpPwrParallelSystemOutputToLoadSource)
mibBuilder.exportSymbols("LIEBERT-GP-POWER-MIB", lgpPwrStateRectifierState=lgpPwrStateRectifierState, lgpPwrTransientCount=lgpPwrTransientCount, lgpPwrLineMeasurementPercentLoad=lgpPwrLineMeasurementPercentLoad, lgpPwrShutdownLowBattery=lgpPwrShutdownLowBattery, lgpPwrMeasSystemOutput=lgpPwrMeasSystemOutput)
