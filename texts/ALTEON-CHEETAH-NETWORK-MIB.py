#
# PySNMP MIB module ALTEON-CHEETAH-NETWORK-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/alteonos/ALTEON-CHEETAH-NETWORK-MIB
# Produced by pysmi-1.1.8 at Tue Sep 12 06:54:03 2023
# On host fv-az442-605 platform Linux version 5.15.0-1041-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
aws_switch, = mibBuilder.importSymbols("ALTEON-ROOT-MIB", "aws-switch")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Integer32, Counter32, TimeTicks, ObjectIdentity, MibIdentifier, IpAddress, NotificationType, Gauge32, ModuleIdentity, Counter64, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Integer32", "Counter32", "TimeTicks", "ObjectIdentity", "MibIdentifier", "IpAddress", "NotificationType", "Gauge32", "ModuleIdentity", "Counter64", "Bits")
DisplayString, PhysAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "PhysAddress", "TextualConvention")
layer3 = ModuleIdentity((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3))
layer3.setRevisions(('2004-09-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: layer3.setRevisionsDescriptions(('Added revision clause for SMIv2 compliance.',))
if mibBuilder.loadTexts: layer3.setLastUpdated('200409010000Z')
if mibBuilder.loadTexts: layer3.setOrganization('Nortel Networks')
if mibBuilder.loadTexts: layer3.setContactInfo('Rekha Singamsetty\n                  Suresh Batchu\n\n                  Nortel Networks\n                  4655 Great America Parkway\n                  Santa Clara CA 95054\n\n                  +1 408 495 2400\n                  rrekha@nortelnetworks.com\n                  sbatchu@nortelnetworks.com')
if mibBuilder.loadTexts: layer3.setDescription('The MIB module for the Alteon OS Layer 3 configuration, statistics \n         and information .')
layer3Configs = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1))
layer3Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2))
layer3Info = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3))
layer3Oper = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4))
ipInterfaceCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1))
ipGatewayCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2))
ipStaticRouteCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3))
ipForwardCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4))
vrrpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6))
arpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 7))
ipBootpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8))
dnsCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9))
ipNwfCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10))
ipRmapCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11))
bgpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12))
ospfCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13))
ipGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 14))
ipStaticArpCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15))
rip2Cfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18))
arpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 2))
routeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 3))
dnsStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 4))
vrrpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 5))
ospfStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6))
clearStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7))
ip6Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10))
icmp6Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11))
ip6gwStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12))
rip2Stats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13))
ipRoutingInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1))
arpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2))
vrrpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3))
ospfinfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4))
gatewayInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5))
nbrcacheInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7))
ipRoute6Info = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8))
ipIntfInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9))
rip2Info = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10))
rip2RoutesInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11))
vrrpOper = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1))
ipInterfaceTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipInterfaceTableMax.setStatus('current')
if mibBuilder.loadTexts: ipInterfaceTableMax.setDescription('The maximum number of rows in the IP interface table.')
ipCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2), )
if mibBuilder.loadTexts: ipCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfTable.setDescription('The table of IP interface configuration.')
ipCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgIntfIndex"))
if mibBuilder.loadTexts: ipCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfEntry.setDescription('A row in the Ip interface table')
ipCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIndex.setDescription('The interface number for which the IP information is related.')
ipCurCfgIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfAddr.setDescription('The IP address of the interface.')
ipCurCfgIntfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfMask.setDescription('The subnet mask of the interface.')
ipCurCfgIntfBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfBroadcast.setStatus('obsolete')
if mibBuilder.loadTexts: ipCurCfgIntfBroadcast.setDescription('The broadcast address of the interface.')
ipCurCfgIntfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfVlan.setDescription('The VLAN associated with the interface.')
ipCurCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfState.setDescription('The state of the interface.')
ipCurCfgIntfBootpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfBootpRelay.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfBootpRelay.setDescription('Enable/disable BOOTP relay.')
ipCurCfgIntfIpVer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIpVer.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIpVer.setDescription('The type of IP address.')
ipCurCfgIntfIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfIpv6Addr.setDescription('The IPv6 address of the interface. Address should be 4-byte \n         haxadecimal colon notation.\n         Valid IPv6 address should be in any of the following forms\n           xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or\n           xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ipCurCfgIntfPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfPrefixLen.setDescription('The prefix length associated with this IP address .')
ipCurCfgIntfRouteAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgIntfRouteAdv.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgIntfRouteAdv.setDescription('Enable/disable route advertisement of the interface.')
ipNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3), )
if mibBuilder.loadTexts: ipNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfTable.setDescription('The table of interface configuration in the New Configuration Block.')
ipNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgIntfIndex"))
if mibBuilder.loadTexts: ipNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfEntry.setDescription('A row in the Ip interface table')
ipNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIndex.setDescription('The interface number for which the IP information is related.')
ipNewCfgIntfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfAddr.setDescription('The IP address of the interface.')
ipNewCfgIntfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfMask.setDescription('The subnet mask of the interface.')
ipNewCfgIntfBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfBroadcast.setStatus('obsolete')
if mibBuilder.loadTexts: ipNewCfgIntfBroadcast.setDescription('The broadcast address of the interface.')
ipNewCfgIntfVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfVlan.setDescription('The VLAN associated with the interface.')
ipNewCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfState.setDescription('The state of the interface.')
ipNewCfgIntfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other(1) is returned. Setting the value to anything \n         other than 2(delete) has no effect on the state of the row.')
ipNewCfgIntfBootpRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfBootpRelay.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfBootpRelay.setDescription('Enable/disable BOOTP relay.')
ipNewCfgIntfIpVer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfIpVer.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIpVer.setDescription('The type of IP address.')
ipNewCfgIntfIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfIpv6Addr.setDescription('The IPv6 address of the interface. Address should be 4-byte \n         haxadecimal colon notation.\n         Valid IPv6 address should be in any of the following forms\n           xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or\n           xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ipNewCfgIntfPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfPrefixLen.setDescription('The prefix length associated with this IP address .')
ipNewCfgIntfRouteAdv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgIntfRouteAdv.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgIntfRouteAdv.setDescription('Enable/disable route advertisement of the interface.')
ipCurCfgGwMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("roundrobin", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwMetric.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwMetric.setDescription('The default gateway metric.')
ipNewCfgGwMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strict", 1), ("roundrobin", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgGwMetric.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwMetric.setDescription('The default gateway metric.')
ipGatewayTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipGatewayTableMax.setStatus('current')
if mibBuilder.loadTexts: ipGatewayTableMax.setDescription('The maximum number of rows in the IP gateway table.')
ipCurCfgGwTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4), )
if mibBuilder.loadTexts: ipCurCfgGwTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwTable.setDescription('The table of gateways  in the Current configuration Block.')
ipCurCfgGwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgGwIndex"))
if mibBuilder.loadTexts: ipCurCfgGwEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwEntry.setDescription('A row in the Ip gateway table')
ipCurCfgGwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIndex.setDescription('The gateway number for which the information is related.')
ipCurCfgGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwAddr.setDescription('The IP address of the default gateway.')
ipCurCfgGwInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwInterval.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwInterval.setDescription('The interval between ping attempts.')
ipCurCfgGwRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwRetry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwRetry.setDescription('The number of failed attempts to declare the default gateway DOWN.')
ipCurCfgGwState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwState.setDescription('The state of the default gateway.')
ipCurCfgGwArp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwArp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwArp.setDescription('The state of ARP only health checks.')
ipCurCfgGwVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwVlan.setDescription('The VLAN number for this gateway. The first 4 entries in the table \n         are only used for default gateway load balancing hence the VLAN \n         cannot be specified for the first 4 entries.')
ipCurCfgGwPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwPriority.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwPriority.setDescription('The priority of the default route for this gateway. High priority\n\t means that the default gateway route will have higher priority\n\t over learned default routes.  Low priority means that the default\n\t gateway route will have lower priority than learned default\n\t routes.')
ipCurCfgGwIpVer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIpVer.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpVer.setDescription('The type of IP address.')
ipCurCfgGwIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgGwIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgGwIpv6Addr.setDescription('The IPv6 address of the gateway. Address should be 4-byte\n         haxadecimal colon notation.\n         Valid IPv6 address should be in any of the following forms\n           xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or\n           xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ipNewCfgGwTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5), )
if mibBuilder.loadTexts: ipNewCfgGwTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwTable.setDescription('The table of gateway configuration in the new configuration block.')
ipNewCfgGwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgGwIndex"))
if mibBuilder.loadTexts: ipNewCfgGwEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwEntry.setDescription('A row in the Ip default gateway table')
ipNewCfgGwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgGwIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIndex.setDescription('The gateway number for which the information is related.')
ipNewCfgGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwAddr.setDescription('The IP address of the default gateway.')
ipNewCfgGwInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwInterval.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwInterval.setDescription('The interval in seconds between ping attempts.')
ipNewCfgGwRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwRetry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwRetry.setDescription('The number of failed attempts to declare the default gateway DOWN.')
ipNewCfgGwState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwState.setDescription('The state of the default gateway.')
ipNewCfgGwDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other is returned. Setting the value to anything other \n         than 2(delete) has no effect on the state of the row.')
ipNewCfgGwArp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwArp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwArp.setDescription('The state of the ARP only health checks.')
ipNewCfgGwVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwVlan.setDescription('The VLAN number for this gateway. The first 4 entries in the table \n         are only used for default gateway load balancing hence the VLAN \n         cannot be specified for the first 4 entries.')
ipNewCfgGwPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwPriority.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwPriority.setDescription('The priority of the default route for this gateway. High priority\n\t means that the default gateway route will have higher priority\n\t over learned default routes.  Low priority means that the default\n\t gateway route will have lower priority than learned default\n\t routes.')
ipNewCfgGwIpVer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwIpVer.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpVer.setDescription('The type of IP address.')
ipNewCfgGwIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 2, 5, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgGwIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgGwIpv6Addr.setDescription('The IPv6 address of the gateway. Address should be 4-byte\n         haxadecimal colon notation.\n         Valid IPv6 address should be in any of the following forms\n           xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx or\n           xxxx::xxxx:xxxx:xxxx:xxxx or ::xxxx')
ipStaticRouteTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticRouteTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticRouteTableMaxSize.setDescription('The maximum number of rows in the Static Route table.')
ipCurCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteTable.setDescription('The table of static routes in the current configuration block.')
ipCurCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipCurCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteEntry.setDescription('A row in the static IP route table')
ipCurCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteIndx.setDescription('The index of the static routing table.')
ipCurCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteDestIp.setDescription('The destination IP address of this route.')
ipCurCfgStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteMask.setDescription('The destination IP address of this route.')
ipCurCfgStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteGateway.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteGateway.setDescription('The destination IP address of this route.')
ipCurCfgStaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticRouteInterface.setDescription('The IP interface of this route.  The IP address of the specified \n         interface shall be use as source IP when performs routing.')
ipNewCfgStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteTable.setDescription('The table of static routes in the new configuration block.')
ipNewCfgStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgStaticRouteIndx"))
if mibBuilder.loadTexts: ipNewCfgStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteEntry.setDescription('A row in the static IP route table')
ipNewCfgStaticRouteIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticRouteIndx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteIndx.setDescription('The index of the static routing table.')
ipNewCfgStaticRouteDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteDestIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteDestIp.setDescription('The destination IP address of this route.')
ipNewCfgStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteMask.setDescription('The subnet mask of this route.')
ipNewCfgStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteGateway.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteGateway.setDescription('The IP address of the gateway for this route.')
ipNewCfgStaticRouteAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other is returned. Setting the value to anything other \n         than 2(delete) has no effect on the state of the row.')
ipNewCfgStaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 3, 3, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticRouteInterface.setDescription('The IP interface of this route.  The IP address of the specified \n         interface shall be use as source IP when performs routing.')
ripCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1), )
if mibBuilder.loadTexts: ripCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfTable.setDescription('The table of RIP on IP interface configuration in the current_config.')
ripCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ripCurCfgIntfIndex"))
if mibBuilder.loadTexts: ripCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfEntry.setDescription('Information about  RIP on IP interface.')
ripCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripCurCfgIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfVersion.setDescription('RIP version.')
ripCurCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfState.setDescription('Enable or disable RIP protocol.')
ripCurCfgIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfListen.setDescription('Enable or disable listening to route updates.')
ripCurCfgIntfDefListen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfDefListen.setStatus('obsolete')
if mibBuilder.loadTexts: ripCurCfgIntfDefListen.setDescription('Enable or disable listening to default routes.')
ripCurCfgIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfTrigUpdate.setDescription('Enable or disable triggered updates.')
ripCurCfgIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfMcastUpdate.setDescription('Enable or disable multicast updates.')
ripCurCfgIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfPoisonReverse.setDescription('RIP poison reverse.')
ripCurCfgIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfSupply.setDescription('Enable or disable supplying route updates.')
ripCurCfgIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfMetric.setDescription('RIP route metric for this interface.')
ripCurCfgIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfAuth.setDescription('The type of Authentication used on this interface.')
ripCurCfgIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfKey.setDescription('RIP update authentication password.')
ripCurCfgIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripCurCfgIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripCurCfgIntfDefault.setDescription('Specifies what RIP does with default routes.')
ripNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2), )
if mibBuilder.loadTexts: ripNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfTable.setDescription('The table of RIP on IP interface configuration in the new_config.')
ripNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ripNewCfgIntfIndex"))
if mibBuilder.loadTexts: ripNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfEntry.setDescription('Information about  RIP on IP interface.')
ripNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripNewCfgIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfVersion.setDescription('RIP version.')
ripNewCfgIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfSupply.setDescription('Enable or disable supplying route updates.')
ripNewCfgIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfListen.setDescription('Enable or disable listening to route updates.')
ripNewCfgIntfDefListen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfDefListen.setStatus('obsolete')
if mibBuilder.loadTexts: ripNewCfgIntfDefListen.setDescription('Enable or disable listening to default routes.')
ripNewCfgIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfTrigUpdate.setDescription('Enable or disable triggered updates.')
ripNewCfgIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfMcastUpdate.setDescription('Enable or disable multicast updates.')
ripNewCfgIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfPoisonReverse.setDescription('RIP poison reverse.')
ripNewCfgIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfState.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfState.setDescription('Enable or disable RIP protocol.')
ripNewCfgIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfMetric.setDescription('RIP route metric for this interface.')
ripNewCfgIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ripNewCfgIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfAuth.setDescription('The type of Authentication used on this interface.')
ripNewCfgIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfKey.setDescription('RIP update authentication password.')
ripNewCfgIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ripNewCfgIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripNewCfgIntfDefault.setDescription('Specifies what RIP does with default routes. The default routes \n         action could be set to listen/supply/both/none.')
ripGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3))
rip2CurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgState.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgState.setDescription('RIP global state.')
rip2NewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgState.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgState.setDescription('Globally turn RIP on or off.')
rip2CurCfgUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgUpdatePeriod.setDescription('Update Period in seconds.')
rip2NewCfgUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgUpdatePeriod.setDescription('Update Period in seconds.')
rip2CurCfgVip = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgVip.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgVip.setDescription('Advertise VIP Host Routes.')
rip2NewCfgVip = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgVip.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgVip.setDescription('Advertise VIP Host Routes.')
rip2CurCfgStaticSupply = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2CurCfgStaticSupply.setStatus('current')
if mibBuilder.loadTexts: rip2CurCfgStaticSupply.setDescription('Advertise Static Routes.')
rip2NewCfgStaticSupply = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 18, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2NewCfgStaticSupply.setStatus('current')
if mibBuilder.loadTexts: rip2NewCfgStaticSupply.setDescription('Advertise Static Routes.')
ipFwdGeneralCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1))
ipFwdCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgState.setDescription('IP forwarding global state.')
ipFwdNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgState.setDescription('IP forwarding global state.')
ipFwdCurCfgDirectedBcast = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgDirectedBcast.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgDirectedBcast.setDescription('Enable or disable forwarding directed broadcasts.')
ipFwdNewCfgDirectedBcast = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgDirectedBcast.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgDirectedBcast.setDescription('Enable or disable forwarding directed broadcasts.')
ipFwdCurCfgNoICMPRedirect = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgNoICMPRedirect.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgNoICMPRedirect.setDescription('Enable or disable no icmp redirects.')
ipFwdNewCfgNoICMPRedirect = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgNoICMPRedirect.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgNoICMPRedirect.setDescription('Enable or disable no icmp redirects.')
ipFwdCurCfgRtCache = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgRtCache.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgRtCache.setDescription('Enable or disable SP Route Caching.')
ipFwdNewCfgRtCache = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgRtCache.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgRtCache.setDescription('Enable or disable SP Route Caching.')
ipFwdPortTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdPortTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipFwdPortTableMaxSize.setDescription('The maximum number of rows in the IP Port table.')
ipFwdCurCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 3), )
if mibBuilder.loadTexts: ipFwdCurCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgPortTable.setDescription('The table of ports and their forwarding states')
ipFwdCurCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipFwdCurCfgPortIndex"))
if mibBuilder.loadTexts: ipFwdCurCfgPortEntry.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgPortEntry.setDescription('A row in the ipFwdCurCfgPortTable ')
ipFwdCurCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgPortIndex.setDescription('The port number for which the forwarding state information pertains.')
ipFwdCurCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgPortState.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgPortState.setDescription('The forwarding state of the port.')
ipFwdNewCfgPortTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 4), )
if mibBuilder.loadTexts: ipFwdNewCfgPortTable.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgPortTable.setDescription('The table of ports and their forwarding states')
ipFwdNewCfgPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipFwdNewCfgPortIndex"))
if mibBuilder.loadTexts: ipFwdNewCfgPortEntry.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgPortEntry.setDescription('A row in the ipFwdNewCfgPortTable ')
ipFwdNewCfgPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdNewCfgPortIndex.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgPortIndex.setDescription('The port number for which the forwarding state information pertains.')
ipFwdNewCfgPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFwdNewCfgPortState.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgPortState.setDescription('The forwarding state of the port.')
ipFwdLocalTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdLocalTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipFwdLocalTableMaxSize.setDescription('The maximum number of rows in the Local table.')
ipFwdCurCfgLocalTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 6), )
if mibBuilder.loadTexts: ipFwdCurCfgLocalTable.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgLocalTable.setDescription('The table of local network definition.')
ipFwdCurCfgLocalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 6, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipFwdCurCfgLocalIndex"))
if mibBuilder.loadTexts: ipFwdCurCfgLocalEntry.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgLocalEntry.setDescription('A row in the ipFwdCurCfgLocalTable ')
ipFwdCurCfgLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgLocalIndex.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgLocalIndex.setDescription('The index of ipFwdCurCfgLocalTable.')
ipFwdCurCfgLocalSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgLocalSubnet.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgLocalSubnet.setDescription('The current local IP subnet.')
ipFwdCurCfgLocalMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdCurCfgLocalMask.setStatus('current')
if mibBuilder.loadTexts: ipFwdCurCfgLocalMask.setDescription('The current local IP subnet mask.')
ipFwdNewCfgLocalTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7), )
if mibBuilder.loadTexts: ipFwdNewCfgLocalTable.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalTable.setDescription('The table of local network definition.')
ipFwdNewCfgLocalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipFwdNewCfgLocalIndex"))
if mibBuilder.loadTexts: ipFwdNewCfgLocalEntry.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalEntry.setDescription('A row in the ipFwdNewCfgLocalTable ')
ipFwdNewCfgLocalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFwdNewCfgLocalIndex.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalIndex.setDescription('The index of ipFwdNewCfgLocalTable.')
ipFwdNewCfgLocalSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFwdNewCfgLocalSubnet.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalSubnet.setDescription('The new local IP subnet.')
ipFwdNewCfgLocalMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFwdNewCfgLocalMask.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalMask.setDescription('The new local IP subnet mask.')
ipFwdNewCfgLocalDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 4, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipFwdNewCfgLocalDelete.setStatus('current')
if mibBuilder.loadTexts: ipFwdNewCfgLocalDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other(1) is returned. Setting the value to anything \n         other than 2(delete) has no effect on the state of the row.')
arpCurCfgReARPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpCurCfgReARPPeriod.setStatus('current')
if mibBuilder.loadTexts: arpCurCfgReARPPeriod.setDescription('Re-ARP Period in seconds.')
arpNewCfgReARPPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpNewCfgReARPPeriod.setStatus('current')
if mibBuilder.loadTexts: arpNewCfgReARPPeriod.setDescription('Re-ARP Period in seconds.')
ipCurCfgBootpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpAddr.setDescription('The IP address of BOOTP server.')
ipNewCfgBootpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpAddr.setDescription('The IP address of BOOTP server.')
ipCurCfgBootpAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpAddr2.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpAddr2.setDescription('The IP address of second BOOTP server.')
ipNewCfgBootpAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpAddr2.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpAddr2.setDescription('The IP address of second BOOTP server.')
ipCurCfgBootpState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgBootpState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgBootpState.setDescription('The state of BOOTP relay.')
ipNewCfgBootpState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 8, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgBootpState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgBootpState.setDescription('The state of BOOTP relay.')
vrrpGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1))
vrrpCurCfgGenState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenState.setDescription('Enable or disable VRRP operation globally.')
vrrpNewCfgGenState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenState.setDescription('Enable or disable VRRP operation globally.')
vrrpCurCfgGenTckVirtRtrInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckVirtRtrInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckVirtRtrInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of other virtual routers.')
vrrpNewCfgGenTckVirtRtrInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckVirtRtrInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckVirtRtrInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of other virtual routers.')
vrrpCurCfgGenTckIpIntfInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckIpIntfInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckIpIntfInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of other router interfaces.')
vrrpNewCfgGenTckIpIntfInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckIpIntfInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckIpIntfInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of other router interfaces.')
vrrpCurCfgGenTckVlanPortInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckVlanPortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckVlanPortInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the port state of ports that belongs to the \n         same virtual LAN as the virtual router.')
vrrpNewCfgGenTckVlanPortInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckVlanPortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckVlanPortInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the port state of ports that belongs to the \n         same virtual LAN as the virtual router.')
vrrpCurCfgGenTckL4PortInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckL4PortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckL4PortInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the Layer 4 port states. This is valid when \n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgGenTckL4PortInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckL4PortInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckL4PortInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the Layer 4 port states. This is valid when \n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgGenTckRServerInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckRServerInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckRServerInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of real servers under the virtual \n         server which is configured as a VRRP virtual router.')
vrrpNewCfgGenTckRServerInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckRServerInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckRServerInc.setDescription('The increment of VRRP virtual router priority. The priority is \n         adjusted by tracking the state of real servers under the virtual \n         server which is configured as a VRRP virtual router.')
vrrpCurCfgGenTckHsrpInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckHsrpInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckHsrpInc.setDescription('The increment of VRRP virtual router priority.  The\n\t priority is adjusted by tracking the HSRP advertisements.')
vrrpNewCfgGenTckHsrpInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckHsrpInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckHsrpInc.setDescription('The increment of VRRP virtual router priority.  The\n         priority is adjusted by tracking the HSRP advertisements.')
vrrpCurCfgGenHotstandby = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenHotstandby.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenHotstandby.setDescription('Enable or disable hotstandby processing.')
vrrpNewCfgGenHotstandby = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenHotstandby.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenHotstandby.setDescription('Enable or disable hotstandby processing.')
vrrpCurCfgGenTckHsrvInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenTckHsrvInc.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenTckHsrvInc.setDescription('The increment of VRRP virtual router priority.  The\n                 priority is adjusted by tracking the HSRP advertisements\n                 by VLAN.')
vrrpNewCfgGenTckHsrvInc = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenTckHsrvInc.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenTckHsrvInc.setDescription('The increment of VRRP virtual router priority.  The\n                 priority is adjusted by tracking the HSRP advertisements\n                 by VLAN.')
vrrpCurCfgGenHoldoff = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgGenHoldoff.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgGenHoldoff.setDescription('The time for VRRP virtual router to hold before it \n                 begins to change state to backup or master state.')
vrrpNewCfgGenHoldoff = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpNewCfgGenHoldoff.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgGenHoldoff.setDescription('The time for VRRP virtual router to hold before it \n                 begins to change state to backup or master state.')
vrrpVirtRtrTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpVirtRtrTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpVirtRtrTableMaxSize.setDescription('The maximum number of entries in VRRP virtual router table.')
vrrpCurCfgVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3), )
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTable.setDescription('The table of VRRP virtual routers configuration in current_config.')
vrrpCurCfgVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpCurCfgVirtRtrIndx"))
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTableEntry.setDescription('Information about a VRRP virtual router.')
vrrpCurCfgVirtRtrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIndx.setDescription('The VRRP virtual router table index.')
vrrpCurCfgVirtRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrID.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrID.setDescription('The VRRP virtual router identifier.')
vrrpCurCfgVirtRtrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrAddr.setDescription('The VRRP virtual router IP address.')
vrrpCurCfgVirtRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpCurCfgVirtRtrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpCurCfgVirtRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpCurCfgVirtRtrPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrPreempt.setDescription('This is for controlling whether a higher priority Backup\n          VRRP virtual router preempts a low priority Master.\n\n          enabled(1)  - allow preemption\n          disabled(2) - prohibit preemption')
vrrpCurCfgVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrState.setDescription('Enable or disable the VRRP virtual router.')
vrrpCurCfgVirtRtrSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrSharing.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrSharing.setDescription('Enable or disable load sharing of non-master virtual router.')
vrrpCurCfgVirtRtrTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for priority \n         adjustment. The priority increment is defined \n         in vrrpCurCfgGenTckVirtRtrInc.')
vrrpCurCfgVirtRtrTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckIpIntf.setDescription('Enable or disable tracking other router interfaces for \n\t priority adjustment. The priority increment is defined \n\t in vrrpCurCfgGenTckIpIntfInc.')
vrrpCurCfgVirtRtrTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports \n\t for priority adjustment. The priority increment is \n\t defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpCurCfgVirtRtrTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpCurCfgGenTckL4PortInc.  This is applied when \n\t virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckRServer.setDescription('Enable or disable tracking real server states for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpCurCfgGenTckRServerInc.  This is applied when \n\t virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpCurCfgGenTckHsrpInc.  This is applied when \n\t virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrTckHsrv.setDescription('Enable or disable tracking HSRP advertisements by VLAN for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpCurCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4), )
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTable.setDescription('The table of VRRP virtual routers configuration in current_config.')
vrrpNewCfgVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpNewCfgVirtRtrIndx"))
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTableEntry.setDescription('Information about a VRRP virtual router.')
vrrpNewCfgVirtRtrIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIndx.setDescription('The VRRP virtual router table index.')
vrrpNewCfgVirtRtrID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrID.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrID.setDescription('The VRRP virtual router identifier.')
vrrpNewCfgVirtRtrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrAddr.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrAddr.setDescription('The VRRP virtual router IP address.')
vrrpNewCfgVirtRtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpNewCfgVirtRtrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpNewCfgVirtRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPriority.setDescription('The priority value to be used by the specified VRRP virtual router.')
vrrpNewCfgVirtRtrPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrPreempt.setDescription('This is for controlling whether a higher priority Backup\n         VRRP virtual router preempts a low priority Master.\n\n         enabled(1)  - allow preemption\n         disabled(2) - prohibit preemption')
vrrpNewCfgVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrState.setDescription('Enable or disable the VRRP virtual router.')
vrrpNewCfgVirtRtrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other(1) is returned. Setting the value to anything \n         other than delete(2) has no effect on the state of the row.')
vrrpNewCfgVirtRtrSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrSharing.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrSharing.setDescription('Enable or disable load sharing of non-master virtual router.')
vrrpNewCfgVirtRtrTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpNewCfgGenTckVirtRtrInc.')
vrrpNewCfgVirtRtrTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckIpIntf.setDescription('Enable or disable tracking other router interfaces for \n\t  priority adjustment.  the priority increment is defined \n\t  in vrrpNewCfgGenTckIpIntfInc.')
vrrpNewCfgVirtRtrTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports \n\t for priority adjustment.  the priority increment is \n\t defined in vrrpNewCfgGenTckVlanPortInc.')
vrrpNewCfgVirtRtrTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for \n\t  priority adjustment.  the priority increment is defined \n\t  in vrrpNewCfgGenTckL4PortInc.  This is applied when \n\t  virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckRServer.setDescription('Enable or disable tracking real server states for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpNewCfgGenTckRServerInc.  This is applied when \n\t virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for \n\t priority adjustment.  the priority increment is defined \n\t in vrrpNewCfgGenTckHsrpInc.  This is applied when \n\t virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrTckHsrv.setDescription('Enable or disable tracking HSRP by VLAN advertisements for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpNewCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpIfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpIfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpIfTableMaxSize.setDescription('The maximum number of entries in VRRP interface table.')
vrrpCurCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 6), )
if mibBuilder.loadTexts: vrrpCurCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfTable.setDescription('The table of VRRP interface configuration in current_config.')
vrrpCurCfgIfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 6, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpCurCfgIfIndx"))
if mibBuilder.loadTexts: vrrpCurCfgIfTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfTableEntry.setDescription('Information about a VRRP interface.')
vrrpCurCfgIfIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfIndx.setDescription('The VRRP interface index.  This is eqivalent to IfIndex.')
vrrpCurCfgIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple-text-password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfAuthType.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfAuthType.setDescription('Type of authentication being used.\n\t none(1) - no authentication\n\t simple-text-password(2) - use password specified in \n         vrrpCurCfgIfPasswd for authentication.')
vrrpCurCfgIfPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgIfPasswd.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgIfPasswd.setDescription('The password for authentication.')
vrrpNewCfgIfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7), )
if mibBuilder.loadTexts: vrrpNewCfgIfTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfTable.setDescription('The table of VRRP interface configuration in current_config.')
vrrpNewCfgIfTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpNewCfgIfIndx"))
if mibBuilder.loadTexts: vrrpNewCfgIfTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfTableEntry.setDescription('Information about a VRRP interface.')
vrrpNewCfgIfIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgIfIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfIndx.setDescription('The VRRP interface index.  This is eqivalent to IfIndex.')
vrrpNewCfgIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple-text-password", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfAuthType.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfAuthType.setDescription('Type of authentication being used.\n\t none(1) - no authentication\n\t simple-text-password(2) - use password specified in \n         vrrpNewCfgIfPasswd for authentication.')
vrrpNewCfgIfPasswd = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfPasswd.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfPasswd.setDescription('The password for authentication.')
vrrpNewCfgIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgIfDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgIfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other(1) is returned. Setting the value to anything \n         other than delete(2) has no effect on the state of the row.')
vrrpVirtRtrGrpTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpVirtRtrGrpTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpVirtRtrGrpTableMaxSize.setDescription('The maximum number of entries in VRRP Group table.')
vrrpCurCfgVirtRtrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9), )
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTable.setDescription('The table of VRRP virtual router group in current_config.')
vrrpCurCfgVirtRtrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpCurCfgVirtRtrGrpIndx"))
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTableEntry.setDescription('Information about a VRRP failover virtual router.')
vrrpCurCfgVirtRtrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIndx.setDescription('The VRRP virtual router table index.')
vrrpCurCfgVirtRtrGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpID.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpID.setDescription('The VRRP virtual router identifier.')
vrrpCurCfgVirtRtrGrpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpCurCfgVirtRtrGrpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpCurCfgVirtRtrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpCurCfgVirtRtrGrpPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpPreempt.setDescription('This is for controlling whether a higher priority Backup\n         VRRP virtual router preempts a low priority Master.\n\n         enabled(1)  - allow preemption\n         disabled(2) - prohibit preemption')
vrrpCurCfgVirtRtrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpState.setDescription('Enable or disable the VRRP virtual router.')
vrrpCurCfgVirtRtrGrpSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpSharing.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpSharing.setDescription('Enable or disable load sharing of non-master virtual router.')
vrrpCurCfgVirtRtrGrpTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckVirtRtrInc.')
vrrpCurCfgVirtRtrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckIpIntf.setDescription('Enable or disable tracking other router interfaces for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckIpIntfInc.')
vrrpCurCfgVirtRtrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports\n         for priority adjustment.  the priority increment is\n         defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpCurCfgVirtRtrGrpTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckL4PortInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrGrpTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckRServer.setDescription('Enable or disable tracking real server states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckRServerInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrGrpTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckHsrpInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrGrpTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 9, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrGrpTckHsrv.setDescription('Enable or disable tracking HSRP by VLAN advertisements for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpCurCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10), )
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTable.setDescription('The table of VRRP virtual router group configuration in new_config.')
vrrpNewCfgVirtRtrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpNewCfgVirtRtrGrpIndx"))
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTableEntry.setDescription('Information about a VRRP failover virtual router.')
vrrpNewCfgVirtRtrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIndx.setDescription('The VRRP virtual router table index.')
vrrpNewCfgVirtRtrGrpID = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpID.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpID.setDescription('The VRRP virtual router identifier.')
vrrpNewCfgVirtRtrGrpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIfIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpIfIndex.setDescription('The IfIndex that the VRRP virtual router is representing.')
vrrpNewCfgVirtRtrGrpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpInterval.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpInterval.setDescription('The time interval between VRRP advertisements in seconds.')
vrrpNewCfgVirtRtrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual router.')
vrrpNewCfgVirtRtrGrpPreempt = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPreempt.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpPreempt.setDescription('This is for controlling whether a higher priority Backup\n         VRRP virtual router preempts a low priority Master.\n\n         enabled(1)  - allow preemption\n         disabled(2) - prohibit preemption')
vrrpNewCfgVirtRtrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpState.setDescription('Enable or disable the VRRP virtual router.')
vrrpNewCfgVirtRtrGrpDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other(1) is returned. Setting the value to anything \n         other than delete(2) has no effect on the state of the row.')
vrrpNewCfgVirtRtrGrpSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpSharing.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpSharing.setDescription('Enable or disable load sharing of non-master virtual router.')
vrrpNewCfgVirtRtrGrpTckVirtRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVirtRtr.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVirtRtr.setDescription('Enable or disable tracking other virtual routers for\n         priority adjustment.  the priority increment is defined\n         in vrrpNewCfgGenTckVirtRtrInc.')
vrrpNewCfgVirtRtrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckIpIntf.setDescription('Enable or disable tracking other router interfaces for\n         priority adjustment.  the priority increment is defined\n         in vrrpNewCfgGenTckIpIntfInc.')
vrrpNewCfgVirtRtrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports\n         for priority adjustment.  the priority increment is\n         defined in vrrpNewCfgGenTckVlanPortInc.')
vrrpNewCfgVirtRtrGrpTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for\n         priority adjustment.  the priority increment is defined\n         in vrrpNewCfgGenTckL4PortInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrGrpTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckRServer.setDescription('Enable or disable tracking real server states for\n         priority adjustment.  the priority increment is defined\n         in vrrpNewCfgGenTckRServerInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrGrpTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for\n         priority adjustment.  the priority increment is defined\n         in vrrpNewCfgGenTckHsrpInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrGrpTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrGrpTckHsrv.setDescription('Enable or disable tracking HSRP by VLAN advertisements for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpNewCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpVirtRtrVrGrpTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpVirtRtrVrGrpTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: vrrpVirtRtrVrGrpTableMaxSize.setDescription('The maximum number of entries in VRRP VrGroup table.')
vrrpCurCfgVirtRtrVrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12), )
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTable.setDescription('The table of VRRP virtual router vrgroup configuration in\n         the current config.')
vrrpCurCfgVirtRtrVrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpCurCfgVirtRtrVrGrpIndx"))
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTableEntry.setDescription('Information about setting VRRP virtual router vrgroup.')
vrrpCurCfgVirtRtrVrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpIndx.setDescription('The VRRP virtual router vrgroup table index.')
vrrpCurCfgVirtRtrVrGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpName.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpName.setDescription('The VRRP virtual router vrgroup name.')
vrrpCurCfgVirtRtrVrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpState.setDescription('Enable or disable VRRP Vrgroup state ')
vrrpCurCfgVirtRtrVrGrpBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpBmap.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpBmap.setDescription('The virtual routers added for to this VRRP vrgroup.\n         The selected virtual routers are presented in a bitmap format.\n         in receiving order:\n\n             OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx .....\n             ||    || |_ Virtual Router 9\n             ||    ||\n             ||    ||___ Virtual Router 8\n             ||    |____ Virtual Router 7\n             ||      .    .   .\n             ||_________ Virtual Router 2\n             |__________ Virtual Router 1\n\n             where x : 1 - The represented Virtual Router is added\n                       0 - The represented Virtual Router is not added')
vrrpCurCfgVirtRtrVrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpCurCfgVirtRtrVrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckIpIntf.setDescription('Enable or disable tracking interfaces in vrgroup for\n         priority adjustment. The priority increment is defined\n         in vrrpCurCfgGenTckIpIntfInc.')
vrrpCurCfgVirtRtrVrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports\n         for priority adjustment. The priority increment is\n         defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpCurCfgVirtRtrVrGrpTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckL4PortInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrVrGrpTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckRServer.setDescription('Enable or disable tracking real server states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckRServerInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrVrGrpTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckHsrpInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrVrGrpTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckHsrv.setDescription('Enable or disable tracking HSRP advertisements by VLAN for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpCurCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpCurCfgVirtRtrVrGrpTckVirtRtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 12, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckVirtRtrNo.setStatus('current')
if mibBuilder.loadTexts: vrrpCurCfgVirtRtrVrGrpTckVirtRtrNo.setDescription('The track virtual router for group.')
vrrpNewCfgVirtRtrVrGrpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13), )
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTable.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTable.setDescription('The table of VRRP virtual router vrgroup configuration in new_config.')
vrrpNewCfgVirtRtrVrGrpTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpNewCfgVirtRtrVrGrpIndx"))
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTableEntry.setDescription('Information about setting VRRP virtual router Vrgroup.')
vrrpNewCfgVirtRtrVrGrpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpIndx.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpIndx.setDescription('The VRRP virtual router vrgroup table index.')
vrrpNewCfgVirtRtrVrGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpName.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpName.setDescription('The VRRP virtual router vrgroup name.')
vrrpNewCfgVirtRtrVrGrpAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpAdd.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpAdd.setDescription('The VRRP virtual router to be added to this vrgroup table.')
vrrpNewCfgVirtRtrVrGrpRem = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpRem.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpRem.setDescription('The VRRP virtual router to be removed from this vrgroup table.')
vrrpNewCfgVirtRtrVrGrpState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpState.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpState.setDescription('Enable or disable VRRP Vrgroup state ')
vrrpNewCfgVirtRtrVrGrpDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpDelete.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted.\n         When read, other(1) is returned. Setting the value to anything\n         other than 2(delete) has no effect on the state of the row.')
vrrpNewCfgVirtRtrVrGrpBmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpBmap.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpBmap.setDescription('The virtual routers added to this VRRP vrgroup.\n         The selected virtual routers are presented in a bitmap format.\n         in receiving order:\n\n             OCTET 1  OCTET 2  .....\n             xxxxxxxx xxxxxxxx .....\n             ||    || |_ Virtual Router 9\n             ||    ||\n             ||    ||___ Virtual Router 8\n             ||    |____ Virtual Router 7\n             ||      .    .   .\n             ||_________ Virtual Router 2\n             |__________ Virtual Router 1\n\n             where x : 1 - The represented Virtual Router is added\n                       0 - The represented Virtual Router is not added')
vrrpNewCfgVirtRtrVrGrpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpPriority.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpPriority.setDescription('The priority value to be used by the specified VRRP virtual routers.')
vrrpNewCfgVirtRtrVrGrpTckIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckIpIntf.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckIpIntf.setDescription('Enable or disable tracking interfaces in vrgroup for\n         priority adjustment. The priority increment is defined\n         in vrrpCurCfgGenTckIpIntfInc.')
vrrpNewCfgVirtRtrVrGrpTckVlanPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckVlanPort.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckVlanPort.setDescription('Enable or disable tracking port state of VLAN ports\n         for priority adjustment. The priority increment is\n         defined in vrrpCurCfgGenTckVlanPortInc.')
vrrpNewCfgVirtRtrVrGrpTckL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckL4Port.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckL4Port.setDescription('Enable or disable tracking Layer 4 port states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckL4PortInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrVrGrpTckRServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckRServer.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckRServer.setDescription('Enable or disable tracking real server states for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckRServerInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrVrGrpTckHsrp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckHsrp.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckHsrp.setDescription('Enable or disable tracking HSRP advertisements for\n         priority adjustment.  the priority increment is defined\n         in vrrpCurCfgGenTckHsrpInc.  This is applied when\n         virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrVrGrpTckHsrv = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckHsrv.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckHsrv.setDescription('Enable or disable tracking HSRP advertisements by VLAN for\n                 priority adjustment.  The priority increment is defined\n                 in vrrpCurCfgGenTckHsrvInc.  This is applied when\n                 virtual server is configured as a VRRP virtual router.')
vrrpNewCfgVirtRtrVrGrpTckVirtRtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 6, 13, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckVirtRtrNo.setStatus('current')
if mibBuilder.loadTexts: vrrpNewCfgVirtRtrVrGrpTckVirtRtrNo.setDescription('The track virtual router for group.')
dnsCurCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgPrimaryIpAddr.setDescription('The DNS primary IP address in the current_configuration block.')
dnsNewCfgPrimaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgPrimaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgPrimaryIpAddr.setDescription('The DNS primary IP address in the new_configuration block.')
dnsCurCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgSecondaryIpAddr.setDescription('The DNS primary IP address in the current_configuration block.')
dnsNewCfgSecondaryIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgSecondaryIpAddr.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgSecondaryIpAddr.setDescription('The DNS primary IP address in the new_configuration block.')
dnsCurCfgDomainName = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 191))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsCurCfgDomainName.setStatus('current')
if mibBuilder.loadTexts: dnsCurCfgDomainName.setDescription('The DNS doamin name in the current_configuration block.')
dnsNewCfgDomainName = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 9, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsNewCfgDomainName.setStatus('current')
if mibBuilder.loadTexts: dnsNewCfgDomainName.setDescription('The DNS doamin name in the new_configuration block.')
ipNwfTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNwfTableMax.setStatus('current')
if mibBuilder.loadTexts: ipNwfTableMax.setDescription('The maximum number of rows in the IP network filter table.')
ipCurCfgNwfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2), )
if mibBuilder.loadTexts: ipCurCfgNwfTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfTable.setDescription('The table of IP network filter configuration in the current_config.')
ipCurCfgNwfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgNwfIndex"))
if mibBuilder.loadTexts: ipCurCfgNwfEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfEntry.setDescription('Information about an IP network filter.')
ipCurCfgNwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfIndex.setDescription('The netowrk filter number for which the NWF is related.')
ipCurCfgNwfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfAddr.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfAddr.setDescription('The IP address of the network filter.')
ipCurCfgNwfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfMask.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfMask.setDescription('The subnet mask of the network filter.')
ipCurCfgNwfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgNwfState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgNwfState.setDescription('Enable or disable the network filter.')
ipNewCfgNwfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3), )
if mibBuilder.loadTexts: ipNewCfgNwfTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfTable.setDescription('The table of IP network filter configuration in the current_config.')
ipNewCfgNwfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgNwfIndex"))
if mibBuilder.loadTexts: ipNewCfgNwfEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfEntry.setDescription('Information about an IP network filter.')
ipNewCfgNwfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgNwfIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfIndex.setDescription('The netowrk filter number for which the NWF is related.')
ipNewCfgNwfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfAddr.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfAddr.setDescription('The IP address of the network filter.')
ipNewCfgNwfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfMask.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfMask.setDescription('The subnet mask of the network filter.')
ipNewCfgNwfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfState.setDescription('Enable or disable the network filter.')
ipNewCfgNwfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 10, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgNwfDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgNwfDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
ipRmapTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRmapTableMax.setStatus('current')
if mibBuilder.loadTexts: ipRmapTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgRmapTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2), )
if mibBuilder.loadTexts: ipCurCfgRmapTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapTable.setDescription('The table of IP route map configuration in the current_config.')
ipCurCfgRmapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgRmapIndex"))
if mibBuilder.loadTexts: ipCurCfgRmapEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapEntry.setDescription('Information about an IP route map.')
ipCurCfgRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgRmapLp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapLp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapLp.setDescription('The local-preference of the route map. 4294967295 means none')
ipCurCfgRmapMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapMetric.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapMetric.setDescription('The metric of the route map. 4294967295 means none')
ipCurCfgRmapPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapPrec.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapPrec.setDescription('The precedence of the route map.')
ipCurCfgRmapWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapWeight.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapWeight.setDescription('The weight of the route map. 65535 means none')
ipCurCfgRmapState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapState.setDescription('Enable or disable the route map.')
ipCurCfgRmapAp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapAp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapAp.setDescription('The as-path prepend of the matched route. Up to 3 AS number can be \n\t displayed for the string. \n\t The usuage is:<AS number> [<AS number>][ <AS number>]')
ipCurCfgRmapMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRmapMetricType.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRmapMetricType.setDescription('The OSPF metric-type of the matched route.')
ipNewCfgRmapTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3), )
if mibBuilder.loadTexts: ipNewCfgRmapTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapTable.setDescription('The table of IP route map configuration in the current_config.')
ipNewCfgRmapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgRmapIndex"))
if mibBuilder.loadTexts: ipNewCfgRmapEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapEntry.setDescription('Information about an IP route map.')
ipNewCfgRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgRmapLp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapLp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapLp.setDescription('The local-preference of the route map. 4294967295 means none')
ipNewCfgRmapMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapMetric.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapMetric.setDescription('The metric of the route map. 4294967295 means none')
ipNewCfgRmapPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapPrec.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapPrec.setDescription('The precedence of the route map.')
ipNewCfgRmapWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapWeight.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapWeight.setDescription('The weight of the route map. 65535 means none')
ipNewCfgRmapState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapState.setDescription('Enable or disable the route map.')
ipNewCfgRmapAp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapAp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapAp.setDescription('The as-path prepend of the matched route. Up to 3 AS number can be \n\t displayed for the string. \n\t The usuage is:<AS number> [<AS number>][ <AS number>]')
ipNewCfgRmapMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapMetricType.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapMetricType.setDescription('The OSPF metric-type of the matched route.')
ipNewCfgRmapDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgRmapDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRmapDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
ipAlistTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAlistTableMax.setStatus('current')
if mibBuilder.loadTexts: ipAlistTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgAlistTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5), )
if mibBuilder.loadTexts: ipCurCfgAlistTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistTable.setDescription('The table of IP route map access list configuration in the \n       current_config.')
ipCurCfgAlistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgAlistRmapIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgAlistIndex"))
if mibBuilder.loadTexts: ipCurCfgAlistEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistEntry.setDescription('Information about an IP route map.')
ipCurCfgAlistRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgAlistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistIndex.setDescription('The access list number for which the access list is related.')
ipCurCfgAlistNwf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistNwf.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistNwf.setDescription('The network filter number of the route map access list. \n\t 0 means none')
ipCurCfgAlistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistMetric.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistMetric.setDescription('The metric of the route map access list. 4294967295 means none')
ipCurCfgAlistAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistAction.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistAction.setDescription('Action of the route map access list.')
ipCurCfgAlistState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAlistState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAlistState.setDescription('Enable or disable the route map access list.')
ipNewCfgAlistTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6), )
if mibBuilder.loadTexts: ipNewCfgAlistTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistTable.setDescription('The table of IP route map access list configuration in the \n       current_config.')
ipNewCfgAlistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgAlistRmapIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgAlistIndex"))
if mibBuilder.loadTexts: ipNewCfgAlistEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistEntry.setDescription('Information about an IP route map.')
ipNewCfgAlistRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAlistRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgAlistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAlistIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistIndex.setDescription('The access list number for which the access list is related.')
ipNewCfgAlistNwf = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistNwf.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistNwf.setDescription('The network filter number of the route map access list. \n\t 0 means none')
ipNewCfgAlistMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistMetric.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistMetric.setDescription('The metric of the route map access list. 4294967295 means none')
ipNewCfgAlistAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistAction.setDescription('Action of the route map access list.')
ipNewCfgAlistState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistState.setDescription('Enable or disable the route map access list.')
ipNewCfgAlistDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAlistDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAlistDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
ipAspathTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAspathTableMax.setStatus('current')
if mibBuilder.loadTexts: ipAspathTableMax.setDescription('The maximum number of rows in the IP route map table.')
ipCurCfgAspathTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8), )
if mibBuilder.loadTexts: ipCurCfgAspathTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathTable.setDescription('The table of IP route map access path configuration.')
ipCurCfgAspathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgAspathRmapIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgAlistIndex"))
if mibBuilder.loadTexts: ipCurCfgAspathEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathEntry.setDescription('Information about an IP route map.')
ipCurCfgAspathRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipCurCfgAspathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathIndex.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathIndex.setDescription('The access path number for which the access list is related.')
ipCurCfgAspathAS = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathAS.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathAS.setDescription('The AS number of the route map access path. \n\t 0 means none')
ipCurCfgAspathAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathAction.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathAction.setDescription('Action of the route map access path.')
ipCurCfgAspathState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgAspathState.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgAspathState.setDescription('Enable or disable the route map access path.')
ipNewCfgAspathTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9), )
if mibBuilder.loadTexts: ipNewCfgAspathTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathTable.setDescription('The table of IP route map access path configuration')
ipNewCfgAspathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgAspathRmapIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgAspathIndex"))
if mibBuilder.loadTexts: ipNewCfgAspathEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathEntry.setDescription('Information about an IP route map.')
ipNewCfgAspathRmapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAspathRmapIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathRmapIndex.setDescription('The route map number for which the RMAP is related.')
ipNewCfgAspathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgAspathIndex.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathIndex.setDescription('The access path number for which the access list is related.')
ipNewCfgAspathAS = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathAS.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathAS.setDescription('The AS number of the route map access path. \n\t 0 means none')
ipNewCfgAspathAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathAction.setDescription('Action of the route map access path.')
ipNewCfgAspathState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathState.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathState.setDescription('Enable or disable the route map access path.')
ipNewCfgAspathDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 11, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgAspathDelete.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgAspathDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
bgpGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1))
bgpCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgState.setDescription('BGP global state.')
bgpNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgState.setDescription('Globally turn BGP on or off.')
bgpCurCfgLocalPref = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgLocalPref.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgLocalPref.setDescription('Local preference value.')
bgpNewCfgLocalPref = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgLocalPref.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgLocalPref.setDescription('Local Preference value.')
bgpCurCfgMaxASPath = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgMaxASPath.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgMaxASPath.setDescription('Maximum AS Path Length.')
bgpNewCfgMaxASPath = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bgpNewCfgMaxASPath.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgMaxASPath.setDescription('Maximum AS Path Length.')
bgpPeerTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpPeerTableMax.setStatus('current')
if mibBuilder.loadTexts: bgpPeerTableMax.setDescription('The maximum number of rows in the BGP peer table.')
bgpCurCfgPeerTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3), )
if mibBuilder.loadTexts: bgpCurCfgPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerTable.setDescription('The table of BGP peer configuration in the current_config.')
bgpCurCfgPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "bgpCurCfgPeerIndex"))
if mibBuilder.loadTexts: bgpCurCfgPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerEntry.setDescription('Information about a BGP peer.')
bgpCurCfgPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerIndex.setDescription('The BGP peer number for which the BGP peer table is related.')
bgpCurCfgPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAddr.setDescription('The remote IP address of the BGP peer.')
bgpCurCfgPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerRemoteAs.setDescription('The remote AS number of the BGP peer.  0 means none')
bgpCurCfgPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerTtl.setDescription('The time-to-live value of the BGP peer IP datagram. ')
bgpCurCfgPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerState.setDescription('Enable or disable the peer.')
bgpCurCfgPeerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerMetric.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerMetric.setDescription("The metric value of the BGP peer.  A value of '0' means none")
bgpCurCfgPeerDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerDefaultAction.setDescription('The value of default route action.')
bgpCurCfgPeerOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpCurCfgPeerFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpCurCfgPeerStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerStaticState.setDescription('Enable or disable advertising static routes.')
bgpCurCfgPeerVipState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerVipState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerVipState.setDescription('Enable or disable VIP static routes.')
bgpCurCfgPeerInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerInRmapList.setDescription('The route maps present in the in route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
bgpCurCfgPeerOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 3, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgPeerOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgPeerOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
bgpNewCfgPeerTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4), )
if mibBuilder.loadTexts: bgpNewCfgPeerTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerTable.setDescription('The table of BGP peer configuration in the current_config.')
bgpNewCfgPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "bgpNewCfgPeerIndex"))
if mibBuilder.loadTexts: bgpNewCfgPeerEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerEntry.setDescription('Information about a BGP peer.')
bgpNewCfgPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerIndex.setDescription('The BGP peer number for which the BGP peer table is related.')
bgpNewCfgPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAddr.setDescription('The remote IP address of the BGP peer.')
bgpNewCfgPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoteAs.setDescription('The remote AS number of the BGP peer.  0 means none')
bgpNewCfgPeerTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerTtl.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerTtl.setDescription('The time-to-live value of the BGP peer IP datagram. ')
bgpNewCfgPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerState.setDescription('Enable or disable the peer.')
bgpNewCfgPeerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerDelete.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
bgpNewCfgPeerMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967294))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerMetric.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerMetric.setDescription("The metric value of the BGP peer. A value of '0' means none")
bgpNewCfgPeerDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("import", 2), ("originate", 3), ("redistribute", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerDefaultAction.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerDefaultAction.setDescription('The value of default route action.')
bgpNewCfgPeerOspfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerOspfState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerOspfState.setDescription('Enable or disable advertising OSPF routes.')
bgpNewCfgPeerFixedState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerFixedState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerFixedState.setDescription('Enable or disable advertising fixed routes.')
bgpNewCfgPeerStaticState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerStaticState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerStaticState.setDescription('Enable or disable advertising static routes.')
bgpNewCfgPeerVipState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerVipState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerVipState.setDescription('Enable or disable VIP static routes.')
bgpNewCfgPeerInRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerInRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerInRmapList.setDescription('The route maps present in the in route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
bgpNewCfgPeerOutRmapList = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgPeerOutRmapList.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
bgpNewCfgPeerAddInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAddInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAddInRmap.setDescription('The route map to be add into in-rmap list. When read,\n\t 0 is returned.')
bgpNewCfgPeerAddOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerAddOutRmap.setDescription('The route map to be add into out-rmap list. When read,\n\t 0 is returned.')
bgpNewCfgPeerRemoveInRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 20), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveInRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveInRmap.setDescription('The route map to be removed from out-rmap list. When read,\n\t 0 is returned.')
bgpNewCfgPeerRemoveOutRmap = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 4, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgPeerRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read,\n\t 0 is returned.')
bgpAggrTableMax = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpAggrTableMax.setStatus('current')
if mibBuilder.loadTexts: bgpAggrTableMax.setDescription('The maximum number of rows in the BGP aggregation table.')
bgpCurCfgAggrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6), )
if mibBuilder.loadTexts: bgpCurCfgAggrTable.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrTable.setDescription('The table of BGP aggregation configuration.')
bgpCurCfgAggrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "bgpCurCfgAggrIndex"))
if mibBuilder.loadTexts: bgpCurCfgAggrEntry.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrEntry.setDescription('Information about a BGP aggregation.')
bgpCurCfgAggrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrIndex.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrIndex.setDescription('The aggregation number for which the BGP aggregation is related.')
bgpCurCfgAggrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrAddr.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrAddr.setDescription('The IP address of the BGP aggregation.')
bgpCurCfgAggrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrMask.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrMask.setDescription('The subnet mask of the BGP aggregation.')
bgpCurCfgAggrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpCurCfgAggrState.setStatus('current')
if mibBuilder.loadTexts: bgpCurCfgAggrState.setDescription('Enable or disable the BGP aggregation.')
bgpNewCfgAggrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7), )
if mibBuilder.loadTexts: bgpNewCfgAggrTable.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrTable.setDescription('The table of BGP aggregation configuration.')
bgpNewCfgAggrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "bgpNewCfgAggrIndex"))
if mibBuilder.loadTexts: bgpNewCfgAggrEntry.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrEntry.setDescription('Information about an BGP aggregation.')
bgpNewCfgAggrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bgpNewCfgAggrIndex.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrIndex.setDescription('The aggregation number for which the BGP aggregation is related.')
bgpNewCfgAggrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrAddr.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrAddr.setDescription('The IP address of the BGP aggregation.')
bgpNewCfgAggrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrMask.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrMask.setDescription('The subnet mask of the BGP aggregation.')
bgpNewCfgAggrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrState.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrState.setDescription('Enable or disable the BGP aggregation.')
bgpNewCfgAggrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 12, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bgpNewCfgAggrDelete.setStatus('current')
if mibBuilder.loadTexts: bgpNewCfgAggrDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
ospfGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1))
ospfCurCfgDefaultRouteMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetric.setDescription('Specify the metric to be assigned.')
ospfNewCfgDefaultRouteMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetric.setDescription('Specify the metric to be assigned.')
ospfCurCfgDefaultRouteMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgDefaultRouteMetricType.setDescription('Specify the AS External metric type to be assigned.')
ospfNewCfgDefaultRouteMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgDefaultRouteMetricType.setDescription('Specify the AS External metric type to be assigned.')
ospfIntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTableMaxSize.setDescription('The maximum number of rows in the OSPF Interface table.')
ospfAreaTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTableMaxSize.setDescription('The maximum number of rows in the OSPF Area table.')
ospfRangeTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfRangeTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfRangeTableMaxSize.setDescription('The maximum number of rows in the OSPF Range table.')
ospfVirtIntfTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVirtIntfTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfVirtIntfTableMaxSize.setDescription('The maximum number of rows in the OSPF Virtual Interface\n         table.')
ospfHostTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfHostTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfHostTableMaxSize.setDescription('The maximum number of rows in the OSPF Host table.')
ospfCurCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgState.setDescription('OSPF global state.')
ospfNewCfgState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgState.setDescription('Globally turn OSPF on or off.')
ospfCurCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2), )
if mibBuilder.loadTexts: ospfCurCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaTable.setDescription('The table of OSPF Area configuration in the current_config.')
ospfCurCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgAreaIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgAreaId"))
if mibBuilder.loadTexts: ospfCurCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaEntry.setDescription('Information about a OSPF area.')
ospfCurCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaIndex.setDescription('The OSPF area number for which the OSPF area table is related.')
ospfCurCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaId.setDescription('The IP Address of the OSPF area.')
ospfCurCfgAreaSpfInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaSpfInterval.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaSpfInterval.setDescription('The SPF interval for the OSPF area.')
ospfCurCfgAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgAreaAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgAreaAuthType.setDescription('Type of authentication being used.\n\t none(1) - no authentication\n\t password(2) - use password\n\t md5(3) - use MD5 authentication.')
ospfNewCfgAreaTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3), )
if mibBuilder.loadTexts: ospfNewCfgAreaTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaTable.setDescription('The table of OSPF Area configuration in the new_config.')
ospfNewCfgAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgAreaIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgAreaId"))
if mibBuilder.loadTexts: ospfNewCfgAreaEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaEntry.setDescription('Information about a OSPF area.')
ospfNewCfgAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaIndex.setDescription('The OSPF area number for which the OSPF area table is related.')
ospfNewCfgAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaId.setDescription('The IP Address of the OSPF area.')
ospfNewCfgAreaSpfInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgAreaSpfInterval.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaSpfInterval.setDescription('The SPF interval for the OSPF area.')
ospfNewCfgAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("password", 2), ("md5", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgAreaAuthType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgAreaAuthType.setDescription('Type of authentication being used.\n\t none(1) - no authentication\n\t password(2) - use password.\n         md5(3) - use MD5 authentication.')
ospfCurCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 12), )
if mibBuilder.loadTexts: ospfCurCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostTable.setDescription('The table of OSPF Host configuration.')
ospfCurCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 12, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgHostIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgHostIpAddr"))
if mibBuilder.loadTexts: ospfCurCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostEntry.setDescription('Information about a OSPF host.')
ospfCurCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostIndex.setDescription('The OSPF host number for which the OSPF host table is related.')
ospfCurCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostIpAddr.setDescription('The IP Address of the OSPF host.')
ospfCurCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgHostAreaIndex.setDescription('The area index.')
ospfNewCfgHostTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 13), )
if mibBuilder.loadTexts: ospfNewCfgHostTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostTable.setDescription('The table of OSPF Host configuration.')
ospfNewCfgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 13, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgHostIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgHostIpAddr"))
if mibBuilder.loadTexts: ospfNewCfgHostEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostEntry.setDescription('Information about a OSPF host.')
ospfNewCfgHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgHostIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostIndex.setDescription('The OSPF host number for which the OSPF host table is related.')
ospfNewCfgHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 13, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostIpAddr.setDescription('The IP Address of the OSPF host.')
ospfNewCfgHostAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 13, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgHostAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgHostAreaIndex.setDescription('The OSPF area index.')
ospfMdkeyTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfMdkeyTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ospfMdkeyTableMaxSize.setDescription('The maximum number of rows in the OSPF Mdkey table.')
ospfCurCfgMdkeyTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 5), )
if mibBuilder.loadTexts: ospfCurCfgMdkeyTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyTable.setDescription('The table of OSPF MD5 keys in the current_config.')
ospfCurCfgMdkeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 5, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgMdkeyIndex"))
if mibBuilder.loadTexts: ospfCurCfgMdkeyEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyEntry.setDescription('Information about an OSPF MD keys table.')
ospfCurCfgMdkeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgMdkeyIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyIndex.setDescription('The OSPF MD5 Key number for which the OSPF MdKey table is related.')
ospfCurCfgMdkeyKey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgMdkeyKey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgMdkeyKey.setDescription('The character string representing the MD5 Key.')
ospfNewCfgMdkeyTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 6), )
if mibBuilder.loadTexts: ospfNewCfgMdkeyTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyTable.setDescription('The table of OSPF MD5 keys in the new_config.')
ospfNewCfgMdkeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 6, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgMdkeyIndex"))
if mibBuilder.loadTexts: ospfNewCfgMdkeyEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyEntry.setDescription('Information about an OSPF MD keys table.')
ospfNewCfgMdkeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgMdkeyIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyIndex.setDescription('The OSPF MD5 Key number for which the OSPF MdKey table is related.')
ospfNewCfgMdkeyKey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgMdkeyKey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyKey.setDescription('The character string representing the MD5 Key.')
ospfNewCfgMdkeyDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgMdkeyDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgMdkeyDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n\t When read, other(1) is returned. Setting the value to anything \n\t other than 2(delete) has no effect on the state of the row.')
ospfCurCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 7), )
if mibBuilder.loadTexts: ospfCurCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfTable.setDescription('The table of OSPF Interface configuration in the current_config.')
ospfCurCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 7, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgIntfIndex"))
if mibBuilder.loadTexts: ospfCurCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfEntry.setDescription('Information about an OSPF Interface.')
ospfCurCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfIndex.setDescription('The OSPF Interface number for which the OSPF Interface table is \n         related.')
ospfCurCfgIntfId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfId.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfId.setDescription('The IP Address of the OSPF interface.')
ospfCurCfgIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIntfMdkey.setDescription('The MD5 key for the OSPF interface\n         0 (none) no MD5 authentication.')
ospfNewCfgIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 8), )
if mibBuilder.loadTexts: ospfNewCfgIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfTable.setDescription('The table of OSPF Interface configuration in the new_config.')
ospfNewCfgIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 8, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgIntfIndex"))
if mibBuilder.loadTexts: ospfNewCfgIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfEntry.setDescription('Information about an OSPF Interface.')
ospfNewCfgIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfIndex.setDescription('The OSPF Interface number for which the OSPF Interface table is \n         related.')
ospfNewCfgIntfId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgIntfId.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfId.setDescription('The IP Address of the OSPF interface.')
ospfNewCfgIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIntfMdkey.setDescription('The MD5 key for the OSPF interface\n         0 (none) no MD5 authentication.')
ospfCurCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9), )
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfTable.setDescription('The table of OSPF Virtual Interface configuration in the current \n       configuration.')
ospfCurCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospfCurCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfEntry.setDescription('Information about an OSPF virtual Interface.')
ospfCurCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfIndex.setDescription('The OSPF Virtual Interface number for which the OSPF \n         Virtual Interface table is related.')
ospfCurCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfAreaId.setDescription('The IP Address of the OSPF area to which this virtual interface\n         belongs.')
ospfCurCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfNbr.setDescription('The IP Address of the OSPF neighbor for this virtual interface.')
ospfCurCfgVirtIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgVirtIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgVirtIntfMdkey.setDescription('The MD5 key for the OSPF virtual interface\n         0 (none) no MD5 authentication.')
ospfNewCfgVirtIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10), )
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfTable.setDescription('The table of OSPF Virtual Interface configuration in the new_config.')
ospfNewCfgVirtIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgVirtIntfIndex"))
if mibBuilder.loadTexts: ospfNewCfgVirtIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfEntry.setDescription('Information about an OSPF virtual Interface.')
ospfNewCfgVirtIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfIndex.setDescription('The OSPF Virtual Interface number for which the OSPF \n         Virtual Interface table is related.')
ospfNewCfgVirtIntfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAreaId.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfAreaId.setDescription('The IP Address of the OSPF area to which this virtual interface\n         belongs.')
ospfNewCfgVirtIntfNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfNbr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfNbr.setDescription('The IP Address of the OSPF neighbor for this virtual interface.')
ospfNewCfgVirtIntfMdkey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgVirtIntfMdkey.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgVirtIntfMdkey.setDescription('The MD5 key for the OSPF virtual interface\n         0 (none) no MD5 authentication.')
ospfCurCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14), )
if mibBuilder.loadTexts: ospfCurCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeTable.setDescription('The table of OSPF summary range in the current configuration.')
ospfCurCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfCurCfgRangeIndex"))
if mibBuilder.loadTexts: ospfCurCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeEntry.setDescription('Information about an OSPF summary range.')
ospfCurCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeIndex.setDescription('The range number for which the OSPF summary range table is related.')
ospfCurCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeAddr.setDescription('The IP Address of the range.')
ospfCurCfgRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeMask.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeMask.setDescription('The mask of the range.')
ospfCurCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeAreaIndex.setDescription('The area index.')
ospfCurCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeHideState.setDescription('The state of the hide range.')
ospfCurCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRangeState.setDescription('The state of the range.')
ospfNewCfgRangeTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15), )
if mibBuilder.loadTexts: ospfNewCfgRangeTable.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeTable.setDescription('The table of OSPF summary range in the new configuration.')
ospfNewCfgRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfNewCfgRangeIndex"))
if mibBuilder.loadTexts: ospfNewCfgRangeEntry.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeEntry.setDescription('Information about an OSPF summary range.')
ospfNewCfgRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgRangeIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeIndex.setDescription('The range number for which the OSPF summary range table is related.')
ospfNewCfgRangeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeAddr.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeAddr.setDescription('The IP Address of the range.')
ospfNewCfgRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeMask.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeMask.setDescription('The mask of the range.')
ospfNewCfgRangeAreaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeAreaIndex.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeAreaIndex.setDescription('The area index.')
ospfNewCfgRangeHideState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeHideState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeHideState.setDescription('The state of the hide range.')
ospfNewCfgRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeState.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeState.setDescription('The state of the range.')
ospfNewCfgRangeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ospfNewCfgRangeDelete.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRangeDelete.setDescription('When set to the value of 2 (delete), the entire row is deleted.\n         When read, other(1) is returned. Setting the value to anything\n         other than 2(delete) has no effect on the state of the row.')
ospfRouteRedistribution = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4))
ospfRedistributeStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1))
ospfCurCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticMetric.setDescription('The metric to be assigned to static routes. \n         A value of 0 indicates none.')
ospfNewCfgStaticMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticMetric.setDescription('The metric to be assigned to static routes. \n         A value of 0 indicates none.')
ospfCurCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospfNewCfgStaticMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticMetricType.setDescription('The AS External metric type for static routes.')
ospfCurCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgStaticOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgStaticOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgStaticAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgStaticRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgStaticRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgStaticRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, \n         0 is returned.')
ospfRedistributeEbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2))
ospfCurCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes.\n         A value of 0 indicates none.')
ospfNewCfgEbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpMetric.setDescription('The export metric to be assigned to External BGP routes.\n         A value of 0 indicates none.')
ospfCurCfgEbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpMetricType.setDescription('The AS External metric type for External BGP routes.')
ospfNewCfgEbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpMetricType.setDescription('The AS External metric type for External BGP routes.')
ospfCurCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgEbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgEbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgEbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgEbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgEbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgEbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, \n         0 is returned.')
ospfRedistributeIbgp = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3))
ospfCurCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpMetric.setDescription('The export metric for Internal BGP routes.\n         A value of 0 indicates none.')
ospfNewCfgIbgpMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpMetric.setDescription('The export metric for Internal BGP routes.\n         A value of 0 indicates none.')
ospfCurCfgIbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpMetricType.setDescription('The AS External metric type for Internal BGP routes.')
ospfNewCfgIbgpMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpMetricType.setDescription('The AS External metric type for Internal BGP routes.')
ospfCurCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgIbgpOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgIbgpOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgIbgpAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgIbgpRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgIbgpRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgIbgpRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, \n         0 is returned.')
ospfRedistributeFixed = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4))
ospfCurCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedMetric.setDescription('The export metric for fixed routes. A value of 0 indicates none')
ospfNewCfgFixedMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedMetric.setDescription('The export metric for fixed routes. A value of 0 indicates none')
ospfCurCfgFixedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedMetricType.setDescription('The AS External metric type for fixed routes.')
ospfNewCfgFixedMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedMetricType.setDescription('The AS External metric type for fixed routes.')
ospfCurCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgFixedOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgFixedOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgFixedAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgFixedRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 4, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgFixedRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgFixedRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, \n         0 is returned.')
ospfRedistributeRip = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5))
ospfCurCfgRipMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipMetric.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ospfNewCfgRipMetric = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipMetric.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipMetric.setDescription('The export metric for RIP routes. A value of 0 indicates none')
ospfCurCfgRipMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipMetricType.setDescription('The AS External metric type for RIP routes.')
ospfNewCfgRipMetricType = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("type1", 2), ("type2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipMetricType.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipMetricType.setDescription('The AS External metric type for RIP routes.')
ospfCurCfgRipOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCurCfgRipOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfCurCfgRipOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgRipOutRmapList = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNewCfgRipOutRmapList.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipOutRmapList.setDescription('The route maps present in the out route map list. \n         The route maps are presented in a bitmap format.\n\n         in receiving order:\n\n         OCTET 1  OCTET 2  .....\n         xxxxxxxx xxxxxxxx .....\n         ||    || |_ Rmap 9\n         ||    ||\n         ||    ||___ Rmap 8\n         ||    |____ Rmap 7\n         ||      .    .   .\n         ||_________ Rmap 2\n         |__________ Rmap 1\n\n         where x : 1 - The represented route map is selected\n         0 - The represented route map is not selected')
ospfNewCfgRipAddOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipAddOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipAddOutRmap.setDescription('The route map to be add into out-rmap list. When read, 0 is returned.')
ospfNewCfgRipRemoveOutRmap = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 13, 4, 5, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ospfNewCfgRipRemoveOutRmap.setStatus('current')
if mibBuilder.loadTexts: ospfNewCfgRipRemoveOutRmap.setDescription('The route map to be removed from out-rmap list. When read, \n         0 is returned.')
ipCurCfgRouterID = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 14, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgRouterID.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgRouterID.setDescription('The router ID of the switch.')
ipNewCfgRouterID = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 14, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgRouterID.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgRouterID.setDescription('The router ID of the switch.')
ipCurCfgASNumber = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgASNumber.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgASNumber.setDescription('The autonomous system (AS) number.')
ipNewCfgASNumber = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 14, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipNewCfgASNumber.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgASNumber.setDescription('The autonomous system (AS) number.')
ipStaticArpTableMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipStaticArpTableMaxSize.setStatus('current')
if mibBuilder.loadTexts: ipStaticArpTableMaxSize.setDescription('The maximum number of rows in the Static ARP table.')
ipCurCfgStaticArpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2), )
if mibBuilder.loadTexts: ipCurCfgStaticArpTable.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpTable.setDescription('The table of static ARPs in the current configuration block.')
ipCurCfgStaticArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipCurCfgStaticArpIndx"))
if mibBuilder.loadTexts: ipCurCfgStaticArpEntry.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpEntry.setDescription('A row in the static ARP table')
ipCurCfgStaticArpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpIndx.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpIndx.setDescription('The index of the static ARP table.')
ipCurCfgStaticArpIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpIp.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpIp.setDescription('The IP address for the ARP entry.')
ipCurCfgStaticArpMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpMAC.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpMAC.setDescription('The MAC address for the ARP entry.')
ipCurCfgStaticArpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpVlan.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpVlan.setDescription('The VLAN for the ARP entry.')
ipCurCfgStaticArpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipCurCfgStaticArpPort.setStatus('current')
if mibBuilder.loadTexts: ipCurCfgStaticArpPort.setDescription('The port for the ARP entry.')
ipNewCfgStaticArpTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3), )
if mibBuilder.loadTexts: ipNewCfgStaticArpTable.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpTable.setDescription('The table of static ARPs in the new configuration block.')
ipNewCfgStaticArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipNewCfgStaticArpIndx"))
if mibBuilder.loadTexts: ipNewCfgStaticArpEntry.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpEntry.setDescription('A row in the static ARP table')
ipNewCfgStaticArpIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipNewCfgStaticArpIndx.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpIndx.setDescription('The index of the static ARP table.')
ipNewCfgStaticArpIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpIp.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpIp.setDescription('The IP address for the ARP entry.')
ipNewCfgStaticArpMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 3), PhysAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpMAC.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpMAC.setDescription('The MAC address for the ARP entry.')
ipNewCfgStaticArpVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpVlan.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpVlan.setDescription('The VLAN for the ARP entry.')
ipNewCfgStaticArpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpPort.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpPort.setDescription('The port for the ARP entry.')
ipNewCfgStaticArpAction = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 1, 15, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("delete", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipNewCfgStaticArpAction.setStatus('current')
if mibBuilder.loadTexts: ipNewCfgStaticArpAction.setDescription('When set to the value of 2 (delete), the entire row is deleted. \n         When read, other is returned. Setting the value to anything other \n         than 2(delete) has no effect on the state of the row.')
ripStatInPackets = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInPackets.setStatus('current')
if mibBuilder.loadTexts: ripStatInPackets.setDescription('The total number of RIP packets recieved.')
ripStatOutPackets = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutPackets.setStatus('current')
if mibBuilder.loadTexts: ripStatOutPackets.setDescription('The total number of RIP packets transmitted.')
ripStatInRequestPkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInRequestPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInRequestPkts.setDescription('The total number of RIP requests recieved.')
ripStatInResponsePkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInResponsePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInResponsePkts.setDescription('The total number of RIP response recieved.')
ripStatOutRequestPkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutRequestPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatOutRequestPkts.setDescription('The total number of RIP requests transmitted.')
ripStatOutResponsePkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatOutResponsePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatOutResponsePkts.setDescription('The total number of RIP responses transmitted.')
ripStatRouteTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatRouteTimeout.setStatus('current')
if mibBuilder.loadTexts: ripStatRouteTimeout.setDescription('The total number of RIP route timeouts.')
ripStatInBadSizePkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSizePkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSizePkts.setDescription('The total number of bad size RIP packets recieved.')
ripStatInBadVersion = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadVersion.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadVersion.setDescription('The total number of RIP bad versions recieved.')
ripStatInBadZeros = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadZeros.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadZeros.setDescription('The total number of RIP bad zeros recieved.')
ripStatInBadSourcePort = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSourcePort.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSourcePort.setDescription('The total number of RIP bad source port recieved.')
ripStatInBadSourceIP = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInBadSourceIP.setStatus('current')
if mibBuilder.loadTexts: ripStatInBadSourceIP.setDescription('The total number of RIP bad source IP recieved.')
ripStatInSelfRcvPkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 13, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripStatInSelfRcvPkts.setStatus('current')
if mibBuilder.loadTexts: ripStatInSelfRcvPkts.setDescription('The total number of RIP packets from self received.')
arpStatEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatEntries.setStatus('current')
if mibBuilder.loadTexts: arpStatEntries.setDescription('The current number of ARP entries.')
arpStatHighWater = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatHighWater.setStatus('current')
if mibBuilder.loadTexts: arpStatHighWater.setDescription('The highest number of ARP entries.')
arpStatMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpStatMaxEntries.setStatus('current')
if mibBuilder.loadTexts: arpStatMaxEntries.setDescription('The maximum number of ARP entries.')
routeStatEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 3, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatEntries.setDescription('The current number of IP routes.')
routeStatHighWater = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 3, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatHighWater.setStatus('current')
if mibBuilder.loadTexts: routeStatHighWater.setDescription('The highest number of IP routes.')
routeStatMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 3, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: routeStatMaxEntries.setStatus('current')
if mibBuilder.loadTexts: routeStatMaxEntries.setDescription('The maximum number of IP routes.')
dnsStatInGoodDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatInGoodDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatInGoodDnsRequests.setDescription('The total number of DNS request packets which are received.')
dnsStatInBadDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatInBadDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatInBadDnsRequests.setDescription('The total number of DNS request packets received that were dropped.')
dnsStatOutDnsRequests = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsStatOutDnsRequests.setStatus('current')
if mibBuilder.loadTexts: dnsStatOutDnsRequests.setDescription('The total number of DNS response packets that have been transmitted.')
vrrpStatInAdvers = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatInAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatInAdvers.setDescription('The number of good VRRP advertisements which are received.')
vrrpStatOutAdvers = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatOutAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatOutAdvers.setDescription('The number of good VRRP advertisements which are transmitted.')
vrrpStatOutBadAdvers = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpStatOutBadAdvers.setStatus('current')
if mibBuilder.loadTexts: vrrpStatOutBadAdvers.setDescription('The number of bad VRRP advertisements which are received.')
ipClearStats = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipClearStats.setStatus('current')
if mibBuilder.loadTexts: ipClearStats.setDescription('Setting this to clear(2) results in clearing the IP statistics.')
ifStatsTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7, 2), )
if mibBuilder.loadTexts: ifStatsTable.setStatus('current')
if mibBuilder.loadTexts: ifStatsTable.setDescription('The table of Interface Statistics.')
ifStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ifStatsIndex"))
if mibBuilder.loadTexts: ifStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ifStatsEntry.setDescription('IP Interface statistics.')
ifStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ifStatsIndex.setDescription('The index of the IP interface for which these statistics apply.')
ifClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifClearStats.setStatus('current')
if mibBuilder.loadTexts: ifClearStats.setDescription('Setting this to clear(2) results in clearing the statistics for this\n         IP interface (if) stats.')
ospfGeneralStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1))
ospfCumRxTxStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1))
ospfCumNbrChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2))
ospfCumIntfChangeStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3))
ospfTimersKickOffStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4))
ospfArea = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2))
ospfAreaRxTxStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1), )
if mibBuilder.loadTexts: ospfAreaRxTxStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxStats.setDescription('The table of OSPF Area Rx/Tx Statistics.')
ospfAreaRxTxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfAreaRxTxIndex"))
if mibBuilder.loadTexts: ospfAreaRxTxStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxStatsEntry.setDescription('Rx Tx packet Statistics about a OSPF area.')
ospfAreaRxTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxTxIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxTxIndex.setDescription('The index of the ospf Area for which these statistics apply.')
ospfAreaRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxPkts.setDescription('The total number of OSPF packets received in this OSPF area.')
ospfAreaTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxPkts.setDescription('The total number of OSPF packets transmitted in this OSPF area.')
ospfAreaRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxHello.setDescription('The total number of Hello packets received in this OSPF area.')
ospfAreaTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxHello.setDescription('The total number of Hello packets transmitted in this OSPF\n         area.')
ospfAreaRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxDatabase.setDescription('The total number of Database Description packets transmitted \n         for this OSPF area.')
ospfAreaTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxDatabase.setDescription('The total number of Database Description packets transmitted \n         for this OSPF area.')
ospfAreaRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsReqs.setDescription('The total number of Link State Request packets received for \n         this OSPF area.')
ospfAreaTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsReqs.setDescription('The total number of Link State Request packets transmitted for \n         this OSPF area.')
ospfAreaRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received for \n         this OSPF area.')
ospfAreaTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted\n         for this OSPF area.')
ospfAreaRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfAreaRxlsUpdates.setDescription('The total number of Link State Update packets received for \n         this OSPF area.')
ospfAreaTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfAreaTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for \n         this OSPF area.')
ospfAreaNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2), )
if mibBuilder.loadTexts: ospfAreaNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrChangeStats.setDescription('The table of OSPF Area Neighbour Statistics.')
ospfAreaNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfAreaNbrIndex"))
if mibBuilder.loadTexts: ospfAreaNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrChangeStatsEntry.setDescription('Area Neighbour Change Statistics about a OSPF area.')
ospfAreaNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrIndex.setDescription('The index of the ospf Area for which these statistics apply.')
ospfAreaNbrhello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrhello.setDescription('The total number of Hello packets received from neighbours\n         in this OSPF area.')
ospfAreaNbrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrStart.setDescription('The total number of neighbours in this state (i.e. an indication\n         that  Hello packets should now be sent to the neighbour at intervals\n         of HelloInterval seconds.) in this OSPF area.')
ospfAreaNbrAdjointOk = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrAdjointOk.setDescription('The total number of decisions to be made (again) as to whether\n         an adjacency should be established/maintained with the neighbour.\n         for this OSPF area.')
ospfAreaNbrNegotiationDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrNegotiationDone.setDescription('The total number of neighbours in this state wherein the \n         Master/slave relationship has been negotiated, and sequence\n         numbers have been exchanged, for this OSPF area.')
ospfAreaNbrExchangeDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrExchangeDone.setDescription("The total number of neighbours in this state (i.e. in an\n         adjacency's final state) having transimitted a full sequence \n         of Database Description packets, for this OSPF area.")
ospfAreaNbrBadRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrBadRequests.setDescription('The sum total number of Link State Requests which have been received\n         for a link state advertisement not contained in the database across\n         this OSPF area.')
ospfAreaNbrBadSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrBadSequence.setDescription('The total number of Database Description packets which have been\n         received that either \n         a) has an unexpected DD sequence number\n         b) Unexpectedly has the init bit set\n         c) Has an options field differing from the last Options field\n            received in a Database Description packet.\n         Any of these conditions indicate that some error has occured during\n         adjacency establishment for this OSPF area.')
ospfAreaNbrLoadingDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrLoadingDone.setDescription('The total number of link state updates received for all \n         out-of-date portions of the database in this OSPF area.')
ospfAreaNbrN1way = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrN1way.setDescription('The total number of Hello packets received from neighbours, in\n         which this router is not mentioned in this OSPF area.')
ospfAreaNbrRstAd = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrRstAd.setDescription('The total number of times the Neighbour adjacency has been reset\n         across this OPSF area.')
ospfAreaNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial\n         state of a neighbour conversation.) in this OSPF area.')
ospfAreaNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfAreaNbrN2way.setDescription('The total number of Hello packets received from neighbours, in\n         which this router is mentioned in this OSPF area.')
ospfAreaChangeStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3), )
if mibBuilder.loadTexts: ospfAreaChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaChangeStats.setDescription('The table of OSPF Area Change Statistics.')
ospfAreaChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfAreaIntfIndex"))
if mibBuilder.loadTexts: ospfAreaChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaChangeStatsEntry.setDescription('Area  Change Statistics about a OSPF area.')
ospfAreaIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfIndex.setDescription('The index of the OSPF Area for which these statistics apply.')
ospfAreaIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfHello.setDescription('The total number of Hello packets sent on this OSPF area.')
ospfAreaIntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfDown.setDescription('The total number of interfaces down in this OSPF area.')
ospfAreaIntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfLoop.setDescription('The total number of interfaces no longer connected to \n         the attatched network in this OSPF area.')
ospfAreaIntfUnloop = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfUnloop.setDescription('The total number of interfaces connected to the attatched\n\t network in this OSPF area..')
ospfAreaIntfWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfWaitTimer.setDescription('The total number of times the Wait Timer has been fired,\n         (indicating the end of the waiting period that is required\n          before electing a (Backup) Designated Router) for this \n          OSPF area.')
ospfAreaIntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfBackup.setDescription('The total number of Backup Designated Routers on the attatched\n         network for this OSPF area.')
ospfAreaIntfNbrChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfAreaIntfNbrChange.setDescription('The total number of changes in the set of bidirectional neighbours\n         associated with the interface in this OSPF area.')
ospfAreaErrorStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4), )
if mibBuilder.loadTexts: ospfAreaErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrorStats.setDescription('The table of OSPF Area Error Statistics.')
ospfAreaErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfAreaErrIndex"))
if mibBuilder.loadTexts: ospfAreaErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrorStatsEntry.setDescription('Error Statistics for an OSPF area.')
ospfAreaErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrIndex.setDescription('The index of the OSPF Area for which these statistics apply.')
ospfAreaErrAuthFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrAuthFailure.setDescription('The total number of packets received with a wrong password in \n         this area.')
ospfAreaErrNetmaskMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrNetmaskMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrNetmaskMismatch.setDescription('The total number of packets received with a wrong netmask in \n         this area.')
ospfAreaErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrHelloMismatch.setDescription('The total number of packets received with a different hello interval\n         in this area.')
ospfAreaErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrDeadMismatch.setDescription('The total number of packets received with a different dead interval\n         in this area.')
ospfAreaErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrOptionsMismatch.setDescription('The total number of packets received with a different options\n         in this area.')
ospfAreaErrUnknownNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaErrUnknownNbr.setStatus('current')
if mibBuilder.loadTexts: ospfAreaErrUnknownNbr.setDescription('The total number of packets received from an unknown neighbor\n         in this area.')
ospfInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3))
ospfIntfRxTxStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1), )
if mibBuilder.loadTexts: ospfIntfRxTxStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxStats.setDescription('The table of OSPF Interface Rx/Tx packet Statistics.')
ospfIntfRxTxStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIntfRxTxIndex"))
if mibBuilder.loadTexts: ospfIntfRxTxStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxStatsEntry.setDescription('OSPF interface Rx/Tx packet statistics.')
ospfIntfRxTxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxTxIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxTxIndex.setDescription('The OSPF interface for which these statistics apply.')
ospfIntfRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxPkts.setDescription('The total number of OSPF packets received for this OSPF interface.')
ospfIntfTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxPkts.setDescription('The total number of OSPF packets transmitted for this OSPF interface.')
ospfIntfRxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxHello.setDescription('The total number of Hello packets received \n         for this OSPF interface.')
ospfIntfTxHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxHello.setDescription('The total number of Hello packets transmitted \n         for this OSPF interface.')
ospfIntfRxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxDatabase.setDescription('The total number of Database Description packets received \n         for this OSPF interface.')
ospfIntfTxDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxDatabase.setDescription('The total number of Database Description packets transmitted \n         for this OSPF interface.')
ospfIntfRxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsReqs.setDescription('The total number of Link State Request packets received\n         for this OSPF interface.')
ospfIntfTxlsReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsReqs.setDescription('The total number of Link State Request packets transmitted\n         for this OSPF interface.')
ospfIntfRxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsAcks.setDescription('The total number of Link State Acknowledgement packets received\n         for this OSPF interface.')
ospfIntfTxlsAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsAcks.setDescription('The total number of Link State Acknowledgement packets transmitted\n         for this OSPF interface.')
ospfIntfRxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfIntfRxlsUpdates.setDescription('The total number of Link State Update packets received for \n         this OSPF interface.')
ospfIntfTxlsUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfIntfTxlsUpdates.setDescription('The total number of Link State Update packets transmitted for \n         this OSPF interface.')
ospfIntfNbrChangeStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2), )
if mibBuilder.loadTexts: ospfIntfNbrChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChangeStats.setDescription('The table of OSPF Interface Neighbour change Statistics.')
ospfIntfNbrChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIntfNbrIndex"))
if mibBuilder.loadTexts: ospfIntfNbrChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChangeStatsEntry.setDescription('OSPF interface Neighbour Change statistics.')
ospfIntfNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrIndex.setDescription('The index of the OSPF Interface for which these statistics apply.')
ospfIntfNbrhello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrhello.setDescription('The total number of Hello packets received from neighbours\n         in this OSPF interface.')
ospfIntfNbrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrStart.setDescription('The total number of neighbours in this state (i.e. an indication\n         that  Hello packets should now be sent to the neighbour at intervals\n         of HelloInterval seconds.) in this OSPF interface.')
ospfIntfNbrAdjointOk = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrAdjointOk.setDescription('The total number of decisions to be made (again) as to whether\n         an adjacency should be established/maintained with the neighbour.\n         for this OSPF interface.')
ospfIntfNbrNegotiationDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrNegotiationDone.setDescription('The total number of neighbours in this state wherein the \n         Master/slave relationship has been negotiated, and sequence\n         numbers have been exchanged, for this OSPF interface.')
ospfIntfNbrExchangeDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrExchangeDone.setDescription("The total number of neighbours in this state (i.e. in an\n         adjacency's final state) having transimitted a full sequence \n         of Database Description packets, for this OSPF interface.")
ospfIntfNbrBadRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrBadRequests.setDescription('The total number of Link State Requests which have been received\n         for a link state advertisement not contained in the database for\n         this interface.')
ospfIntfNbrBadSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrBadSequence.setDescription('The total number of Database Description packets which have been\n         received that either \n         a) has an unexpected DD sequence number\n         b) Unexpectedly has the init bit set\n         c) Has an options field differing from the last Options field\n            received in a Database Description packet.\n         Any of these conditions indicate that some error has occured during\n         adjacency establishment for this interface.')
ospfIntfNbrLoadingDone = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrLoadingDone.setDescription('The total number of link state updates received for all \n         out-of-date portions of the database for this OSPF interface.')
ospfIntfNbrN1way = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrN1way.setDescription('The total number of Hello packets received from neighbours, in\n         which this router is not mentioned for this OSPF interface.')
ospfIntfNbrRstAd = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrRstAd.setDescription('The sum total number of times the Neighbour adjacency has been reset\n         on this interface.')
ospfIntfNbrDown = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial\n         state of a neighbour conversation.) for this interface.')
ospfIntfNbrN2way = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrN2way.setDescription('The total number of Hello packets received from neighbours, in\n         which this router is mentioned for this OSPF interface.')
ospfIntfChangeStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3), )
if mibBuilder.loadTexts: ospfIntfChangeStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfChangeStats.setDescription('The table of OSPF Interface change Statistics.')
ospfIntfChangeStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIntfIndex"))
if mibBuilder.loadTexts: ospfIntfChangeStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfChangeStatsEntry.setDescription('OSPF interface Change statistics.')
ospfIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfIndex.setDescription('The index of the OSPF Interface for which these statistics apply.')
ospfIntfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfIntfHello.setDescription('The total number of Hello packets sent by this interface.')
ospfIntfDown = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfIntfDown.setDescription('The total number of times the interface was down.')
ospfIntfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfIntfLoop.setDescription('The total number of times the interface was no longer connected to \n         the attatched network.')
ospfIntfUnloop = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfIntfUnloop.setDescription('The total number of times the interface, connected back to\n         the attatched network.')
ospfIntfWaitTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfIntfWaitTimer.setDescription('The total number of times the Wait Timer has been fired,\n         (indicating the end of the waiting period that is required\n          before electing a (Backup) Designated Router) for this \n          OSPF interface.')
ospfIntfBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfIntfBackup.setDescription('The total number of Backup Designated Routers on the attatched\n         network for this OSPF interface.')
ospfIntfNbrChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfIntfNbrChange.setDescription('The total number of changes in the set of bidirectional neighbours\n         associated with the interface for this OSPF interface.')
ospfIntfErrorStats = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4), )
if mibBuilder.loadTexts: ospfIntfErrorStats.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrorStats.setDescription('The table of OSPF Interface Error Statistics.')
ospfIntfErrorStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIntfErrIndex"))
if mibBuilder.loadTexts: ospfIntfErrorStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrorStatsEntry.setDescription('Error Statistics for an OSPF area.')
ospfIntfErrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrIndex.setDescription('The index of the OSPF Intf for which these statistics apply.')
ospfIntfErrAuthFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrAuthFailure.setDescription('The total number of packets received with a wrong password in \n         this area.')
ospfIntfErrNetmaskMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrNetmaskMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrNetmaskMismatch.setDescription('The total number of packets received with a wrong netmask in \n         this area.')
ospfIntfErrHelloMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrHelloMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrHelloMismatch.setDescription('The total number of packets received with a different hello interval\n         in this area.')
ospfIntfErrDeadMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrDeadMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrDeadMismatch.setDescription('The total number of packets received with a different dead interval\n         in this area.')
ospfIntfErrOptionsMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrOptionsMismatch.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrOptionsMismatch.setDescription('The total number of packets received with a different options\n         in this area.')
ospfIntfErrUnknownNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfErrUnknownNbr.setStatus('current')
if mibBuilder.loadTexts: ospfIntfErrUnknownNbr.setDescription('The total number of packets received from an unknown neighbor\n         in this area.')
ospfCumRxPkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxPkts.setDescription('The sum total of all OSPF packets received on all OSPF areas\n         and interfaces.')
ospfCumTxPkts = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxPkts.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxPkts.setDescription('The sum total of all OSPF packets transmitted on all OSPF areas\n         and interfaces.')
ospfCumRxHello = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxHello.setDescription('The sum total of all Hello packets received on all OSPF areas\n         and interfaces.')
ospfCumTxHello = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxHello.setDescription('The sum total of all Hello packets transmitted on all OSPF areas\n         and interfaces.')
ospfCumRxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxDatabase.setDescription('The sum total of all Database Description packets received on\n         all OSPF areas and interfaces.')
ospfCumTxDatabase = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxDatabase.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxDatabase.setDescription('The sum total of all Database Description packets transmitted on\n         all OSPF areas and interfaces.')
ospfCumRxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsReqs.setDescription('The sum total of all Link State Request packets received on\n         all OSPF areas and interfaces.')
ospfCumTxlsReqs = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsReqs.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsReqs.setDescription('The sum total of all Link State Request packets transmitted on\n         all OSPF areas and interfaces.')
ospfCumRxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsAcks.setDescription('The sum total of all Link State Acknowledgement packets received\n         on all OSPF areas and interfaces.')
ospfCumTxlsAcks = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsAcks.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsAcks.setDescription('The sum total of all Link State Acknowledgement packets transmitted\n         on all OSPF areas and interfaces.')
ospfCumRxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumRxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfCumRxlsUpdates.setDescription('The sum total of all Link State Update packets received\n         on all OSPF areas and interfaces.')
ospfCumTxlsUpdates = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumTxlsUpdates.setStatus('current')
if mibBuilder.loadTexts: ospfCumTxlsUpdates.setDescription('The sum total of all Link State Update packets transmitted\n         on all OSPF areas and interfaces.')
ospfCumNbrhello = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrhello.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrhello.setDescription('The sum total of all Hello packets received from neighbours\n         on all OSPF areas and interfaces.')
ospfCumNbrStart = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrStart.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrStart.setDescription('The sum total number of neighbours in this state (i.e. an indication\n         that  Hello packets should now be sent to the neighbour at intervals\n         of HelloInterval seconds.) across all OSPF areas and interfaces.')
ospfCumNbrAdjointOk = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrAdjointOk.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrAdjointOk.setDescription('The sum total number of decisions to be made (again) as to whether\n         an adjacency should be established/maintained with the neighbour\n         across all OSPF areas and interfaces.')
ospfCumNbrNegotiationDone = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrNegotiationDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrNegotiationDone.setDescription('The sum total number of neighbours in this state wherein the \n         Master/slave relationship has been negotiated, and sequence\n         numbers have been exchanged, across all OSPF areas and \n         interfaces.')
ospfCumNbrExchangeDone = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrExchangeDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrExchangeDone.setDescription("The sum total number of neighbours in this state (i.e. in an\n         adjacency's final state) having transimitted a full sequence \n         of Database Description packets, across all OSPF areas\n         and interfaces.")
ospfCumNbrBadRequests = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrBadRequests.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrBadRequests.setDescription('The sum total number of Link State Requests which have been received\n         for a link state advertisement not contained in the database across\n         all interfaces and OSPF areas.')
ospfCumNbrBadSequence = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrBadSequence.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrBadSequence.setDescription('The sum total number of Database Description packets which have been\n         received that either \n         a) has an unexpected DD sequence number\n         b) Unexpectedly has the init bit set\n         c) Has an options field differing from the last Options field\n            received in a Database Description packet.\n         Any of these conditions indicate that some error has occured during\n         adjacency establishment for all OSPF areas and interfaces.')
ospfCumNbrLoadingDone = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrLoadingDone.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrLoadingDone.setDescription('The sum total number of link state updates received for all \n         out-of-date portions of the database across all OSPF areas\n         and interfaces.')
ospfCumNbrN1way = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrN1way.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrN1way.setDescription('The sum total number of Hello packets received from neighbours, in\n         which this router is not mentioned across all OSPF interfaces\n         and areas.')
ospfCumNbrRstAd = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrRstAd.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrRstAd.setDescription('The sum total number of times the Neighbour adjacency has been reset\n         across all OPSF areas and interfaces.')
ospfCumNbrDown = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrDown.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrDown.setDescription('The total number of Neighbouring routers down (i.e. in the initial\n         state of a neighbour conversation.) across all OSPF areas and \n         interfaces.')
ospfCumNbrN2way = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumNbrN2way.setStatus('current')
if mibBuilder.loadTexts: ospfCumNbrN2way.setDescription('The sum total number of Hello packets received from neighbours, in\n         which this router is mentioned across all OSPF interfaces\n         and areas.')
ospfCumIntfHello = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfHello.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfHello.setDescription('The sum total number of Hello packets sent on all interfaces \n         and areas')
ospfCumIntfDown = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfDown.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfDown.setDescription('The sum total number of interfaces down in all OSPF areas.')
ospfCumIntfLoop = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfLoop.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfLoop.setDescription('The sum total of interfaces no longer connected to \n         the attatched network across all OSPF areas and interfaces.')
ospfCumIntfUnloop = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfUnloop.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfUnloop.setDescription('The sum total number of interfaces, connected to\n         the attatched network in all OSPF areas.')
ospfCumIntfWaitTimer = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfWaitTimer.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfWaitTimer.setDescription('The sum total number of times the Wait Timer has been fired,\n         (indicating the end of the waiting period that is required\n          before electing a (Backup) Designated Router) across all \n          OSPF areas and interfaces.')
ospfCumIntfBackup = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfBackup.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfBackup.setDescription('The sum total number of Backup Designated Routers on the attatched\n         network for all OSPF areas and interfaces.')
ospfCumIntfNbrChange = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfCumIntfNbrChange.setStatus('current')
if mibBuilder.loadTexts: ospfCumIntfNbrChange.setDescription('The sum total number of changes in the set of bidirectional\n         neighbours associated with any interface across all OSPF areas.')
ospfTmrsKckOffHello = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffHello.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffHello.setDescription('The sum total number of times the Hello timer has been fired\n         (which triggers the send of a Hello packet) across all OPSF \n         areas and interfaces.')
ospfTmrsKckOffRetransmit = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffRetransmit.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffRetransmit.setDescription('The sum total number of times the Retransmit timer has been\n         fired across all OPSF areas and interfaces.')
ospfTmrsKckOffLsaLock = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffLsaLock.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffLsaLock.setDescription('The sum total number of times the Lsa Lock timer has been \n         fired across all OSPF areas and interfaces.')
ospfTmrsKckOffLsaAck = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffLsaAck.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffLsaAck.setDescription('The sum total number of times the Lsa Ack timer has been \n         fired across all ospf areas and interfaces.')
ospfTmrsKckOffDbage = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffDbage.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffDbage.setDescription('The total number of times the Dbage has been fired.')
ospfTmrsKckOffSummary = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffSummary.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffSummary.setDescription('The total number of times the Summary timer has been fired.')
ospfTmrsKckOffAseExport = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 6, 1, 4, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTmrsKckOffAseExport.setStatus('current')
if mibBuilder.loadTexts: ospfTmrsKckOffAseExport.setDescription('The total number of times the ASE Export timer has been fired.')
ip6InReceives = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6InReceives.setStatus('current')
if mibBuilder.loadTexts: ip6InReceives.setDescription('The total number of input datagrams received from\n         interfaces, including those received in error.')
ip6ForwDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6ForwDatagrams.setStatus('current')
if mibBuilder.loadTexts: ip6ForwDatagrams.setDescription('The number of input datagrams for which this entity was not\n         their final IP destination, as a result of which an attempt\n         was made to find a route to forward them to that final\n         destination.')
ip6InDelivers = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6InDelivers.setStatus('current')
if mibBuilder.loadTexts: ip6InDelivers.setDescription('The total number of input datagrams successfully\n         delivered to IP user-protocols (including ICMP).')
ip6InDiscards = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6InDiscards.setStatus('current')
if mibBuilder.loadTexts: ip6InDiscards.setDescription('The number of input IP datagrams for which no problems were\n         encountered to prevent their continued processing, but which were\n         discarded (e.g., for lack of buffer space).  Note that this counter\n         does not include any datagrams discarded while awaiting re-assembly.')
ip6InUnknownProtos = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6InUnknownProtos.setStatus('current')
if mibBuilder.loadTexts: ip6InUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully\n         but discarded because of an unknown or unsupported protocol.')
ip6InAddrErrors = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6InAddrErrors.setStatus('current')
if mibBuilder.loadTexts: ip6InAddrErrors.setDescription("The number of input datagrams discarded because the IP address\n         in their IP header's destination field was not a valid address\n         to be received at this entity.")
ip6OutRequests = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6OutRequests.setStatus('current')
if mibBuilder.loadTexts: ip6OutRequests.setDescription('The total number of IP datagrams which local IP\n         user-protocols (including ICMP) supplied to IP in\n         requests for transmission.  Note that this counter does not\n         include any datagrams counted in ipForwDatagrams.')
ip6OutNoRoutes = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6OutNoRoutes.setStatus('current')
if mibBuilder.loadTexts: ip6OutNoRoutes.setDescription("The number of IP datagrams discarded because no route \n        could be found to transmit them to their destination.\n        Note that this Counter32 includes any packets counted in \n        ipForwDatagrams which meet this`no-route' criterion. \n        Note that this includes any datagrams which a host cannot \n        route because all of its default gateways are down.")
ip6ReasmOKs = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6ReasmOKs.setStatus('current')
if mibBuilder.loadTexts: ip6ReasmOKs.setDescription('The number of IP datagrams successfully re-assembled.')
ip6ReasmFails = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6ReasmFails.setStatus('current')
if mibBuilder.loadTexts: ip6ReasmFails.setDescription('The number of failures detected by the IP re-assembly.')
ip6icmpInMsgs = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6icmpInMsgs.setStatus('current')
if mibBuilder.loadTexts: ip6icmpInMsgs.setDescription('The total number of ICMP messages received.  \n         Note that this Counter32 includes all those counted by \n         icmpInErrors.')
ip6icmpOutMsgs = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6icmpOutMsgs.setStatus('current')
if mibBuilder.loadTexts: ip6icmpOutMsgs.setDescription('The total number of ICMP messages attempted to send.  Note that \n         this Counter32 includes all those counted by icmp6OutErrors.')
ip6icmpInErrors = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6icmpInErrors.setStatus('current')
if mibBuilder.loadTexts: ip6icmpInErrors.setDescription('The number of ICMP messages received but determined as having \n         ICMP-specific errors (bad ICMP checksums, bad length, etc.).')
ip6icmpOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 10, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6icmpOutErrors.setStatus('current')
if mibBuilder.loadTexts: ip6icmpOutErrors.setDescription('The number of ICMP messages did not send due to problems \n         discovered within ICMP such as a lack of buffers.')
icmp6StatsTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1), )
if mibBuilder.loadTexts: icmp6StatsTable.setStatus('current')
if mibBuilder.loadTexts: icmp6StatsTable.setDescription('Statistics for ICMP6.')
icmp6StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "icmp6StatsIndx"))
if mibBuilder.loadTexts: icmp6StatsEntry.setStatus('current')
if mibBuilder.loadTexts: icmp6StatsEntry.setDescription('Statistics for IGMP Snooping.')
icmp6StatsIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6StatsIndx.setStatus('current')
if mibBuilder.loadTexts: icmp6StatsIndx.setDescription('The index of this statistics table.')
icmp6IntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6IntfIndex.setStatus('current')
if mibBuilder.loadTexts: icmp6IntfIndex.setDescription('IP interface index in interface configuration table.')
icmp6InMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InMsgs.setStatus('current')
if mibBuilder.loadTexts: icmp6InMsgs.setDescription('The total number of ICMP messages received.  Note that this \n         Counter32 includes all those counted by icmpInErrors.')
icmp6InErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InErrors.setStatus('current')
if mibBuilder.loadTexts: icmp6InErrors.setDescription('The number of ICMP messages received but determined as having \n         ICMP-specific errors (bad ICMP checksums, bad length, etc.).')
icmp6InEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InEchos.setStatus('current')
if mibBuilder.loadTexts: icmp6InEchos.setDescription('The number of ICMP Echo request messages received.')
icmp6InEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InEchoReps.setStatus('current')
if mibBuilder.loadTexts: icmp6InEchoReps.setDescription('The number of ICMP Echo Reply messages received.')
icmp6InNSs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InNSs.setStatus('current')
if mibBuilder.loadTexts: icmp6InNSs.setDescription('The number of neighbor solicitations received.')
icmp6InNAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InNAs.setStatus('current')
if mibBuilder.loadTexts: icmp6InNAs.setDescription('The number of neighbor advertisements received.')
icmp6InRSs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InRSs.setStatus('current')
if mibBuilder.loadTexts: icmp6InRSs.setDescription('The number of router solicitations received.')
icmp6InRAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InRAs.setStatus('current')
if mibBuilder.loadTexts: icmp6InRAs.setDescription('The number of router advertisements received.')
icmp6InDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InDestUnreachs.setStatus('current')
if mibBuilder.loadTexts: icmp6InDestUnreachs.setDescription('The number of ICMP Destination Unreachable messages received.')
icmp6InTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InTimeExcds.setStatus('current')
if mibBuilder.loadTexts: icmp6InTimeExcds.setDescription('The number of ICMP Time Exceeded messages received.')
icmp6InTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InTooBigs.setStatus('current')
if mibBuilder.loadTexts: icmp6InTooBigs.setDescription('The number of ICMP too big messages received.')
icmp6InParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InParmProbs.setStatus('current')
if mibBuilder.loadTexts: icmp6InParmProbs.setDescription('The number of ICMP Parameter Problem messages received.')
icmp6InRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6InRedirects.setStatus('current')
if mibBuilder.loadTexts: icmp6InRedirects.setDescription('The number of ICMP Redirect messages received.')
icmp6OutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutMsgs.setStatus('current')
if mibBuilder.loadTexts: icmp6OutMsgs.setDescription('The total number of ICMP messages which this entity \n         attempted to send.  Note that this Counter32 includes \n         all those counted by icmp6OutErrors.')
icmp6OutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutErrors.setStatus('current')
if mibBuilder.loadTexts: icmp6OutErrors.setDescription('The number of ICMP messages which this entity did not \n         send due to problems discovered within ICMP\n         such as a lack of buffers.')
icmp6OutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutEchos.setStatus('current')
if mibBuilder.loadTexts: icmp6OutEchos.setDescription('The number of ICMP Echo request messages sent.')
icmp6OutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutEchoReps.setStatus('current')
if mibBuilder.loadTexts: icmp6OutEchoReps.setDescription('The number of ICMP Echo Reply messages sent.')
icmp6OutNSs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutNSs.setStatus('current')
if mibBuilder.loadTexts: icmp6OutNSs.setDescription('The number of neighbor solicitations sent.')
icmp6OutNAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutNAs.setStatus('current')
if mibBuilder.loadTexts: icmp6OutNAs.setDescription('The number of neighbor advertisements sent.')
icmp6OutRSs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutRSs.setStatus('current')
if mibBuilder.loadTexts: icmp6OutRSs.setDescription('The number of router solicitations sent.')
icmp6OutRAs = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutRAs.setStatus('current')
if mibBuilder.loadTexts: icmp6OutRAs.setDescription('The number of router advertisements sent.')
icmp6OutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 11, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmp6OutRedirects.setStatus('current')
if mibBuilder.loadTexts: icmp6OutRedirects.setDescription('The number of ICMP Redirect messages sent.  For a host, this \n         object will always be zero, since hosts do not send redirects.')
ip6GwStatsTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1), )
if mibBuilder.loadTexts: ip6GwStatsTable.setStatus('current')
if mibBuilder.loadTexts: ip6GwStatsTable.setDescription('Statistics for IP6 Gateway.')
ip6GwStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ip6GwStatsIndex"))
if mibBuilder.loadTexts: ip6GwStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ip6GwStatsEntry.setDescription('Statistics for IP6 Gateway.')
ip6GwStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwStatsIndex.setStatus('current')
if mibBuilder.loadTexts: ip6GwStatsIndex.setDescription('The index of Gw6 statistics.')
ip6GwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwIndex.setStatus('current')
if mibBuilder.loadTexts: ip6GwIndex.setDescription('Gateway index in gateway configuration table.')
ip6GwEchoreq = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwEchoreq.setStatus('current')
if mibBuilder.loadTexts: ip6GwEchoreq.setDescription('The number of GW Echo request messages .')
ip6GwEchoresp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwEchoresp.setStatus('current')
if mibBuilder.loadTexts: ip6GwEchoresp.setDescription('The number of GW Echo response messages .')
ip6GwFails = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwFails.setStatus('current')
if mibBuilder.loadTexts: ip6GwFails.setDescription('The number of GWs fails.')
ip6GwMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwMaster.setStatus('current')
if mibBuilder.loadTexts: ip6GwMaster.setDescription('The master gateway.')
ip6IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6IfIndex.setStatus('current')
if mibBuilder.loadTexts: ip6IfIndex.setDescription('The IP6 interface.')
ip6GwRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 2, 12, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip6GwRetry.setStatus('current')
if mibBuilder.loadTexts: ip6GwRetry.setDescription('The number of retries.')
ipIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1), )
if mibBuilder.loadTexts: ipIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipIntfInfoTable.setDescription('The table of IP interface information.')
intfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "intfInfoIndex"))
if mibBuilder.loadTexts: intfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: intfInfoEntry.setDescription('A row in IP interface information table.')
intfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: intfInfoIndex.setDescription('The interface number for which the information is related.')
intfInfoIpver = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoIpver.setStatus('current')
if mibBuilder.loadTexts: intfInfoIpver.setDescription('The type of IP address.')
intfInfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoAddr.setStatus('current')
if mibBuilder.loadTexts: intfInfoAddr.setDescription('The IP address of the interface.')
intfInfoNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoNetMask.setStatus('current')
if mibBuilder.loadTexts: intfInfoNetMask.setDescription('The subnet mask of the interface.')
intfInfoBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoBcastAddr.setStatus('current')
if mibBuilder.loadTexts: intfInfoBcastAddr.setDescription('The broadcast address of the interface.')
intfInfoVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoVlan.setStatus('current')
if mibBuilder.loadTexts: intfInfoVlan.setDescription('The VLAN number for this interface.')
intfInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoStatus.setStatus('current')
if mibBuilder.loadTexts: intfInfoStatus.setDescription('The status of the interface.')
intfInfoLinkLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 9, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: intfInfoLinkLocalAddr.setStatus('current')
if mibBuilder.loadTexts: intfInfoLinkLocalAddr.setDescription('The site local address of the interface.')
ipRouteInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1), )
if mibBuilder.loadTexts: ipRouteInfoTable.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoTable.setDescription('The table of run-time IP routes.')
ipRouteInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipRouteInfoIndx"))
if mibBuilder.loadTexts: ipRouteInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoEntry.setDescription('A row in the run-time IP route table')
ipRouteInfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoIndx.setDescription('The index of this route table.')
ipRouteInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoDestIp.setDescription('The destination IP address of this route.')
ipRouteInfoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoMask.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoMask.setDescription('The destination IP mask of this route.')
ipRouteInfoGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoGateway.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoGateway.setDescription('The next-hop router address for this route.')
ipRouteInfoTag = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("fixed", 1), ("static", 2), ("addr", 3), ("rip", 4), ("broadcast", 5), ("martian", 6), ("multicast", 7), ("vip", 8), ("bgp", 9), ("ospf", 10), ("none", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoTag.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoTag.setDescription('The tag-type for this route.')
ipRouteInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("indirect", 1), ("direct", 2), ("local", 3), ("broadcast", 4), ("martian", 5), ("multicast", 6), ("other", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoType.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoType.setDescription('The type of the route.')
ipRouteInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoInterface.setDescription('The interface number for which the destination\taddress is applicable.')
ipRouteInfoGateway1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoGateway1.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoGateway1.setDescription('The next-hop router address for this route.')
ipRouteInfoGateway2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoGateway2.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoGateway2.setDescription('The next-hop router address for this route.')
ipRouteInfoMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRouteInfoMetric.setStatus('current')
if mibBuilder.loadTexts: ipRouteInfoMetric.setDescription('The Metric for this route.')
routeTableClear = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeTableClear.setStatus('current')
if mibBuilder.loadTexts: routeTableClear.setDescription('Setting this value to clear(2) clears the route table.')
arpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1), )
if mibBuilder.loadTexts: arpInfoTable.setStatus('current')
if mibBuilder.loadTexts: arpInfoTable.setDescription('The table of ARP entries.')
arpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "arpInfoDestIp"))
if mibBuilder.loadTexts: arpInfoEntry.setStatus('current')
if mibBuilder.loadTexts: arpInfoEntry.setDescription('A row in the ARP table')
arpInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: arpInfoDestIp.setDescription('The destination IP address of the ARP entry.')
arpInfoMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: arpInfoMacAddr.setDescription('The MAC address for the ARP entry.')
arpInfoVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoVLAN.setStatus('current')
if mibBuilder.loadTexts: arpInfoVLAN.setDescription('The VLAN identifier for the ARP entry.')
arpInfoSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoSrcPort.setStatus('current')
if mibBuilder.loadTexts: arpInfoSrcPort.setDescription("The  port number on which this entry's equivalence is effective.")
arpInfoRefPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoRefPorts.setStatus('current')
if mibBuilder.loadTexts: arpInfoRefPorts.setDescription('The reference SPs associated with this ARP entry.')
arpInfoFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("clear", 1), ("unresolved", 2), ("permanent", 3), ("indirect", 4), ("layer4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInfoFlag.setStatus('current')
if mibBuilder.loadTexts: arpInfoFlag.setDescription('The flag associated with this ARP entry.')
arpCacheClear = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpCacheClear.setStatus('current')
if mibBuilder.loadTexts: arpCacheClear.setDescription('Setting this value to clear(2) clears the ARP cache.')
vrrpInfoVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1), )
if mibBuilder.loadTexts: vrrpInfoVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrTable.setDescription('The table of VRRP virtual router run-time information.')
vrrpInfoVirtRtrTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpInfoVirtRtrIndex"))
if mibBuilder.loadTexts: vrrpInfoVirtRtrTableEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrTableEntry.setDescription('The run-time information about a VRRP virtual router.')
vrrpInfoVirtRtrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrIndex.setDescription('The VRRP virtual router index.')
vrrpInfoVirtRtrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("init", 1), ("master", 2), ("backup", 3), ("holdoff", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrState.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrState.setDescription('The VRRP virtual router state.')
vrrpInfoVirtRtrOwnership = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("owner", 1), ("renter", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrOwnership.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrOwnership.setDescription('The VRRP virtual router ownership status.')
vrrpInfoVirtRtrServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrServer.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrServer.setDescription('The VRRP server state identifies virtual routers that support \n         Layer 4 services.')
vrrpInfoVirtRtrProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpInfoVirtRtrProxy.setStatus('current')
if mibBuilder.loadTexts: vrrpInfoVirtRtrProxy.setDescription('The VRRP proxy state identifies virtual proxy routers.')
ospfGeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1))
ospfStartTime = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfStartTime.setStatus('current')
if mibBuilder.loadTexts: ospfStartTime.setDescription('The time when ospf has been started.')
ospfProcessUptime = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfProcessUptime.setStatus('current')
if mibBuilder.loadTexts: ospfProcessUptime.setDescription('The time since ospf has been started.')
ospfLsTypesSupported = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfLsTypesSupported.setStatus('current')
if mibBuilder.loadTexts: ospfLsTypesSupported.setDescription('The Link State Types that are supported.')
ospfIntfCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIntfCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospfIntfCountForRouter.setDescription('The number of interfaces for this router.')
ospfVlinkCountForRouter = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfVlinkCountForRouter.setStatus('current')
if mibBuilder.loadTexts: ospfVlinkCountForRouter.setDescription('The number of virtual links for this router.')
ospfTotalNeighbours = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNeighbours.setDescription('The total number of OSPF neighbours.')
ospfNbrInInitState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInInitState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInInitState.setDescription('The number of neighbours in the initial state of exchange.')
ospfNbrInExchState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInExchState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInExchState.setDescription('The number of neighbours in the exchange state.')
ospfNbrInFullState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNbrInFullState.setStatus('current')
if mibBuilder.loadTexts: ospfNbrInFullState.setDescription('The number of neighbours in the Full state of exchange.')
ospfTotalAreas = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalAreas.setDescription('The Total number of areas.')
ospfTotalTransitAreas = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalTransitAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalTransitAreas.setDescription('The Total number of Transit areas.')
ospfTotalNssaAreas = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNssaAreas.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNssaAreas.setDescription('The Total number of NSSA areas.')
ospfAreaInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2), )
if mibBuilder.loadTexts: ospfAreaInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoTable.setDescription('The table of OSPF Area information.')
ospfAreaInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfAreaInfoIndex"))
if mibBuilder.loadTexts: ospfAreaInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoEntry.setDescription('Information about a OSPF area.')
ospfAreaInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoIndex.setDescription('The OSPF area number for which the OSPF info table is related.')
ospfTotalNumberOfInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfTotalNumberOfInterfaces.setStatus('current')
if mibBuilder.loadTexts: ospfTotalNumberOfInterfaces.setDescription('The total number of interfaces for this OSPF area.')
ospfNumberOfInterfacesUp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNumberOfInterfacesUp.setStatus('current')
if mibBuilder.loadTexts: ospfNumberOfInterfacesUp.setDescription('The number of interfaces UP in area.')
ospfNumberOfLsdbEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfNumberOfLsdbEntries.setStatus('current')
if mibBuilder.loadTexts: ospfNumberOfLsdbEntries.setDescription('The number of Link State Database entries for this OSPF area.')
ospfAreaInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfAreaInfoId.setStatus('current')
if mibBuilder.loadTexts: ospfAreaInfoId.setDescription('The IP address of the OSPF area.')
ospfIntfInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3), )
if mibBuilder.loadTexts: ospfIntfInfoTable.setStatus('current')
if mibBuilder.loadTexts: ospfIntfInfoTable.setDescription('The table of OSPF Interface information.')
ospfIntfInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIfInfoIndex"))
if mibBuilder.loadTexts: ospfIntfInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIntfInfoEntry.setDescription('Information about a OSPF interface.')
ospfIfInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoIndex.setDescription('The OSPF interface number for which the OSPF info table is related.')
ospfIfDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfIfDesignatedRouterIP.setDescription('The OSPF Designated Router ID (IP Address) for this OSPF interface.')
ospfIfBackupDesignatedRouterIP = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfBackupDesignatedRouterIP.setStatus('current')
if mibBuilder.loadTexts: ospfIfBackupDesignatedRouterIP.setDescription('The OSPF Backup Designated Router ID (IP Address) for this OSPF\n         interface.')
ospfIfWaitInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfWaitInterval.setStatus('current')
if mibBuilder.loadTexts: ospfIfWaitInterval.setDescription('The OSPF Wait interval for this OSPF interface.')
ospfIfTotalNeighbours = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfTotalNeighbours.setStatus('current')
if mibBuilder.loadTexts: ospfIfTotalNeighbours.setDescription('The Total number of neighbours for this OSPF interface.')
ospfIfInfoIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfInfoIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfInfoIpAddress.setDescription('The IP address of the OSPF interface.')
ospfIfNbrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5), )
if mibBuilder.loadTexts: ospfIfNbrTable.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrTable.setDescription('The table of OSPF Interface Neighbor information.')
ospfIfNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIfNbrIntfIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "ospfIfNbrIpAddr"))
if mibBuilder.loadTexts: ospfIfNbrEntry.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrEntry.setDescription('Information about a OSPF interface, neighbor pair.')
ospfIfNbrIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIntfIndex.setDescription('The OSPF Interface number for which this Interface/Nbr table is \n         related.')
ospfIfNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIpAddr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIpAddr.setDescription('The OSPF Neighbor ID .')
ospfIfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrPriority.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrPriority.setDescription('The priority of the OSPF neighbor.')
ospfIfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoway", 4), ("exStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrState.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrState.setDescription('The state of the OSPF neighbor.')
ospfIfNbrDesignatedRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrDesignatedRtr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrDesignatedRtr.setDescription('The IP Address of the Designated Router for this OSPF Neighbor.')
ospfIfNbrBackupDesignatedRtr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrBackupDesignatedRtr.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrBackupDesignatedRtr.setDescription('The IP Address of the backup designated Router for this OSPF Neighbor.')
ospfIfNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 4, 5, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ospfIfNbrIpAddress.setStatus('current')
if mibBuilder.loadTexts: ospfIfNbrIpAddress.setDescription('The IP Address of the OSPF Neighbor.')
gatewayInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1), )
if mibBuilder.loadTexts: gatewayInfoTable.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoTable.setDescription('The table containing information for the default gateways.')
gatewayInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "gatewayInfoIndex"))
if mibBuilder.loadTexts: gatewayInfoEntry.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoEntry.setDescription('A row in the gateway information table')
gatewayInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoIndex.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoIndex.setDescription('The gateway number for which the information is related.')
gatewayInfoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoAddr.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoAddr.setDescription('The IP address of the default gateway.')
gatewayInfoVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoVlan.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoVlan.setDescription('The VLAN number for this gateway.')
gatewayInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoStatus.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoStatus.setDescription('The status of the default gateway.')
gatewayInfoAddr6 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 5, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayInfoAddr6.setStatus('current')
if mibBuilder.loadTexts: gatewayInfoAddr6.setDescription('The IP6 address of the default gateway.')
nbrcacheInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1), )
if mibBuilder.loadTexts: nbrcacheInfoTable.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoTable.setDescription('The table of nbrcache information.')
nbrcacheInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "nbrcacheInfoIndex"))
if mibBuilder.loadTexts: nbrcacheInfoEntry.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoEntry.setDescription('Information about neighbor discovery protocol.')
nbrcacheInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoIndex.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoIndex.setDescription('The index of the nbrcache entry.')
nbrcacheInfoDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoDestIp.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoDestIp.setDescription('The destination IP address of the nbrcache entry.')
nbrcacheInfoState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("undef", 1), ("reach", 2), ("stale", 3), ("delay", 4), ("probe", 5), ("inval", 6), ("unknown", 7), ("incmp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoState.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoState.setDescription('The state of the nbrcache entry.')
nbrcacheInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("undef", 1), ("other", 2), ("invalid", 3), ("dynamic", 4), ("static", 5), ("local", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoType.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoType.setDescription('The type of the nbrcache entry.')
nbrcacheInfoMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoMacAddr.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoMacAddr.setDescription('The MAC address for the nbrcache entry.')
nbrcacheInfoVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoVlanId.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoVlanId.setDescription('The VLAN identifier for the nbrcache entry.')
nbrcacheInfoPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoPortNum.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoPortNum.setDescription("The  port number on which this entry's equivalence is effective.")
nbrcacheClear = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbrcacheClear.setStatus('current')
if mibBuilder.loadTexts: nbrcacheClear.setDescription('Setting this value to clear(2) clears the Nbr cache,\n         When read ok(1) is  returned.')
nbrcacheInfoTotDynamicEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoTotDynamicEntries.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoTotDynamicEntries.setDescription('The total number of dynamic neighbor cache entries.')
nbrcacheInfoTotLocalEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoTotLocalEntries.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoTotLocalEntries.setDescription('The total number of local neighbor cache entries.')
nbrcacheInfoTotOtherEntries = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbrcacheInfoTotOtherEntries.setStatus('current')
if mibBuilder.loadTexts: nbrcacheInfoTotOtherEntries.setDescription('The total number of other neighbor cache entries.')
ipRoute6InfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1), )
if mibBuilder.loadTexts: ipRoute6InfoTable.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoTable.setDescription('The table of run-time IP6 routes.')
ipRoute6InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ipRoute6InfoIndx"))
if mibBuilder.loadTexts: ipRoute6InfoEntry.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoEntry.setDescription('A row in the run-time IP6 route table.')
ipRoute6InfoIndx = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoIndx.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoIndx.setDescription('The index of this route6 table.')
ipRoute6InfoDestIp6 = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoDestIp6.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoDestIp6.setDescription('The destination of the route.')
ipRoute6InfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoInterface.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoInterface.setDescription('The interface of the route.')
ipRoute6InfoNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoNextHop.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoNextHop.setDescription('The next hop of the route.')
ipRoute6InfoProto = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("isis", 1), ("rip", 2), ("ospf", 3), ("static", 4), ("local", 5), ("bgp", 6), ("stlow", 7), ("ospfi", 8), ("ospfe", 9), ("ospfe2", 10), ("ospfa", 11), ("ripa", 12), ("bgpa", 13), ("igmp", 14), ("unknown", 15), ("natpt", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRoute6InfoProto.setStatus('current')
if mibBuilder.loadTexts: ipRoute6InfoProto.setDescription('The protocol type of the route.')
rip2GeneralInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 1))
ripInfoState = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoState.setStatus('current')
if mibBuilder.loadTexts: ripInfoState.setDescription('RIP global state.')
ripInfoUpdatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoUpdatePeriod.setStatus('current')
if mibBuilder.loadTexts: ripInfoUpdatePeriod.setDescription('Update Period in seconds.')
ripInfoVip = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoVip.setStatus('current')
if mibBuilder.loadTexts: ripInfoVip.setDescription('Advertise VIP Host Routes.')
ripInfoStaticSupply = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoStaticSupply.setStatus('current')
if mibBuilder.loadTexts: ripInfoStaticSupply.setDescription('Advertise Static Routes.')
rip2InfoIntfTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2), )
if mibBuilder.loadTexts: rip2InfoIntfTable.setStatus('current')
if mibBuilder.loadTexts: rip2InfoIntfTable.setDescription('The information table of RIP.')
ripInfoIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "ripInfoIntfIndex"))
if mibBuilder.loadTexts: ripInfoIntfEntry.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfEntry.setDescription('Information about  RIP on IP interface.')
ripInfoIntfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfIndex.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfIndex.setDescription('The interface number for which the RIP information is related.')
ripInfoIntfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ripVersion1", 1), ("ripVersion2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfVersion.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfVersion.setDescription('RIP version.')
ripInfoIntfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfAddress.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfAddress.setDescription('The interface address.')
ripInfoIntfState = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfState.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfState.setDescription('The status of RIP protocol.')
ripInfoIntfListen = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfListen.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfListen.setDescription('The status of listening to route updates.')
ripInfoIntfTrigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfTrigUpdate.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfTrigUpdate.setDescription('The status of triggered updates.')
ripInfoIntfMcastUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfMcastUpdate.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfMcastUpdate.setDescription('The status of multicast updates.')
ripInfoIntfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfPoisonReverse.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfPoisonReverse.setDescription('The status of RIP poison reverse.')
ripInfoIntfSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfSupply.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfSupply.setDescription('The status of supplying route updates.')
ripInfoIntfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfMetric.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfMetric.setDescription('RIP route metric for this interface.')
ripInfoIntfAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("password", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfAuth.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfAuth.setDescription('The type of Authentication used on this interface.')
ripInfoIntfKey = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfKey.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfKey.setDescription('RIP update authentication password.')
ripInfoIntfDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 10, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("both", 1), ("listen", 2), ("supply", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInfoIntfDefault.setStatus('current')
if mibBuilder.loadTexts: ripInfoIntfDefault.setDescription('Specifies what RIP does with default routes.')
rip2RoutesInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1), )
if mibBuilder.loadTexts: rip2RoutesInfoTable.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoTable.setDescription('The table of rip routes.')
rip2RoutesInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "rip2RoutesInfoDestIndex"), (0, "ALTEON-CHEETAH-NETWORK-MIB", "rip2RoutesInfoNxtHopIndex"))
if mibBuilder.loadTexts: rip2RoutesInfoEntry.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoEntry.setDescription('Information about rip routes.')
rip2RoutesInfoDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2RoutesInfoDestIndex.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoDestIndex.setDescription('The index of the rip routes.')
rip2RoutesInfoNxtHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2RoutesInfoNxtHopIndex.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoNxtHopIndex.setDescription('The index of the next hop.')
rip2RoutesInfoDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2RoutesInfoDestination.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoDestination.setDescription('The destination of the rip route.')
rip2RoutesInfoIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2RoutesInfoIpAddress.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoIpAddress.setDescription('The ipaddress of the next hop.')
rip2RoutesInfoMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 3, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2RoutesInfoMetric.setStatus('current')
if mibBuilder.loadTexts: rip2RoutesInfoMetric.setDescription('RIP route metric for this route.')
vrrpOperVirtRtrTable = MibTable((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1, 1), )
if mibBuilder.loadTexts: vrrpOperVirtRtrTable.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrTable.setDescription('An entry in the table of virtual routers.')
vrrpOperVirtRtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1, 1, 1), ).setIndexNames((0, "ALTEON-CHEETAH-NETWORK-MIB", "vrrpOperVirtRtrIndex"))
if mibBuilder.loadTexts: vrrpOperVirtRtrEntry.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrEntry.setDescription('A row in the vrrpOperVirtRtrTable ')
vrrpOperVirtRtrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrrpOperVirtRtrIndex.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrIndex.setDescription('The index for the  VRRP virtual router.')
vrrpOperVirtRtrBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("backup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpOperVirtRtrBackup.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrBackup.setDescription("When set to a value of 'backup(2)' it forces the specified \n         master virtual router into backup mode.\n         'ok(1)' is returned when the object os read.")
vrrpOperVirtRtrGroupBackup = MibScalar((1, 3, 6, 1, 4, 1, 1872, 2, 5, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("backup", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrrpOperVirtRtrGroupBackup.setStatus('current')
if mibBuilder.loadTexts: vrrpOperVirtRtrGroupBackup.setDescription("When set to a value of 'backup(2)' it forces the specified \n         master virtual router group into backup mode.\n         'ok(1)' is returned when the object os read.")
mibBuilder.exportSymbols("ALTEON-CHEETAH-NETWORK-MIB", ospfAreaInfoEntry=ospfAreaInfoEntry, ipStaticArpCfg=ipStaticArpCfg, vrrpNewCfgVirtRtrVrGrpRem=vrrpNewCfgVirtRtrVrGrpRem, ipCurCfgRmapPrec=ipCurCfgRmapPrec, bgpCurCfgAggrMask=bgpCurCfgAggrMask, ospfCurCfgIntfId=ospfCurCfgIntfId, ipNewCfgGwRetry=ipNewCfgGwRetry, vrrpCurCfgVirtRtrInterval=vrrpCurCfgVirtRtrInterval, ip6InReceives=ip6InReceives, ospfNewCfgEbgpRemoveOutRmap=ospfNewCfgEbgpRemoveOutRmap, ospfLsTypesSupported=ospfLsTypesSupported, ipNewCfgGwPriority=ipNewCfgGwPriority, ripCurCfgIntfPoisonReverse=ripCurCfgIntfPoisonReverse, ospfNewCfgVirtIntfNbr=ospfNewCfgVirtIntfNbr, ospfIntfChangeStatsEntry=ospfIntfChangeStatsEntry, routeTableClear=routeTableClear, ospfRangeTableMaxSize=ospfRangeTableMaxSize, ipFwdNewCfgLocalDelete=ipFwdNewCfgLocalDelete, ospfRedistributeFixed=ospfRedistributeFixed, ipFwdNewCfgPortIndex=ipFwdNewCfgPortIndex, ipCurCfgNwfState=ipCurCfgNwfState, ipCurCfgRmapAp=ipCurCfgRmapAp, ospfIntfErrAuthFailure=ospfIntfErrAuthFailure, ipNewCfgAspathAction=ipNewCfgAspathAction, vrrpCurCfgVirtRtrTckVlanPort=vrrpCurCfgVirtRtrTckVlanPort, ipNewCfgRmapEntry=ipNewCfgRmapEntry, vrrpNewCfgGenState=vrrpNewCfgGenState, ipFwdNewCfgPortState=ipFwdNewCfgPortState, icmp6InEchoReps=icmp6InEchoReps, ripNewCfgIntfDefault=ripNewCfgIntfDefault, ospfIntfRxTxIndex=ospfIntfRxTxIndex, ipCurCfgIntfRouteAdv=ipCurCfgIntfRouteAdv, ospfCumIntfUnloop=ospfCumIntfUnloop, ripInfoIntfListen=ripInfoIntfListen, ipNewCfgStaticRouteMask=ipNewCfgStaticRouteMask, ospfIntfRxlsReqs=ospfIntfRxlsReqs, ipNewCfgStaticRouteAction=ipNewCfgStaticRouteAction, ipNewCfgNwfState=ipNewCfgNwfState, vrrpNewCfgVirtRtrTckL4Port=vrrpNewCfgVirtRtrTckL4Port, vrrpStatOutBadAdvers=vrrpStatOutBadAdvers, icmp6InRedirects=icmp6InRedirects, icmp6OutEchoReps=icmp6OutEchoReps, ipCurCfgAlistState=ipCurCfgAlistState, rip2NewCfgVip=rip2NewCfgVip, ripInfoIntfState=ripInfoIntfState, ospfCurCfgHostIndex=ospfCurCfgHostIndex, ifStatsTable=ifStatsTable, rip2CurCfgStaticSupply=rip2CurCfgStaticSupply, bgpNewCfgPeerFixedState=bgpNewCfgPeerFixedState, bgpNewCfgAggrAddr=bgpNewCfgAggrAddr, ipCurCfgStaticArpEntry=ipCurCfgStaticArpEntry, ospfCurCfgMdkeyKey=ospfCurCfgMdkeyKey, arpStatMaxEntries=arpStatMaxEntries, ospfIntfNbrIndex=ospfIntfNbrIndex, ripInfoStaticSupply=ripInfoStaticSupply, vrrpCurCfgVirtRtrVrGrpTckVlanPort=vrrpCurCfgVirtRtrVrGrpTckVlanPort, bgpCurCfgPeerRemoteAddr=bgpCurCfgPeerRemoteAddr, ipRouteInfoGateway1=ipRouteInfoGateway1, ipRouteInfoEntry=ipRouteInfoEntry, bgpCurCfgAggrAddr=bgpCurCfgAggrAddr, rip2NewCfgUpdatePeriod=rip2NewCfgUpdatePeriod, ipNewCfgIntfVlan=ipNewCfgIntfVlan, ipCurCfgIntfPrefixLen=ipCurCfgIntfPrefixLen, ripNewCfgIntfState=ripNewCfgIntfState, vrrpCurCfgGenTckL4PortInc=vrrpCurCfgGenTckL4PortInc, vrrpCurCfgVirtRtrGrpTckHsrp=vrrpCurCfgVirtRtrGrpTckHsrp, ripStatOutPackets=ripStatOutPackets, vrrpNewCfgVirtRtrIndx=vrrpNewCfgVirtRtrIndx, vrrpNewCfgVirtRtrGrpPreempt=vrrpNewCfgVirtRtrGrpPreempt, ip6gwStats=ip6gwStats, ipCurCfgGwInterval=ipCurCfgGwInterval, ospfAreaNbrChangeStatsEntry=ospfAreaNbrChangeStatsEntry, ipNewCfgNwfIndex=ipNewCfgNwfIndex, ipNewCfgStaticArpMAC=ipNewCfgStaticArpMAC, ospfCumRxTxStats=ospfCumRxTxStats, ripStatInBadSourcePort=ripStatInBadSourcePort, ospfIntfTxlsReqs=ospfIntfTxlsReqs, nbrcacheInfoTotOtherEntries=nbrcacheInfoTotOtherEntries, bgpNewCfgPeerDefaultAction=bgpNewCfgPeerDefaultAction, vrrpCurCfgVirtRtrVrGrpName=vrrpCurCfgVirtRtrVrGrpName, ipNewCfgAspathTable=ipNewCfgAspathTable, ospfCurCfgStaticOutRmapList=ospfCurCfgStaticOutRmapList, ospfAreaTxlsReqs=ospfAreaTxlsReqs, rip2CurCfgVip=rip2CurCfgVip, dnsNewCfgSecondaryIpAddr=dnsNewCfgSecondaryIpAddr, bgpNewCfgPeerEntry=bgpNewCfgPeerEntry, icmp6InDestUnreachs=icmp6InDestUnreachs, nbrcacheInfoTotLocalEntries=nbrcacheInfoTotLocalEntries, ospfNewCfgMdkeyKey=ospfNewCfgMdkeyKey, ospfGeneralStats=ospfGeneralStats, layer3=layer3, ipFwdGeneralCfg=ipFwdGeneralCfg, nbrcacheClear=nbrcacheClear, ipNewCfgBootpAddr=ipNewCfgBootpAddr, vrrpCurCfgVirtRtrTckVirtRtr=vrrpCurCfgVirtRtrTckVirtRtr, ripNewCfgIntfDefListen=ripNewCfgIntfDefListen, arpNewCfgReARPPeriod=arpNewCfgReARPPeriod, vrrpNewCfgVirtRtrGrpID=vrrpNewCfgVirtRtrGrpID, vrrpCfg=vrrpCfg, ipNewCfgGwInterval=ipNewCfgGwInterval, bgpNewCfgAggrTable=bgpNewCfgAggrTable, ripNewCfgIntfKey=ripNewCfgIntfKey, ospfNewCfgFixedAddOutRmap=ospfNewCfgFixedAddOutRmap, ripInfoIntfKey=ripInfoIntfKey, vrrpCurCfgIfAuthType=vrrpCurCfgIfAuthType, ospfIntfTxDatabase=ospfIntfTxDatabase, ip6GwStatsTable=ip6GwStatsTable, ospfAreaIntfBackup=ospfAreaIntfBackup, ospfNumberOfLsdbEntries=ospfNumberOfLsdbEntries, vrrpOperVirtRtrEntry=vrrpOperVirtRtrEntry, ipCurCfgGwState=ipCurCfgGwState, ipNewCfgRmapState=ipNewCfgRmapState, ospfNewCfgIntfIndex=ospfNewCfgIntfIndex, ospfIntfNbrhello=ospfIntfNbrhello, vrrpNewCfgIfIndx=vrrpNewCfgIfIndx, rip2NewCfgStaticSupply=rip2NewCfgStaticSupply, rip2CurCfgState=rip2CurCfgState, ipFwdCurCfgLocalTable=ipFwdCurCfgLocalTable, vrrpCurCfgVirtRtrVrGrpTckIpIntf=vrrpCurCfgVirtRtrVrGrpTckIpIntf, ipNewCfgNwfMask=ipNewCfgNwfMask, vrrpInfoVirtRtrState=vrrpInfoVirtRtrState, vrrpCurCfgVirtRtrGrpSharing=vrrpCurCfgVirtRtrGrpSharing, ospfCurCfgDefaultRouteMetric=ospfCurCfgDefaultRouteMetric, ospfNewCfgVirtIntfAreaId=ospfNewCfgVirtIntfAreaId, ospfCumIntfNbrChange=ospfCumIntfNbrChange, bgpNewCfgMaxASPath=bgpNewCfgMaxASPath, ipCurCfgAlistEntry=ipCurCfgAlistEntry, ospfCurCfgHostTable=ospfCurCfgHostTable, ripStatInSelfRcvPkts=ripStatInSelfRcvPkts, arpInfoFlag=arpInfoFlag, ospfNewCfgVirtIntfTable=ospfNewCfgVirtIntfTable, ripInfoIntfAddress=ripInfoIntfAddress, ospfCurCfgIntfIndex=ospfCurCfgIntfIndex, vrrpNewCfgVirtRtrGrpIndx=vrrpNewCfgVirtRtrGrpIndx, ip6IfIndex=ip6IfIndex, vrrpCurCfgVirtRtrGrpIndx=vrrpCurCfgVirtRtrGrpIndx, ospfAreaTxDatabase=ospfAreaTxDatabase, bgpNewCfgPeerDelete=bgpNewCfgPeerDelete, arpInfoMacAddr=arpInfoMacAddr, ipFwdNewCfgLocalEntry=ipFwdNewCfgLocalEntry, ospfAreaNbrDown=ospfAreaNbrDown, ospfCumNbrStart=ospfCumNbrStart, vrrpNewCfgVirtRtrTckHsrp=vrrpNewCfgVirtRtrTckHsrp, ipCurCfgRmapMetric=ipCurCfgRmapMetric, ipCurCfgAspathTable=ipCurCfgAspathTable, ipCurCfgAspathAS=ipCurCfgAspathAS, ipInterfaceCfg=ipInterfaceCfg, icmp6InRAs=icmp6InRAs, dnsStatInGoodDnsRequests=dnsStatInGoodDnsRequests, ipCurCfgIntfIpv6Addr=ipCurCfgIntfIpv6Addr, bgpNewCfgAggrMask=bgpNewCfgAggrMask, ospfIntfErrHelloMismatch=ospfIntfErrHelloMismatch, vrrpCurCfgVirtRtrVrGrpTableEntry=vrrpCurCfgVirtRtrVrGrpTableEntry, ip6ReasmOKs=ip6ReasmOKs, vrrpNewCfgVirtRtrVrGrpTableEntry=vrrpNewCfgVirtRtrVrGrpTableEntry, ipRoute6InfoTable=ipRoute6InfoTable, ipFwdCurCfgPortIndex=ipFwdCurCfgPortIndex, intfInfoIpver=intfInfoIpver, ospfCurCfgMdkeyEntry=ospfCurCfgMdkeyEntry, ospfNewCfgFixedMetric=ospfNewCfgFixedMetric, bgpCurCfgLocalPref=bgpCurCfgLocalPref, ospfIntfNbrBadSequence=ospfIntfNbrBadSequence, vrrpInfoVirtRtrProxy=vrrpInfoVirtRtrProxy, nbrcacheInfoPortNum=nbrcacheInfoPortNum, ipForwardCfg=ipForwardCfg, ip6InUnknownProtos=ip6InUnknownProtos, ospfCumNbrBadRequests=ospfCumNbrBadRequests, ospfCurCfgFixedMetric=ospfCurCfgFixedMetric, ospfIntfInfoEntry=ospfIntfInfoEntry, ospfCurCfgIbgpOutRmapList=ospfCurCfgIbgpOutRmapList, vrrpNewCfgVirtRtrGrpDelete=vrrpNewCfgVirtRtrGrpDelete, ripInfoIntfSupply=ripInfoIntfSupply, ospfAreaNbrhello=ospfAreaNbrhello, gatewayInfoIndex=gatewayInfoIndex, ipFwdCurCfgPortEntry=ipFwdCurCfgPortEntry, ipCurCfgIntfIpVer=ipCurCfgIntfIpVer, dnsNewCfgDomainName=dnsNewCfgDomainName, vrrpCurCfgGenTckHsrvInc=vrrpCurCfgGenTckHsrvInc, ospfAreaErrNetmaskMismatch=ospfAreaErrNetmaskMismatch, ospfNewCfgMdkeyIndex=ospfNewCfgMdkeyIndex, icmp6OutRAs=icmp6OutRAs, ipCurCfgGwAddr=ipCurCfgGwAddr, icmp6Stats=icmp6Stats, ipRouteInfoMetric=ipRouteInfoMetric, layer3Configs=layer3Configs, PYSNMP_MODULE_ID=layer3, ipNewCfgGwIpv6Addr=ipNewCfgGwIpv6Addr, vrrpCurCfgVirtRtrVrGrpTckVirtRtrNo=vrrpCurCfgVirtRtrVrGrpTckVirtRtrNo, ospfCurCfgIntfTable=ospfCurCfgIntfTable, ospfAreaNbrN1way=ospfAreaNbrN1way, ospfCurCfgVirtIntfTable=ospfCurCfgVirtIntfTable, clearStats=clearStats, bgpNewCfgPeerState=bgpNewCfgPeerState, ospfNewCfgIbgpAddOutRmap=ospfNewCfgIbgpAddOutRmap, vrrpCurCfgVirtRtrTableEntry=vrrpCurCfgVirtRtrTableEntry, vrrpNewCfgGenTckIpIntfInc=vrrpNewCfgGenTckIpIntfInc, ipCurCfgGwEntry=ipCurCfgGwEntry, ipNewCfgBootpState=ipNewCfgBootpState, dnsNewCfgPrimaryIpAddr=dnsNewCfgPrimaryIpAddr, ospfGeneral=ospfGeneral, vrrpNewCfgVirtRtrGrpInterval=vrrpNewCfgVirtRtrGrpInterval, vrrpNewCfgVirtRtrTckVirtRtr=vrrpNewCfgVirtRtrTckVirtRtr, vrrpNewCfgVirtRtrVrGrpTckIpIntf=vrrpNewCfgVirtRtrVrGrpTckIpIntf, ipFwdNewCfgLocalMask=ipFwdNewCfgLocalMask, ospfAreaNbrBadRequests=ospfAreaNbrBadRequests, ospfCurCfgAreaTable=ospfCurCfgAreaTable, vrrpNewCfgVirtRtrPreempt=vrrpNewCfgVirtRtrPreempt, ipNewCfgGwMetric=ipNewCfgGwMetric, ipFwdCurCfgState=ipFwdCurCfgState, ripStatInResponsePkts=ripStatInResponsePkts, ripInfoIntfEntry=ripInfoIntfEntry, ipNewCfgStaticArpAction=ipNewCfgStaticArpAction, ospfIntfWaitTimer=ospfIntfWaitTimer, ipCurCfgAlistRmapIndex=ipCurCfgAlistRmapIndex, ospfAreaNbrChangeStats=ospfAreaNbrChangeStats, ipCurCfgBootpAddr=ipCurCfgBootpAddr, ripNewCfgIntfEntry=ripNewCfgIntfEntry, vrrpCurCfgGenState=vrrpCurCfgGenState, ospfIntfErrIndex=ospfIntfErrIndex, ospfAreaRxPkts=ospfAreaRxPkts, ipRouteInfoInterface=ipRouteInfoInterface, gatewayInfoStatus=gatewayInfoStatus, vrrpStatOutAdvers=vrrpStatOutAdvers, ospfCurCfgVirtIntfMdkey=ospfCurCfgVirtIntfMdkey, ospfNewCfgRangeTable=ospfNewCfgRangeTable, bgpCurCfgPeerRemoteAs=bgpCurCfgPeerRemoteAs, bgpNewCfgPeerInRmapList=bgpNewCfgPeerInRmapList, ipCurCfgNwfEntry=ipCurCfgNwfEntry, ospfAreaInfoTable=ospfAreaInfoTable, bgpCurCfgState=bgpCurCfgState, vrrpOperVirtRtrBackup=vrrpOperVirtRtrBackup, ipNewCfgIntfEntry=ipNewCfgIntfEntry, bgpCurCfgPeerMetric=bgpCurCfgPeerMetric, ipGeneralCfg=ipGeneralCfg, ipCurCfgNwfAddr=ipCurCfgNwfAddr, vrrpCurCfgVirtRtrGrpTableEntry=vrrpCurCfgVirtRtrGrpTableEntry, vrrpNewCfgGenTckL4PortInc=vrrpNewCfgGenTckL4PortInc, bgpNewCfgLocalPref=bgpNewCfgLocalPref, bgpCurCfgPeerStaticState=bgpCurCfgPeerStaticState, ospfCumNbrRstAd=ospfCumNbrRstAd, intfInfoIndex=intfInfoIndex, ospfIntfErrNetmaskMismatch=ospfIntfErrNetmaskMismatch, arpStatHighWater=arpStatHighWater, ospfIntfUnloop=ospfIntfUnloop, vrrpCurCfgVirtRtrGrpTckIpIntf=vrrpCurCfgVirtRtrGrpTckIpIntf, rip2Cfg=rip2Cfg, ipRmapCfg=ipRmapCfg, ripCurCfgIntfSupply=ripCurCfgIntfSupply, vrrpVirtRtrGrpTableMaxSize=vrrpVirtRtrGrpTableMaxSize, ipCurCfgAlistMetric=ipCurCfgAlistMetric, ospfCurCfgAreaAuthType=ospfCurCfgAreaAuthType, vrrpNewCfgVirtRtrDelete=vrrpNewCfgVirtRtrDelete, ipNewCfgAspathEntry=ipNewCfgAspathEntry, ipNewCfgRouterID=ipNewCfgRouterID)
mibBuilder.exportSymbols("ALTEON-CHEETAH-NETWORK-MIB", arpCacheClear=arpCacheClear, bgpCurCfgPeerTtl=bgpCurCfgPeerTtl, ipRoute6InfoProto=ipRoute6InfoProto, ospfCumRxlsUpdates=ospfCumRxlsUpdates, icmp6InNAs=icmp6InNAs, ipNewCfgAlistState=ipNewCfgAlistState, ipCurCfgRmapLp=ipCurCfgRmapLp, ripStatRouteTimeout=ripStatRouteTimeout, vrrpNewCfgVirtRtrGrpTckIpIntf=vrrpNewCfgVirtRtrGrpTckIpIntf, ospfNewCfgRipAddOutRmap=ospfNewCfgRipAddOutRmap, icmp6InNSs=icmp6InNSs, ospfNewCfgVirtIntfEntry=ospfNewCfgVirtIntfEntry, intfInfoVlan=intfInfoVlan, ospfAreaInfoIndex=ospfAreaInfoIndex, ospfCurCfgFixedMetricType=ospfCurCfgFixedMetricType, vrrpInfo=vrrpInfo, vrrpNewCfgGenHoldoff=vrrpNewCfgGenHoldoff, ospfVlinkCountForRouter=ospfVlinkCountForRouter, vrrpNewCfgVirtRtrInterval=vrrpNewCfgVirtRtrInterval, vrrpOper=vrrpOper, ospfHostTableMaxSize=ospfHostTableMaxSize, ospfCurCfgMdkeyIndex=ospfCurCfgMdkeyIndex, ipNewCfgIntfState=ipNewCfgIntfState, vrrpNewCfgVirtRtrVrGrpIndx=vrrpNewCfgVirtRtrVrGrpIndx, arpInfo=arpInfo, vrrpInfoVirtRtrServer=vrrpInfoVirtRtrServer, ipFwdCurCfgLocalSubnet=ipFwdCurCfgLocalSubnet, ospfRouteRedistribution=ospfRouteRedistribution, ospfAreaTxHello=ospfAreaTxHello, ospfCurCfgAreaSpfInterval=ospfCurCfgAreaSpfInterval, ipStaticRouteCfg=ipStaticRouteCfg, ipFwdNewCfgPortTable=ipFwdNewCfgPortTable, ospfCumRxlsReqs=ospfCumRxlsReqs, bgpCurCfgAggrEntry=bgpCurCfgAggrEntry, ip6GwEchoreq=ip6GwEchoreq, icmp6StatsIndx=icmp6StatsIndx, nbrcacheInfoVlanId=nbrcacheInfoVlanId, ospfCurCfgVirtIntfNbr=ospfCurCfgVirtIntfNbr, ospfCumNbrN2way=ospfCumNbrN2way, vrrpCurCfgVirtRtrVrGrpTckRServer=vrrpCurCfgVirtRtrVrGrpTckRServer, ospfAreaRxTxStats=ospfAreaRxTxStats, ipNewCfgIntfTable=ipNewCfgIntfTable, ripCurCfgIntfTrigUpdate=ripCurCfgIntfTrigUpdate, ripCurCfgIntfKey=ripCurCfgIntfKey, ospfNewCfgEbgpAddOutRmap=ospfNewCfgEbgpAddOutRmap, ipCurCfgAspathState=ipCurCfgAspathState, ospfIntfRxlsUpdates=ospfIntfRxlsUpdates, ipNewCfgStaticRouteGateway=ipNewCfgStaticRouteGateway, ipNewCfgStaticArpIp=ipNewCfgStaticArpIp, vrrpNewCfgIfPasswd=vrrpNewCfgIfPasswd, vrrpNewCfgVirtRtrGrpTckRServer=vrrpNewCfgVirtRtrGrpTckRServer, bgpNewCfgAggrDelete=bgpNewCfgAggrDelete, ipNewCfgStaticRouteTable=ipNewCfgStaticRouteTable, ipNewCfgIntfAddr=ipNewCfgIntfAddr, vrrpCurCfgVirtRtrVrGrpTckL4Port=vrrpCurCfgVirtRtrVrGrpTckL4Port, ipRouteInfoTag=ipRouteInfoTag, ospfIfNbrDesignatedRtr=ospfIfNbrDesignatedRtr, ipCurCfgStaticRouteEntry=ipCurCfgStaticRouteEntry, ospfAreaErrUnknownNbr=ospfAreaErrUnknownNbr, ipCurCfgGwArp=ipCurCfgGwArp, bgpCurCfgPeerEntry=bgpCurCfgPeerEntry, bgpNewCfgPeerOutRmapList=bgpNewCfgPeerOutRmapList, ospfAreaChangeStats=ospfAreaChangeStats, icmp6InTooBigs=icmp6InTooBigs, ifStatsIndex=ifStatsIndex, vrrpCurCfgGenHotstandby=vrrpCurCfgGenHotstandby, ospfCumRxDatabase=ospfCumRxDatabase, intfInfoEntry=intfInfoEntry, ospfNewCfgRangeAreaIndex=ospfNewCfgRangeAreaIndex, ipNewCfgRmapWeight=ipNewCfgRmapWeight, arpInfoSrcPort=arpInfoSrcPort, ospfIntfErrorStats=ospfIntfErrorStats, ospfNewCfgEbgpMetricType=ospfNewCfgEbgpMetricType, ospfTmrsKckOffSummary=ospfTmrsKckOffSummary, ospfIntfNbrN1way=ospfIntfNbrN1way, ospfNewCfgRangeHideState=ospfNewCfgRangeHideState, ospfNewCfgMdkeyDelete=ospfNewCfgMdkeyDelete, bgpGeneral=bgpGeneral, ospfIntfRxTxStatsEntry=ospfIntfRxTxStatsEntry, vrrpCurCfgGenTckRServerInc=vrrpCurCfgGenTckRServerInc, ipNewCfgNwfEntry=ipNewCfgNwfEntry, icmp6InErrors=icmp6InErrors, vrrpCurCfgGenHoldoff=vrrpCurCfgGenHoldoff, ospfTmrsKckOffLsaLock=ospfTmrsKckOffLsaLock, ripStatOutRequestPkts=ripStatOutRequestPkts, vrrpNewCfgVirtRtrVrGrpPriority=vrrpNewCfgVirtRtrVrGrpPriority, vrrpCurCfgVirtRtrGrpPriority=vrrpCurCfgVirtRtrGrpPriority, ospfArea=ospfArea, ospfNewCfgState=ospfNewCfgState, ripInfoIntfMetric=ripInfoIntfMetric, ipNewCfgStaticArpIndx=ipNewCfgStaticArpIndx, ipCurCfgStaticArpPort=ipCurCfgStaticArpPort, ospfCurCfgVirtIntfAreaId=ospfCurCfgVirtIntfAreaId, ospfAreaErrorStatsEntry=ospfAreaErrorStatsEntry, ospfInterface=ospfInterface, bgpNewCfgPeerTtl=bgpNewCfgPeerTtl, ipIntfInfo=ipIntfInfo, ipIntfInfoTable=ipIntfInfoTable, ospfNewCfgRipRemoveOutRmap=ospfNewCfgRipRemoveOutRmap, ipNewCfgIntfRouteAdv=ipNewCfgIntfRouteAdv, ospfCumNbrDown=ospfCumNbrDown, icmp6InEchos=icmp6InEchos, ospfCumNbrExchangeDone=ospfCumNbrExchangeDone, icmp6OutErrors=icmp6OutErrors, dnsCurCfgSecondaryIpAddr=dnsCurCfgSecondaryIpAddr, ip6icmpInMsgs=ip6icmpInMsgs, ospfNbrInInitState=ospfNbrInInitState, ospfCumTxPkts=ospfCumTxPkts, ospfCurCfgAreaIndex=ospfCurCfgAreaIndex, ipNewCfgAspathAS=ipNewCfgAspathAS, vrrpNewCfgVirtRtrGrpTableEntry=vrrpNewCfgVirtRtrGrpTableEntry, gatewayInfoAddr=gatewayInfoAddr, vrrpCurCfgIfTable=vrrpCurCfgIfTable, vrrpCurCfgVirtRtrTckL4Port=vrrpCurCfgVirtRtrTckL4Port, vrrpNewCfgVirtRtrGrpTckHsrv=vrrpNewCfgVirtRtrGrpTckHsrv, bgpNewCfgPeerVipState=bgpNewCfgPeerVipState, ospfCumIntfChangeStats=ospfCumIntfChangeStats, ospfIntfNbrChange=ospfIntfNbrChange, rip2RoutesInfoDestination=rip2RoutesInfoDestination, ospfAreaIntfWaitTimer=ospfAreaIntfWaitTimer, ipCurCfgIntfTable=ipCurCfgIntfTable, ospfNewCfgRangeMask=ospfNewCfgRangeMask, ospfCurCfgRipMetric=ospfCurCfgRipMetric, ospfIntfNbrDown=ospfIntfNbrDown, icmp6IntfIndex=icmp6IntfIndex, ripStatInBadZeros=ripStatInBadZeros, ipRmapTableMax=ipRmapTableMax, ospfAreaNbrN2way=ospfAreaNbrN2way, vrrpCurCfgVirtRtrTckIpIntf=vrrpCurCfgVirtRtrTckIpIntf, ospfIfWaitInterval=ospfIfWaitInterval, ripInfoIntfVersion=ripInfoIntfVersion, bgpAggrTableMax=bgpAggrTableMax, ipStaticRouteTableMaxSize=ipStaticRouteTableMaxSize, ospfIntfNbrChangeStats=ospfIntfNbrChangeStats, ipNewCfgAlistMetric=ipNewCfgAlistMetric, vrrpNewCfgVirtRtrTckVlanPort=vrrpNewCfgVirtRtrTckVlanPort, ospfIfNbrBackupDesignatedRtr=ospfIfNbrBackupDesignatedRtr, ripCurCfgIntfEntry=ripCurCfgIntfEntry, vrrpCurCfgVirtRtrIfIndex=vrrpCurCfgVirtRtrIfIndex, ripNewCfgIntfPoisonReverse=ripNewCfgIntfPoisonReverse, ripCurCfgIntfAuth=ripCurCfgIntfAuth, nbrcacheInfoTotDynamicEntries=nbrcacheInfoTotDynamicEntries, ipRoutingInfo=ipRoutingInfo, ospfCumIntfHello=ospfCumIntfHello, ospfTmrsKckOffDbage=ospfTmrsKckOffDbage, vrrpStatInAdvers=vrrpStatInAdvers, ospfCumNbrBadSequence=ospfCumNbrBadSequence, rip2RoutesInfoDestIndex=rip2RoutesInfoDestIndex, ospfStartTime=ospfStartTime, vrrpCurCfgGenTckIpIntfInc=vrrpCurCfgGenTckIpIntfInc, ipNewCfgStaticArpTable=ipNewCfgStaticArpTable, vrrpStats=vrrpStats, ospfNewCfgHostAreaIndex=ospfNewCfgHostAreaIndex, vrrpNewCfgGenTckRServerInc=vrrpNewCfgGenTckRServerInc, ip6GwIndex=ip6GwIndex, ipFwdCurCfgLocalIndex=ipFwdCurCfgLocalIndex, ipNewCfgAlistRmapIndex=ipNewCfgAlistRmapIndex, ospfNewCfgEbgpOutRmapList=ospfNewCfgEbgpOutRmapList, ospfNewCfgFixedRemoveOutRmap=ospfNewCfgFixedRemoveOutRmap, ipCurCfgGwTable=ipCurCfgGwTable, ipRouteInfoGateway=ipRouteInfoGateway, ipNewCfgNwfAddr=ipNewCfgNwfAddr, ospfNewCfgVirtIntfIndex=ospfNewCfgVirtIntfIndex, ospfAreaRxTxIndex=ospfAreaRxTxIndex, ipNewCfgIntfDelete=ipNewCfgIntfDelete, ospfNewCfgStaticMetric=ospfNewCfgStaticMetric, ripNewCfgIntfMetric=ripNewCfgIntfMetric, ospfIntfNbrBadRequests=ospfIntfNbrBadRequests, ipNewCfgStaticRouteIndx=ipNewCfgStaticRouteIndx, ospfCumRxHello=ospfCumRxHello, ospfCurCfgRangeTable=ospfCurCfgRangeTable, ipCurCfgStaticArpMAC=ipCurCfgStaticArpMAC, ospfNewCfgRipMetric=ospfNewCfgRipMetric, ipNewCfgStaticArpVlan=ipNewCfgStaticArpVlan, bgpCurCfgMaxASPath=bgpCurCfgMaxASPath, vrrpNewCfgVirtRtrState=vrrpNewCfgVirtRtrState, ospfCurCfgRangeIndex=ospfCurCfgRangeIndex, arpCfg=arpCfg, bgpNewCfgPeerTable=bgpNewCfgPeerTable, arpInfoRefPorts=arpInfoRefPorts, ripStatInBadSourceIP=ripStatInBadSourceIP, ripNewCfgIntfVersion=ripNewCfgIntfVersion, ipCurCfgASNumber=ipCurCfgASNumber, ripInfoIntfIndex=ripInfoIntfIndex, ospfTmrsKckOffLsaAck=ospfTmrsKckOffLsaAck, nbrcacheInfoDestIp=nbrcacheInfoDestIp, ospfCfg=ospfCfg, ripInfoIntfAuth=ripInfoIntfAuth, bgpNewCfgState=bgpNewCfgState, ipNewCfgStaticArpEntry=ipNewCfgStaticArpEntry, ipCurCfgNwfTable=ipCurCfgNwfTable, ospfNewCfgIntfMdkey=ospfNewCfgIntfMdkey, ospfCumNbrNegotiationDone=ospfCumNbrNegotiationDone, ipNewCfgAlistDelete=ipNewCfgAlistDelete, vrrpCurCfgVirtRtrVrGrpTable=vrrpCurCfgVirtRtrVrGrpTable, vrrpNewCfgVirtRtrVrGrpTable=vrrpNewCfgVirtRtrVrGrpTable, ipCurCfgRmapWeight=ipCurCfgRmapWeight, ospfCurCfgRangeAreaIndex=ospfCurCfgRangeAreaIndex, bgpNewCfgPeerAddOutRmap=bgpNewCfgPeerAddOutRmap, ospfCumIntfLoop=ospfCumIntfLoop, ipBootpCfg=ipBootpCfg, ipGatewayCfg=ipGatewayCfg, ospfIntfInfoTable=ospfIntfInfoTable, ipNewCfgRmapMetric=ipNewCfgRmapMetric, ospfNewCfgEbgpMetric=ospfNewCfgEbgpMetric, ospfNewCfgIbgpMetric=ospfNewCfgIbgpMetric, ipNewCfgIntfIpv6Addr=ipNewCfgIntfIpv6Addr, ospfCurCfgIbgpMetricType=ospfCurCfgIbgpMetricType, vrrpNewCfgVirtRtrVrGrpTckHsrp=vrrpNewCfgVirtRtrVrGrpTckHsrp, ospfIntfRxlsAcks=ospfIntfRxlsAcks, ipCurCfgAlistNwf=ipCurCfgAlistNwf, ospfIntfLoop=ospfIntfLoop, vrrpCurCfgVirtRtrVrGrpState=vrrpCurCfgVirtRtrVrGrpState, bgpNewCfgPeerStaticState=bgpNewCfgPeerStaticState, ipCurCfgBootpState=ipCurCfgBootpState, ospfNewCfgMdkeyTable=ospfNewCfgMdkeyTable, ipNewCfgRmapLp=ipNewCfgRmapLp, ospfNewCfgIntfEntry=ospfNewCfgIntfEntry, nbrcacheInfoType=nbrcacheInfoType, ripCurCfgIntfMcastUpdate=ripCurCfgIntfMcastUpdate, vrrpCurCfgGenTckHsrpInc=vrrpCurCfgGenTckHsrpInc, ospfNewCfgAreaSpfInterval=ospfNewCfgAreaSpfInterval, intfInfoNetMask=intfInfoNetMask, bgpNewCfgPeerOspfState=bgpNewCfgPeerOspfState, ospfAreaTxPkts=ospfAreaTxPkts, vrrpCurCfgVirtRtrGrpInterval=vrrpCurCfgVirtRtrGrpInterval, ripInfoIntfDefault=ripInfoIntfDefault, ipFwdNewCfgLocalTable=ipFwdNewCfgLocalTable, bgpCurCfgPeerOutRmapList=bgpCurCfgPeerOutRmapList, bgpCurCfgPeerTable=bgpCurCfgPeerTable, ipNewCfgGwIpVer=ipNewCfgGwIpVer, ipCurCfgAspathAction=ipCurCfgAspathAction, dnsStatInBadDnsRequests=dnsStatInBadDnsRequests, ospfNewCfgRipOutRmapList=ospfNewCfgRipOutRmapList, vrrpCurCfgVirtRtrPriority=vrrpCurCfgVirtRtrPriority, vrrpCurCfgVirtRtrGrpTable=vrrpCurCfgVirtRtrGrpTable, dnsCurCfgDomainName=dnsCurCfgDomainName, ipNewCfgIntfBroadcast=ipNewCfgIntfBroadcast, vrrpIfTableMaxSize=vrrpIfTableMaxSize, ospfIfNbrTable=ospfIfNbrTable, ospfTmrsKckOffHello=ospfTmrsKckOffHello, ipCurCfgAspathRmapIndex=ipCurCfgAspathRmapIndex, ipNewCfgIntfBootpRelay=ipNewCfgIntfBootpRelay, icmp6StatsEntry=icmp6StatsEntry, vrrpNewCfgVirtRtrVrGrpState=vrrpNewCfgVirtRtrVrGrpState, ospfRedistributeStatic=ospfRedistributeStatic, ipRouteInfoTable=ipRouteInfoTable, ipRoute6InfoNextHop=ipRoute6InfoNextHop, ospfAreaNbrLoadingDone=ospfAreaNbrLoadingDone, vrrpCurCfgGenTckVlanPortInc=vrrpCurCfgGenTckVlanPortInc, ipFwdCurCfgNoICMPRedirect=ipFwdCurCfgNoICMPRedirect, ipNwfTableMax=ipNwfTableMax, ipCurCfgGwIpVer=ipCurCfgGwIpVer, vrrpNewCfgVirtRtrVrGrpBmap=vrrpNewCfgVirtRtrVrGrpBmap)
mibBuilder.exportSymbols("ALTEON-CHEETAH-NETWORK-MIB", bgpNewCfgAggrIndex=bgpNewCfgAggrIndex, ospfNewCfgVirtIntfMdkey=ospfNewCfgVirtIntfMdkey, ospfAreaTxlsUpdates=ospfAreaTxlsUpdates, vrrpCurCfgVirtRtrVrGrpTckHsrp=vrrpCurCfgVirtRtrVrGrpTckHsrp, ipNewCfgAspathState=ipNewCfgAspathState, ospfAreaInfoId=ospfAreaInfoId, ospfIfNbrIntfIndex=ospfIfNbrIntfIndex, bgpCurCfgAggrTable=bgpCurCfgAggrTable, ospfRedistributeRip=ospfRedistributeRip, bgpCurCfgPeerInRmapList=bgpCurCfgPeerInRmapList, ospfNewCfgIntfTable=ospfNewCfgIntfTable, ospfAreaNbrStart=ospfAreaNbrStart, vrrpCurCfgVirtRtrAddr=vrrpCurCfgVirtRtrAddr, ospfNewCfgHostIpAddr=ospfNewCfgHostIpAddr, ospfIntfErrorStatsEntry=ospfIntfErrorStatsEntry, ospfStats=ospfStats, bgpNewCfgPeerAddInRmap=bgpNewCfgPeerAddInRmap, ospfNewCfgHostTable=ospfNewCfgHostTable, ipNewCfgStaticRouteInterface=ipNewCfgStaticRouteInterface, ospfGeneralInfo=ospfGeneralInfo, layer3Oper=layer3Oper, ipCurCfgRmapState=ipCurCfgRmapState, ipCurCfgGwIndex=ipCurCfgGwIndex, ospfAreaRxlsUpdates=ospfAreaRxlsUpdates, ipCurCfgIntfMask=ipCurCfgIntfMask, ospfIfNbrPriority=ospfIfNbrPriority, ipFwdNewCfgRtCache=ipFwdNewCfgRtCache, ip6InAddrErrors=ip6InAddrErrors, ospfIntfBackup=ospfIntfBackup, gatewayInfo=gatewayInfo, vrrpCurCfgIfPasswd=vrrpCurCfgIfPasswd, nbrcacheInfoEntry=nbrcacheInfoEntry, ospfIntfHello=ospfIntfHello, ospfAreaNbrRstAd=ospfAreaNbrRstAd, ospfNewCfgHostIndex=ospfNewCfgHostIndex, ipCurCfgStaticArpTable=ipCurCfgStaticArpTable, ospfAreaRxHello=ospfAreaRxHello, ospfNewCfgIbgpRemoveOutRmap=ospfNewCfgIbgpRemoveOutRmap, ospfNumberOfInterfacesUp=ospfNumberOfInterfacesUp, ip6icmpInErrors=ip6icmpInErrors, ospfCumIntfBackup=ospfCumIntfBackup, ip6OutNoRoutes=ip6OutNoRoutes, ip6OutRequests=ip6OutRequests, ipCurCfgAlistIndex=ipCurCfgAlistIndex, ripInfoState=ripInfoState, ospfNewCfgStaticOutRmapList=ospfNewCfgStaticOutRmapList, vrrpCurCfgVirtRtrGrpTckHsrv=vrrpCurCfgVirtRtrGrpTckHsrv, ospfIfNbrState=ospfIfNbrState, ipFwdNewCfgPortEntry=ipFwdNewCfgPortEntry, ospfCurCfgHostIpAddr=ospfCurCfgHostIpAddr, bgpCurCfgPeerFixedState=bgpCurCfgPeerFixedState, ospfCumNbrAdjointOk=ospfCumNbrAdjointOk, ipCurCfgGwPriority=ipCurCfgGwPriority, vrrpNewCfgIfTableEntry=vrrpNewCfgIfTableEntry, vrrpCurCfgVirtRtrGrpIfIndex=vrrpCurCfgVirtRtrGrpIfIndex, arpInfoVLAN=arpInfoVLAN, ipCurCfgRmapEntry=ipCurCfgRmapEntry, dnsCfg=dnsCfg, ipCurCfgAlistAction=ipCurCfgAlistAction, vrrpNewCfgVirtRtrTckHsrv=vrrpNewCfgVirtRtrTckHsrv, gatewayInfoTable=gatewayInfoTable, bgpNewCfgPeerMetric=bgpNewCfgPeerMetric, ipCurCfgGwIpv6Addr=ipCurCfgGwIpv6Addr, gatewayInfoVlan=gatewayInfoVlan, vrrpCurCfgGenTckVirtRtrInc=vrrpCurCfgGenTckVirtRtrInc, ripNewCfgIntfMcastUpdate=ripNewCfgIntfMcastUpdate, ospfIntfTableMaxSize=ospfIntfTableMaxSize, ipCurCfgIntfAddr=ipCurCfgIntfAddr, layer3Info=layer3Info, ripInfoIntfTrigUpdate=ripInfoIntfTrigUpdate, ipNewCfgNwfTable=ipNewCfgNwfTable, ripInfoVip=ripInfoVip, vrrpNewCfgVirtRtrVrGrpTckVlanPort=vrrpNewCfgVirtRtrVrGrpTckVlanPort, ospfCumNbrChangeStats=ospfCumNbrChangeStats, ospfIfTotalNeighbours=ospfIfTotalNeighbours, ospfAreaRxDatabase=ospfAreaRxDatabase, rip2RoutesInfoIpAddress=rip2RoutesInfoIpAddress, ipFwdNewCfgState=ipFwdNewCfgState, ipNewCfgNwfDelete=ipNewCfgNwfDelete, ripStatInPackets=ripStatInPackets, bgpNewCfgPeerRemoveInRmap=bgpNewCfgPeerRemoveInRmap, ipNewCfgASNumber=ipNewCfgASNumber, ospfAreaChangeStatsEntry=ospfAreaChangeStatsEntry, ospfIntfErrUnknownNbr=ospfIntfErrUnknownNbr, ipNewCfgRmapAp=ipNewCfgRmapAp, ospfNewCfgDefaultRouteMetricType=ospfNewCfgDefaultRouteMetricType, icmp6StatsTable=icmp6StatsTable, ripCurCfgIntfListen=ripCurCfgIntfListen, vrrpNewCfgVirtRtrTckRServer=vrrpNewCfgVirtRtrTckRServer, ifClearStats=ifClearStats, ospfCumNbrLoadingDone=ospfCumNbrLoadingDone, vrrpNewCfgVirtRtrGrpPriority=vrrpNewCfgVirtRtrGrpPriority, ospfCumRxlsAcks=ospfCumRxlsAcks, ripCurCfgIntfVersion=ripCurCfgIntfVersion, ip6ForwDatagrams=ip6ForwDatagrams, ifStatsEntry=ifStatsEntry, ipNewCfgRmapIndex=ipNewCfgRmapIndex, ospfAreaErrorStats=ospfAreaErrorStats, vrrpOperVirtRtrIndex=vrrpOperVirtRtrIndex, ripCurCfgIntfDefListen=ripCurCfgIntfDefListen, ospfNewCfgRangeAddr=ospfNewCfgRangeAddr, ipNewCfgAlistIndex=ipNewCfgAlistIndex, ospfAreaIntfNbrChange=ospfAreaIntfNbrChange, vrrpCurCfgVirtRtrPreempt=vrrpCurCfgVirtRtrPreempt, ospfTimersKickOffStats=ospfTimersKickOffStats, ospfIfInfoIpAddress=ospfIfInfoIpAddress, ospfCurCfgVirtIntfEntry=ospfCurCfgVirtIntfEntry, rip2RoutesInfoTable=rip2RoutesInfoTable, ipFwdNewCfgDirectedBcast=ipFwdNewCfgDirectedBcast, ospfIfNbrIpAddr=ospfIfNbrIpAddr, vrrpCurCfgVirtRtrState=vrrpCurCfgVirtRtrState, bgpNewCfgPeerIndex=bgpNewCfgPeerIndex, vrrpInfoVirtRtrTableEntry=vrrpInfoVirtRtrTableEntry, vrrpNewCfgVirtRtrVrGrpTckRServer=vrrpNewCfgVirtRtrVrGrpTckRServer, vrrpNewCfgVirtRtrGrpTable=vrrpNewCfgVirtRtrGrpTable, bgpNewCfgAggrEntry=bgpNewCfgAggrEntry, bgpPeerTableMax=bgpPeerTableMax, ospfAreaTableMaxSize=ospfAreaTableMaxSize, ospfCumTxDatabase=ospfCumTxDatabase, ripInfoIntfPoisonReverse=ripInfoIntfPoisonReverse, ipCurCfgRmapTable=ipCurCfgRmapTable, vrrpNewCfgVirtRtrTable=vrrpNewCfgVirtRtrTable, rip2Info=rip2Info, ospfNewCfgAreaTable=ospfNewCfgAreaTable, ospfCurCfgRipMetricType=ospfCurCfgRipMetricType, vrrpCurCfgVirtRtrVrGrpTckHsrv=vrrpCurCfgVirtRtrVrGrpTckHsrv, ipCurCfgIntfVlan=ipCurCfgIntfVlan, ospfCurCfgStaticMetricType=ospfCurCfgStaticMetricType, ospfAreaNbrExchangeDone=ospfAreaNbrExchangeDone, ospfCumTxHello=ospfCumTxHello, ip6icmpOutErrors=ip6icmpOutErrors, ospfAreaErrHelloMismatch=ospfAreaErrHelloMismatch, ospfIntfNbrNegotiationDone=ospfIntfNbrNegotiationDone, vrrpGeneral=vrrpGeneral, ospfTotalNeighbours=ospfTotalNeighbours, gatewayInfoEntry=gatewayInfoEntry, ipFwdLocalTableMaxSize=ipFwdLocalTableMaxSize, vrrpCurCfgVirtRtrGrpTckVlanPort=vrrpCurCfgVirtRtrGrpTckVlanPort, nbrcacheInfoTable=nbrcacheInfoTable, vrrpNewCfgGenTckVirtRtrInc=vrrpNewCfgGenTckVirtRtrInc, ospfNewCfgRipMetricType=ospfNewCfgRipMetricType, bgpCurCfgAggrState=bgpCurCfgAggrState, ipNewCfgIntfIpVer=ipNewCfgIntfIpVer, vrrpNewCfgGenTckHsrvInc=vrrpNewCfgGenTckHsrvInc, vrrpNewCfgGenHotstandby=vrrpNewCfgGenHotstandby, vrrpNewCfgVirtRtrGrpTckHsrp=vrrpNewCfgVirtRtrGrpTckHsrp, ospfAreaErrAuthFailure=ospfAreaErrAuthFailure, vrrpCurCfgVirtRtrVrGrpPriority=vrrpCurCfgVirtRtrVrGrpPriority, nbrcacheInfoIndex=nbrcacheInfoIndex, ospfTotalAreas=ospfTotalAreas, ospfIntfNbrN2way=ospfIntfNbrN2way, ipCurCfgStaticArpIndx=ipCurCfgStaticArpIndx, ipGatewayTableMax=ipGatewayTableMax, ipNewCfgIntfIndex=ipNewCfgIntfIndex, rip2RoutesInfoEntry=rip2RoutesInfoEntry, vrrpNewCfgVirtRtrGrpTckVlanPort=vrrpNewCfgVirtRtrGrpTckVlanPort, ripStatInBadSizePkts=ripStatInBadSizePkts, ospfIntfChangeStats=ospfIntfChangeStats, vrrpOperVirtRtrGroupBackup=vrrpOperVirtRtrGroupBackup, ipFwdPortTableMaxSize=ipFwdPortTableMaxSize, ospfNewCfgRangeState=ospfNewCfgRangeState, ospfCumTxlsReqs=ospfCumTxlsReqs, vrrpVirtRtrVrGrpTableMaxSize=vrrpVirtRtrVrGrpTableMaxSize, ospfNewCfgStaticAddOutRmap=ospfNewCfgStaticAddOutRmap, ospfAreaIntfHello=ospfAreaIntfHello, ospfCumNbrhello=ospfCumNbrhello, ipCurCfgStaticRouteGateway=ipCurCfgStaticRouteGateway, ospfCurCfgRangeHideState=ospfCurCfgRangeHideState, ospfIntfTxlsUpdates=ospfIntfTxlsUpdates, nbrcacheInfoState=nbrcacheInfoState, bgpNewCfgAggrState=bgpNewCfgAggrState, intfInfoBcastAddr=intfInfoBcastAddr, ripNewCfgIntfTable=ripNewCfgIntfTable, bgpCurCfgPeerState=bgpCurCfgPeerState, bgpCurCfgPeerIndex=bgpCurCfgPeerIndex, ospfCurCfgEbgpMetricType=ospfCurCfgEbgpMetricType, arpStatEntries=arpStatEntries, ospfIntfIndex=ospfIntfIndex, ospfNewCfgRangeIndex=ospfNewCfgRangeIndex, ospfNewCfgStaticRemoveOutRmap=ospfNewCfgStaticRemoveOutRmap, ipCurCfgBootpAddr2=ipCurCfgBootpAddr2, rip2Stats=rip2Stats, ipFwdNewCfgNoICMPRedirect=ipFwdNewCfgNoICMPRedirect, bgpCfg=bgpCfg, ospfCumNbrN1way=ospfCumNbrN1way, ipRoute6InfoInterface=ipRoute6InfoInterface, ipCurCfgAspathEntry=ipCurCfgAspathEntry, ripStatInBadVersion=ripStatInBadVersion, icmp6OutNAs=icmp6OutNAs, ipNewCfgIntfMask=ipNewCfgIntfMask, ipNewCfgAspathRmapIndex=ipNewCfgAspathRmapIndex, vrrpInfoVirtRtrIndex=vrrpInfoVirtRtrIndex, ipNewCfgGwDelete=ipNewCfgGwDelete, ipInterfaceTableMax=ipInterfaceTableMax, intfInfoLinkLocalAddr=intfInfoLinkLocalAddr, ospfNewCfgIntfId=ospfNewCfgIntfId, vrrpNewCfgVirtRtrVrGrpDelete=vrrpNewCfgVirtRtrVrGrpDelete, ospfNbrInFullState=ospfNbrInFullState, ospfIfBackupDesignatedRouterIP=ospfIfBackupDesignatedRouterIP, vrrpNewCfgVirtRtrTckIpIntf=vrrpNewCfgVirtRtrTckIpIntf, ospfVirtIntfTableMaxSize=ospfVirtIntfTableMaxSize, ripNewCfgIntfTrigUpdate=ripNewCfgIntfTrigUpdate, ospfCurCfgHostAreaIndex=ospfCurCfgHostAreaIndex, ospfMdkeyTableMaxSize=ospfMdkeyTableMaxSize, ospfCurCfgEbgpMetric=ospfCurCfgEbgpMetric, ipStaticArpTableMaxSize=ipStaticArpTableMaxSize, ospfTotalNssaAreas=ospfTotalNssaAreas, ipCurCfgGwMetric=ipCurCfgGwMetric, bgpNewCfgPeerRemoteAs=bgpNewCfgPeerRemoteAs, ipNewCfgAlistEntry=ipNewCfgAlistEntry, ospfAreaIntfUnloop=ospfAreaIntfUnloop, ipNewCfgGwAddr=ipNewCfgGwAddr, ipCurCfgStaticRouteTable=ipCurCfgStaticRouteTable, vrrpNewCfgVirtRtrID=vrrpNewCfgVirtRtrID, ospfCurCfgRangeAddr=ospfCurCfgRangeAddr, ipFwdCurCfgPortState=ipFwdCurCfgPortState, intfInfoStatus=intfInfoStatus, ospfCurCfgRangeEntry=ospfCurCfgRangeEntry, vrrpNewCfgVirtRtrSharing=vrrpNewCfgVirtRtrSharing, vrrpNewCfgVirtRtrGrpSharing=vrrpNewCfgVirtRtrGrpSharing, ospfIntfRxHello=ospfIntfRxHello, vrrpOperVirtRtrTable=vrrpOperVirtRtrTable, ipCurCfgAlistTable=ipCurCfgAlistTable, ip6ReasmFails=ip6ReasmFails, ipRouteInfoMask=ipRouteInfoMask, ripStatInRequestPkts=ripStatInRequestPkts, ipNewCfgGwTable=ipNewCfgGwTable, vrrpCurCfgVirtRtrVrGrpBmap=vrrpCurCfgVirtRtrVrGrpBmap, ospfCurCfgRipOutRmapList=ospfCurCfgRipOutRmapList, ip6InDelivers=ip6InDelivers, ospfAreaIntfDown=ospfAreaIntfDown, vrrpNewCfgVirtRtrIfIndex=vrrpNewCfgVirtRtrIfIndex, ospfIntfRxTxStats=ospfIntfRxTxStats, ipFwdNewCfgLocalIndex=ipFwdNewCfgLocalIndex, vrrpNewCfgVirtRtrVrGrpTckVirtRtrNo=vrrpNewCfgVirtRtrVrGrpTckVirtRtrNo, ipCurCfgRmapMetricType=ipCurCfgRmapMetricType, ospfCumIntfDown=ospfCumIntfDown, ospfCumIntfWaitTimer=ospfCumIntfWaitTimer, ipCurCfgStaticArpVlan=ipCurCfgStaticArpVlan, ipRoute6InfoEntry=ipRoute6InfoEntry, routeStats=routeStats, ipNewCfgGwState=ipNewCfgGwState, ip6GwRetry=ip6GwRetry, ospfNewCfgRangeEntry=ospfNewCfgRangeEntry, gatewayInfoAddr6=gatewayInfoAddr6, ospfRedistributeIbgp=ospfRedistributeIbgp, ospfNewCfgIbgpMetricType=ospfNewCfgIbgpMetricType, ospfIntfErrDeadMismatch=ospfIntfErrDeadMismatch, ospfNewCfgFixedMetricType=ospfNewCfgFixedMetricType, vrrpNewCfgIfTable=vrrpNewCfgIfTable, vrrpNewCfgVirtRtrGrpTckL4Port=vrrpNewCfgVirtRtrGrpTckL4Port, ospfCurCfgVirtIntfIndex=ospfCurCfgVirtIntfIndex, ripCurCfgIntfMetric=ripCurCfgIntfMetric, ospfTmrsKckOffAseExport=ospfTmrsKckOffAseExport)
mibBuilder.exportSymbols("ALTEON-CHEETAH-NETWORK-MIB", ipFwdCurCfgLocalEntry=ipFwdCurCfgLocalEntry, ipFwdCurCfgDirectedBcast=ipFwdCurCfgDirectedBcast, ospfIfDesignatedRouterIP=ospfIfDesignatedRouterIP, nbrcacheInfo=nbrcacheInfo, ipAspathTableMax=ipAspathTableMax, ospfAreaRxTxStatsEntry=ospfAreaRxTxStatsEntry, ospfIntfDown=ospfIntfDown, ospfTotalTransitAreas=ospfTotalTransitAreas, icmp6OutRSs=icmp6OutRSs, ospfIntfNbrRstAd=ospfIntfNbrRstAd, ipCurCfgStaticRouteDestIp=ipCurCfgStaticRouteDestIp, ripNewCfgIntfAuth=ripNewCfgIntfAuth, arpInfoDestIp=arpInfoDestIp, ip6InDiscards=ip6InDiscards, icmp6OutEchos=icmp6OutEchos, vrrpNewCfgVirtRtrPriority=vrrpNewCfgVirtRtrPriority, vrrpCurCfgVirtRtrGrpID=vrrpCurCfgVirtRtrGrpID, ipNewCfgAspathDelete=ipNewCfgAspathDelete, ipNewCfgBootpAddr2=ipNewCfgBootpAddr2, ipNewCfgIntfPrefixLen=ipNewCfgIntfPrefixLen, ospfCurCfgRangeState=ospfCurCfgRangeState, ipNewCfgAlistTable=ipNewCfgAlistTable, icmp6InTimeExcds=icmp6InTimeExcds, ospfAreaErrIndex=ospfAreaErrIndex, rip2RoutesInfo=rip2RoutesInfo, ospfCurCfgDefaultRouteMetricType=ospfCurCfgDefaultRouteMetricType, ospfCurCfgIbgpMetric=ospfCurCfgIbgpMetric, vrrpCurCfgVirtRtrSharing=vrrpCurCfgVirtRtrSharing, dnsCurCfgPrimaryIpAddr=dnsCurCfgPrimaryIpAddr, ipNewCfgStaticArpPort=ipNewCfgStaticArpPort, ospfNewCfgRangeDelete=ospfNewCfgRangeDelete, ospfIfInfoIndex=ospfIfInfoIndex, vrrpCurCfgVirtRtrGrpPreempt=vrrpCurCfgVirtRtrGrpPreempt, vrrpCurCfgVirtRtrGrpTckRServer=vrrpCurCfgVirtRtrGrpTckRServer, ripInfoUpdatePeriod=ripInfoUpdatePeriod, ipNewCfgGwEntry=ipNewCfgGwEntry, ospfCurCfgFixedOutRmapList=ospfCurCfgFixedOutRmapList, ospfIntfCountForRouter=ospfIntfCountForRouter, vrrpInfoVirtRtrTable=vrrpInfoVirtRtrTable, ospfTmrsKckOffRetransmit=ospfTmrsKckOffRetransmit, ipNewCfgRmapTable=ipNewCfgRmapTable, ospfCumTxlsUpdates=ospfCumTxlsUpdates, ipCurCfgStaticRouteIndx=ipCurCfgStaticRouteIndx, ripStatOutResponsePkts=ripStatOutResponsePkts, ipNewCfgAlistAction=ipNewCfgAlistAction, routeStatHighWater=routeStatHighWater, ospfIntfRxDatabase=ospfIntfRxDatabase, ripCurCfgIntfIndex=ripCurCfgIntfIndex, ipNewCfgAlistNwf=ipNewCfgAlistNwf, ipCurCfgIntfBootpRelay=ipCurCfgIntfBootpRelay, nbrcacheInfoMacAddr=nbrcacheInfoMacAddr, ipCurCfgGwVlan=ipCurCfgGwVlan, ipNewCfgRmapPrec=ipNewCfgRmapPrec, ospfAreaNbrBadSequence=ospfAreaNbrBadSequence, rip2RoutesInfoMetric=rip2RoutesInfoMetric, ospfNewCfgDefaultRouteMetric=ospfNewCfgDefaultRouteMetric, ospfIfNbrIpAddress=ospfIfNbrIpAddress, ipNewCfgGwArp=ipNewCfgGwArp, vrrpCurCfgVirtRtrTckRServer=vrrpCurCfgVirtRtrTckRServer, icmp6InParmProbs=icmp6InParmProbs, arpInfoEntry=arpInfoEntry, ripInfoIntfMcastUpdate=ripInfoIntfMcastUpdate, arpCurCfgReARPPeriod=arpCurCfgReARPPeriod, ipFwdCurCfgPortTable=ipFwdCurCfgPortTable, ospfCurCfgRangeMask=ospfCurCfgRangeMask, ipRouteInfoDestIp=ipRouteInfoDestIp, vrrpNewCfgGenTckHsrpInc=vrrpNewCfgGenTckHsrpInc, ip6GwStatsEntry=ip6GwStatsEntry, ip6GwFails=ip6GwFails, vrrpCurCfgVirtRtrGrpState=vrrpCurCfgVirtRtrGrpState, ipCurCfgAspathIndex=ipCurCfgAspathIndex, ospfCurCfgAreaEntry=ospfCurCfgAreaEntry, ospfCumRxPkts=ospfCumRxPkts, vrrpCurCfgVirtRtrGrpTckVirtRtr=vrrpCurCfgVirtRtrGrpTckVirtRtr, arpInfoTable=arpInfoTable, ipNewCfgGwIndex=ipNewCfgGwIndex, ipRouteInfoGateway2=ipRouteInfoGateway2, bgpNewCfgPeerRemoveOutRmap=bgpNewCfgPeerRemoveOutRmap, ipFwdCurCfgLocalMask=ipFwdCurCfgLocalMask, ipNewCfgAspathIndex=ipNewCfgAspathIndex, bgpCurCfgPeerOspfState=bgpCurCfgPeerOspfState, rip2GeneralInfo=rip2GeneralInfo, ipCurCfgStaticRouteMask=ipCurCfgStaticRouteMask, ospfAreaTxlsAcks=ospfAreaTxlsAcks, dnsStatOutDnsRequests=dnsStatOutDnsRequests, arpStats=arpStats, vrrpNewCfgVirtRtrGrpIfIndex=vrrpNewCfgVirtRtrGrpIfIndex, ospfAreaNbrNegotiationDone=ospfAreaNbrNegotiationDone, ipNewCfgGwVlan=ipNewCfgGwVlan, ospfNewCfgAreaIndex=ospfNewCfgAreaIndex, vrrpNewCfgVirtRtrVrGrpAdd=vrrpNewCfgVirtRtrVrGrpAdd, ipNewCfgStaticRouteDestIp=ipNewCfgStaticRouteDestIp, ripNewCfgIntfListen=ripNewCfgIntfListen, bgpNewCfgPeerRemoteAddr=bgpNewCfgPeerRemoteAddr, vrrpCurCfgVirtRtrTable=vrrpCurCfgVirtRtrTable, vrrpCurCfgVirtRtrIndx=vrrpCurCfgVirtRtrIndx, ospfCurCfgIntfMdkey=ospfCurCfgIntfMdkey, dnsStats=dnsStats, icmp6OutNSs=icmp6OutNSs, ipRoute6Info=ipRoute6Info, rip2RoutesInfoNxtHopIndex=rip2RoutesInfoNxtHopIndex, vrrpNewCfgIfDelete=vrrpNewCfgIfDelete, ospfAreaErrOptionsMismatch=ospfAreaErrOptionsMismatch, ospfIntfErrOptionsMismatch=ospfIntfErrOptionsMismatch, ospfIfNbrEntry=ospfIfNbrEntry, ospfNewCfgMdkeyEntry=ospfNewCfgMdkeyEntry, ospfAreaNbrAdjointOk=ospfAreaNbrAdjointOk, ospfAreaNbrIndex=ospfAreaNbrIndex, ospfAreaIntfLoop=ospfAreaIntfLoop, ipCurCfgRouterID=ipCurCfgRouterID, ip6icmpOutMsgs=ip6icmpOutMsgs, ospfIntfTxHello=ospfIntfTxHello, ipCurCfgIntfIndex=ipCurCfgIntfIndex, vrrpNewCfgVirtRtrGrpTckVirtRtr=vrrpNewCfgVirtRtrGrpTckVirtRtr, ipCurCfgRmapIndex=ipCurCfgRmapIndex, ipFwdNewCfgLocalSubnet=ipFwdNewCfgLocalSubnet, icmp6OutRedirects=icmp6OutRedirects, ipCurCfgStaticRouteInterface=ipCurCfgStaticRouteInterface, ospfCurCfgIntfEntry=ospfCurCfgIntfEntry, ospfAreaRxlsAcks=ospfAreaRxlsAcks, vrrpCurCfgVirtRtrTckHsrp=vrrpCurCfgVirtRtrTckHsrp, ospfTotalNumberOfInterfaces=ospfTotalNumberOfInterfaces, ipNewCfgRmapMetricType=ipNewCfgRmapMetricType, vrrpInfoVirtRtrOwnership=vrrpInfoVirtRtrOwnership, icmp6InRSs=icmp6InRSs, ripCurCfgIntfTable=ripCurCfgIntfTable, ipClearStats=ipClearStats, ip6GwMaster=ip6GwMaster, vrrpNewCfgVirtRtrVrGrpTckHsrv=vrrpNewCfgVirtRtrVrGrpTckHsrv, vrrpNewCfgGenTckVlanPortInc=vrrpNewCfgGenTckVlanPortInc, ipCurCfgNwfIndex=ipCurCfgNwfIndex, ipCurCfgGwRetry=ipCurCfgGwRetry, ip6GwStatsIndex=ip6GwStatsIndex, ip6GwEchoresp=ip6GwEchoresp, ospfIntfTxlsAcks=ospfIntfTxlsAcks, ospfNewCfgAreaId=ospfNewCfgAreaId, ospfIntfNbrChangeStatsEntry=ospfIntfNbrChangeStatsEntry, ipNewCfgStaticRouteEntry=ipNewCfgStaticRouteEntry, ospfNbrInExchState=ospfNbrInExchState, ipNewCfgRmapDelete=ipNewCfgRmapDelete, ipRoute6InfoIndx=ipRoute6InfoIndx, vrrpCurCfgIfIndx=vrrpCurCfgIfIndx, vrrpCurCfgIfTableEntry=vrrpCurCfgIfTableEntry, ipCurCfgIntfBroadcast=ipCurCfgIntfBroadcast, vrrpNewCfgVirtRtrGrpState=vrrpNewCfgVirtRtrGrpState, bgpCurCfgPeerDefaultAction=bgpCurCfgPeerDefaultAction, vrrpCurCfgVirtRtrGrpTckL4Port=vrrpCurCfgVirtRtrGrpTckL4Port, rip2InfoIntfTable=rip2InfoIntfTable, ipFwdCurCfgRtCache=ipFwdCurCfgRtCache, ospfNewCfgIbgpOutRmapList=ospfNewCfgIbgpOutRmapList, ospfIntfNbrExchangeDone=ospfIntfNbrExchangeDone, vrrpNewCfgVirtRtrTableEntry=vrrpNewCfgVirtRtrTableEntry, ospfNewCfgAreaEntry=ospfNewCfgAreaEntry, ospfCurCfgStaticMetric=ospfCurCfgStaticMetric, ospfNewCfgFixedOutRmapList=ospfNewCfgFixedOutRmapList, ipNwfCfg=ipNwfCfg, ospfIntfNbrLoadingDone=ospfIntfNbrLoadingDone, ipCurCfgIntfEntry=ipCurCfgIntfEntry, ospfNewCfgStaticMetricType=ospfNewCfgStaticMetricType, ospfIntfNbrAdjointOk=ospfIntfNbrAdjointOk, ripCurCfgIntfState=ripCurCfgIntfState, ospfCurCfgHostEntry=ospfCurCfgHostEntry, vrrpNewCfgVirtRtrAddr=vrrpNewCfgVirtRtrAddr, vrrpNewCfgVirtRtrVrGrpTckL4Port=vrrpNewCfgVirtRtrVrGrpTckL4Port, ip6Stats=ip6Stats, ospfNewCfgHostEntry=ospfNewCfgHostEntry, ospfCurCfgAreaId=ospfCurCfgAreaId, ipRouteInfoIndx=ipRouteInfoIndx, vrrpCurCfgVirtRtrTckHsrv=vrrpCurCfgVirtRtrTckHsrv, ipCurCfgIntfState=ipCurCfgIntfState, ospfIntfNbrStart=ospfIntfNbrStart, ospfCurCfgState=ospfCurCfgState, ospfAreaErrDeadMismatch=ospfAreaErrDeadMismatch, ipCurCfgStaticArpIp=ipCurCfgStaticArpIp, bgpCurCfgAggrIndex=bgpCurCfgAggrIndex, ospfIntfRxPkts=ospfIntfRxPkts, ospfinfo=ospfinfo, ospfAreaRxlsReqs=ospfAreaRxlsReqs, ospfIntfTxPkts=ospfIntfTxPkts, ipRoute6InfoDestIp6=ipRoute6InfoDestIp6, ipAlistTableMax=ipAlistTableMax, icmp6OutMsgs=icmp6OutMsgs, ospfAreaIntfIndex=ospfAreaIntfIndex, ospfCumTxlsAcks=ospfCumTxlsAcks, icmp6InMsgs=icmp6InMsgs, ripGeneral=ripGeneral, ipCurCfgNwfMask=ipCurCfgNwfMask, vrrpNewCfgIfAuthType=vrrpNewCfgIfAuthType, routeStatMaxEntries=routeStatMaxEntries, vrrpVirtRtrTableMaxSize=vrrpVirtRtrTableMaxSize, bgpCurCfgPeerVipState=bgpCurCfgPeerVipState, rip2NewCfgState=rip2NewCfgState, ripNewCfgIntfIndex=ripNewCfgIntfIndex, ospfCurCfgEbgpOutRmapList=ospfCurCfgEbgpOutRmapList, ospfProcessUptime=ospfProcessUptime, ipRouteInfoType=ipRouteInfoType, rip2CurCfgUpdatePeriod=rip2CurCfgUpdatePeriod, vrrpNewCfgVirtRtrVrGrpName=vrrpNewCfgVirtRtrVrGrpName, ripCurCfgIntfDefault=ripCurCfgIntfDefault, vrrpCurCfgVirtRtrID=vrrpCurCfgVirtRtrID, vrrpCurCfgVirtRtrVrGrpIndx=vrrpCurCfgVirtRtrVrGrpIndx, ospfRedistributeEbgp=ospfRedistributeEbgp, intfInfoAddr=intfInfoAddr, ripNewCfgIntfSupply=ripNewCfgIntfSupply, routeStatEntries=routeStatEntries, layer3Stats=layer3Stats, ospfCurCfgMdkeyTable=ospfCurCfgMdkeyTable, ospfNewCfgAreaAuthType=ospfNewCfgAreaAuthType)
