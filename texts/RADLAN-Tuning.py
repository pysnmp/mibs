#
# PySNMP MIB module RADLAN-Tuning (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radlan/RADLAN-Tuning
# Produced by pysmi-1.1.12 at Mon Jul  1 11:17:58 2024
# On host fv-az1493-704 platform Linux version 6.5.0-1022-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, MibIdentifier, Gauge32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Unsigned32, TimeTicks, Counter32, Counter64, ObjectIdentity, Bits, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "Gauge32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Unsigned32", "TimeTicks", "Counter32", "Counter64", "ObjectIdentity", "Bits", "NotificationType", "ModuleIdentity")
DisplayString, RowStatus, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention", "TruthValue")
DisplayString, = mibBuilder.importSymbols("SNMPv2-TC-v1", "DisplayString")
rsTunning = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 29))
rsTunning.setRevisions(('2004-06-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rsTunning.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rsTunning.setLastUpdated('200406010000Z')
if mibBuilder.loadTexts: rsTunning.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rsTunning.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rsTunning.setDescription('The private MIB module definition for RND device tuning MIB.')
rsHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsHighPriority.setStatus('current')
if mibBuilder.loadTexts: rsHighPriority.setDescription('This variable indicates the time interval the forwarding task inside the\n      RS works in High Priority Mode.')
rsLowPriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLowPriority.setStatus('current')
if mibBuilder.loadTexts: rsLowPriority.setDescription('This variable indicates the time interval the forwarding task inside the\n      RS works in Low Priority Mode.')
rsDbgLevel = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDbgLevel.setStatus('current')
if mibBuilder.loadTexts: rsDbgLevel.setDescription('This variable indicates the debug level the Router Server works.\n       the range of this variable is 1..100 ')
rsDiagnosticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 4), )
if mibBuilder.loadTexts: rsDiagnosticsTable.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsTable.setDescription('The diagnostics table of the agent')
rsDiagnosticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 4, 1), ).setIndexNames((0, "RADLAN-Tuning", "rsDiagnosticsRequestId"))
if mibBuilder.loadTexts: rsDiagnosticsEntry.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsEntry.setDescription('The row definition for this table.')
rsDiagnosticsRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDiagnosticsRequestId.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsRequestId.setDescription('The request id of the rejected SNMP request whose diagnostics are\n       specified by this entry. If  request  id  0xFFFFFFFF is given,\n       the diagnostic of the last  rejected SNMP\n       request sent  by the querying NMS is returned.')
rsDiagnosticsCode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDiagnosticsCode.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsCode.setDescription('The code of the rejected the SNMP request whose diagnostics are\n         specified by this entry. This code may be used to find out the reason\n         for rejection if the diagnostic text is unavailable.')
rsDiagnosticsLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDiagnosticsLocation.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsLocation.setDescription('The internal location in the SW rejecting the SNMP request whose\n     diagnostics are specified by this entry. This information is available\n     for debugging purposes only and will be returned in GET requests only if\n     rsDbgLevel >= 99.  ')
rsDiagnosticsText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 160))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDiagnosticsText.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticsText.setDescription('The diagnostic text of the rejected SNMP request whose diagnostics are\n         specified by this entry.')
rsConfirmMessagTab = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsConfirmMessagTab.setStatus('current')
if mibBuilder.loadTexts: rsConfirmMessagTab.setDescription('This variable  enables the operator to confirm all the message in the\n       event Message Table.')
eventMessageTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 6), )
if mibBuilder.loadTexts: eventMessageTable.setStatus('current')
if mibBuilder.loadTexts: eventMessageTable.setDescription('The Event Message table of the agent')
eventMessageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 6, 1), ).setIndexNames((0, "RADLAN-Tuning", "eventNum"))
if mibBuilder.loadTexts: eventMessageEntry.setStatus('current')
if mibBuilder.loadTexts: eventMessageEntry.setDescription('The row definition for this table.')
eventNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventNum.setStatus('current')
if mibBuilder.loadTexts: eventNum.setDescription('The event number,the index of this table.')
eventDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventDesc.setStatus('current')
if mibBuilder.loadTexts: eventDesc.setDescription('The event discription, this text will include time and severity.')
reaTunning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 7))
reaIpForwardEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaIpForwardEnable.setStatus('current')
if mibBuilder.loadTexts: reaIpForwardEnable.setDescription("The Platform will perform fast IP forwarding if only if this\n       variable's value is enable.")
reaIpxForwardEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaIpxForwardEnable.setStatus('current')
if mibBuilder.loadTexts: reaIpxForwardEnable.setDescription("The Platform will perform fast IPX forwarding if only if this\n       variable's value is enable.")
rsMaxEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8))
rsMaxBridgeForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 1))
rsMaxBrgFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxBrgFrwEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxBrgFrwEntries.setDescription('Maximal number of entries in bridge forwarding table.')
rsMaxBrgFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxBrgFrwEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxBrgFrwEntriesAfterReset.setDescription('Future maximal number of entries in bridge forwarding table.')
rsMaxIpForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 2))
rsMaxIpFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpFrwEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpFrwEntries.setDescription('Maximal number of entries in Ip forwarding table.')
rsMaxIpFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpFrwEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpFrwEntriesAfterReset.setDescription('Future maximal number of entries in Ip forwarding table.')
rsMaxArpEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 3))
rsMaxArpEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxArpEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxArpEntries.setDescription('Maximal number of entries in Arp forwarding table.')
rsMaxArpEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxArpEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxArpEntriesAfterReset.setDescription('Future maximal number of entries in Arp forwarding table.')
rsMaxIpxForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 4))
rsMaxIpxFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxFrwEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxFrwEntries.setDescription('Maximal number of entries in Ipx forwarding table.')
rsMaxIpxFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxFrwEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxFrwEntriesAfterReset.setDescription('Future maximal number of entries in Ipx forwarding table.')
rsMaxIpxSapEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 5))
rsMaxIpxSapEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxSapEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSapEntries.setDescription('Maximal number of entries in IpxSap table.')
rsMaxIpxSapEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxSapEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSapEntriesAfterReset.setDescription('Future maximal number of entries in IpxSap table.')
rsMaxDspClntEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 6))
rsMaxDspClntEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDspClntEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxDspClntEntries.setDescription('Maximal number of entries in rsSdClientsTable.')
rsMaxDspClntEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDspClntEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDspClntEntriesAfterReset.setDescription('Future maximal number of entries in rsSdClientsTable.')
rsMaxIpFftEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 9))
rsMaxIpSFftEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpSFftEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpSFftEntries.setDescription('The current maximal size of one IP SFFT Table.')
rsMaxIpSFftEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpSFftEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpSFftEntriesAfterReset.setDescription('The future (after reset) maximal size of one IP SFFT Table.')
rsMaxIpNFftEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpNFftEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNFftEntries.setDescription('The current maximal size of one IP NFFT Table.')
rsMaxIpNFftEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpNFftEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNFftEntriesAfterReset.setDescription('The future (after reset) maximal size of one IP NFFT Table.')
rsMaxIpSFftSysEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpSFftSysEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpSFftSysEntries.setDescription('The current maximal size of the SYSTEM IP SFFT Table.')
rsMaxIpSFftSysEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpSFftSysEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpSFftSysEntriesAfterReset.setDescription('The future (after reset) maximal size of the SYSTEM IP SFFT Table.')
rsMaxIpNFftSysEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpNFftSysEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNFftSysEntries.setDescription('The current maximal size of the SYSTEM IP NFFT Table.')
rsMaxIpNFftSysEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpNFftSysEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNFftSysEntriesAfterReset.setDescription('The future (after reset) maximal size of the SYSTEM IP NFFT Table.')
rsMaxIpNextHopEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpNextHopEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNextHopEntries.setDescription('The current maximal size of one IP NextHop Table.')
rsMaxIpNextHopEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpNextHopEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNextHopEntriesAfterReset.setDescription('The future (after reset) maximal size of one NextHop Table.')
rsMaxIpxFftEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 10))
rsMaxIpxSFftEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxSFftEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSFftEntries.setDescription('The current maximal size of one IPX SFFT Table.')
rsMaxIpxSFftEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxSFftEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSFftEntriesAfterReset.setDescription('The future (after reset) maximal size of one IPX SFFT Table.')
rsMaxIpxNFftEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxNFftEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxNFftEntries.setDescription('The current maximal size of one IPX NFFT Table.')
rsMaxIpxNFftEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxNFftEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxNFftEntriesAfterReset.setDescription('The future (after reset) maximal size of one IPX NFFT Table.')
rsMaxIpxSFftSysEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxSFftSysEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSFftSysEntries.setDescription('The current maximal size of the SYSTEM IPX SFFT Table.')
rsMaxIpxSFftSysEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxSFftSysEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxSFftSysEntriesAfterReset.setDescription('The future (after reset) maximal size of the SYSTEM IPX SFFT Table.')
rsMaxIpxNFftSysEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxNFftSysEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxNFftSysEntries.setDescription('The current maximal size of the SYSTEM IPX NFFT Table.')
rsMaxIpxNFftSysEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxNFftSysEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpxNFftSysEntriesAfterReset.setDescription('The future (after reset) maximal size of the SYSTEM IPX NFFT Table.')
rsMaxDhcpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 11))
rsMaxDhcpConns = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 11, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDhcpConns.setStatus('current')
if mibBuilder.loadTexts: rsMaxDhcpConns.setDescription('The current maximal number of DHCP connections.')
rsMaxDhcpConnsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDhcpConnsAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDhcpConnsAfterReset.setDescription('The future (after reset)  maximal number of DHCP connections.')
rsMaxIpmTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12))
rsMaxIpmFftEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 1))
rsMaxIpmFftEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpmFftEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpmFftEntries.setDescription('The current maximal number of the IPM FFT Tables.')
rsMaxIpmFftEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpmFftEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpmFftEntriesAfterReset.setDescription('The future (after reset) maximal number of the IPM FFT Tables.')
rsIpmFftAging = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpmFftAging.setStatus('current')
if mibBuilder.loadTexts: rsIpmFftAging.setDescription('The aging timeout of the IPM FFT Tables.')
rsMaxIgmpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 2))
rsMaxIgmpInterfaceEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIgmpInterfaceEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpInterfaceEntries.setDescription('Maximal number of entries in the IGMP Neighbor Table.')
rsMaxIgmpInterfaceEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIgmpInterfaceEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpInterfaceEntriesAfterReset.setDescription('Future maximal number of entries in the IGMP Neighbor Table.')
rsMaxIgmpCacheEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIgmpCacheEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpCacheEntries.setDescription('Maximal number of entries in the IGMP Cache Table.')
rsMaxIgmpCacheEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIgmpCacheEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpCacheEntriesAfterReset.setDescription('Future maximal number of entries in the IGMP Cache Table.')
rsMaxPimTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3))
rsMaxPimNeighborEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimNeighborEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimNeighborEntries.setDescription('Maximal number of entries in the PIM Neighbor Table.')
rsMaxPimNeighborEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimNeighborEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimNeighborEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Neighbor Table.')
rsMaxPimRouteEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimRouteEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimRouteEntries.setDescription('Maximal number of entries in the PIM Route Table.')
rsMaxPimRouteEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimRouteEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimRouteEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Route Table.')
rsMaxPimRouteNextHopEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimRouteNextHopEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimRouteNextHopEntries.setDescription('Maximal number of entries in the PIM Route Next Hop Table.')
rsMaxPimRouteNextHopEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimRouteNextHopEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimRouteNextHopEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Route Next Hop Table.')
rsMaxPimInterfaceEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimInterfaceEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimInterfaceEntriesAfterReset.setDescription('Future maximal number of interfaces in the PIM Interface Table.')
rsMaxPimInterfaceEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimInterfaceEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimInterfaceEntries.setDescription('Maximal number of interfaces in the PIM Interface Table.')
rsMaxDvmrpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4))
rsMaxDvmrpNeighborEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDvmrpNeighborEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpNeighborEntries.setDescription('Maximal number of entries in the Dvmrp Neighbor Table.')
rsMaxDvmrpNeighborEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDvmrpNeighborEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpNeighborEntriesAfterReset.setDescription('Future maximal number of entries in the Dvmrp Neighbor Table.')
rsMaxDvmrpRouteEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDvmrpRouteEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpRouteEntries.setDescription('Maximal number of entries in the Dvmrp Route Table.')
rsMaxDvmrpRouteEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDvmrpRouteEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpRouteEntriesAfterReset.setDescription('Future maximal number of entries in the Dvmrp Route Table.')
rsMaxDvmrpMRouteEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDvmrpMRouteEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpMRouteEntries.setDescription('Maximal number of entries in the Dvmrp Multicast Route Table.')
rsMaxDvmrpMRouteEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDvmrpMRouteEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpMRouteEntriesAfterReset.setDescription('Future maximal number of entries in the Dvmrp Multicast Route Table.')
rsMaxDvmrpInterfaceEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDvmrpInterfaceEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpInterfaceEntries.setDescription('Maximal number of interfaces in the Dvmrp Interface Table.')
rsMaxDvmrpInterfaceEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 4, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDvmrpInterfaceEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxDvmrpInterfaceEntriesAfterReset.setDescription('Future maximal number of interfaces in the Dvmrp Interface Table.')
rsMaxPigmpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 5))
rsMaxPigmpRouteEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPigmpRouteEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPigmpRouteEntries.setDescription('Maximal number of entries in the IGMP Proxy Routing Table.')
rsMaxPigmpRouteEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPigmpRouteEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPigmpRouteEntriesAfterReset.setDescription('Future maximal number of entries in the IGMP Proxy Routing Table.')
rsMaxPimSmTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6))
rsMaxPimSmNeighborEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimSmNeighborEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmNeighborEntries.setDescription('Maximal number of entries in the PIM Neighbor Table.')
rsMaxPimSmNeighborEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimSmNeighborEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmNeighborEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Neighbor Table.')
rsMaxPimSmRouteEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimSmRouteEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmRouteEntries.setDescription('Maximal number of entries in the PIM Route Table.')
rsMaxPimSmRouteEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimSmRouteEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmRouteEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Route Table.')
rsMaxPimSmInterfaceEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimSmInterfaceEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmInterfaceEntries.setDescription('Maximal number of entries in the PIM Interface Table.')
rsMaxPimSmInterfaceEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimSmInterfaceEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmInterfaceEntriesAfterReset.setDescription('Future maximal number of entries in the PIM Interface Table.')
rsMaxPimSmRPSetEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimSmRPSetEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmRPSetEntries.setDescription('Maximal number of entries in the RPSet Table.')
rsMaxPimSmRPSetEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimSmRPSetEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmRPSetEntriesAfterReset.setDescription('Future maximal number of entries in the RPSet Table.')
rsMaxPimSmCRPEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPimSmCRPEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmCRPEntries.setDescription('Maximal number of entries in the RPSet Table.')
rsMaxPimSmCRPEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPimSmCRPEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPimSmCRPEntriesAfterReset.setDescription('Future maximal number of entries in the RPSet Table.')
rsMaxNumberRpAddresesInGroupRange = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxNumberRpAddresesInGroupRange.setStatus('current')
if mibBuilder.loadTexts: rsMaxNumberRpAddresesInGroupRange.setDescription('Maximal number of rp addresses per group range  in the RPSet Table.')
rsMaxNumberRpAddresesInGroupRangeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 12, 6, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxNumberRpAddresesInGroupRangeAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxNumberRpAddresesInGroupRangeAfterReset.setDescription('Future maximal number of rp addresses per group range  in the RPSet Table.')
rsMaxRmonTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 13))
rsMaxRmonLogEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 13, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxRmonLogEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxRmonLogEntries.setDescription('Maximal number of entries in RMON Log table.')
rsMaxRmonLogEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 13, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxRmonLogEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxRmonLogEntriesAfterReset.setDescription('Future maximal number of entries in RMON Log table.')
rsMaxRmonEtherHistoryEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 13, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxRmonEtherHistoryEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxRmonEtherHistoryEntries.setDescription('Maximal number of entries in RMON EtherHistory table.')
rsMaxRmonEtherHistoryEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 13, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxRmonEtherHistoryEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxRmonEtherHistoryEntriesAfterReset.setDescription('Future maximal number of entries in RMON EtherHistory table.')
rsMaxIgmpSnoopTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 14))
rsMaxIgmpSnoopGroupEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIgmpSnoopGroupEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpSnoopGroupEntries.setDescription('The maximum number of entries in the IGMP Snooping group table.')
rsMaxIgmpSnoopGroupEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 14, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIgmpSnoopGroupEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIgmpSnoopGroupEntriesAfterReset.setDescription('Future maximal number of entries in the IGMP Snooping group table.')
rsMaxVlansTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 15))
rsMaxVlansEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 15, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxVlansEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxVlansEntries.setDescription('The maximum number of entries in the VLANs table.')
rsMaxVlansEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 15, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxVlansEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxVlansEntriesAfterReset.setDescription('Future maximal number of entries in the VLANs table.')
rsMaxPolicyTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 16))
rsMaxPolicyMaxRulesEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPolicyMaxRulesEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicyMaxRulesEntries.setDescription('Maximal number of entries in the Policy Route Table.')
rsMaxPolicyMaxRulesEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPolicyMaxRulesEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicyMaxRulesEntriesAfterReset.setDescription('Future maximal number of entries in the Policy Route Table.')
rsMaxPolicySimpleMibMaxRulesEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxRulesEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxRulesEntries.setDescription('Maximal number of entries in the Policy SimpleMib Table.')
rsMaxPolicySimpleMibMaxRulesEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxRulesEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxRulesEntriesAfterReset.setDescription('Future maximal number of entries in the Policy SimpleMib Table.')
rsMaxPolicySimpleMibMaxProfilesEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxProfilesEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxProfilesEntries.setDescription('Maximal number of entries in the profile Policy SimpleMib Table.')
rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 16, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset.setDescription('Future maximal number of entries in the profile Policy SimpleMib Table.')
rsMaxGvrpVlansTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 17))
rsMaxGvrpVlans = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 17, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxGvrpVlans.setStatus('current')
if mibBuilder.loadTexts: rsMaxGvrpVlans.setDescription('The maximum number of VLANs that can participant in Gvrp.')
rsMaxGvrpVlansAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 17, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxGvrpVlansAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxGvrpVlansAfterReset.setDescription('Future maximal number of VLANs that can participant in Gvrp.')
rsMaxTraceRouteTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 18))
rsMaxTraceRouteControlEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxTraceRouteControlEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxTraceRouteControlEntries.setDescription('The maximum number of trace route control entries.')
rsMaxTraceRouteControEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 18, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxTraceRouteControEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxTraceRouteControEntriesAfterReset.setDescription('Future maximum number of trace route control entries.')
rsMaxTraceRouteProbeHistoryEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 18, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxTraceRouteProbeHistoryEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxTraceRouteProbeHistoryEntries.setDescription('The maximum number of trace route probe history entries.')
rsMaxTraceRouteProbeHistoryEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 18, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxTraceRouteProbeHistoryEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxTraceRouteProbeHistoryEntriesAfterReset.setDescription('Future maximum number of trace route probe history entries.')
rsMaxSnmpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 19))
rsMaxSnmpCommunityEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 19, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxSnmpCommunityEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxSnmpCommunityEntries.setDescription('The maximum number of snmpCommunityTable entries.')
rsMaxSnmpCommunityEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 19, 2), Integer32().clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxSnmpCommunityEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxSnmpCommunityEntriesAfterReset.setDescription('Future maximum number of snmpCommunityTable entries.')
rsMaxSocketTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 20))
rsMaxNumberOfSockets = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxNumberOfSockets.setStatus('current')
if mibBuilder.loadTexts: rsMaxNumberOfSockets.setDescription('Maximal number of sockets.')
rsMaxNumberOfSocketsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 20, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxNumberOfSocketsAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxNumberOfSocketsAfterReset.setDescription('Future Maximal number of sockets.')
rsMaxSizeOfSocketDataPool = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 20, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxSizeOfSocketDataPool.setStatus('current')
if mibBuilder.loadTexts: rsMaxSizeOfSocketDataPool.setDescription('Maximal size of socket data pool.')
rsMaxSizeOfSocketDataPoolAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 20, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxSizeOfSocketDataPoolAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxSizeOfSocketDataPoolAfterReset.setDescription('Future Maximal size of socket data pool.')
rsMaxIpRouteTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 21))
rsMaxIpPrefixes = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpPrefixes.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpPrefixes.setDescription('Maximal number of IP prefixes that router supports.')
rsMaxIpPrefixesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 21, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpPrefixesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpPrefixesAfterReset.setDescription('FutureMaximal number of IP prefixes that router supports. ')
rsMaxIpNextHopSetTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 22))
rsMaxIpNextHopSetEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 22, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpNextHopSetEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNextHopSetEntries.setDescription('Maximal number of NextHops that may be\n       used for forwarding for a destinaton.')
rsMaxIpNextHopSetEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 22, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpNextHopSetEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpNextHopSetEntriesAfterReset.setDescription('FutureMaximal number of NextHops that may be\n       used for forwarding for a destinaton. ')
rsMaxIpEcmpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 23))
rsMaxIpEcmpEntrySize = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 23, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpEcmpEntrySize.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpEcmpEntrySize.setDescription('Maximum number of ECMP Sets for forwarding.')
rsMaxIpEcmpEntrySizeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 23, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpEcmpEntrySizeAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpEcmpEntrySizeAfterReset.setDescription('FutureMaximum number of ECMP Sets for forwarding. ')
rsMaxdot1xEapRequestTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 24))
rsMaxdot1xEapRequestEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 24, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxdot1xEapRequestEntries.setStatus('current')
if mibBuilder.loadTexts: rsMaxdot1xEapRequestEntries.setDescription('The maximum number of eap request packets entries that\n         can be retransmitted.')
rsMaxdot1xEapRequestEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 24, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxdot1xEapRequestEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxdot1xEapRequestEntriesAfterReset.setDescription('Future maximum number of eap request packets entries that\n         can be retransmitted.')
rsMaxIpInterfaceTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 25))
rsMaxIpInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 25, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpInterfaces.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpInterfaces.setDescription('Maximal number of IP interfaces.\n       Applies to inBand IP interfaces.')
rsMaxIpInterfacesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 25, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpInterfacesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMaxIpInterfacesAfterReset.setDescription('FutureMaximal number of IP interfaces.\n       Applies to inBand IP interfaces.')
rsTcpTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 11))
rsTcpMemoryPoolSizeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTcpMemoryPoolSizeAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsTcpMemoryPoolSizeAfterReset.setDescription('The size of the memory pool that the tcp will allocate after reset.\n         The memory pool is used for sending packets')
rsTcpMemoryPoolSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 11, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTcpMemoryPoolSize.setStatus('current')
if mibBuilder.loadTexts: rsTcpMemoryPoolSize.setDescription('The size of the memory pool that the tcp uses currently.\n         The memory pool is used for sending packets')
rsRadiusTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 12))
rsRadiusMemoryPoolSizeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 12, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusMemoryPoolSizeAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsRadiusMemoryPoolSizeAfterReset.setDescription('The size of the memory pool that radius will allocate after reset.\n         The memory pool is used for attributes')
rsRadiusMemoryPoolSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRadiusMemoryPoolSize.setStatus('current')
if mibBuilder.loadTexts: rsRadiusMemoryPoolSize.setDescription('The size of the memory pool that radius uses currently.\n         The memory pool is used for attributes')
rlSyslogTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 13))
rlSyslogFilePercentToDeleteWhenCompacting = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 13, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSyslogFilePercentToDeleteWhenCompacting.setStatus('current')
if mibBuilder.loadTexts: rlSyslogFilePercentToDeleteWhenCompacting.setDescription('When the flash file which is used by reports becomes full,\n         a certain percentage of the old messages on flash are deleted.\n         This is the current value.')
rlSyslogFilePercentToDeleteWhenCompactingAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 13, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSyslogFilePercentToDeleteWhenCompactingAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlSyslogFilePercentToDeleteWhenCompactingAfterReset.setDescription('When the flash file which is used by reports becomes full,\n         a certain percentage of the old messages on flash are deleted.\n         This is the value after reset.')
rlSyslogCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 13, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSyslogCacheSize.setStatus('current')
if mibBuilder.loadTexts: rlSyslogCacheSize.setDescription('The size of memory cache of last errors reported.\n         This cache is cyclic.  This is the current value.')
rlSyslogCacheSizeAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 13, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSyslogCacheSizeAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlSyslogCacheSizeAfterReset.setDescription('The size of memory cache of last errors reported.\n         This cache is cyclic.  This is the value after reset.')
rlMngInfTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 14))
rlMaxNumberOfAccessRules = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxNumberOfAccessRules.setStatus('current')
if mibBuilder.loadTexts: rlMaxNumberOfAccessRules.setDescription('The Maximum number of rules per Access List that can be defined')
rlMaxNumberOfAccessRulesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 14, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxNumberOfAccessRulesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxNumberOfAccessRulesAfterReset.setDescription('The Maximum number of rules per Access List for after reset tuning')
rlSshTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 15))
rlSshMaxAuthorizedKeysAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 15, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshMaxAuthorizedKeysAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlSshMaxAuthorizedKeysAfterReset.setDescription('The maximum amount of authorized user keys the SSH deamon will store\n        after reset.')
rlSshMaxAuthorizedKeys = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 15, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshMaxAuthorizedKeys.setStatus('current')
if mibBuilder.loadTexts: rlSshMaxAuthorizedKeys.setDescription('The maximum amount of authorized user keys the SSH deamon stores\n        currently.')
rsDiagnosticTextSource = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fromCLI", 1), ("fromDiagnosticsTable", 2))).clone('fromCLI')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDiagnosticTextSource.setStatus('current')
if mibBuilder.loadTexts: rsDiagnosticTextSource.setDescription('The source from which SNMP diagnostics message texts should be\n         taken.')
rsMultiSession = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 17))
rsMultiSessionMaxSessionsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 17, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMultiSessionMaxSessionsAfterReset.setStatus('current')
if mibBuilder.loadTexts: rsMultiSessionMaxSessionsAfterReset.setDescription('The maximum number of terminal sessions (serial, telnet and ssh)\n        available after reset.')
rsMultiSessionMaxSessions = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 17, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMultiSessionMaxSessions.setStatus('current')
if mibBuilder.loadTexts: rsMultiSessionMaxSessions.setDescription('The maximum number of terminal sessions (serial, telnet and ssh)\n        available.')
rlDnsClTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 18))
rlMaxDnsClCacheRREntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxDnsClCacheRREntries.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClCacheRREntries.setDescription('The current maximal number of DNS client cache entries.')
rlMaxDnsClCacheRREntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxDnsClCacheRREntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClCacheRREntriesAfterReset.setDescription('The future (after reset) maximal number of DNS client cache\n       entries.')
rlMaxDnsClNCacheErrEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxDnsClNCacheErrEntries.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClNCacheErrEntries.setDescription('The current maximal number of DNS client negative cache entries.')
rlMaxDnsClNCacheErrEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxDnsClNCacheErrEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClNCacheErrEntriesAfterReset.setDescription('The future (after reset) maximal number of DNS client negative cache\n       entries.')
rlMaxDnsClNamesEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxDnsClNamesEntries.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClNamesEntries.setDescription('The current maximal number of DNS client static names entries.')
rlMaxDnsClNamesEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 18, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxDnsClNamesEntriesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxDnsClNamesEntriesAfterReset.setDescription('The future (after reset) maximal number of DNS client static names\n       entries.')
rlTuningParamsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 19), )
if mibBuilder.loadTexts: rlTuningParamsTable.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsTable.setDescription('table to show tuning : limits curent and after reset values.')
rlTuningParamsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 19, 1), ).setIndexNames((1, "RADLAN-Tuning", "rlTuningParamsName"))
if mibBuilder.loadTexts: rlTuningParamsEntry.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsEntry.setDescription('Defines the contents of each line in the rlTuningParamsTable table.')
rlTuningParamsName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsName.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsName.setDescription('Index to the rlTuningParamsTable.\n          name of current value Mib for this entry. ')
rlTuningParamsCurrentValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsCurrentValue.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsCurrentValue.setDescription(' This variable current value used in this run by the system.')
rlTuningParamsAfterResetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsAfterResetValue.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsAfterResetValue.setDescription(' This variable value that will be used in next run by the system.\n          i.e. the value will be effective after next reboot')
rlTuningParamsDefaultValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsDefaultValue.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsDefaultValue.setDescription(' This variable value that is used by the system as default.')
rlTuningParamsMinimalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsMinimalValue.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsMinimalValue.setDescription('This variable value indicate minimum value.\n          this is the lower limit for editing the value after reset.')
rlTuningParamsMaximalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 19, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTuningParamsMaximalValue.setStatus('current')
if mibBuilder.loadTexts: rlTuningParamsMaximalValue.setDescription('This variable value indicate maximum value.\n          This is the upper limit for editing the value after reset.')
rlHostParamTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 20), )
if mibBuilder.loadTexts: rlHostParamTable.setStatus('current')
if mibBuilder.loadTexts: rlHostParamTable.setDescription('table to show tuning : limits curent and after reset values.')
rlHostParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 20, 1), ).setIndexNames((1, "RADLAN-Tuning", "rlHostParamName"))
if mibBuilder.loadTexts: rlHostParamEntry.setStatus('current')
if mibBuilder.loadTexts: rlHostParamEntry.setDescription('Defines the contents of each line in the rlHostParamTable table.')
rlHostParamName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 20, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHostParamName.setStatus('current')
if mibBuilder.loadTexts: rlHostParamName.setDescription('Index to the rlHostParamTable.\n          name of current value Mib for this entry. ')
rlHostParamValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlHostParamValue.setStatus('current')
if mibBuilder.loadTexts: rlHostParamValue.setDescription(' This variable current value used in this run by the system.')
rlOspfTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 21))
rlMaxOspfInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxOspfInterfaces.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfInterfaces.setDescription('The current maximum number of ospf interfaces.')
rlMaxOspfInterfacesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxOspfInterfacesAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfInterfacesAfterReset.setDescription('The future (after reset) maximum number of ospf interfaces.')
rlMaxOspfAreas = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxOspfAreas.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfAreas.setDescription('The current maximum number of ospf areas.')
rlMaxOspfAreasAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxOspfAreasAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfAreasAfterReset.setDescription('The future (after reset) maximum number of ospf areas.')
rlMaxOspfNeighbors = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxOspfNeighbors.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfNeighbors.setDescription('The current maximum number of ospf neighbors.')
rlMaxOspfNeighborsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxOspfNeighborsAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfNeighborsAfterReset.setDescription('The future (after reset) maximum number of ospf neighbors.')
rlMaxOspfAbrPerArea = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxOspfAbrPerArea.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfAbrPerArea.setDescription('The current maximum number of ABR in ospf area.')
rlMaxOspfAbrPerAreaAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxOspfAbrPerAreaAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfAbrPerAreaAfterReset.setDescription('The future (after reset) maximum number of ABR in ospf area.')
rlMaxOspfNetsInAs = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlMaxOspfNetsInAs.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfNetsInAs.setDescription('The current maximum number of networks in AS.')
rlMaxOspfNetsInAsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 21, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlMaxOspfNetsInAsAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlMaxOspfNetsInAsAfterReset.setDescription('The future (after reset) maximum number of networks in AS.')
rlVlanTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 22))
rlVlanDefaultVID = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 22, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlVlanDefaultVID.setStatus('current')
if mibBuilder.loadTexts: rlVlanDefaultVID.setDescription('The default vlan vid.')
rlVlanDefaultVIDAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 22, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlVlanDefaultVIDAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlVlanDefaultVIDAfterReset.setDescription('The default vlan vid after rest')
rlDependendFeaturesEnableTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 23))
rlDependendFeaturesEnabled = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 23, 1), Bits().clone(namedValues=NamedValues(("ipV4routingEnabled", 0), ("policyBasedVlanEnabled", 1), ("qualityOfServiceEnables", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlDependendFeaturesEnabled.setStatus('current')
if mibBuilder.loadTexts: rlDependendFeaturesEnabled.setDescription('Current set of running features.\n        These features combinations may limit by\n          A. The same resource (such as ASIC module).\n          B. limitation of product or logic for combination\n          System limit is for up to 5 features\n          First implemented with 3.')
rlDependendFeaturesEnabledAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 23, 2), Bits().clone(namedValues=NamedValues(("ipV4routingEnabled", 0), ("policyBasedVlanEnabled", 1), ("qualityOfServiceEnables", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDependendFeaturesEnabledAfterReset.setStatus('current')
if mibBuilder.loadTexts: rlDependendFeaturesEnabledAfterReset.setDescription('Next system load (after reset) set of running features.\n        These features combinations limited by\n          A. The same resource (such as ASIC module).\n          B. Limitation of product or logic for combination (one feature override the other).\n          C. Per product some or all features status may not be changed.\n        System limit is for up to 5 features\n        First implemented with 3.')
mibBuilder.exportSymbols("RADLAN-Tuning", rsMaxIpxFftEntriesTuning=rsMaxIpxFftEntriesTuning, rsMaxIgmpTuning=rsMaxIgmpTuning, rsRadiusTuning=rsRadiusTuning, rsMaxPimNeighborEntriesAfterReset=rsMaxPimNeighborEntriesAfterReset, rsMaxIpEcmpEntrySizeAfterReset=rsMaxIpEcmpEntrySizeAfterReset, rsMaxNumberOfSocketsAfterReset=rsMaxNumberOfSocketsAfterReset, rsMaxIpxFrwEntries=rsMaxIpxFrwEntries, rlMaxDnsClCacheRREntries=rlMaxDnsClCacheRREntries, rsMaxTraceRouteControEntriesAfterReset=rsMaxTraceRouteControEntriesAfterReset, rsMaxIpNextHopSetTuning=rsMaxIpNextHopSetTuning, rsMaxIpEcmpTuning=rsMaxIpEcmpTuning, rsMaxRmonTuning=rsMaxRmonTuning, rsMaxdot1xEapRequestEntriesAfterReset=rsMaxdot1xEapRequestEntriesAfterReset, rsMaxIgmpCacheEntriesAfterReset=rsMaxIgmpCacheEntriesAfterReset, rsMaxRmonEtherHistoryEntriesAfterReset=rsMaxRmonEtherHistoryEntriesAfterReset, rsMaxIpPrefixes=rsMaxIpPrefixes, rsMaxArpEntriesTuning=rsMaxArpEntriesTuning, rsMaxIpNextHopEntries=rsMaxIpNextHopEntries, rsTcpMemoryPoolSizeAfterReset=rsTcpMemoryPoolSizeAfterReset, rlSshMaxAuthorizedKeys=rlSshMaxAuthorizedKeys, rsMaxPimInterfaceEntries=rsMaxPimInterfaceEntries, rlMaxOspfInterfaces=rlMaxOspfInterfaces, rsMaxIpSFftEntries=rsMaxIpSFftEntries, rsMaxIpNFftEntries=rsMaxIpNFftEntries, rsHighPriority=rsHighPriority, rlMaxOspfNeighbors=rlMaxOspfNeighbors, rlMaxDnsClCacheRREntriesAfterReset=rlMaxDnsClCacheRREntriesAfterReset, rlTuningParamsCurrentValue=rlTuningParamsCurrentValue, rsMaxNumberRpAddresesInGroupRangeAfterReset=rsMaxNumberRpAddresesInGroupRangeAfterReset, rsDiagnosticsRequestId=rsDiagnosticsRequestId, rsMaxIpForwardingEntriesTuning=rsMaxIpForwardingEntriesTuning, rsMaxIpNFftEntriesAfterReset=rsMaxIpNFftEntriesAfterReset, rsMaxIpxNFftEntries=rsMaxIpxNFftEntries, rlMaxDnsClNCacheErrEntriesAfterReset=rlMaxDnsClNCacheErrEntriesAfterReset, rlTuningParamsDefaultValue=rlTuningParamsDefaultValue, rsMaxPigmpRouteEntriesAfterReset=rsMaxPigmpRouteEntriesAfterReset, rlMaxNumberOfAccessRulesAfterReset=rlMaxNumberOfAccessRulesAfterReset, rsMaxIpxSFftSysEntriesAfterReset=rsMaxIpxSFftSysEntriesAfterReset, rsMaxIgmpCacheEntries=rsMaxIgmpCacheEntries, rsMaxSocketTuning=rsMaxSocketTuning, rsMaxPimTuning=rsMaxPimTuning, rsIpmFftAging=rsIpmFftAging, rsMaxPolicyTuning=rsMaxPolicyTuning, rsMaxSnmpCommunityEntriesAfterReset=rsMaxSnmpCommunityEntriesAfterReset, rsMaxdot1xEapRequestTuning=rsMaxdot1xEapRequestTuning, rsMaxTraceRouteControlEntries=rsMaxTraceRouteControlEntries, rsMaxGvrpVlansTuning=rsMaxGvrpVlansTuning, rlMaxOspfNeighborsAfterReset=rlMaxOspfNeighborsAfterReset, rsMaxIgmpSnoopGroupEntriesAfterReset=rsMaxIgmpSnoopGroupEntriesAfterReset, rlDnsClTuning=rlDnsClTuning, rsMaxIpxNFftSysEntriesAfterReset=rsMaxIpxNFftSysEntriesAfterReset, rsMaxIpSFftEntriesAfterReset=rsMaxIpSFftEntriesAfterReset, rsMaxDspClntEntriesAfterReset=rsMaxDspClntEntriesAfterReset, rlDependendFeaturesEnabledAfterReset=rlDependendFeaturesEnabledAfterReset, rsMaxSnmpTuning=rsMaxSnmpTuning, rsMaxIpxFrwEntriesAfterReset=rsMaxIpxFrwEntriesAfterReset, rlHostParamTable=rlHostParamTable, rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset=rsMaxPolicySimpleMibMaxProfilesEntriesAfterReset, rlMaxNumberOfAccessRules=rlMaxNumberOfAccessRules, rsMaxEntriesTuning=rsMaxEntriesTuning, rsMaxDvmrpMRouteEntries=rsMaxDvmrpMRouteEntries, eventMessageTable=eventMessageTable, rlSyslogFilePercentToDeleteWhenCompacting=rlSyslogFilePercentToDeleteWhenCompacting, rsMultiSessionMaxSessionsAfterReset=rsMultiSessionMaxSessionsAfterReset, rsMaxPimRouteNextHopEntries=rsMaxPimRouteNextHopEntries, rsMaxBridgeForwardingEntriesTuning=rsMaxBridgeForwardingEntriesTuning, rsMaxDvmrpInterfaceEntries=rsMaxDvmrpInterfaceEntries, rsMaxBrgFrwEntries=rsMaxBrgFrwEntries, rsRadiusMemoryPoolSizeAfterReset=rsRadiusMemoryPoolSizeAfterReset, rsMultiSession=rsMultiSession, rlTuningParamsMinimalValue=rlTuningParamsMinimalValue, rlTuningParamsMaximalValue=rlTuningParamsMaximalValue, rlMaxDnsClNCacheErrEntries=rlMaxDnsClNCacheErrEntries, rsMaxIpFrwEntriesAfterReset=rsMaxIpFrwEntriesAfterReset, rsMaxPigmpTuning=rsMaxPigmpTuning, rlVlanTuning=rlVlanTuning, rsMaxIpNFftSysEntries=rsMaxIpNFftSysEntries, rlTuningParamsName=rlTuningParamsName, reaIpForwardEnable=reaIpForwardEnable, rsMaxIpmTuning=rsMaxIpmTuning, rsDiagnosticsLocation=rsDiagnosticsLocation, rsLowPriority=rsLowPriority, rsMaxPimSmInterfaceEntries=rsMaxPimSmInterfaceEntries, rlVlanDefaultVIDAfterReset=rlVlanDefaultVIDAfterReset, rsMaxPimSmRPSetEntriesAfterReset=rsMaxPimSmRPSetEntriesAfterReset, rsMaxIgmpSnoopTuning=rsMaxIgmpSnoopTuning, rlDependendFeaturesEnabled=rlDependendFeaturesEnabled, rsMaxIpSFftSysEntriesAfterReset=rsMaxIpSFftSysEntriesAfterReset, rsMaxDhcpConns=rsMaxDhcpConns, rsMaxIpxSFftEntries=rsMaxIpxSFftEntries, rsMaxPimRouteEntries=rsMaxPimRouteEntries, rsMaxdot1xEapRequestEntries=rsMaxdot1xEapRequestEntries, rsMaxRmonEtherHistoryEntries=rsMaxRmonEtherHistoryEntries, rsMaxIpxForwardingEntriesTuning=rsMaxIpxForwardingEntriesTuning, rlOspfTuning=rlOspfTuning, rsMaxDvmrpMRouteEntriesAfterReset=rsMaxDvmrpMRouteEntriesAfterReset, eventNum=eventNum, rsMaxIpxSapEntriesAfterReset=rsMaxIpxSapEntriesAfterReset, rsMaxIgmpSnoopGroupEntries=rsMaxIgmpSnoopGroupEntries, rlMaxOspfAreas=rlMaxOspfAreas, rsMaxPigmpRouteEntries=rsMaxPigmpRouteEntries, rsMaxPimSmTuning=rsMaxPimSmTuning, rlTuningParamsEntry=rlTuningParamsEntry, rsTcpTuning=rsTcpTuning, rsDiagnosticTextSource=rsDiagnosticTextSource, rsMaxDvmrpRouteEntries=rsMaxDvmrpRouteEntries, rsMaxIpNextHopSetEntries=rsMaxIpNextHopSetEntries, rsMaxIpInterfaceTuning=rsMaxIpInterfaceTuning, rsRadiusMemoryPoolSize=rsRadiusMemoryPoolSize, rsMaxGvrpVlans=rsMaxGvrpVlans, rsMaxDhcpTuning=rsMaxDhcpTuning, rsMaxIpmFftEntriesTuning=rsMaxIpmFftEntriesTuning, rsMaxSnmpCommunityEntries=rsMaxSnmpCommunityEntries, rsMaxPimSmNeighborEntriesAfterReset=rsMaxPimSmNeighborEntriesAfterReset, rsMaxRmonLogEntries=rsMaxRmonLogEntries, rsTcpMemoryPoolSize=rsTcpMemoryPoolSize, rsMaxNumberOfSockets=rsMaxNumberOfSockets, rlMaxOspfAreasAfterReset=rlMaxOspfAreasAfterReset, rsMaxNumberRpAddresesInGroupRange=rsMaxNumberRpAddresesInGroupRange, rsMaxIgmpInterfaceEntriesAfterReset=rsMaxIgmpInterfaceEntriesAfterReset, rsDiagnosticsText=rsDiagnosticsText, rsMaxDvmrpNeighborEntriesAfterReset=rsMaxDvmrpNeighborEntriesAfterReset, reaTunning=reaTunning, rlSyslogFilePercentToDeleteWhenCompactingAfterReset=rlSyslogFilePercentToDeleteWhenCompactingAfterReset, rlTuningParamsTable=rlTuningParamsTable, rlSshMaxAuthorizedKeysAfterReset=rlSshMaxAuthorizedKeysAfterReset, rsMaxPimRouteNextHopEntriesAfterReset=rsMaxPimRouteNextHopEntriesAfterReset, rsMaxTraceRouteProbeHistoryEntries=rsMaxTraceRouteProbeHistoryEntries, rsMaxVlansEntriesAfterReset=rsMaxVlansEntriesAfterReset, rsMaxPolicySimpleMibMaxRulesEntries=rsMaxPolicySimpleMibMaxRulesEntries, rlMaxOspfInterfacesAfterReset=rlMaxOspfInterfacesAfterReset, rsMaxDspClntEntriesTuning=rsMaxDspClntEntriesTuning, rlHostParamValue=rlHostParamValue, rlMngInfTuning=rlMngInfTuning, rsMaxIpxSFftSysEntries=rsMaxIpxSFftSysEntries, rsMaxVlansTuning=rsMaxVlansTuning, rsMaxPimSmNeighborEntries=rsMaxPimSmNeighborEntries, rsMaxPolicySimpleMibMaxRulesEntriesAfterReset=rsMaxPolicySimpleMibMaxRulesEntriesAfterReset, rlMaxOspfAbrPerArea=rlMaxOspfAbrPerArea, rsDiagnosticsEntry=rsDiagnosticsEntry, eventDesc=eventDesc, rsMaxIpEcmpEntrySize=rsMaxIpEcmpEntrySize, rsMaxIpRouteTuning=rsMaxIpRouteTuning, rsMaxDspClntEntries=rsMaxDspClntEntries, rsMaxPimSmRouteEntries=rsMaxPimSmRouteEntries, rsMaxPimSmInterfaceEntriesAfterReset=rsMaxPimSmInterfaceEntriesAfterReset, rsMaxPolicyMaxRulesEntries=rsMaxPolicyMaxRulesEntries, rlSshTuning=rlSshTuning, rsMaxIpNFftSysEntriesAfterReset=rsMaxIpNFftSysEntriesAfterReset, rsMaxPimSmRPSetEntries=rsMaxPimSmRPSetEntries, rsMaxSizeOfSocketDataPool=rsMaxSizeOfSocketDataPool, rsMaxIpInterfaces=rsMaxIpInterfaces, rlTuningParamsAfterResetValue=rlTuningParamsAfterResetValue, rsMaxDvmrpRouteEntriesAfterReset=rsMaxDvmrpRouteEntriesAfterReset, rsMaxSizeOfSocketDataPoolAfterReset=rsMaxSizeOfSocketDataPoolAfterReset, rsMaxTraceRouteTuning=rsMaxTraceRouteTuning, rlMaxOspfAbrPerAreaAfterReset=rlMaxOspfAbrPerAreaAfterReset, PYSNMP_MODULE_ID=rsTunning, rlVlanDefaultVID=rlVlanDefaultVID, rsMaxBrgFrwEntriesAfterReset=rsMaxBrgFrwEntriesAfterReset, rsMaxIpxSapEntries=rsMaxIpxSapEntries, rsMaxIpxSFftEntriesAfterReset=rsMaxIpxSFftEntriesAfterReset, rsMaxDvmrpInterfaceEntriesAfterReset=rsMaxDvmrpInterfaceEntriesAfterReset, rsMaxIpInterfacesAfterReset=rsMaxIpInterfacesAfterReset, rsMaxPimSmRouteEntriesAfterReset=rsMaxPimSmRouteEntriesAfterReset, rsMaxPimSmCRPEntries=rsMaxPimSmCRPEntries, rsMaxIgmpInterfaceEntries=rsMaxIgmpInterfaceEntries, rlSyslogTuning=rlSyslogTuning, rlHostParamName=rlHostParamName, rsMaxDhcpConnsAfterReset=rsMaxDhcpConnsAfterReset, rsMaxTraceRouteProbeHistoryEntriesAfterReset=rsMaxTraceRouteProbeHistoryEntriesAfterReset, rlSyslogCacheSize=rlSyslogCacheSize, rlHostParamEntry=rlHostParamEntry, rsMaxIpPrefixesAfterReset=rsMaxIpPrefixesAfterReset, rsMaxDvmrpNeighborEntries=rsMaxDvmrpNeighborEntries, rsDbgLevel=rsDbgLevel, rsDiagnosticsCode=rsDiagnosticsCode, rsMaxIpmFftEntriesAfterReset=rsMaxIpmFftEntriesAfterReset, rsMaxPimInterfaceEntriesAfterReset=rsMaxPimInterfaceEntriesAfterReset, rsMaxIpxSapEntriesTuning=rsMaxIpxSapEntriesTuning, rsMaxRmonLogEntriesAfterReset=rsMaxRmonLogEntriesAfterReset, rsConfirmMessagTab=rsConfirmMessagTab, rsMaxIpmFftEntries=rsMaxIpmFftEntries, rsMaxPolicySimpleMibMaxProfilesEntries=rsMaxPolicySimpleMibMaxProfilesEntries, rlMaxOspfNetsInAs=rlMaxOspfNetsInAs, rsMaxArpEntries=rsMaxArpEntries, rsDiagnosticsTable=rsDiagnosticsTable, rlSyslogCacheSizeAfterReset=rlSyslogCacheSizeAfterReset, rsMaxVlansEntries=rsMaxVlansEntries, rsMultiSessionMaxSessions=rsMultiSessionMaxSessions, rlMaxOspfNetsInAsAfterReset=rlMaxOspfNetsInAsAfterReset, rsMaxIpFftEntriesTuning=rsMaxIpFftEntriesTuning, rsMaxGvrpVlansAfterReset=rsMaxGvrpVlansAfterReset, rsMaxPimSmCRPEntriesAfterReset=rsMaxPimSmCRPEntriesAfterReset, rsMaxIpxNFftEntriesAfterReset=rsMaxIpxNFftEntriesAfterReset, rsMaxIpSFftSysEntries=rsMaxIpSFftSysEntries, rsMaxPolicyMaxRulesEntriesAfterReset=rsMaxPolicyMaxRulesEntriesAfterReset, rsMaxIpNextHopSetEntriesAfterReset=rsMaxIpNextHopSetEntriesAfterReset, rlMaxDnsClNamesEntriesAfterReset=rlMaxDnsClNamesEntriesAfterReset, rsMaxDvmrpTuning=rsMaxDvmrpTuning, rsMaxPimRouteEntriesAfterReset=rsMaxPimRouteEntriesAfterReset, rsMaxIpxNFftSysEntries=rsMaxIpxNFftSysEntries, rsMaxArpEntriesAfterReset=rsMaxArpEntriesAfterReset, rsMaxIpNextHopEntriesAfterReset=rsMaxIpNextHopEntriesAfterReset, rlDependendFeaturesEnableTuning=rlDependendFeaturesEnableTuning, eventMessageEntry=eventMessageEntry, reaIpxForwardEnable=reaIpxForwardEnable, rsMaxIpFrwEntries=rsMaxIpFrwEntries, rsTunning=rsTunning, rlMaxDnsClNamesEntries=rlMaxDnsClNamesEntries, rsMaxPimNeighborEntries=rsMaxPimNeighborEntries)
