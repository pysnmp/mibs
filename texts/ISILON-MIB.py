#
# PySNMP MIB module ISILON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/emc/ISILON-MIB
# Produced by pysmi-1.1.8 at Sat Jan 15 23:24:44 2022
# On host fv-az42-839 platform Linux version 5.11.0-1025-azure by user runner
# Using Python version 3.10.1 (main, Dec 22 2021, 10:45:09) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
CounterBasedGauge64, = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, Counter64, enterprises, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, IpAddress, Bits, ObjectIdentity, ModuleIdentity, NotificationType, Unsigned32, Integer32, Counter32, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter64", "enterprises", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "IpAddress", "Bits", "ObjectIdentity", "ModuleIdentity", "NotificationType", "Unsigned32", "Integer32", "Counter32", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
isilon = ModuleIdentity((1, 3, 6, 1, 4, 1, 12124))
isilon.setRevisions(('2015-09-23 00:00', '2015-04-07 00:00', '2010-10-21 00:00', '2010-06-29 00:00', '2009-12-15 00:00', '2009-11-10 00:00', '2009-05-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: isilon.setRevisionsDescriptions(('Removed support for the iSCSI protocol in nodeProtocolPerfTable', 'MIB maintenance, using smilint to fix errors and warnings in MIB as\n        well as improving descriptions and fixing spelling and grammar errors.\n        Added compliance groups for SMIv2, and removed unused imports.', 'The list of protocols supported by OneFS and reported in the\n     nodeProtocolPerfEntry tables has changed: CIFS was\n     renamed to SMB1, SMB2 was added, NFS was renamed to\n     NFS3 (which includes also version 2), and NFS4 was added.', 'diskPerfOutBytesPerSecond was renamed to diskPerfOutBitsPerSecond.\n     The value returned by the OID was and is bits per second.\n     ifsFreeBytes was added, comparing with ifsAvailableBytes will\n     show space used for Virtual Hot Spares (system reserve).', 'iSCSI and SyncIQ protocols were added to nodeProtocolPerfTable.', 'The following OIDs were obsoleted: clusterNetworkInBytes,\n       clusterNetworkOutBytes, nodeNetworkInBytes, and\n       nodeNetworkOutBytes.', 'Initial revision.',))
if mibBuilder.loadTexts: isilon.setLastUpdated('201509230000Z')
if mibBuilder.loadTexts: isilon.setOrganization('Isilon Systems LLC')
if mibBuilder.loadTexts: isilon.setContactInfo('Isilon Systems LLC\n         Support phone: 1-800.782.4362 \n         Support website: http://support.emc.com\n        ')
if mibBuilder.loadTexts: isilon.setDescription('The base MIB module for Isilon Systems OneFS operating system.')
cluster = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1))
node = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2))
local = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 4))
conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5))
clusterStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 1))
clusterPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 2))
ifsFilesystem = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 3))
licenses = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 5))
quotas = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 12))
snapshots = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 13))
clusterName = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterName.setStatus('current')
if mibBuilder.loadTexts: clusterName.setDescription('The name of the cluster.')
clusterHealth = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("attn", 1), ("down", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterHealth.setStatus('current')
if mibBuilder.loadTexts: clusterHealth.setDescription('The overall health of the cluster.')
clusterGUID = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterGUID.setStatus('current')
if mibBuilder.loadTexts: clusterGUID.setDescription('The globally unique identifier for the cluster.')
nodeCount = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCount.setStatus('current')
if mibBuilder.loadTexts: nodeCount.setDescription('The total number of nodes in the cluster.')
configuredNodes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configuredNodes.setStatus('current')
if mibBuilder.loadTexts: configuredNodes.setDescription('A comma-separted list of the logical node numbers\n        of the configured nodes in the cluster.')
onlineNodes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: onlineNodes.setStatus('current')
if mibBuilder.loadTexts: onlineNodes.setDescription('A comma-separted list of the logical node numbers\n        of the online nodes in the cluster.')
offlineNodes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: offlineNodes.setStatus('current')
if mibBuilder.loadTexts: offlineNodes.setDescription('A comma-separted list of the logical node numbers\n        of the offline nodes in the cluster.')
clusterIfsPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 2, 1))
clusterIfsInBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 1, 1), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterIfsInBytes.setStatus('current')
if mibBuilder.loadTexts: clusterIfsInBytes.setDescription('The cumulative number of bytes into /ifs.')
clusterIfsInBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 1, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterIfsInBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: clusterIfsInBitsPerSecond.setDescription('The cumulative throughput rate (bits per second) into /ifs.')
clusterIfsOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 1, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterIfsOutBytes.setStatus('current')
if mibBuilder.loadTexts: clusterIfsOutBytes.setDescription('The cumulative number of bytes out of /ifs.')
clusterIfsOutBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 1, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterIfsOutBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: clusterIfsOutBitsPerSecond.setDescription('The cumulative throughput rate (bits per second) out of /ifs.')
clusterNetworkPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 2, 2))
clusterNetworkInBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 2, 1), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterNetworkInBytes.setStatus('obsolete')
if mibBuilder.loadTexts: clusterNetworkInBytes.setDescription('The cumulative input bytes for all external interfaces.\n        Obsolete.')
clusterNetworkInBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 2, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterNetworkInBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: clusterNetworkInBitsPerSecond.setDescription('The cumulative input rate (bits per second) for\n         all external interfaces.')
clusterNetworkOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 2, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterNetworkOutBytes.setStatus('obsolete')
if mibBuilder.loadTexts: clusterNetworkOutBytes.setDescription('The cumulative output bytes for all external interfaces.\n        Obsolete.')
clusterNetworkOutBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 2, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterNetworkOutBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: clusterNetworkOutBitsPerSecond.setDescription('The cumulative output rate (bits per second) for\n         all external interfaces.')
clusterCPUPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3))
clusterCPUUser = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCPUUser.setStatus('current')
if mibBuilder.loadTexts: clusterCPUUser.setDescription('Average amount of CPU time (per mil) used by user processes \n        averaged for all nodes over the last 5 seconds.')
clusterCPUNice = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCPUNice.setStatus('current')
if mibBuilder.loadTexts: clusterCPUNice.setDescription('Average amount of CPU time (per mil) used by nice processes \n        averaged for all nodes over the last 5 seconds.')
clusterCPUSystem = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCPUSystem.setStatus('current')
if mibBuilder.loadTexts: clusterCPUSystem.setDescription('Average amount of CPU time (per mil) used by system processes \n        averaged for all nodes over the last 5 seconds.')
clusterCPUInterrupt = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCPUInterrupt.setStatus('current')
if mibBuilder.loadTexts: clusterCPUInterrupt.setDescription('Average amount of CPU time (per mil) used by interrupts \n        averaged for all nodes over the last 5 seconds.')
clusterCPUIdlePct = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 2, 3, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCPUIdlePct.setStatus('current')
if mibBuilder.loadTexts: clusterCPUIdlePct.setDescription('Average amount of idle CPU time (per mil) averaged for all nodes\n        averaged for all nodes over the last 5 seconds.')
ifsTotalBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 1), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifsTotalBytes.setStatus('current')
if mibBuilder.loadTexts: ifsTotalBytes.setDescription('The total cluster capacity of the /ifs filesystem in bytes.')
ifsUsedBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifsUsedBytes.setStatus('current')
if mibBuilder.loadTexts: ifsUsedBytes.setDescription('The number of bytes used in the /ifs filesystem.')
ifsAvailableBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifsAvailableBytes.setStatus('current')
if mibBuilder.loadTexts: ifsAvailableBytes.setDescription('The number of bytes available for use in the /ifs filesystem.')
ifsFreeBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifsFreeBytes.setStatus('current')
if mibBuilder.loadTexts: ifsFreeBytes.setDescription('The number of bytes free in the /ifs filesystem (includes\n        Virtual Hot Spare).')
accessTimeEnabled = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessTimeEnabled.setStatus('current')
if mibBuilder.loadTexts: accessTimeEnabled.setDescription('Indicates if access time tracking is enabled on the /ifs filesystem.')
accessTimeGracePeriod = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 3, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessTimeGracePeriod.setStatus('current')
if mibBuilder.loadTexts: accessTimeGracePeriod.setDescription("Tthe minimum amount of time (in milliseconds) \n         between updates to a file's last access time.")
licenseTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1), )
if mibBuilder.loadTexts: licenseTable.setStatus('current')
if mibBuilder.loadTexts: licenseTable.setDescription('Licensing information for OneFS software modules.')
licenseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1, 1), ).setIndexNames((0, "ISILON-MIB", "licenseIndex"))
if mibBuilder.loadTexts: licenseEntry.setStatus('current')
if mibBuilder.loadTexts: licenseEntry.setDescription("A software module's license status.")
licenseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)))
if mibBuilder.loadTexts: licenseIndex.setStatus('current')
if mibBuilder.loadTexts: licenseIndex.setDescription('Index of a row in the licensed modules table.')
licenseModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseModuleName.setStatus('current')
if mibBuilder.loadTexts: licenseModuleName.setDescription('The name of the licensable module.')
licenseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-2, -1, 0, 1))).clone(namedValues=NamedValues(("inactive", -2), ("expired", -1), ("activated", 0), ("evaluation", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseStatus.setStatus('current')
if mibBuilder.loadTexts: licenseStatus.setDescription('The status of the license. It may be licensed, unlicensed \n        (inactive or expired), or an evaluation license.')
licenseExpirationDate = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 5, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseExpirationDate.setStatus('current')
if mibBuilder.loadTexts: licenseExpirationDate.setDescription('The UNIX epoch time that the license expires. This value is only\n        present for evaluation licenses as normal licenses do not expire.')
quotaTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1), )
if mibBuilder.loadTexts: quotaTable.setStatus('current')
if mibBuilder.loadTexts: quotaTable.setDescription('A table of specific directory, user, and group quotas.')
quotaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1), ).setIndexNames((0, "ISILON-MIB", "quotaDomainID"))
if mibBuilder.loadTexts: quotaEntry.setStatus('current')
if mibBuilder.loadTexts: quotaEntry.setDescription('A quota.')
quotaDomainID = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(48, 48)).setFixedLength(48))
if mibBuilder.loadTexts: quotaDomainID.setStatus('current')
if mibBuilder.loadTexts: quotaDomainID.setDescription('The unique identifier for the quota.')
quotaType = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("defaultUser", 0), ("user", 1), ("defaultGroup", 2), ("group", 3), ("directory", 4), ("special", 5), ("max", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaType.setStatus('current')
if mibBuilder.loadTexts: quotaType.setDescription('The type of quota.')
quotaID = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaID.setStatus('current')
if mibBuilder.loadTexts: quotaID.setDescription('The user or group ID governed by this quota, if this is a \n        user or group quota; otherwise 0.')
quotaIncludesSnapshotUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaIncludesSnapshotUsage.setStatus('current')
if mibBuilder.loadTexts: quotaIncludesSnapshotUsage.setDescription('Indicates whether or not snapshot usage is included\n         in the quota usage.')
quotaPath = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaPath.setStatus('current')
if mibBuilder.loadTexts: quotaPath.setDescription('The path governed by this quota.')
quotaHardThresholdDefined = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaHardThresholdDefined.setStatus('current')
if mibBuilder.loadTexts: quotaHardThresholdDefined.setDescription('Indicates if a hard threshold is enforced for the quota.')
quotaHardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 7), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaHardThreshold.setStatus('current')
if mibBuilder.loadTexts: quotaHardThreshold.setDescription('The hard threshold in bytes.')
quotaSoftThresholdDefined = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaSoftThresholdDefined.setStatus('current')
if mibBuilder.loadTexts: quotaSoftThresholdDefined.setDescription('Indicates if a soft threshold is enforced for the quota.')
quotaSoftThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaSoftThreshold.setStatus('current')
if mibBuilder.loadTexts: quotaSoftThreshold.setDescription('The soft threshold in bytes.')
quotaAdvisoryThresholdDefined = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaAdvisoryThresholdDefined.setStatus('current')
if mibBuilder.loadTexts: quotaAdvisoryThresholdDefined.setDescription('Indicates if an advisory threshold is enforced for the quota.')
quotaAdvisoryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 11), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaAdvisoryThreshold.setStatus('current')
if mibBuilder.loadTexts: quotaAdvisoryThreshold.setDescription('The advisory threshold in bytes.')
quotaGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaGracePeriod.setStatus('current')
if mibBuilder.loadTexts: quotaGracePeriod.setDescription('The grace period for the soft threshold. If the soft threshold\n        is exceeded for this time period, write access will be denied.')
quotaUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 13), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaUsage.setStatus('current')
if mibBuilder.loadTexts: quotaUsage.setDescription('The current quota usage in bytes.')
quotaUsageWithOverhead = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 14), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaUsageWithOverhead.setStatus('current')
if mibBuilder.loadTexts: quotaUsageWithOverhead.setDescription('The current quota usage in bytes including FlexProtect overhead.')
quotaInodeUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 15), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaInodeUsage.setStatus('current')
if mibBuilder.loadTexts: quotaInodeUsage.setDescription('The number of inodes (directories and files) covered by the quota.')
quotaIncludesOverhead = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 12, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: quotaIncludesOverhead.setStatus('current')
if mibBuilder.loadTexts: quotaIncludesOverhead.setDescription('Indicates if the quota includes data protection overhead.')
snapshotSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1))
snapshotScheduledCreateEnabled = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduledCreateEnabled.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduledCreateEnabled.setDescription('Indicates if the scheduled (automatic) creation of snapshots\n        should occur.')
snapshotScheduledDeleteEnabled = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduledDeleteEnabled.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduledDeleteEnabled.setDescription('Indicates if scheduled (automatic) deletion of snapshots\n        should occur.')
snapshotReservedPct = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotReservedPct.setStatus('current')
if mibBuilder.loadTexts: snapshotReservedPct.setDescription('The percent of storage space reserved for snapshots. The value\n        report is a percentage of total cluster storage capacity.')
snapshotRootVisibilityNFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootVisibilityNFS.setStatus('current')
if mibBuilder.loadTexts: snapshotRootVisibilityNFS.setDescription('Indicates if the /ifs/.snapshot directory is visible\n        to NFS clients.')
snapshotRootAccessNFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootAccessNFS.setStatus('current')
if mibBuilder.loadTexts: snapshotRootAccessNFS.setDescription('Indicates if the /ifs/.snapshot directory is accessible\n        to NFS clients.')
snapshotSubdirAccessNFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotSubdirAccessNFS.setStatus('current')
if mibBuilder.loadTexts: snapshotSubdirAccessNFS.setDescription('Indicates if .snapshot directories in subdirectories of /ifs are\n        visible to NFS clients.')
snapshotRootVisibilityCIFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootVisibilityCIFS.setStatus('current')
if mibBuilder.loadTexts: snapshotRootVisibilityCIFS.setDescription('Indicates if the /ifs/.snapshot directory is visible\n        to CIFS clients.')
snapshotRootAccessCIFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootAccessCIFS.setStatus('current')
if mibBuilder.loadTexts: snapshotRootAccessCIFS.setDescription('Indicates if the /ifs/.snapshot directory is accessible\n        to CIFS clients.')
snapshotSubdirAccessCIFS = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotSubdirAccessCIFS.setStatus('current')
if mibBuilder.loadTexts: snapshotSubdirAccessCIFS.setDescription('Indicates if .snapshot directories in subdirectories of /ifs are\n        visible to CIFS clients.')
snapshotRootVisibilityLocal = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootVisibilityLocal.setStatus('current')
if mibBuilder.loadTexts: snapshotRootVisibilityLocal.setDescription('Indicates if .snapshot directories in subdirectories of /ifs are\n        visible to local users.')
snapshotRootAccessLocal = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotRootAccessLocal.setStatus('current')
if mibBuilder.loadTexts: snapshotRootAccessLocal.setDescription('Indicates if the /ifs/.snapshot directory is visible\n        to local users.')
snapshotSubdirAccessLocal = MibScalar((1, 3, 6, 1, 4, 1, 12124, 1, 13, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotSubdirAccessLocal.setStatus('current')
if mibBuilder.loadTexts: snapshotSubdirAccessLocal.setDescription('Indicates if the /ifs/.snapshot directory is accessible\n        to local users.')
snapshotScheduleTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2), )
if mibBuilder.loadTexts: snapshotScheduleTable.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleTable.setDescription('A table of snapshot schedules.')
snapshotScheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1), ).setIndexNames((0, "ISILON-MIB", "snapshotScheduleIndex"))
if mibBuilder.loadTexts: snapshotScheduleEntry.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleEntry.setDescription('A snapshot schedule.')
snapshotScheduleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleIndex.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleIndex.setDescription('The unique identifier for a snapshot schedule.')
snapshotScheduleName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleName.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleName.setDescription('The name of the schedule.')
snapshotScheduleAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleAlias.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleAlias.setDescription('The alias for snapshots created by the schedule.')
snapshotScheduleNamingPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleNamingPattern.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleNamingPattern.setDescription('The naming pattern for snapshots created by the schedule.')
snapshotScheduleSchedule = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleSchedule.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleSchedule.setDescription('The date, time, and frequency that snapshots\n         will be created by this schedule.')
snapshotScheduleExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotScheduleExpiration.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleExpiration.setDescription('Description of when snapshots created by the schedule will expire.')
snapshotSchedulePath = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotSchedulePath.setStatus('current')
if mibBuilder.loadTexts: snapshotSchedulePath.setDescription('The paths that snapshots will be created from for the schedule.')
snapshotTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3), )
if mibBuilder.loadTexts: snapshotTable.setStatus('current')
if mibBuilder.loadTexts: snapshotTable.setDescription('A table of snapshots.')
snapshotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1), ).setIndexNames((0, "ISILON-MIB", "snapshotIndex"))
if mibBuilder.loadTexts: snapshotEntry.setStatus('current')
if mibBuilder.loadTexts: snapshotEntry.setDescription('A snapshot.')
snapshotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: snapshotIndex.setStatus('current')
if mibBuilder.loadTexts: snapshotIndex.setDescription('The unique identifier of the snapshot.')
snapshotName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotName.setStatus('current')
if mibBuilder.loadTexts: snapshotName.setDescription('The name of the snapshot.')
snapshotCreated = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotCreated.setStatus('current')
if mibBuilder.loadTexts: snapshotCreated.setDescription('The UNIX epoch time at which the snapshot was created.')
snapshotExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotExpires.setStatus('current')
if mibBuilder.loadTexts: snapshotExpires.setDescription('The UNIX epoch time that the snapshot expires in seconds.')
snapshotSize = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 5), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotSize.setStatus('current')
if mibBuilder.loadTexts: snapshotSize.setDescription('The amount of storage space consumed by the snapshot in bytes.')
snapshotPath = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotPath.setStatus('current')
if mibBuilder.loadTexts: snapshotPath.setDescription('The path covered by the snapshot.')
snapshotAliasFor = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotAliasFor.setStatus('current')
if mibBuilder.loadTexts: snapshotAliasFor.setDescription('An alternate name for the snapshot.')
snapshotLocked = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 1, 13, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snapshotLocked.setStatus('current')
if mibBuilder.loadTexts: snapshotLocked.setDescription('Indicates if the snapshot is locked.')
nodeStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2, 1))
nodePerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2, 2))
nodeName = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeName.setStatus('current')
if mibBuilder.loadTexts: nodeName.setDescription('The hostname of the node.')
nodeHealth = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("attn", 1), ("down", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeHealth.setStatus('current')
if mibBuilder.loadTexts: nodeHealth.setDescription('The overall health of the node.')
nodeType = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("storage", 0), ("accelerator", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeType.setStatus('current')
if mibBuilder.loadTexts: nodeType.setDescription('The general type of the node.')
readOnly = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: readOnly.setStatus('current')
if mibBuilder.loadTexts: readOnly.setDescription('Indicates if this node in read-only mode.')
nodeIfsPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2, 2, 1))
nodeIfsInBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 1, 1), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfsInBytes.setStatus('current')
if mibBuilder.loadTexts: nodeIfsInBytes.setDescription('The number of bytes into /ifs through this node.')
nodeIfsInBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 1, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfsInBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: nodeIfsInBitsPerSecond.setDescription('The throughput rate (bytes per second) into /ifs through this node.')
nodeIfsOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 1, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfsOutBytes.setStatus('current')
if mibBuilder.loadTexts: nodeIfsOutBytes.setDescription('The number of bytes out of /ifs through this node.')
nodeIfsOutBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 1, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeIfsOutBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: nodeIfsOutBitsPerSecond.setDescription('The throughput rate (bytes per second) out of /ifs through this node.')
nodeNetworkPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2, 2, 2))
nodeNetworkInBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 2, 1), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNetworkInBytes.setStatus('obsolete')
if mibBuilder.loadTexts: nodeNetworkInBytes.setDescription("Total bytes into the node's external interfaces.\n        Obsolete.")
nodeNetworkInBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 2, 2), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNetworkInBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: nodeNetworkInBitsPerSecond.setDescription("The total input rate (bits per second) into the \n        node's external interfaces.")
nodeNetworkOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 2, 3), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNetworkOutBytes.setStatus('obsolete')
if mibBuilder.loadTexts: nodeNetworkOutBytes.setDescription("Total bytes out of the node's external interfaces.\n        Obsolete.")
nodeNetworkOutBitsPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 2, 4), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeNetworkOutBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: nodeNetworkOutBitsPerSecond.setDescription("The total output rate (bits per second) from the \n        node's external interfaces.")
nodeCPUPerf = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3))
nodeCPUUser = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCPUUser.setStatus('current')
if mibBuilder.loadTexts: nodeCPUUser.setDescription('Average amount of CPU (per mil) used by user processes\n        within the last 5 seconds for all CPUs.')
nodeCPUNice = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCPUNice.setStatus('current')
if mibBuilder.loadTexts: nodeCPUNice.setDescription('Average amount of CPU (per mil) used by nice processes\n        within the last 5 seconds for all CPUs.')
nodeCPUSystem = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCPUSystem.setStatus('current')
if mibBuilder.loadTexts: nodeCPUSystem.setDescription('Average amount of CPU (per mil) used by system processes\n        within the last 5 seconds for all CPUs.')
nodeCPUInterrupt = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCPUInterrupt.setStatus('current')
if mibBuilder.loadTexts: nodeCPUInterrupt.setDescription('Average amount of CPU (per mil) used by interrupts\n        within the last 5 seconds for all CPUs.')
nodeCPUIdle = MibScalar((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeCPUIdle.setStatus('current')
if mibBuilder.loadTexts: nodeCPUIdle.setDescription('Average amount of CPU (per mil) used by idle processes\n        within the last 5 seconds for all CPUs.')
nodeCPUPerfTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10), )
if mibBuilder.loadTexts: nodeCPUPerfTable.setStatus('current')
if mibBuilder.loadTexts: nodeCPUPerfTable.setDescription('Per CPU usage metrics.')
nodeCPUPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1), ).setIndexNames((0, "ISILON-MIB", "nodePerCPUID"))
if mibBuilder.loadTexts: nodeCPUPerfEntry.setStatus('current')
if mibBuilder.loadTexts: nodeCPUPerfEntry.setDescription('CPU usage metrics for one CPU/core.\n         ')
nodePerCPUUser = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePerCPUUser.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUUser.setDescription('Amount of CPU (per mil) used by user processes\n        within the last 5 seconds for the CPU.')
nodePerCPUNice = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePerCPUNice.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUNice.setDescription('Amount of CPU (per mil) used by nice processes\n        within the last 5 seconds for the CPU.')
nodePerCPUSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePerCPUSystem.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUSystem.setDescription('Amount of CPU (per mil) used by system processes\n        within the last 5 seconds for the CPU.')
nodePerCPUInterrupt = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePerCPUInterrupt.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUInterrupt.setDescription('Amount of CPU (per mil) used by interrupts\n        within the last 5 seconds for the CPU.')
nodePerCPUIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePerCPUIdle.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUIdle.setDescription('Amount of CPU (per mil) used by idle processes\n        within the last 5 seconds for the CPU.')
nodePerCPUID = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)))
if mibBuilder.loadTexts: nodePerCPUID.setStatus('current')
if mibBuilder.loadTexts: nodePerCPUID.setDescription('ID of the CPU.')
nodeProtocolPerfTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10), )
if mibBuilder.loadTexts: nodeProtocolPerfTable.setStatus('current')
if mibBuilder.loadTexts: nodeProtocolPerfTable.setDescription('Per-protocol performance metrics and statistics.')
nodeProtocolPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1), ).setIndexNames((1, "ISILON-MIB", "protocolName"))
if mibBuilder.loadTexts: nodeProtocolPerfEntry.setStatus('current')
if mibBuilder.loadTexts: nodeProtocolPerfEntry.setDescription('Basic protocol performance metrics and statistics.\n         Each row represents a protocol. The procotols\n         are: SMB1, SMB2, FTP, HTTP, NFS3, NFS4, NLM, SYNCIQ.\n         ')
protocolName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolName.setStatus('current')
if mibBuilder.loadTexts: protocolName.setDescription('The name of the protocol.')
protocolOpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolOpCount.setStatus('current')
if mibBuilder.loadTexts: protocolOpCount.setDescription('The total number of operations for the protocol.\n         ')
protocolOpsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolOpsPerSecond.setStatus('current')
if mibBuilder.loadTexts: protocolOpsPerSecond.setDescription('The number of operations per second for the last 5 second.')
inMinBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inMinBytes.setStatus('current')
if mibBuilder.loadTexts: inMinBytes.setDescription('The smallest input size in bytes of all operations for the protocol.')
inMaxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inMaxBytes.setStatus('current')
if mibBuilder.loadTexts: inMaxBytes.setDescription('The largest input size in bytes of all operations for the protocol.')
inAvgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inAvgBytes.setStatus('current')
if mibBuilder.loadTexts: inAvgBytes.setDescription('The average input size in bytes for all operations for the protocol.')
inStdDevBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inStdDevBytes.setStatus('current')
if mibBuilder.loadTexts: inStdDevBytes.setDescription('The standard deviation input size in bytes\n        for all operations for the protocol.')
inBitsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 8), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: inBitsPerSecond.setDescription('The input rate (bits per second) for the protocol.')
outMinBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outMinBytes.setStatus('current')
if mibBuilder.loadTexts: outMinBytes.setDescription('The smallest output size in bytes of all operations for the protocol.')
outMaxBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outMaxBytes.setStatus('current')
if mibBuilder.loadTexts: outMaxBytes.setDescription('The largest output size in bytes of all operations for the protocol.')
outAvgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outAvgBytes.setStatus('current')
if mibBuilder.loadTexts: outAvgBytes.setDescription('The average output size in bytes of all operations for the protocol.')
outStdDevBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outStdDevBytes.setStatus('current')
if mibBuilder.loadTexts: outStdDevBytes.setDescription('The standard deviation output size in bytes \n        for all operations for the protocol.')
outBitsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 13), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: outBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: outBitsPerSecond.setDescription('The output rate (bits per second)\n        for all operations for the protocol.')
latencyMin = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: latencyMin.setStatus('current')
if mibBuilder.loadTexts: latencyMin.setDescription('The minimum latency in microseconds\n        for all operations for the protocol.')
latencyMax = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: latencyMax.setStatus('current')
if mibBuilder.loadTexts: latencyMax.setDescription('The maximum latency in microseconds\n        for all operations for the protocol.')
latencyAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: latencyAverage.setStatus('current')
if mibBuilder.loadTexts: latencyAverage.setDescription('The average latency in microseconds\n        for all operations for the protocol.')
latencyStdDev = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 10, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: latencyStdDev.setStatus('current')
if mibBuilder.loadTexts: latencyStdDev.setDescription('The latency standard deviation in microseconds\n        for all operations for the protocol.')
diskPerfTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52), )
if mibBuilder.loadTexts: diskPerfTable.setStatus('current')
if mibBuilder.loadTexts: diskPerfTable.setDescription('Disk performance metrics and statistics.')
diskPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1), ).setIndexNames((0, "ISILON-MIB", "diskPerfBay"))
if mibBuilder.loadTexts: diskPerfEntry.setStatus('current')
if mibBuilder.loadTexts: diskPerfEntry.setDescription('Performance metrics and statistics for a disk.\n         Each row in the table represents a disk.')
diskPerfBay = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskPerfBay.setStatus('current')
if mibBuilder.loadTexts: diskPerfBay.setDescription('The bay that contains the disk.')
diskPerfDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskPerfDeviceName.setStatus('current')
if mibBuilder.loadTexts: diskPerfDeviceName.setDescription('The device name for this disk. This value\n        correspond to the diskBay column in the diskTable.')
diskPerfOpsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskPerfOpsPerSecond.setStatus('current')
if mibBuilder.loadTexts: diskPerfOpsPerSecond.setDescription('The number of disk operations per second.')
diskPerfInBitsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskPerfInBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: diskPerfInBitsPerSecond.setDescription('The input rate (bits per second) into this disk.')
diskPerfOutBitsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 2, 52, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskPerfOutBitsPerSecond.setStatus('current')
if mibBuilder.loadTexts: diskPerfOutBitsPerSecond.setDescription('The output rate (bits per second) from this disk.')
chassisTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 51), )
if mibBuilder.loadTexts: chassisTable.setStatus('current')
if mibBuilder.loadTexts: chassisTable.setDescription('A list of chassis that comprise the node.')
chassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1), ).setIndexNames((0, "ISILON-MIB", "chassisNumber"))
if mibBuilder.loadTexts: chassisEntry.setStatus('current')
if mibBuilder.loadTexts: chassisEntry.setDescription('A node chassis.')
chassisNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisNumber.setStatus('current')
if mibBuilder.loadTexts: chassisNumber.setDescription('A logical chassis number.')
chassisConfigNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisConfigNumber.setStatus('current')
if mibBuilder.loadTexts: chassisConfigNumber.setDescription('The chassis configuration number.')
chassisSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSerialNumber.setStatus('current')
if mibBuilder.loadTexts: chassisSerialNumber.setDescription('The chassis serial number.')
chassisModel = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisModel.setStatus('current')
if mibBuilder.loadTexts: chassisModel.setDescription('The chassis model name.')
chassisUnitIDLEDOn = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 51, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1))).clone(namedValues=NamedValues(("na", -1), ("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisUnitIDLEDOn.setStatus('current')
if mibBuilder.loadTexts: chassisUnitIDLEDOn.setDescription('Indicates if the unit ID light on the chassis is lighted.\n         This is the blue service light on the back of the chassis.\n         A value of NA indicates that no Unit ID LED exists \n         on the chassis.\n         ')
diskTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 52), )
if mibBuilder.loadTexts: diskTable.setStatus('current')
if mibBuilder.loadTexts: diskTable.setDescription('A list of disk state and properties for all disk in the node\n        including expansion chassis.')
diskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1), ).setIndexNames((0, "ISILON-MIB", "diskBay"))
if mibBuilder.loadTexts: diskEntry.setStatus('current')
if mibBuilder.loadTexts: diskEntry.setDescription('A disk.')
diskBay = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskBay.setStatus('current')
if mibBuilder.loadTexts: diskBay.setDescription('The bay that contains the disk.')
diskLogicalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskLogicalNumber.setStatus('current')
if mibBuilder.loadTexts: diskLogicalNumber.setDescription('The disk logical identification number.')
diskChassisNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskChassisNumber.setStatus('current')
if mibBuilder.loadTexts: diskChassisNumber.setDescription('The chassis which contains the disk.')
diskDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskDeviceName.setStatus('current')
if mibBuilder.loadTexts: diskDeviceName.setDescription('The device name for this disk.')
diskStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskStatus.setStatus('current')
if mibBuilder.loadTexts: diskStatus.setDescription('The operational status of the disk.\n        Gone drives are considered not part of /ifs.\n        Commonly returned values include (but not limited to):\n        HEALTHY - Drive is healthy\n        L3 - Drive is being used for L3 caching\n        DEAD - Drive is dead\n        SMARTFAIL - Drive is smartfailed')
diskModel = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskModel.setStatus('current')
if mibBuilder.loadTexts: diskModel.setDescription('The manufacture and model name of the disk.')
diskSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskSerialNumber.setStatus('current')
if mibBuilder.loadTexts: diskSerialNumber.setDescription('The serial number of the disk.')
diskFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: diskFirmwareVersion.setDescription('The firmware version installed on the disk.')
diskSizeBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 52, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: diskSizeBytes.setStatus('current')
if mibBuilder.loadTexts: diskSizeBytes.setDescription('The size of the disk in bytes.')
fanTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 53), )
if mibBuilder.loadTexts: fanTable.setStatus('current')
if mibBuilder.loadTexts: fanTable.setDescription('A table of fans in the node including expansion chassis.')
fanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 53, 1), ).setIndexNames((0, "ISILON-MIB", "fanNumber"))
if mibBuilder.loadTexts: fanEntry.setStatus('current')
if mibBuilder.loadTexts: fanEntry.setDescription('A fan.')
fanNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 53, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanNumber.setStatus('current')
if mibBuilder.loadTexts: fanNumber.setDescription('The unique identifer of the fan on this node.\n        Note: Numbers may correspond to different fans on different hardware.')
fanName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 53, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanName.setStatus('current')
if mibBuilder.loadTexts: fanName.setDescription('The name of the fan.')
fanDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 53, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanDescription.setStatus('current')
if mibBuilder.loadTexts: fanDescription.setDescription('The description of the fan.')
fanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 53, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanSpeed.setStatus('current')
if mibBuilder.loadTexts: fanSpeed.setDescription('The current speed of the fan in revolutions per minute.')
tempSensorTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 54), )
if mibBuilder.loadTexts: tempSensorTable.setStatus('current')
if mibBuilder.loadTexts: tempSensorTable.setDescription('A list of thermal sensors in the node including expansion chassis.')
tempSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 54, 1), ).setIndexNames((0, "ISILON-MIB", "tempSensorNumber"))
if mibBuilder.loadTexts: tempSensorEntry.setStatus('current')
if mibBuilder.loadTexts: tempSensorEntry.setDescription('A thermometer.')
tempSensorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 54, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorNumber.setStatus('current')
if mibBuilder.loadTexts: tempSensorNumber.setDescription('The unique identifier of the sensor on this node.')
tempSensorName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 54, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorName.setStatus('current')
if mibBuilder.loadTexts: tempSensorName.setDescription('The name of the temperature sensor.')
tempSensorDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 54, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorDescription.setStatus('current')
if mibBuilder.loadTexts: tempSensorDescription.setDescription('Description of the temperature sensor.')
tempSensorValue = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 54, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempSensorValue.setStatus('current')
if mibBuilder.loadTexts: tempSensorValue.setDescription('The cuurent reading of the temperature sensor in degrees celsius.')
powerSensorTable = MibTable((1, 3, 6, 1, 4, 1, 12124, 2, 55), )
if mibBuilder.loadTexts: powerSensorTable.setStatus('current')
if mibBuilder.loadTexts: powerSensorTable.setDescription('A list of all voltage and current sensors in the node\n        including expansion chassis.')
powerSensorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 12124, 2, 55, 1), ).setIndexNames((0, "ISILON-MIB", "powerSensorNumber"))
if mibBuilder.loadTexts: powerSensorEntry.setStatus('current')
if mibBuilder.loadTexts: powerSensorEntry.setDescription('A power sensor.')
powerSensorNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 55, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSensorNumber.setStatus('current')
if mibBuilder.loadTexts: powerSensorNumber.setDescription('The unique identifier of the sensor on this node.')
powerSensorName = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 55, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSensorName.setStatus('current')
if mibBuilder.loadTexts: powerSensorName.setDescription('The name of the sensor.')
powerSensorDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 55, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSensorDescription.setStatus('current')
if mibBuilder.loadTexts: powerSensorDescription.setDescription('The description of the sensor.')
powerSensorValue = MibTableColumn((1, 3, 6, 1, 4, 1, 12124, 2, 55, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSensorValue.setStatus('current')
if mibBuilder.loadTexts: powerSensorValue.setDescription('The current reading of the sensor in volts or amps.')
credentialBindings = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 4, 1))
clusterGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5, 1))
nodeGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5, 2))
clusterStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 1)).setObjects(("ISILON-MIB", "clusterName"), ("ISILON-MIB", "clusterHealth"), ("ISILON-MIB", "clusterGUID"), ("ISILON-MIB", "nodeCount"), ("ISILON-MIB", "configuredNodes"), ("ISILON-MIB", "onlineNodes"), ("ISILON-MIB", "offlineNodes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clusterStatusGroup = clusterStatusGroup.setStatus('current')
if mibBuilder.loadTexts: clusterStatusGroup.setDescription('A collection of objects that cover the status of a cluster.')
clusterPerformanceGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5, 1, 2))
clusterIfsPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 2, 1)).setObjects(("ISILON-MIB", "clusterIfsInBytes"), ("ISILON-MIB", "clusterIfsInBitsPerSecond"), ("ISILON-MIB", "clusterIfsOutBytes"), ("ISILON-MIB", "clusterIfsOutBitsPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clusterIfsPerfGroup = clusterIfsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: clusterIfsPerfGroup.setDescription('A collection of objects that cover the cluster IFS performance.')
clusterNetworkPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 2, 2)).setObjects(("ISILON-MIB", "clusterNetworkInBytes"), ("ISILON-MIB", "clusterNetworkInBitsPerSecond"), ("ISILON-MIB", "clusterNetworkOutBytes"), ("ISILON-MIB", "clusterNetworkOutBitsPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clusterNetworkPerfGroup = clusterNetworkPerfGroup.setStatus('current')
if mibBuilder.loadTexts: clusterNetworkPerfGroup.setDescription('A collection of objects that cover the cluster network performance.')
clusterCPUPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 2, 3)).setObjects(("ISILON-MIB", "clusterCPUUser"), ("ISILON-MIB", "clusterCPUNice"), ("ISILON-MIB", "clusterCPUSystem"), ("ISILON-MIB", "clusterCPUInterrupt"), ("ISILON-MIB", "clusterCPUIdlePct"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    clusterCPUPerfGroup = clusterCPUPerfGroup.setStatus('current')
if mibBuilder.loadTexts: clusterCPUPerfGroup.setDescription('A collection of objects that cover the CPU performance.')
ifsFilesystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 3)).setObjects(("ISILON-MIB", "ifsTotalBytes"), ("ISILON-MIB", "ifsUsedBytes"), ("ISILON-MIB", "ifsAvailableBytes"), ("ISILON-MIB", "ifsFreeBytes"), ("ISILON-MIB", "accessTimeEnabled"), ("ISILON-MIB", "accessTimeGracePeriod"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifsFilesystemGroup = ifsFilesystemGroup.setStatus('current')
if mibBuilder.loadTexts: ifsFilesystemGroup.setDescription('A collection of objects that cover the IFS filesystem.')
licensesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 5)).setObjects(("ISILON-MIB", "licenseModuleName"), ("ISILON-MIB", "licenseStatus"), ("ISILON-MIB", "licenseExpirationDate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    licensesGroup = licensesGroup.setStatus('current')
if mibBuilder.loadTexts: licensesGroup.setDescription('A collection of object that cover licenses.')
quotasGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 12)).setObjects(("ISILON-MIB", "quotaType"), ("ISILON-MIB", "quotaID"), ("ISILON-MIB", "quotaIncludesSnapshotUsage"), ("ISILON-MIB", "quotaPath"), ("ISILON-MIB", "quotaHardThresholdDefined"), ("ISILON-MIB", "quotaHardThreshold"), ("ISILON-MIB", "quotaSoftThresholdDefined"), ("ISILON-MIB", "quotaSoftThreshold"), ("ISILON-MIB", "quotaAdvisoryThresholdDefined"), ("ISILON-MIB", "quotaAdvisoryThreshold"), ("ISILON-MIB", "quotaGracePeriod"), ("ISILON-MIB", "quotaUsage"), ("ISILON-MIB", "quotaUsageWithOverhead"), ("ISILON-MIB", "quotaInodeUsage"), ("ISILON-MIB", "quotaIncludesOverhead"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    quotasGroup = quotasGroup.setStatus('current')
if mibBuilder.loadTexts: quotasGroup.setDescription('A collection of objects that cover quotas.')
snapshotsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5, 1, 13))
snapshotSettingsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 13, 1)).setObjects(("ISILON-MIB", "snapshotScheduledCreateEnabled"), ("ISILON-MIB", "snapshotScheduledDeleteEnabled"), ("ISILON-MIB", "snapshotReservedPct"), ("ISILON-MIB", "snapshotRootVisibilityNFS"), ("ISILON-MIB", "snapshotRootAccessNFS"), ("ISILON-MIB", "snapshotSubdirAccessNFS"), ("ISILON-MIB", "snapshotRootVisibilityCIFS"), ("ISILON-MIB", "snapshotRootAccessCIFS"), ("ISILON-MIB", "snapshotSubdirAccessCIFS"), ("ISILON-MIB", "snapshotRootVisibilityLocal"), ("ISILON-MIB", "snapshotRootAccessLocal"), ("ISILON-MIB", "snapshotSubdirAccessLocal"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snapshotSettingsGroup = snapshotSettingsGroup.setStatus('current')
if mibBuilder.loadTexts: snapshotSettingsGroup.setDescription('A collection of objects that covers snapshot settings.')
snapshotScheduleTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 13, 2)).setObjects(("ISILON-MIB", "snapshotScheduleIndex"), ("ISILON-MIB", "snapshotScheduleName"), ("ISILON-MIB", "snapshotScheduleAlias"), ("ISILON-MIB", "snapshotScheduleNamingPattern"), ("ISILON-MIB", "snapshotScheduleSchedule"), ("ISILON-MIB", "snapshotScheduleExpiration"), ("ISILON-MIB", "snapshotSchedulePath"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snapshotScheduleTableGroup = snapshotScheduleTableGroup.setStatus('current')
if mibBuilder.loadTexts: snapshotScheduleTableGroup.setDescription('A collection of objects that cover snapshot schedules.')
snapshotTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 1, 13, 3)).setObjects(("ISILON-MIB", "snapshotName"), ("ISILON-MIB", "snapshotCreated"), ("ISILON-MIB", "snapshotExpires"), ("ISILON-MIB", "snapshotSize"), ("ISILON-MIB", "snapshotPath"), ("ISILON-MIB", "snapshotAliasFor"), ("ISILON-MIB", "snapshotLocked"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snapshotTableGroup = snapshotTableGroup.setStatus('current')
if mibBuilder.loadTexts: snapshotTableGroup.setDescription('A collection of objects that covers the snapshots.')
nodeStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 1)).setObjects(("ISILON-MIB", "nodeName"), ("ISILON-MIB", "nodeHealth"), ("ISILON-MIB", "nodeType"), ("ISILON-MIB", "readOnly"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nodeStatusGroup = nodeStatusGroup.setStatus('current')
if mibBuilder.loadTexts: nodeStatusGroup.setDescription('A collection of objects that cover node status.')
nodePerformanceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2))
nodeIfsPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2, 1)).setObjects(("ISILON-MIB", "nodeIfsInBytes"), ("ISILON-MIB", "nodeIfsInBitsPerSecond"), ("ISILON-MIB", "nodeIfsOutBytes"), ("ISILON-MIB", "nodeIfsOutBitsPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nodeIfsPerfGroup = nodeIfsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: nodeIfsPerfGroup.setDescription('A collection of objects that cover node IFS performance.')
nodeNetworkPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2, 2)).setObjects(("ISILON-MIB", "nodeNetworkInBytes"), ("ISILON-MIB", "nodeNetworkInBitsPerSecond"), ("ISILON-MIB", "nodeNetworkOutBytes"), ("ISILON-MIB", "nodeNetworkOutBitsPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nodeNetworkPerfGroup = nodeNetworkPerfGroup.setStatus('current')
if mibBuilder.loadTexts: nodeNetworkPerfGroup.setDescription('A collection of objects that cover node network performance.')
nodeCPUPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2, 3)).setObjects(("ISILON-MIB", "nodeCPUUser"), ("ISILON-MIB", "nodeCPUNice"), ("ISILON-MIB", "nodeCPUSystem"), ("ISILON-MIB", "nodeCPUInterrupt"), ("ISILON-MIB", "nodeCPUIdle"), ("ISILON-MIB", "nodePerCPUUser"), ("ISILON-MIB", "nodePerCPUNice"), ("ISILON-MIB", "nodePerCPUSystem"), ("ISILON-MIB", "nodePerCPUInterrupt"), ("ISILON-MIB", "nodePerCPUIdle"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nodeCPUPerfGroup = nodeCPUPerfGroup.setStatus('current')
if mibBuilder.loadTexts: nodeCPUPerfGroup.setDescription('A collection of objects that cover node CPU performance.')
nodeProtocolPerfTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2, 10)).setObjects(("ISILON-MIB", "protocolName"), ("ISILON-MIB", "protocolOpCount"), ("ISILON-MIB", "protocolOpsPerSecond"), ("ISILON-MIB", "inMinBytes"), ("ISILON-MIB", "inMaxBytes"), ("ISILON-MIB", "inAvgBytes"), ("ISILON-MIB", "inStdDevBytes"), ("ISILON-MIB", "inBitsPerSecond"), ("ISILON-MIB", "outMinBytes"), ("ISILON-MIB", "outMaxBytes"), ("ISILON-MIB", "outAvgBytes"), ("ISILON-MIB", "outStdDevBytes"), ("ISILON-MIB", "outBitsPerSecond"), ("ISILON-MIB", "latencyMin"), ("ISILON-MIB", "latencyMax"), ("ISILON-MIB", "latencyAverage"), ("ISILON-MIB", "latencyStdDev"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nodeProtocolPerfTableGroup = nodeProtocolPerfTableGroup.setStatus('current')
if mibBuilder.loadTexts: nodeProtocolPerfTableGroup.setDescription('A collection of objects that cover protocol performance.')
diskPerfTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 2, 52)).setObjects(("ISILON-MIB", "diskPerfBay"), ("ISILON-MIB", "diskPerfDeviceName"), ("ISILON-MIB", "diskPerfOpsPerSecond"), ("ISILON-MIB", "diskPerfInBitsPerSecond"), ("ISILON-MIB", "diskPerfOutBitsPerSecond"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diskPerfTableGroup = diskPerfTableGroup.setStatus('current')
if mibBuilder.loadTexts: diskPerfTableGroup.setDescription('A collection of objects that cover disk performance.')
chassisTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 51)).setObjects(("ISILON-MIB", "chassisNumber"), ("ISILON-MIB", "chassisConfigNumber"), ("ISILON-MIB", "chassisSerialNumber"), ("ISILON-MIB", "chassisModel"), ("ISILON-MIB", "chassisUnitIDLEDOn"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    chassisTableGroup = chassisTableGroup.setStatus('current')
if mibBuilder.loadTexts: chassisTableGroup.setDescription('A collection of objects that cover chassis information.')
diskTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 52)).setObjects(("ISILON-MIB", "diskBay"), ("ISILON-MIB", "diskLogicalNumber"), ("ISILON-MIB", "diskChassisNumber"), ("ISILON-MIB", "diskDeviceName"), ("ISILON-MIB", "diskStatus"), ("ISILON-MIB", "diskModel"), ("ISILON-MIB", "diskSerialNumber"), ("ISILON-MIB", "diskFirmwareVersion"), ("ISILON-MIB", "diskSizeBytes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    diskTableGroup = diskTableGroup.setStatus('current')
if mibBuilder.loadTexts: diskTableGroup.setDescription('A collection of objects that cover disk information.')
fanTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 53)).setObjects(("ISILON-MIB", "fanNumber"), ("ISILON-MIB", "fanName"), ("ISILON-MIB", "fanDescription"), ("ISILON-MIB", "fanSpeed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fanTableGroup = fanTableGroup.setStatus('current')
if mibBuilder.loadTexts: fanTableGroup.setDescription('A collection of objects that cover fan information.')
tempSensorTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 54)).setObjects(("ISILON-MIB", "tempSensorNumber"), ("ISILON-MIB", "tempSensorName"), ("ISILON-MIB", "tempSensorDescription"), ("ISILON-MIB", "tempSensorValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tempSensorTableGroup = tempSensorTableGroup.setStatus('current')
if mibBuilder.loadTexts: tempSensorTableGroup.setDescription('A collection of objects that cover temperature sensor information.')
powerSensorTableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 12124, 5, 2, 55)).setObjects(("ISILON-MIB", "powerSensorNumber"), ("ISILON-MIB", "powerSensorName"), ("ISILON-MIB", "powerSensorDescription"), ("ISILON-MIB", "powerSensorValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    powerSensorTableGroup = powerSensorTableGroup.setStatus('current')
if mibBuilder.loadTexts: powerSensorTableGroup.setDescription('A collection of objects that cover power sensor information.')
isilonCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 12124, 5, 10)).setObjects(("ISILON-MIB", "clusterStatusGroup"), ("ISILON-MIB", "clusterIfsPerfGroup"), ("ISILON-MIB", "clusterNetworkPerfGroup"), ("ISILON-MIB", "clusterCPUPerfGroup"), ("ISILON-MIB", "ifsFilesystemGroup"), ("ISILON-MIB", "licensesGroup"), ("ISILON-MIB", "quotasGroup"), ("ISILON-MIB", "snapshotSettingsGroup"), ("ISILON-MIB", "snapshotScheduleTableGroup"), ("ISILON-MIB", "snapshotTableGroup"), ("ISILON-MIB", "nodeStatusGroup"), ("ISILON-MIB", "nodeIfsPerfGroup"), ("ISILON-MIB", "nodeNetworkPerfGroup"), ("ISILON-MIB", "nodeCPUPerfGroup"), ("ISILON-MIB", "nodeProtocolPerfTableGroup"), ("ISILON-MIB", "diskPerfTableGroup"), ("ISILON-MIB", "chassisTableGroup"), ("ISILON-MIB", "diskTableGroup"), ("ISILON-MIB", "fanTableGroup"), ("ISILON-MIB", "tempSensorTableGroup"), ("ISILON-MIB", "powerSensorTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    isilonCompliance = isilonCompliance.setStatus('current')
if mibBuilder.loadTexts: isilonCompliance.setDescription('The compliance statement for Isilon OneFS.')
mibBuilder.exportSymbols("ISILON-MIB", quotaID=quotaID, snapshotExpires=snapshotExpires, diskBay=diskBay, tempSensorDescription=tempSensorDescription, nodeType=nodeType, diskSizeBytes=diskSizeBytes, fanEntry=fanEntry, diskTable=diskTable, powerSensorValue=powerSensorValue, node=node, nodeCPUNice=nodeCPUNice, onlineNodes=onlineNodes, clusterName=clusterName, fanNumber=fanNumber, snapshotSettingsGroup=snapshotSettingsGroup, nodeCPUPerfTable=nodeCPUPerfTable, snapshotCreated=snapshotCreated, licenseExpirationDate=licenseExpirationDate, snapshotScheduleAlias=snapshotScheduleAlias, readOnly=readOnly, chassisModel=chassisModel, clusterCPUInterrupt=clusterCPUInterrupt, clusterPerformanceGroups=clusterPerformanceGroups, licenseTable=licenseTable, nodePerCPUID=nodePerCPUID, diskPerfEntry=diskPerfEntry, clusterCPUSystem=clusterCPUSystem, latencyMax=latencyMax, snapshotSubdirAccessCIFS=snapshotSubdirAccessCIFS, cluster=cluster, clusterNetworkOutBitsPerSecond=clusterNetworkOutBitsPerSecond, clusterHealth=clusterHealth, clusterNetworkPerf=clusterNetworkPerf, licenseStatus=licenseStatus, protocolName=protocolName, nodeNetworkPerfGroup=nodeNetworkPerfGroup, diskTableGroup=diskTableGroup, clusterGroups=clusterGroups, licenseIndex=licenseIndex, isilon=isilon, snapshotReservedPct=snapshotReservedPct, nodePerformance=nodePerformance, inAvgBytes=inAvgBytes, PYSNMP_MODULE_ID=isilon, fanName=fanName, outAvgBytes=outAvgBytes, chassisNumber=chassisNumber, clusterIfsOutBytes=clusterIfsOutBytes, diskPerfDeviceName=diskPerfDeviceName, snapshotRootAccessNFS=snapshotRootAccessNFS, snapshotSize=snapshotSize, diskDeviceName=diskDeviceName, nodeProtocolPerfTableGroup=nodeProtocolPerfTableGroup, licenseModuleName=licenseModuleName, snapshotScheduleTable=snapshotScheduleTable, nodeCPUUser=nodeCPUUser, clusterPerformance=clusterPerformance, nodeIfsInBitsPerSecond=nodeIfsInBitsPerSecond, nodeNetworkInBytes=nodeNetworkInBytes, quotaInodeUsage=quotaInodeUsage, nodeCount=nodeCount, quotaUsageWithOverhead=quotaUsageWithOverhead, nodePerCPUIdle=nodePerCPUIdle, tempSensorTableGroup=tempSensorTableGroup, clusterCPUIdlePct=clusterCPUIdlePct, conformance=conformance, chassisTableGroup=chassisTableGroup, quotaHardThresholdDefined=quotaHardThresholdDefined, snapshotSubdirAccessLocal=snapshotSubdirAccessLocal, diskPerfOpsPerSecond=diskPerfOpsPerSecond, nodeName=nodeName, inBitsPerSecond=inBitsPerSecond, nodePerCPUInterrupt=nodePerCPUInterrupt, powerSensorEntry=powerSensorEntry, nodeNetworkPerf=nodeNetworkPerf, nodeIfsInBytes=nodeIfsInBytes, diskEntry=diskEntry, diskFirmwareVersion=diskFirmwareVersion, fanTable=fanTable, ifsFreeBytes=ifsFreeBytes, outStdDevBytes=outStdDevBytes, licenses=licenses, snapshots=snapshots, snapshotScheduleSchedule=snapshotScheduleSchedule, quotaAdvisoryThresholdDefined=quotaAdvisoryThresholdDefined, latencyStdDev=latencyStdDev, diskChassisNumber=diskChassisNumber, outMaxBytes=outMaxBytes, nodeIfsOutBytes=nodeIfsOutBytes, snapshotScheduledDeleteEnabled=snapshotScheduledDeleteEnabled, nodeProtocolPerfTable=nodeProtocolPerfTable, inStdDevBytes=inStdDevBytes, diskLogicalNumber=diskLogicalNumber, nodeGroups=nodeGroups, quotaSoftThreshold=quotaSoftThreshold, snapshotRootAccessCIFS=snapshotRootAccessCIFS, quotaPath=quotaPath, snapshotName=snapshotName, chassisUnitIDLEDOn=chassisUnitIDLEDOn, snapshotScheduleEntry=snapshotScheduleEntry, clusterCPUUser=clusterCPUUser, clusterGUID=clusterGUID, snapshotPath=snapshotPath, nodeNetworkOutBitsPerSecond=nodeNetworkOutBitsPerSecond, inMaxBytes=inMaxBytes, snapshotSubdirAccessNFS=snapshotSubdirAccessNFS, outMinBytes=outMinBytes, licensesGroup=licensesGroup, snapshotScheduledCreateEnabled=snapshotScheduledCreateEnabled, nodeStatus=nodeStatus, nodeNetworkInBitsPerSecond=nodeNetworkInBitsPerSecond, fanTableGroup=fanTableGroup, chassisConfigNumber=chassisConfigNumber, quotaAdvisoryThreshold=quotaAdvisoryThreshold, quotaSoftThresholdDefined=quotaSoftThresholdDefined, nodeCPUPerf=nodeCPUPerf, protocolOpCount=protocolOpCount, snapshotScheduleIndex=snapshotScheduleIndex, snapshotRootVisibilityLocal=snapshotRootVisibilityLocal, chassisTable=chassisTable, credentialBindings=credentialBindings, powerSensorDescription=powerSensorDescription, local=local, tempSensorNumber=tempSensorNumber, snapshotRootVisibilityCIFS=snapshotRootVisibilityCIFS, nodePerCPUUser=nodePerCPUUser, nodeStatusGroup=nodeStatusGroup, outBitsPerSecond=outBitsPerSecond, snapshotTable=snapshotTable, nodeIfsPerf=nodeIfsPerf, quotaIncludesSnapshotUsage=quotaIncludesSnapshotUsage, clusterStatus=clusterStatus, nodePerformanceGroup=nodePerformanceGroup, quotasGroup=quotasGroup, offlineNodes=offlineNodes, clusterIfsInBytes=clusterIfsInBytes, snapshotSchedulePath=snapshotSchedulePath, clusterNetworkOutBytes=clusterNetworkOutBytes, nodeHealth=nodeHealth, latencyMin=latencyMin, nodePerCPUSystem=nodePerCPUSystem, clusterNetworkPerfGroup=clusterNetworkPerfGroup, ifsUsedBytes=ifsUsedBytes, chassisSerialNumber=chassisSerialNumber, snapshotTableGroup=snapshotTableGroup, accessTimeGracePeriod=accessTimeGracePeriod, clusterIfsInBitsPerSecond=clusterIfsInBitsPerSecond, powerSensorNumber=powerSensorNumber, quotaType=quotaType, snapshotSettings=snapshotSettings, snapshotRootVisibilityNFS=snapshotRootVisibilityNFS, snapshotScheduleExpiration=snapshotScheduleExpiration, clusterNetworkInBitsPerSecond=clusterNetworkInBitsPerSecond, protocolOpsPerSecond=protocolOpsPerSecond, diskPerfBay=diskPerfBay, nodeCPUPerfGroup=nodeCPUPerfGroup, quotaGracePeriod=quotaGracePeriod, nodeProtocolPerfEntry=nodeProtocolPerfEntry, nodeIfsPerfGroup=nodeIfsPerfGroup, diskPerfInBitsPerSecond=diskPerfInBitsPerSecond, snapshotIndex=snapshotIndex, diskPerfOutBitsPerSecond=diskPerfOutBitsPerSecond, powerSensorName=powerSensorName, nodeIfsOutBitsPerSecond=nodeIfsOutBitsPerSecond, chassisEntry=chassisEntry, ifsAvailableBytes=ifsAvailableBytes, tempSensorValue=tempSensorValue, diskPerfTableGroup=diskPerfTableGroup, isilonCompliance=isilonCompliance, fanDescription=fanDescription, nodePerCPUNice=nodePerCPUNice, quotaIncludesOverhead=quotaIncludesOverhead, tempSensorTable=tempSensorTable, snapshotScheduleTableGroup=snapshotScheduleTableGroup, snapshotScheduleNamingPattern=snapshotScheduleNamingPattern, clusterCPUPerfGroup=clusterCPUPerfGroup, clusterCPUPerf=clusterCPUPerf, snapshotScheduleName=snapshotScheduleName, ifsFilesystemGroup=ifsFilesystemGroup, fanSpeed=fanSpeed, tempSensorName=tempSensorName, latencyAverage=latencyAverage, snapshotsGroup=snapshotsGroup, quotas=quotas, powerSensorTable=powerSensorTable, licenseEntry=licenseEntry, nodeNetworkOutBytes=nodeNetworkOutBytes, clusterIfsPerf=clusterIfsPerf, snapshotEntry=snapshotEntry, powerSensorTableGroup=powerSensorTableGroup, nodeCPUPerfEntry=nodeCPUPerfEntry, accessTimeEnabled=accessTimeEnabled, quotaHardThreshold=quotaHardThreshold, quotaTable=quotaTable, inMinBytes=inMinBytes, ifsTotalBytes=ifsTotalBytes, nodeCPUInterrupt=nodeCPUInterrupt, clusterIfsPerfGroup=clusterIfsPerfGroup, quotaDomainID=quotaDomainID, clusterStatusGroup=clusterStatusGroup, tempSensorEntry=tempSensorEntry, nodeCPUSystem=nodeCPUSystem, diskStatus=diskStatus, nodeCPUIdle=nodeCPUIdle, diskPerfTable=diskPerfTable, clusterIfsOutBitsPerSecond=clusterIfsOutBitsPerSecond, ifsFilesystem=ifsFilesystem, clusterNetworkInBytes=clusterNetworkInBytes, clusterCPUNice=clusterCPUNice, quotaUsage=quotaUsage, snapshotRootAccessLocal=snapshotRootAccessLocal, snapshotLocked=snapshotLocked, snapshotAliasFor=snapshotAliasFor, configuredNodes=configuredNodes, diskSerialNumber=diskSerialNumber, diskModel=diskModel, quotaEntry=quotaEntry)
