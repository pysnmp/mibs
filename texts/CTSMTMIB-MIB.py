#
# PySNMP MIB module CTSMTMIB-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTSMTMIB-MIB
# Produced by pysmi-1.1.12 at Tue May 28 12:11:55 2024
# On host fv-az1567-4 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
ctsmtmib, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctsmtmib")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Bits, Gauge32, iso, Counter64, ModuleIdentity, ObjectIdentity, MibIdentifier, IpAddress, Unsigned32, Integer32, Counter32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Bits", "Gauge32", "iso", "Counter64", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "IpAddress", "Unsigned32", "Integer32", "Counter32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ctsmtmibRingTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1), )
if mibBuilder.loadTexts: ctsmtmibRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingTable.setDescription('A list of fddi nodes found on the ring.')
ctsmtmibRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibRingSmtIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingMacIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingNodeIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibRingMacAddr"))
if mibBuilder.loadTexts: ctsmtmibRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingEntry.setDescription('A fddi ring entry containing information common to all\n                  stations in a token path.')
ctsmtmibRingSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingSmtIndex.setDescription('The value of the SMT index associated with this ring.')
ctsmtmibRingMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacIndex.setDescription('A unique value for each MAC within a given SMT.')
ctsmtmibRingNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNodeIndex.setDescription('The index of the node on the ring in reverse token\n                  flow order. It is sequential from 1 to n where n is\n                  the number of nodes on the ring at a given time.')
ctsmtmibRingMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacAddr.setDescription('A canonical representation of the MAC address of the\n                  node.')
ctsmtmibRingUpStreamAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingUpStreamAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingUpStreamAddr.setDescription("This is a canonical representation of the upstream\n                  neighbor's address. The upstream neighbor is the last\n                  MAC to receive the token before this MAC. Unknown\n                  addresses should be specified as 00-00-F8-00-00-00.")
ctsmtmibRingNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("station", 1), ("concentrator", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNodeClass.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNodeClass.setDescription('Reports if the node is a station or a concentrator.')
ctsmtmibRingMacCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMacCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMacCount.setDescription('The number of MACs on this FDDI node.')
ctsmtmibRingNonMasterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingNonMasterCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingNonMasterCount.setDescription('The sum of all A ports, B ports, and S ports on this\n                  node.')
ctsmtmibRingMasterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingMasterCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingMasterCount.setDescription('The number of master ports on this node.')
ctsmtmibRingTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingTopology.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingTopology.setDescription("A bit mapped representation of the current state of\n                  the node.\n                  if state:                Add 2**n where n =\n                  Wrapped Node                    0\n                  Unattached Concentrator         1\n                  A-A Twisted Ring                2\n                  B-B Twisted Ring                3\n                  Rooted Station                  4\n                  SRF Supported                   5\n\n                  where\n                    Wrapped Node: is set when the node's cf-state is\n                                  Wrap-A,  Wrap-B, Wrap-C, or Wrap-AB.\n                    Unattached Concentrator: is set when a concentrator\n                                  has no active A, B, or S ports.\n                    A-A Twisted Ring: is set when this node's A port is\n                                  connected to another A port.\n                    B-B Twisted Ring: is set when this node's B port is\n                                  connected to another B port.\n                    Rooted Station: is a station with ports A, B and S,\n                                  not active in tree mode.\n                    SRF Supported: This node adheres to the status\n                                  reporting frame protocol.")
ctsmtmibRingDuplicate = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibRingDuplicate.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibRingDuplicate.setDescription("A bit mapped representation of duplicate address\n                  information.\n\n                  if State:                 Add 2**n where n=\n                  My Duplicate:                     0\n                  UNA Duplicate:                    1\n\n                  where\n                     My Duplicate: This node determines that it's MAC\n                        address is same as the MAC address for another\n                        node on the ring.\n                     UNA Duplicate: The upstream neighbor of this node\n                        has determined that its's MAC address is same as\n                        the MAC address for another node on the ring.")
ctsmtmibMacTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2), )
if mibBuilder.loadTexts: ctsmtmibMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacTable.setDescription('A list of MAC entries. The total number of entries is\n                  given by the value of ctsmtmibRingMacCount with appropriate\n                  ctsmtmibRingMacAddr.')
ctsmtmibMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibMacSmtIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibMacIndex"))
if mibBuilder.loadTexts: ctsmtmibMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEntry.setDescription('A MAC entry containing information pertaining to a\n                  given MAC.')
ctsmtmibMacSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSmtIndex.setDescription('The value of the SMT Index associated with this MAC.')
ctsmtmibMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacIndex.setDescription('A unique value for each MAC within a given SMT.')
ctsmtmibMacNifTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacNifTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacNifTxCts.setDescription('The count of Neighborhood Information frames\n                  transmitted by the MAC.')
ctsmtmibMacNifRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacNifRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacNifRxCts.setDescription('The count of Neighborhood Information frames received\n                  by the MAC.')
ctsmtmibMacSifTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSifTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSifTxCts.setDescription('The count of Status Information frames transmitted by\n                  the MAC.')
ctsmtmibMacSifRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacSifRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacSifRxCts.setDescription('The count of Status Information Frames received by\n                  the MAC.')
ctsmtmibMacEcfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacEcfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEcfTxCts.setDescription('The count of Echo Frames transmitted by the MAC.')
ctsmtmibMacEcfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacEcfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacEcfRxCts.setDescription('The count of Echo Frames received by the MAC.')
ctsmtmibMacPmfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacPmfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacPmfTxCts.setDescription('The count of Parameter Management Frames transmitted\n                  by the MAC.')
ctsmtmibMacPmfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacPmfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacPmfRxCts.setDescription('The count of Parameter Management Frames received by\n                  the MAC.')
ctsmtmibMacRdfTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRdfTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRdfTxCts.setDescription('The count of Request Denied Frames transmitted by the\n                  MAC.')
ctsmtmibMacRdfRxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRdfRxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRdfRxCts.setDescription('The count of Request Denied Frames received by the MAC.')
ctsmtmibMacRingOpCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRingOpCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRingOpCts.setDescription("The count of the number of times the ring has entered\n                  'Ring Operational' state from the 'Ring Not Operational'\n                  state.")
ctsmtmibMacTxCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacTxCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacTxCts.setDescription('A count that should as closely as possible match the\n                  number of frames transmitted by this MAC.')
ctsmtmibMacRingMapUpdateCts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibMacRingMapUpdateCts.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacRingMapUpdateCts.setDescription('The count of the number of times the ring map table has\n                  been updated.')
ctsmtmibMacAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibMacAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibMacAutoNegotiation.setDescription('Indicates whether the station has auto-negotiation\n                  enabled or disabled.')
ctsmtmibAttachmentNumber = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentNumber.setDescription("The total number of attachments (across all SMTs) on\n                  this network management application entity. The value\n                  for this variable must remain constant at least from\n                  one re-initialization of the entity's network\n                  management system to the next re-initialization.")
ctsmtmibAttachmentTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4), )
if mibBuilder.loadTexts: ctsmtmibAttachmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentTable.setDescription('A list of Attachment entries. The number of entries is\n                  given by the value of fdmimAttachmentNumber.')
ctsmtmibAttachmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibAttachmentSMTIndex"), (0, "CTSMTMIB-MIB", "ctsmtmibAttachmentIndex"))
if mibBuilder.loadTexts: ctsmtmibAttachmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentEntry.setDescription("An Attachment entry containing information common to a\n                  given set of Attachments.\n\n                  There is a natural association of Attachment resource\n                  indices to the PORT Indices. The resource index for\n                  the Attachment is equal to the associated port index\n                  for 'single-attachment' and 'concentrator' type\n                  fdmimAttachmentClasses. For 'dual-attachment' classes,\n                  the Attachment Index is the PORT Index of the A PORT\n                  of the A/B PORT pair that represents the Attachment.")
ctsmtmibAttachmentSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentSMTIndex.setDescription('The value of the SMT index associated with this\n                  Attachment.')
ctsmtmibAttachmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentIndex.setDescription('A unique value for each Attachment on a given SMT. ')
ctsmtmibAttachmentClass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("single-attachment", 1), ("dual-attachment", 2), ("concentrator", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentClass.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentClass.setDescription('The Attachment class. This represents a PORT or a pair\n                  of PORTs plus the associated optional optical bypass\n                  that are managed as a functional unit. The PORT\n                  associations are the following unit.\n                         single-attachment - S Ports\n                         dual-attachment   - A/B Port pairs\n                         concentrator      - M Ports\n                 ')
ctsmtmibAttachmentOpticalBypassPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentOpticalBypassPresent.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentOpticalBypassPresent.setDescription("The value of this is false for 'single-attachment' .\n                  Correct operation of CMT for single-attachments\n                  requires that a bypass function must not loopback the\n                  network side of the MIC, but only the node side.")
ctsmtmibAttachmentIMaxExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentIMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentIMaxExpiration.setDescription('I_Max (refer to ANSI SMT 9.4.4.2.1). Systems not\n                  implementing optical bypass should return a value of\n                  0. Else the value should be returned in the granularity\n                  of 80ns.')
ctsmtmibAttachmentInsertedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertedStatus.setDescription('Indicates whether the attachment is currently inserted\n                  in the node.')
ctsmtmibAttachmentInsertPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unimplemented", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibAttachmentInsertPolicy.setDescription('Indicates the Insert Policy for this Attachment.')
ctsmtmibSMTTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5), )
if mibBuilder.loadTexts: ctsmtmibSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTTable.setDescription('Describes the dual homed status for SMT entries.')
ctsmtmibSMTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1), ).setIndexNames((0, "CTSMTMIB-MIB", "ctsmtmibSmtIndex"))
if mibBuilder.loadTexts: ctsmtmibSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTEntry.setDescription('A specific dual homed SMT entry.')
ctsmtmibSMTDualHomeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notDualHomed", 1), ("linkAorB", 2), ("linkAandB", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeStatus.setDescription('Indicates the current dual homed link status for a given\n                SMT instance.\n                        notDualHomed(1) - This SMT is not dual homed.\n                        linkAorB(2) - Dual homed with link on A and no link\n                                      link on B, or link on B and no link\n                                      on A.\n                        linkAandB(3) - Dual homed with link on A and B.')
ctsmtmibSMTDualHomeWrpLEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeWrpLEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSMTDualHomeWrpLEDStatus.setDescription('When on, the WRAP LED will be illuminated when\n                the node is in a dual homed configuration with link on the\n                A, B or both A and B ports. When off, the WRAP LED will not\n                be illuminated when the node is in a dual homed\n                configuration with link on A and B, but will be illuminated\n                when in a dual homed configuration with no link on A or B.')
ctsmtmibSmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctsmtmibSmtIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctsmtmibSmtIndex.setDescription('Specifies the particular SMT entry.')
mibBuilder.exportSymbols("CTSMTMIB-MIB", ctsmtmibAttachmentEntry=ctsmtmibAttachmentEntry, ctsmtmibAttachmentTable=ctsmtmibAttachmentTable, ctsmtmibRingNodeIndex=ctsmtmibRingNodeIndex, ctsmtmibRingMacCount=ctsmtmibRingMacCount, ctsmtmibRingMasterCount=ctsmtmibRingMasterCount, ctsmtmibMacEcfRxCts=ctsmtmibMacEcfRxCts, ctsmtmibMacSifRxCts=ctsmtmibMacSifRxCts, ctsmtmibAttachmentSMTIndex=ctsmtmibAttachmentSMTIndex, ctsmtmibAttachmentClass=ctsmtmibAttachmentClass, ctsmtmibMacEntry=ctsmtmibMacEntry, ctsmtmibAttachmentIMaxExpiration=ctsmtmibAttachmentIMaxExpiration, ctsmtmibSMTTable=ctsmtmibSMTTable, ctsmtmibRingDuplicate=ctsmtmibRingDuplicate, ctsmtmibMacSmtIndex=ctsmtmibMacSmtIndex, ctsmtmibRingMacIndex=ctsmtmibRingMacIndex, ctsmtmibMacEcfTxCts=ctsmtmibMacEcfTxCts, ctsmtmibSMTDualHomeWrpLEDStatus=ctsmtmibSMTDualHomeWrpLEDStatus, ctsmtmibMacIndex=ctsmtmibMacIndex, ctsmtmibRingNonMasterCount=ctsmtmibRingNonMasterCount, ctsmtmibMacPmfTxCts=ctsmtmibMacPmfTxCts, ctsmtmibRingEntry=ctsmtmibRingEntry, ctsmtmibMacNifTxCts=ctsmtmibMacNifTxCts, ctsmtmibRingMacAddr=ctsmtmibRingMacAddr, ctsmtmibRingNodeClass=ctsmtmibRingNodeClass, ctsmtmibMacRingOpCts=ctsmtmibMacRingOpCts, ctsmtmibMacRingMapUpdateCts=ctsmtmibMacRingMapUpdateCts, ctsmtmibMacTxCts=ctsmtmibMacTxCts, ctsmtmibSmtIndex=ctsmtmibSmtIndex, ctsmtmibMacRdfRxCts=ctsmtmibMacRdfRxCts, ctsmtmibMacSifTxCts=ctsmtmibMacSifTxCts, ctsmtmibAttachmentNumber=ctsmtmibAttachmentNumber, ctsmtmibRingUpStreamAddr=ctsmtmibRingUpStreamAddr, ctsmtmibAttachmentIndex=ctsmtmibAttachmentIndex, ctsmtmibMacPmfRxCts=ctsmtmibMacPmfRxCts, ctsmtmibAttachmentInsertedStatus=ctsmtmibAttachmentInsertedStatus, ctsmtmibMacNifRxCts=ctsmtmibMacNifRxCts, ctsmtmibRingTable=ctsmtmibRingTable, ctsmtmibSMTDualHomeStatus=ctsmtmibSMTDualHomeStatus, ctsmtmibAttachmentOpticalBypassPresent=ctsmtmibAttachmentOpticalBypassPresent, ctsmtmibRingTopology=ctsmtmibRingTopology, ctsmtmibRingSmtIndex=ctsmtmibRingSmtIndex, ctsmtmibMacAutoNegotiation=ctsmtmibMacAutoNegotiation, ctsmtmibAttachmentInsertPolicy=ctsmtmibAttachmentInsertPolicy, ctsmtmibSMTEntry=ctsmtmibSMTEntry, ctsmtmibMacRdfTxCts=ctsmtmibMacRdfTxCts, ctsmtmibMacTable=ctsmtmibMacTable)
