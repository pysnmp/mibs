#
# PySNMP MIB module RADWARE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radware/RADWARE-MIB
# Produced by pysmi-1.1.12 at Fri Jul 19 08:59:51 2024
# On host fv-az1149-759 platform Linux version 6.5.0-1023-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
ipAddrEntry, = mibBuilder.importSymbols("IP-MIB", "ipAddrEntry")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
enterprises, ObjectIdentity, Bits, IpAddress, TimeTicks, Unsigned32, iso, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType, Integer32, NotificationType, ModuleIdentity, Counter32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "ObjectIdentity", "Bits", "IpAddress", "TimeTicks", "Unsigned32", "iso", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType", "Integer32", "NotificationType", "ModuleIdentity", "Counter32", "Counter64")
TextualConvention, DisplayString, TimeStamp, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TimeStamp", "PhysAddress")
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class RowStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))

class FeatureStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enable", 1), ("disable", 2))

class NetNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class BitFlag(Integer32):
    pass

class VrId(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 255)

class RouteTag(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

rnd = MibIdentifier((1, 3, 6, 1, 4, 1, 89))
rndMng = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 1))
rndSysId = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 62))).clone(namedValues=NamedValues(("reb", 1), ("ceb", 2), ("ceblb", 3), ("xeb", 4), ("xeb1", 5), ("rebsx", 6), ("rtb", 7), ("ltb", 8), ("lte", 9), ("iprouter", 10), ("ielb", 11), ("leb", 12), ("openGate12", 13), ("openGate4", 14), ("ran", 15), ("itlb", 16), ("gatelinx", 17), ("openGate2", 18), ("ogRanTR", 19), ("stc", 20), ("ftc", 21), ("armon", 22), ("fccs1004", 23), ("fccs1012", 24), ("rdapter", 25), ("ogvan", 26), ("wanGate", 27), ("ogRubE", 28), ("ogRubT", 29), ("elX", 30), ("vGate4", 31), ("mrt", 32), ("ogSrubET", 33), ("vanXS", 34), ("lre", 35), ("vGate2", 36), ("serverDispatcher4", 37), ("serverDispatcher2", 38), ("vGate2Fast", 39), ("serverDispatcher2Fast", 40), ("prt", 41), ("mlm", 42), ("prt11", 43), ("quickOffice", 44), ("apollo", 45), ("radware", 62)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndSysId.setStatus('mandatory')
if mibBuilder.loadTexts: rndSysId.setDescription('Identification of an RND device. The device type for each\n      integer clarifies the sysObjectID in MIB - II.')
rndAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("reset", 1), ("sendNetworkTab", 2), ("deleteNetworkTab", 3), ("sendRoutingTab", 4), ("deleteRoutingTab", 5), ("sendLanTab", 6), ("deleteLanTab", 7), ("deleteArpTab", 8), ("sendArpTab", 9), ("deleteRouteTab", 10), ("sendRouteTab", 11), ("backupSPFRoutingTab", 12), ("backupIPRoutingTab", 13), ("backupNetworkTab", 14), ("backupLanTab", 15), ("backupArpTab", 16), ("backupIPXRipTab", 17), ("backupIPXSAPTab", 18), ("resetCDB", 19), ("eraseCDB", 20), ("deleteZeroHopRoutingAllocTab", 21), ("shutdown", 22)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndAction.setStatus('mandatory')
if mibBuilder.loadTexts: rndAction.setDescription('This variable enables the operator to perform one of the\n      specified actions on the tables maintained by the network device.\n      Send actions require support of proprietery File exchange\n      protocol.')
rndFileName = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFileName.setStatus('mandatory')
if mibBuilder.loadTexts: rndFileName.setDescription('The name of the file used internally by RND for transferring\n      tables maintained by network devices, using a prorietary File\n      exchange protocol.')
removeViewTablePermissionReductionCheck = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 0))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: removeViewTablePermissionReductionCheck.setStatus('mandatory')
if mibBuilder.loadTexts: removeViewTablePermissionReductionCheck.setDescription("This is a True/False variable that determines whether the\n\t    user is able to change his own view permissions (originally it\n\t    wasn't allowed in order to prevent situations of permission reduction).\n\t    added for Fortis.")
rsConfigurationAuditStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsConfigurationAuditStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsConfigurationAuditStatus.setDescription('Enable/Disable audit notifications.')
rsConfigurationAuditingType = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("regular", 1), ("extended", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsConfigurationAuditingType.setStatus('mandatory')
if mibBuilder.loadTexts: rsConfigurationAuditingType.setDescription('Sets audit notifications type.')
rndDeviceParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2))
rndBridgeType = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48))).clone(namedValues=NamedValues(("reb", 1), ("ceb", 2), ("ceblb", 3), ("xeb", 4), ("xeb1", 5), ("rebsx", 6), ("rtb", 7), ("ltb", 8), ("tre", 9), ("rtre", 10), ("xtb", 11), ("ete", 12), ("rete", 13), ("ielb", 30), ("leb", 31), ("openGate12", 32), ("openGate4", 33), ("ran", 34), ("itlb", 35), ("gatelinx", 36), ("openGate2", 37), ("ogRanTR", 38), ("rdapter", 39), ("ogVan", 40), ("wanGate", 41), ("ogRubE", 42), ("ogRubT", 43), ("wanGateI", 44), ("vGate4", 45), ("lre", 46), ("mrt", 47), ("vGate2", 48)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBridgeType.setStatus('mandatory')
if mibBuilder.loadTexts: rndBridgeType.setDescription('Identification of the RND bridge type.')
rndInactiveArpTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndInactiveArpTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rndInactiveArpTimeOut.setDescription('This variable defines the maximum time period that can pass\n       between ARP requests concerning an entry in the ARP table.\n       After this time period, the entry is deleted from the table.')
rndBridgeAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 3))
rndErrorDesc = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndErrorDesc.setStatus('mandatory')
if mibBuilder.loadTexts: rndErrorDesc.setDescription('A textual description of the enterprise-specific trap sent\n        to the Network Management Station by the RND managed device.')
rndErrorSeverity = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndErrorSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: rndErrorSeverity.setDescription('The severity type of the enterprise-specific trap sent to the\n      Network Management Station by the RND managed device.')
rndBrgVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBrgVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgVersion.setDescription('The application software version.')
rndBrgFeatures = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndBrgFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgFeatures.setDescription('A bit mask that defines the features supported by a particular configuration\n       of this network element:\n       __________________________________________\n       |  Byte 1|Byte 2 |Byte 3 | ....|Byte 20  |\n       |87654321|                     | 87654321|\n       |________|_______________________________|\n\n Byte1 :\n      bit1: TX Block mask\n      bit2: Source Routing Encapulation\n      bit3: SNA/SDLC\n      bit4: Frame Relay\n      bit5: SNMP\n      bit6: LAN Manager\n      bit7: High Performance\n      bit8: Translation\n Byte2 :\n      bit1: DEC Router\n      bit2: IPX Router\n      bit3: IP  Router\n Byte3 :\n      bit1: Dial Up Backup\n      bit2: COD\n      bit3: FACS\n      bit4: Load Balance\n      bit5: Remote Configuration\n      bit6: RIP 2\n      bit7: OSPF\n      bit8: IPX RIP/SAP Filter\n Byte4 :\n      bit1: BootP Server\n      bit2: BootP Client\n      bit3: Compression\n      bit4: V25.bis\n      bit5: ISDN\n      bit6: CODv2\n      bit7: NSPF\n      bit8: UDP Relay\n\n Byte5\n      bit1:VirtualLAN\n      bit2:Static IP Multicast\n      bit3:IP Redundancy\n      bit4:CCM2\n      bit5:ISDN Bonding\n      bit6:Backup Link Selection -- for the  VAN/Rdapter ver 4.0\n      bit7:IP/IPX Forwarding     -- for the  WANgate ver 4.0\n      bit8:Improved COD\n\n Byte6\n      bit1: Server Disptacher\n      bit2: ISDN_US               -- for the  VANSX/WANGATE ver 5.0\n      bit3: PPP\n      bit4: IP Rip Filter       -- for Vgate3\n      bit5: Zero Hop Routing    -- for Vgate3\n      bit6: ISDN Japan\n\n Byte7\n     bit1: With unmanaged Switch\n     bit2: 2 LANs\n     bit3: OSPF Ver 2.0\n     bit4: FACS Ver 2.0\n     bit5: Multiple WEB Farm\n     bit6: Backup Server')
rndBrgLicense = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBrgLicense.setStatus('mandatory')
if mibBuilder.loadTexts: rndBrgLicense.setDescription('This parameter is used for entering a s/w license number for a device.\n        A separate license number is supplied for each device.')
rndIpHost = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 7))
rndICMPTransmitionEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndICMPTransmitionEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rndICMPTransmitionEnable.setDescription('This variable controlls the ability to transmit ICMP frames')
rndCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 89, 2, 7, 2), )
if mibBuilder.loadTexts: rndCommunityTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityTable.setDescription('The community table of the agent')
rndCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rndCommunityMngStationAddr"), (1, "RADWARE-MIB", "rndCommunityString"))
if mibBuilder.loadTexts: rndCommunityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityEntry.setDescription(' The row definition for this table.')
rndCommunityMngStationAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityMngStationAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityMngStationAddr.setDescription('The management station that will be allowed to\n    communicate with the agent IP address')
rndCommunityString = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityString.setDescription('The community string with which the management\n     station will communicate with the agent')
rndCommunityAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2), ("super", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityAccess.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityAccess.setDescription('The allowed access to this management station')
rndCommunityTrapsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapsEnable", 1), ("trapsDisable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityTrapsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityTrapsEnable.setDescription('Should the agent send traps to the management station')
rndCommunityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 2, 7, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndCommunityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndCommunityStatus.setDescription('The status of this entry. If the status is invalid the\n    community entry will be deleted')
rndManagedTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndManagedTime.setStatus('mandatory')
if mibBuilder.loadTexts: rndManagedTime.setDescription('The time will be sent in the format hhmmss')
rndManagedDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndManagedDate.setStatus('mandatory')
if mibBuilder.loadTexts: rndManagedDate.setDescription('The date will be sent in the format ddmmyyyy')
genGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 2, 11))
genGroupHWVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWVersion.setDescription('Defines the HW version of the product.')
genGroupConfigurationSymbol = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupConfigurationSymbol.setDescription('Defines the Configuration Symbol attached to any hardware module\n      manufactured by LANNET. One single character A..Z defines the CS\n      version.')
genGroupHWStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("ok", 1), ("hardwareProblems", 2), ("notSupported", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: genGroupHWStatus.setStatus('mandatory')
if mibBuilder.loadTexts: genGroupHWStatus.setDescription('This attribute describes the status of the group hardware as detected\n      by the sensors software.')
rndSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rndSerialNumber.setDescription("The device's serial number. This parameter is sent with the device configuration but will\n     not be set when the configuration is uploaded to the device.")
rndApsoluteOSVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndApsoluteOSVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rndApsoluteOSVersion.setDescription('The ApsoluteOS version.')
rdwrDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceType.setDescription('The Device Type.')
rdwrDeviceNumberOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceNumberOfPorts.setDescription('The Device Number of Ports.')
rdwrDevicePortsConfig = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDevicePortsConfig.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDevicePortsConfig.setDescription('The Device Ports Configuration.')
rdwrDeviceThroughput = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceThroughput.setDescription('The Device Throughput.')
rdwrDeviceNetworkDriver = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceNetworkDriver.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceNetworkDriver.setDescription('The Device Network Driver.')
rdwrDeviceCPUsNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceCPUsNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceCPUsNumber.setDescription("The Device number of CPU's.")
rdwrDeviceActiveBoot = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceActiveBoot.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceActiveBoot.setDescription('The Device Active Boot.')
rdwrDeviceSecondaryBoot = MibScalar((1, 3, 6, 1, 4, 1, 89, 2, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDeviceSecondaryBoot.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDeviceSecondaryBoot.setDescription('The Device Secondary Boot.')
rndInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 4))
rndIfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 4, 1), )
if mibBuilder.loadTexts: rndIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfTable.setDescription('RND-specific interface table.  Each table entry includes an\n      index, Board number, Network Address, interface status, clock\n      indicator and interface cost.')
rndIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 4, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rndIfIndex"))
if mibBuilder.loadTexts: rndIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfEntry.setDescription(' The row definition for this table.')
rndIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfIndex.setDescription('Index to the RND Interface Table. The interface defined by a\n     particular value of this index is the same interface as\n     identified by the same value of ifIndex (MIBII).')
rndIfBoardNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfBoardNum.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfBoardNum.setDescription('The interface defined by this entry correspTnds to the board\n     defined by the same value of rndSlotBoardNum in the rndSlotTab.')
rndIfNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfNetAddress.setDescription('The IP address of the interface defined by the particular value of\n     rndIfIndex.')
rndIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ok", 1), ("okSingleBrg", 2), ("okMultiBrg", 3), ("connctFault", 4), ("rxFault", 5), ("txFault", 6), ("channelLoopback", 7), ("rxClockFault", 8), ("t1Alarm", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfStatus.setDescription('The current status of the interface.')
rndIfClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("t1", 3), ("g703", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfClockType.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfClockType.setDescription('rndIfClockType defines the type of clock each interface\n     uses: internal or external.')
rndIfBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfBaudRate.setDescription(' Defines the baud rate of use by the interface. The valid\n      rates are determined by the type of the media for which this\n      baud rate is defined.')
rndIfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfCost.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfCost.setDescription('This variable assigns a transmission cost to the interface\n        (channel or LAN). These costs are used in Level II routing. The\n        costs aretypically inversly proportional to the channel quality.')
rndIfCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfCompression.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfCompression.setDescription('Defines whether data compression is enabled or disabled for the\n       interface.')
rndIfCompressionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-inserted", 1), ("active", 2), ("not-active", 3), ("disable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfCompressionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfCompressionStatus.setDescription('Defines the status of the compression component:\n        not-inserted - Compression component is not in the device\n        active -     Compression is enabled and operates correctly\n        not-active - Compression is enables but does not operate.\n                     The reason may be that there is no compression\n                     component on the device connected to this interface.\n        disabled   - Compression was disabled by management, using\n                     variable rndCompression.')
rndIfCompressionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfCompressionRate.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfCompressionRate.setDescription('Percentage of compression. This variable applies only\n  if rndCompressionStatus is active.')
rndIfLATCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfLATCompression.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfLATCompression.setDescription('Enable/Disable the LAT Compression.')
rndIfCompressionType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lowSpeed", 2), ("highSpeed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndIfCompressionType.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfCompressionType.setDescription('This parameter indicates the type of compression option available in the device.\n         none(1)     - indicates that there is no compression option in the device\n         lowSpeed(2) - indicates a compression option which is  operational up\n                       to line speed sof 64 kbps.\n         highSpeed(3)- indicates a compression option which is  operational up\n                       to line speeds of 2 Mbps.')
rndIfFilterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("destinationOnly", 1), ("sourceAndDestination", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfFilterMode.setDescription('This parameter indicates the type of filtering in the device. ')
rndIfChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("wanChannel", 1), ("ogRanPort", 2), ("routerToBridge", 3), ("spsFramRelay", 4), ("dialBackup", 5), ("snar", 6), ("lan", 7), ("spsX25", 8), ("frameRelay1490", 9), ("frameRelay1490CAR", 10), ("frameRelayCAR", 11), ("ppp", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfChannelType.setDescription(' The type of the WAN channel ')
rndIfBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndIfBridge.setStatus('mandatory')
if mibBuilder.loadTexts: rndIfBridge.setDescription(' This variable indicates  whether this interface forward Layer II pakages.')
rndHighPriorityIf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndHighPriorityIf.setStatus('mandatory')
if mibBuilder.loadTexts: rndHighPriorityIf.setDescription(' This variable indicates  whether this interface will forward pakages\n        that fit HighPriority set by the manager.')
rndWanHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("regular", 1), ("short", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndWanHeader.setStatus('mandatory')
if mibBuilder.loadTexts: rndWanHeader.setDescription(" This variable indicates the RND WAN header type used for frames\n          which pass through this interface. 'regular' specifies a 14 bytes\n          header compatible with older OG versions and 'short' a 4 byte header\n          compatible with the RND adapter product family.")
rndDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 4, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndDuplexMode.setStatus('mandatory')
if mibBuilder.loadTexts: rndDuplexMode.setDescription(' This variable indicates whether this interface operates in half duplex\n          full duplex or auto negotiation mode.')
rndIPX = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 12))
rndFACS = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 16))
rndFACSDefaultAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 16, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 129))).clone(namedValues=NamedValues(("block", 1), ("forward", 2), ("enable", 3), ("disable", 4), ("blockAndReport", 129))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSDefaultAction.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSDefaultAction.setDescription('Used to define the default action for the device, when no\n                FACS statements applicable to a given frame are defined.')
rndFACSActTable = MibTable((1, 3, 6, 1, 4, 1, 89, 16, 2), )
if mibBuilder.loadTexts: rndFACSActTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSActTable.setDescription('The table of  FACS action.')
rndFACSActEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 16, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rndFACSActType"), (0, "RADWARE-MIB", "rndFACSActIfIndex"))
if mibBuilder.loadTexts: rndFACSActEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSActEntry.setDescription('Each rndFACSActEntry consist of the following parameters')
rndFACSActType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2), ("activeDB", 4), ("tempDB", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSActType.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSActType.setDescription('This parameter indicate on which FACS Table the FACS\n                 action will preform.')
rndFACSActIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSActIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSActIfIndex.setDescription('The interface to which this FACS entry is applicable.')
rndFACSAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 13))).clone(namedValues=NamedValues(("none", 1), ("eraseIP", 2), ("eraseDECnet", 3), ("eraseIPX", 4), ("eraseBrg", 5), ("replaceIP", 6), ("replaceIPX", 8), ("replaceBrg", 9), ("backupIP", 10), ("backupIPX", 12), ("backupBrg", 13))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSAction.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSAction.setDescription('The management station that sends a SET request for one of these actions\n                with indexes  rndFACSType and rndFACSIfIndex defines the type and the\n                interface  Id for which all FACS statements are to be erased.\n                If no interface or no type  is specified, all FACS statements for a\n                protocol are erased.')
rndFACSTable = MibTable((1, 3, 6, 1, 4, 1, 89, 16, 3), )
if mibBuilder.loadTexts: rndFACSTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSTable.setDescription('The table of  FACS statment.')
rndFACSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 16, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rndFACSIfIndex"), (0, "RADWARE-MIB", "rndFACSProtocolType"), (0, "RADWARE-MIB", "rndFACSType"), (0, "RADWARE-MIB", "rndFACSIndex"))
if mibBuilder.loadTexts: rndFACSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSEntry.setDescription('Each FACS statment consist of the following parameters')
rndFACSIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSIfIndex.setDescription('The interface to which this FACS entry is applicable.')
rndFACSProtocolType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ip", 1), ("ipx", 2), ("dec", 3), ("bridge", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSProtocolType.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSProtocolType.setDescription('This parameter define the protocol the Security  Access Control\n                is applicable.')
rndFACSType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("tx", 1), ("rx", 2), ("cod", 3), ("activeDB", 4), ("tempDB", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSType.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSType.setDescription(' The Mode of in which this FACS statement operates.')
rndFACSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndFACSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSIndex.setDescription('Index to the FACS  Table. ')
rndFACSSrcAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSSrcAdd.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSSrcAdd.setDescription('The size of the octet string will be according to the protocol type define in\n          rndFACSProtocolType.')
rndFACSSrcAddMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSSrcAddMask.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSSrcAddMask.setDescription('Source-address mask .')
rndFACSDesAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSDesAdd.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSDesAdd.setDescription('Destination-address The size of the octet string will be according to the\n           protocol type define in rndFACSProtocolType .')
rndFACSDesAddMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSDesAddMask.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSDesAddMask.setDescription('Destination-address mask .')
rndFACSOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 129))).clone(namedValues=NamedValues(("block", 1), ("forward", 2), ("permit", 3), ("deny", 4), ("blockZHRP", 5), ("blockAndReport", 129)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSOperation.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSOperation.setDescription('... .')
rndFACSNetFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("l2multicast", 2), ("arp", 3), ("icmp", 4), ("ip", 5), ("udp", 6), ("tcp", 7), ("decnet", 8), ("ipx", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSNetFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSNetFiltering.setDescription('... .')
rndFACSSoketNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSSoketNum.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSSoketNum.setDescription(' Port/socket  number for different applications\n              0 is default meaning not applicable.')
rndFACSMask1Id = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSMask1Id.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSMask1Id.setDescription(' Index into RND mask table FACS/COD Type) .')
rndFACSMask2Id = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSMask2Id.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSMask2Id.setDescription(' Index into RND mask table FACS/COD according to\n       the value of rndFACSType .')
rndFACSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 16, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndFACSStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndFACSStatus.setDescription('The status of a table entry.')
rndBootP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 24))
rndBootPServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 24, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBootPServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rndBootPServerAddress.setDescription(' The IPAddress of the BOOTP server. the OpenGate will act as a BootP relay if\n       this parameter is not equale to 0.0.0.0.')
rndBootPRelaySecThreshold = MibScalar((1, 3, 6, 1, 4, 1, 89, 24, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndBootPRelaySecThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rndBootPRelaySecThreshold.setDescription('BootP requests are relayed only if their SEC field is greater or\n        equal to the threshold value in order to allow local BootP Servers\n        to answer first.')
ipSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26))
rsIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 1), )
if mibBuilder.loadTexts: rsIpAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAddrTable.setDescription('This table is parralel to MIB II IpAddrTable, and is used to\n        add/delete entries to/from that table. In addition it contains\n        private objects.')
rsIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpAdEntAddr"))
if mibBuilder.loadTexts: rsIpAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAddrEntry.setDescription("The addressing information for one of this\n            entity's IP addresses.")
rsIpAdEntAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpAdEntAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntAddr.setDescription("The IP address to which this entry's addressing\n            information pertains.")
rsIpAdEntIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntIfIndex.setDescription('The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.')
rsIpAdEntNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntNetMask.setDescription('The subnet mask associated with the IP address of\n            this entry.  The value of the mask is an IP\n            address with all the network bits set to 1 and all\n            the hosts bits set to 0.')
rsIpAdEntForwardIpBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntForwardIpBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntForwardIpBroadcast.setDescription(' This variable controls forwarding of IP (sub)net-directed\n          broadcasts destined for an attached sub(net). ')
rsIpAdEntReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpAdEntReasmMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntReasmMaxSize.setDescription('The size of the largest IP datagram which this\n          entity can re-assemble from incoming IP fragmented\n          datagrams received on this interface.')
rsIpAdEntStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntStatus.setDescription(' The validity of this entry. Invalid indicates that this entry is\n          invalid in IpAddrTable (MIB II).')
rsIpAdEntBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntBcastAddr.setDescription(' Indicates how the host part of ip subnet broadcast messages will be\n          filled:\n           0 - host part will be filled by 0\n           1 - host part will be filled by 1.')
rsIpAdEntVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntVlanTag.setDescription('The vlan Tag value that represent this ip interface\n             this filed include both vlna tag and vlan priority ')
rsIpAdEntOneIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntOneIpMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntOneIpMode.setDescription('the one-ip mode. Relevant only for LinkProof devices.\n\t\tdisable - regular interface. Enable - the specific ip can be ip-to-me (to device) \n\t\tand/or forwarding ip')
rsIpAdEntType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("pppoe", 3), ("pptp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpAdEntType.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntType.setDescription('Ip interface type. The way the ip-interface was set determine its type')
rsIpAdEntPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntPeerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntPeerAddr.setDescription('IP of same interface on the peer device.')
rsIpAdEntPeerAddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("relevant", 1), ("nonrelevant", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntPeerAddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpAdEntPeerAddrStatus.setDescription('Indicating the relevancy of PeerAddr for this row')
icmpSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 2))
rsIcmpGenErrMsgEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpGenErrMsgEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpGenErrMsgEnable.setDescription('This variable controlls the ability to generate ICMP error messages')
rsIcmpRdTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 2, 2), )
if mibBuilder.loadTexts: rsIcmpRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdTable.setDescription('This table contains ICMP Router Discovery parameters\n        configurated per IP interface.')
rsIcmpRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIcmpRdIpAddr"))
if mibBuilder.loadTexts: rsIcmpRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdEntry.setDescription('The ICMP parameters configurated for IP interface.')
rsIcmpRdIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIcmpRdIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdIpAddr.setDescription("The IP address to which this entry's information pertains.")
rsIcmpRdIpAdvertAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 2), IpAddress().clone(hexValue="E0000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdIpAdvertAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdIpAdvertAddr.setDescription(' The IP destination address to be used for multicast\n              Router Advertisements sent from the interface. The\n              only permissible values are the all-systems multicast\n              address, 224.0.0.1, or the limited-broadcast address,\n              255.255.255.255.')
rsIcmpRdMaxAdvertInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdMaxAdvertInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdMaxAdvertInterval.setDescription('The maximum time allowed between sending multicast\n             Router Advertisements from the interface, in seconds.\n             Must be no less than 4 seconds and no greater than 1800\n             seconds.')
rsIcmpRdMinAdvertInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdMinAdvertInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdMinAdvertInterval.setDescription('The minimum time allowed between sending unsolicited\n             multicast Router Advertisements from the interface, in\n             seconds.  Must be no less than 3 seconds and no greater\n             than rsIcmpRdMaxAdvertInterval.\n             Default: 0.75 * rsIcmpRdMaxAdvertInterval.')
rsIcmpRdAdvertLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 9000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdAdvertLifetime.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdAdvertLifetime.setDescription('The maximum length of time that the advertised addresses\n             are to be considered as valid. Must be no less than\n             rsIcmpRdMaxAdvertInterval and no greater than 9000 seconds.\n             Default: 3 * rsIcmpRdMaxAdvertInterval.')
rsIcmpRdAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdAdvertise.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdAdvertise.setDescription('A flag indicating whether or not the address is to be\n              advertised.')
rsIcmpRdPreferenceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdPreferenceLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdPreferenceLevel.setDescription('The preferability of the address as a default router\n             address, relative to other router addresses on the same\n             subnet.')
rsIcmpRdEntStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdEntStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIcmpRdEntStatus.setDescription('Setting of any value to this object set values of\n             all fields to the default values.')
rip2Spec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 3))
rsRip2IfConfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 3, 1), )
if mibBuilder.loadTexts: rsRip2IfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsRip2IfConfTable.setDescription('This table is extension of rip2IfConfTable (RFC 1389 ,RIP 2)')
rsRip2IfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 3, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsRip2IfConfAddress"))
if mibBuilder.loadTexts: rsRip2IfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsRip2IfConfEntry.setDescription(' ')
rsRip2IfConfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsRip2IfConfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsRip2IfConfAddress.setDescription(' The IP Address of this system on the indicated subnet. ')
rsRip2IfConfVirtualDis = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 1, 1, 2), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRip2IfConfVirtualDis.setStatus('mandatory')
if mibBuilder.loadTexts: rsRip2IfConfVirtualDis.setDescription('This variable defines the virtual number of hops assigned to\n          the interface specified by rsIfIpAddrIndex. This enables\n          fine-tuning of the RIP routing algorithm.')
rsRip2IfConfAutoSend = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRip2IfConfAutoSend.setStatus('mandatory')
if mibBuilder.loadTexts: rsRip2IfConfAutoSend.setDescription('This variable controls RIP automatic send behavior. If enabled\n          and no routers were heard on the interface, RIP will only send\n          default route with high metric. Otherwise RIP will send updates\n          according to configuration. ')
rdwrRip2IfConfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 3, 2), )
if mibBuilder.loadTexts: rdwrRip2IfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfTable.setDescription('A list of subnets which require separate configuration in RIP. \n\t\tThis is a combination of rip2IfConfTable and rsRip2IfConfTable.')
rdwrRip2IfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrRip2IfConfAddress"))
if mibBuilder.loadTexts: rdwrRip2IfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfEntry.setDescription('A Single Routing Domain in a single Subnet.')
rdwrRip2IfConfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRip2IfConfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfAddress.setDescription('The IP Address of this system on the indicated\n        subnet.  For unnumbered interfaces, the value 0.0.0.N,\n        where the least significant 24 bits (N) is the ifIndex\n        for the IP Interface in network byte order.')
rdwrRip2IfConfDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 2), RouteTag()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfDomain.setStatus('deprecated')
if mibBuilder.loadTexts: rdwrRip2IfConfDomain.setDescription('Value inserted into the Routing Domain field\n        of all RIP packets sent on this interface.')
rdwrRip2IfConfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAuthentication", 1), ("simplePassword", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfAuthType.setDescription('The type of Authentication used on this\n        interface.')
rdwrRip2IfConfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfAuthKey.setDescription('The value to be used as the Authentication Key\n        whenever the corresponding instance of\n        rip2IfConfAuthType has the value simplePassword\n        word.  A modification of the corresponding\n        instance of rip2IfConfAuthType does not modify\n        the rip2IfConfAuthKey value.  If a string shorter\n        than 16 octets is supplied, it will be left-\n        justified and padded to 16 octets, on the right,\n        with nulls (0x00).\n        Reading this object always results in an  OCTET\n        STRING of length zero; authentication may not\n        be bypassed by reading the MIB object.')
rdwrRip2IfConfSend = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4), ("ripV1Demand", 5), ("ripV2Demand", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfSend.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfSend.setDescription('What the router sends on this interface.\n        ripVersion1 implies sending RIP updates compliant\n        with  RFC  1058.   rip1Compatible implies\n        broadcasting RIP-2 updates using RFC 1058 route\n        subsumption rules.  ripVersion2 implies\n        multicasting RIP-2 updates.  ripV1Demand indicates\n        the use of Demand RIP on a WAN interface under RIP\n        Version 1 rules.  ripV2Demand indicates the use of\n        Demand RIP on a WAN interface under Version 2 rules.')
rdwrRip2IfConfReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3), ("doNotRecieve", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfReceive.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfReceive.setDescription('This indicates which version of RIP updates\n        are to be accepted.  Note that rip2 and\n        rip1OrRip2 implies reception of multicast\n        packets.')
rdwrRip2IfConfDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfDefaultMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfDefaultMetric.setDescription('This variable indicates the metric that is to\n        be used for the default route entry in RIP updates\n        originated on this interface.  A value of zero\n        indicates that no default route should be\n        originated; in this case, a default route via\n        another router may be propagated.')
rdwrRip2IfConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfStatus.setDescription('Writing invalid has  the  effect  of  deleting\n        this interface.')
rdwrRip2IfConfSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfSrcAddress.setDescription('The IP Address this system will use as a source\n        address on this interface.  If it is a numbered\n        interface, this MUST be the same value as\n        rip2IfConfAddress.  On unnumbered interfaces,\n        it must be the value of rip2IfConfAddress for\n        some interface on the system.')
rdwrRip2IfConfVirtualDis = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 10), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfVirtualDis.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfVirtualDis.setDescription('This variable defines the virtual number of hops assigned to\n          the interface specified by rsIfIpAddrIndex. This enables\n          fine-tuning of the RIP routing algorithm.')
rdwrRip2IfConfAutoSend = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRip2IfConfAutoSend.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRip2IfConfAutoSend.setDescription('This variable controls RIP automatic send behavior. If enabled\n          and no routers were heard on the interface, RIP will only send\n          default route with high metric. Otherwise RIP will send updates\n          according to configuration. ')
arpSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 4))
rsArpDeleteTable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpDeleteTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsArpDeleteTable.setDescription('Setting this object to any not-null value has the effect of deleting\n          all entries of the ARP table.')
rsArpInactiveTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 2), Integer32().clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpInactiveTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rsArpInactiveTimeOut.setDescription('This variable defines the maximum time period (in second) that can\n          pass between ARP requests concerning an entry in the ARP table.\n          After this time period, the entry is deleted from the table.')
rsArpProxy = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpProxy.setStatus('mandatory')
if mibBuilder.loadTexts: rsArpProxy.setDescription('When ARP Proxy is enabled, the router can respond to\n          ARP requests for nodes located on a different sub-net,\n          provided they are it its network table. The router responds\n          with its own MAC address.\n          When ARP Proxy is disabled, the router responds only\n          to ARP requests for its own IP addresses.')
tftp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 5))
rsTftpRetryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 1), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTftpRetryTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rsTftpRetryTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
rsTftpTotalTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 2), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTftpTotalTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rsTftpTotalTimeOut.setDescription(' Total Retransmission time-out value (seconds) ')
rsSendConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSendConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: rsSendConfigFile.setDescription('The file name include path where the Router Server will put the full\n         configuration. The default destination address will be the sender\n         address.')
rsGetConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: rsGetConfigFile.setDescription('The file name include path where the Router Server will get the\n         configuration. The default source address will be the sender address.')
rsLoadSoftware = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLoadSoftware.setStatus('mandatory')
if mibBuilder.loadTexts: rsLoadSoftware.setDescription('The file name include path where the Router Server will get the\n         software. The source address will the sender address.')
rsFileServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFileServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsFileServerAddress.setDescription('The IP address of the configuration / sw server.')
rsGetConfigFileAppend = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigFileAppend.setStatus('mandatory')
if mibBuilder.loadTexts: rsGetConfigFileAppend.setDescription('The file name include path where the Router Server will get the\n         configuration commands file. The default source address will be the sender address.')
rsGetConfigFileAppendReboot = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigFileAppendReboot.setStatus('mandatory')
if mibBuilder.loadTexts: rsGetConfigFileAppendReboot.setDescription('The file name include path where the Router Server will get the\n         configuration commands file. The default source address will be the sender address.')
rsGetConfigErrorLog = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigErrorLog.setStatus('mandatory')
if mibBuilder.loadTexts: rsGetConfigErrorLog.setDescription('The file name include path where the Router Server will get the\n         configuration. The default source address will be the sender address.')
rsSendConfigFileBer = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSendConfigFileBer.setStatus('mandatory')
if mibBuilder.loadTexts: rsSendConfigFileBer.setDescription('The file name include path where the device puts the full configuration\n\tin BER format. The default destination address will be the sender address.')
rsIncludePrivateKeys = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 12), FeatureStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIncludePrivateKeys.setStatus('mandatory')
if mibBuilder.loadTexts: rsIncludePrivateKeys.setDescription('Flags whether the configuration will include private keys.')
rsGetConfigFileType = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("regular", 0), ("active-active", 1), ("active-backup", 2), ("for-peer", 3))).clone('regular')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigFileType.setStatus('mandatory')
if mibBuilder.loadTexts: rsGetConfigFileType.setDescription('Type of configuration to be downloaded.')
ipRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 6))
ipRedundAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("vrrp", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRedundAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundAdminStatus.setDescription('This variable controls the IP Redundancy method in the device.\n      In case the value is enable, it means the ARP redundancy mechanism\n      is running .If the value is vrrp, it means the former redundancy\n      mechanism is disabled, and the vrrp mechanism is enabled.\n      If the value is disable, both redundancy methods are disabled  ')
ipRedundOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRedundOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundOperStatus.setDescription(' obsolete ')
ipRedundRoutersTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 6, 3), )
if mibBuilder.loadTexts: ipRedundRoutersTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersTable.setDescription('List of IP addresses backed up by this router.')
ipRedundRoutersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "ipRedundRoutersIfAddr"), (0, "RADWARE-MIB", "ipRedundRoutersMainRouterAddr"))
if mibBuilder.loadTexts: ipRedundRoutersEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersEntry.setDescription(' The row definition for this table.')
ipRedundRoutersIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRedundRoutersIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersIfAddr.setDescription('The Ip address of the IP interface on which the redundancy feature\n     is operational.')
ipRedundRoutersMainRouterAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRedundRoutersMainRouterAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersMainRouterAddr.setDescription('The Ip address of the polled main router.')
ipRedundRoutersOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipRedundRoutersOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersOperStatus.setDescription('If active, the main router is considered inoperational and the IP\n    interface operates as its backup.')
ipRedundRoutersPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 4), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRedundRoutersPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersPollInterval.setDescription('Polling interval for this router (in seconds). If 0 the router is not\n     polled.')
ipRedundRoutersTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 5), Integer32().clone(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRedundRoutersTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersTimeout.setDescription('Interval in seconds during which the backed-up router must signal.\n     If it does not signal, it is considered inoperational and the IP\n     interface starts operating as backup.')
ipRedundRoutersStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipRedundRoutersStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipRedundRoutersStatus.setDescription('Entry status')
rdwrRedunForceDownPorts = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 6, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrRedunForceDownPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedunForceDownPorts.setDescription('the time that the forced ports will be electrically down. The value 0 means that the feature is disabled')
rdwrRedundancyInfoTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 6, 5), )
if mibBuilder.loadTexts: rdwrRedundancyInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoTable.setDescription('Row holding the device redundancy information.')
rdwrRedundancyInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrRedundancyInfoIdx"))
if mibBuilder.loadTexts: rdwrRedundancyInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoEntry.setDescription('Row definition for the table.')
rdwrRedundancyInfoIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoIdx.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoIdx.setDescription('The entry index. Starting from 1')
rdwrRedundancyInfoInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoInterface.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoInterface.setDescription('The entry attached interface')
rdwrRedundancyInfoVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoVRID.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoVRID.setDescription('Supporting VRRP, the entry indicates the entry VRID')
rdwrRedundancyInfoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("arp", 1), ("not-used", 2), ("vrrp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoMode.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoMode.setDescription('This variable indicates the IP Redundancy method in the device')
rdwrRedundancyInfoMyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoMyAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoMyAddress.setDescription('The entry indicates the device interfece address')
rdwrRedundancyInfoNeighborAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoNeighborAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoNeighborAddress.setDescription('Acting as backup, the entry indicates the master associated address ')
rdwrRedundancyInfoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 6, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("backup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrRedundancyInfoStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrRedundancyInfoStatus.setDescription('The redundancy entry status ')
ipRouteLeaking = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 7))
ipLeakStaticToRip = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakStaticToRip.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakStaticToRip.setDescription('This parameter controls leaking (redistribution) of static routes\n         to RIP. When enabled, all routes inserted to the IP routing table\n         via SNMP are advertised into RIP.')
ipLeakStaticToOspf = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakStaticToOspf.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakStaticToOspf.setDescription('This parameter controls leaking (redistribution) of static routes\n         into OSPF. When enabled, all routes inserted to the IP routing table\n         via SNMP are advertised into OSPF as external routes.')
ipLeakOspfToRip = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakOspfToRip.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakOspfToRip.setDescription('This parameter controls leaking (redistribution) of routes\n         from OSPF to RIP. If enabled, all routes learned via OSPF\n         are advertised into RIP.')
ipLeakRipToOspf = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakRipToOspf.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakRipToOspf.setDescription('This parameter controls leaking (redistribution) of routes\n         from RIP to OSPF. If enabled, all routes learned via RIP\n         are advertised into OSPF as external routes.')
ipLeakExtDirectToOspf = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakExtDirectToOspf.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakExtDirectToOspf.setDescription('This parameter controls leaking (redistribution) into OSPF of\n         direct routes external to OSPF, i.e. routes to local network\n         corresponding to IP interfaces on which OSPF is disabled.\n         When enabled, all such direct routes are advertised into OSPF\n         as external routes.')
ipLeakOverrideOSPFLeakonFailure = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakOverrideOSPFLeakonFailure.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakOverrideOSPFLeakonFailure.setDescription("In case of OSPF:\n\tdon't advertise the device as next hop router in case all load balanced devices are down.")
ipLeakAdvertiseOSPFAccordingtoPortRules = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLeakAdvertiseOSPFAccordingtoPortRules.setStatus('mandatory')
if mibBuilder.loadTexts: ipLeakAdvertiseOSPFAccordingtoPortRules.setDescription('in OPSF: advertise routing according to the port rules')
ipRipFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 8))
rsIpRipFilterGlbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 8, 1), )
if mibBuilder.loadTexts: rsIpRipFilterGlbTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbTable.setDescription('The table of RIP global filters per IP router.')
rsIpRipFilterGlbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpRipFilterGlbType"), (0, "RADWARE-MIB", "rsIpRipFilterGlbNumber"))
if mibBuilder.loadTexts: rsIpRipFilterGlbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbEntry.setDescription(' An entry in the RIP global filter table ')
rsIpRipFilterGlbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("input", 1), ("output", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpRipFilterGlbType.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbType.setDescription(' Type of filter - input/output ')
rsIpRipFilterGlbNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpRipFilterGlbNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbNumber.setDescription(' Number of RIP filter. ')
rsIpRipFilterGlbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("underCreation", 3))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterGlbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbStatus.setDescription(' The validity of this entry. Setting this value to invalid deletes\n   the entry, and the entry may be actualy removed from the table.')
rsIpRipFilterGlbIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterGlbIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbIpAddr.setDescription(' network prefix IP address, as in the forwarding table. ')
rsIpRipFilterGlbNetworkMaskBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterGlbNetworkMaskBits.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbNetworkMaskBits.setDescription(' the number of bits in the IP Network mask, called network-prefix-length\n   in Router Requirements terminology. for example: the value 16 means\n   mask 255.255.0.0 ')
rsIpRipFilterGlbMatchBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 6), Integer32().clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterGlbMatchBits.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbMatchBits.setDescription(' the number of bits to match in the Network IP address. A value\n   smaller than 32 defines a wildcard. for example: the value 8 means\n   all routes whose leftmost 8 bits are equal to those of the network IP\n   address. If this variable has a value other than 32, than\n   rsIpRipFilterGlbNetworkMaskBits must be 0 and is ignored. ')
rsIpRipFilterGlbAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2))).clone('permit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterGlbAction.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterGlbAction.setDescription(' Filter action - permit/deny for this network')
rsIpRipFilterLclTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 8, 2), )
if mibBuilder.loadTexts: rsIpRipFilterLclTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclTable.setDescription('Table of input/output  RIP filters used per IP Interface.')
rsIpRipFilterLclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpRipFilterLclIpIntf"), (0, "RADWARE-MIB", "rsIpRipFilterLclType"), (0, "RADWARE-MIB", "rsIpRipFilterLclNumber"))
if mibBuilder.loadTexts: rsIpRipFilterLclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclEntry.setDescription(' An entry in the Intf RIP filter table')
rsIpRipFilterLclIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpRipFilterLclIpIntf.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclIpIntf.setDescription(' The IP address identifying the RIP interface for this filter.\n   This value corresponds to rsIpAdEntAddr. ')
rsIpRipFilterLclType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("input", 1), ("output", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpRipFilterLclType.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclType.setDescription(' Type of filter - input/output ')
rsIpRipFilterLclNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpRipFilterLclNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclNumber.setDescription(' Number of RIP filter for this Interface')
rsIpRipFilterLclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2), ("underCreation", 3))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterLclStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclStatus.setDescription(' The validity of this entry. Setting this value to invalid deletes\n   the entry, and the entry may be actualy removed from the table.')
rsIpRipFilterLclIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterLclIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclIpAddr.setDescription(' network prefix IP address, as in the forwarding table. ')
rsIpRipFilterLclNetworkMaskBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterLclNetworkMaskBits.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclNetworkMaskBits.setDescription(' the number of bits in the IP Network mask, called network-prefix-length\n   in Router Requirements terminology. for example: the value 16 means\n   mask 255.255.0.0 ')
rsIpRipFilterLclMatchBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 7), Integer32().clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterLclMatchBits.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclMatchBits.setDescription(' the number of bits to match in the Network IP address. A value\n   smaller than 32 defines a wildcard. for example: the value 8 means\n   all routes whose leftmost 8 bits are equal to those of the network IP\n   address. If this variable has a value other than 32, than\n   rsIpRipFilterLclNetworkMaskBits must be 0 and is ignored. ')
rsIpRipFilterLclAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deny", 1), ("permit", 2))).clone('permit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpRipFilterLclAction.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpRipFilterLclAction.setDescription(' Filter action - permit/deny ')
rsRipEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRipEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsRipEnable.setDescription('Enables or disables RIP.')
lreBoxAgentIP = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreBoxAgentIP.setStatus('mandatory')
if mibBuilder.loadTexts: lreBoxAgentIP.setDescription('')
ipIfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 11), )
if mibBuilder.loadTexts: ipIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfTable.setDescription('This table is parralel to IPv6 MIB (RFC4293) ipIfTable, and is \nused to\n\n        add/delete entries to/from that table. In addition it contains\n        private objects.')
ipIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 11, 1), ).setIndexNames((0, "RADWARE-MIB", "ipIfAddr"))
if mibBuilder.loadTexts: ipIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfEntry.setDescription("The addressing information for one of this\n            entity's IP addresses.")
ipIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 1), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfAddr.setDescription("The IP address to which this entry's addressing\n            information pertains.")
ipIfPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfPrefix.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfPrefix.setDescription("The IP address's prefix.")
ipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfIndex.setDescription('The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.')
ipIfFwdBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfFwdBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfFwdBroadcast.setDescription(' This variable controls forwarding of IP (sub)net-directed\n          broadcasts destined for an attached sub(net). ')
ipIfBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfBcastAddr.setDescription(' Indicates how the host part of ip subnet broadcast messages will be\n          filled:\n           0 - host part will be filled by 0\n           1 - host part will be filled by 1.')
ipIfVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfVlanTag.setDescription('The vlan Tag value that represent this ip interface\n             this filed include both vlna tag and vlan priority ')
ipIfLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfLabel.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfLabel.setDescription('User textual dscription of the ip interface.')
ipIfEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfEntryStatus.setDescription('It is used to delete an entry')
ipIfBackupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 11, 1, 9), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipIfBackupAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfBackupAddr.setDescription('The ip address of the peer address. It is used by CDE and High Availability.')
ipSpecRouteTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 12), )
if mibBuilder.loadTexts: ipSpecRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteTable.setDescription("This entity's IP Routing table.")
ipSpecRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 12, 1), ).setIndexNames((0, "RADWARE-MIB", "ipSpecRouteDest"), (0, "RADWARE-MIB", "ipSpecRoutePfxLen"), (0, "RADWARE-MIB", "ipSpecRouteNextHop"))
if mibBuilder.loadTexts: ipSpecRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteEntry.setDescription('A particular route to a particular destination, under a\n           particular policy (as reflected in the ipSpecRoutePolicy object).\n\n           Dynamically created rows will survive an agent reboot.\n\n           Implementers need to be aware that if the total number\n           of elements (octets or sub-identifiers) in\n           ipSpecRouteDest, and\n           ipSpecRouteNextHop exceeds 111, then OIDs of column\n           instances in this table will have more than 128 sub-\n           identifiers and cannot be accessed using SNMPv1,\n           SNMPv2c, or SNMPv3.')
ipSpecRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 1), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSpecRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteDest.setDescription('The destination IP address of this route.\n\n           The values for the index objects ipSpecRouteDest and\n           ipSpecRoutePfxLen must be consistent.  When the value\n           of ipSpecRouteDest (excluding the zone index, if one\n           is present) is x, then the bitwise logical-AND\n           of x with the value of the mask formed from the\n           corresponding index object ipSpecRoutePfxLen MUST be\n           equal to x.  If not, then the index pair is not\n           consistent and an inconsistentName error must be\n           returned on SET or CREATE requests.')
ipSpecRoutePfxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSpecRoutePfxLen.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRoutePfxLen.setDescription('The prefix length. For IPv4 must be <=32, for IPv6 <= 128.\n\n           The values for the index objects ipSpecRouteDest and\n           ipSpecRoutePfxLen must be consistent. For IPv4 must be \n           <=32, for IPv6 <= 128. If not, then the index pair is not\n           consistent and an inconsistentName error must be\n           returned on SET or CREATE requests.')
ipSpecRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 3), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSpecRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteNextHop.setDescription('On remote routes, the address of the next system en\n           route.  For non-remote routes, a zero length string.\n\n           The type of this address is determined by the value of\n           the ipSpecRouteNextHopType object.')
ipSpecRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSpecRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteMetric.setDescription("The primary routing metric for this route.  The\n           semantics of this metric are determined by the routing-\n           protocol specified in the route's ipSpecRouteProto\n           value.  The default value is 1.")
ipSpecRoutePort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSpecRoutePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRoutePort.setDescription('The Port value that identifies the local port/interface\n           through which the next hop of this route should be\n           reached. ')
ipSpecRouteLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSpecRouteLabel.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteLabel.setDescription('User defined data.')
ipSpecRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSpecRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipSpecRouteStatus.setDescription('The row status variable, used according to row\n           installation and removal conventions.\n\n           A row entry cannot be modified when the status is\n           marked as active(1).')
ip6NetToMediaTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 13), )
if mibBuilder.loadTexts: ip6NetToMediaTable.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaTable.setDescription("This entity's ND table.")
ip6NetToMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 13, 1), ).setIndexNames((0, "RADWARE-MIB", "ip6NetToMediaIfIndex"), (0, "RADWARE-MIB", "ip6NetToMediaNetAddress"))
if mibBuilder.loadTexts: ip6NetToMediaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaEntry.setDescription("The addressing information for one of this\n            entity's ND addresses.")
ip6NetToMediaIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 13, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip6NetToMediaIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaIfIndex.setDescription("The interface on which this entry's equivalence\n                      is effective.  The interface identified by a\n                      particular value of this index is the same\n                      interface as identified by the same value of\n                      ifIndex.")
ip6NetToMediaPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 13, 1, 2), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip6NetToMediaPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaPhysAddress.setDescription("The media-dependent `physical' address.")
ip6NetToMediaNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 13, 1, 3), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip6NetToMediaNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaNetAddress.setDescription("The IpAddress corresponding to the media-\n                      dependent `physical' address.")
ip6NetToMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ip6NetToMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: ip6NetToMediaType.setDescription('The type of mapping.\n\n                      Setting this object to the value invalid(2) has\n                      the effect of invalidating the corresponding entry\n                      in the ipNetToMediaTable.  That is, it effectively\n                      dissasociates the interface identified with said\n                      entry from the mapping identified with said entry.\n                      It is an implementation-specific matter as to\n                      whether the agent removes an invalidated entry\n                      from the table.  Accordingly, management stations\n                      must be prepared to receive tabular information\n                      from agents that corresponds to entries not\n                      currently in use.  Proper interpretation of such\n                      entries requires examination of the relevant\n                      ipNetToMediaType object.')
ndSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 14))
rsNetNdInactiveTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 14, 1), Integer32().clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsNetNdInactiveTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetNdInactiveTimeOut.setDescription('This variable defines the maximum time period (in second) that can\n          pass between Neighbor-discovery requests concerning an entry in the Neighbor-discovery table.\n          After this time period, the entry is deleted from the table.\n\t\t  This timer is common for both IPv6 Neighbor-discovery and IPv4 ARP.')
virtualLan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 27))
virtualLanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 27, 1), )
if mibBuilder.loadTexts: virtualLanTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanTable.setDescription('An entry of this table specifies an new ifIndex with a type of\n          propVirtual(53).')
virtualLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 27, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "vlIfIndex"))
if mibBuilder.loadTexts: virtualLanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanEntry.setDescription('A list of information for each virtual LAN.')
vlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlIfIndex.setDescription('An logical interface number, corresponded this VL')
vlProto = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("ipmulticast", 3), ("ipxRaw", 4), ("ipxET", 5), ("ipxLLC", 6), ("ipxSNAP", 7), ("decNET", 8), ("decLAT", 9), ("netBios", 10), ("appleTalk", 11), ("xns", 12), ("sna", 13), ("userDefined", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlProto.setStatus('mandatory')
if mibBuilder.loadTexts: vlProto.setDescription("The protocol, supported by this VL. The meanings of the values are:\n      other: none of the following. This VL includes any protocol except the\n             following protocols. It  is a bridging VL. RS relies on\n             a third-party router to exchange traffic between nodes on different\n             virtual LANs of this type.\n      IP:    This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      IPmulticast: RS will broadcast the message to all  the VL's ports. Used for\n             video-conferencing applications.\n      ipxRaw: This is a Routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxET: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxLLC: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxSNAP: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      decNET: This is a bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different DECnet virtual\n             LANs of this type.\n      netBios: This is a Bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different NetBIOS virtual\n             LANs of this type.\n      appleTalk: This is a bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different AppleTalk virtual\n             LANs of this type.")
vlAutoConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlAutoConfigEnable.setStatus('mandatory')
if mibBuilder.loadTexts: vlAutoConfigEnable.setDescription("It is used only in the case of IP. The meanings of the values are:\n      true(1):  Autolearning is used for this VL\n      false(2): Autolearning isn't used for this VL from ports, specified in\n                the table virtualLanAutoConfTable.")
vlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vlStatus.setDescription('It is used to delete an entry')
vlType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("regular", 1), ("specBroadcast", 2), ("specArpReq", 3), ("specBroadcastAndUnicast", 4), ("specArpReqAndUnicast", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlType.setStatus('mandatory')
if mibBuilder.loadTexts: vlType.setDescription("regular       - ordinary type\n        specBroadcast - for switches that support VLANs as a set of ports and\n                        only as a broadcast domain: broadcast frames do not\n                        cross VLAN's bounders, but unicast frames may be\n                        transmitted between different VLANs. Permits passing\n                        of broadcast frames between Vgate's VLANs.\n        specArpReq -    for switches that support VLANs as a set of ports and\n                        only as a broadcast domain: broadcast frames do not\n                        cross VLAN's bounders, but unicast frames may be\n                        transmitted between different VLANs. Permits passing\n                        of ARP request frames between Vgate's VLANs.\n        specBroadcastAndUnicast -\n                        for switches that support VLANs as a set of ports\n                        but no frame crosses VLAN's bounders. Permits passing\n                        of IP/ARP request broadcast and IP unicast frames\n                        between Vgate's VLANs.\n        specArpReqAndUnicast -\n                        for switches that support VLANs as a set of ports\n                        but no frame crosses VLAN's bounders. Permits passing\n                        of ARP request broadcast and IP unicast frames between\n                        Vgate's VLANs. This type can be used only for IP VLANs.")
virtualLanPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 27, 2), )
if mibBuilder.loadTexts: virtualLanPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanPortsTable.setDescription('For each VL (a ifIndex with a type of propVirtual(53)) an entry of  this\n           table specifies a set of ports, which it contains.')
virtualLanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 27, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "vLIfIndex"), (0, "RADWARE-MIB", "vLPortIfIndex"))
if mibBuilder.loadTexts: virtualLanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanPortEntry.setDescription('A entry of this table specifies a  VL and a port belonging to it')
vLIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vLIfIndex.setDescription('An logical interface number, corresponding to this VL')
vLPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vLPortIfIndex.setDescription('A physical port belonging to the VL specified by vlIfIndex.')
vLPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vLPortType.setStatus('mandatory')
if mibBuilder.loadTexts: vLPortType.setDescription('static means configured by user dynamic means autoconfigured by the RS')
vLPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vLPortStatus.setDescription('It is used to delete an entry')
virtualLanAutoConfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 27, 3), )
if mibBuilder.loadTexts: virtualLanAutoConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanAutoConfTable.setDescription('This table specifies per a routing protocol a set of ports, from which\n           RS will automatically  learning VL in accordance with rules, defined\n           by the protocol.')
virtualLanAutoConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 27, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "vlAutoConfPortIfIndex"), (0, "RADWARE-MIB", "vlAutoConfProto"))
if mibBuilder.loadTexts: virtualLanAutoConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanAutoConfEntry.setDescription('One port, specified by vlAutoConfPortIfIndex, for which the RS will\n        automatically  learn its VL in accordance with rules, defined\n        by  the protocol specified in vlAutoConfProto.')
vlAutoConfPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 3, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlAutoConfPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vlAutoConfPortIfIndex.setDescription('Port on which the autoconfig option should be supported')
vlAutoConfProto = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("ip", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlAutoConfProto.setStatus('mandatory')
if mibBuilder.loadTexts: vlAutoConfProto.setDescription('Protocol for which the autoconfig option is supported for the port\n          specified by vlAutoConfPortIfIndex  ')
vlAutoConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 27, 3, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlAutoConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vlAutoConfStatus.setDescription('It is used to delete an entry')
virtualLanAutoConfAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 27, 4), Integer32().clone(3600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtualLanAutoConfAgingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanAutoConfAgingTimeout.setDescription('The units of this MIB object is seconds.\n          Its value can be either 0 or in range 10..65535 .')
virtualLanProtocolVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 27, 5))
virtualLanUserEtherType = MibScalar((1, 3, 6, 1, 4, 1, 89, 27, 5, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtualLanUserEtherType.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanUserEtherType.setDescription('')
virtualLanUserMask = MibScalar((1, 3, 6, 1, 4, 1, 89, 27, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: virtualLanUserMask.setStatus('mandatory')
if mibBuilder.loadTexts: virtualLanUserMask.setDescription('')
rsConf = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 28))
class RsIfType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(23, 32, 500, 1000, 1001, 1002, 1003, 1010, 1011, 1100))
    namedValues = NamedValues(("ppp", 23), ("frameRelay", 32), ("virtualNet", 500), ("rndWan", 1000), ("cod", 1001), ("backup", 1002), ("fr1490", 1003), ("b1isdn", 1010), ("b2isdn", 1011), ("unknown", 1100))

rsIfConfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 28, 1), )
if mibBuilder.loadTexts: rsIfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfTable.setDescription('This table enable the user to add interface  to the RS.\n           RS will automatically  add the new interface to the interface Table ')
rsIfConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 28, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIfConfIndex"))
if mibBuilder.loadTexts: rsIfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfEntry.setDescription('Each entry defines a configured interface.')
rsIfConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 28, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIfConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfIndex.setDescription('This variable uniquely identifies the interface.\n       It is used as a cross reference in other system tables')
rsIfConfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 28, 1, 1, 2), RsIfType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfConfType.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfType.setDescription('This variable identifies the type of the specific\n       entry in the rsIfConfTable.\n       This field is writable only at creation time\n       (i.e., when value of status is underCreation).')
rsIfConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 28, 1, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfConfName.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfName.setDescription('This variable provides a logical name to a specific entry in\n       rsIfConfTable')
rsIfConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 28, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfConfStatus.setDescription('The status of the ConfigEntry.  The choices are those\n       defined in SNMPv2-TC. Only: active, createAndWait, and destroy\n       will be used.\n       active - The conceptual row is available for use by the managed device.\n       createAndWait - A new instance of a conceptual row is desired, but\n       not to have it available for use by the managed device.\n       destroy - Delete all instances associated with an existing conceptual row.')
rsTunning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29))
rsHighPriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsHighPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsHighPriority.setDescription('This variable indicates the time interval the forwarding task inside the\n      RS works in High Priority Mode.')
rsLowPriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLowPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsLowPriority.setDescription('This variable indicates the time interval the forwarding task inside the\n      RS works in Low Priority Mode.')
rsDbgLevel = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDbgLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rsDbgLevel.setDescription('This variable indicates the debug level the Router Server works.\n       the range of this variable is 1..100 ')
rsDiagnostic = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: rsDiagnostic.setDescription('This variable  will contain some dignostic information in case on a\n       problem ocurs in the RS functinality.')
rsConfirmMessagTab = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsConfirmMessagTab.setStatus('mandatory')
if mibBuilder.loadTexts: rsConfirmMessagTab.setDescription('This variable  enables the operator to confirm all the message in the\n       event Message Table.')
eventMessageTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 6), )
if mibBuilder.loadTexts: eventMessageTable.setStatus('mandatory')
if mibBuilder.loadTexts: eventMessageTable.setDescription('The Event Message table of the agent')
eventMessageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 6, 1), ).setIndexNames((0, "RADWARE-MIB", "eventNum"))
if mibBuilder.loadTexts: eventMessageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: eventMessageEntry.setDescription(' The row definition for this table.')
eventNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventNum.setStatus('mandatory')
if mibBuilder.loadTexts: eventNum.setDescription('The event number,the index of this table.')
eventDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 6, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eventDesc.setStatus('mandatory')
if mibBuilder.loadTexts: eventDesc.setDescription('The event discription, this text will include time and severity.')
reaTunning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 7))
reaIpRemoteAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaIpRemoteAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpRemoteAgingTime.setDescription('This variable specifies aging time used by the REA for remote\n       entries in the Ip Fast Forwarding Table.')
reaFftHashMaxChain = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaFftHashMaxChain.setStatus('mandatory')
if mibBuilder.loadTexts: reaFftHashMaxChain.setDescription('This variable specifies the maximum length of hash chains in\n       the Fast Forwarding Tables.')
reaMltcstBitOn = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaMltcstBitOn.setStatus('mandatory')
if mibBuilder.loadTexts: reaMltcstBitOn.setDescription('')
reaIpForwardEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaIpForwardEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpForwardEnable.setDescription("The Platform will perform fast IP forwarding if only if this\n       variable's value is enable.")
reaIpxForwardEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaIpxForwardEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxForwardEnable.setDescription("The Platform will perform fast IPX forwarding if only if this\n       variable's value is enable.")
reaBridgeEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaBridgeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaBridgeEnable.setDescription("The Platform will perform bridging if only if this\n       variable's value is enable.")
reaFacsEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaFacsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaFacsEnable.setDescription("The RS and Platform will perform FASC if only if this\n       variable's value is enable.")
reaIpForwardDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpForwardDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpForwardDatagrams.setDescription('The number of IP datagrams have been forwarded by the Platform.')
reaIpInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpInDiscards.setDescription('The number of IP datagrams have been dicarded by the Platform.')
reaIpxForwardDatagrams = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxForwardDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxForwardDatagrams.setDescription('The number of IPX datagrams have been forwarded by the Platform.')
reaIpxInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxInDiscards.setDescription('The number of IP datagrams have been dicarded by the Platform.')
reaBridgeFftTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 7, 12), )
if mibBuilder.loadTexts: reaBridgeFftTable.setStatus('mandatory')
if mibBuilder.loadTexts: reaBridgeFftTable.setDescription('The Bridge Fast Forwarding Table')
reaBridgeFftEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1), ).setIndexNames((0, "RADWARE-MIB", "reaBrgFftEntryNum"))
if mibBuilder.loadTexts: reaBridgeFftEntry.setStatus('mandatory')
if mibBuilder.loadTexts: reaBridgeFftEntry.setDescription(' The row definition for this table.')
reaBrgFftEntryNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftEntryNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftEntryNum.setDescription('')
reaBrgFftMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftMacAddr.setDescription('')
reaBrgFftReNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftReNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftReNum.setDescription('')
reaBrgFftPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftPortNum.setDescription('')
reaBrgFftFacsSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftFacsSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftFacsSrcIndex.setDescription('')
reaBrgFftFacsDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 12, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgFftFacsDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgFftFacsDstIndex.setDescription('')
reaBrgDiscards = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgDiscards.setDescription('The number of bridging datagrams have been discarded by the Platform.')
reaBrgForwards = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBrgForwards.setStatus('mandatory')
if mibBuilder.loadTexts: reaBrgForwards.setDescription('The number of bridging datagrams have been forwarded by the Platform.')
reaIpFftTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 7, 15), )
if mibBuilder.loadTexts: reaIpFftTable.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftTable.setDescription('The IP Fast Forwarding Table')
reaIpFftEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1), ).setIndexNames((0, "RADWARE-MIB", "reaIpFftEntryNum"))
if mibBuilder.loadTexts: reaIpFftEntry.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftEntry.setDescription(' The row definition for this table.')
reaIpFftEntryNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftEntryNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftEntryNum.setDescription('')
reaIpFftDstIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftDstIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftDstIpAddr.setDescription('')
reaIpFftDstIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftDstIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftDstIpMask.setDescription('')
reaIpFftRangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftRangeType.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftRangeType.setDescription('')
reaIpFftSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftSrcMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftSrcMacAddr.setDescription('')
reaIpFftDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftDstMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftDstMacAddr.setDescription('')
reaIpFftReNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftReNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftReNum.setDescription('')
reaIpFftPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftPortNum.setDescription('')
reaIpFftFacsSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftFacsSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftFacsSrcIndex.setDescription('')
reaIpFftFacsDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftFacsDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftFacsDstIndex.setDescription('')
reaIpFftApplFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 15, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpFftApplFlags.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpFftApplFlags.setDescription('A bit mask that defines the applications associated with this entry:\n       __________________________________________\n       |  Byte 1|Byte 2 |Byte 3 | ....|Byte 20  |\n       |87654321|                     | 87654321|\n       |________|_______________________________|\n\n Byte1 :\n      bit1: Server Dispatcher Client')
reaIpxFftTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 7, 16), )
if mibBuilder.loadTexts: reaIpxFftTable.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftTable.setDescription('The IPX Fast Forwarding Table')
reaIpxFftEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1), ).setIndexNames((0, "RADWARE-MIB", "reaIpxFftEntryNum"))
if mibBuilder.loadTexts: reaIpxFftEntry.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftEntry.setDescription(' The row definition for this table.')
reaIpxFftEntryNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftEntryNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftEntryNum.setDescription('')
reaIpxFftDstNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftDstNetid.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftDstNetid.setDescription('')
reaIpxFftRangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("direct", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftRangeType.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftRangeType.setDescription('')
reaIpxFftSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftSrcMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftSrcMacAddr.setDescription('')
reaIpxFftDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 5), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftDstMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftDstMacAddr.setDescription('')
reaIpxFftReNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftReNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftReNum.setDescription('')
reaIpxFftPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftPortNum.setDescription('')
reaIpxFftFacsSrcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftFacsSrcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftFacsSrcIndex.setDescription('')
reaIpxFftFacsDstIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 16, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaIpxFftFacsDstIndex.setStatus('mandatory')
if mibBuilder.loadTexts: reaIpxFftFacsDstIndex.setDescription('')
lreVnResposibilityTable = MibTable((1, 3, 6, 1, 4, 1, 89, 29, 7, 17), )
if mibBuilder.loadTexts: lreVnResposibilityTable.setStatus('mandatory')
if mibBuilder.loadTexts: lreVnResposibilityTable.setDescription('The Bridge Responsibility Table')
lreVnResposibilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 29, 7, 17, 1), ).setIndexNames((0, "RADWARE-MIB", "lreVnRespVn"))
if mibBuilder.loadTexts: lreVnResposibilityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lreVnResposibilityEntry.setDescription(' The row definition for this table.')
lreVnRespVn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 17, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreVnRespVn.setStatus('mandatory')
if mibBuilder.loadTexts: lreVnRespVn.setDescription('')
lreVnRespStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 29, 7, 17, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreVnRespStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lreVnRespStatus.setDescription('')
reaSrcViolationEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaSrcViolationEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaSrcViolationEnable.setDescription("The Platform will perform the Source Port Violation Procedure\n       if only if this variable's value is enable.")
reaSrcViolationTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaSrcViolationTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaSrcViolationTrapEnable.setDescription("The RS will send the Source Port Violation TRAP messages\n       if only if this variable's value is enable.")
reaSrcAddrValidationEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reaSrcAddrValidationEnable.setStatus('mandatory')
if mibBuilder.loadTexts: reaSrcAddrValidationEnable.setDescription('The Platform will verify the source address of incoming\n       IP datagram.')
reaRsQueueDiscards = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaRsQueueDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: reaRsQueueDiscards.setDescription('')
reaBufFree = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: reaBufFree.setStatus('mandatory')
if mibBuilder.loadTexts: reaBufFree.setDescription('The number of free buffers.')
lreResetDstMacBit46 = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreResetDstMacBit46.setStatus('mandatory')
if mibBuilder.loadTexts: lreResetDstMacBit46.setDescription('')
lreQueSourceSelect = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vNET", 1), ("dstMac", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreQueSourceSelect.setStatus('mandatory')
if mibBuilder.loadTexts: lreQueSourceSelect.setDescription('')
lreResetDstMacBit47 = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 7, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lreResetDstMacBit47.setStatus('mandatory')
if mibBuilder.loadTexts: lreResetDstMacBit47.setDescription('')
rsMaxEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8))
rsMaxBridgeForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 1))
rsMaxBrgFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxBrgFrwEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxBrgFrwEntries.setDescription('Maximal number of entries in bridge forwarding table.')
rsMaxBrgFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxBrgFrwEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxBrgFrwEntriesAfterReset.setDescription('Future maximal number of entries in bridge forwarding table.')
rsMaxIpForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 2))
rsMaxIpFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpFrwEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpFrwEntries.setDescription('Maximal number of entries in Ip forwarding table.')
rsMaxIpFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpFrwEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpFrwEntriesAfterReset.setDescription('Future maximal number of entries in Ip forwarding table.')
rsMaxArpEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 3))
rsMaxArpEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxArpEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxArpEntries.setDescription('Maximal number of entries in Arp forwarding table.')
rsMaxArpEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxArpEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxArpEntriesAfterReset.setDescription('Future maximal number of entries in Arp forwarding table.')
rsMaxIpxForwardingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 4))
rsMaxIpxFrwEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxFrwEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpxFrwEntries.setDescription('Maximal number of entries in Ipx forwarding table.')
rsMaxIpxFrwEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxFrwEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpxFrwEntriesAfterReset.setDescription('Future maximal number of entries in Ipx forwarding table.')
rsMaxIpxSapEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 5))
rsMaxIpxSapEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxIpxSapEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpxSapEntries.setDescription('Maximal number of entries in IpxSap table.')
rsMaxIpxSapEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxIpxSapEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxIpxSapEntriesAfterReset.setDescription('Future maximal number of entries in IpxSap table.')
rsMaxDspClntEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 6))
rsMaxDspClntEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDspClntEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxDspClntEntries.setDescription('Maximal number of entries in rsSdClientsTable.')
rsMaxDspClntEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDspClntEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxDspClntEntriesAfterReset.setDescription('Future maximal number of entries in rsSdClientsTable.')
rsMaxZeroHopRoutEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 7))
rsMaxZhrConns = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxZhrConns.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxZhrConns.setDescription('The current maximal number of direct Zero-hop routing\n       connections.')
rsMaxZhrConnsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxZhrConnsAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxZhrConnsAfterReset.setDescription('The future (after reset) maximal number of direct Zero-hop routing\n       connections.')
rsMaxDspFrmEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 8))
rsMaxDspFrmEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxDspFrmEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxDspFrmEntries.setDescription('Maximal number of entries in rsSdClientsTable.')
rsMaxDspFrmEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxDspFrmEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxDspFrmEntriesAfterReset.setDescription('Future maximal number of entries in rsSdClientsTable.')
rsMaxRoutingEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 9))
rsMaxRoutingEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxRoutingEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRoutingEntries.setDescription('Maximal number of entries in the routing table.')
rsMaxRoutingEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxRoutingEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRoutingEntriesAfterReset.setDescription('Future maximal number of entries in the routing table.')
rsMaxRadiusEntriesTuning = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 29, 8, 10))
rsMaxRadiusUsersEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxRadiusUsersEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRadiusUsersEntries.setDescription('Maximal number of entries in the radius users table.')
rsMaxRadiusUsersEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxRadiusUsersEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRadiusUsersEntriesAfterReset.setDescription('Future maximal number of entries in the radius users table.')
rsMaxRadiusNasAuthEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsMaxRadiusNasAuthEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRadiusNasAuthEntries.setDescription('Maximal number of entries in the NAS Authenticators table.')
rsMaxRadiusNasAuthEntriesAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 8, 10, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsMaxRadiusNasAuthEntriesAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsMaxRadiusNasAuthEntriesAfterReset.setDescription('Future maximal number of entries in the NAS Authenticators table.')
rsTuneCheckMemory = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enoughMemory", 1), ("notEnoughMemory", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTuneCheckMemory.setStatus('mandatory')
if mibBuilder.loadTexts: rsTuneCheckMemory.setDescription('Shows whether the requested number of entries in the after-reset tuning\n       variables can be successfully allocated.')
rsTuneLastCheckResult = MibScalar((1, 3, 6, 1, 4, 1, 89, 29, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsTuneLastCheckResult.setStatus('mandatory')
if mibBuilder.loadTexts: rsTuneLastCheckResult.setDescription('Number of Kbytes missing in request for new table sizes.')
rndApplications = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35))
rsServerDispatcher = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1))
rndMidLevelManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 2))
rndAlarmOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 2, 2))
rndAlarmEnabling = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndAlarmEnabling.setStatus('mandatory')
if mibBuilder.loadTexts: rndAlarmEnabling.setDescription('Indicates whether alarms should be issued to the high-level\n         NMS ')
rndAlarmInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndAlarmInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rndAlarmInterval.setDescription('Indicates the minimal period of time which must pass after issuing\n         an alarm before issuing the same alarm again.')
rndMonitoredElementsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 2, 3), )
if mibBuilder.loadTexts: rndMonitoredElementsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementsTable.setDescription('The table of monitored elements of the network')
rndMonitoredElementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rndMonitoredElementAddress"))
if mibBuilder.loadTexts: rndMonitoredElementEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementEntry.setDescription(' The row definition for this table.')
rndMonitoredElementAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndMonitoredElementAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementAddress.setDescription('The IP address of the monitored element')
rndMonitoredElementCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredElementCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementCommunity.setDescription('The community of the monitored element')
rndMonitoredElementLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredElementLabel.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementLabel.setDescription('The label assigned by the network manager to the monitored element')
rndDefaultPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndDefaultPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rndDefaultPollingInterval.setDescription('The default period of time between two consecutive pollings of the\n     monitored element for the value of an object instance. If no other polling\n     interval is specifically assigned to the monitored object instance, this\n     one will be used')
rndDefaultLogFile = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndDefaultLogFile.setStatus('mandatory')
if mibBuilder.loadTexts: rndDefaultLogFile.setDescription('The default file path of the log-file which will contain the polling\n     results for the monitored element. If no other file path is specifically\n     assigned to the monitored object instance, this log-file will be used.')
rndMonitoredElementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 3, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredElementStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElementStatus.setDescription('It is used to manage the monitored elements table and indicates\n          the current monitoring status of an element.')
rndMonitoringTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 2, 4), )
if mibBuilder.loadTexts: rndMonitoringTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoringTable.setDescription('The table of monitored object instances. Each monitored object instance\n     belongs to a monitored element previously entered in the\n     rndMonitoredElementsTable. ')
rndMonitoringEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1), ).setIndexNames((0, "RADWARE-MIB", "rndMonitoredElement"), (0, "RADWARE-MIB", "rndMonitoredObjectInstanceLabel"))
if mibBuilder.loadTexts: rndMonitoringEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoringEntry.setDescription(' The row definition for this table.')
rndMonitoredElement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndMonitoredElement.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredElement.setDescription('A label assigned by the network manager to a monitored element to\n     which this monitored object instance belongs. This label must have\n     been previously entered in an instance of rndMonitoredElementLabel')
rndMonitoredObjectInstanceLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndMonitoredObjectInstanceLabel.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredObjectInstanceLabel.setDescription('The label assigned by the network manager to the monitored object instance')
rndMonitoredObjectName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredObjectName.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredObjectName.setDescription('The symbolic object type name of the object to which the monitored object\n     instance belongs (as it appears the MIB module definition). In case of\n     ambiguity the <MIB module name> : <object type name> format should be used.\n     An instance of rndMonitoredObjectName need not be assigned any value, if\n     the corresponding instance of rndMonitoredObjectIdentifier is assigned a\n     value, since any one of these, together with the object instance\n     identifier, suffices to unambigously identify the monitored object\n     instance.')
rndMonitoredObjectIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredObjectIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredObjectIdentifier.setDescription('The object identifier of the object to which the monitored object\n     instance belongs.\n     An instance of rndMonitoredObjectIdentifier need not be assigned any value, if\n     the corresponding instance of rndMonitoredObjectName is assigned a value,\n     since any one of these, together with the object instance identifier,\n     suffices to unambigously identify the monitored object instance.')
rndMonitoredObjectInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 5), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredObjectInstance.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredObjectInstance.setDescription('The instance identifier (key) of the monitored object instance.')
rndMonitoredObjectSyntax = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("integer", 1), ("octet-string", 2), ("ip-address", 3), ("object-identifier", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoredObjectSyntax.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoredObjectSyntax.setDescription('The syntax of the monitored object instance (i.e., the syntax of the object\n     type of the object to which the monitored instance belongs).\n     Need not be assigned any value if the corresponding instance of\n     rndMonitoredObjectName has been assigned a value')
rndMonitoringInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoringInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoringInterval.setDescription("The period of time between two consecutive retrievals of the monitored\n     object instance's value.")
rndAlarmMaxTreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndAlarmMaxTreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rndAlarmMaxTreshold.setDescription('The value of the monitored object instance, the exceeding of which\n     will cause the generation of an alarm to the high-level management\n     station.')
rndAlarmMinTreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndAlarmMinTreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rndAlarmMinTreshold.setDescription('If the value of the monitored object instance falls below the value\n     assigned to rndAlarmMinTreshold, an alarm to the high-level management\n     station will be issued.')
rndMonitoringLogfile = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoringLogfile.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoringLogfile.setDescription('The entire path of the file in which the results of the monitoring\n     of this object instance should be recorded.')
rndMonitoringEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 4, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMonitoringEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndMonitoringEntryStatus.setDescription('It is used to manage the monitored object instances table and\n          indicates the current monitoring status of an object instance.')
rndMibFilesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 2, 5), )
if mibBuilder.loadTexts: rndMibFilesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFilesTable.setDescription('The table of monitored object instances. Each monitored object instance\n     belongs to a monitored element previously entered in the\n     rndMonitoredElementsTable. ')
rndMibFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 2, 5, 1), ).setIndexNames((0, "RADWARE-MIB", "rndMibFileIndex"))
if mibBuilder.loadTexts: rndMibFileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFileEntry.setDescription(' The row definition for this table.')
rndMibFileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndMibFileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFileIndex.setDescription('The number of the MIB file in the list MIB files supported by the\n     Mid-Level management station. The order of the MIB files in this\n     list must reflect the the IMPORT relation between the MIBS contained\n     in the MIB files, i.e., if MIB A IMPORTS FROM MIB B, the file containing\n     MIB A must have a lesser index in this table than the file containing\n     MIB B.')
rndMibFilePath = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMibFilePath.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFilePath.setDescription('The path of the MIB file in the MIB file server.')
rndMibFileRefresh = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMibFileRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFileRefresh.setDescription('Indicates if the file should be fetched after setting this entry from the\n     MIB file server.')
rndMibFileEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndMibFileEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndMibFileEntryStatus.setDescription('It is used to manage the MIB files table.')
rndHardwareConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndHardwareConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rndHardwareConfiguration.setDescription('Indicates whether the current SET SNMP PDU contains hardware\n         configuration (i.e., normally read-only variables). SET of such\n         variables in the Mid-level management station will be allowed only\n         if this variable is included in the SNMP PDU and its value is true.\n         Its value as returned in  a GET SNMP PDU will always be false.')
rndEraseSimulatedConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eraseSimulatedConfiguration", 1), ("simulatedConfigurationPresent", 2), ("simulatedConfigurationErased", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndEraseSimulatedConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rndEraseSimulatedConfiguration.setDescription('eraseSimulatedConfiguration instructs the MLNMS to erase all the\n         simulated configuration from its configuration data-base (CDB). This\n         the only accepted value for SNMP SET statements and will never be\n         returned in SNMP GET statements.\n         simulatedConfigurationPresent indicates that the MLNMS currently has\n         a simulated configuration.\n         simulatedConfigurationErased indicates that the MLNMS currently has\n         no simulated configuration.')
rndDeleteValuesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 2, 8), )
if mibBuilder.loadTexts: rndDeleteValuesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rndDeleteValuesTable.setDescription('This table indicates which MIB variables are row status fields which\n     control the status of the entry to which they belong. This table also\n     indicates which (integer!) value of these MIB variables will cause, if\n     present in a SNMP SET PDU, the deletion of the conceptual row instance\n     to which the SET MIB variable instance belongs.')
rndDeleteValuesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 2, 8, 1), ).setIndexNames((1, "RADWARE-MIB", "rndRowStatusVariableName"))
if mibBuilder.loadTexts: rndDeleteValuesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rndDeleteValuesEntry.setDescription(' The row definition for the rndDeleteValuesTable table.')
rndRowStatusVariableName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 8, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndRowStatusVariableName.setStatus('mandatory')
if mibBuilder.loadTexts: rndRowStatusVariableName.setDescription('The name of the row status field. This name may not necessarily be any\n     name which is present in the MIBs loaded into the MLNMS station.')
rndRowStatusObjectId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 8, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndRowStatusObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: rndRowStatusObjectId.setDescription('The object id of the row status field. If the rndRowStatusVariableName is\n     a name present in the MIBs loaded into the MLNMS, this MIB\n     variable is not required, but if given, it must match the object id known\n     to the MLNMS.\n     The variable identified by rndRowStatusVariableName and/or rndRowStatusObjectId\n     must be a read-write MIB variable of type INTEGER which belongs to an\n     entry (i.e, is a child of a MIB variable of type SEQUENCE).')
rndRowDeleteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 8, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndRowDeleteValue.setStatus('mandatory')
if mibBuilder.loadTexts: rndRowDeleteValue.setDescription('The value of the variable identified by rndRowStatusVariableName and/or\n     rndRowStatusObjectId, which, if present in a SNMP SET PDU, will cause\n     the deletion of the conceptual row instance which the SET MIB variable\n     instance belongs.')
rndDeleteValueEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 2, 8, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndDeleteValueEntryStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndDeleteValueEntryStatus.setDescription('It is used to delete an entry from this table.')
rndVisionDriver = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 2, 9))
rndVisionDriverActiveName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 9, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndVisionDriverActiveName.setStatus('mandatory')
if mibBuilder.loadTexts: rndVisionDriverActiveName.setDescription('The name of the active vision driver stored on the device.')
rndVisionDriverRestoreFromBackup = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("activate", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndVisionDriverRestoreFromBackup.setStatus('mandatory')
if mibBuilder.loadTexts: rndVisionDriverRestoreFromBackup.setDescription('Restores the backup vision driver')
rndSmartFan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 2, 10))
rndSmartFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 2, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndSmartFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rndSmartFanStatus.setDescription('Smart Fan Status')
rsIpZeroHopRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 3))
rsIpZhrGeneralStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrGeneralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrGeneralStatus.setDescription('This parameter enables or disables the IP Zero Hop Routing feature\n         for all IP interfaces. The IP Zero Hop Routing feature can also be\n         enabled or disabled on each IP interface through the\n         rsIpZhrStatusTable.')
rsIpZhrAgingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 3, 2), Integer32().clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrAgingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrAgingTimeout.setDescription('This parameter controls the aging time-out in seconds of direct\n         connections which were allocated. The virtual IP address of a direct\n         connection whose time-out has expired is eligible for allocation to a\n         different connection.')
rsIpZhrStatusTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 3, 3), )
if mibBuilder.loadTexts: rsIpZhrStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrStatusTable.setDescription('The administrative status of the ZHR feature per ip interface.')
rsIpZhrStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 3, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpZhrStatusIpIntf"))
if mibBuilder.loadTexts: rsIpZhrStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrStatusEntry.setDescription(' An entry in the ZHR status table.  ')
rsIpZhrStatusIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrStatusIpIntf.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrStatusIpIntf.setDescription(' The Ip interface whose ZHR feature status is accessed. ')
rsIpZhrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrAdminStatus.setDescription('It is used to control whether ZHR will operate on the interface. ')
rsIpZhrVirtAddressTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 3, 4), )
if mibBuilder.loadTexts: rsIpZhrVirtAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressTable.setDescription('The table of free virtual IP addresses which may be allocated\n       to establish direct connections   -  Per IP Interface.')
rsIpZhrVirtAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 3, 4, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpZhrVirtAddressIpIntf"), (0, "RADWARE-MIB", "rsIpZhrVirtAddressTo"))
if mibBuilder.loadTexts: rsIpZhrVirtAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressEntry.setDescription(' An entry in the ZHR virtual IP addresses table ')
rsIpZhrVirtAddressIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrVirtAddressIpIntf.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressIpIntf.setDescription(' The Ip Interface to which the IP addresses in this entry are allocated.')
rsIpZhrVirtAddressTo = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrVirtAddressTo.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressTo.setDescription(' The last free IP address in the block. ')
rsIpZhrVirtAddressFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 4, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrVirtAddressFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressFrom.setDescription(' The first free IP address in the block. ')
rsIpZhrVirtAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 4, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrVirtAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrVirtAddressStatus.setDescription('It is used to manage the virtual address table.\n          The supported actions will be active, createAndGo and destroy. ')
rsIpZhrConnectionsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 3, 5), )
if mibBuilder.loadTexts: rsIpZhrConnectionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionsTable.setDescription('Table of the currently active direct connections.')
rsIpZhrConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIpZhrConnectionIpIntf"), (0, "RADWARE-MIB", "rsIpZhrConnectionSrcIp"), (0, "RADWARE-MIB", "rsIpZhrConnectionDestIp"))
if mibBuilder.loadTexts: rsIpZhrConnectionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionEntry.setDescription(' An entry in the ZHR Connection table')
rsIpZhrConnectionIpIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionIpIntf.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionIpIntf.setDescription(' The IP Interface for which this direct connection was established. ')
rsIpZhrConnectionSrcIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionSrcIp.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionSrcIp.setDescription(' The source IP Address of this direct connection. ')
rsIpZhrConnectionDestIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionDestIp.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionDestIp.setDescription(' The destination IP Address of this direct connection. ')
rsIpZhrConnectionVirtualIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionVirtualIp.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionVirtualIp.setDescription(' The virtual IP address allocated for this direct connection. ')
rsIpZhrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionType.setDescription(" The type of this direct connection.\n     dynamic  - established by the RS.\n     disabled - established by the RS.\n                The RS detected that the virtual address is already used as\n                destination by the source BEFORE its allocation, and therefore\n                marked this connection as 'disabled' to prevent a future\n                allocation of this virtual address to this source.\n     static   - established by user.")
rsIpZhrConnectionAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpZhrConnectionAge.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionAge.setDescription(' The age of the connection in seconds.')
rsIpZhrConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 3, 5, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpZhrConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsIpZhrConnectionStatus.setDescription('It is used to manage the connections table.\n          The supported actions will be active, createAndGo and destroy. ')
routeTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,5)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: routeTableOverflow.setDescription('An overflow condition has occurred in the Routing Table. The Routing\n              Table is used for IP routing algorithm (RIP).')
fanNotWorking = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,7)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: fanNotWorking.setDescription('Fan Failure was detected')
resetRequired = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,10)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: resetRequired.setDescription('This trap indicates that in order to perform the last SET request, a reset operation\n              of the router/bridge is required. This occurs when the layer 2 routing algorithm is\n              changed between SPF and Spanning Tree. The reset can be performed manually or\n              using the variable rndAction.')
endTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,12)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: endTftp.setDescription('This trap indicates that in the device finished a TFTP\n             transaction with the management station.\n             variable rndErrorDesc and rndErrorSeverity provides the actual message\n             text and severity respectively.')
abortTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,13)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: abortTftp.setDescription('This trap indicates that in the device aborted a TFTP session with the management station.\n              variable rndErrorDesc  and rndErrorSeverity  provides the actual  message text  and\n              severity  respectively.')
startTftp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,14)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: startTftp.setDescription('Informational trap indicating that the device has intiated a\n             TFTP session. rndErrorDesc will contain the file type in\n             question')
deviceTemperatureNormal = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,15)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: deviceTemperatureNormal.setDescription('Sent whenever the temperature changes back to normal')
deviceTemperatureHigh = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,16)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: deviceTemperatureHigh.setDescription('Sent whenever the temperature changes to high')
deviceTemperatureCritical = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,17)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: deviceTemperatureCritical.setDescription('Sent whenever the temperature changes to critical')
ipxRipTblOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,36)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: ipxRipTblOverflow.setDescription('This trap indicates that in an OpenGate IPX RIP table overflow.\n             The bound variable rndErrorDesc, rndErrorSeverity\n             provides the actual  message text and severity respectively.')
ipxSapTblOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,37)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: ipxSapTblOverflow.setDescription('This trap indicates that in an OpenGate IPX SAP table overflow.\n             The bound variable rndErrorDesc, rndErrorSeverity\n             provides the actual  message text and severity respectively.')
facsAccessVoilation = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,49)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: facsAccessVoilation.setDescription('This trap indicates that message that fits FACS statenebt with operation\n            blockAndReport was forward to the interface.The bound variable rndErrorDesc,\n               rndErrorSeverity(== info ) and interface Number.')
autoConfigurationCompleted = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,50)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: autoConfigurationCompleted.setDescription('This trap indicates that auto comfiguration completetd succssefully.\n           The bound variable rndErrorDesc, rndErrorSeverity(== info )')
forwardingTabOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,51)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: forwardingTabOverflow.setDescription('This trap indicates that an overflow condition has occurred in the\n           layer II Forward Table.\n           The bound variable rndErrorDesc, rndErrorSeverity(== warning )')
errorsDuringInit = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,61)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: errorsDuringInit.setDescription('')
vlanDynPortAdded = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,66)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynPortAdded.setDescription('')
vlanDynPortRemoved = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,67)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: vlanDynPortRemoved.setDescription('')
rsSDclientsTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,68)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSDclientsTableOverflow.setDescription('This warning is generated when an overflow occurs in the clients table.')
rsSDinactiveServer = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,69)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSDinactiveServer.setDescription('This warning is generated when a server does not respond to the dispatchers polling\n              and is thought to be inactive.')
rsIpZhrConnectionsTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,70)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrConnectionsTableOverflow.setDescription('The Zero Hop Routing connections Table has been overflown.')
rsIpZhrReqStaticConnNotAccepted = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,71)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrReqStaticConnNotAccepted.setDescription('The requested static connection was not accepted because there is\n              no available IP virtual address to allocate to it.')
rsIpZhrVirtualIpAsSource = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,72)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrVirtualIpAsSource.setDescription('The virtual IP address appeared as a source IP.\n              All the connections using it will be deleted and\n              it will not be further allocated to new connections.')
rsIpZhrNotAllocVirtualIp = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,73)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsIpZhrNotAllocVirtualIp.setDescription('The source IP address sent an ARP specifying a virtual IP\n              which was not allocated for this source.\n              This virtual IP will not be allocated to connections of this\n              specific source IP.')
rsSnmpSetRequestInSpecialCfgState = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,74)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSnmpSetRequestInSpecialCfgState.setDescription('An incoming SNMP SET request was rejected because no such\n              requests (except action requests) are accepted after start of\n              new configuration reception or during sending the current\n              configuration to an NMS.')
rsConfigurationAuditEvent = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,75)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsConfigurationAuditEvent.setDescription('Triggered by an audit event.')
rdwrFanNotWorking = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,76)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrFanNotWorking.setDescription('Triggered by fan failure.')
rdwrFanInfo = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,77)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrFanInfo.setDescription('Triggered by fan information.')
rdwrCertExpiration = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,78)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrCertExpiration.setDescription('Certificate expiration notification.')
cdeResyncronizing = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,79)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeResyncronizing.setDescription('Config Sync primary device Resyncronize with secondary device.')
cdeCannotSync = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,80)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeCannotSync.setDescription('Config Sync Cannot sync.')
cdeConnected = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,81)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeConnected.setDescription('Config Sync primary device Connected to secondary device')
cdeConfigUpdateFailed = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,82)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeConfigUpdateFailed.setDescription('Config Sync primary device Failed to update the secondary device with a specific change.')
cdeSlaveReboot = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,83)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeSlaveReboot.setDescription('Config Sync primary device Send reboot command to the secondary device')
cdeSlaveRebootFailed = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,84)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeSlaveRebootFailed.setDescription('Config Sync Secondary Device Reboot has failed.')
cdeEnterOutOfSync = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,85)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeEnterOutOfSync.setDescription('Config Sync enters out-of-sync state.')
cdeSlaveRebootPending = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,86)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeSlaveRebootPending.setDescription('Config Sync Secondary Device Reboot is pending.')
cdeDisconnected = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,87)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeDisconnected.setDescription('Config Sync enters disconnected state.')
cdeInSync = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,88)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeInSync.setDescription('Config Sync enters in-sync state.')
cdeIncompatible = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,89)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeIncompatible.setDescription('Config Sync enters incompatible state.')
cdeNoMaster = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,90)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeNoMaster.setDescription('Config Sync enters no-master state.')
cdeMasterConnected = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,91)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: cdeMasterConnected.setDescription('Config Sync enters master-connected state.')
rsWSDRedundancySwitch = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,141)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDRedundancySwitch.setDescription('Whenever main server fails and backup takes over or server comes\n               up after failure a trap of this type is issued.')
rsWSDServerStatTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 12), )
if mibBuilder.loadTexts: rsWSDServerStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDServerStatTable.setDescription('In this table the WSD collects statistics per servers.')
rsWSDServerStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDSerStatName"))
if mibBuilder.loadTexts: rsWSDServerStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDServerStatEntry.setDescription(' The row definition for this table.')
rsWSDSerStatName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatName.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatName.setDescription('This variable indicate the name assigned by the user to the serve.')
rsWSDSerStatAttUsersNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatAttUsersNum.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatAttUsersNum.setDescription('The total number of currently active users attached to this server.')
rsWSDSerStatPeakLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatPeakLoad.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatPeakLoad.setDescription('Maximal number of frames per second dispatched to server\n       since last reset.')
rsWSDSerStatFramesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatFramesRate.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatFramesRate.setDescription('Number of frames per second dispatched to server.')
rsWSDSerStatFramesLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatFramesLoad.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatFramesLoad.setDescription('Number of frames per second dispatched to server.')
rsWSDSerStatRecoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSerStatRecoveryTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatRecoveryTime.setDescription("Number of seconds after server initialization during which ISD won't\n       send any requests.")
rsWSDSerStatWarmUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSerStatWarmUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatWarmUpTime.setDescription('Number of seconds after server recovery during which the server will get\n       less requests than permitted by his weight and load.')
rsWSDSerStatConnectionLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSerStatConnectionLimit.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatConnectionLimit.setDescription('The maximal number of client sessions which can be opened on this sever.')
rsWSDSerStatAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("connectionsShutdown", 2), ("sessionsShutdown", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSerStatAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatAdminStatus.setDescription('Administrative status of physical server.\n     enable -   activates the server.\n                The rsADServerOperStatus will change to active.\n     connectionsShutdown - gracefully shuts down connections to the server by allowing existing connections to complete,\n                           while new connections are not forwarded to this server.\n                  \t       The rsADServerOperStatus will change to noNewSessions.\n     sessionsShutdown - gracefully shuts down sessions to the server by allowing existing sessions to complete\n\t\t\t            (new connections that match existing sessions on this server are still forwarded to the server), while new sessions are not forwarded to this server. \n                  \t    The rsADServerOperStatus will change to noNewSessions.')
rsWSDSerStatConnectionLimitReached = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 12, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSerStatConnectionLimitReached.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSerStatConnectionLimitReached.setDescription('Connection limit reached flag.')
wsdRedundTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 16), )
if mibBuilder.loadTexts: wsdRedundTable.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundTable.setDescription('List of Farm IP addresses backed up by this router.')
wsdRedundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1), ).setIndexNames((0, "RADWARE-MIB", "wsdRedundFarmAddr"), (0, "RADWARE-MIB", "wsdRedundMainWsdAddr"))
if mibBuilder.loadTexts: wsdRedundEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundEntry.setDescription('The row definition for this table.')
wsdRedundFarmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsdRedundFarmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundFarmAddr.setDescription('The Farm Virtual Ip address on which the redundancy feature operates.')
wsdRedundMainWsdAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsdRedundMainWsdAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundMainWsdAddr.setDescription('The Ip address of the polled main wsd.')
wsdRedundOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wsdRedundOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundOperStatus.setDescription('If active, the main wsd is considered inactive and the IP interface operates as its backup.')
wsdRedundPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsdRedundPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundPollInterval.setDescription('Polling interval for the main wsd (in seconds). If 0 the wsd is not\n       polled.')
wsdRedundTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsdRedundTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundTimeout.setDescription('Interval in seconds during which the backed-up wsd must signal.\n       If it does not signal, it is considered inactive and the IP\n       interface starts operating as backup.')
wsdRedundStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wsdRedundStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wsdRedundStatus.setDescription('Entry status')
rsWSDNewEntryOnSourcePort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNewEntryOnSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNewEntryOnSourcePort.setDescription('Check source port and if different open new client entry.')
rsWSDSelectServerOnSourcePort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSelectServerOnSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSelectServerOnSourcePort.setDescription('Check source port and if different select a new server.')
rsWSDRedundancyMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDRedundancyMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDRedundancyMode.setDescription('Defines whether interface grouping functionality is enabled on the device.')
rsNsdMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("slowMode", 1), ("fastMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsNsdMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsNsdMode.setDescription('The Topology chosen for the NSD.\n         Slow mode keeps the servers behind the NSD.\n         Fast mode uses retargeting to connect clients directly\n         to servers.')
rsNsdWINSAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsNsdWINSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsNsdWINSAddr.setDescription('NetBIOS Name Server IP Address.')
rsWSDSyslogStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogStatus.setDescription('Enable/Disable syslog message sending to remote station.')
rsWSDSyslogAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 27), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogAddress.setDescription('The IP Address of the syslog station.')
rsWSDNTCheckTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 28), )
if mibBuilder.loadTexts: rsWSDNTCheckTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTCheckTable.setDescription('In this table the WSD collects NT statistics per servers.')
rsIGTransitTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 32), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIGTransitTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: rsIGTransitTimeout.setDescription('Sets the Interface Grouping port status transit timeout in seconds, i.e. how much time after setting a port up, it is considered in a transit state. A port in a transit state is not considered as down, even if that port is not yet up (relevant to Interface Grouping).')
rsWSDNTCheckEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDNTSerialNum"))
if mibBuilder.loadTexts: rsWSDNTCheckEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTCheckEntry.setDescription(' The row definition for this table.')
rsWSDNTSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDNTSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTSerialNum.setDescription('The serial number of the algorithm.')
rsWSDNTFrequentCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTFrequentCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTFrequentCheckPeriod.setDescription('The period for getting the frequent NT variables.')
rsWSDNTOpenSessionsWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTOpenSessionsWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTOpenSessionsWeight.setDescription('The weight for currently open sessions consideration.')
rsWSDNTIncomingTrafficWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTIncomingTrafficWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTIncomingTrafficWeight.setDescription('The weight for incoming traffic consideration.')
rsWSDNTOutgoingTrafficWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTOutgoingTrafficWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTOutgoingTrafficWeight.setDescription('The weight for outgoing traffic consideration.')
rsWSDNTRegularCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTRegularCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTRegularCheckPeriod.setDescription('The period for getting the regular NT variables.')
rsWSDNTAvResponseWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTAvResponseWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTAvResponseWeight.setDescription('The weight for average response time.')
rsWSDNTUsersLimitWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTUsersLimitWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTUsersLimitWeight.setDescription('The weight for the users limit on the server.')
rsWSDNTTCPLimitWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTTCPLimitWeight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTTCPLimitWeight.setDescription('The weight for the TCP connections limit on the server.')
rsWSDNTRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTRetries.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTRetries.setDescription('The number of retries before issuing a trap.')
rsWSDNTCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 28, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTCommunity.setDescription('The SNMP community name with which we access the servers.')
rsWSDPrivateCheckTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 29), )
if mibBuilder.loadTexts: rsWSDPrivateCheckTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateCheckTable.setDescription('In this table the WSD collects private statistics per server.')
rsWSDPrivateCheckEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDPrivateSerialNum"))
if mibBuilder.loadTexts: rsWSDPrivateCheckEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateCheckEntry.setDescription(' The row definition for this table.')
rsWSDPrivateSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDPrivateSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateSerialNum.setDescription('The serial number of the algorithm.')
rsWSDPrivateSpecialCheckPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateSpecialCheckPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateSpecialCheckPeriod.setDescription('The period for getting the private variables.')
rsWSDPrivateExtraVar1ID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1ID.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1ID.setDescription('This MIB variable will be retrieved from the server.')
rsWSDPrivateExtraVar1Weight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1Weight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1Weight.setDescription('The weight for variable number 1.')
rsWSDPrivateExtraVar2ID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 5), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2ID.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2ID.setDescription('This MIB variable will be retrieved from the server.')
rsWSDPrivateExtraVar2Weight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2Weight.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2Weight.setDescription('The weight for variable number 2.')
rsWSDPrivateRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateRetries.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateRetries.setDescription('The number of retries before issuing a trap.')
rsWSDPrivateCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateCommunity.setDescription('The SNMP community name with which we access the servers.')
rsWSDPrivateExtraVar1Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascending", 1), ("descending", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1Mode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar1Mode.setDescription('Specify the type of parameter. Ascending means that the value of 100 is the best (Idle CPU percentage). Descending means that the value of 0 is the best (CPU utilization percentage)')
rsWSDPrivateExtraVar2Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 29, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascending", 1), ("descending", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2Mode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPrivateExtraVar2Mode.setDescription('Specify the type of parameter. Ascending means that the value of 100 is the best (Idle CPU percentage). Descending means that the value of 0 is the best (CPU utilization percentage)')
rsWSDDNSResolution = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("proximity", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDDNSResolution.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDDNSResolution.setDescription('Enable/Disable DNS resolution for Farm Addresses. In proximity mode, the WSD will give the best proximity address for the farm.')
rsWSDUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDUserPassword.setDescription('Software download user provided password.')
rsWSDUserVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDUserVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDUserVersion.setDescription('Software download user provided version.')
rsWSDNatStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNatStatus.setDescription('Enable/Disable NAT - to hide the address of the server in messages send .')
rsWSDRedundancyTakeback = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDRedundancyTakeback.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDRedundancyTakeback.setDescription('Whether to take the interfaces when coming up from redundancy failure automatically or wait for manual terminal command')
rsMLB = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 38))
rsCSD = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 39))
rsNWSD = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 40))
rsWSDIfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 41), )
if mibBuilder.loadTexts: rsWSDIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfTable.setDescription('RND-specific interface table.  Each table entry includes an\n      index, Board number, Network Address, interface status, clock\n      indicator and interface cost.')
rsWSDIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDIfIndex"))
if mibBuilder.loadTexts: rsWSDIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfEntry.setDescription(' The row definition for this table.')
rsWSDIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfIndex.setDescription('Index to the RND Interface Table. The interface defined by a\n     particular value of this index is the same interface as\n     identified by the same value of ifIndex (MIBII).')
rsWSDIfBoardNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfBoardNum.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfBoardNum.setDescription('The interface defined by this entry correspTnds to the board\n     defined by the same value of rndSlotBoardNum in the rndSlotTab.')
rsWSDIfNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfNetAddress.setDescription('The IP address of the interface defined by the particular value of\n     rsWSDIfIndex.')
rsWSDIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("ok", 1), ("okSingleBrg", 2), ("okMultiBrg", 3), ("connctFault", 4), ("rxFault", 5), ("txFault", 6), ("channelLoopback", 7), ("rxClockFault", 8), ("t1Alarm", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfStatus.setDescription('The current status of the interface.')
rsWSDIfClockType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("external", 1), ("internal", 2), ("t1", 3), ("g703", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfClockType.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfClockType.setDescription('rsWSDIfClockType defines the type of clock each interface\n     uses: internal or external.')
rsWSDIfBaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfBaudRate.setDescription(' Defines the baud rate of use by the interface. The valid\n      rates are determined by the type of the media for which this\n      baud rate is defined.')
rsWSDIfCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfCost.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfCost.setDescription('This variable assigns a transmission cost to the interface\n        (channel or LAN). These costs are used in Level II routing. The\n        costs aretypically inversly proportional to the channel quality.')
rsWSDIfCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfCompression.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfCompression.setDescription('Defines whether data compression is enabled or disabled for the\n       interface.')
rsWSDIfCompressionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("not-inserted", 1), ("active", 2), ("not-active", 3), ("disable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfCompressionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfCompressionStatus.setDescription('Defines the status of the compression component:\n        not-inserted - Compression component is not in the device\n        active -     Compression is enabled and operates correctly\n        not-active - Compression is enables but does not operate.\n                     The reason may be that there is no compression\n                     component on the device connected to this interface.\n        disabled   - Compression was disabled by management, using\n                     variable rndCompression.')
rsWSDIfCompressionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfCompressionRate.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfCompressionRate.setDescription('Percentage of compression. This variable applies only\n  if rndCompressionStatus is active.')
rsWSDIfLATCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfLATCompression.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfLATCompression.setDescription('Enable/Disable the LAT Compression.')
rsWSDIfCompressionType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("lowSpeed", 2), ("highSpeed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDIfCompressionType.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfCompressionType.setDescription('This parameter indicates the type of compression option available in the device.\n         none(1)     - indicates that there is no compression option in the device\n         lowSpeed(2) - indicates a compression option which is  operational up\n                       to line speed sof 64 kbps.\n         highSpeed(3)- indicates a compression option which is  operational up\n                       to line speeds of 2 Mbps.')
rsWSDIfFilterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("destinationOnly", 1), ("sourceAndDestination", 2), ("none", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfFilterMode.setDescription('This parameter indicates the type of filtering in the device. ')
rsWSDIfChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("wanChannel", 1), ("ogRanPort", 2), ("routerToBridge", 3), ("spsFramRelay", 4), ("dialBackup", 5), ("snar", 6), ("lan", 7), ("spsX25", 8), ("frameRelay1490", 9), ("frameRelay1490CAR", 10), ("frameRelayCAR", 11), ("ppp", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfChannelType.setDescription(' The type of the WAN channel ')
rsWSDIfBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDIfBridge.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDIfBridge.setDescription(' This variable indicates  whether this interface forward Layer II pakages.')
rsWSDHighPriorityIf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDHighPriorityIf.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDHighPriorityIf.setDescription(' This variable indicates  whether this interface will forward pakages\n        that fit HighPriority set by the manager.')
rsWSDWanHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("regular", 1), ("short", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWanHeader.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWanHeader.setDescription(" This variable indicates the RND WAN header type used for frames\n          which pass through this interface. 'regular' specifies a 14 bytes\n          header compatible with older OG versions and 'short' a 4 byte header\n          compatible with the RND adapter product family.")
rsWSDDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 41, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("half", 1), ("full", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDDuplexMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDDuplexMode.setDescription(' This variable indicates whether this interface operates in half duplex\n          full duplex or auto negotiation mode.')
rsWSDClientMirrorPercentage = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDClientMirrorPercentage.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDClientMirrorPercentage.setDescription('The percent of client entries to back up.')
rsWSDMirrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDMirrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDMirrorStatus.setDescription('Enable/Disable mirroring. This enables the allocation of the mirror tables.')
rsWSDMirrorProtocolMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDMirrorProtocolMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDMirrorProtocolMode.setDescription('Enable/Disable of the mirror protocol. That is whether to send the mirror\n       messages.')
rsWSDApplicationMirrorTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 45), )
if mibBuilder.loadTexts: rsWSDApplicationMirrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDApplicationMirrorTable.setDescription('Table containing the list of active mirror entries.')
rsWSDApplicationMirrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 45, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDMirrorActiveAddress"))
if mibBuilder.loadTexts: rsWSDApplicationMirrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDApplicationMirrorEntry.setDescription('The row definition for this table.')
rsWSDMirrorActiveAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 45, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDMirrorActiveAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDMirrorActiveAddress.setDescription('The IP address of the active device.')
rsWSDMirrorActiveStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 45, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDMirrorActiveStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDMirrorActiveStatus.setDescription('This variable indicates the administrative status of this entry.\n        Used to delete an entry of this table.')
rsWSDClientMirrorPollingTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDClientMirrorPollingTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDClientMirrorPollingTime.setDescription('The polling time for sending the client entries.')
rsPlatformIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("vgate", 1), ("vgfe", 2), ("onecpu", 3), ("onecpuh", 4), ("boomer", 5), ("cougar", 6), ("argo", 7), ("kitty", 8), ("voyager", 9), ("galaxy", 10), ("ninia", 11), ("mecong", 12), ("congo", 13), ("ods1", 14), ("ods2", 15), ("ods3", 16), ("ods3S1", 17), ("ods3S2", 18), ("vl", 19), ("ods-ht", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPlatformIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: rsPlatformIdentifier.setDescription('An administratively-assigned value that identifies managed device platform.')
rsConfigurationIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("twoPorts", 1), ("fourPorts", 2), ("fixed-2", 3), ("fixed-8", 4), ("fixed-8-2", 5), ("fixed-16-5", 6), ("chassis", 7), ("fixed-7", 8), ("fixed-16-7-1", 9), ("fixed-9-1", 10), ("fixed-8cg-9fg-2fxg", 11), ("fixed-12cg-8fg", 12), ("fixed-3cg", 13), ("fixed-4-2", 14), ("fixed-12-4-2", 15), ("fixed-2-8-9", 16), ("fixed-4-4-8-2", 17), ("fixed-4-8-2", 18), ("fixed-6", 19), ("fixed-6-2", 20), ("fixed-4-20-2", 21)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsConfigurationIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: rsConfigurationIdentifier.setDescription('An administratively-assigned value that identifies managed device configuration.\n         cg - copper gig, fg - fiber gig, fxg - fiber 10gig.')
rsSWPasswordStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("statusUnset", 1), ("passwordOK", 2), ("wrongPassword", 3))).clone('statusUnset')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSWPasswordStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSWPasswordStatus.setDescription('Software download password status.')
rsWSDFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDFlashSize.setDescription('Flash Size')
rsWSDDRAMSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDDRAMSize.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDDRAMSize.setDescription('DRAM Size')
rsWSDVLANRedundOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("blockBroadcast", 1), ("forwardTraffic", 2), ("blockAll", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDVLANRedundOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDVLANRedundOperStatus.setDescription('Sets the backup redundant device for a VLAN.\n     blockBroadcast - blocks only the broadcast traffic\n     forwardTraffic - forwards the traffic\n     blockAll - blocks broadcast and unicast traffic')
rsWSDResourceUtilization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDResourceUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDResourceUtilization.setDescription('Resource Utilization of WSD. Considers network utilization and internal CPU utilization')
rsWSDRSResourceUtilization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDRSResourceUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDRSResourceUtilization.setDescription('Resource Utilization of internal CPU utilization')
rsWSDREResourceUtilization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDREResourceUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDREResourceUtilization.setDescription('Resource Utilization of network utilization')
rsWSDBuildNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 56), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDBuildNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDBuildNumber.setDescription('Build number')
rsWSDUseOneTrap = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDUseOneTrap.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDUseOneTrap.setDescription('When enabled, a single trap is used to indicate server failure. When disabled,\n        continuous traps are sent.')
rsWSDSecuredComm = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 58))
rsWSDSCProtcolsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 58, 1), )
if mibBuilder.loadTexts: rsWSDSCProtcolsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSCProtcolsTable.setDescription('Table containing the list of ports/protocols for secured (encrypted)\n       communication between the device and the management station or other device.')
rsWSDSCProtcolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 58, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDSCProtocol"))
if mibBuilder.loadTexts: rsWSDSCProtcolsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSCProtcolsEntry.setDescription('The row definition for protocol table.')
rsWSDSCProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 58, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("snmp", 1), ("tftp", 2), ("lrp", 3), ("prp", 4), ("srp", 5), ("mirror", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSCProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSCProtocol.setDescription('The protocol that should work in secured mode.')
rsWSDSCProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 58, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("encrypted", 1), ("notEncrypted", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSCProtocolStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSCProtocolStatus.setDescription('The status (secured or not secured) of the protocol.')
rsWSDSNMPPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 59), )
if mibBuilder.loadTexts: rsWSDSNMPPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPortsTable.setDescription('The table contains all the physical ports. Each port can be set to\n       allow/block SNMP operations to the device.')
rsWSDSNMPPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDSNMPPhysicalPortNumber"))
if mibBuilder.loadTexts: rsWSDSNMPPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPortsEntry.setDescription('Row definition for the table.')
rsWSDSNMPPhysicalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortNumber.setDescription('Physical port number.')
rsWSDSNMPPhysicalPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortState.setDescription('enable - accept SNMP operations on the physical port. disable -\n     ignore SNMP opertaions on the physical port.')
rsWSDSNMPPhysicalPortTelnetState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortTelnetState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortTelnetState.setDescription('enable - accept Telnet operations on the physical port. disable -\n     ignore Telnet opertaions on the physical port.')
rsWSDSNMPPhysicalPortSSHState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortSSHState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortSSHState.setDescription('enable - accept SSH operations on the physical port. disable -\n     ignore SSH opertaions on the physical port.')
rsWSDSNMPPhysicalPortWebState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortWebState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortWebState.setDescription('enable - accept Web operations on the physical port. disable -\n     ignore Web opertaions on the physical port.')
rsWSDSNMPPhysicalPortSSLState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 59, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortSSLState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSNMPPhysicalPortSSLState.setDescription('enable - accept SSL operations on the physical port. disable -\n     ignore SSL opertaions on the physical port.')
rsSendPortUnreachableStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 175), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSendPortUnreachableStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSendPortUnreachableStatus.setDescription("enable - send port unreachable (UDP) or reset (TCP) when port not available. disable -\n     don't send a response, just discard the received packet.")
rsBWM = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 60))
rsWSDTelnetUserTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 61), )
if mibBuilder.loadTexts: rsWSDTelnetUserTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserTable.setDescription('A table containing the users authorized to use TELNET.')
rsWSDTelnetUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDTelnetUserName"))
if mibBuilder.loadTexts: rsWSDTelnetUserEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserEntry.setDescription('Information about a particular Telnet user.')
rsWSDTelnetUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserName.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserName.setDescription('User Name.')
rsWSDTelnetUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserPassword.setDescription('User password.')
rsWSDTelnetUserEAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserEAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserEAddr.setDescription('User email address.')
rsWSDTelnetUserSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("info", 2), ("warning", 3), ("error", 4), ("fatal", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserSeverity.setDescription('minimum failure severity to be notified by mail')
rsWSDTelnetUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserStatus.setDescription('Entry status')
rsWSDTelnetUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserGroup.setDescription('The group to which that user belongs.')
rsWSDTelnetUserConfigurationTraceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserConfigurationTraceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserConfigurationTraceStatus.setDescription('enable mail trace of configuration change')
rsWSDTelnetUserConfigurationTraceInf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("webBased", 2), ("terminal", 3), ("snmp", 4), ("telnetSSH", 5), ("ftp", 6), ("ftpSSH", 7))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserConfigurationTraceInf.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserConfigurationTraceInf.setDescription('specify configuration interfaces via which changes in configuration should be informed')
rsWSDTelnetUserWebAccessLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("readwrite", 1), ("readonly", 2), ("none", 3))).clone('readwrite')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserWebAccessLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserWebAccessLevel.setDescription('Defines access level for web based management. Either read-write, read-only or no access.')
rsWSDTelnetUserSshPublicKeyName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 61, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetUserSshPublicKeyName.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetUserSshPublicKeyName.setDescription('The name of the Certificate Entry where the ssh public key resides.')
rsWSDTelnetParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 62))
rsWSDTelnetPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 62, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetPort.setDescription('The Telnet Server Port.')
rsWSDTelnetStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 62, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDTelnetStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDTelnetStatus.setDescription('Telnet Status. Enable/Disable Telnet Terminal operation.')
rsSSD = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 63))
rsSSDvirtualLan = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1))
rsSSDvirtualLanTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1), )
if mibBuilder.loadTexts: rsSSDvirtualLanTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvirtualLanTable.setDescription('An entry of this table specifies an new ifIndex with a type of\n          propVirtual(53).')
rsSSDvirtualLanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsSSDvlIfIndex"))
if mibBuilder.loadTexts: rsSSDvirtualLanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvirtualLanEntry.setDescription('A list of information for each virtual LAN.')
rsSSDvlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlIfIndex.setDescription('An logical interface number, corresponded this VL')
rsSSDvlProto = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("ip", 2), ("ipmulticast", 3), ("ipxRaw", 4), ("ipxET", 5), ("ipxLLC", 6), ("ipxSNAP", 7), ("decNET", 8), ("decLAT", 9), ("netBios", 10), ("appleTalk", 11), ("xns", 12), ("sna", 13), ("userDefined", 14), ("swVlan", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlProto.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlProto.setDescription("The protocol, supported by this VL. The meanings of the values are:\n      other: none of the following. This VL includes any protocol except the\n             following protocols. It  is a bridging VL. RS relies on\n             a third-party router to exchange traffic between nodes on different\n             virtual LANs of this type.\n      IP:    This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      IPmulticast: RS will broadcast the message to all  the VL's ports. Used for\n             video-conferencing applications.\n      ipxRaw: This is a Routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxET: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxLLC: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      ipxSNAP: This is a routing VL, RS will route between nodes on\n             different virtual LANs.\n      decNET: This is a bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different DECnet virtual\n             LANs of this type.\n      netBios: This is a Bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different NetBIOS virtual\n             LANs of this type.\n      appleTalk: This is a bridging VL, RS relies on a third-party router\n             to exchange traffic between nodes on different AppleTalk virtual\n             LANs of this type.\n      swVlan: This is a Bridging and routing VL (switch VL) , Bridging is\n             done on the Hertz/Uhaul level , and the RS route between nodes on\n             different virtual LANs and/or between nodes of the switch VL.")
rsSSDvlAutoConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlAutoConfigEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlAutoConfigEnable.setDescription("It is used only in the case of IP. The meanings of the values are:\n      true(1):  Autolearning is used for this VL\n      false(2): Autolearning isn't used for this VL from ports, specified in\n                the table virtualLanAutoConfTable.")
rsSSDvlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlStatus.setDescription('It is used to delete an entry')
rsSSDvlType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("regular", 1), ("specBroadcast", 2), ("specArpReq", 3), ("specBroadcastAndUnicast", 4), ("specArpReqAndUnicast", 5), ("specSwitch", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlType.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlType.setDescription("regular       - ordinary type\n        specBroadcast - for switches that support VLANs as a set of ports and\n                        only as a broadcast domain: broadcast frames do not\n                        cross VLAN's bounders, but unicast frames may be\n                        transmitted between different VLANs. Permits passing\n                        of broadcast frames between Vgate's VLANs.\n        specArpReq -    for switches that support VLANs as a set of ports and\n                        only as a broadcast domain: broadcast frames do not\n                        cross VLAN's bounders, but unicast frames may be\n                        transmitted between different VLANs. Permits passing\n                        of ARP request frames between Vgate's VLANs.\n        specBroadcastAndUnicast -\n                        for switches that support VLANs as a set of ports\n                        but no frame crosses VLAN's bounders. Permits passing\n                        of IP/ARP request broadcast and IP unicast frames\n                        between Vgate's VLANs.\n        specArpReqAndUnicast -\n                        for switches that support VLANs as a set of ports\n                        but no frame crosses VLAN's bounders. Permits passing\n                        of ARP request broadcast and IP unicast frames between\n                        Vgate's VLANs. This type can be used only for IP VLANs.\n\tspecSwitch -\n        \t\tfor switches that support VLANs as a set of ports.\n                        This VLAN type is for switching when packets do not have\n                        to get to the cpu except when an IP interface defined on the VLAN.\n                        In Switch VLAN the cpu don't interfere in the bridging action\n                        this is done on the Herzts level (L2).")
rsSSDvlTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlTag.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlTag.setDescription("A VLAN tag, used for this VLAN on tagged ports.\n          If it's 0, then a value of (rsSSDvlIfIndex-100000+1) is used")
rsSSDvlPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlPriority.setDescription('A user priority, used for this VLAN on tagged ports.')
rsSSDvlUpCriterion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defaultByType", 1), ("onePort", 2), ("allPorts", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlUpCriterion.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlUpCriterion.setDescription('The criterion according to which the vlan interface is considered to be up \n\t\t  for interface grouping.')
rsSSDvlDownCriterion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defaultByType", 1), ("onePort", 2), ("allPorts", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvlDownCriterion.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvlDownCriterion.setDescription('The criterion according to which the vlan interface is considered to be down \n\t\t  for interface grouping.')
rsSSDvirtualLanPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2), )
if mibBuilder.loadTexts: rsSSDvirtualLanPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvirtualLanPortsTable.setDescription('For each VL (a ifIndex with a type of propVirtual(53)) an entry of  this\n           table specifies a set of ports, which it contains.')
rsSSDvirtualLanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rsSSDvLIfIndex"), (0, "RADWARE-MIB", "rsSSDvLPortIfIndex"))
if mibBuilder.loadTexts: rsSSDvirtualLanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvirtualLanPortEntry.setDescription('A entry of this table specifies a  VL and a port belonging to it')
rsSSDvLIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvLIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLIfIndex.setDescription('An logical interface number, corresponding to this VL')
rsSSDvLPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvLPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLPortIfIndex.setDescription('A physical port belonging to the VL specified by rsSSDvlIfIndex.')
rsSSDvLPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsSSDvLPortType.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLPortType.setDescription('static means configured by user dynamic means autoconfigured by the RS')
rsSSDvLPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvLPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLPortStatus.setDescription('It is used to delete an entry')
rsSSDvLPortTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untag", 1), ("tag", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvLPortTag.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLPortTag.setDescription('This variable indicate if the port is tagged or untagged ')
rsSSDvLPortInterfaceGroupingState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 63, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSDvLPortInterfaceGroupingState.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSDvLPortInterfaceGroupingState.setDescription('included- the port effects the VLAN Up/Down decision for interface grouping. \n     excluded- the port does not effect the VLAN Up/Down decision for interface grouping.')
rsWSDThresholdWarnings = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 64))
rsWSDThreshTrapFloodDelay = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 64, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDThreshTrapFloodDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDThreshTrapFloodDelay.setDescription('This variable defines how far (in seconds) will 2 Threshold Warning Traps be\n        spaced for the same Threshold Warning Type. Default = 0, i.e. DISABLED')
rsWSDCriticalTrapFloodDelay = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 64, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDCriticalTrapFloodDelay.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDCriticalTrapFloodDelay.setDescription('This variable defines how far (in seconds) will 2 Critical Warning Traps be\n        spaced (of any type). Default = 20 seconds.')
rsIDS = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 65))
rsWSDLicense = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 66), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDLicense.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDLicense.setDescription('The new licence for the device')
rsErrMailParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 67))
rsErrMailEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 67, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsErrMailEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsErrMailEnable.setDescription('Send email on errors enable')
rsErrMailGateway = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 67, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsErrMailGateway.setStatus('mandatory')
if mibBuilder.loadTexts: rsErrMailGateway.setDescription('primary SMTP gateway for error mail')
rsErrMailSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 67, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsErrMailSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsErrMailSrcAddress.setDescription('source address to be used by device for outgoing mail')
rsErrMailToFieldText = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 67, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsErrMailToFieldText.setStatus('mandatory')
if mibBuilder.loadTexts: rsErrMailToFieldText.setDescription("Display name in 'TO:' field used by device for outgoing \n\t mail. When empty the text in the To field is generated \n\t by the device according to the message severity.")
rsWSDWebParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 68))
rsWSDWebPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebPort.setDescription('The Web Server Port.')
rsWSDWebStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebStatus.setDescription('Web Status. Enable/Disable Web operation.')
rsWSDWebHelpLocation = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebHelpLocation.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebHelpLocation.setDescription('Location of the help files directory.')
rsWSDWebSSLPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(443)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLPort.setDescription('SSL Port')
rsWSDWebSSLStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLStatus.setDescription('Web SSL Status. Enable/Disable Web SSL operation.')
rsWSDWebSSLPrivateKeyFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLPrivateKeyFile.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLPrivateKeyFile.setDescription('File name of the private key file used by the web server.')
rsWSDWebSSLCertificateFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLCertificateFile.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLCertificateFile.setDescription('File name of the certificate file used by the web server.')
rsWSDWebSSLCaFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLCaFile.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLCaFile.setDescription('File name of the CAfile used by the web server.')
rsWSDWebSSLCaPath = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLCaPath.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLCaPath.setDescription('Directory where the CA certificates are stored.')
rsWSDWebSSLClientAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("password", 1), ("certificate", 2))).clone('password')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLClientAuthentication.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLClientAuthentication.setDescription('Type of client authentication.')
rsWSDWebAccessLevel = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2))).clone('readWrite')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebAccessLevel.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebAccessLevel.setDescription('Determines whether web server allows read-only or also write access. In read-only mode some\n         pages will not be available.')
rsWSDWebSoapSupportStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSoapSupportStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSoapSupportStatus.setDescription('Whether the devices support of web services is enabled or not.')
rsWSDWebSSLWeakCiphersSupportStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 68, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDWebSSLWeakCiphersSupportStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDWebSSLWeakCiphersSupportStatus.setDescription('Determines whether the secure web server allows SSL connections using weak ciphers security access.')
rsWSDSysParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 69))
rsWSDSysFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSysFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSysFlashSize.setDescription('The flash size of the device in mega bytes.')
rsWSDSysUpTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDSysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSysUpTime.setDescription('Time since the system was last reinitialized in a convenient format.')
rsWSDSysManagedTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSysManagedTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSysManagedTime.setDescription('The time will be sent in the format hh:mm:ss')
rsWSDSysManagedDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSysManagedDate.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSysManagedDate.setDescription('The date will be sent in the format dd/mm/yyyy')
rsWSDSysBaseMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSysBaseMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSysBaseMACAddress.setDescription('Base MAC address of the device')
rdwrDualPowerSupplyParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 6))
rdwrPowerSupply1Status = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrPowerSupply1Status.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPowerSupply1Status.setDescription('Status of power supply 1. Relevant only for dual power supply devices.\n     On single power supply devices the status returned is invalid.')
rdwrPowerSupply2Status = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrPowerSupply2Status.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPowerSupply2Status.setDescription('Status of power supply 2. Relevant only for dual power supply devices.\n     On single power supply devices the status returned is invalid.')
rdwrPowerSupplyTrapStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 6, 3), FeatureStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrPowerSupplyTrapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPowerSupplyTrapStatus.setDescription('Enables the user to disable the sending of traps for the power supply status')
rdwrPowerSupplyStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 69, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singlePowerSupplyOk", 1), ("firstPowerSupplyFailed", 2), ("secondPowerSupplyFailed", 3), ("doublePowerSupplyOk", 4), ("unknownPowerSupplyFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPowerSupplyStatus.setDescription('The status of the power supply')
rsWSDLicenseID = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 70), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDLicenseID.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDLicenseID.setDescription('License ID used for license downgrade')
rsWSDSendFakeArp = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSendFakeArp.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSendFakeArp.setDescription("Controls whether a backup will send a fake ARP, advertising the main box's\n         interfaces and VIPs, when the main box returns to service.")
rsWSDNTP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 72))
rsWSDNTPServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPServerAddr.setDescription('Server IP address.')
rsWSDNTPInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPInterval.setDescription('Time update interval.')
rsWSDNTPStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPStatus.setDescription('Enable status for NTP synchronization.')
rsWSDNTPTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPTimeZone.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPTimeZone.setDescription('Offset from Greenwich time (format hh:mm).')
rsWSDNTPPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPPort.setDescription(' A UDP Port number.')
rsWSDNTPServerUrl = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 72, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDNTPServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDNTPServerUrl.setDescription('NTP Server URL or IP address.')
rsStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 73))
rsPhysPortMirrorTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 74), )
if mibBuilder.loadTexts: rsPhysPortMirrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorTable.setDescription('Table containing the list of copy ports ')
rsPhysPortMirrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1), ).setIndexNames((0, "RADWARE-MIB", "rsPhysPortMirrorSrcInf"), (0, "RADWARE-MIB", "rsPhysPortMirrorDstPort"))
if mibBuilder.loadTexts: rsPhysPortMirrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorEntry.setDescription(' The row definition for physical copy port table.')
rsPhysPortMirrorSrcInf = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorSrcInf.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorSrcInf.setDescription('The port under sniffing')
rsPhysPortMirrorDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorDstPort.setDescription('The destination port - the target sniffer port')
rsPhysPortMirrorRxTx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("copyRxTx", 1), ("copyRxOnly", 2), ("copyTxOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorRxTx.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorRxTx.setDescription('Copy Rx/Tx traffic to the copy port .')
rsPhysPortMirrorRxBroadCast = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorRxBroadCast.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorRxBroadCast.setDescription('The copy will include broadcast/unknown or not')
rsPhysPortMirrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorStatus.setDescription('Used to delete an entry of this table.')
rsPhysPortMirrorBackupDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorBackupDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorBackupDstPort.setDescription('The destination port - the target sniffer port')
rsPhysPortMirrorDstStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("portDown", 2), ("checkIDSFail", 3), ("checkIDSFailAndPortDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorDstStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorDstStatus.setDescription('The status of the dest-port according to the health check:\n        active - the port is ok and can be used as a destination port for copy-port\n        portDown - the port has been recognized as physically DOWN and therefore the traffic\n                            will not be copied to this port until it will be recognized as physically UP\n        checkIDSFail - the connectivty check of the monitoring port of the IDS failed and therefore\n                        the traffic will not be copied to this port until the check will recognize differently\n        checkIDSFailAnd PortDown - both the connectivty check on the IDS failed and the port has\n                        been recognized as physically DOWN.')
rsPhysPortMirrorBackupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("active", 1), ("portDown", 2), ("checkIDSFail", 3), ("checkIDSFailAndPortDown", 4), ("none", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorBackupStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorBackupStatus.setDescription(' The status of the backup-port according to the health check:\n        Active - the port is ok and can be used as a destination port for copy-port\n        PortDown - the port has been recognized as physically DOWN and therefore the traffic\n                            will not be copied to this port until it will be recognized as physically UP\n        CheckIDSFail - the connectivty check of the monitoring port of the IDS failed and therefore\n                        the traffic will not be copied to this port until the check will recognize differently\n        CheckIDSFailAnd PortDown - both the connectivty check on the IDS failed and the port has\n                        been recognized as physically DOWN\n         None - for the case there is no defined backup port.')
rsPhysPortMirrorActiveDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dstPort", 1), ("backupPort", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorActiveDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorActiveDstPort.setDescription('The active dest-port at a certain time, if it is the dest-port or the backup-port or none of\n        them.')
rsPhysPortMirrorMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("traffic-rate", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorMode.setDescription('Always copy or copy according to threshold ')
rsPhysPortMirrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorThreshold.setDescription('The copy threshold ')
rsPhysPortMirrorThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 74, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("waiting", 1), ("active", 2), ("elapsed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdStatus.setDescription('The threshold status ')
rsPhysPortMirrorThresholdUnits = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pps", 1), ("kbps", 2))).clone('pps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdUnits.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdUnits.setDescription('Units used to measure port-mirroring threshold.')
rsPhysPortMirrorThresholdInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 127), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdInterval.setDescription('Time interval in which port mirroring will be active, if the mode is threshold')
rsPhysPortMirrorThresholdReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 128), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("no-reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdReset.setStatus('mandatory')
if mibBuilder.loadTexts: rsPhysPortMirrorThresholdReset.setDescription('Reset the port mirroring threshold')
rsCP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 75))
rsVWSD = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 76))
rsVWSDDataPermissionsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1), )
if mibBuilder.loadTexts: rsVWSDDataPermissionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDDataPermissionsTable.setDescription('Table containing the list of data items to which Farm administrators\n    of the virtual wsd has permissions.')
rsVWSDDataPermissionsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsVWSDUserGroup"), (0, "RADWARE-MIB", "rsVWSDDataType"), (0, "RADWARE-MIB", "rsVWSDDataItems"))
if mibBuilder.loadTexts: rsVWSDDataPermissionsTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDDataPermissionsTableEntry.setDescription(' The row definition for this table.')
rsVWSDUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsVWSDUserGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDUserGroup.setDescription('The Group of users for whom data permission is given.')
rsVWSDDataType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsVWSDDataType.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDDataType.setDescription('Holds a string that identifies the table of the index by which the\n    data filtering is done.')
rsVWSDDataItems = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsVWSDDataItems.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDDataItems.setDescription('The Value(s) of the index column for the data item to which permission is set.')
rsVWSDDataStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 76, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsVWSDDataStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsVWSDDataStatus.setDescription('The row status for the table')
rsWSDManagementPorts = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("outOfPath", 1), ("switch", 2), ("promiscuous", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDManagementPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDManagementPorts.setDescription('The entry indicates the functionality of the device.\n    outOfPath implies that the device will be able to have a management\n    port, and the rest of the ports will be used for sniffing. switch\n    implies the regular functionality of the device (router or VLAN).\n    promiscuous will have static port mappings for forwarding.')
rsWSDManagementPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 78), )
if mibBuilder.loadTexts: rsWSDManagementPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDManagementPortsTable.setDescription('Table containing the operation of each port..')
rsWSDManagementPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 78, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDPortIndex"))
if mibBuilder.loadTexts: rsWSDManagementPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDManagementPortsEntry.setDescription('The row definition for this table.')
rsWSDPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 78, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPortIndex.setDescription('The index of the physical ports.')
rsWSDPortOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 78, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("management", 1), ("sniffer", 2))).clone('sniffer')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDPortOperation.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPortOperation.setDescription('The operation of the particular port.')
rsCCK = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 79))
rsWSDSshParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 80))
rsWSDSshPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 80, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSshPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSshPort.setDescription('The SSH Server Port.')
rsWSDSshStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 80, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSshStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSshStatus.setDescription('SSH Status. Enable/Disable SSH operation.')
rsWSDSshAllowPwdAndPubKey = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 80, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSshAllowPwdAndPubKey.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSshAllowPwdAndPubKey.setDescription('SSH allow the use of password for user with public key.')
rsWSDHttpsParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 81))
rsWSDHttpsPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 81, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDHttpsPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDHttpsPort.setDescription('The Https Server Port.')
rsWSDHttpsStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 81, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDHttpsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDHttpsStatus.setDescription('Https Status. Enable/Disable Https operation.')
rsWSDStaticForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 82), )
if mibBuilder.loadTexts: rsWSDStaticForwardingTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticForwardingTable.setDescription('Table containing the static fowarding configration.')
rsWSDStaticForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDStaticSourcePort"))
if mibBuilder.loadTexts: rsWSDStaticForwardingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticForwardingEntry.setDescription('The row definition for this table.')
rsWSDStaticSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDStaticSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticSourcePort.setDescription('The index of the source port.')
rsWSDStaticDestinationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDStaticDestinationPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticDestinationPort.setDescription('The destination port.')
rsWSDStaticPortOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("process", 1), ("forward", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDStaticPortOperation.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticPortOperation.setDescription('The operation for the specific port. process implies that the packets\n      will be processed (analyzed, filtered etc.) prior to being forwarded.\n      forward implies that the packets will be forwarded.')
rsWSDStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDStaticStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticStatus.setDescription('This variable indicates the administrative status of this entry.\n        Used to delete an entry of this table.')
rsWSDStaticFailureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fail-close", 1), ("fail-open", 2))).clone('fail-open')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDStaticFailureMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticFailureMode.setDescription('The link state in case the device fails.\n        fail-open: allow traffic to continue to flow unimpeded\n        fail-close: traffic is blocked.')
rsWSDStaticInPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 82, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("source", 1), ("destination", 2))).clone('source')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDStaticInPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDStaticInPort.setDescription('This field is needed for Apsolute Vision.')
rsRadiusServer = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 83))
rsRadiusMainServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusMainServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusMainServerAddr.setDescription('The IP Address of the radius main server.')
rsRadiusMainServerPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusMainServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusMainServerPort.setDescription('The port on which the radius main server listens')
rsRadiusMainServerSecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusMainServerSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusMainServerSecret.setDescription("The key with which the user's password is encrypted.")
rsRadiusBackupServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusBackupServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusBackupServerAddr.setDescription('The IP Address of the backup radius server.')
rsRadiusBackupServerPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusBackupServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusBackupServerPort.setDescription('The port on which the radius backup server listens')
rsRadiusBackupServerSecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusBackupServerSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusBackupServerSecret.setDescription("The key with which the user's password is encrypted.")
rsAuthenticationMethod = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("userTable", 1), ("radius", 2), ("radiusAndUserTable", 3), ("tacacsAndUserTable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsAuthenticationMethod.setStatus('mandatory')
if mibBuilder.loadTexts: rsAuthenticationMethod.setDescription('Radius authentication method.')
rsRadiusServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusServerTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusServerTimeout.setDescription('Number of seconds to wait for reply from the radius server before\n\t   retransmitting the request.')
rsRadiusServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusServerRetries.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusServerRetries.setDescription('Minimal number of unanswered request attempts before considering the radius\n\t   server disconnected.')
rsLockUserAfterLoginFailure = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLockUserAfterLoginFailure.setStatus('mandatory')
if mibBuilder.loadTexts: rsLockUserAfterLoginFailure.setDescription('Number of failed access attempts after which the user is locked out and cannot\n       manage the device. 0 - never lock users.')
rsRadiusClientLifeTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusClientLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusClientLifeTime.setDescription('Number of seconds for which radius authentication replies are cached. During this\n       time the device will use the cached response and not issue authentication\n       requests for the user.')
rsRadiusMainServerUrl = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusMainServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusMainServerUrl.setDescription('The URL or IP Address of the radius main server.')
rsRadiusBackupServerUrl = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRadiusBackupServerUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsRadiusBackupServerUrl.setDescription('The URL or IP Address of the backup radius server.')
rspRadiusParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14))
rspRadiusPrimaryAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusPrimaryAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusPrimaryAddr.setDescription('Primary Radius server URL or IP address.')
rspRadiusPrimaryAuthPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusPrimaryAuthPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusPrimaryAuthPort.setDescription('Primary Radius server authentication port.')
rspRadiusPrimaryAccPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusPrimaryAccPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusPrimaryAccPort.setDescription('Primary Radius server accounting port.')
rspRadiusPrimarySecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusPrimarySecret.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusPrimarySecret.setDescription('CID and Primary Radius shared secret')
rspRadiusAltAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusAltAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusAltAddr.setDescription('Alternate Radius server URL or IP address.')
rspRadiusAltAuthPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusAltAuthPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusAltAuthPort.setDescription(' Alternate Radius server authentication port.')
rspRadiusAltAccPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusAltAccPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusAltAccPort.setDescription(' Alternate Radius server accounting port.')
rspRadiusAltSecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusAltSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusAltSecret.setDescription('CID and Alternate Radius shared secret')
rspRadiusOwnAuthPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusOwnAuthPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusOwnAuthPort.setDescription('Own Radius proxy authentication port.')
rspRadiusOwnAccPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusOwnAccPort.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusOwnAccPort.setDescription('Own Radius proxy accounting port.')
rspRadiusEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusEnable.setDescription('Proxy Radius resolution enable.')
rspRadiusTransparentEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusTransparentEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusTransparentEnable.setDescription('Proxy Radius transparent mode resolution enable.')
rspRadiusRuleTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13), )
if mibBuilder.loadTexts: rspRadiusRuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusRuleTable.setDescription('The attribute action table')
rspRadiusRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13, 1), ).setIndexNames((0, "RADWARE-MIB", "rspRadiusattId"), (0, "RADWARE-MIB", "rspRadiusattValue"), (0, "RADWARE-MIB", "rspRadiusNetworkName"))
if mibBuilder.loadTexts: rspRadiusRuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusRuleEntry.setDescription(' The row definition for this table.')
rspRadiusattId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rspRadiusattId.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusattId.setDescription('Attribute ID of the message to/from the RADIUS')
rspRadiusattValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rspRadiusattValue.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusattValue.setDescription('Attribute value of the message to/from the RADIUS')
rspRadiusNetworkName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rspRadiusNetworkName.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNetworkName.setDescription('The name of the network that the rule applied to')
rspRadiusrowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 13, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusrowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusrowStatus.setDescription('Administrative status.')
rspRadiusNasTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 14), )
if mibBuilder.loadTexts: rspRadiusNasTable.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNasTable.setDescription('The NAS IP/Secret table')
rspRadiusNasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 14, 1), ).setIndexNames((0, "RADWARE-MIB", "rspRadiusNasIp"))
if mibBuilder.loadTexts: rspRadiusNasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNasEntry.setDescription(' The row definition for this table.')
rspRadiusNasIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 14, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rspRadiusNasIp.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNasIp.setDescription('The IP of this NAS')
rspRadiusNasSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 14, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusNasSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNasSecret.setDescription('The secret of this NAS')
rspRadiusNasrowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 14, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusNasrowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNasrowStatus.setDescription('Administrative status.')
rspRadiusUserMirrorProtocolMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusUserMirrorProtocolMode.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusUserMirrorProtocolMode.setDescription('The status of the mirroring for Radius proxy.')
rspRadiusUserMirrorPollingTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 16), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusUserMirrorPollingTime.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusUserMirrorPollingTime.setDescription('The polling time of the Radius users table.')
rspRadiusNetworkUpdatePolicy = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 83, 14, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("replace", 1), ("add", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rspRadiusNetworkUpdatePolicy.setStatus('mandatory')
if mibBuilder.loadTexts: rspRadiusNetworkUpdatePolicy.setDescription('Define the way the device treats new user network. \n      Replace - the device replaces current network and update the user policy. \n      Add -the device adds the network to the user entry. \n      The device supports up to fine simultaneous networks for each entry ')
rsTacacsServer = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 180))
rsTacacsPrimaryServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsPrimaryServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsPrimaryServerAddr.setDescription('Defines the primary TACACS+ server address.')
rsTacacsPrimaryServerSecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsPrimaryServerSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsPrimaryServerSecret.setDescription('Defines the shared secret between the switch and the primary TACACS+ server.')
rsTacacsPrimaryServerPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000)).clone(49)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsPrimaryServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsPrimaryServerPort.setDescription('The port on which the TACACS+ primary server listens.')
rsTacacsSecondaryServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsSecondaryServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsSecondaryServerAddr.setDescription('Defines the secondary TACACS+ server address.')
rsTacacsSecondaryServerSecret = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsSecondaryServerSecret.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsSecondaryServerSecret.setDescription('Defines the shared secret between the switch and the secondary TACACS+ server.')
rsTacacsSecondaryServerPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000)).clone(49)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsSecondaryServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsSecondaryServerPort.setDescription('The port on which the TACACS+ secondary server listens.')
rsTacacsServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsServerRetries.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsServerRetries.setDescription('Defines the number of failed authentication requests before switching to a different TACACS+ server. \n      The default is 3 requests.')
rsTacacsServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsServerTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsServerTimeout.setDescription('Defines the amount of time, in seconds, before a TACACS+ server authentication attempt is considered to have failed. \n      The default is 4 seconds.')
rsTacacsCommandLoggingStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 9), FeatureStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsCommandLoggingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsCommandLoggingStatus.setDescription('Enable/disable TACACS+ command logging. \n\tWhen enabled, device sends command log messages to TACACS+ server.')
rsTacacsCommandAuthorizationStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 10), FeatureStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsCommandAuthorizationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsCommandAuthorizationStatus.setDescription('Enable/disable TACACS+ command authorization.')
rsTacacsClientAging = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 180, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTacacsClientAging.setStatus('mandatory')
if mibBuilder.loadTexts: rsTacacsClientAging.setDescription('Number of seconds for which tacacs+ authentication and authorization replies are cached. During this\n       time the device will use the cached response and not issue requests for the user.')
rsIfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 84), )
if mibBuilder.loadTexts: rsIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfTable.setDescription('Device physical interface table')
rsIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1), ).setIndexNames((0, "RADWARE-MIB", "rsIfIndex"))
if mibBuilder.loadTexts: rsIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfEntry.setDescription('The row definition for this table')
rsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfIndex.setDescription("interface's index")
rsIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("auto", 0), ("eth10", 1), ("fe100", 2), ("ge1000", 3), ("xg10000", 4), ("qxg10000", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfSpeed.setDescription("interface's speed")
rsIfDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half", 1), ("full", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfDuplex.setDescription("interface's duplex")
rsIfAutoNegotiate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("auto", 0), ("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfAutoNegotiate.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfAutoNegotiate.setDescription("interface's autonegotiation status")
rsIfAutoNegotiateCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 84, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("auto", 0), ("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIfAutoNegotiateCfg.setStatus('mandatory')
if mibBuilder.loadTexts: rsIfAutoNegotiateCfg.setDescription("interface's autonegotiation status")
rsWSDDeviceOperationMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("trafficRedirection", 1), ("staticForwarding", 2), ("transparentForwarding", 3))).clone('trafficRedirection')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDDeviceOperationMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDDeviceOperationMode.setDescription('Device operation mode: redirection (load balancing) or static\n      forwarding (Dos Shield), or transparent forwarding (for IDS load\n      balancing).')
rsWSDVersionStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("final", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDVersionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDVersionStatus.setDescription('Indicates whether the current version is closed or still open (under development).')
rsWSDSyslogFacility = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("kernelMsg", 0), ("userLevelMsg", 1), ("mailSystem", 2), ("systemDaemons", 3), ("authorization", 4), ("syslogdMessages", 5), ("linePrinter", 6), ("networkNews", 7), ("uucp", 8), ("clockDaemon1", 9), ("security", 10), ("ftpDaemon", 11), ("ntpSubsystem", 12), ("logAudit", 13), ("logAlert", 14), ("clockDaemon2", 15), ("local0", 16), ("local1", 17), ("local2", 18), ("local3", 19), ("local4", 20), ("local5", 21), ("local6", 22), ("local7", 23))).clone('local6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogFacility.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogFacility.setDescription('The SYSLOG Priority value is calculated by multiplying the Facility\n       number by 8 and then adding the numerical value of the Severity.')
rsACC = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 88))
rsWSDPingPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 89), )
if mibBuilder.loadTexts: rsWSDPingPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPingPortsTable.setDescription('The table contains all the physical ports. Each port can be set to\n       allow/block Ping operations to the device.')
rsWSDPingPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 89, 1), ).setIndexNames((0, "RADWARE-MIB", "rsWSDPingPhysicalPortNumber"))
if mibBuilder.loadTexts: rsWSDPingPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPingPortsEntry.setDescription('Row definition for the table.')
rsWSDPingPhysicalPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 89, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDPingPhysicalPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPingPhysicalPortNumber.setDescription('Physical port number.')
rsWSDPingPhysicalPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 89, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDPingPhysicalPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDPingPhysicalPortState.setDescription('enable - accept Ping operations on the physical port. disable -\n     ignore Ping opertaions on the physical port.')
rsWSDBackupInterfaceGrouping = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDBackupInterfaceGrouping.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDBackupInterfaceGrouping.setDescription("When Backup Interface Grouping is enabled, the backup will take all interfaces when all of the main's\n         interfaces are down. It will also release all interfaces at the same time when all the main's are up.")
rsRegistrationStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("registered", 1), ("notRegistered", 2))).clone('notRegistered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRegistrationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsRegistrationStatus.setDescription('Indicates whether the device has been registered. The NMS is expected to set it after\n         successful registration.')
rsCT100 = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 92))
rsFloatingPacketOffset = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFloatingPacketOffset.setStatus('mandatory')
if mibBuilder.loadTexts: rsFloatingPacketOffset.setDescription('Indicates whether the incoming packet offset may be changed by the application. This is not needed in\n         most cases but is required for tagging of outgoing packets (802.1q) and packet encapsulation.')
rsDnsParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 94))
rsDnsrParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1))
rsDnsrPrimaryAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsrPrimaryAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrPrimaryAddr.setDescription('Primary DNS server IP address.')
rsDnsrAlternateAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsrAlternateAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrAlternateAddr.setDescription('Alternate DNS server IP address.')
rsDnsrEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsrEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrEnable.setDescription('DNS resolution enable.')
rsDnsrStaticResTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 4), )
if mibBuilder.loadTexts: rsDnsrStaticResTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrStaticResTable.setDescription('DNS Static resolution table. The table containing URL/IP Pairs.\n\t The DNS resolver use this table in the resolution process.')
rsDnsrStaticResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 4, 1), ).setIndexNames((0, "RADWARE-MIB", "rsDnsrSUrl"))
if mibBuilder.loadTexts: rsDnsrStaticResEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrStaticResEntry.setDescription(' The row definition for this table.')
rsDnsrSUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 49))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDnsrSUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrSUrl.setDescription('The URL string in the static URL/IP resolution table.')
rsDnsrSIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsrSIp.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrSIp.setDescription('The IP Address in the static URL/IP resolution table.')
rsDnsrSrowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 1, 4, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsrSrowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsrSrowStatus.setDescription('Administrative status.')
rsDnsServerParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2))
rsDnsServerEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsServerEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerEnable.setDescription('DNS server enable.')
rsDnsServerStaticResTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2), )
if mibBuilder.loadTexts: rsDnsServerStaticResTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerStaticResTable.setDescription('DNS Static resolution table. The table containing URL/IP Pairs.\n\t The DNS server use this table to look form farms IP.')
rsDnsServerStaticResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rsDnsServerSUrl"))
if mibBuilder.loadTexts: rsDnsServerStaticResEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerStaticResEntry.setDescription(' The row definition for this table.')
rsDnsServerSUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsDnsServerSUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerSUrl.setDescription('The URL string in the static URL/IP resolution table.')
rsDnsServerSIp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsServerSIp.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerSIp.setDescription('The IP Address in the static URL/IP resolution table.')
rsDnsServerSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsServerSEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerSEnable.setDescription('Mark if the entry is enabled for the DNS server.')
rsDnsServerSrowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 94, 2, 2, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsDnsServerSrowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsDnsServerSrowStatus.setDescription('Administrative status.')
rsPrivateCheckSNMPPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 95), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(161)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsPrivateCheckSNMPPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsPrivateCheckSNMPPort.setDescription('Destination SNMP port used for private and NT checks.')
rsVlanTagHandling = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("retain", 1), ("overwrite", 2))).clone('overwrite')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsVlanTagHandling.setStatus('mandatory')
if mibBuilder.loadTexts: rsVlanTagHandling.setDescription('Determine how to handle incoming tagged packets: forward them with the original tags or\n       overwrite the tags with new ones before forwarding. Note that overwrite may in some\n       cases simply remove the tag.')
rsSmtpParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 97))
rsSmtpPrimaryAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 97, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSmtpPrimaryAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsSmtpPrimaryAddr.setDescription('Primary SMTP server address.')
rsSmtpAlternateAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 97, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSmtpAlternateAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsSmtpAlternateAddr.setDescription('Alternate SMTP server address.')
rsSmtpEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 97, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSmtpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSmtpEnable.setDescription('SMTP task enable.')
rsSmtpOwnAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 97, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSmtpOwnAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsSmtpOwnAddr.setDescription('Our own Email address')
rsSmtpBackupOwnAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 97, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSmtpBackupOwnAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rsSmtpBackupOwnAddr.setDescription('Backup device own Email address')
rsWSDSyslogUrl = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 98), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogUrl.setDescription('The URL/IP Address of the syslog station.')
rsFileSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 99))
rsFSapplList = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1), )
if mibBuilder.loadTexts: rsFSapplList.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplList.setDescription('An entry of this table specifies an an application on the compact flash.')
rsFSapplEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rsFSapplName"))
if mibBuilder.loadTexts: rsFSapplEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplEntry.setDescription('A list of information for each application.')
rsFSapplName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsFSapplName.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplName.setDescription('The application name')
rsFSapplIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsFSapplIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplIndex.setDescription('The application index number as appears on the compact flash.')
rsFSapplValid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsFSapplValid.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplValid.setDescription('Indicate whether the application is valid or not:\n      true(1) : Application is valid - can be set to active\n      false(2): Application is invalid - indicates a problem in the\n\t\tupgrade process or installation, user should download a new version.')
rsFSapplActive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFSapplActive.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplActive.setDescription('Indicate or set the application as the current active application:\n      true(1):  active application\n      false(2): not the active application.')
rsFSapplVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsFSapplVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplVersion.setDescription('The major version of the application.')
rsFSapplStartup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsFSapplStartup.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplStartup.setDescription('Indicate whether the application is the startup application:\n      true(1) : startup application\n      false(2): not the startup application.')
rsFSapplStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFSapplStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSapplStatus.setDescription('delete/update an entry')
rsFSinstallNew = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFSinstallNew.setStatus('mandatory')
if mibBuilder.loadTexts: rsFSinstallNew.setDescription('Enable/Disable - automatic make new downloaded application the default.')
rdwrConfigurationFileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3), )
if mibBuilder.loadTexts: rdwrConfigurationFileTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileTable.setDescription('A table holding information about configuration files.')
rdwrConfigurationFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrConfigurationFileApp"), (0, "RADWARE-MIB", "rdwrConfigurationFileName"))
if mibBuilder.loadTexts: rdwrConfigurationFileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileEntry.setDescription('An entry in the table of configuration files')
rdwrConfigurationFileApp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrConfigurationFileApp.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileApp.setDescription('The application the configuration file belongs to.')
rdwrConfigurationFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrConfigurationFileName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileName.setDescription('The name of the configuration file relative to a predefined directory holding\n          all configuration files for a specific application.')
rdwrConfigurationFileRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrConfigurationFileRunning.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileRunning.setDescription('Indicate whether this is the currently running configuration.')
rdwrConfigurationFileInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrConfigurationFileInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileInstalled.setDescription("Indicate whether this is the currently installed configuration, i.e. the configuration\n          which will be associated to it's application after reset.")
rdwrConfigurationFilePath = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrConfigurationFilePath.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFilePath.setDescription('The absolute path of the configuration file. When creating a new entry in this table\n          the path must be present and indicates where the file is to be taken from.')
rdwrConfigurationFileAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("add", 2), ("install", 3), ("delete", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrConfigurationFileAction.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileAction.setDescription('The required operation needed on the configuration file.')
rdwrConfigurationFileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 3, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrConfigurationFileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrConfigurationFileStatus.setDescription('Operation to be performed on a specific configuration file.')
rdwrDefCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4))
rdwrDefCfgIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgIpAddress.setDescription('The default IP address of the device')
rdwrDefCfgIpMask = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgIpMask.setDescription('The default IP mask of the device')
rdwrDefCfgPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgPort.setDescription('The default port number of the device')
rdwrDefCfgGateway = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgGateway.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgGateway.setDescription('The default gatewary address of the device')
rdwrDefCfgUserName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgUserName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgUserName.setDescription('The default root user name')
rdwrDefCfgUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgUserPassword.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgUserPassword.setDescription('The default root user password')
rdwrDefCfgCommunity = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 4, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDefCfgCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDefCfgCommunity.setDescription('The default community string for SNMP v1 and SNMP v2 access.')
rdwrApplicationFileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5), )
if mibBuilder.loadTexts: rdwrApplicationFileTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileTable.setDescription('A table holding information about Application files.')
rdwrApplicationFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrApplicationFileName"))
if mibBuilder.loadTexts: rdwrApplicationFileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileEntry.setDescription('An entry in the table of Application files')
rdwrApplicationFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileName.setDescription('The application name.')
rdwrApplicationFileRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileRunning.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileRunning.setDescription('Indicate whether this is the currently running application.')
rdwrApplicationFileSelected = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileSelected.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileSelected.setDescription('Indicate whether this is the currently selected application, i.e. the application\n          which will be running after reset.')
rdwrApplicationFileValid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileValid.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileValid.setDescription('Indicate whether the application is valid or not:\n      true(1) : Application is valid - can be set to active\n      false(2): Application is invalid - indicates a problem in the\n\t\tupgrade process or installation, user should download a new version.')
rdwrApplicationFileStartup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileStartup.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileStartup.setDescription('Indicate whether the application is the startup application:\n      true(1) : startup application\n      false(2): not the startup application.')
rdwrApplicationFileVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrApplicationFileVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileVersion.setDescription('The major version of the application.')
rdwrApplicationFileAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("add", 2), ("select", 3), ("delete", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrApplicationFileAction.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileAction.setDescription('Add/Select(install)/Delete an application name.')
rdwrApplicationFileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 99, 5, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrApplicationFileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrApplicationFileStatus.setDescription('The SNMP Operation to be performed on a specific application file.')
rsWSDHardwareLicense = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 100), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDHardwareLicense.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDHardwareLicense.setDescription('The new licence for the device')
rsWSDHardwareLicenseID = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 101), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDHardwareLicenseID.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDHardwareLicenseID.setDescription('License ID used for license downgrade')
rsWSDThroughputLicense = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 141), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDThroughputLicense.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDThroughputLicense.setDescription('The new licence for the device')
rsWSDThroughputLicenseID = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 142), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDThroughputLicenseID.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDThroughputLicenseID.setDescription('License ID used for license downgrade')
rdwrSnmpParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 102))
rdwrSnmpSupportedVersions = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpSupportedVersions.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpSupportedVersions.setDescription('The currently supported SNMP versions as a bit mask. ')
rdwrSnmpSupportedVersionsAfterReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSnmpSupportedVersionsAfterReset.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpSupportedVersionsAfterReset.setDescription('The bit mask of supported SNMP versions after resetting the device.')
rdwrSnmpPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSnmpPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpPort.setDescription('The Snmp Port.')
rdwrSnmpStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSnmpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpStatus.setDescription('Snmp Status. Enable/Disable Snmp operation.')
rdwrSnmpConfigFileFormat = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cli", 1), ("ber", 2), ("ascii", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSnmpConfigFileFormat.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpConfigFileFormat.setDescription('The format of the configuration file.')
rdwrSnmpErrorIndex = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorIndex.setDescription('The index of the field in the PDU which caused the error. \n       Values as in the reply PDU starting with 1.')
rdwrSnmpErrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorStatus.setDescription('The status returned in the Reply PDU.')
rdwrSnmpErrorDescription = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorDescription.setDescription('The description of the error.')
rdwrSnmpErrorRequestId = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorRequestId.setDescription('The requestId of the request which caused the last error.')
rdwrSnmpErrorTbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10), )
if mibBuilder.loadTexts: rdwrSnmpErrorTbTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbTable.setDescription('Table containing the list of errors occured')
rdwrSnmpErrorTbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrSnmpErrorTbRequestId"))
if mibBuilder.loadTexts: rdwrSnmpErrorTbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbEntry.setDescription('The row definition for this table.')
rdwrSnmpErrorTbRequestId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbRequestId.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbRequestId.setDescription('This variable indicates the requestId of the request which caused the error.')
rdwrSnmpErrorTbVarId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbVarId.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbVarId.setDescription('This variable indicates the variable Oid')
rdwrSnmpErrorTbDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbDescription.setDescription('This variable indicates the description of the error')
rdwrSnmpErrorTbErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbErrorIndex.setDescription('This variable indicates the index of the field in the PDU which caused the error (start at 1)')
rdwrSnmpErrorTbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("application", 1), ("internalRange", 2), ("internalGeneral", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbType.setDescription('This variable indicates the type of error.')
rdwrSnmpErrorTbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("tooBig", 1), ("noSuchName", 2), ("badValue", 3), ("readOnly", 4), ("genErr", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbStatus.setDescription('This variable indicates the type of error.')
rdwrSnmpErrorTbFieldInEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbFieldInEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbFieldInEntry.setDescription('This variable indicates the index of the field in an entry (0 for scalar)')
rdwrSnmpErrorTbTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbTime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbTime.setDescription('This variable indicates the time the error occurred, the time will be in the format hh:mm:ss')
rdwrSnmpErrorTbDate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 10, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrSnmpErrorTbDate.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbDate.setDescription('This variable indicates the time the error occurred, the date will be in the format dd/mm/yyyy')
rdwrSnmpErrorTbTableReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSnmpErrorTbTableReset.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSnmpErrorTbTableReset.setDescription('Reset the SNMP error table')
rdwrLastConfigurationChangesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12), )
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTable.setDescription('Table containing the list of last configuration changes occured.')
rdwrLastConfigurationChangesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrLastConfigurationChangesID"))
if mibBuilder.loadTexts: rdwrLastConfigurationChangesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesEntry.setDescription('The row definition for this table.')
rdwrLastConfigurationChangesID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesID.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesID.setDescription('This variable indicates the change ID')
rdwrLastConfigurationChangesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesStatus.setDescription('Entry status. It is used to delete an entry')
rdwrLastConfigurationChangesMibOid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesMibOid.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesMibOid.setDescription('This variable indicates Mib OID.')
rdwrLastConfigurationChangesChangeType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("add", 1), ("modify", 2), ("delete", 3), ("configurationFileLoaded", 4), ("tableNotUpdated", 5), ("refreshTable", 6), ("updatePolicies", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesChangeType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesChangeType.setDescription('This variable indicates ChangeType ')
rdwrLastConfigurationChangesKeys = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 12, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesKeys.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesKeys.setDescription('This variable indicates Keys.')
rdwrLastConfigurationChangesTableReset = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTableReset.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTableReset.setDescription('Reset the Last Configuration Changes table')
rdwrLastConfigurationChangesTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTimestamp.setDescription('The value of sysUpTime at the last configuration change.')
rdwrLastConfigurationChangesTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 102, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrLastConfigurationChangesTime.setDescription('Last configuration change time, time since 00:00:00 GMT, Jan. 1, 1970, measured in seconds.')
rsWSDSyslogSourcePort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 103), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(514, 514), ValueRangeConstraint(1024, 65535), )).clone(514)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogSourcePort.setDescription('Determines the source port with which Syslog packets will be sent.')
rsWSDSyslogDestinationPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 124), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(514, 514), ValueRangeConstraint(1024, 65535), )).clone(514)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogDestinationPort.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogDestinationPort.setDescription('Determines the destination port with which Syslog packets will be sent.')
rsSESSION = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 104))
rsLinkAggregationHash = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 105))
rsLinkAggregationL2Hash = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 105, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("source", 2), ("detination", 3), ("both", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLinkAggregationL2Hash.setStatus('mandatory')
if mibBuilder.loadTexts: rsLinkAggregationL2Hash.setDescription('Layer 2 addresses usage in the hash function')
rsLinkAggregationL3Hash = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 105, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("source", 2), ("detination", 3), ("both", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLinkAggregationL3Hash.setStatus('mandatory')
if mibBuilder.loadTexts: rsLinkAggregationL3Hash.setDescription('Layer 3 addresses usage in the hash function')
rsLinkAggregationL4Hash = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 105, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("source", 2), ("detination", 3), ("both", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLinkAggregationL4Hash.setStatus('mandatory')
if mibBuilder.loadTexts: rsLinkAggregationL4Hash.setDescription('Layer 4 ports usage in the hash function')
rsScheduleTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 106), )
if mibBuilder.loadTexts: rsScheduleTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleTable.setDescription('The table of event schedules. All schedules are kept in it.')
rsScheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1), ).setIndexNames((0, "RADWARE-MIB", "rsScheduleName"))
if mibBuilder.loadTexts: rsScheduleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleEntry.setDescription(' The row definition for this table.')
rsScheduleName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleName.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleName.setDescription('The name of the schedule. It is the primary key')
rsScheduleFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("once", 1), ("daily", 2), ("weekly", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleFrequency.setDescription('The frequency of the event.')
rsScheduleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleTime.setDescription('The time will be sent in the format hhmm- 0 means field not relevant ')
rsScheduleDays = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleDays.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleDays.setDescription('Each octet represents status of day. 0 -not selected, 1-selected.\n        The order is:\n        Sunday    1000000\n        Monday    0100000\n        Tuesday   0010000\n        wednesday 0001000\n        Thursday  0000100\n        Friday    0000010\n        Saturday  0000001')
rsScheduleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleDate.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleDate.setDescription('The date will be sent in the format ddmmyyyy - 0 means field not relevant')
rsScheduleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 106, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsScheduleStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsScheduleStatus.setDescription('delete/update an entry')
rdwrFtpParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 107))
rdwrFtpPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 107, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrFtpPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrFtpPort.setDescription('The FTP Server Port.')
rdwrFtpStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 107, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrFtpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrFtpStatus.setDescription('Ftp Status. Enable/Disable Ftp Server.')
rsFullMacCompareStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enforce", 1), ("share", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFullMacCompareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsFullMacCompareStatus.setDescription('Select whether all 48 bits of the destination MAC address are used to determine if \n\t   a packet is destined to the device, or just 42 (the default)')
rsREStateMonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 109))
rsREACCReasonCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1))
rsACCReasonUnknownCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonUnknownCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonUnknownCounter.setDescription('ACC send packet to master with reason unknown')
rsACCReasonETHBroadcastCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonETHBroadcastCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonETHBroadcastCounter.setDescription('ACC send packet to master with reason ETH broadcast')
rsACCReasonProtolcolTypeCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonProtolcolTypeCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonProtolcolTypeCounter.setDescription('ACC send packet to master with reason protolcol type ')
rsACCReasonIPVERCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonIPVERCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonIPVERCounter.setDescription('ACC send packet to master with reason IP ver')
rsACCReasonIPHeaderLenCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonIPHeaderLenCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonIPHeaderLenCounter.setDescription('ACC send packet to master with reason IP header lenght')
rsACCReasonIPFragmentedCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonIPFragmentedCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonIPFragmentedCounter.setDescription('ACC send packet to master with reason IP fragmented')
rsACCReasonTTLCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonTTLCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonTTLCounter.setDescription('ACC send packet to master with reason TTL 1 or 0')
rsACCReasonNoFlowCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonNoFlowCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonNoFlowCounter.setDescription('ACC send packet to master with reason no flow')
rsACCReasonMACCFGCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonMACCFGCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonMACCFGCounter.setDescription('ACC send packet to master with reason MAC cfg')
rsACCReasonSYNcookieOKCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonSYNcookieOKCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonSYNcookieOKCounter.setDescription('ACC send packet to master with reason SYN cookie OK')
rsACCReasonSYNcookieInvalidCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonSYNcookieInvalidCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonSYNcookieInvalidCounter.setDescription('ACC send packet to master with reason SYN cookie invalid')
rsACCReasonInconsistentPktLenCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonInconsistentPktLenCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonInconsistentPktLenCounter.setDescription('ACC send packet to master with reason inconsistent packet lenght')
rsACCReasonNoReasonCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonNoReasonCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonNoReasonCounter.setDescription('ACC send packet to master with reason no reason')
rsACCReasonFTPportCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonFTPportCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonFTPportCounter.setDescription('ACC send packet to master with reason FTP port in packet')
rsACCReasonFTP227Counter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonFTP227Counter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonFTP227Counter.setDescription('ACC send packet to master with reason FTP 227 in packet')
rsACCReasonIPLenghtCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonIPLenghtCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonIPLenghtCounter.setDescription('ACC send packet to master with reason IP lenght > 40, this means a packet with data')
rsACCReasonFINorRSTCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonFINorRSTCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonFINorRSTCounter.setDescription('ACC send packet to master with reason FIN or RST, the session has ended')
rsACCReasonClassifyCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonClassifyCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonClassifyCounter.setDescription('ACC send packet to master with reason classify')
rsACCReasonVlanReplyCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonVlanReplyCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonVlanReplyCounter.setDescription('ACC send packet to master with reason VLAN Reply')
rsACCReasonDBindNewSYNCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonDBindNewSYNCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonDBindNewSYNCounter.setDescription('ACC send packet to master with reason new SYN on delayed binding')
rsACCReasonAllToMasterCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsACCReasonAllToMasterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsACCReasonAllToMasterCounter.setDescription('ACC send packet to master with reason all traffic')
rsREStateCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2))
rsREStateRXReplyCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsREStateRXReplyCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateRXReplyCounter.setDescription('RE is state rx reply')
rsREStateRXRequestCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsREStateRXRequestCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateRXRequestCounter.setDescription('RE is state rx request')
rsREStateIPDAinFFTCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsREStateIPDAinFFTCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateIPDAinFFTCounter.setDescription('Packet IPDA in FFT')
rsREStateIPDAnotFFTCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsREStateIPDAnotFFTCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateIPDAnotFFTCounter.setDescription('Packet IPDA not FFT')
rsREStateBridgeCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsREStateBridgeCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateBridgeCounter.setDescription('Performing bridging')
rsREStateResetCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 109, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsREStateResetCounter.setStatus('mandatory')
if mibBuilder.loadTexts: rsREStateResetCounter.setDescription('Reset the ACC counters')
rdwrTerminalParams = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 110))
rdwrTerminalAliasTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1), )
if mibBuilder.loadTexts: rdwrTerminalAliasTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalAliasTable.setDescription('A table containing the alias strings of a specific user.')
rdwrTerminalAliasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrTerminalAliasName"), (0, "RADWARE-MIB", "rdwrTerminalUserName"))
if mibBuilder.loadTexts: rdwrTerminalAliasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalAliasEntry.setDescription('Information about a particular Alias entry.')
rdwrTerminalAliasName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrTerminalAliasName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalAliasName.setDescription('Alias string.')
rdwrTerminalUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrTerminalUserName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalUserName.setDescription('User name string.')
rdwrTerminalAliasCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrTerminalAliasCommand.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalAliasCommand.setDescription('command string.')
rdwrTerminalAliasStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrTerminalAliasStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalAliasStatus.setDescription('Entry status')
rdwrTerminalPrompt = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 110, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrTerminalPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTerminalPrompt.setDescription('The system prompt of the device.')
rdwrMasterInterfaceGroupingPortsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 111), )
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortsTable.setDescription('The table contains all the physical ports. Each port can be set to\n       included/excluded from the master interface grouping.')
rdwrMasterInterfaceGroupingPortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 111, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrMasterInterfaceGroupingPortNumber"))
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortsEntry.setDescription('Row definition for the table.')
rdwrMasterInterfaceGroupingPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 111, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortNumber.setDescription('Physical port number.')
rdwrMasterInterfaceGroupingPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 111, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMasterInterfaceGroupingPortState.setDescription('included- the port effects the master interface grouping. \n    excluded- the port does not effects the master interface grouping.')
rdwr5SecAvgResourceUtilization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 112), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwr5SecAvgResourceUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rdwr5SecAvgResourceUtilization.setDescription('Average 5 seconds Resource Utilization of internal CPU utilization')
rdwr60SecAvgResourceUtilization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 113), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwr60SecAvgResourceUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: rdwr60SecAvgResourceUtilization.setDescription('Average 60 seconds Resource Utilization of internal CPU utilization')
rdwrArpWithInterfaceGroup = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 114), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("avoid", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrArpWithInterfaceGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrArpWithInterfaceGroup.setDescription('indicates if the device should send arp request (broadcast) when redundancy enable (interface grouping enable) and the (main) device is down (interface/s go down)')
rdwrDBind = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 115))
rdwrDP = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 116))
rsDOS = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 117))
rsSTATEFUL = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 118))
rsAPM = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 119))
rdwrIpsec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 120))
rdwrIpsecIke = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1))
rdwrIkeTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1), )
if mibBuilder.loadTexts: rdwrIkeTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeTable.setDescription('A table holding information about ike connections')
rdwrIkeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrIkeName"))
if mibBuilder.loadTexts: rdwrIkeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeEntry.setDescription('An entry in the ike table')
rdwrIkeName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrIkeName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeName.setDescription('The name of this entry in the ike table.')
rdwrIkePhase1EncryptionAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("des", 1), ("idea", 2), ("blowfish", 3), ("rc5", 4), ("des3", 5), ("cast", 6), ("aes", 7))).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase1EncryptionAlg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase1EncryptionAlg.setDescription('The encryption algorithm used in phase1 negotiation')
rdwrIkePhase1HashAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase1HashAlg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase1HashAlg.setDescription('The hash algorithm used in phase1 negotiation')
rdwrIkePhase1DhKeyGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("modp768", 1), ("modp1024", 2), ("ec2n155", 3), ("ec2n185", 4), ("modp1536", 5))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase1DhKeyGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase1DhKeyGroup.setDescription('The Diffie Hellman Group used in phase1 negotiations')
rdwrIkePhase1LifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 5), Integer32().clone(28800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase1LifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase1LifeTime.setDescription('The lifetime in seconds')
rdwrIkePhase1Psk = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase1Psk.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase1Psk.setDescription('The Pre Shared Key')
rdwrIkePhase2Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("ah", 2), ("esp", 3))).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase2Protocol.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase2Protocol.setDescription('The Encapsulation protocol')
rdwrIkePhase2EncryptionAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("des", 1), ("idea", 2), ("blowfish", 3), ("rc5", 4), ("des3", 5), ("cast", 6), ("aes", 7))).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase2EncryptionAlg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase2EncryptionAlg.setDescription('The encryption algorithm to be used in phase2 negotiation')
rdwrIkePhase2HashAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("md5", 1), ("sha", 2), ("null", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePhase2HashAlg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePhase2HashAlg.setDescription('The hash algorithm to be used in phase2 negotiation')
rdwrIkePfsKeyGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 65535))).clone(namedValues=NamedValues(("modp768", 1), ("modp1024", 2), ("ec2n155", 3), ("ec2n185", 4), ("modp1536", 5), ("off", 65535))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkePfsKeyGroup.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkePfsKeyGroup.setDescription('The Diffie Hellman Group to be used in phase2 negotiations')
rdwrIkeSaLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 11), Integer32().clone(28800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeSaLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeSaLifeTime.setDescription('The lifetime in seconds')
rdwrIkeIpCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeIpCompression.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeIpCompression.setDescription('Indicate whether to use ip compression.')
rdwrIkeManualKeyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ike", 1), ("manual", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeManualKeyMode.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeManualKeyMode.setDescription('indicate the ipSec key mode: IKE (automatic) or manual')
rdwrIkeEncrypKey = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeEncrypKey.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeEncrypKey.setDescription('the encryption key in case of manual mode')
rdwrIkeAuthntKey = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeAuthntKey.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeAuthntKey.setDescription('the authentication key in case of manual mode')
rdwrIkeInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeInSpi.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeInSpi.setDescription('the inbound SPI value for manual key mode')
rdwrIkeOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeOutSpi.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeOutSpi.setDescription('the outbound SPI value for manual key mode')
rdwrIkeDPDCheckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeDPDCheckInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeDPDCheckInterval.setDescription('interval for the keep alive checks')
rdwrIkeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 120, 1, 1, 1, 19), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrIkeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrIkeStatus.setDescription('Operation to be performed on a specific ike table entry.')
rdwrDedicatedManagementPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 121), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDedicatedManagementPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDedicatedManagementPort.setDescription('A dedicated port for management - 0 is Not Assigned')
rsGeneric = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 122))
rdwrClientsTableStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 123))
rdwrClientsTableNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 123, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsTableNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTableNumEntries.setDescription('Number of entries in the clients table.')
rdwrClientsTableNumEntries5SecAvg = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 123, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsTableNumEntries5SecAvg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTableNumEntries5SecAvg.setDescription('Average number of entries in the clients table in the last 5 seconds.')
rdwrClientsTableNumEntries60SecAvg = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 123, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsTableNumEntries60SecAvg.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTableNumEntries60SecAvg.setDescription('Average number of entries in the clients table in the last 60 seconds.')
rdwrPortsTagTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 125), )
if mibBuilder.loadTexts: rdwrPortsTagTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPortsTagTable.setDescription('The table contains all the physical ports. Each entry can force port\n       tag for incoming and outgoing traffic.')
rdwrPortsTagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 125, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrPortsTagPortNumber"))
if mibBuilder.loadTexts: rdwrPortsTagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPortsTagEntry.setDescription('Row definition for the table.')
rdwrPortsTagPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 125, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrPortsTagPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPortsTagPortNumber.setDescription('Physical port number.')
rdwrPortsTagPortInTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 125, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrPortsTagPortInTag.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPortsTagPortInTag.setDescription('The incoming physical port vlan Tag value that represent this port.')
rdwrPortsTagPortOutTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 125, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrPortsTagPortOutTag.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPortsTagPortOutTag.setDescription('The outgoing physical port vlan Tag value that represent this port.')
rdwrDayLightSaving = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 129))
rdwrDayLightSavingBegins = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDayLightSavingBegins.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingBegins.setDescription('The day light saving beginning, this can be either a specific \n      date - format D|DD/Mon/HH, or a recurring date - format R|x/Day/Mon/HH')
rdwrDayLightSavingEnds = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDayLightSavingEnds.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingEnds.setDescription('The day light saving ending, this can be either a specific \n      date - format D|DD/Mon/HH, or a recurring date - format R|x/Day/Mon/HH')
rdwrDayLightSavingTimeDesignations = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standardTime", 1), ("summerTime", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDayLightSavingTimeDesignations.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingTimeDesignations.setDescription('The day light saving actual designation.')
rdwrDayLightSavingAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDayLightSavingAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingAdminStatus.setDescription('The day light saving administrator status.')
rdwrDayLightSavingBeginDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDayLightSavingBeginDate.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingBeginDate.setDescription('Returns the date of the beginning of the daylight saving')
rdwrDayLightSavingEndDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDayLightSavingEndDate.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingEndDate.setDescription('Returns the date of the end of the daylight saving')
rdwrDayLightSavingDelta = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 129, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrDayLightSavingDelta.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDayLightSavingDelta.setDescription('Indicates the daylight savings delta. When the daylight savings starts \n      the hour will be moved back delta hours. When it is started it will be \n      moved forward delta hours. The default is one hour.')
rdwrCommonClientTable = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 130))
rdwrClientsViewTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1), )
if mibBuilder.loadTexts: rdwrClientsViewTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewTable.setDescription('A table holding information for defining client table views (filtering)')
rdwrClientsViewEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrClientsViewIndex"))
if mibBuilder.loadTexts: rdwrClientsViewEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewEntry.setDescription('An entry in the client views table')
rdwrClientsViewIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsViewIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewIndex.setDescription('The index of this entry in the views table.')
rdwrClientsViewSrcAddrFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewSrcAddrFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewSrcAddrFrom.setDescription('The IP Address of the low boundary of the source interval.')
rdwrClientsViewSrcAddrTo = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewSrcAddrTo.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewSrcAddrTo.setDescription('The IP Address of the high boundary of the source interval.')
rdwrClientsViewDstAddrFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewDstAddrFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewDstAddrFrom.setDescription('The IP Address of the low boundary of the requested interval.')
rdwrClientsViewDstAddrTo = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewDstAddrTo.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewDstAddrTo.setDescription('The IP Address of the high boundary of the requested interval.')
rdwrClientsViewSrcPortFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewSrcPortFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewSrcPortFrom.setDescription('The TCP/UDP port of the low boundary of the source interval.')
rdwrClientsViewSrcPortTo = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewSrcPortTo.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewSrcPortTo.setDescription('The TCP/UDP port of the high boundary of the source interval.')
rdwrClientsViewDstPortFrom = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewDstPortFrom.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewDstPortFrom.setDescription('The TCP/UDP port of the low boundary of the requested interval.')
rdwrClientsViewDstPortTo = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewDstPortTo.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewDstPortTo.setDescription('The TCP/UDP port of the high boundary of the requested interval.')
rdwrClientsViewFarmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewFarmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewFarmAddr.setDescription('The client IP Address of the farm.')
rdwrClientsViewServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewServerAddr.setDescription('The client IP Address of the server.')
rdwrClientsViewClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewClientType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewClientType.setDescription('The client type')
rdwrClientsViewAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewAdminStatus.setDescription('Administrative status of the view entry\n\t enabled - activates the view.\n         disabled - inactive the view.')
rdwrClientsViewStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewStatus.setDescription('It is used to create and delete a filter')
rdwrClientsViewAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("deleteMatching", 2), ("countMatching", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewAction.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewAction.setDescription('The type of action to be performed on entries matching this filter.')
rdwrClientsViewActionFeedback = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsViewActionFeedback.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewActionFeedback.setDescription('Message containing feedback for the action taken.')
rdwrClientsViewVlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewVlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewVlanTag.setDescription('802.1q VLAN tag associated with the client entry. 0 - no tag.')
rdwrClientsViewFarmName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsViewFarmName.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsViewFarmName.setDescription("The client's farm name.")
rdwrClientsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2), )
if mibBuilder.loadTexts: rdwrClientsTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTable.setDescription('A table holding the device filtered client table')
rdwrClientsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrClientsIndex"))
if mibBuilder.loadTexts: rdwrClientsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsEntry.setDescription('An entry in the client table')
rdwrClientsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsIndex.setDescription('The index of this entry in the table.')
rdwrClientsSourceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsSourceAddr.setDescription('The client source address.')
rdwrClientsSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsSourcePort.setDescription('The clinet source port.')
rdwrClientsRequestedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsRequestedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsRequestedAddr.setDescription('The client requested address.')
rdwrClientsRequestedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsRequestedPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsRequestedPort.setDescription('The client requested TCP/UDP Port.')
rdwrClientsFarmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsFarmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsFarmAddr.setDescription('IP Address of the farm the client trough which the client connected.')
rdwrClientsServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsServerAddr.setDescription('IP Address of server currently serving this client.')
rdwrClientsServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsServerPort.setDescription('TCP/UDP Port of server currently serving this client.')
rdwrClientsAttachedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsAttachedTime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsAttachedTime.setDescription('Indicates when the client was attached.\n         Measured in seconds since device re-initialization.')
rdwrClientsNATaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsNATaddr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsNATaddr.setDescription('NAT IP Address of the client.')
rdwrClientsNATPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsNATPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsNATPort.setDescription('NAT TCP/UDP port of the client.')
rdwrClientsTimeToLive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTimeToLive.setDescription('This variable measures the client time to live in seconds.')
rdwrClientsClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsClientType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsClientType.setDescription('This variable indicates the administrative type of this entry.')
rdwrClientsClientMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsClientMode.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsClientMode.setDescription("This variable indicates how a single client's sessions are  \n         handled in the client table.")
rdwrClientsUserData1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsUserData1.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsUserData1.setDescription('This variable holds miscellaneous client information.')
rdwrClientsUserData2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsUserData2.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsUserData2.setDescription('This variable holds miscellaneous client information.')
rdwrClientsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 2, 1, 17), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClientsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsStatus.setDescription('It is used to delete an entry')
rdwrClientsTypeTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 3), )
if mibBuilder.loadTexts: rdwrClientsTypeTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTypeTable.setDescription('A table holding the client types')
rdwrClientsTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrClientsType"))
if mibBuilder.loadTexts: rdwrClientsTypeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsTypeEntry.setDescription('An entry in the client types table')
rdwrClientsType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 130, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrClientsType.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClientsType.setDescription('The clinet type of this entry.')
rdwrVersionIdentifierTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 131), )
if mibBuilder.loadTexts: rdwrVersionIdentifierTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVersionIdentifierTable.setDescription('Row holding version verification information.')
rdwrVersionIdentifierEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 131, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrVersionIdentifierIdx"))
if mibBuilder.loadTexts: rdwrVersionIdentifierEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVersionIdentifierEntry.setDescription('Row definition for the table.')
rdwrVersionIdentifierIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 131, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrVersionIdentifierIdx.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVersionIdentifierIdx.setDescription('Installed version index. Calculated by version major * 100 + version minor')
rdwrVersionIdentifierBase = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 131, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVersionIdentifierBase.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVersionIdentifierBase.setDescription('Installed version base number. ')
rdwrVersionIdentifierVal = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 131, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVersionIdentifierVal.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVersionIdentifierVal.setDescription('Installed version identifier string. ')
rdwrVrrp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 132))
rdwrVrrpAdmin = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("allDown", 1), ("allUp", 2), ("noChange", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVrrpAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAdmin.setDescription('Control all VRIDs admin status.')
rdwrVrrpOperAdvertisementInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVrrpOperAdvertisementInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpOperAdvertisementInterval.setDescription('The time interval, in milliseconds, between sending\n        advertisement messages for all VRIDs. Only the master router sends\n        VRRP advertisements.')
rdwrVrrpAssoIpV6AddrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3), )
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrTable.setDescription('This MIB describes proparitery radware support for managing Virtual Router Redundancy Protocol (VRRP). Most of the support is given via the VRRP mib ')
rdwrVrrpAssoIpV6AddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrVrrpAssoIpV6IfIndex"), (0, "RADWARE-MIB", "rdwrVrrpAssoIpV6VrId"), (0, "RADWARE-MIB", "rdwrVrrpAssoIpV6Addr"))
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrEntry.setDescription("An entry in the table contains an IPv6 address that is\n            associated with a virtual router. The number of rows for\n            a given ifIndex and VrId will equal the number of IP addresses associated (e.g., backed up) by the virtual\n            router (equivalent to 'vrrpOperIpV6AddrCount').\n            Rows in the table cannot be modified unless the value\n            of `vrrpOperAdminState' is `disabled' and the\n            `vrrpOperState' has transitioned to `initialize'.")
rdwrVrrpAssoIpV6IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6IfIndex.setDescription('')
rdwrVrrpAssoIpV6VrId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3, 1, 2), VrId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6VrId.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6VrId.setDescription('This object contains the Virtual Router Identifier (VRID).')
rdwrVrrpAssoIpV6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3, 1, 3), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6Addr.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6Addr.setDescription('The assigned IPv6 addresses that a virtual router is\n            responsible for backing up.')
rdwrVrrpAssoIpV6AddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpAssoIpV6AddrRowStatus.setDescription('The row status variable, used according to installation\n            and removal conventions for conceptual rows. Setting this object to active(1) or createAndGo(4) results in the\n            addition of an associated address for a virtual router. Destroying the entry or setting it to notInService(2)\n            removes the associated address from the virtual router.\n            The use of other values is implementation-dependent.')
rdwrVrrpPriorityTracking = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 132, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrVrrpPriorityTracking.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrVrrpPriorityTracking.setDescription('VRRP priority tracking weight for interface link status, zero is disabled')
rdwrWSDCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 134))
rdwrCdbParameters = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 139))
rdwrCdbTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 139, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrCdbTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrCdbTimeStamp.setDescription('The time stamp taken when the the CDB was last changed. Defined as the number of seconds since 1/1/1970.')
rdwrMirroring = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 140))
rdwrMirroringActiveThreshold = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveThreshold.setDescription('The maximum amount of entries to be sent from the active device.')
rdwrMirroringActiveSleep = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveSleep.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveSleep.setDescription('After sending the maximum amount of entries the active device \n      will sleep for the predefined period (in milliseconds).')
rdwrMirroringActiveBackupThreshold = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveBackupThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveBackupThreshold.setDescription('The maximum amount of entries to be sent from the active device to the \n      backup (after the backup device is up).')
rdwrMirroringActiveBackupSleep = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveBackupSleep.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveBackupSleep.setDescription('After sending the maximum amount of entries the active device \n      will sleep for the predefined period (in milliseconds).')
rdwrMirroringActiveBackupHoldtime = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveBackupHoldtime.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveBackupHoldtime.setDescription('The active device will start to notify the main of all existing \n      entries after the configured time (in milliseconds).')
rdwrMirroringActiveBackupUpdate = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 140, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrMirroringActiveBackupUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrMirroringActiveBackupUpdate.setDescription('Enable/Disable the update of the backup device from the active')
rdwrTemperatureCPU1Get = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 150), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureCPU1Get.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureCPU1Get.setDescription('get the temperature of CPU1')
rdwrTemperatureCPU2Get = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 151), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureCPU2Get.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureCPU2Get.setDescription('get the temperature of CPU2')
rdwrTemperatureWarningThresholdGet = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 152), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureWarningThresholdGet.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureWarningThresholdGet.setDescription('get the temperature warning threshold')
rdwrTemperatureShutdownThresholdGet = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 153), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureShutdownThresholdGet.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureShutdownThresholdGet.setDescription('get the temperature shutdown threshold')
rdwrTemperatureThresholdStatusCPU1Get = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 154), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureThresholdStatusCPU1Get.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureThresholdStatusCPU1Get.setDescription('get the threshold status of CPU1\n\t    warning - if the warning threshold exceeded\n\t    critical - if the shutdown threshold exceeded')
rdwrTemperatureThresholdStatusCPU2Get = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 155), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTemperatureThresholdStatusCPU2Get.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTemperatureThresholdStatusCPU2Get.setDescription('get the threshold status of CPU2\n\t    warning - if the warning threshold exceeded\n\t    critical - if the shutdown threshold exceeded')
rdwrPrintToLogAndCli = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrPrintToLogAndCli.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrPrintToLogAndCli.setDescription('print to system log file and to the CLI')
rdwrClearTheLogFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clearSysLog", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrClearTheLogFile.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrClearTheLogFile.setDescription('Clears the system log file')
rdwrAutoRowGenerationStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrAutoRowGenerationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrAutoRowGenerationStatus.setDescription('Enable/Disable automatic generation of rows by device')
rsSSLCertificate = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 148))
rsSSLCertificateDefaultValues = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1))
rsSSLCertificateDefaultCommon = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultCommon.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultCommon.setDescription('default value for common field for certificate requests.')
rsSSLCertificateDefaultLocality = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultLocality.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultLocality.setDescription('default value for locality field for certificate requests.')
rsSSLCertificateDefaultStateOrProvince = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultStateOrProvince.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultStateOrProvince.setDescription('default value for state or province field for certificate requests.')
rsSSLCertificateDefaultOrganization = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultOrganization.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultOrganization.setDescription('default value for organization field for certificate requests.')
rsSSLCertificateDefaultOrganizationUnit = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultOrganizationUnit.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultOrganizationUnit.setDescription('default value for organization unit field for certificate requests.')
rsSSLCertificateDefaultCountryName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultCountryName.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultCountryName.setDescription('default value for country name field for certificate requests.')
rsSSLCertificateDefaultEMail = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateDefaultEMail.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateDefaultEMail.setDescription('default value for e-mail field for certificate requests.')
rsSSLCertificateTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2), )
if mibBuilder.loadTexts: rsSSLCertificateTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateTable.setDescription('The table for certificate handling')
rsSSLCertificateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1), ).setIndexNames((0, "RADWARE-MIB", "rsSSLCertificateName"))
if mibBuilder.loadTexts: rsSSLCertificateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateEntry.setDescription(' The row definition for this table.')
rsSSLCertificateName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsSSLCertificateName.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateName.setDescription('The name of the certificate entry')
rsSSLCertificateEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("key", 1), ("certificateSigningRequest", 2), ("certificate", 3), ("certificateChain", 4), ("clientCAcertificate", 5), ("rootTSLcertificate", 6), ("sshPublicKey", 7))).clone('key')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateEntryType.setDescription('entry type')
rsSSLCertificateKeySize = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 512, 1024, 2048))).clone(namedValues=NamedValues(("na", 0), ("size512", 512), ("size1024", 1024), ("size2048", 2048))).clone('size1024')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateKeySize.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateKeySize.setDescription('key data size in bits')
rsSSLCertificateKeyPassphrase = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateKeyPassphrase.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateKeyPassphrase.setDescription('password phrase to scramble key')
rsSSLCertificateCommon = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateCommon.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateCommon.setDescription('value for common name field for certificate requests.')
rsSSLCertificateLocality = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateLocality.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateLocality.setDescription('value for locality field for certificate requests.')
rsSSLCertificateStateOrProvince = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateStateOrProvince.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateStateOrProvince.setDescription('value for state or province field for certificate requests.')
rsSSLCertificateOrganization = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateOrganization.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateOrganization.setDescription('value for organization field for certificate requests.')
rsSSLCertificateOrganizationUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateOrganizationUnit.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateOrganizationUnit.setDescription(' value for organization unit field for certificate requests.')
rsSSLCertificateCountryName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateCountryName.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateCountryName.setDescription('value for country name field for certificate requests.')
rsSSLCertificateEMail = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateEMail.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateEMail.setDescription('value for e-mail field for certificate requests.')
rsSSLCertificateExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsSSLCertificateExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateExpiry.setDescription('expiry date according to certificate')
rsSSLCertificateOCSPUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateOCSPUrl.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateOCSPUrl.setDescription('OCSP url for client CA status validation')
rsSSLCertificateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 14), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateStatus.setDescription('row status for certificate entry')
rsSSLCertificateRequestedValidityPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateRequestedValidityPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateRequestedValidityPeriod.setDescription('validity period in days requested for self signed certificate')
rsSSLCertificateImportExport = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 3))
rsSSLCertificateImportExportEntryName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateImportExportEntryName.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateImportExportEntryName.setDescription('entry name to be addressed.')
rsSSLCertificateImportExportFileName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 3, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateImportExportFileName.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateImportExportFileName.setDescription('file name path to export to or import from according to action.')
rsSSLCertificateImportExportPassphrase = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 3, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateImportExportPassphrase.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateImportExportPassphrase.setDescription('Passphrase to be used when importing a key.')
rsSSLCertificateImportExportAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 148, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("importKey", 1), ("exportKey", 2), ("importCertificate", 3), ("exportCertificate", 4), ("exportSigningRequest", 5), ("importCertChain", 6), ("exportCertChain", 7), ("importCertClientCA", 8), ("exportCertClientCA", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSSLCertificateImportExportAction.setStatus('mandatory')
if mibBuilder.loadTexts: rsSSLCertificateImportExportAction.setDescription('Action to be performed on the entry name or file specified.')
rndNumberOfHD = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 156), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndNumberOfHD.setStatus('mandatory')
if mibBuilder.loadTexts: rndNumberOfHD.setDescription('The number of hard drives.')
rndSSLCardName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 157), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndSSLCardName.setStatus('mandatory')
if mibBuilder.loadTexts: rndSSLCardName.setDescription('The name of the SSL card.')
rndCompCardName = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 158), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rndCompCardName.setStatus('mandatory')
if mibBuilder.loadTexts: rndCompCardName.setDescription('The name of the compression card.')
rdwrHardDisk = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 159))
rdwrHardDiskLogging = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 160))
rdwrConfigurationSync = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 161))
rdwrDualPsuStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 163), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("singlePwrSupplyOk", 0), ("firstPwrSupplyFailed", 1), ("secondPwrSupplyFailed", 2), ("doublePwrSupplyOk", 3), ("unknownPwrSupplyFailed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrDualPsuStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrDualPsuStatus.setDescription('This variable represent the current status of the power supplies\n       0 - Single PowerSupply OK\n\t   1 - First PowerSupply Failed\n\t   2 - Second PowerSupply Failed\n\t   3 - Double PowerSupply OK\n\t   4 - Unknown PowerSupply Failed')
rdwrTotalIncomingTrafficPeak = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 166), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwrTotalIncomingTrafficPeak.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrTotalIncomingTrafficPeak.setDescription('This variable represent the maximum incoming traffic in Mbps')
rsManagePro = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 35, 1, 170))
rsUserLockoutInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 171), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsUserLockoutInterval.setStatus('mandatory')
if mibBuilder.loadTexts: rsUserLockoutInterval.setDescription('Lockout time interval for user account (min). Zero means no lockout.')
rdwrManagmentPortsStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 172), FeatureStatus().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrManagmentPortsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrManagmentPortsStatus.setDescription('Is management port enabled on the device')
rdwrSyslogServerTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 173), )
if mibBuilder.loadTexts: rdwrSyslogServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerTable.setDescription('A table of syslog servers.')
rdwrSyslogServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1), ).setIndexNames((0, "RADWARE-MIB", "rdwrSyslogServerAddress"))
if mibBuilder.loadTexts: rdwrSyslogServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerEntry.setDescription('An entry of the syslog servers table')
rdwrSyslogServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerAddress.setDescription('IP address of the syslog server.')
rdwrSyslogServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 2), FeatureStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerStatus.setDescription('Server operational status.')
rdwrSyslogServerSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 3), Integer32().clone(514)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerSrcPort.setDescription('Server source port.')
rdwrSyslogServerDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 4), Integer32().clone(514)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerDstPort.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerDstPort.setDescription('Server destination port.')
rdwrSyslogServerFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23))).clone(namedValues=NamedValues(("kernelMsg", 0), ("userLevelMsg", 1), ("mailSystem", 2), ("systemDaemons", 3), ("authorization", 4), ("syslogdMessages", 5), ("linePrinter", 6), ("networkNews", 7), ("uucp", 8), ("clockDaemon1", 9), ("security", 10), ("ftpDaemon", 11), ("ntpSubsystem", 12), ("logAudit", 13), ("logAlert", 14), ("clockDaemon2", 15), ("local0", 16), ("local1", 17), ("local2", 18), ("local3", 19), ("local4", 20), ("local5", 21), ("local6", 22), ("local7", 23))).clone('local6')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerFacility.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerFacility.setDescription('The SYSLOG Priority value is calculated by multiplying the Facility\n       number by 8 and then adding the numerical value of the Severity.')
rdwrSyslogServerProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("udpProtocol", 1), ("tcpProtocol", 2), ("tlsProtocol", 3))).clone('udpProtocol')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerProtocol.setDescription('The SYSLOG Protocol.')
rdwrSyslogCACertificate = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogCACertificate.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogCACertificate.setDescription('CA Certificate of the syslog server.')
rdwrSyslogServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerRowStatus.setDescription('IP address of the syslog server.')
rdwrSyslogServerConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nr", 1), ("reachable", 2), ("unreachable", 3))).clone('unreachable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerConnectionStatus.setDescription('The SYSLOG Protocol.')
rdwrSyslogServerNumberOfLogsInBackLog = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogServerNumberOfLogsInBackLog.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogServerNumberOfLogsInBackLog.setDescription('Number of logs in the backlog.')
rdwrSyslogSecuritySending = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 11), FeatureStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogSecuritySending.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogSecuritySending.setDescription('Security events sending status.')
rdwrSyslogHealthSending = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 12), FeatureStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogHealthSending.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogHealthSending.setDescription('Health events sending status.')
rdwrSyslogUserAuditSending = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 173, 1, 13), FeatureStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdwrSyslogUserAuditSending.setStatus('mandatory')
if mibBuilder.loadTexts: rdwrSyslogUserAuditSending.setDescription('Audit events sending status.')
rsWSDSyslogGlobalStatus = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 174), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsWSDSyslogGlobalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDSyslogGlobalStatus.setDescription('Enable/Disable syslog message sending to remote station.')
rsWSDConnectionLimitReached = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,1)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDConnectionLimitReached.setDescription('This warning is generated when the users connection limit of an application or a physical server is reached.')
rsWSDReadyForShutDown = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,2)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDReadyForShutDown.setDescription('This warning is generated when all the clients sessions of an application or a physical server are finished and so, the application or server are ready to be shut down.')
rsWSDIllegalReport = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,3)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDIllegalReport.setDescription('This warning is generated when an LRP message arrives with illegal information.')
rsWSDRemoteWSDUnavailable = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,4)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDRemoteWSDUnavailable.setDescription('This warning is generated when a remote WSD is in full capacity, not in service or disabled. This server is then unavailable')
rsWSDCapacityLimitReached = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,5)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDCapacityLimitReached.setDescription('This warning is generated when WSD capacity limit is reached.')
rsWSDStatusMonitoring = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,6)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDStatusMonitoring.setDescription(' This warning is generated for unavailable SNMP parameter from a server.')
rsWSDWrongPassword = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,7)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDWrongPassword.setDescription(' This warning is generated when authentication failed because of wrong user name or password.')
rsWSDInternalTableOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,8)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDInternalTableOverflow.setDescription('This warning is generated when there are no more free entries in the table.')
rsWSDServerUp = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,9)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDServerUp.setDescription('This informational trap is sent when a server correctly responds to a connectivity check for the first time.')
rsWSDPoliciesUpdated = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,10)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDPoliciesUpdated.setDescription('This informational trap is sent when the rule policies are\n             updated.')
rsWSDIntrusionDetected = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,11)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDIntrusionDetected.setDescription('This informational trap is sent when an intrusion is detected.')
rsWSDUserLocked = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,12)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDUserLocked.setDescription('This warning trap is sent when a user is locked from managing the device because of login failure.')
rsWSDAuthenticationSuccess = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,13)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDAuthenticationSuccess.setDescription('This informational trap is sent when a user authentication succeeded.')
rsRadwareNTPUpdateProblem = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,14)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsRadwareNTPUpdateProblem.setDescription('This warning trap is sent when the device NTP client encounters problem updating \n              the system clock.')
rsRadwareVrrpErrors = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,15)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsRadwareVrrpErrors.setDescription('This warning trap is generated when VRRP error occurs.')
rdwrDualPowerSupplyProblem = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,16)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrDualPowerSupplyProblem.setDescription('This warning trap is sent when a power supply becomes inacive on a dual power supply device.')
rdwrDualPowerSupplyUp = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,17)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrDualPowerSupplyUp.setDescription('This info trap is sent when a power supply changes state from inactive to active on a dual power supply device.')
rdwrMngmntPortDisabled = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,18)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrMngmntPortDisabled.setDescription('This info trap is sent when a user tries to access a management port via a protocol, which is disabled on this port.')
rdwrUnauthorizedSourceIP = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,19)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rdwrUnauthorizedSourceIP.setDescription('This info trap is sent when a user tries to access a management port from an IP address, that is not authorized to perform access.')
rsSSLCertificateSyncProblem = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,20)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsSSLCertificateSyncProblem.setDescription('This trap is issued when a file is removed from certificate directory causing a synchronization problem with certificate table.')
rsARPTableIpConflict = NotificationType((1, 3, 6, 1, 4, 1, 89) + (0,21)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsARPTableIpConflict.setDescription('Indecate IP Conflicts on ARP table.')
rsWSDAuthenticationServerSuccess = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,22)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDAuthenticationServerSuccess.setDescription('This informational trap is sent after a successful connection to authentication server such as RADIUS/TACACS+.')
rsWSDAuthenticationServerFail = NotificationType((1, 3, 6, 1, 4, 1, 89, 35, 1) + (0,23)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsWSDAuthenticationServerFail.setDescription('This informational trap is sent after a connection to authentication server such as RADIUS/TACACS+ has failed.')
stpSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 30))
rsStpMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("per-vlan", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpMode.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpMode.setDescription('Default STP Mode.')
rsStpDefaultBridgePriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpDefaultBridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpDefaultBridgePriority.setDescription('Default STP priority for this bridge.')
rsStpDefaultHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpDefaultHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpDefaultHelloTime.setDescription('Default STP hello time (Sec).')
rsStpDefaultMaxAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40)).clone(20)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpDefaultMaxAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpDefaultMaxAgingTime.setDescription('Default STP hello time (Sec).')
rsStpDefaultForwardDelayTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpDefaultForwardDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpDefaultForwardDelayTime.setDescription('Default STP hello time (Sec).')
rsStpDefaultPortPriority = MibScalar((1, 3, 6, 1, 4, 1, 89, 30, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpDefaultPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpDefaultPortPriority.setDescription('Default Port Priority.')
rsStpInstancesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 30, 7), )
if mibBuilder.loadTexts: rsStpInstancesTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstancesTable.setDescription('A table holding STP instances running on device')
rsStpInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 30, 7, 1), ).setIndexNames((0, "RADWARE-MIB", "rsStpInstanceVlanId"))
if mibBuilder.loadTexts: rsStpInstanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceEntry.setDescription('An entry in the STP instances table')
rsStpInstanceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpInstanceVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceVlanId.setDescription('Vlan of STP instance.')
rsStpInstanceBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpInstanceBridgePriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceBridgePriority.setDescription('Current bridge priority.')
rsStpInstanceHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpInstanceHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceHelloTime.setDescription('Hello Time (in seconds).')
rsStpInstanceMaxAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpInstanceMaxAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceMaxAgingTime.setDescription('Max Aging Time (in seconds).')
rsStpInstanceForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpInstanceForwardDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceForwardDelayTime.setDescription('Forward Delay Time (in seconds).')
rsStpInstanceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 6), FeatureStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpInstanceEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceEnabled.setDescription('Whether this STP instance is enabled')
rsStpInstanceRootId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpInstanceRootId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceRootId.setDescription('Spanning Tree Root Id.')
rsStpInstanceRootPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpInstanceRootPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceRootPathCost.setDescription('Spanning Tree Root Path Cost.')
rsStpInstanceDesignatedBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpInstanceDesignatedBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceDesignatedBridgeId.setDescription('Designated Bridge Id.')
rsStpInstanceDesignatedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpInstanceDesignatedPortId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpInstanceDesignatedPortId.setDescription('Designated Port Id.')
rsStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 89, 30, 8), )
if mibBuilder.loadTexts: rsStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortTable.setDescription('A table holding STP Information and instance mapping for each port ')
rsStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 30, 8, 1), ).setIndexNames((0, "RADWARE-MIB", "rsStpPortId"))
if mibBuilder.loadTexts: rsStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortEntry.setDescription('An entry in the STP ports table')
rsStpPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpPortId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortId.setDescription('Port Id.')
rsStpPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpPortVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortVlanId.setDescription('Vlan this port belongs to.')
rsStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortPriority.setDescription('STP Priority for this port.')
rsStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortPathCost.setDescription('Port Path Cost.')
rsStpPortModeFast = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 5), FeatureStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpPortModeFast.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortModeFast.setDescription('Whether this port is an Edge port, and should start forwarding immediately.')
rsStpPortEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 6), FeatureStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsStpPortEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortEnabled.setDescription('Whether this port participates in spanning tree')
rsStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discarding", 1), ("learning", 2), ("forwarding", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortState.setDescription('Port State according to STP Algorithm.')
rsStpPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 30, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("root", 2), ("designated", 3), ("alternate", 4), ("backup", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsStpPortRole.setStatus('mandatory')
if mibBuilder.loadTexts: rsStpPortRole.setDescription('Port Role according to STP Algorithm.')
rsStpPortStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 89, 30) + (0,1)).setObjects(("RADWARE-MIB", "rndErrorDesc"), ("RADWARE-MIB", "rndErrorSeverity"))
if mibBuilder.loadTexts: rsStpPortStateTrap.setDescription('This trap is sent to inform the user of silent link failure or physical port state change, initiated by STP.')
rsSystemFansTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 162), )
if mibBuilder.loadTexts: rsSystemFansTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsSystemFansTable.setDescription('A table containing the fans status.')
rsSystemFansEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 162, 1), ).setIndexNames((0, "RADWARE-MIB", "rsSystemFanIndex"))
if mibBuilder.loadTexts: rsSystemFansEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsSystemFansEntry.setDescription('Information about a particular fan.')
rsSystemFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 162, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsSystemFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsSystemFanIndex.setDescription('Fan Index.')
rsSystemFansStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 162, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsSystemFansStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rsSystemFansStatus.setDescription('Fan Status.')
rsNetPortUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 164), )
if mibBuilder.loadTexts: rsNetPortUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetPortUtilizationTable.setDescription('Display the port Utilization.')
rsNetPortUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 164, 1), ).setIndexNames((0, "RADWARE-MIB", "rsNetPortUtilizationIndex"))
if mibBuilder.loadTexts: rsNetPortUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetPortUtilizationEntry.setDescription('An entry containing a single port utilization.')
rsNetPortUtilizationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 164, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsNetPortUtilizationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetPortUtilizationIndex.setDescription('The ports index.')
rsNetPortUtilizationEntryInUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 164, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsNetPortUtilizationEntryInUtil.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetPortUtilizationEntryInUtil.setDescription('The inbound utilization in-packets/speed.')
rsNetPortUtilizationEntryOutUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 164, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsNetPortUtilizationEntryOutUtil.setStatus('mandatory')
if mibBuilder.loadTexts: rsNetPortUtilizationEntryOutUtil.setDescription('The outbound utilization out-packets/speed.')
rsHWCPUTemperatureTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 165), )
if mibBuilder.loadTexts: rsHWCPUTemperatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCPUTemperatureTable.setDescription('Display the CPU temperature.')
rsHWCPUTemperatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 165, 1), ).setIndexNames((0, "RADWARE-MIB", "rsHWCPUTemperatureIndex"))
if mibBuilder.loadTexts: rsHWCPUTemperatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCPUTemperatureEntry.setDescription('An entry containing a single CPU temperature.')
rsHWCPUTemperatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 165, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsHWCPUTemperatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCPUTemperatureIndex.setDescription('The CPU index.')
rsHWCPUTemperatureValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 165, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsHWCPUTemperatureValue.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCPUTemperatureValue.setDescription('The CPU temperature.')
rsHWCoreUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 35, 1, 167), )
if mibBuilder.loadTexts: rsHWCoreUtilizationTable.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCoreUtilizationTable.setDescription('Display the device core utilization.')
rsHWCoreUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 35, 1, 167, 1), ).setIndexNames((0, "RADWARE-MIB", "rsHWCoreUtilizationIndex"))
if mibBuilder.loadTexts: rsHWCoreUtilizationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCoreUtilizationEntry.setDescription('An entry containing a single core utilization.')
rsHWCoreUtilizationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 167, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsHWCoreUtilizationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCoreUtilizationIndex.setDescription('The core index.')
rsHWCoreUtilizationValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 35, 1, 167, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsHWCoreUtilizationValue.setStatus('mandatory')
if mibBuilder.loadTexts: rsHWCoreUtilizationValue.setDescription('The core utilization.')
rsWSDResourceUtilizationInstance1 = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 181), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDResourceUtilizationInstance1.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDResourceUtilizationInstance1.setDescription('Resource Utilization of WSD on instance 1. Considers network utilization and internal CPU utilization')
rsWSDREResourceUtilizationInstance1 = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 182), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDREResourceUtilizationInstance1.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDREResourceUtilizationInstance1.setDescription('Resource Utilization of network utilization on instance 1')
rsWSDRSResourceUtilizationInstance1 = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 183), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsWSDRSResourceUtilizationInstance1.setStatus('mandatory')
if mibBuilder.loadTexts: rsWSDRSResourceUtilizationInstance1.setDescription('Resource Utilization of internal CPU utilization on instance 1')
rdwr5SecAvgResourceUtilizationInstance1 = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 184), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwr5SecAvgResourceUtilizationInstance1.setStatus('mandatory')
if mibBuilder.loadTexts: rdwr5SecAvgResourceUtilizationInstance1.setDescription('Average 5 seconds Resource Utilization of internal CPU utilization on instance 1')
rdwr60SecAvgResourceUtilizationInstance1 = MibScalar((1, 3, 6, 1, 4, 1, 89, 35, 1, 185), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdwr60SecAvgResourceUtilizationInstance1.setStatus('mandatory')
if mibBuilder.loadTexts: rdwr60SecAvgResourceUtilizationInstance1.setDescription('Average 60 seconds Resource Utilization of internal CPU utilization on instance 1')
mibBuilder.exportSymbols("RADWARE-MIB", rndIpHost=rndIpHost, rsSSLCertificateImportExportPassphrase=rsSSLCertificateImportExportPassphrase, rdwrClientsViewDstAddrFrom=rdwrClientsViewDstAddrFrom, arpSpec=arpSpec, reaIpFftFacsSrcIndex=reaIpFftFacsSrcIndex, rsIpRipFilterLclIpIntf=rsIpRipFilterLclIpIntf, rndMibFilesTable=rndMibFilesTable, rsWSDThreshTrapFloodDelay=rsWSDThreshTrapFloodDelay, rsIpRipFilterGlbMatchBits=rsIpRipFilterGlbMatchBits, rdwrFanInfo=rdwrFanInfo, rdwrHardDiskLogging=rdwrHardDiskLogging, rsMaxRadiusUsersEntriesAfterReset=rsMaxRadiusUsersEntriesAfterReset, rdwrRedundancyInfoMyAddress=rdwrRedundancyInfoMyAddress, rsWSDThresholdWarnings=rsWSDThresholdWarnings, rdwrPowerSupply2Status=rdwrPowerSupply2Status, rsPhysPortMirrorRxTx=rsPhysPortMirrorRxTx, rspRadiusParameters=rspRadiusParameters, rsDnsrStaticResEntry=rsDnsrStaticResEntry, rdwrApplicationFileTable=rdwrApplicationFileTable, rdwrRedundancyInfoTable=rdwrRedundancyInfoTable, rsSSDvlUpCriterion=rsSSDvlUpCriterion, rsRip2IfConfAutoSend=rsRip2IfConfAutoSend, rsGetConfigFileAppendReboot=rsGetConfigFileAppendReboot, rsPhysPortMirrorStatus=rsPhysPortMirrorStatus, rsLoadSoftware=rsLoadSoftware, rsWSDStaticStatus=rsWSDStaticStatus, rsDnsrSUrl=rsDnsrSUrl, rdwrClientsViewIndex=rdwrClientsViewIndex, rsIpAdEntNetMask=rsIpAdEntNetMask, rdwrDayLightSavingEndDate=rdwrDayLightSavingEndDate, rdwrClientsViewFarmName=rdwrClientsViewFarmName, ipLeakExtDirectToOspf=ipLeakExtDirectToOspf, rsWSDPrivateRetries=rsWSDPrivateRetries, rsSSLCertificateLocality=rsSSLCertificateLocality, rdwrApplicationFileRunning=rdwrApplicationFileRunning, rsMaxRadiusEntriesTuning=rsMaxRadiusEntriesTuning, rdwrSnmpErrorDescription=rdwrSnmpErrorDescription, rdwrClientsViewSrcAddrFrom=rdwrClientsViewSrcAddrFrom, rdwrVrrpAssoIpV6AddrTable=rdwrVrrpAssoIpV6AddrTable, reaFacsEnable=reaFacsEnable, rdwrAutoRowGenerationStatus=rdwrAutoRowGenerationStatus, rsTacacsServer=rsTacacsServer, rsWSDPingPortsTable=rsWSDPingPortsTable, RouteTag=RouteTag, rsRadiusBackupServerSecret=rsRadiusBackupServerSecret, abortTftp=abortTftp, rsDbgLevel=rsDbgLevel, rsWSDSNMPPhysicalPortSSLState=rsWSDSNMPPhysicalPortSSLState, rdwrClearTheLogFile=rdwrClearTheLogFile, rsScheduleDays=rsScheduleDays, rsWSDPrivateExtraVar2Weight=rsWSDPrivateExtraVar2Weight, rndDeleteValueEntryStatus=rndDeleteValueEntryStatus, rsWSDNTCheckEntry=rsWSDNTCheckEntry, rdwrMasterInterfaceGroupingPortsEntry=rdwrMasterInterfaceGroupingPortsEntry, rsSSLCertificateSyncProblem=rsSSLCertificateSyncProblem, ipxSapTblOverflow=ipxSapTblOverflow, NetNumber=NetNumber, rsStpDefaultMaxAgingTime=rsStpDefaultMaxAgingTime, rsRadiusClientLifeTime=rsRadiusClientLifeTime, virtualLanUserEtherType=virtualLanUserEtherType, rsWSDServerUp=rsWSDServerUp, rndFACSNetFiltering=rndFACSNetFiltering, rndCommunityString=rndCommunityString, rsWSDIfCompressionStatus=rsWSDIfCompressionStatus, rsWSDDuplexMode=rsWSDDuplexMode, rsDnsServerSrowStatus=rsDnsServerSrowStatus, rndRowDeleteValue=rndRowDeleteValue, rsWSDDRAMSize=rsWSDDRAMSize, rsIfIndex=rsIfIndex, rsTacacsSecondaryServerAddr=rsTacacsSecondaryServerAddr, rsFSapplVersion=rsFSapplVersion, rsLockUserAfterLoginFailure=rsLockUserAfterLoginFailure, rdwrConfigurationFileTable=rdwrConfigurationFileTable, rndSysId=rndSysId, rsConf=rsConf, rsWSDNTIncomingTrafficWeight=rsWSDNTIncomingTrafficWeight, rndMonitoringEntry=rndMonitoringEntry, rsWSDUserLocked=rsWSDUserLocked, rdwrDBind=rdwrDBind, virtualLanAutoConfAgingTimeout=virtualLanAutoConfAgingTimeout, VrId=VrId, eventDesc=eventDesc, cdeEnterOutOfSync=cdeEnterOutOfSync, rndMonitoringLogfile=rndMonitoringLogfile, rdwrConfigurationFileApp=rdwrConfigurationFileApp, rdwrClientsViewDstPortTo=rdwrClientsViewDstPortTo, rsPhysPortMirrorBackupStatus=rsPhysPortMirrorBackupStatus, rsWSDClientMirrorPollingTime=rsWSDClientMirrorPollingTime, rsMaxZhrConnsAfterReset=rsMaxZhrConnsAfterReset, rdwrRip2IfConfDefaultMetric=rdwrRip2IfConfDefaultMetric, rsWSDIfEntry=rsWSDIfEntry, rsACCReasonFTPportCounter=rsACCReasonFTPportCounter, rsStpInstanceRootPathCost=rsStpInstanceRootPathCost, rsTacacsCommandAuthorizationStatus=rsTacacsCommandAuthorizationStatus, rndHardwareConfiguration=rndHardwareConfiguration, rdwrCommonClientTable=rdwrCommonClientTable, rsWSDStaticForwardingTable=rsWSDStaticForwardingTable, rsRadiusBackupServerAddr=rsRadiusBackupServerAddr, rdwrIkePfsKeyGroup=rdwrIkePfsKeyGroup, rdwrTemperatureThresholdStatusCPU2Get=rdwrTemperatureThresholdStatusCPU2Get, rsWSDWebSSLPort=rsWSDWebSSLPort, rndFACSDesAddMask=rndFACSDesAddMask, ipRedundRoutersMainRouterAddr=ipRedundRoutersMainRouterAddr, reaBrgFftEntryNum=reaBrgFftEntryNum, rsCCK=rsCCK, rdwrClientsTable=rdwrClientsTable, rsIcmpGenErrMsgEnable=rsIcmpGenErrMsgEnable, rndMibFileIndex=rndMibFileIndex, rdwrSnmpErrorStatus=rdwrSnmpErrorStatus, rsMaxBridgeForwardingEntriesTuning=rsMaxBridgeForwardingEntriesTuning, rsWSDSyslogStatus=rsWSDSyslogStatus, rsSTATEFUL=rsSTATEFUL, rndAlarmMaxTreshold=rndAlarmMaxTreshold, rdwrRip2IfConfStatus=rdwrRip2IfConfStatus, rsWSDNTRegularCheckPeriod=rsWSDNTRegularCheckPeriod, rsWSDIfStatus=rsWSDIfStatus, rsSSDvLPortIfIndex=rsSSDvLPortIfIndex, startTftp=startTftp, rndIfBaudRate=rndIfBaudRate, rdwrRip2IfConfAuthType=rdwrRip2IfConfAuthType, rdwrIkeInSpi=rdwrIkeInSpi, rsWSDIfChannelType=rsWSDIfChannelType, rndMonitoredElementCommunity=rndMonitoredElementCommunity, rdwrVrrpPriorityTracking=rdwrVrrpPriorityTracking, rdwrWSDCommon=rdwrWSDCommon, ndSpec=ndSpec, rndFACSOperation=rndFACSOperation, rsSSDvLIfIndex=rsSSDvLIfIndex, rsIpZhrStatusIpIntf=rsIpZhrStatusIpIntf, rdwrClientsServerAddr=rdwrClientsServerAddr, rdwrLastConfigurationChangesChangeType=rdwrLastConfigurationChangesChangeType, rsRadiusServerRetries=rsRadiusServerRetries, rsREStateMonitoring=rsREStateMonitoring, rsIcmpRdMaxAdvertInterval=rsIcmpRdMaxAdvertInterval, rsStpPortPriority=rsStpPortPriority, rsHWCPUTemperatureValue=rsHWCPUTemperatureValue, rsACCReasonClassifyCounter=rsACCReasonClassifyCounter, rsWSDTelnetUserTable=rsWSDTelnetUserTable, rsSSDvirtualLanPortsTable=rsSSDvirtualLanPortsTable, rdwrRedundancyInfoEntry=rdwrRedundancyInfoEntry, rsACCReasonAllToMasterCounter=rsACCReasonAllToMasterCounter, rsREStateIPDAnotFFTCounter=rsREStateIPDAnotFFTCounter, rsIpAdEntPeerAddrStatus=rsIpAdEntPeerAddrStatus, rdwrClientsTableStatistics=rdwrClientsTableStatistics, rsRip2IfConfEntry=rsRip2IfConfEntry, reaRsQueueDiscards=reaRsQueueDiscards, rsIpZhrVirtualIpAsSource=rsIpZhrVirtualIpAsSource, rsIncludePrivateKeys=rsIncludePrivateKeys, rdwrDeviceSecondaryBoot=rdwrDeviceSecondaryBoot, rsWSDMirrorProtocolMode=rsWSDMirrorProtocolMode, rndIfChannelType=rndIfChannelType, rsScheduleStatus=rsScheduleStatus, ipSpecRoutePort=ipSpecRoutePort, rsNWSD=rsNWSD, rsWSDNTPStatus=rsWSDNTPStatus, rsFileSystem=rsFileSystem, rsWSDApplicationMirrorEntry=rsWSDApplicationMirrorEntry, cdeMasterConnected=cdeMasterConnected, rsWSDIfBridge=rsWSDIfBridge, rsACC=rsACC, rsIfConfName=rsIfConfName, rndFACSEntry=rndFACSEntry, reaIpFftApplFlags=reaIpFftApplFlags, rsIcmpRdTable=rsIcmpRdTable, rsIGTransitTimeout=rsIGTransitTimeout, ipSpecRouteEntry=ipSpecRouteEntry, rsSSLCertificateDefaultOrganizationUnit=rsSSLCertificateDefaultOrganizationUnit, rdwrRedundancyInfoMode=rdwrRedundancyInfoMode, cdeSlaveReboot=cdeSlaveReboot, rsLinkAggregationHash=rsLinkAggregationHash, rsWSDIfCompressionRate=rsWSDIfCompressionRate, rndCommunityEntry=rndCommunityEntry, rsSSDvirtualLanEntry=rsSSDvirtualLanEntry, rdwrApplicationFileStatus=rdwrApplicationFileStatus, rsSSLCertificateKeySize=rsSSLCertificateKeySize, rndCompCardName=rndCompCardName, rsWSDIfCompression=rsWSDIfCompression, rsACCReasonNoFlowCounter=rsACCReasonNoFlowCounter, rsWSDAuthenticationServerSuccess=rsWSDAuthenticationServerSuccess, rsPhysPortMirrorThresholdInterval=rsPhysPortMirrorThresholdInterval, rsNetPortUtilizationTable=rsNetPortUtilizationTable, rndIfClockType=rndIfClockType, rsWSDRedundancyTakeback=rsWSDRedundancyTakeback, rsLowPriority=rsLowPriority, rdwrCertExpiration=rdwrCertExpiration, rspRadiusattValue=rspRadiusattValue, rdwrConfigurationFilePath=rdwrConfigurationFilePath, rsREStateIPDAinFFTCounter=rsREStateIPDAinFFTCounter, rsStpInstanceRootId=rsStpInstanceRootId, rsWSDSCProtcolsEntry=rsWSDSCProtcolsEntry, reaMltcstBitOn=reaMltcstBitOn, rsNsdWINSAddr=rsNsdWINSAddr, rdwrIkePhase2EncryptionAlg=rdwrIkePhase2EncryptionAlg, rsACCReasonProtolcolTypeCounter=rsACCReasonProtolcolTypeCounter, rdwrIkePhase1Psk=rdwrIkePhase1Psk, rsErrMailParams=rsErrMailParams, rsStpPortPathCost=rsStpPortPathCost, routeTableOverflow=routeTableOverflow, rndFileName=rndFileName, rsCSD=rsCSD, rsWSDIllegalReport=rsWSDIllegalReport, RowStatus=RowStatus, rsWSDSNMPPhysicalPortNumber=rsWSDSNMPPhysicalPortNumber, rsWSDNewEntryOnSourcePort=rsWSDNewEntryOnSourcePort, rdwrRip2IfConfSend=rdwrRip2IfConfSend, rspRadiusOwnAccPort=rspRadiusOwnAccPort, rsSystemFansTable=rsSystemFansTable, rsMaxZhrConns=rsMaxZhrConns, rsAuthenticationMethod=rsAuthenticationMethod, rdwrApplicationFileEntry=rdwrApplicationFileEntry, rdwrConfigurationFileRunning=rdwrConfigurationFileRunning, rdwrSyslogServerDstPort=rdwrSyslogServerDstPort, rsWSDCriticalTrapFloodDelay=rsWSDCriticalTrapFloodDelay, rdwrClientsTableNumEntries5SecAvg=rdwrClientsTableNumEntries5SecAvg, rsIpZhrConnectionSrcIp=rsIpZhrConnectionSrcIp, ipRedundRoutersOperStatus=ipRedundRoutersOperStatus, rsSSLCertificateDefaultCommon=rsSSLCertificateDefaultCommon, rsSystemFansEntry=rsSystemFansEntry, genGroup=genGroup, rsWSDSyslogAddress=rsWSDSyslogAddress, rdwrRip2IfConfEntry=rdwrRip2IfConfEntry, rndManagedDate=rndManagedDate, rspRadiusEnable=rspRadiusEnable, rsWSDREResourceUtilization=rsWSDREResourceUtilization, rsIfSpeed=rsIfSpeed, rsSDinactiveServer=rsSDinactiveServer, ipRedundRoutersTimeout=ipRedundRoutersTimeout, rsWSDSysBaseMACAddress=rsWSDSysBaseMACAddress, rdwrLastConfigurationChangesID=rdwrLastConfigurationChangesID, rsREStateBridgeCounter=rsREStateBridgeCounter, rsAPM=rsAPM, rsIcmpRdIpAdvertAddr=rsIcmpRdIpAdvertAddr, rsIpRipFilterLclNumber=rsIpRipFilterLclNumber, ipLeakStaticToOspf=ipLeakStaticToOspf, rsWSDSerStatRecoveryTime=rsWSDSerStatRecoveryTime, rsSWPasswordStatus=rsSWPasswordStatus, rdwrClientsFarmAddr=rdwrClientsFarmAddr, ipLeakRipToOspf=ipLeakRipToOspf, rsPhysPortMirrorDstPort=rsPhysPortMirrorDstPort, rsFSapplStartup=rsFSapplStartup, rsIpAdEntForwardIpBroadcast=rsIpAdEntForwardIpBroadcast, rdwrRip2IfConfVirtualDis=rdwrRip2IfConfVirtualDis, ip6NetToMediaEntry=ip6NetToMediaEntry, genGroupConfigurationSymbol=genGroupConfigurationSymbol, rsIpZhrVirtAddressTo=rsIpZhrVirtAddressTo, rsWSDTelnetUserEntry=rsWSDTelnetUserEntry, rdwrPowerSupplyStatus=rdwrPowerSupplyStatus, rspRadiusTransparentEnable=rspRadiusTransparentEnable, rsScheduleName=rsScheduleName, rsConfigurationAuditStatus=rsConfigurationAuditStatus, rdwrSnmpConfigFileFormat=rdwrSnmpConfigFileFormat, rsRadiusServerTimeout=rsRadiusServerTimeout, rdwrSnmpErrorTbStatus=rdwrSnmpErrorTbStatus, rsIfDuplex=rsIfDuplex)
mibBuilder.exportSymbols("RADWARE-MIB", rndCommunityStatus=rndCommunityStatus, rsGetConfigFileType=rsGetConfigFileType, virtualLanPortEntry=virtualLanPortEntry, reaIpxFftTable=reaIpxFftTable, rndIfIndex=rndIfIndex, rdwrRip2IfConfAuthKey=rdwrRip2IfConfAuthKey, rdwrRip2IfConfAutoSend=rdwrRip2IfConfAutoSend, rsIpZhrConnectionAge=rsIpZhrConnectionAge, cdeDisconnected=cdeDisconnected, rsWSDIfBaudRate=rsWSDIfBaudRate, TruthValue=TruthValue, errorsDuringInit=errorsDuringInit, rsWSDServerStatTable=rsWSDServerStatTable, rsWSDTelnetParams=rsWSDTelnetParams, rsPhysPortMirrorMode=rsPhysPortMirrorMode, rsPhysPortMirrorThreshold=rsPhysPortMirrorThreshold, rdwrConfigurationFileEntry=rdwrConfigurationFileEntry, rsVWSDDataStatus=rsVWSDDataStatus, reaSrcViolationTrapEnable=reaSrcViolationTrapEnable, reaIpFftDstMacAddr=reaIpFftDstMacAddr, rdwrVrrpAssoIpV6AddrRowStatus=rdwrVrrpAssoIpV6AddrRowStatus, reaBrgFftReNum=reaBrgFftReNum, rdwrRip2IfConfSrcAddress=rdwrRip2IfConfSrcAddress, rspRadiusrowStatus=rspRadiusrowStatus, rsArpDeleteTable=rsArpDeleteTable, rdwrDefCfg=rdwrDefCfg, reaBrgDiscards=reaBrgDiscards, vlProto=vlProto, rdwrApplicationFileStartup=rdwrApplicationFileStartup, rsWSDSyslogSourcePort=rsWSDSyslogSourcePort, rdwrVrrpAssoIpV6VrId=rdwrVrrpAssoIpV6VrId, rdwrTemperatureCPU2Get=rdwrTemperatureCPU2Get, rsWSDPingPhysicalPortNumber=rsWSDPingPhysicalPortNumber, rdwrDefCfgCommunity=rdwrDefCfgCommunity, rndWanHeader=rndWanHeader, rdwrSnmpErrorTbVarId=rdwrSnmpErrorTbVarId, rdwr5SecAvgResourceUtilization=rdwr5SecAvgResourceUtilization, rndCommunityAccess=rndCommunityAccess, rdwrDeviceActiveBoot=rdwrDeviceActiveBoot, rsWSDVersionStatus=rsWSDVersionStatus, rndIfTable=rndIfTable, rsACCReasonInconsistentPktLenCounter=rsACCReasonInconsistentPktLenCounter, rsConfigurationIdentifier=rsConfigurationIdentifier, rdwrLastConfigurationChangesTableReset=rdwrLastConfigurationChangesTableReset, rsACCReasonIPHeaderLenCounter=rsACCReasonIPHeaderLenCounter, rsSSLCertificateImportExport=rsSSLCertificateImportExport, reaBrgFftMacAddr=reaBrgFftMacAddr, rsStpInstanceDesignatedPortId=rsStpInstanceDesignatedPortId, lreVnResposibilityEntry=lreVnResposibilityEntry, rdwrClientsTableNumEntries60SecAvg=rdwrClientsTableNumEntries60SecAvg, rsNsdMode=rsNsdMode, rdwrSnmpErrorRequestId=rdwrSnmpErrorRequestId, rndMibFileRefresh=rndMibFileRefresh, rndBridgeType=rndBridgeType, lreVnResposibilityTable=lreVnResposibilityTable, rsIcmpRdMinAdvertInterval=rsIcmpRdMinAdvertInterval, rdwrSyslogServerAddress=rdwrSyslogServerAddress, rsSmtpAlternateAddr=rsSmtpAlternateAddr, rsMaxEntriesTuning=rsMaxEntriesTuning, rdwrDeviceNumberOfPorts=rdwrDeviceNumberOfPorts, rsPhysPortMirrorActiveDstPort=rsPhysPortMirrorActiveDstPort, ipIfPrefix=ipIfPrefix, rndFACS=rndFACS, rsWSDHttpsParams=rsWSDHttpsParams, rsWSDCapacityLimitReached=rsWSDCapacityLimitReached, rsWSDFlashSize=rsWSDFlashSize, rsWSDNTAvResponseWeight=rsWSDNTAvResponseWeight, rndApsoluteOSVersion=rndApsoluteOSVersion, rsIcmpRdEntStatus=rsIcmpRdEntStatus, rndBootP=rndBootP, ipSpecRouteMetric=ipSpecRouteMetric, rsTacacsPrimaryServerAddr=rsTacacsPrimaryServerAddr, rsTacacsSecondaryServerPort=rsTacacsSecondaryServerPort, rndIfBridge=rndIfBridge, rsStpPortStateTrap=rsStpPortStateTrap, rdwrLastConfigurationChangesTable=rdwrLastConfigurationChangesTable, ipRipFilter=ipRipFilter, rsWSDSNMPPhysicalPortSSHState=rsWSDSNMPPhysicalPortSSHState, rspRadiusNasrowStatus=rspRadiusNasrowStatus, reaIpFftPortNum=reaIpFftPortNum, rsSystemFanIndex=rsSystemFanIndex, rdwrTerminalAliasTable=rdwrTerminalAliasTable, rsIcmpRdAdvertLifetime=rsIcmpRdAdvertLifetime, rsSESSION=rsSESSION, vLIfIndex=vLIfIndex, lreResetDstMacBit47=lreResetDstMacBit47, rndAlarmMinTreshold=rndAlarmMinTreshold, rsVWSDDataPermissionsTableEntry=rsVWSDDataPermissionsTableEntry, rdwrRip2IfConfDomain=rdwrRip2IfConfDomain, rsWSDSshParams=rsWSDSshParams, rsTacacsClientAging=rsTacacsClientAging, rsACCReasonNoReasonCounter=rsACCReasonNoReasonCounter, rdwrClientsSourceAddr=rdwrClientsSourceAddr, rsVWSDUserGroup=rsVWSDUserGroup, rsRadiusMainServerPort=rsRadiusMainServerPort, rndFACSSrcAddMask=rndFACSSrcAddMask, rsFSapplActive=rsFSapplActive, rdwrClientsIndex=rdwrClientsIndex, rsWSDSshStatus=rsWSDSshStatus, lreVnRespStatus=lreVnRespStatus, rsStatistics=rsStatistics, rsMaxArpEntriesTuning=rsMaxArpEntriesTuning, reaIpxInDiscards=reaIpxInDiscards, rsScheduleTime=rsScheduleTime, rdwrClientsViewTable=rdwrClientsViewTable, rsStpMode=rsStpMode, tftp=tftp, ipSpecRouteLabel=ipSpecRouteLabel, rsIpZhrConnectionType=rsIpZhrConnectionType, rdwrSyslogUserAuditSending=rdwrSyslogUserAuditSending, rsGetConfigFile=rsGetConfigFile, rspRadiusNasSecret=rspRadiusNasSecret, rsWSDTelnetUserStatus=rsWSDTelnetUserStatus, wsdRedundTimeout=wsdRedundTimeout, rdwrPortsTagTable=rdwrPortsTagTable, rdwrVrrpAssoIpV6IfIndex=rdwrVrrpAssoIpV6IfIndex, rsSSLCertificateEntryType=rsSSLCertificateEntryType, reaBridgeFftEntry=reaBridgeFftEntry, rdwrSnmpErrorIndex=rdwrSnmpErrorIndex, rsACCReasonIPVERCounter=rsACCReasonIPVERCounter, rsSSDvLPortInterfaceGroupingState=rsSSDvLPortInterfaceGroupingState, rdwrRedunForceDownPorts=rdwrRedunForceDownPorts, rsWSDWebSSLCertificateFile=rsWSDWebSSLCertificateFile, rndMibFileEntryStatus=rndMibFileEntryStatus, rsIfTable=rsIfTable, rsWSDPingPhysicalPortState=rsWSDPingPhysicalPortState, ipIfIndex=ipIfIndex, rsStpDefaultForwardDelayTime=rsStpDefaultForwardDelayTime, eventMessageEntry=eventMessageEntry, rsWSDTelnetUserName=rsWSDTelnetUserName, rdwrLastConfigurationChangesMibOid=rdwrLastConfigurationChangesMibOid, rsIfConfEntry=rsIfConfEntry, rsACCReasonFTP227Counter=rsACCReasonFTP227Counter, ipRedundRoutersIfAddr=ipRedundRoutersIfAddr, reaIpFftReNum=reaIpFftReNum, rsWSDNTPInterval=rsWSDNTPInterval, rsREStateCounters=rsREStateCounters, ipIfBcastAddr=ipIfBcastAddr, rsWSDSyslogGlobalStatus=rsWSDSyslogGlobalStatus, rsErrMailSrcAddress=rsErrMailSrcAddress, rdwrClientsTimeToLive=rdwrClientsTimeToLive, rdwrSnmpErrorTbRequestId=rdwrSnmpErrorTbRequestId, rsWSDSelectServerOnSourcePort=rsWSDSelectServerOnSourcePort, rsWSDDNSResolution=rsWSDDNSResolution, rsHWCoreUtilizationEntry=rsHWCoreUtilizationEntry, rsTuneCheckMemory=rsTuneCheckMemory, rndCommunityMngStationAddr=rndCommunityMngStationAddr, rsIpZhrAgingTimeout=rsIpZhrAgingTimeout, rsWSDUserPassword=rsWSDUserPassword, rsRadiusBackupServerPort=rsRadiusBackupServerPort, rndBrgFeatures=rndBrgFeatures, rsWSDClientMirrorPercentage=rsWSDClientMirrorPercentage, rsWSDUserVersion=rsWSDUserVersion, cdeConnected=cdeConnected, rsWSDNTPServerUrl=rsWSDNTPServerUrl, rsWSDSysManagedDate=rsWSDSysManagedDate, rndAlarmOptions=rndAlarmOptions, genGroupHWStatus=genGroupHWStatus, rspRadiusUserMirrorPollingTime=rspRadiusUserMirrorPollingTime, reaFftHashMaxChain=reaFftHashMaxChain, rsWSDIfLATCompression=rsWSDIfLATCompression, reaIpxFftEntry=reaIpxFftEntry, rsSSLCertificateOrganization=rsSSLCertificateOrganization, reaBrgFftFacsDstIndex=reaBrgFftFacsDstIndex, rsRipEnable=rsRipEnable, rndEraseSimulatedConfiguration=rndEraseSimulatedConfiguration, rsWSDStaticForwardingEntry=rsWSDStaticForwardingEntry, rdwrPortsTagPortOutTag=rdwrPortsTagPortOutTag, ipIfVlanTag=ipIfVlanTag, rdwrSnmpErrorTbTime=rdwrSnmpErrorTbTime, rsWSDBackupInterfaceGrouping=rsWSDBackupInterfaceGrouping, rsIpZeroHopRouting=rsIpZeroHopRouting, rndFACSMask1Id=rndFACSMask1Id, rsRegistrationStatus=rsRegistrationStatus, rsSSLCertificateRequestedValidityPeriod=rsSSLCertificateRequestedValidityPeriod, rsSSDvlProto=rsSSDvlProto, rsWSDSNMPPhysicalPortTelnetState=rsWSDSNMPPhysicalPortTelnetState, rsVWSDDataType=rsVWSDDataType, reaIpxFftFacsDstIndex=reaIpxFftFacsDstIndex, rsIpZhrStatusTable=rsIpZhrStatusTable, rsLinkAggregationL3Hash=rsLinkAggregationL3Hash, rdwrClientsTableNumEntries=rdwrClientsTableNumEntries, rdwrVrrpOperAdvertisementInterval=rdwrVrrpOperAdvertisementInterval, rndMonitoringEntryStatus=rndMonitoringEntryStatus, autoConfigurationCompleted=autoConfigurationCompleted, virtualLanTable=virtualLanTable, rsWSDTelnetUserEAddr=rsWSDTelnetUserEAddr, rsWSDNTTCPLimitWeight=rsWSDNTTCPLimitWeight, rsWSDSerStatAttUsersNum=rsWSDSerStatAttUsersNum, rsIfAutoNegotiate=rsIfAutoNegotiate, rsIpZhrVirtAddressIpIntf=rsIpZhrVirtAddressIpIntf, ipRouteLeaking=ipRouteLeaking, rsDnsrParameters=rsDnsrParameters, rsACCReasonTTLCounter=rsACCReasonTTLCounter, rsIpRipFilterGlbEntry=rsIpRipFilterGlbEntry, rspRadiusPrimaryAddr=rspRadiusPrimaryAddr, rsStpInstanceDesignatedBridgeId=rsStpInstanceDesignatedBridgeId, rdwrMirroring=rdwrMirroring, rsSSDvLPortType=rsSSDvLPortType, reaIpFftDstIpAddr=reaIpFftDstIpAddr, rdwrMirroringActiveBackupSleep=rdwrMirroringActiveBackupSleep, rsREStateResetCounter=rsREStateResetCounter, ipLeakAdvertiseOSPFAccordingtoPortRules=ipLeakAdvertiseOSPFAccordingtoPortRules, rdwr60SecAvgResourceUtilization=rdwr60SecAvgResourceUtilization, rsTacacsPrimaryServerSecret=rsTacacsPrimaryServerSecret, rdwrIkePhase1LifeTime=rdwrIkePhase1LifeTime, rsIpZhrVirtAddressStatus=rsIpZhrVirtAddressStatus, rsIpRipFilterLclTable=rsIpRipFilterLclTable, rsWSDWebSoapSupportStatus=rsWSDWebSoapSupportStatus, rsSSLCertificateImportExportAction=rsSSLCertificateImportExportAction, ipSpecRouteTable=ipSpecRouteTable, vLPortType=vLPortType, rndDefaultPollingInterval=rndDefaultPollingInterval, rsWSDSerStatFramesLoad=rsWSDSerStatFramesLoad, rsRip2IfConfVirtualDis=rsRip2IfConfVirtualDis, rsWSDNTP=rsWSDNTP, rndFACSIfIndex=rndFACSIfIndex, rsMaxIpxSapEntriesAfterReset=rsMaxIpxSapEntriesAfterReset, rsIpAdEntOneIpMode=rsIpAdEntOneIpMode, rdwrConfigurationFileInstalled=rdwrConfigurationFileInstalled, rdwrDeviceType=rdwrDeviceType, rsWSDSshPort=rsWSDSshPort, rdwrClientsUserData1=rdwrClientsUserData1, icmpSpec=icmpSpec, reaIpForwardEnable=reaIpForwardEnable, rsRadwareVrrpErrors=rsRadwareVrrpErrors, rsWSDNTCheckTable=rsWSDNTCheckTable, rsTunning=rsTunning, reaBufFree=reaBufFree, rsDnsServerSEnable=rsDnsServerSEnable, rsStpPortId=rsStpPortId, rsIpRipFilterGlbNetworkMaskBits=rsIpRipFilterGlbNetworkMaskBits, rsMaxRadiusUsersEntries=rsMaxRadiusUsersEntries, rsStpPortRole=rsStpPortRole, reaIpxFftPortNum=reaIpxFftPortNum, rdwrDayLightSavingEnds=rdwrDayLightSavingEnds, rdwrDayLightSavingBegins=rdwrDayLightSavingBegins, facsAccessVoilation=facsAccessVoilation, rdwrDedicatedManagementPort=rdwrDedicatedManagementPort, rsWSDManagementPortsTable=rsWSDManagementPortsTable, rdwrIkeAuthntKey=rdwrIkeAuthntKey, vlIfIndex=vlIfIndex, wsdRedundStatus=wsdRedundStatus, rdwrIpsecIke=rdwrIpsecIke, rndDeleteValuesTable=rndDeleteValuesTable, rsSmtpParameters=rsSmtpParameters, rsWSDUseOneTrap=rsWSDUseOneTrap, rdwrVrrpAssoIpV6Addr=rdwrVrrpAssoIpV6Addr, rsNetPortUtilizationIndex=rsNetPortUtilizationIndex, fanNotWorking=fanNotWorking, rsMaxZeroHopRoutEntriesTuning=rsMaxZeroHopRoutEntriesTuning, rsIpZhrVirtAddressFrom=rsIpZhrVirtAddressFrom, rsFSinstallNew=rsFSinstallNew, rsHWCoreUtilizationValue=rsHWCoreUtilizationValue)
mibBuilder.exportSymbols("RADWARE-MIB", rsIpRipFilterGlbType=rsIpRipFilterGlbType, virtualLan=virtualLan, rsWSDStaticInPort=rsWSDStaticInPort, rsWSDNTPTimeZone=rsWSDNTPTimeZone, rsScheduleFrequency=rsScheduleFrequency, rdwrVrrpAdmin=rdwrVrrpAdmin, rsWSDAuthenticationServerFail=rsWSDAuthenticationServerFail, reaBridgeEnable=reaBridgeEnable, reaIpFftSrcMacAddr=reaIpFftSrcMacAddr, rspRadiusPrimaryAccPort=rspRadiusPrimaryAccPort, rndMonitoringInterval=rndMonitoringInterval, rsIpZhrConnectionStatus=rsIpZhrConnectionStatus, rsWSDLicense=rsWSDLicense, rsDnsServerParameters=rsDnsServerParameters, rsWSDIfNetAddress=rsWSDIfNetAddress, rndMonitoredElementStatus=rndMonitoredElementStatus, rdwrSyslogHealthSending=rdwrSyslogHealthSending, rsMaxRadiusNasAuthEntries=rsMaxRadiusNasAuthEntries, rsNetNdInactiveTimeOut=rsNetNdInactiveTimeOut, rsWSDSerStatName=rsWSDSerStatName, rsTacacsServerRetries=rsTacacsServerRetries, rsWSDTelnetUserPassword=rsWSDTelnetUserPassword, rdwrPowerSupplyTrapStatus=rdwrPowerSupplyTrapStatus, eventMessageTable=eventMessageTable, rdwrClientsNATPort=rdwrClientsNATPort, rsSSLCertificateDefaultStateOrProvince=rsSSLCertificateDefaultStateOrProvince, reaIpFftDstIpMask=reaIpFftDstIpMask, ipIfEntry=ipIfEntry, rsMaxDspClntEntriesAfterReset=rsMaxDspClntEntriesAfterReset, rdwrClientsNATaddr=rdwrClientsNATaddr, rsWSDSCProtocolStatus=rsWSDSCProtocolStatus, rdwrHardDisk=rdwrHardDisk, rsWSDBuildNumber=rsWSDBuildNumber, rdwrSyslogServerNumberOfLogsInBackLog=rdwrSyslogServerNumberOfLogsInBackLog, rsARPTableIpConflict=rsARPTableIpConflict, rsMaxDspFrmEntriesTuning=rsMaxDspFrmEntriesTuning, virtualLanEntry=virtualLanEntry, ipSpecRouteDest=ipSpecRouteDest, rsIcmpRdPreferenceLevel=rsIcmpRdPreferenceLevel, rsMaxRoutingEntriesTuning=rsMaxRoutingEntriesTuning, rsSSDvirtualLanTable=rsSSDvirtualLanTable, rsACCReasonUnknownCounter=rsACCReasonUnknownCounter, rsSSDvlIfIndex=rsSSDvlIfIndex, rdwrSyslogServerSrcPort=rdwrSyslogServerSrcPort, rdwrRedundancyInfoVRID=rdwrRedundancyInfoVRID, rndMonitoredObjectInstanceLabel=rndMonitoredObjectInstanceLabel, rdwrClientsClientType=rdwrClientsClientType, rsIpRipFilterGlbTable=rsIpRipFilterGlbTable, rsWSDSNMPPhysicalPortState=rsWSDSNMPPhysicalPortState, rsSSLCertificateDefaultCountryName=rsSSLCertificateDefaultCountryName, rsWSDRemoteWSDUnavailable=rsWSDRemoteWSDUnavailable, ipxRipTblOverflow=ipxRipTblOverflow, rsIpAdEntStatus=rsIpAdEntStatus, rsFileServerAddress=rsFileServerAddress, rsFSapplName=rsFSapplName, rsMaxIpForwardingEntriesTuning=rsMaxIpForwardingEntriesTuning, rdwrTemperatureWarningThresholdGet=rdwrTemperatureWarningThresholdGet, rdwrCdbTimeStamp=rdwrCdbTimeStamp, reaIpFftRangeType=reaIpFftRangeType, rsIpZhrConnectionVirtualIp=rsIpZhrConnectionVirtualIp, rdwrDualPsuStatus=rdwrDualPsuStatus, rdwrArpWithInterfaceGroup=rdwrArpWithInterfaceGroup, rdwrTerminalAliasStatus=rdwrTerminalAliasStatus, rndMonitoredObjectSyntax=rndMonitoredObjectSyntax, rsWSDSysParams=rsWSDSysParams, lreBoxAgentIP=lreBoxAgentIP, reaSrcAddrValidationEnable=reaSrcAddrValidationEnable, rsSSLCertificateDefaultValues=rsSSLCertificateDefaultValues, cdeCannotSync=cdeCannotSync, reaIpInDiscards=reaIpInDiscards, rsPrivateCheckSNMPPort=rsPrivateCheckSNMPPort, removeViewTablePermissionReductionCheck=removeViewTablePermissionReductionCheck, rdwrClientsViewSrcAddrTo=rdwrClientsViewSrcAddrTo, rdwrClientsViewAction=rdwrClientsViewAction, rdwrPortsTagPortInTag=rdwrPortsTagPortInTag, rndSSLCardName=rndSSLCardName, rdwrClientsType=rdwrClientsType, rsWSDThroughputLicense=rsWSDThroughputLicense, rndHighPriorityIf=rndHighPriorityIf, rip2Spec=rip2Spec, rsIpRipFilterLclNetworkMaskBits=rsIpRipFilterLclNetworkMaskBits, rndIfCompressionType=rndIfCompressionType, rndMonitoredObjectName=rndMonitoredObjectName, rdwrDefCfgPort=rdwrDefCfgPort, rsWSDSshAllowPwdAndPubKey=rsWSDSshAllowPwdAndPubKey, ip6NetToMediaNetAddress=ip6NetToMediaNetAddress, rsMaxIpFrwEntriesAfterReset=rsMaxIpFrwEntriesAfterReset, rsWSDSNMPPortsEntry=rsWSDSNMPPortsEntry, rndMonitoredObjectIdentifier=rndMonitoredObjectIdentifier, rsIpAddrTable=rsIpAddrTable, rsVlanTagHandling=rsVlanTagHandling, lreQueSourceSelect=lreQueSourceSelect, wsdRedundFarmAddr=wsdRedundFarmAddr, rdwrMngmntPortDisabled=rdwrMngmntPortDisabled, reaIpxFftDstMacAddr=reaIpxFftDstMacAddr, rsStpDefaultHelloTime=rsStpDefaultHelloTime, cdeInSync=cdeInSync, vLPortStatus=vLPortStatus, reaIpFftEntry=reaIpFftEntry, rdwrClientsViewDstPortFrom=rdwrClientsViewDstPortFrom, rsWSDIntrusionDetected=rsWSDIntrusionDetected, rdwrFtpStatus=rdwrFtpStatus, rsWSDNTOutgoingTrafficWeight=rsWSDNTOutgoingTrafficWeight, rsWSDSecuredComm=rsWSDSecuredComm, reaIpxFftEntryNum=reaIpxFftEntryNum, rsMaxIpxFrwEntriesAfterReset=rsMaxIpxFrwEntriesAfterReset, rdwrSnmpParameters=rdwrSnmpParameters, rdwrSnmpSupportedVersions=rdwrSnmpSupportedVersions, rdwrClientsViewServerAddr=rdwrClientsViewServerAddr, rsWSDManagementPortsEntry=rsWSDManagementPortsEntry, deviceTemperatureCritical=deviceTemperatureCritical, BitFlag=BitFlag, reaIpxFftDstNetid=reaIpxFftDstNetid, rsMaxRadiusNasAuthEntriesAfterReset=rsMaxRadiusNasAuthEntriesAfterReset, rsWSDNTUsersLimitWeight=rsWSDNTUsersLimitWeight, rsACCReasonIPLenghtCounter=rsACCReasonIPLenghtCounter, rsWSDIfClockType=rsWSDIfClockType, rndIfCompressionStatus=rndIfCompressionStatus, rsConfigurationAuditEvent=rsConfigurationAuditEvent, rdwrDP=rdwrDP, rdwrMirroringActiveSleep=rdwrMirroringActiveSleep, reaIpxFftReNum=reaIpxFftReNum, rsIpRipFilterLclType=rsIpRipFilterLclType, rndVisionDriverActiveName=rndVisionDriverActiveName, rsTacacsPrimaryServerPort=rsTacacsPrimaryServerPort, rdwrCdbParameters=rdwrCdbParameters, rsStpPortState=rsStpPortState, rndFACSActIfIndex=rndFACSActIfIndex, rsWSDHardwareLicenseID=rsWSDHardwareLicenseID, rndDuplexMode=rndDuplexMode, ipSpecRouteNextHop=ipSpecRouteNextHop, rdwrIkePhase1EncryptionAlg=rdwrIkePhase1EncryptionAlg, rsPhysPortMirrorSrcInf=rsPhysPortMirrorSrcInf, rdwrClientsViewFarmAddr=rdwrClientsViewFarmAddr, rsWSDPrivateExtraVar2Mode=rsWSDPrivateExtraVar2Mode, rndIfCompressionRate=rndIfCompressionRate, rsWSDWebParams=rsWSDWebParams, rsWSDPrivateExtraVar1ID=rsWSDPrivateExtraVar1ID, rdwrSnmpErrorTbType=rdwrSnmpErrorTbType, rsRip2IfConfTable=rsRip2IfConfTable, rsGetConfigErrorLog=rsGetConfigErrorLog, rndFACSActType=rndFACSActType, rndIPX=rndIPX, rsWSDServerStatEntry=rsWSDServerStatEntry, rdwrTemperatureShutdownThresholdGet=rdwrTemperatureShutdownThresholdGet, rsACCReasonFINorRSTCounter=rsACCReasonFINorRSTCounter, rdwrRip2IfConfReceive=rdwrRip2IfConfReceive, rspRadiusAltSecret=rspRadiusAltSecret, virtualLanProtocolVlan=virtualLanProtocolVlan, reaBrgFftFacsSrcIndex=reaBrgFftFacsSrcIndex, rsWSDPortIndex=rsWSDPortIndex, rsIpZhrStatusEntry=rsIpZhrStatusEntry, rsVWSD=rsVWSD, rdwrSyslogServerConnectionStatus=rdwrSyslogServerConnectionStatus, rdwrPrintToLogAndCli=rdwrPrintToLogAndCli, rsScheduleDate=rsScheduleDate, rsWSDWanHeader=rsWSDWanHeader, rsUserLockoutInterval=rsUserLockoutInterval, rdwrIpsec=rdwrIpsec, ipLeakOspfToRip=ipLeakOspfToRip, rsTacacsSecondaryServerSecret=rsTacacsSecondaryServerSecret, rsWSDNTSerialNum=rsWSDNTSerialNum, rspRadiusAltAccPort=rspRadiusAltAccPort, vlAutoConfStatus=vlAutoConfStatus, lreResetDstMacBit46=lreResetDstMacBit46, rsWSDIfCompressionType=rsWSDIfCompressionType, rsWSDHighPriorityIf=rsWSDHighPriorityIf, rsMaxBrgFrwEntriesAfterReset=rsMaxBrgFrwEntriesAfterReset, rsPlatformIdentifier=rsPlatformIdentifier, rndBrgLicense=rndBrgLicense, vlStatus=vlStatus, rndMonitoredElementEntry=rndMonitoredElementEntry, rsFSapplValid=rsFSapplValid, rdwrSyslogCACertificate=rdwrSyslogCACertificate, rsRadiusMainServerUrl=rsRadiusMainServerUrl, rdwrMirroringActiveBackupUpdate=rdwrMirroringActiveBackupUpdate, rsHWCPUTemperatureTable=rsHWCPUTemperatureTable, rsSSDvlType=rsSSDvlType, rsIpRipFilterLclMatchBits=rsIpRipFilterLclMatchBits, rsConfirmMessagTab=rsConfirmMessagTab, rsWSDSNMPPortsTable=rsWSDSNMPPortsTable, rsMaxArpEntriesAfterReset=rsMaxArpEntriesAfterReset, rndRowStatusObjectId=rndRowStatusObjectId, rdwrConfigurationFileName=rdwrConfigurationFileName, rsStpPortModeFast=rsStpPortModeFast, rsStpInstanceHelloTime=rsStpInstanceHelloTime, rsHWCPUTemperatureIndex=rsHWCPUTemperatureIndex, rndCommunityTable=rndCommunityTable, virtualLanPortsTable=virtualLanPortsTable, rsIfConfType=rsIfConfType, rsWSDSCProtcolsTable=rsWSDSCProtcolsTable, rsIpRipFilterLclEntry=rsIpRipFilterLclEntry, ipSpec=ipSpec, rsWSDTelnetUserWebAccessLevel=rsWSDTelnetUserWebAccessLevel, rsMaxIpxSapEntries=rsMaxIpxSapEntries, rdwrTemperatureThresholdStatusCPU1Get=rdwrTemperatureThresholdStatusCPU1Get, rdwrDayLightSavingBeginDate=rdwrDayLightSavingBeginDate, rndIfFilterMode=rndIfFilterMode, endTftp=endTftp, rsSSLCertificate=rsSSLCertificate, rsSSLCertificateDefaultEMail=rsSSLCertificateDefaultEMail, rdwrDeviceCPUsNumber=rdwrDeviceCPUsNumber, rndApplications=rndApplications, rsWSDWebSSLStatus=rsWSDWebSSLStatus, rsWSDWebAccessLevel=rsWSDWebAccessLevel, stpSpec=stpSpec, rsWSDTelnetPort=rsWSDTelnetPort, rsWSDResourceUtilizationInstance1=rsWSDResourceUtilizationInstance1, rdwrSnmpErrorTbTableReset=rdwrSnmpErrorTbTableReset, cdeConfigUpdateFailed=cdeConfigUpdateFailed, rndIfCompression=rndIfCompression, rndFACSType=rndFACSType, rsWSDTelnetUserConfigurationTraceInf=rsWSDTelnetUserConfigurationTraceInf, rsStpInstanceMaxAgingTime=rsStpInstanceMaxAgingTime, rdwrSnmpPort=rdwrSnmpPort, rndSmartFanStatus=rndSmartFanStatus, vlanDynPortAdded=vlanDynPortAdded, rsDnsrStaticResTable=rsDnsrStaticResTable, rsPhysPortMirrorThresholdReset=rsPhysPortMirrorThresholdReset, rndAction=rndAction, rsWSDWebHelpLocation=rsWSDWebHelpLocation, rsWSDWebStatus=rsWSDWebStatus, rsStpInstanceEntry=rsStpInstanceEntry, rsIpRipFilterGlbIpAddr=rsIpRipFilterGlbIpAddr, rdwrClientsViewEntry=rdwrClientsViewEntry, rndBridgeAlarm=rndBridgeAlarm, rndFACSMask2Id=rndFACSMask2Id, rsSmtpBackupOwnAddr=rsSmtpBackupOwnAddr, rdwrDefCfgIpAddress=rdwrDefCfgIpAddress, rdwrTemperatureCPU1Get=rdwrTemperatureCPU1Get, rsWSDREResourceUtilizationInstance1=rsWSDREResourceUtilizationInstance1, reaIpFftTable=reaIpFftTable, rsIfConfTable=rsIfConfTable, rdwrClientsServerPort=rdwrClientsServerPort, rsWSDAuthenticationSuccess=rsWSDAuthenticationSuccess, rndRowStatusVariableName=rndRowStatusVariableName, rsWSDResourceUtilization=rsWSDResourceUtilization, rsWSDStaticDestinationPort=rsWSDStaticDestinationPort, rndErrorSeverity=rndErrorSeverity, rdwrVrrp=rdwrVrrp, rsWSDWebSSLPrivateKeyFile=rsWSDWebSSLPrivateKeyFile, rsMaxIpFrwEntries=rsMaxIpFrwEntries, rsIcmpRdAdvertise=rsIcmpRdAdvertise, rsStpInstanceEnabled=rsStpInstanceEnabled, ipRedundOperStatus=ipRedundOperStatus, rndMonitoredElementAddress=rndMonitoredElementAddress, rndMonitoredElementLabel=rndMonitoredElementLabel, rdwrApplicationFileValid=rdwrApplicationFileValid, rsPhysPortMirrorTable=rsPhysPortMirrorTable, rsWSDMirrorActiveStatus=rsWSDMirrorActiveStatus, rndVisionDriverRestoreFromBackup=rndVisionDriverRestoreFromBackup, rndFACSTable=rndFACSTable, rdwrClientsClientMode=rdwrClientsClientMode, ipSpecRouteStatus=ipSpecRouteStatus)
mibBuilder.exportSymbols("RADWARE-MIB", rsNetPortUtilizationEntryInUtil=rsNetPortUtilizationEntryInUtil, rsWSDConnectionLimitReached=rsWSDConnectionLimitReached, rsWSDPrivateExtraVar2ID=rsWSDPrivateExtraVar2ID, rsTftpRetryTimeOut=rsTftpRetryTimeOut, rsSmtpPrimaryAddr=rsSmtpPrimaryAddr, rspRadiusNetworkName=rspRadiusNetworkName, rdwrDeviceNetworkDriver=rdwrDeviceNetworkDriver, rndMng=rndMng, rsIpAdEntBcastAddr=rsIpAdEntBcastAddr, rdwrSnmpSupportedVersionsAfterReset=rdwrSnmpSupportedVersionsAfterReset, rsWSDNTPPort=rsWSDNTPPort, rndFACSActTable=rndFACSActTable, rdwrIkeManualKeyMode=rdwrIkeManualKeyMode, rsDnsrAlternateAddr=rsDnsrAlternateAddr, rdwrClientsViewVlanTag=rdwrClientsViewVlanTag, ipIfFwdBroadcast=ipIfFwdBroadcast, rspRadiusPrimarySecret=rspRadiusPrimarySecret, rdwrConfigurationSync=rdwrConfigurationSync, rsWSDWrongPassword=rsWSDWrongPassword, rsStpInstancesTable=rsStpInstancesTable, rsPhysPortMirrorDstStatus=rsPhysPortMirrorDstStatus, rsRadwareNTPUpdateProblem=rsRadwareNTPUpdateProblem, rdwrSyslogServerTable=rdwrSyslogServerTable, rsMaxArpEntries=rsMaxArpEntries, rsWSDThroughputLicenseID=rsWSDThroughputLicenseID, rsWSDTelnetUserSeverity=rsWSDTelnetUserSeverity, rdwrDayLightSaving=rdwrDayLightSaving, rdwrSyslogServerProtocol=rdwrSyslogServerProtocol, rsServerDispatcher=rsServerDispatcher, rndIfBoardNum=rndIfBoardNum, rdwrIkeTable=rdwrIkeTable, rsMaxRoutingEntriesAfterReset=rsMaxRoutingEntriesAfterReset, rndFACSProtocolType=rndFACSProtocolType, rsWSDSNMPPhysicalPortWebState=rsWSDSNMPPhysicalPortWebState, cdeSlaveRebootFailed=cdeSlaveRebootFailed, rsTuneLastCheckResult=rsTuneLastCheckResult, rsSSLCertificateOrganizationUnit=rsSSLCertificateOrganizationUnit, rsSSLCertificateEMail=rsSSLCertificateEMail, genGroupHWVersion=genGroupHWVersion, rsSSDvirtualLanPortEntry=rsSSDvirtualLanPortEntry, rsLinkAggregationL2Hash=rsLinkAggregationL2Hash, rdwrClientsUserData2=rdwrClientsUserData2, rdwrSnmpErrorTbFieldInEntry=rdwrSnmpErrorTbFieldInEntry, rndInactiveArpTimeOut=rndInactiveArpTimeOut, rsIpZhrConnectionEntry=rsIpZhrConnectionEntry, rsSSLCertificateStatus=rsSSLCertificateStatus, rdwrFanNotWorking=rdwrFanNotWorking, virtualLanAutoConfTable=virtualLanAutoConfTable, rspRadiusAltAddr=rspRadiusAltAddr, rsSSDvlTag=rsSSDvlTag, rsWSDSysFlashSize=rsWSDSysFlashSize, rdwrRedundancyInfoIdx=rdwrRedundancyInfoIdx, rsArpInactiveTimeOut=rsArpInactiveTimeOut, rndAlarmEnabling=rndAlarmEnabling, ipRedundRoutersStatus=ipRedundRoutersStatus, rsWSDTelnetUserSshPublicKeyName=rsWSDTelnetUserSshPublicKeyName, rsACCReasonETHBroadcastCounter=rsACCReasonETHBroadcastCounter, reaTunning=reaTunning, rdwrTerminalAliasCommand=rdwrTerminalAliasCommand, rsManagePro=rsManagePro, rsPhysPortMirrorRxBroadCast=rsPhysPortMirrorRxBroadCast, ipRedundancy=ipRedundancy, deviceTemperatureHigh=deviceTemperatureHigh, rsWSDPortOperation=rsWSDPortOperation, reaIpxFftSrcMacAddr=reaIpxFftSrcMacAddr, rspRadiusNasTable=rspRadiusNasTable, rsPhysPortMirrorEntry=rsPhysPortMirrorEntry, rsDnsServerSIp=rsDnsServerSIp, rdwrConfigurationFileStatus=rdwrConfigurationFileStatus, rdwrPortsTagPortNumber=rdwrPortsTagPortNumber, rdwrDeviceThroughput=rdwrDeviceThroughput, ip6NetToMediaTable=ip6NetToMediaTable, rsIpZhrAdminStatus=rsIpZhrAdminStatus, rsIpRipFilterLclAction=rsIpRipFilterLclAction, rdwrVersionIdentifierVal=rdwrVersionIdentifierVal, rsNetPortUtilizationEntryOutUtil=rsNetPortUtilizationEntryOutUtil, rndFACSActEntry=rndFACSActEntry, rsStpDefaultBridgePriority=rsStpDefaultBridgePriority, rsWSDPrivateCommunity=rsWSDPrivateCommunity, ipIfLabel=ipIfLabel, rndIfEntry=rndIfEntry, rsRadiusMainServerAddr=rsRadiusMainServerAddr, rdwrMasterInterfaceGroupingPortsTable=rdwrMasterInterfaceGroupingPortsTable, rndFACSAction=rndFACSAction, rndBootPServerAddress=rndBootPServerAddress, rsIpZhrGeneralStatus=rsIpZhrGeneralStatus, ipRedundRoutersEntry=ipRedundRoutersEntry, rsHWCoreUtilizationTable=rsHWCoreUtilizationTable, rsSSDvlStatus=rsSSDvlStatus, rdwrIkePhase2Protocol=rdwrIkePhase2Protocol, rsMaxDspClntEntries=rsMaxDspClntEntries, rsSSLCertificateDefaultOrganization=rsSSLCertificateDefaultOrganization, rsSSLCertificateImportExportFileName=rsSSLCertificateImportExportFileName, rndCommunityTrapsEnable=rndCommunityTrapsEnable, rsSSLCertificateEntry=rsSSLCertificateEntry, rdwrFtpParameters=rdwrFtpParameters, rdwrVersionIdentifierBase=rdwrVersionIdentifierBase, rdwrSyslogSecuritySending=rdwrSyslogSecuritySending, rsWSDRSResourceUtilizationInstance1=rsWSDRSResourceUtilizationInstance1, ipRedundAdminStatus=ipRedundAdminStatus, vlAutoConfProto=vlAutoConfProto, rsMaxRoutingEntries=rsMaxRoutingEntries, rsScheduleEntry=rsScheduleEntry, rsREACCReasonCounters=rsREACCReasonCounters, rsStpPortVlanId=rsStpPortVlanId, rsFSapplList=rsFSapplList, rsSnmpSetRequestInSpecialCfgState=rsSnmpSetRequestInSpecialCfgState, rsWSDSysUpTime=rsWSDSysUpTime, rsFSapplIndex=rsFSapplIndex, rsWSDPrivateSpecialCheckPeriod=rsWSDPrivateSpecialCheckPeriod, ipSpecRoutePfxLen=ipSpecRoutePfxLen, reaBrgFftPortNum=reaBrgFftPortNum, rsWSDNTFrequentCheckPeriod=rsWSDNTFrequentCheckPeriod, rdwrSnmpErrorTbEntry=rdwrSnmpErrorTbEntry, rsSSDvLPortTag=rsSSDvLPortTag, rsWSDPingPortsEntry=rsWSDPingPortsEntry, rsSSDvirtualLan=rsSSDvirtualLan, rsIcmpRdEntry=rsIcmpRdEntry, rdwrIkeEntry=rdwrIkeEntry, rdwrIkePhase2HashAlg=rdwrIkePhase2HashAlg, rsMaxIpxFrwEntries=rsMaxIpxFrwEntries, rsHWCoreUtilizationIndex=rsHWCoreUtilizationIndex, rsWSDRedundancyMode=rsWSDRedundancyMode, rdwrClientsEntry=rdwrClientsEntry, rsSSDvLPortStatus=rsSSDvLPortStatus, rdwrDayLightSavingDelta=rdwrDayLightSavingDelta, rsLinkAggregationL4Hash=rsLinkAggregationL4Hash, rdwrClientsViewAdminStatus=rdwrClientsViewAdminStatus, rsFSapplStatus=rsFSapplStatus, rdwrClientsViewStatus=rdwrClientsViewStatus, rndMidLevelManagement=rndMidLevelManagement, rdwrIkeEncrypKey=rdwrIkeEncrypKey, rdwrVersionIdentifierTable=rdwrVersionIdentifierTable, rsNetPortUtilizationEntry=rsNetPortUtilizationEntry, rsIpRipFilterGlbStatus=rsIpRipFilterGlbStatus, rsPhysPortMirrorThresholdStatus=rsPhysPortMirrorThresholdStatus, rspRadiusattId=rspRadiusattId, rsWSDPrivateExtraVar1Weight=rsWSDPrivateExtraVar1Weight, eventNum=eventNum, rdwrPowerSupply1Status=rdwrPowerSupply1Status, rsWSDNTPServerAddr=rsWSDNTPServerAddr, rdwrFtpPort=rdwrFtpPort, rsWSDNTCommunity=rsWSDNTCommunity, rdwrTerminalAliasName=rdwrTerminalAliasName, rdwrMirroringActiveThreshold=rdwrMirroringActiveThreshold, rsDnsServerEnable=rsDnsServerEnable, rsSSLCertificateTable=rsSSLCertificateTable, rdwr60SecAvgResourceUtilizationInstance1=rdwr60SecAvgResourceUtilizationInstance1, rsSSDvlDownCriterion=rsSSDvlDownCriterion, rsSendPortUnreachableStatus=rsSendPortUnreachableStatus, rdwrClientsStatus=rdwrClientsStatus, rndMibFileEntry=rndMibFileEntry, rsBWM=rsBWM, rspRadiusPrimaryAuthPort=rspRadiusPrimaryAuthPort, rsWSDHardwareLicense=rsWSDHardwareLicense, rdwrDefCfgUserPassword=rdwrDefCfgUserPassword, vlanDynPortRemoved=vlanDynPortRemoved, cdeResyncronizing=cdeResyncronizing, rdwrDefCfgGateway=rdwrDefCfgGateway, deviceTemperatureNormal=deviceTemperatureNormal, rdwrSnmpErrorTbDescription=rdwrSnmpErrorTbDescription, rdwrApplicationFileName=rdwrApplicationFileName, rsDOS=rsDOS, reaSrcViolationEnable=reaSrcViolationEnable, rsWSDSerStatWarmUpTime=rsWSDSerStatWarmUpTime, ipLeakStaticToRip=ipLeakStaticToRip, virtualLanAutoConfEntry=virtualLanAutoConfEntry, rsErrMailEnable=rsErrMailEnable, rsWSDSyslogUrl=rsWSDSyslogUrl, rsStpInstanceVlanId=rsStpInstanceVlanId, rsSmtpOwnAddr=rsSmtpOwnAddr, rsACCReasonVlanReplyCounter=rsACCReasonVlanReplyCounter, rsIfAutoNegotiateCfg=rsIfAutoNegotiateCfg, rsSSLCertificateOCSPUrl=rsSSLCertificateOCSPUrl, wsdRedundTable=wsdRedundTable, cdeSlaveRebootPending=cdeSlaveRebootPending, rsRip2IfConfAddress=rsRip2IfConfAddress, rsWSDWebPort=rsWSDWebPort, rndFACSDefaultAction=rndFACSDefaultAction, rndFACSSrcAdd=rndFACSSrcAdd, reaIpxForwardEnable=reaIpxForwardEnable, reaBridgeFftTable=reaBridgeFftTable, rndSerialNumber=rndSerialNumber, rdwrIkeIpCompression=rdwrIkeIpCompression, rsWSDIfCost=rsWSDIfCost, rsStpInstanceForwardDelayTime=rsStpInstanceForwardDelayTime, rsWSDMirrorStatus=rsWSDMirrorStatus, rdwrTerminalPrompt=rdwrTerminalPrompt, rdwrClientsRequestedAddr=rdwrClientsRequestedAddr, rndMonitoringTable=rndMonitoringTable, rsIpRipFilterLclStatus=rsIpRipFilterLclStatus, rsWSDTelnetStatus=rsWSDTelnetStatus, rsFloatingPacketOffset=rsFloatingPacketOffset, rsIpZhrVirtAddressEntry=rsIpZhrVirtAddressEntry, rsIfConfIndex=rsIfConfIndex, reaIpForwardDatagrams=reaIpForwardDatagrams, rsArpProxy=rsArpProxy, rsWSDHttpsPort=rsWSDHttpsPort, rsStpInstanceBridgePriority=rsStpInstanceBridgePriority, rsWSDSerStatConnectionLimit=rsWSDSerStatConnectionLimit, rndICMPTransmitionEnable=rndICMPTransmitionEnable, rdwrDevicePortsConfig=rdwrDevicePortsConfig, rndAlarmInterval=rndAlarmInterval, rsWSDIfBoardNum=rsWSDIfBoardNum, rsWSDSCProtocol=rsWSDSCProtocol, rsWSDWebSSLWeakCiphersSupportStatus=rsWSDWebSSLWeakCiphersSupportStatus, rspRadiusNasIp=rspRadiusNasIp, rsIpAdEntIfIndex=rsIpAdEntIfIndex, rsACCReasonDBindNewSYNCounter=rsACCReasonDBindNewSYNCounter, rsGetConfigFileAppend=rsGetConfigFileAppend, rsACCReasonMACCFGCounter=rsACCReasonMACCFGCounter, rdwrTerminalUserName=rdwrTerminalUserName, reaIpxFftFacsSrcIndex=reaIpxFftFacsSrcIndex, rsWSDTelnetUserConfigurationTraceStatus=rsWSDTelnetUserConfigurationTraceStatus, rsWSDStaticPortOperation=rsWSDStaticPortOperation, rsCP=rsCP, rsACCReasonSYNcookieInvalidCounter=rsACCReasonSYNcookieInvalidCounter, rdwrSnmpErrorTbErrorIndex=rdwrSnmpErrorTbErrorIndex, rdwrTerminalAliasEntry=rdwrTerminalAliasEntry, rsDnsrEnable=rsDnsrEnable, rsSSLCertificateStateOrProvince=rsSSLCertificateStateOrProvince, rdwrSyslogServerStatus=rdwrSyslogServerStatus, rsIpZhrVirtAddressTable=rsIpZhrVirtAddressTable, rndManagedTime=rndManagedTime, rsDnsServerStaticResTable=rsDnsServerStaticResTable, rsIfEntry=rsIfEntry, rsSSLCertificateDefaultLocality=rsSSLCertificateDefaultLocality, rnd=rnd, rndErrorDesc=rndErrorDesc, rdwrRedundancyInfoInterface=rdwrRedundancyInfoInterface, rdwrClientsSourcePort=rdwrClientsSourcePort, rndMibFilePath=rndMibFilePath, rndFACSIndex=rndFACSIndex, rsSSLCertificateImportExportEntryName=rsSSLCertificateImportExportEntryName, rndIfLATCompression=rndIfLATCompression, rsWSDStaticFailureMode=rsWSDStaticFailureMode, wsdRedundOperStatus=wsdRedundOperStatus, rdwrTotalIncomingTrafficPeak=rdwrTotalIncomingTrafficPeak, rdwrConfigurationFileAction=rdwrConfigurationFileAction, rsREStateRXRequestCounter=rsREStateRXRequestCounter, rspRadiusRuleEntry=rspRadiusRuleEntry, rsWSDMirrorActiveAddress=rsWSDMirrorActiveAddress, rsWSDPrivateSerialNum=rsWSDPrivateSerialNum, rsDnsParameters=rsDnsParameters, rdwrClientsViewSrcPortTo=rdwrClientsViewSrcPortTo, rndIfCost=rndIfCost, rsSmtpEnable=rsSmtpEnable, rsWSDRedundancySwitch=rsWSDRedundancySwitch, rsWSDWebSSLCaFile=rsWSDWebSSLCaFile, rdwrRip2IfConfTable=rdwrRip2IfConfTable, vlAutoConfPortIfIndex=vlAutoConfPortIfIndex, rndMonitoredElement=rndMonitoredElement, rsWSDWebSSLClientAuthentication=rsWSDWebSSLClientAuthentication, rsWSDRSResourceUtilization=rsWSDRSResourceUtilization)
mibBuilder.exportSymbols("RADWARE-MIB", ip6NetToMediaType=ip6NetToMediaType, rsIpZhrConnectionIpIntf=rsIpZhrConnectionIpIntf, rdwrIkeSaLifeTime=rdwrIkeSaLifeTime, reaIpRemoteAgingTime=reaIpRemoteAgingTime, rsPhysPortMirrorBackupDstPort=rsPhysPortMirrorBackupDstPort, rspRadiusNetworkUpdatePolicy=rspRadiusNetworkUpdatePolicy, rsTacacsServerTimeout=rsTacacsServerTimeout, rsWSDManagementPorts=rsWSDManagementPorts, rspRadiusOwnAuthPort=rspRadiusOwnAuthPort, rsSSLCertificateName=rsSSLCertificateName, rsWSDSerStatFramesRate=rsWSDSerStatFramesRate, vlType=vlType, rsErrMailGateway=rsErrMailGateway, rsTacacsCommandLoggingStatus=rsTacacsCommandLoggingStatus, rndDeviceParams=rndDeviceParams, ipIfAddr=ipIfAddr, rsIfConfStatus=rsIfConfStatus, rspRadiusNasEntry=rspRadiusNasEntry, ipLeakOverrideOSPFLeakonFailure=ipLeakOverrideOSPFLeakonFailure, ipIfTable=ipIfTable, rdwrApplicationFileAction=rdwrApplicationFileAction, rsStpPortEntry=rsStpPortEntry, rsWSDNTRetries=rsWSDNTRetries, rsWSDSendFakeArp=rsWSDSendFakeArp, rndIfNetAddress=rndIfNetAddress, ip6NetToMediaPhysAddress=ip6NetToMediaPhysAddress, rdwrMasterInterfaceGroupingPortState=rdwrMasterInterfaceGroupingPortState, reaIpxFftRangeType=reaIpxFftRangeType, reaBrgForwards=reaBrgForwards, rsWSDNTOpenSessionsWeight=rsWSDNTOpenSessionsWeight, rsWSDIfIndex=rsWSDIfIndex, rdwrDualPowerSupplyParams=rdwrDualPowerSupplyParams, rdwrDefCfgIpMask=rdwrDefCfgIpMask, rdwrManagmentPortsStatus=rdwrManagmentPortsStatus, rdwrSyslogServerFacility=rdwrSyslogServerFacility, rdwrIkePhase1DhKeyGroup=rdwrIkePhase1DhKeyGroup, rdwrMirroringActiveBackupHoldtime=rdwrMirroringActiveBackupHoldtime, rsCT100=rsCT100, rdwrLastConfigurationChangesEntry=rdwrLastConfigurationChangesEntry, rdwrUnauthorizedSourceIP=rdwrUnauthorizedSourceIP, rsACCReasonIPFragmentedCounter=rsACCReasonIPFragmentedCounter, wsdRedundMainWsdAddr=wsdRedundMainWsdAddr, rsWSDPoliciesUpdated=rsWSDPoliciesUpdated, rdwrDayLightSavingAdminStatus=rdwrDayLightSavingAdminStatus, ipIfEntryStatus=ipIfEntryStatus, rsWSDPrivateExtraVar1Mode=rsWSDPrivateExtraVar1Mode, rndInterface=rndInterface, rsWSDInternalTableOverflow=rsWSDInternalTableOverflow, rdwrRedundancyInfoNeighborAddress=rdwrRedundancyInfoNeighborAddress, rsACCReasonSYNcookieOKCounter=rsACCReasonSYNcookieOKCounter, rdwrClientsAttachedTime=rdwrClientsAttachedTime, rndVisionDriver=rndVisionDriver, rsWSDVLANRedundOperStatus=rsWSDVLANRedundOperStatus, rsWSDHttpsStatus=rsWSDHttpsStatus, rsIpZhrConnectionsTable=rsIpZhrConnectionsTable, rndSmartFan=rndSmartFan, rsSendConfigFile=rsSendConfigFile, rdwrLastConfigurationChangesStatus=rdwrLastConfigurationChangesStatus, rsIpZhrConnectionsTableOverflow=rsIpZhrConnectionsTableOverflow, rdwrDualPowerSupplyUp=rdwrDualPowerSupplyUp, rsIpAdEntAddr=rsIpAdEntAddr, rdwrIkePhase1HashAlg=rdwrIkePhase1HashAlg, rdwrDualPowerSupplyProblem=rdwrDualPowerSupplyProblem, rndDeleteValuesEntry=rndDeleteValuesEntry, rdwrLastConfigurationChangesTime=rdwrLastConfigurationChangesTime, rsIpZhrConnectionDestIp=rsIpZhrConnectionDestIp, rsWSDWebSSLCaPath=rsWSDWebSSLCaPath, rdwrLastConfigurationChangesTimestamp=rdwrLastConfigurationChangesTimestamp, rsFSapplEntry=rsFSapplEntry, rsDnsrSrowStatus=rsDnsrSrowStatus, rdwrClientsTypeTable=rdwrClientsTypeTable, rsTftpTotalTimeOut=rsTftpTotalTimeOut, forwardingTabOverflow=forwardingTabOverflow, rndIfStatus=rndIfStatus, rdwrMasterInterfaceGroupingPortNumber=rdwrMasterInterfaceGroupingPortNumber, rsStpPortTable=rsStpPortTable, rsMaxIpxSapEntriesTuning=rsMaxIpxSapEntriesTuning, rsSSDvlAutoConfigEnable=rsSSDvlAutoConfigEnable, rdwrClientsViewSrcPortFrom=rdwrClientsViewSrcPortFrom, rsSSLCertificateKeyPassphrase=rsSSLCertificateKeyPassphrase, rdwrDefCfgUserName=rdwrDefCfgUserName, rsWSDSerStatConnectionLimitReached=rsWSDSerStatConnectionLimitReached, rsIpAdEntVlanTag=rsIpAdEntVlanTag, rdwrClientsTypeEntry=rdwrClientsTypeEntry, rsSSD=rsSSD, rdwrClientsViewDstAddrTo=rdwrClientsViewDstAddrTo, rsRadiusBackupServerUrl=rsRadiusBackupServerUrl, rsWSDDeviceOperationMode=rsWSDDeviceOperationMode, rndFACSDesAdd=rndFACSDesAdd, rndFACSSoketNum=rndFACSSoketNum, virtualLanUserMask=virtualLanUserMask, rsMaxIpxForwardingEntriesTuning=rsMaxIpxForwardingEntriesTuning, rndFACSStatus=rndFACSStatus, rsREStateRXReplyCounter=rsREStateRXReplyCounter, rdwrClientsRequestedPort=rdwrClientsRequestedPort, rdwrVersionIdentifierIdx=rdwrVersionIdentifierIdx, rdwrVrrpAssoIpV6AddrEntry=rdwrVrrpAssoIpV6AddrEntry, rsSSLCertificateCommon=rsSSLCertificateCommon, ip6NetToMediaIfIndex=ip6NetToMediaIfIndex, rsPhysPortMirrorThresholdUnits=rsPhysPortMirrorThresholdUnits, rdwrSnmpStatus=rdwrSnmpStatus, rsScheduleTable=rsScheduleTable, vLPortIfIndex=vLPortIfIndex, rsWSDPrivateCheckTable=rsWSDPrivateCheckTable, rsWSDLicenseID=rsWSDLicenseID, rdwrClientsViewClientType=rdwrClientsViewClientType, ipRedundRoutersPollInterval=ipRedundRoutersPollInterval, rsGeneric=rsGeneric, rdwrSyslogServerRowStatus=rdwrSyslogServerRowStatus, wsdRedundEntry=wsdRedundEntry, rsWSDSyslogFacility=rsWSDSyslogFacility, rsWSDSerStatAdminStatus=rsWSDSerStatAdminStatus, rsSendConfigFileBer=rsSendConfigFileBer, rsIpZhrNotAllocVirtualIp=rsIpZhrNotAllocVirtualIp, rsSSDvlPriority=rsSSDvlPriority, reaIpFftEntryNum=reaIpFftEntryNum, cdeNoMaster=cdeNoMaster, rsWSDIfFilterMode=rsWSDIfFilterMode, rsIcmpRdIpAddr=rsIcmpRdIpAddr, reaIpxForwardDatagrams=reaIpxForwardDatagrams, rsErrMailToFieldText=rsErrMailToFieldText, rdwrRedundancyInfoStatus=rdwrRedundancyInfoStatus, rdwrMirroringActiveBackupThreshold=rdwrMirroringActiveBackupThreshold, rsSystemFansStatus=rsSystemFansStatus, resetRequired=resetRequired, rsMaxDspClntEntriesTuning=rsMaxDspClntEntriesTuning, cdeIncompatible=cdeIncompatible, rsRadiusMainServerSecret=rsRadiusMainServerSecret, rdwrSyslogServerEntry=rdwrSyslogServerEntry, rsWSDStaticSourcePort=rsWSDStaticSourcePort, rsMaxBrgFrwEntries=rsMaxBrgFrwEntries, rspRadiusRuleTable=rspRadiusRuleTable, RsIfType=RsIfType, rdwrApplicationFileSelected=rdwrApplicationFileSelected, rdwrPortsTagEntry=rdwrPortsTagEntry, rsStpPortEnabled=rsStpPortEnabled, rsIpRipFilterLclIpAddr=rsIpRipFilterLclIpAddr, rsWSDSerStatPeakLoad=rsWSDSerStatPeakLoad, rndMonitoredElementsTable=rndMonitoredElementsTable, rdwr5SecAvgResourceUtilizationInstance1=rdwr5SecAvgResourceUtilizationInstance1, rsWSDStatusMonitoring=rsWSDStatusMonitoring, rsDiagnostic=rsDiagnostic, rsWSDSyslogDestinationPort=rsWSDSyslogDestinationPort, rndMonitoredObjectInstance=rndMonitoredObjectInstance, rdwrApplicationFileVersion=rdwrApplicationFileVersion, rsVWSDDataPermissionsTable=rsVWSDDataPermissionsTable, rsIpAdEntType=rsIpAdEntType, rsMaxDspFrmEntriesAfterReset=rsMaxDspFrmEntriesAfterReset, rsWSDNatStatus=rsWSDNatStatus, rndBootPRelaySecThreshold=rndBootPRelaySecThreshold, rsDnsrPrimaryAddr=rsDnsrPrimaryAddr, rsIpAdEntReasmMaxSize=rsIpAdEntReasmMaxSize, rdwrIkeStatus=rdwrIkeStatus, rsHWCPUTemperatureEntry=rsHWCPUTemperatureEntry, rsDnsServerStaticResEntry=rsDnsServerStaticResEntry, rndDefaultLogFile=rndDefaultLogFile, rdwrLastConfigurationChangesKeys=rdwrLastConfigurationChangesKeys, rdwrVersionIdentifierEntry=rdwrVersionIdentifierEntry, rsIpAddrEntry=rsIpAddrEntry, rsWSDApplicationMirrorTable=rsWSDApplicationMirrorTable, rsMaxDspFrmEntries=rsMaxDspFrmEntries, rdwrIkeDPDCheckInterval=rdwrIkeDPDCheckInterval, rdwrDayLightSavingTimeDesignations=rdwrDayLightSavingTimeDesignations, rsSSLCertificateCountryName=rsSSLCertificateCountryName, rsWSDSysManagedTime=rsWSDSysManagedTime, rsFullMacCompareStatus=rsFullMacCompareStatus, rsIpZhrReqStaticConnNotAccepted=rsIpZhrReqStaticConnNotAccepted, FeatureStatus=FeatureStatus, rndNumberOfHD=rndNumberOfHD, vlAutoConfigEnable=vlAutoConfigEnable, rsDnsrSIp=rsDnsrSIp, rdwrTerminalParams=rdwrTerminalParams, rsIDS=rsIDS, rsWSDReadyForShutDown=rsWSDReadyForShutDown, rsMLB=rsMLB, rsWSDIfTable=rsWSDIfTable, rspRadiusAltAuthPort=rspRadiusAltAuthPort, rsDnsServerSUrl=rsDnsServerSUrl, rsStpDefaultPortPriority=rsStpDefaultPortPriority, rsSDclientsTableOverflow=rsSDclientsTableOverflow, reaIpFftFacsDstIndex=reaIpFftFacsDstIndex, rsVWSDDataItems=rsVWSDDataItems, rsRadiusServer=rsRadiusServer, rspRadiusUserMirrorProtocolMode=rspRadiusUserMirrorProtocolMode, rsIpRipFilterGlbAction=rsIpRipFilterGlbAction, ipIfBackupAddr=ipIfBackupAddr, rdwrIkeName=rdwrIkeName, rsWSDTelnetUserGroup=rsWSDTelnetUserGroup, rsSSLCertificateExpiry=rsSSLCertificateExpiry, rsConfigurationAuditingType=rsConfigurationAuditingType, rsIpRipFilterGlbNumber=rsIpRipFilterGlbNumber, rdwrSnmpErrorTbTable=rdwrSnmpErrorTbTable, rdwrSnmpErrorTbDate=rdwrSnmpErrorTbDate, lreVnRespVn=lreVnRespVn, rndBrgVersion=rndBrgVersion, rsIpAdEntPeerAddr=rsIpAdEntPeerAddr, rsWSDPrivateCheckEntry=rsWSDPrivateCheckEntry, rdwrIkeOutSpi=rdwrIkeOutSpi, rdwrRip2IfConfAddress=rdwrRip2IfConfAddress, wsdRedundPollInterval=wsdRedundPollInterval, rdwrClientsViewActionFeedback=rdwrClientsViewActionFeedback, rsHighPriority=rsHighPriority, ipRedundRoutersTable=ipRedundRoutersTable)
