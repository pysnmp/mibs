#
# PySNMP MIB module CTRON-ETHERNET-PARAMETERS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-ETHERNET-PARAMETERS-MIB
# Produced by pysmi-1.1.8 at Tue Aug  9 15:42:15 2022
# On host fv-az135-436 platform Linux version 5.15.0-1014-azure by user runner
# Using Python version 3.10.6 (main, Aug  2 2022, 15:19:40) [GCC 9.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
ctIfPortPortNumber, ctIfPortIfNumber = mibBuilder.importSymbols("CTIF-EXT-MIB", "ctIfPortPortNumber", "ctIfPortIfNumber")
ctEthernetCtlParameters, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctEthernetCtlParameters")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, MibIdentifier, TimeTicks, Bits, Integer32, ModuleIdentity, Gauge32, Counter64, ObjectIdentity, Unsigned32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibIdentifier", "TimeTicks", "Bits", "Integer32", "ModuleIdentity", "Gauge32", "Counter64", "ObjectIdentity", "Unsigned32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ctAutoNegCtl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1))
ctAutoNegCtlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1), )
if mibBuilder.loadTexts: ctAutoNegCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegCtlTable.setDescription('Provides a list of definitions and control objects over any 10BASE-T,\n        100BASE-TX, or 1000BASE-X Cabletron interface that supports \n        auto-negotiation as described by the aforementioned standards.')
ctAutoNegCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1), ).setIndexNames((0, "CTIF-EXT-MIB", "ctIfPortIfNumber"), (0, "CTIF-EXT-MIB", "ctIfPortPortNumber"))
if mibBuilder.loadTexts: ctAutoNegCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegCtlEntry.setDescription('Defines a particular entry containing objects pertaining to\n       definition and control over interfaces supporting Auto-Negotiation.')
ctAutoNegAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctAutoNegAdminStatus.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.2')
if mibBuilder.loadTexts: ctAutoNegAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegAdminStatus.setDescription('This object controls whether Auto-Negotiation is enabled \n       for the specified port.  If Auto-Negotiation is disabled the port will\n       revert to the speed, duplex and flow control settings specified by\n       their associated leaves in the ctEtherManualConfig and\n       ctFlowControl groups.')
ctAutoNegRemoteSignalling = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("detected", 1), ("notdetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctAutoNegRemoteSignalling.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.3')
if mibBuilder.loadTexts: ctAutoNegRemoteSignalling.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegRemoteSignalling.setDescription('This object indicates whether the remote end of the link is operating\n       Auto-Negotiation signalling or not.')
ctAutoNegAutoConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("configuring", 2), ("complete", 3), ("disabled", 4), ("paralleldetectfailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctAutoNegAutoConfig.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.4')
if mibBuilder.loadTexts: ctAutoNegAutoConfig.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegAutoConfig.setDescription('This object indicates whether Auto-Negotiation signalling is in\n       progress or has completed.')
ctAutoNegLocalTechnologyAbility = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctAutoNegLocalTechnologyAbility.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.5')
if mibBuilder.loadTexts: ctAutoNegLocalTechnologyAbility.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegLocalTechnologyAbility.setDescription('This indicates the technology ability of the local hardware.\n    \n       The value is a sum.  This sum initially takes the value zero. Then, for\n       each technology, T, that the port supports, 2 raised to (T - 1) is added \n       to the sum.  For example, a port that supports 1000BASE-TFD (T = 18) and \n       1000BASE-T (T = 17) would return a value of 196608\n       ((2 ^ (18 - 1)) + (2 ^ (17 - 1))).\n\n       For ports supporting Auto-Negotiation, values should be calculated\n       as follows:\n\n          T   Technology           Description\n         --   -----------     ------------------------------------------------\n          1   global          Reserved for future use.\n          2   other           None of the following.\n          3   unknown         Initializing, true state or type not yet known\n          4   10BASE-T        10BASE-T Half Duplex\n          5   10BASE-TFD      10BASE-T Full Duplex\n          6   100BASE-T4      100BASE-T4 Half Duplex\n          7   100BASE-TX      100BASE-TX Half Duplex\n          8   100BASE-TXFD    100BASE-TX Full Duplex\n          9   FDX PAUSE       Full Duplex Flow Control\n         10   FDX APAUSE      Full Duplex Asymmetric Flow Control\n         11   FDX SPAUSE      Full Duplex Symmetric Flow Control\n         12   FDX BPAUSE      Full Duplex Asymmetric and Symmetric Flow Control\n         13   100BASE-T2      100BASE-T2 Half Duplex\n         14   100BASE-T2FD    100BASE-T2 Full Duplex\n         15   1000BASE-X      1000BASE-X Half Duplex\n         16   1000BASE-XFD    1000BASE-X Full Duplex\n         17   1000BASE-T      1000BASE-T Half Duplex\n         18   1000BASE-TFD    1000BASE-T Full Duplex\n         19   Rem Fault1      Remote Fault Bit 1\n         20   Rem Fault2      Remote Fault Bit 2 \n         21   ISO Ethernet    IEEE Std 802.9 ISLAN-16T\n      ')
ctAutoNegAdvertisedTechnologyAbility = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctAutoNegAdvertisedTechnologyAbility.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.6')
if mibBuilder.loadTexts: ctAutoNegAdvertisedTechnologyAbility.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegAdvertisedTechnologyAbility.setDescription('Indicates the advertised ability of the local hardware, but only\n       becomes active on ports that have auto-negotiation enabled.  \n\n       The value is a sum.  This sum initially takes the value zero. Then, for\n       each technology, T, that the port is advertising, 2 raised to (T - 1)\n       is added to the sum.  For example, a port that advertises 1000BASE-TFD\n       (T = 18) and 1000BASE-T (T = 17) would return a value of 196608 \n       ((2 ^ (18 - 1)) + (2 ^ (17 - 1))). \n       \n       Values for T are limited to technologies supported by the hardware as\n       specified by ctAutoNegLocalTechnologyAbility.  For ports supporting \n       Auto-Negotiation, values should be calculated as follows:\n\n          T   Technology           Description\n         --   -----------     ------------------------------------------------\n          1   global          Reserved for future use.\n          2   other           None of the following.\n          3   unknown         Initializing, true state or type not yet known\n          4   10BASE-T        10BASE-T Half Duplex\n          5   10BASE-TFD      10BASE-T Full Duplex\n          6   100BASE-T4      100BASE-T4 Half Duplex\n          7   100BASE-TX      100BASE-TX Half Duplex\n          8   100BASE-TXFD    100BASE-TX Full Duplex\n          9   FDX PAUSE       Full Duplex Flow Control\n         10   FDX APAUSE      Full Duplex Asymmetric Flow Control\n         11   FDX SPAUSE      Full Duplex Symmetric Flow Control\n         12   FDX BPAUSE      Full Duplex Asymmetric and Symmetric Flow Control\n         13   100BASE-T2      100BASE-T2 Half Duplex\n         14   100BASE-T2FD    100BASE-T2 Full Duplex\n         15   1000BASE-X      1000BASE-X Half Duplex\n         16   1000BASE-XFD    1000BASE-X Full Duplex\n         17   1000BASE-T      1000BASE-T Half Duplex\n         18   1000BASE-TFD    1000BASE-T Full Duplex\n         19   Rem Fault1      Remote Fault Bit 1\n         20   Rem Fault2      Remote Fault Bit 2 \n         21   ISO Ethernet    IEEE Std 802.9 ISLAN-16T\n\n       A successful set operation will result in immediate link re-negotiation\n       if Auto-Negotiation is enabled on this port, as specified by\n       ctAutoNegAdminStatus.  A set of this object to a value containing bits \n       that are not supported by the hardware will be successful, but, the port\n       will only advertise values which are the logical AND of the set value and\n       ctAutoNegLocalTechnologyAbility.\n\n       Note: this re-negotiation will in every case cause temporary link loss\n       during the link re-negotiation.  If set to a value that is incompatible\n       with ctAutoNegLocalTechnologyAbility, link negotiation will not\n       be successful and will cause permanent link loss.')
ctAutoNegReceivedTechnologyAbility = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctAutoNegReceivedTechnologyAbility.setReference('IEEE Std 802.3, 1998 Edition 30.6.1.1.7')
if mibBuilder.loadTexts: ctAutoNegReceivedTechnologyAbility.setStatus('mandatory')
if mibBuilder.loadTexts: ctAutoNegReceivedTechnologyAbility.setDescription('Indicates the advertised ability of the remote hardware, or link\n       partner.  \n\n       The value is a sum.  This sum initially takes the value zero. Then, for\n       each technology, T, that the link partner supports, 2 raised to (T - 1)\n       is added to the sum.  For example, a link partner advertising \n       1000BASE-TFD (T = 18) and 1000BASE-T (T = 17) would return a value \n       of 196608 ((2 ^ (18 - 1)) + (2 ^ (17 - 1))).\n\n       For ports supporting Auto-Negotiation, values should be calculated\n       as follows:\n\n          T   Technology           Description\n         --   -----------     ------------------------------------------------\n          1   global          Reserved for future use.\n          2   other           None of the following.\n          3   unknown         Initializing, true state or type not yet known\n          4   10BASE-T        10BASE-T Half Duplex\n          5   10BASE-TFD      10BASE-T Full Duplex\n          6   100BASE-T4      100BASE-T4 Half Duplex\n          7   100BASE-TX      100BASE-TX Half Duplex\n          8   100BASE-TXFD    100BASE-TX Full Duplex\n          9   FDX PAUSE       Full Duplex Flow Control\n         10   FDX APAUSE      Full Duplex Asymmetric Flow Control\n         11   FDX SPAUSE      Full Duplex Symmetric Flow Control\n         12   FDX BPAUSE      Full Duplex Asymmetric and Symmetric Flow Control\n         13   100BASE-T2      100BASE-T2 Half Duplex\n         14   100BASE-T2FD    100BASE-T2 Full Duplex\n         15   1000BASE-X      1000BASE-X Half Duplex\n         16   1000BASE-XFD    1000BASE-X Full Duplex\n         17   1000BASE-T      1000BASE-T Half Duplex\n         18   1000BASE-TFD    1000BASE-T Full Duplex\n         19   Rem Fault1      Remote Fault Bit 1\n         20   Rem Fault2      Remote Fault Bit 2 \n         21   ISO Ethernet    IEEE Std 802.9 ISLAN-16T\n      ')
ctFlowControl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2))
ctFlowCtlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1), )
if mibBuilder.loadTexts: ctFlowCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlTable.setDescription('Provides a list of statistic and control objects over 10BASE-X, \n        100BASE-X and 1000BASE-X Cabletron interfaces that support flow \n        control as described by IEEE Std 802.3, 1998 Edition.')
ctFlowCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1), ).setIndexNames((0, "CTIF-EXT-MIB", "ctIfPortIfNumber"), (0, "CTIF-EXT-MIB", "ctIfPortPortNumber"))
if mibBuilder.loadTexts: ctFlowCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlEntry.setDescription('Defines a particular entry containing objects pertaining to\n       definition and control over Cabletron flow control capable interfaces.')
ctFlowCtlHalfDuplexAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctFlowCtlHalfDuplexAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlHalfDuplexAdminStatus.setDescription('The administrative status requested by management for back pressure\n       on this port.  Back pressure is a collision based flow control mechanism \n       used in half duplex configurations.  The value of enabled(1) indicates \n       that back pressure should be enabled on this port if the port is in half\n       duplex.  The value of disable(2) indicates that back pressure should be \n       disabled on this port.')
ctFlowCtlHalfDuplexOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("notsupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctFlowCtlHalfDuplexOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlHalfDuplexOperStatus.setDescription('The current operational status of back pressure on this port.')
ctEtherSupportedPauseModes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctEtherSupportedPauseModes.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherSupportedPauseModes.setDescription('This indicates the frame based modes of full duplex flow control for this\n       port.\n    \n       The value is a sum.  This sum initially takes the value zero. Then, for\n       each mode, M, that the port supports, 2 raised to (M - 1) is added to \n       the sum.  For example, a port that supports Symmetric (M= 2),\n       AsymmetricRX (M = 3) and AsymmetricTx (M = 4) would return a value \n       of 14 ((2 ^ (2 - 1)) + (2 ^ (3 - 1)) + (2 ^ (4 - 1))).\n\n       Speed values should be calculated as follows:\n\n          M   Mode            Description\n         --   ------------    ------------------------------------------------\n          1   Other           None of the following\n          2   Symmetric       Receive and Transmit Pause Frames        \n          3   AsymmetricRx    Receive Pause Frames\n          4   AsymmetricTx    Transmit Pause Frames\n      ')
ctFlowCtlPauseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("symmetric", 1), ("asymmetricRx", 2), ("asymmetricTx", 3), ("disabled", 4), ("autonegotiate", 5))).clone('autonegotiate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctFlowCtlPauseAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlPauseAdminStatus.setDescription('The administrative status requested by management for frame based\n       flow control on this port.  For 10 Mb and 100 Mb ports the value of \n       symmetric(1) indicates that if Auto-Negotiation is supported for this \n       port, that the FDX PAUSE bit in the ctAutoNegLocalTechnologyAbility will\n       be set, further indicating that the port supports full duplex flow \n       control.  For 1000 Mb the value of symmetric(1) indicates that if \n       Auto-Negotiation is supported for this port, that the FDX SPAUSE\n       bit in the ctAutoNegLocalTechnologyAbility will be set, further \n       indicating that the port supports symmetric frame based flow control.\n       In all cases a set of symmetric(1) will cause the port to interpret \n       received PAUSE frames and allow the port to transmit PAUSE frames when \n       necessary.  A set of a value of symmetric(1) is limited to those ports \n       that support symmetric frame based flow control as specified by\n       ctEtherSupportedPauseModes.\n       \n       The value of asymmetricRx(2) indicates that if Auto-Negotiation is \n       supported for this port, that the FDX BPAUSE bit in the \n       ctAutoNegLocalTechnologyAbility will be set, further\n       indicating that the port supports asymmetric receive frame based flow \n       control.  In all cases a set of asymmetricRx(2) will cause the port to \n       interpret received PAUSE frames and disallow the port to transmit PAUSE \n       frames.  A set of a value of asymmetricRx(2) is limited to those ports \n       that support asymmetricRx frame based flow control as specified by \n       ctEtherSupportedPauseModes. \n\n       The value of asymmetricTx(3) indicates that if Auto-Negotiation is\n       supported for this port, that the FDX APAUSE bit in the\n       ctAutoNegLocalTechnologyAbility will be set, further indicating that the\n       port supports asymmetric transmit frame based flow control.  In all cases\n       a set of asymmetricTx(3) will cause the port to ignore PAUSE frames and \n       allow the port to transmit PAUSE frames when necessary.  A set of a value\n       of asymmetricTx(3) is limited to those ports that support asymmetricTx \n       frame based flow control as specified by ctEtherSupportedPauseModes.\n\n       The value of disabled(4) indicates that if Auto-Negotiation is supported \n       for this port, that the FDX PAUSE, FDX APAUSE, FDX SPAUSE and FDX BPAUSE\n       bits in the ctAutoNegLocalTechnologyAbility will be cleared, further \n       indicating that the port does not support frame based flow control.  In \n       all cases a set of disable(2) will cause the port to ignore received \n       PAUSE frames and to disallow the port to transmit PAUSE frames.  \n       \n       The value of autonegotiate(5) indicates that if Auto-Negotiation is \n       supported for this port, and the hardware supports the ability to\n       advertise PAUSE capability, that the maximum flow control capabilities \n       of the hardware are to be reflected in the PAUSE bits of \n       ctAutoNegLocalTechnologyAbility.  The ports flow control operational\n       state will be determined by the results of Auto-Negotiation.  If \n       Auto-Negotiation is not supported for this port, a set of \n       autonegotiate(5) will fail.\n       \n       In all cases frame based flow control is only used for ports that\n       are in full duplex.')
ctFlowCtlPauseOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("symmetric", 1), ("asymmetricRx", 2), ("asymmetricTx", 3), ("disabled", 4), ("unknown", 5), ("notsupported", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctFlowCtlPauseOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlPauseOperStatus.setDescription('The current operational status of full duplex flow control \n       on this port.  A value of unknown(5) will be returned for any port which \n       has a Pause Frame Admin Status of autonegotiate(5), as specified by\n       ctFlowCtlPauseAdminStatus, but is in an unknown Auto-Negotiation state.')
ctFlowCtlPauseTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctFlowCtlPauseTimer.setReference('IEEE Std 802.3, 1998 Edition Annex 31B.2')
if mibBuilder.loadTexts: ctFlowCtlPauseTimer.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlPauseTimer.setDescription('A 2 octet, unsigned integer containing the length of time for which\n       the receiving station is requested to inhibit data frame transmission.\n       The pause time is measured in units of pause_quanta, equal to 512 bit\n       times of the particular implementation.')
ctFlowCtlRxPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctFlowCtlRxPauseFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlRxPauseFrames.setDescription('The number of pause frames received on this port.')
ctFlowCtlTxPauseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctFlowCtlTxPauseFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ctFlowCtlTxPauseFrames.setDescription('The number of pause frames transmitted from this port.')
ctEtherManualConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3))
ctEtherManualConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1), )
if mibBuilder.loadTexts: ctEtherManualConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherManualConfigTable.setDescription('Provides a list of speed and duplex control objects over 10BASE-X, \n        100BASE-X and 1000 BASE-X Cabletron Ethernet interfaces.')
ctEtherManualConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1), ).setIndexNames((0, "CTIF-EXT-MIB", "ctIfPortIfNumber"), (0, "CTIF-EXT-MIB", "ctIfPortPortNumber"))
if mibBuilder.loadTexts: ctEtherManualConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherManualConfigEntry.setDescription('Defines a particular entry containing objects pertaining to\n       definition and control over Cabletron Ethernet interfaces.')
ctEtherSupportedSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctEtherSupportedSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherSupportedSpeed.setDescription('This indicates the supported speeds for the port.\n    \n       The value is a sum.  This sum initially takes the value zero. Then, for\n       each speed, S, that the port supports, 2 raised to (S - 1) is added to \n       the sum.  For example, a port that supports 10 Mb (S = 1) and 100 Mb\n       (S = 2) would return a value of 3 ((2 ^ (1 - 1)) + (2 ^ (2 - 1))).\n\n       Speed values should be calculated as follows:\n\n          S   Speed           Description\n         --   -----------     ------------------------------------------------\n          1   10 Mb           Ethernet\n          2   100 Mb          Fast Ethernet\n          3   1000 Mb         Gigabit Ethernet\n      ')
ctEtherSpeedAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("tenmegabit", 2), ("hundredmegabit", 3), ("gigabit", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctEtherSpeedAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherSpeedAdminStatus.setDescription('The administrative status requested by management for the speed of this \n       port.  The value of tenmegabit(2) indicates that if Auto-Negotiation \n       is disabled for this port, that the port will operate at a speed of\n       10 megabits per second, provided that the port supports that speed,\n       as specified by ctEtherSupportedSpeed.  \n       \n       The value of hundredmegabit(3) indicates that if Auto-Negotiation \n       is disabled for this port, that the port will operate at a speed of\n       100 megabits per second, provided that the port supports that speed,\n       as specified by ctEtherSupportedSpeed.\n  \n       The value of gigabit(4) indicates that if Auto-Negotiation \n       is disabled for this port, that the port will operate at a speed of\n       1000 megabits per second, provided that the port supports that speed,\n       as specified by ctEtherSupportedSpeed.\n       \n       In all cases, if the value specified does not indicate a speed that \n       the port supports the set will fail.')
ctEtherSpeedOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tenmegabit", 2), ("hundredmegabit", 3), ("gigabit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctEtherSpeedOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherSpeedOperStatus.setDescription('This object indicates the current speed of the Ethernet port.')
ctEtherSupportedDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("halfduplex", 1), ("fullduplex", 2), ("halfandfullduplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctEtherSupportedDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherSupportedDuplex.setDescription('This object indicates the duplex modes supported by this port.\n       A value of halfduplex(1) indicates that the port only supports\n       half duplex operation.  A value of fullduplex(2) indicates that\n       the port only supports full duplex operation.  A value of\n       halfandfullduplex(3) indicates that the port supports both\n       half and full duplex operation.')
ctEtherDuplexAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("halfduplex", 2), ("fullduplex", 3))).clone('halfduplex')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctEtherDuplexAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherDuplexAdminStatus.setDescription('The administrative status requested by management for the duplex of this \n       port.  The value of halfduplex(2) indicates that if Auto-Negotiation \n       is disabled for this port, that the port will operate in half duplex,\n       provided that the port supports half duplex, as specified by \n       ctEtherSupportedDuplex.\n       \n       The value of fullduplex(3) indicates that if Auto-Negotiation \n       is disabled for this port, that the port will operate in full duplex,\n       provided that the port supports full duplex, as specified by \n       ctEtherSupportedDuplex.\n       \n       In all cases, if the value specified does not indicate a duplex that \n       the port supports the set will fail.')
ctEtherDuplexOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 4, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("halfduplex", 2), ("fullduplex", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctEtherDuplexOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctEtherDuplexOperStatus.setDescription('This object indicates the current duplex of the Ethernet port.')
mibBuilder.exportSymbols("CTRON-ETHERNET-PARAMETERS-MIB", ctFlowCtlTxPauseFrames=ctFlowCtlTxPauseFrames, ctEtherSpeedOperStatus=ctEtherSpeedOperStatus, ctFlowCtlPauseAdminStatus=ctFlowCtlPauseAdminStatus, ctFlowCtlPauseOperStatus=ctFlowCtlPauseOperStatus, ctEtherManualConfig=ctEtherManualConfig, ctAutoNegAutoConfig=ctAutoNegAutoConfig, ctAutoNegRemoteSignalling=ctAutoNegRemoteSignalling, ctAutoNegLocalTechnologyAbility=ctAutoNegLocalTechnologyAbility, ctFlowCtlEntry=ctFlowCtlEntry, ctEtherSupportedPauseModes=ctEtherSupportedPauseModes, ctFlowCtlRxPauseFrames=ctFlowCtlRxPauseFrames, ctFlowCtlTable=ctFlowCtlTable, ctEtherManualConfigEntry=ctEtherManualConfigEntry, ctAutoNegReceivedTechnologyAbility=ctAutoNegReceivedTechnologyAbility, ctEtherSupportedSpeed=ctEtherSupportedSpeed, ctEtherDuplexOperStatus=ctEtherDuplexOperStatus, ctAutoNegCtlTable=ctAutoNegCtlTable, ctAutoNegAdminStatus=ctAutoNegAdminStatus, ctFlowControl=ctFlowControl, ctEtherSpeedAdminStatus=ctEtherSpeedAdminStatus, ctAutoNegCtl=ctAutoNegCtl, ctFlowCtlHalfDuplexOperStatus=ctFlowCtlHalfDuplexOperStatus, ctAutoNegAdvertisedTechnologyAbility=ctAutoNegAdvertisedTechnologyAbility, ctEtherSupportedDuplex=ctEtherSupportedDuplex, ctEtherDuplexAdminStatus=ctEtherDuplexAdminStatus, ctFlowCtlHalfDuplexAdminStatus=ctFlowCtlHalfDuplexAdminStatus, ctEtherManualConfigTable=ctEtherManualConfigTable, ctAutoNegCtlEntry=ctAutoNegCtlEntry, ctFlowCtlPauseTimer=ctFlowCtlPauseTimer)
