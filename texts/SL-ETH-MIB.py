#
# PySNMP MIB module SL-ETH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/packetlight/SL-ETH-MIB
# Produced by pysmi-1.1.8 at Mon Feb  6 15:05:16 2023
# On host fv-az357-935 platform Linux version 5.15.0-1031-azure by user runner
# Using Python version 3.10.9 (main, Dec  7 2022, 08:16:13) [GCC 11.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
PerfTotalCount, PerfIntervalCount, PerfCurrentCount = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfTotalCount", "PerfIntervalCount", "PerfCurrentCount")
slService, = mibBuilder.importSymbols("SL-NE-MIB", "slService")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter32, Gauge32, IpAddress, MibIdentifier, Counter64, TimeTicks, ObjectIdentity, Integer32, Bits, iso, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter32", "Gauge32", "IpAddress", "MibIdentifier", "Counter64", "TimeTicks", "ObjectIdentity", "Integer32", "Bits", "iso", "Unsigned32", "NotificationType")
DisplayString, TruthValue, TextualConvention, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention", "DateAndTime")
slEthernet = ModuleIdentity((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1))
if mibBuilder.loadTexts: slEthernet.setLastUpdated('200508171200Z')
if mibBuilder.loadTexts: slEthernet.setOrganization('PacketLight Networks Ltd.')
if mibBuilder.loadTexts: slEthernet.setContactInfo('Omri_Viner@PacketLight.com')
if mibBuilder.loadTexts: slEthernet.setDescription('This MIB module describes the Ethernet Service')
ethTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 7))
ethConfigTable = MibTable((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1), )
if mibBuilder.loadTexts: ethConfigTable.setStatus('current')
if mibBuilder.loadTexts: ethConfigTable.setDescription('The Ethernet Configuration table.')
ethConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1), ).setIndexNames((0, "SL-ETH-MIB", "ethLineIndex"))
if mibBuilder.loadTexts: ethConfigEntry.setStatus('current')
if mibBuilder.loadTexts: ethConfigEntry.setDescription('An entry in the Ethernet Configuration table.')
ethLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethLineIndex.setStatus('current')
if mibBuilder.loadTexts: ethLineIndex.setDescription('This object should be made equal to ifIndex.')
ethTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: ethTimeElapsed.setDescription("The number of seconds that have elapsed since\n\t\tthe beginning of the near end current error-\n\t\tmeasurement period.  If, for some reason, such\n\t\tas an adjustment in the system's time-of-day\n\t\tclock, the current interval exceeds the maximum\n\t\tvalue, the agent will return the maximum value.")
ethValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethValidIntervals.setStatus('current')
if mibBuilder.loadTexts: ethValidIntervals.setDescription('The number of previous near end intervals for\n\t\twhich data was collected.  The value will be\n\t\t96 unless the interface was brought online within\n\t\tthe last 24 hours, in which case the value will be\n\t\tthe number of complete 15 minute near end\n\t\tintervals since the interface has been online.  In\n\t\tthe case where the agent is a proxy, it is\n\t\tpossible that some intervals are unavailable.  In\n\t\tthis case, this interval is the maximum interval\n\t\tnumber for which data is available.')
ethResetPm = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethResetPm.setStatus('current')
if mibBuilder.loadTexts: ethResetPm.setDescription('Writing to this object cause a Reset to the current\n\t\tPM counters of the corresponding Ethernet interface.')
ethAutoNegSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethAutoNegSupported.setStatus('current')
if mibBuilder.loadTexts: ethAutoNegSupported.setDescription('This object indicates the AutoNeg oper status.\n    \t TRUE - meanse that ethAutoNegAdminStatus is enabled(1)\n    \t        and the Remote interface supports AutoNeg.\n    \t FALSE - Otherwise.')
ethAutoNegAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethAutoNegAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ethAutoNegAdminStatus.setDescription('Setting this object to enabled(1) will cause\n\t\tthe interface auto-negotiation function capability \n\t\tto be enabled.')
ethConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethConfigStatus.setStatus('current')
if mibBuilder.loadTexts: ethConfigStatus.setDescription('This variable indicates the Line Status of the\n\t\tEthrenet interface.  \n\n\t\tThe ethConfigStatus is a bit map represented as a\n\t\tsum, therefore, it can represent multiple failures (alarms) \n\t\tsimultaneously.\n\n\t\tethConfigNoAlarm must be set if and only if no other\n\t\tflag is set.\n\n\t       The various bit positions are:\n\t      1     ethConfigNoAlarm           No alarm present\n\t      2     ethConfigTransmitFault     Optical GbE transceiver transmit fault \n\t      4     ethConfigLossOfSignal      Optical GbE transceiver signal detect failed\n\t      8     ethConfigLinkFail          Mac Layer Link failed')
ethTransceiverType = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("base1000SX", 2), ("base1000LX", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTransceiverType.setStatus('current')
if mibBuilder.loadTexts: ethTransceiverType.setDescription('The GBIC Type.')
ethPauseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 16383))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPauseTime.setStatus('current')
if mibBuilder.loadTexts: ethPauseTime.setDescription('This object indicate how much time the other mac\n    \tdevice should pause after it receive a pause frame.\n    \tThe unit are of 512 ns.')
ethPauseEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethPauseEnable.setStatus('current')
if mibBuilder.loadTexts: ethPauseEnable.setDescription('This object indicates whether or not\n        we want to use the flow control mechanism.')
ethResetPmCounters = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethResetPmCounters.setStatus('current')
if mibBuilder.loadTexts: ethResetPmCounters.setDescription('Setting this object to 1 reset the current interval PM\n    \tcounters of the port.')
ethTransceiverMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("copper", 2), ("fiber", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethTransceiverMedia.setStatus('current')
if mibBuilder.loadTexts: ethTransceiverMedia.setDescription('The thernet port tranceiver media.\n\t\tUsed to determine which uplink interface to use.')
ethCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2), )
if mibBuilder.loadTexts: ethCurrentTable.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTable.setDescription('The Ethernet current table contains various statistics\n\t\tbeing collected for the current 15 minute\n\t\tinterval.')
ethCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1), ).setIndexNames((0, "SL-ETH-MIB", "ethCurrentIndex"))
if mibBuilder.loadTexts: ethCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: ethCurrentEntry.setDescription('An entry in the Ethernet Current table.')
ethCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentIndex.setStatus('current')
if mibBuilder.loadTexts: ethCurrentIndex.setDescription('The index value which uniquely identifies  the\n\t\tEthernet interface to which this entry is applicable.\n\t\tThe interface identified by a particular value of\n\t\tthis index is the same interface as identified by\n\t\tthe same value as a ethLineIndex object\n\t\tinstance.')
ethCurrentRxDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxDropEvents.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxDropEvents.setDescription('The total number of events in which packets were \n\t\tdropped by the probe due to lack of Ingress resources during \n\t\tthis sampling interval. Note that this number is not\n\t\tnecessarily the number of packets dropped, it is just \n\t\tthe number of times this condition has been detected.')
ethCurrentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentOctets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentOctets.setDescription('The total number of octets of data (including those \n\t\tin bad packets) received on the network (excluding \n\t\tframing bits but including FCS octets).\n\t\tThis object can be used as a reasonable estimate of\n\t\t10-Megabit ethernet utilization.  If greater precision is\n\t\tdesired, the etherStatsPkts and etherStatsOctets objects\n\t\tshould be sampled before and after a common interval.  The\n\t\tdifferences in the sampled values are Pkts and Octets,\n\t\trespectively, and the number of seconds in the interval is\n\t\tInterval.  These values are used to calculate the Utilization\n\t\tas follows:\n\n                          Pkts * (9.6 + 6.4) + (Octets * .8)\n          Utilization = -------------------------------------\n                                  Interval * 10,000\n\n\t\tThe result of this equation is the value Utilization which\n\t\tis the percent utilization of the ethernet segment on a\n\t\tscale of 0 to 100 percent.')
ethCurrentPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentPkts.setDescription('The number of packets (including bad packets) \n\t\treceived during this sampling interval.')
ethCurrentBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentBroadcastPkts.setDescription('The number of good packets received during this \n\t\tsampling interval that were directed to the broadcast \n\t\taddress.')
ethCurrentMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentMulticastPkts.setDescription('The number of good packets received during this \n\t\tsampling interval that were directed to a multicast \n\t\taddress. Note that this number does not include \n\t\tpackets addressed to the broadcast address.')
ethCurrentCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: ethCurrentCRCAlignErrors.setDescription('The number of packets received during this \n\t\tsampling interval that had a length (excluding framing \n\t\tbits but including FCS octets) between 64 and 1518 octets,\n\t\tinclusive, but had either a bad Frame Check Sequence (FCS)\n\t\twith an integral number of octets (FCS Error) or a bad FCS\n\t\twith a non-integral number of octets (Alignment Error).')
ethCurrentUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentUndersizePkts.setDescription('The number of packets received during this sampling\n\t\tinterval that were less than 64 octets long (excluding\n\t\tframing bits but including FCS octets) and were \n\t\totherwise well formed.')
ethCurrentOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentOversizePkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentOversizePkts.setDescription('The number of packets received during this sampling\n\t\tinterval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets) but were otherwise\n\t\twell formed.')
ethCurrentFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentFragments.setStatus('current')
if mibBuilder.loadTexts: ethCurrentFragments.setDescription('The total number of packets received during this \n\t\tsampling interval that were less than 64 octets in length\n\t\t(excluding framing bits but including FCS octets) had \n\t\teither a bad Frame Check Sequence (FCS) with an integral\n\t\tnumber of octets (FCS Error) or a bad FCS with a non-integral\n\t\tnumber of octets (Alignment error).')
ethCurrentJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentJabbers.setStatus('current')
if mibBuilder.loadTexts: ethCurrentJabbers.setDescription('The number of packets received during this sampling\n\t\tinterval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets), and had either a \n\t\tbad Frame Check Sequence (FCS) with an integral number of\n\t\toctets (FCS Error) or a bad FCS with a non-integral number \n\t\tof octets (Alignment Error).')
ethCurrentCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentCollisions.setStatus('current')
if mibBuilder.loadTexts: ethCurrentCollisions.setDescription('The best estimate of the total number of collisions \n\t\ton this Ethernet segment during this sampling interval.')
ethCurrentUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentUtilization.setStatus('current')
if mibBuilder.loadTexts: ethCurrentUtilization.setDescription('The best estimate of the mean physical layer network\n\t\tutilization on this interface during this sampling interval,\n\t\tin hundredths of a percent (0..10000).')
ethCurrentTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxOctets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxOctets.setDescription('The total number of octets of data \n\t\ttransmited during the current interval.')
ethCurrentTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts.setDescription('The number of packets (including bad packets) \n\t\treceived during the current interval.')
ethCurrentRxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPause.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPause.setDescription('The number of Pause frames \n\t\treceived during the current interval.')
ethCurrentTxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPause.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPause.setDescription('The number of Pause farmes \n\t\ttransmitted during the current interval.')
ethCurrentTxDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxDropEvents.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxDropEvents.setDescription('The total number of events in which packets were \n\t\tdropped by the probe due to lack of Egress resources during \n\t\tthis sampling interval. Note that this number is not\n\t\tnecessarily the number of packets dropped, it is just \n\t\tthe number of times this condition has been detected.')
ethCurrentRxPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts64Octets.setDescription('The total number of packets (including bad\n         packets) received that were 64 octets in length\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts65to127Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         65 and 127 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts128to255Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         128 and 255 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts256to511Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         256 and 511 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts512to1023Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         512 and 1023 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts1024to1518Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         1024 and 1518 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxPkts1519to1522Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxPkts1519to1522Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxPkts1519to1522Octets.setDescription('The total number of packets (including bad\n         packets) received that were between\n         1024 and 1518 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts64Octets.setDescription('The total number of packets transmitted \n         that were 64 octets in length\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts65to127Octets.setDescription('The total number of packets transmitted that were between\n         65 and 127 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts128to255Octets.setDescription('The total number of packets transmitted that were between\n         128 and 255 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts256to511Octets.setDescription('The total number of packets transmitted that were between\n         256 and 511 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts512to1023Octets.setDescription('The total number of packets transmitted that were between\n         512 and 1023 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts1024to1518Octets.setDescription('The total number of packets transmitted that were between\n         1024 and 1518 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentTxPkts1519to1522Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxPkts1519to1522Octets.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxPkts1519to1522Octets.setDescription('The total number of packets transmitted that were between\n         1519 and 1522 octets in length inclusive\n         (excluding framing bits but including FCS octets).')
ethCurrentRxVlanPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxVlanPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxVlanPkts.setDescription('The total number of VLAN packets received.')
ethCurrentTxVlanPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxVlanPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxVlanPkts.setDescription('The total number of VLAN packets transmitted.')
ethCurrentRxJumboPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 35), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentRxJumboPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentRxJumboPkts.setDescription('The total number of Jumbo packets received.')
ethCurrentTxJumboPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 2, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethCurrentTxJumboPkts.setStatus('current')
if mibBuilder.loadTexts: ethCurrentTxJumboPkts.setDescription('The total number of Jumbo packets transmitted.')
ethIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3), )
if mibBuilder.loadTexts: ethIntervalTable.setStatus('current')
if mibBuilder.loadTexts: ethIntervalTable.setDescription('The Ethernet Interval Table contains various\n\t\tstatistics collected by each Ethernet Interface over\n\t\tthe previous 24 hours of operation.  The past 24\n\t\thours are broken into 96 completed 15 minute\n\t\tintervals.  Each row in this table represents one\n\t\tsuch interval (identified by ethIntervalNumber)\n\t\tfor one specific instance (identified by\n\t\tethIntervalIndex).')
ethIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1), ).setIndexNames((0, "SL-ETH-MIB", "ethIntervalIndex"), (0, "SL-ETH-MIB", "ethIntervalNumber"))
if mibBuilder.loadTexts: ethIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: ethIntervalEntry.setDescription('An entry in the Ethernet Interval table.')
ethIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalIndex.setStatus('current')
if mibBuilder.loadTexts: ethIntervalIndex.setDescription('The index value which uniquely identifies the Ethernet\n\t\tinterface to which this entry is applicable.  The\n\t\tinterface identified by a particular value of this\n\t\tindex is the same interface as identified by the\n\t\tsame value as a ethLineIndex object instance.')
ethIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: ethIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most\n\t\trecently completed 15 minute interval and 96 is\n\t\tthe 15 minutes interval completed 23 hours and 45\n\t\tminutes prior to interval 1.')
ethIntervalDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalDropEvents.setStatus('current')
if mibBuilder.loadTexts: ethIntervalDropEvents.setDescription('The total number of events in which packets were \n\t\tdropped by the probe due to lack of resources during \n\t\tthis sampling interval. Note that this number is not\n\t\tnecessarily the number of packets dropped, it is just \n\t\tthe number of times this condition has been detected.')
ethIntervalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalOctets.setStatus('current')
if mibBuilder.loadTexts: ethIntervalOctets.setDescription('The total number of octets of data (including those \n\t\tin bad packets) received on the network (excluding \n\t\tframing bits but including FCS octets) in the current \n\t\tinterval.')
ethIntervalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalPkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalPkts.setDescription('The number of packets (including bad packets) \n\t\treceived during this sampling interval.')
ethIntervalBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalBroadcastPkts.setDescription('The number of good packets received during this \n\t\tsampling interval that were directed to the broadcast \n\t\taddress.')
ethIntervalMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalMulticastPkts.setDescription('The number of good packets received during this \n\t\tsampling interval that were directed to a multicast \n\t\taddress. Note that this number does not include \n\t\tpackets addressed to the broadcast address.')
ethIntervalCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: ethIntervalCRCAlignErrors.setDescription('The number of packets received during this \n\t\tsampling interval that had a length (excluding framing \n\t\tbits but including FCS octets) between 64 and 1518 octets,\n\t\tinclusive, but had either a bad Frame Check Sequence (FCS)\n\t\twith an integral number of octets (FCS Error) or a bad FCS\n\t\twith a non-integral number of octets (Alignment Error).')
ethIntervalUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalUndersizePkts.setDescription('The number of packets received during this sampling\n\t\tinterval that were less than 64 octets long (excluding\n\t\tframing bits but including FCS octets) and were \n\t\totherwise well formed.')
ethIntervalOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalOversizePkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalOversizePkts.setDescription('The number of packets received during this sampling\n\t\tinterval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets) but were otherwise\n\t\twell formed.')
ethIntervalFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalFragments.setStatus('current')
if mibBuilder.loadTexts: ethIntervalFragments.setDescription('The total number of packets received during this \n\t\tsampling interval that were less than 64 octets in length\n\t\t(excluding framing bits but including FCS octets) had \n\t\teither a bad Frame Check Sequence (FCS) with an integral\n\t\tnumber of octets (FCS Error) or a bad FCS with a non-integral\n\t\tnumber of octets (Alignment error).')
ethIntervalJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalJabbers.setStatus('current')
if mibBuilder.loadTexts: ethIntervalJabbers.setDescription('The number of packets received during this sampling\n\t\tinterval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets), and had either a \n\t\tbad Frame Check Sequence (FCS) with an integral number of\n\t\toctets (FCS Error) or a bad FCS with a non-integral number \n\t\tof octets (Alignment Error).')
ethIntervalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalCollisions.setStatus('current')
if mibBuilder.loadTexts: ethIntervalCollisions.setDescription('The best estimate of the total number of collisions \n\t\ton this Ethernet segment during this sampling interval.')
ethIntervalUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalUtilization.setStatus('current')
if mibBuilder.loadTexts: ethIntervalUtilization.setDescription('The best estimate of the mean physical layer network\n\t\tutilization on this interface during this sampling interval,\n\t\tin hundredths of a percent (0..10000).')
ethIntervalTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalTxOctets.setStatus('current')
if mibBuilder.loadTexts: ethIntervalTxOctets.setDescription('The total number of octets of data \n\t\ttransmited on the network.')
ethIntervalTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalTxPkts.setStatus('current')
if mibBuilder.loadTexts: ethIntervalTxPkts.setDescription('The number of packets (including bad packets) \n\t\treceived during this sampling interval.')
ethIntervalRxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalRxPause.setStatus('current')
if mibBuilder.loadTexts: ethIntervalRxPause.setDescription('The number of Pause frames \n\t\treceived during this sampling interval.')
ethIntervalTxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalTxPause.setStatus('current')
if mibBuilder.loadTexts: ethIntervalTxPause.setDescription('The number of Pause farmes \n\t\ttransmitted during this sampling interval.')
ethIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: ethIntervalValidData.setDescription('This variable indicates if the data for this\n        interval is valid.')
ethIntervalTcaFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 3, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntervalTcaFlag.setStatus('current')
if mibBuilder.loadTexts: ethIntervalTcaFlag.setDescription('TRUE if one of the counters crossed the threshold during the interval.')
ethTotalTable = MibTable((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4), )
if mibBuilder.loadTexts: ethTotalTable.setStatus('current')
if mibBuilder.loadTexts: ethTotalTable.setDescription('The Ethernet Total Table contains the cumulative sum\n\t\tof the various statistics for the 24 hour period\n\t\tpreceding the current day, starting from startOfDay.')
ethTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1), ).setIndexNames((0, "SL-ETH-MIB", "ethTotalIndex"), (0, "SL-ETH-MIB", "ethTotalDayNumber"))
if mibBuilder.loadTexts: ethTotalEntry.setStatus('current')
if mibBuilder.loadTexts: ethTotalEntry.setDescription('An entry in the Ethernet Total table.')
ethTotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalIndex.setStatus('current')
if mibBuilder.loadTexts: ethTotalIndex.setDescription('The index value which uniquely identifies the Ethernet\n\t\tinterface to which this entry is applicable.  The\n\t\tinterface identified by a particular value of this\n\t\tindex is the same interface as identified by the\n\t\tsame value as a ethLineIndex object instance.')
ethTotalDayNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 33)))
if mibBuilder.loadTexts: ethTotalDayNumber.setStatus('current')
if mibBuilder.loadTexts: ethTotalDayNumber.setDescription('A number which identifies the 1-day interval for which the set\n        of section related statistics is available.  The number is\n        between 1 and n, where n is the number of 1-day intervals\n        supported by the agent.  The interval identified by 1 is the\n        current 1-day interval, 2 is the previous (most recently\n        completed) 1-day interval and n is the least recently completed\n        1-day interval.')
ethTotalDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalDropEvents.setStatus('current')
if mibBuilder.loadTexts: ethTotalDropEvents.setDescription('The total number of events in which packets were \n\t\tdropped by the probe due to lack of resources in the \n\t\tprevious 24 hour interval. Note that this number is not\n\t\tnecessarily the number of packets dropped, it is just \n\t\tthe number of times this condition has been detected.')
ethTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalOctets.setStatus('current')
if mibBuilder.loadTexts: ethTotalOctets.setDescription('The total number of octets of data (including those \n\t\tin bad packets) received on the network (excluding \n\t\tframing bits but including FCS octets) in the \n\t\tprevious 24 hour interval.')
ethTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalPkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalPkts.setDescription(' The number of packets (including bad packets) \n\t\treceived in the previous 24 hour interval.')
ethTotalBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalBroadcastPkts.setDescription(' The number of good packets received in the \n\t\t\t\tprevious 24 hour interval that were directed \n\t\t\t\tto the broadcast address.')
ethTotalMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalMulticastPkts.setDescription('The number of good packets received in the \n\t\t\t\tprevious 24 hour interval that were directed to a \n\t\t\t\tmulticast address. Note that this number does not include \n\t\t\t\tpackets addressed to the broadcast address.')
ethTotalCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: ethTotalCRCAlignErrors.setDescription('The number of packets received in the previous 24 \n\t\thour interval that had a length (excluding framing \n\t\tbits but including FCS octets) between 64 and 1518 octets,\n\t\tinclusive, but had either a bad Frame Check Sequence (FCS)\n\t\twith an integral number of octets (FCS Error) or a bad FCS\n\t\twith a non-integral number of octets (Alignment Error).')
ethTotalUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalUndersizePkts.setDescription('The number of packets received in the previous 24 hour\n\t\tinterval that were less than 64 octets long (excluding\n\t\tframing bits but including FCS octets) and were \n\t\totherwise well formed.')
ethTotalOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalOversizePkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalOversizePkts.setDescription('The number of packets received in the previous 24 \n\t\thour interval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets) but were otherwise\n\t\twell formed.')
ethTotalFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalFragments.setStatus('current')
if mibBuilder.loadTexts: ethTotalFragments.setDescription('The total number of packets received in the previous 24 \n\t\thour interval that were less than 64 octets in length\n\t\t(excluding framing bits but including FCS octets) had \n\t\teither a bad Frame Check Sequence (FCS) with an integral\n\t\tnumber of octets (FCS Error) or a bad FCS with a non-integral\n\t\tnumber of octets (Alignment error).')
ethTotalJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalJabbers.setStatus('current')
if mibBuilder.loadTexts: ethTotalJabbers.setDescription('The number of packets received in the previous 24 hour \n\t\tinterval that were longer than 1518 octets (excluding \n\t\tframing bits but including FCS octets), and had either a \n\t\tbad Frame Check Sequence (FCS) with an integral number of\n\t\toctets (FCS Error) or a bad FCS with a non-integral number \n\t\tof octets (Alignment Error).')
ethTotalCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalCollisions.setStatus('current')
if mibBuilder.loadTexts: ethTotalCollisions.setDescription('The best estimate of the total number of collisions \n\t\ton this Ethernet segment in the previous 24 hour interval.')
ethTotalUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalUtilization.setStatus('current')
if mibBuilder.loadTexts: ethTotalUtilization.setDescription('The avarage of the mean physical layer network\n\t\tutilization on this interface in the previous 24 hour \n\t\tinterval.')
ethTotalTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalTxOctets.setStatus('current')
if mibBuilder.loadTexts: ethTotalTxOctets.setDescription('The total number of octets of data \n\t\ttransmited on the network.')
ethTotalTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalTxPkts.setStatus('current')
if mibBuilder.loadTexts: ethTotalTxPkts.setDescription('The number of packets (including bad packets) \n\t\treceived during this sampling interval.')
ethTotalRxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalRxPause.setStatus('current')
if mibBuilder.loadTexts: ethTotalRxPause.setDescription('The number of Pause frames \n\t\treceived during this sampling interval.')
ethTotalTxPause = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalTxPause.setStatus('current')
if mibBuilder.loadTexts: ethTotalTxPause.setDescription('The number of Pause farmes \n\t\ttransmitted during this sampling interval.')
ethTotalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 4, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethTotalValidData.setStatus('current')
if mibBuilder.loadTexts: ethTotalValidData.setDescription('This variable indicates if the data for this\n        day is valid.')
ethStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 4515, 1, 1, 1, 7, 1)).setObjects(("SL-ETH-MIB", "ethLineIndex"), ("SL-ETH-MIB", "ethConfigStatus"))
if mibBuilder.loadTexts: ethStatusChange.setStatus('current')
if mibBuilder.loadTexts: ethStatusChange.setDescription('A ethStatusChange trap is sent when the\n\t\tvalue of an instance ethConfigStatus changes. It\n\t\tcan be utilized by an NMS to trigger polls.')
mibBuilder.exportSymbols("SL-ETH-MIB", ethCurrentRxPkts64Octets=ethCurrentRxPkts64Octets, ethCurrentJabbers=ethCurrentJabbers, ethIntervalDropEvents=ethIntervalDropEvents, ethIntervalValidData=ethIntervalValidData, ethIntervalTcaFlag=ethIntervalTcaFlag, ethCurrentRxPkts512to1023Octets=ethCurrentRxPkts512to1023Octets, ethTotalTxOctets=ethTotalTxOctets, ethStatusChange=ethStatusChange, ethTimeElapsed=ethTimeElapsed, ethPauseTime=ethPauseTime, ethCurrentRxDropEvents=ethCurrentRxDropEvents, ethIntervalRxPause=ethIntervalRxPause, ethTransceiverMedia=ethTransceiverMedia, ethTotalTxPause=ethTotalTxPause, ethCurrentTxOctets=ethCurrentTxOctets, ethTotalUndersizePkts=ethTotalUndersizePkts, ethIntervalBroadcastPkts=ethIntervalBroadcastPkts, ethAutoNegSupported=ethAutoNegSupported, ethCurrentTxVlanPkts=ethCurrentTxVlanPkts, ethCurrentTxPkts65to127Octets=ethCurrentTxPkts65to127Octets, ethConfigEntry=ethConfigEntry, ethCurrentTxPkts256to511Octets=ethCurrentTxPkts256to511Octets, ethIntervalUtilization=ethIntervalUtilization, ethCurrentOversizePkts=ethCurrentOversizePkts, ethIntervalMulticastPkts=ethIntervalMulticastPkts, ethCurrentTxPkts1024to1518Octets=ethCurrentTxPkts1024to1518Octets, ethConfigTable=ethConfigTable, ethCurrentRxPkts128to255Octets=ethCurrentRxPkts128to255Octets, ethCurrentUndersizePkts=ethCurrentUndersizePkts, ethCurrentUtilization=ethCurrentUtilization, ethCurrentRxPkts65to127Octets=ethCurrentRxPkts65to127Octets, ethTotalTxPkts=ethTotalTxPkts, ethIntervalTxOctets=ethIntervalTxOctets, ethCurrentEntry=ethCurrentEntry, ethTotalRxPause=ethTotalRxPause, ethCurrentTxPause=ethCurrentTxPause, ethTotalValidData=ethTotalValidData, ethTotalFragments=ethTotalFragments, ethIntervalIndex=ethIntervalIndex, ethTotalOversizePkts=ethTotalOversizePkts, PYSNMP_MODULE_ID=slEthernet, ethTotalCRCAlignErrors=ethTotalCRCAlignErrors, ethCurrentTable=ethCurrentTable, ethCurrentTxPkts64Octets=ethCurrentTxPkts64Octets, ethCurrentTxPkts=ethCurrentTxPkts, ethIntervalEntry=ethIntervalEntry, ethTotalIndex=ethTotalIndex, ethTotalMulticastPkts=ethTotalMulticastPkts, ethResetPm=ethResetPm, ethCurrentTxPkts1519to1522Octets=ethCurrentTxPkts1519to1522Octets, ethIntervalTxPause=ethIntervalTxPause, ethCurrentRxVlanPkts=ethCurrentRxVlanPkts, ethLineIndex=ethLineIndex, ethConfigStatus=ethConfigStatus, ethCurrentMulticastPkts=ethCurrentMulticastPkts, ethCurrentTxDropEvents=ethCurrentTxDropEvents, ethTotalJabbers=ethTotalJabbers, ethTraps=ethTraps, ethTotalDropEvents=ethTotalDropEvents, ethIntervalTable=ethIntervalTable, ethIntervalFragments=ethIntervalFragments, ethCurrentRxPkts1024to1518Octets=ethCurrentRxPkts1024to1518Octets, ethTotalDayNumber=ethTotalDayNumber, ethIntervalJabbers=ethIntervalJabbers, ethTransceiverType=ethTransceiverType, ethTotalUtilization=ethTotalUtilization, ethTotalCollisions=ethTotalCollisions, ethCurrentFragments=ethCurrentFragments, ethIntervalNumber=ethIntervalNumber, ethAutoNegAdminStatus=ethAutoNegAdminStatus, ethCurrentRxPkts1519to1522Octets=ethCurrentRxPkts1519to1522Octets, ethTotalOctets=ethTotalOctets, slEthernet=slEthernet, ethCurrentTxPkts512to1023Octets=ethCurrentTxPkts512to1023Octets, ethIntervalOctets=ethIntervalOctets, ethIntervalPkts=ethIntervalPkts, ethCurrentCRCAlignErrors=ethCurrentCRCAlignErrors, ethIntervalUndersizePkts=ethIntervalUndersizePkts, ethIntervalTxPkts=ethIntervalTxPkts, ethIntervalCollisions=ethIntervalCollisions, ethPauseEnable=ethPauseEnable, ethCurrentBroadcastPkts=ethCurrentBroadcastPkts, ethCurrentRxPkts256to511Octets=ethCurrentRxPkts256to511Octets, ethTotalBroadcastPkts=ethTotalBroadcastPkts, ethCurrentRxPause=ethCurrentRxPause, ethCurrentCollisions=ethCurrentCollisions, ethValidIntervals=ethValidIntervals, ethResetPmCounters=ethResetPmCounters, ethCurrentPkts=ethCurrentPkts, ethCurrentOctets=ethCurrentOctets, ethCurrentIndex=ethCurrentIndex, ethIntervalCRCAlignErrors=ethIntervalCRCAlignErrors, ethCurrentTxJumboPkts=ethCurrentTxJumboPkts, ethTotalEntry=ethTotalEntry, ethCurrentTxPkts128to255Octets=ethCurrentTxPkts128to255Octets, ethIntervalOversizePkts=ethIntervalOversizePkts, ethCurrentRxJumboPkts=ethCurrentRxJumboPkts, ethTotalPkts=ethTotalPkts, ethTotalTable=ethTotalTable)
