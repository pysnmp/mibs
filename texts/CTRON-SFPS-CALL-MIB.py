#
# PySNMP MIB module CTRON-SFPS-CALL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-SFPS-CALL-MIB
# Produced by pysmi-1.1.10 at Thu Oct 26 13:06:01 2023
# On host fv-az445-119 platform Linux version 6.2.0-1015-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
sfpsSapAPI, sfpsCallByTuple, sfpsSap, sfpsCallTableStats = mibBuilder.importSymbols("CTRON-SFPS-INCLUDE-MIB", "sfpsSapAPI", "sfpsCallByTuple", "sfpsSap", "sfpsCallTableStats")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, ObjectIdentity, IpAddress, Gauge32, NotificationType, TimeTicks, iso, MibIdentifier, Counter64, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "IpAddress", "Gauge32", "NotificationType", "TimeTicks", "iso", "MibIdentifier", "Counter64", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter32", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class HexInteger(Integer32):
    pass

sfpsSapTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1), )
if mibBuilder.loadTexts: sfpsSapTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTable.setDescription('This table contains the registered (active) call processors\n                indexed (indirectly) by address and address type supported.')
sfpsSapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-SFPS-CALL-MIB", "sfpsSapTableTag"), (0, "CTRON-SFPS-CALL-MIB", "sfpsSapTableHash"), (0, "CTRON-SFPS-CALL-MIB", "sfpsSapTableHashIndex"))
if mibBuilder.loadTexts: sfpsSapTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableEntry.setDescription('Each entry contains information pertaining to an active\n                call processor.')
sfpsSapTableTag = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableTag.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableTag.setDescription('A type tag used to sort and index the table entries.')
sfpsSapTableHash = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableHash.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableHash.setDescription('A hash of the sfpsSapTableAddress used to identify the \n                instance.')
sfpsSapTableHashIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableHashIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableHashIndex.setDescription('A count of the non-unique sfpsSapTableAddress hashes used to\n                identify the instance.')
sfpsSapTableSourceCP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableSourceCP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableSourceCP.setDescription('The name of the call processor initiating the the SAP attempts\n                for this particular SAP load.')
sfpsSapTableDestCP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableDestCP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableDestCP.setDescription('The destination call processor that is registered for with this\n                source call processor for the given SAP load.')
sfpsSapTableSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableSAP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableSAP.setDescription('The value of the SAP in 0x format.')
sfpsSapTableOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableOperStatus.setDescription('Displays the Current OperStatus of the SAP entry.')
sfpsSapTableAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableAdminStatus.setDescription('Displays the Current AdminStatus of the SAP entry.')
sfpsSapTableStateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableStateTime.setDescription('Total number of SFPSElements stored in NVRAM for persistence.')
sfpsSapTableDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableDescription.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableDescription.setDescription('Text description of the entry.')
sfpsSapTableNumAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableNumAccepted.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableNumAccepted.setDescription('Number accepted by the SAP.')
sfpsSapTableNumDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableNumDropped.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableNumDropped.setDescription('Number dropped by the SAP.')
sfpsSapTableUnicastSap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapTableUnicastSap.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableUnicastSap.setDescription('')
sfpsSapTableNVStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3), ("unset", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapTableNVStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapTableNVStatus.setDescription('Status in NVRAM  for persistence.')
sfpsSapAPIVerb = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("getStatus", 1), ("next", 2), ("first", 3), ("disable", 4), ("disableInNvram", 5), ("enable", 6), ("enableInNvram", 7), ("clearFromNvram", 8), ("clearAllNvram", 9), ("resetStats", 10), ("resetAllStats", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapAPIVerb.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPIVerb.setDescription('1 - getStatus -- The default verb. When the SourceCP, DestCP,\n                 and SAP info are entered, this action will get the current\n                 AdminStatus, OperStatus, and NvramStatus.\n                (Must perform a mo_get after setting the above info to actually\n                get the status info)\n                2 - next -- Move to the next Entry in the SAP Table and Get the\n                 status. If this operation is successful, the verb will stay\n                 next, else it defaults to getStatus.\n                3 - first -- Jump back to the First Entry in the SAP Table.\n                4 - disable -- Disable the Current SAP Entry.\n                This does not effect the Status of this Entry in Nvram.\n                5 - disableInNvram -- Set the Current SAP Entries status to\n                 Disabled in Nvram - This does not effect the Current Admin\n                 Status for this SAP Entry.\n                6 - enable -- Enable the Current SAP Entry.\n                This does not effect the Status of this Entry in Nvram.\n                7 - enableInNvram -- Set the Current SAP Entries status to\n                Enabled in Nvram - This does not effect the Current Admin \n                Status for this SAP Entry.\n                8 - clearFromNvram -- Clear the Current SAP Entry from Nvram \n                (if set).\n                9 - clearAllNvram -- Clear all SAP Entries from Nvram.\n                10 - resetStats -- Resets the Accepted/Dropped Stats for the\n                Current/Entered SAP Entry.\n                11 - resetAllStats -- Resets the Accepted/Dropped Stats for \n                all SAP Entries.')
sfpsSapAPISourceCP = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapAPISourceCP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPISourceCP.setDescription('The name of the call processor initiating the the SAP attempts\n                for this particular SAP load.')
sfpsSapAPIDestCP = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapAPIDestCP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPIDestCP.setDescription('The destination call processor that is registered for with this\n                source call processor for the given SAP load.')
sfpsSapAPISAP = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapAPISAP.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPISAP.setDescription('Enter in the SAP for the desired SAP Entry.')
sfpsSapAPINVStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3), ("unset", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPINVStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPINVStatus.setDescription('Displays the Current Admin Status of this SAP Entry saved \n                in Nvram.')
sfpsSapAPIAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPIAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPIAdminStatus.setDescription('Displays the Current AdminStatus of the SAP Entry.')
sfpsSapAPIOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPIOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPIOperStatus.setDescription('Displays the Current OperStatus of the SAP Entry.')
sfpsSapAPINvSet = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPINvSet.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPINvSet.setDescription('Total number of entries stored in NVRAM for persistence.')
sfpsSapAPINVTotal = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsSapAPINVTotal.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPINVTotal.setDescription('Total number of entries allocated in NVRAM. The \n                switch will always allocate enough space in NVRAM for\n                the number of elements. That is, NvTotal will always be\n                greater than or equal to NvSet.')
sfpsSapAPINumAccept = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPINumAccept.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPINumAccept.setDescription('')
sfpsSapAPINvDiscard = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPINvDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPINvDiscard.setDescription('')
sfpsSapAPIDefaultStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 2, 2, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsSapAPIDefaultStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsSapAPIDefaultStatus.setDescription('')
sfpsCallByTupleTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1), )
if mibBuilder.loadTexts: sfpsCallByTupleTable.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTable.setDescription('This table contains the call tags, and call states \n                indexed (indirectly) by switch tuple (in port, src \n                address, dst address)')
sfpsCallByTupleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1), ).setIndexNames((0, "CTRON-SFPS-CALL-MIB", "sfpsCallByTupleInPort"), (0, "CTRON-SFPS-CALL-MIB", "sfpsCallByTupleSrcHash"), (0, "CTRON-SFPS-CALL-MIB", "sfpsCallByTupleDstHash"), (0, "CTRON-SFPS-CALL-MIB", "sfpsCallByTupleHashIndex"))
if mibBuilder.loadTexts: sfpsCallByTupleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleEntry.setDescription('Each entry contains information pertaining to a call tag\n                and its state.')
sfpsCallByTupleInPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleInPort.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleInPort.setDescription('Port of the switch on which the packet associated with \n                this call tag was seen.')
sfpsCallByTupleSrcHash = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleSrcHash.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleSrcHash.setDescription('A hash of sfpsCallByTupleBotSrcAddress used to identify the \n                instance.')
sfpsCallByTupleDstHash = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleDstHash.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleDstHash.setDescription('A hash of sfpsCallByTupleTopDstAddress used to identify the \n                instance.')
sfpsCallByTupleHashIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleHashIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleHashIndex.setDescription('A count of non-unique sfpsCallByTupleSrcHash and \n                sfpsCallByTupleDstHash pairs used to identify the instance.')
sfpsCallByTupleBotSrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleBotSrcType.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleBotSrcType.setDescription('The source address type of the lowest known protocol \n                layer.')
sfpsCallByTupleBotSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleBotSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleBotSrcAddress.setDescription('The source address value of the lowest known protocol \n                layer.')
sfpsCallByTupleBotDstType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleBotDstType.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleBotDstType.setDescription('The destination address type of the lowest known \n                protocol layer.')
sfpsCallByTupleBotDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleBotDstAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleBotDstAddress.setDescription('The destination address value of the lowest known \n                protocol layer.')
sfpsCallByTupleTopSrcType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleTopSrcType.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTopSrcType.setDescription('The source address type of the highest learned protocol \n                layer.')
sfpsCallByTupleTopSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleTopSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTopSrcAddress.setDescription('The source address value of the highest learned protocol \n                layer.')
sfpsCallByTupleTopDstType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleTopDstType.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTopDstType.setDescription('The destination address type of the highest learned \n                protocol layer.')
sfpsCallByTupleTopDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleTopDstAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTopDstAddress.setDescription('The destination address value of the highest learned \n                protocol layer.')
sfpsCallByTupleCallProcName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleCallProcName.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleCallProcName.setDescription('The name of the call processor responsible for all \n                signaling for this packet/call tag.')
sfpsCallByTupleCallTag = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 14), HexInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleCallTag.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleCallTag.setDescription('The number used to reference this packet and its \n                associated calls.')
sfpsCallByTupleCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleCallState.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleCallState.setDescription('The current state of the packet in the call processor.')
sfpsCallByTupleTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 5, 1, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallByTupleTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallByTupleTimeRemaining.setDescription("The number of time ticks remaining before this entry's\n                timer expires and it is removed from the table.")
sfpsCallTableStatsRam = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsRam.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsRam.setDescription('The number of bytes used by the Call Table.')
sfpsCallTableStatsSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsSize.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsSize.setDescription('The number of entries in the Call Table.')
sfpsCallTableStatsInUse = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsInUse.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsInUse.setDescription('The current number of calls in use. A call goes into this\n                table only if it is being blocked (waiting for resolve or\n                sent new user).')
sfpsCallTableStatsMax = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsMax.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsMax.setDescription('The maximum number of calls that the switch maintained.')
sfpsCallTableStatsTotMisses = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsTotMisses.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsTotMisses.setDescription('The number of times that there were no calls available\n                 in the Call Table. This would be the number of calls that\n                 had to be dropped.')
sfpsCallTableStatsMissStart = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsMissStart.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsMissStart.setDescription('Time when last miss occurred')
sfpsCallTableStatsMissStop = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpsCallTableStatsMissStop.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsMissStop.setDescription('Time when missing stopped')
sfpsCallTableStatsLastMiss = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 4, 2, 2, 5, 1, 6, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpsCallTableStatsLastMiss.setStatus('mandatory')
if mibBuilder.loadTexts: sfpsCallTableStatsLastMiss.setDescription('Number of calls dropped in last miss,  also write 0 to files')
mibBuilder.exportSymbols("CTRON-SFPS-CALL-MIB", sfpsCallByTupleCallState=sfpsCallByTupleCallState, sfpsCallByTupleBotSrcType=sfpsCallByTupleBotSrcType, sfpsCallByTupleHashIndex=sfpsCallByTupleHashIndex, sfpsSapTableTag=sfpsSapTableTag, sfpsSapTableHashIndex=sfpsSapTableHashIndex, sfpsSapTableUnicastSap=sfpsSapTableUnicastSap, sfpsCallByTupleSrcHash=sfpsCallByTupleSrcHash, sfpsSapAPISourceCP=sfpsSapAPISourceCP, sfpsSapTableSourceCP=sfpsSapTableSourceCP, sfpsSapTableNumDropped=sfpsSapTableNumDropped, sfpsSapTable=sfpsSapTable, sfpsSapTableStateTime=sfpsSapTableStateTime, sfpsSapTableNVStatus=sfpsSapTableNVStatus, sfpsCallByTupleTopSrcType=sfpsCallByTupleTopSrcType, sfpsCallTableStatsMissStop=sfpsCallTableStatsMissStop, sfpsCallTableStatsMax=sfpsCallTableStatsMax, sfpsCallByTupleBotSrcAddress=sfpsCallByTupleBotSrcAddress, sfpsSapAPISAP=sfpsSapAPISAP, sfpsCallByTupleTopSrcAddress=sfpsCallByTupleTopSrcAddress, sfpsCallByTupleTopDstType=sfpsCallByTupleTopDstType, sfpsSapAPIAdminStatus=sfpsSapAPIAdminStatus, sfpsSapTableNumAccepted=sfpsSapTableNumAccepted, sfpsCallByTupleCallProcName=sfpsCallByTupleCallProcName, sfpsCallByTupleTopDstAddress=sfpsCallByTupleTopDstAddress, sfpsSapAPIOperStatus=sfpsSapAPIOperStatus, sfpsCallByTupleTimeRemaining=sfpsCallByTupleTimeRemaining, sfpsCallByTupleEntry=sfpsCallByTupleEntry, sfpsCallByTupleInPort=sfpsCallByTupleInPort, sfpsSapAPIDefaultStatus=sfpsSapAPIDefaultStatus, sfpsSapTableDescription=sfpsSapTableDescription, sfpsCallTableStatsLastMiss=sfpsCallTableStatsLastMiss, sfpsCallTableStatsRam=sfpsCallTableStatsRam, sfpsSapAPINvDiscard=sfpsSapAPINvDiscard, sfpsSapTableDestCP=sfpsSapTableDestCP, sfpsCallByTupleCallTag=sfpsCallByTupleCallTag, sfpsSapTableOperStatus=sfpsSapTableOperStatus, sfpsCallTableStatsSize=sfpsCallTableStatsSize, sfpsSapTableSAP=sfpsSapTableSAP, sfpsSapAPIVerb=sfpsSapAPIVerb, sfpsSapTableAdminStatus=sfpsSapTableAdminStatus, sfpsSapAPINvSet=sfpsSapAPINvSet, sfpsCallByTupleBotDstType=sfpsCallByTupleBotDstType, sfpsCallTableStatsInUse=sfpsCallTableStatsInUse, sfpsCallTableStatsTotMisses=sfpsCallTableStatsTotMisses, sfpsSapTableEntry=sfpsSapTableEntry, sfpsCallByTupleBotDstAddress=sfpsCallByTupleBotDstAddress, sfpsCallTableStatsMissStart=sfpsCallTableStatsMissStart, sfpsSapAPINVStatus=sfpsSapAPINVStatus, sfpsCallByTupleTable=sfpsCallByTupleTable, sfpsSapAPINumAccept=sfpsSapAPINumAccept, sfpsSapTableHash=sfpsSapTableHash, sfpsSapAPIDestCP=sfpsSapAPIDestCP, HexInteger=HexInteger, sfpsCallByTupleDstHash=sfpsCallByTupleDstHash, sfpsSapAPINVTotal=sfpsSapAPINVTotal)
