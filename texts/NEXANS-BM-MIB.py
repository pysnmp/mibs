#
# PySNMP MIB module NEXANS-BM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nexans/NEXANS-BM-MIB
# Produced by pysmi-1.1.12 at Tue Jun 18 01:42:05 2024
# On host fv-az1446-447 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
nexansANS, = mibBuilder.importSymbols("NEXANS-MIB", "nexansANS")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ObjectIdentity, MibIdentifier, Counter32, iso, Unsigned32, TimeTicks, NotificationType, Bits, IpAddress, Counter64, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ObjectIdentity", "MibIdentifier", "Counter32", "iso", "Unsigned32", "TimeTicks", "NotificationType", "Bits", "IpAddress", "Counter64", "Gauge32")
TextualConvention, DisplayString, MacAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress")
bmSwitchMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 266, 20))
bmSwitchMIB.setRevisions(('2014-01-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bmSwitchMIB.setRevisionsDescriptions(('Revision 4.01',))
if mibBuilder.loadTexts: bmSwitchMIB.setLastUpdated('201401290000Z')
if mibBuilder.loadTexts: bmSwitchMIB.setOrganization('Nexans Advanced Networking Solutions')
if mibBuilder.loadTexts: bmSwitchMIB.setContactInfo('h.theissen@nexans.com')
if mibBuilder.loadTexts: bmSwitchMIB.setDescription('MIB for Nexans switches')
bmTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 0))
bmSwitchInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 1))
bmSwitchAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 2))
bmSwitchPort = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 3))
bmSwitchVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 4))
bmSwitchSfp = MibIdentifier((1, 3, 6, 1, 4, 1, 266, 20, 5))
infoDescr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoDescr.setStatus('current')
if mibBuilder.loadTexts: infoDescr.setDescription('The ordering description of the switch')
infoType = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoType.setStatus('current')
if mibBuilder.loadTexts: infoType.setDescription('The infoType indentifies the product familie of this switch.\n\t\t Refer to NEXANS-MIB for the currently defined families')
infoProductNo = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoProductNo.setStatus('current')
if mibBuilder.loadTexts: infoProductNo.setDescription('The product number of the switch (8830xxxx)')
infoSerie = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSerie.setStatus('current')
if mibBuilder.loadTexts: infoSerie.setDescription('The production series of the switch')
infoSeriesNo = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSeriesNo.setStatus('current')
if mibBuilder.loadTexts: infoSeriesNo.setDescription('The production number of the switch')
infoManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoManufactureDate.setStatus('current')
if mibBuilder.loadTexts: infoManufactureDate.setDescription('The manufacturing date of the switch.\n\t\t The display format is dd.mm.jjjj')
infoSwitchHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSwitchHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoSwitchHardwareVersion.setDescription('The hardware version of the base switch.')
infoMgmtHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoMgmtHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoMgmtHardwareVersion.setDescription('The hardware version of the plug-in management module.')
infoMgmtFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoMgmtFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: infoMgmtFirmwareVersion.setDescription('The firmware version of the management module.')
infoNoOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNoOfPorts.setStatus('current')
if mibBuilder.loadTexts: infoNoOfPorts.setDescription('The number of switching ports within the system. This includes all\n\t\t user and uplink ports.')
infoNoOfReboots = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNoOfReboots.setStatus('current')
if mibBuilder.loadTexts: infoNoOfReboots.setDescription("The number of reboots since the manufacturing date. This counter \n\t\tcan't be cleared by any admin command.")
infoTemperature = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTemperature.setStatus('current')
if mibBuilder.loadTexts: infoTemperature.setDescription('The case temperature in degree Celsius of the switch.')
infoTemperatureMaxAllowed = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTemperatureMaxAllowed.setStatus('current')
if mibBuilder.loadTexts: infoTemperatureMaxAllowed.setDescription('The upper limit of the allowed temperature range in degree\n\t\tCelsius.\n\t\tIf the current temperature indicated by infoTemperature\n\t\texceeds infoTemperatureMaxAllowed, the switch sends an \n\t\tswitchOverTemperature alarm trap.')
infoPowerVoltage2500 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPowerVoltage2500.setStatus('current')
if mibBuilder.loadTexts: infoPowerVoltage2500.setDescription('The 2.5 volt supply voltage in millivolts.\n\t\tThe allowed range is 2300...2700 millivolts.')
infoPowerVoltage3300 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPowerVoltage3300.setStatus('current')
if mibBuilder.loadTexts: infoPowerVoltage3300.setDescription('The 3.3 volt supply voltage in millivolts.\n\t\tThe allowed range is 3100...3500 millivolts.')
infoUnauthIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoUnauthIpAddr.setStatus('current')
if mibBuilder.loadTexts: infoUnauthIpAddr.setDescription('The source IP address of the station which generated the last\n\t\tauthentication failure. The infoUnauthAddr is also reported \n\t\tin the switchMgmtAuthFailure alarm trap.')
infoSecurityFailMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoSecurityFailMacAddr.setStatus('current')
if mibBuilder.loadTexts: infoSecurityFailMacAddr.setDescription('The source MAC address of the station which has generated a\n\t\tthe last port security failure. The infoSecurityFailMacAddr is\n\t\talso reported in the portSecurityFailure alarm trap.')
infoNewMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoNewMacAddr.setStatus('current')
if mibBuilder.loadTexts: infoNewMacAddr.setDescription('The last new source MAC address seen on a port witch has \n\t\tportsecurity enabled. The infoNewMacAddr is also reported in the\n\t\tnewMacAddress trap.')
infoPoeInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPoeInputVoltage.setStatus('current')
if mibBuilder.loadTexts: infoPoeInputVoltage.setDescription('The current PoE input voltage delivered from the power supply.')
infoPoeInputPower = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoPoeInputPower.setStatus('current')
if mibBuilder.loadTexts: infoPoeInputPower.setDescription('The current PoE input power delivered from the power supply.')
infoAlarmStateM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmOff", 2), ("alarmOn", 3), ("alarmOnLinkDown", 4), ("alarmOnForced", 5), ("alarmOffForced", 6), ("alarmOnPowerSupplyS1", 7), ("alarmOnPowerSupplyS2", 8), ("alarmOnPowerSupplyS1orS2", 9), ("alarmOnFunctionInputShorted", 10), ("alarmOnFunctionInputOpen", 11), ("alarmOnRemoteFunctionInput", 12), ("alarmOnRemoteAlarmDestTable", 13), ("alarmOnLocalAlarmDestTable", 14), ("alarmContactForcedShorted", 15), ("alarmContactForcedOpen", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoAlarmStateM1.setStatus('current')
if mibBuilder.loadTexts: infoAlarmStateM1.setDescription('The current state of the industrial alarm output M1.')
infoAlarmStateM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmOff", 2), ("alarmOn", 3), ("alarmOnLinkDown", 4), ("alarmOnForced", 5), ("alarmOffForced", 6), ("alarmOnPowerSupplyS1", 7), ("alarmOnPowerSupplyS2", 8), ("alarmOnPowerSupplyS1orS2", 9), ("alarmOnFunctionInputShorted", 10), ("alarmOnFunctionInputOpen", 11), ("alarmOnRemoteFunctionInput", 12), ("alarmOnRemoteAlarmDestTable", 13), ("alarmOnLocalAlarmDestTable", 14), ("alarmContactForcedShorted", 15), ("alarmContactForcedOpen", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoAlarmStateM2.setStatus('current')
if mibBuilder.loadTexts: infoAlarmStateM2.setDescription('The current state of the industrial alarm output M2.')
infoLastTftpMessage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastTftpMessage.setStatus('current')
if mibBuilder.loadTexts: infoLastTftpMessage.setDescription('The message of the last successful or failed TFTP transfer.\n\t\t This does not include TFTP transfers executed from Device Manager.')
infoLastSfpEventMessage = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastSfpEventMessage.setStatus('current')
if mibBuilder.loadTexts: infoLastSfpEventMessage.setDescription('The last event message from one of the available SFP modules.')
infoLastInternalMgmtWarning = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: infoLastInternalMgmtWarning.setStatus('current')
if mibBuilder.loadTexts: infoLastInternalMgmtWarning.setDescription('The last internal management warning message.')
infoFunctionInputStateF1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("functionInputShorted", 2), ("functionInputOpen", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoFunctionInputStateF1.setStatus('current')
if mibBuilder.loadTexts: infoFunctionInputStateF1.setDescription('The current state of the function input F1.')
infoTotalConfigChanges = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTotalConfigChanges.setStatus('current')
if mibBuilder.loadTexts: infoTotalConfigChanges.setDescription('The number of total configurations changes.')
adminReset = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("resetIdle", 1), ("resetCounters", 2), ("rebootSwitch", 3), ("rebootToFactoryDefaults", 4), ("renewIpAndVlanParameter", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminReset.setStatus('current')
if mibBuilder.loadTexts: adminReset.setDescription('Writing this object causes the switch to perform a reset operation.\n\t\tThe following reset types are supported.\n\t\t\tSet Values:\n\t\t\tresetCounters(2)\n\t\t\t\tThis action resets all error and statistic counters to zero.\n\t\t\t\tThis actions will NOT reboot the switch.\n\t\t\trebootSwitch(3)\n\t\t\t\tThis action resets switch and management. All counters, timers and other\n\t\t\t\tvolatile data are reset to there power-up values stored in flash.\n\t\t\t\tThis actions will reboot the switch.\n\t\t\trebootToFactoryDefaults(4)\n\t\t\t\tThis action resets switch and management. All volatile and nonvolatile data\n\t\t\t\tare reset to there power-up or factory default values.\n\t\t\t\tThis actions will reboot the switch.\n\t\t\trenewIpAndVlanParameter(5)\n\t\t\t\tThis action reinitializes the IP and VLAN module of the switch so that the \n\t\t\t\tactually set IP and VLAN parameters will take affect.\n\t\t\t\tThis actions will NOT reboot the switch.\n\t\t\tGet values:\n\t\t\tresetIdle(1)\n\t\t\t\tReading this object will allways return resetIdle(1).')
adminAgentDhcp = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentDhcp.setStatus('current')
if mibBuilder.loadTexts: adminAgentDhcp.setDescription('If set to enable(1), the switch tries to get his IP parameter\n\t\tvia DHCP. If set to disable(2), the switch uses the IP parameters\n\t\tdefined with adminIpAddress, adminDefRouterIpAddress and \n\t\tadminNetmask.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).')
adminAgentIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentIpAddress.setDescription("The IP address of the switch agent's ethernet interface.\n\t\tIf the value of adminDHCP is enable(1) this value is read-only.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).")
adminAgentPhysAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminAgentPhysAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentPhysAddress.setDescription('The Ethernet MAC address of the switch agent.')
adminAgentDefRouterIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentDefRouterIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentDefRouterIpAddress.setDescription('The IP address of the default Router.\n\t\tIf the value of adminDHCP is enable(1) this value is read-only.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).')
adminAgentNetmask = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentNetmask.setStatus('current')
if mibBuilder.loadTexts: adminAgentNetmask.setDescription('The IP Netmask of the connected network.\n\t\tIf the value of adminDHCP is enable(1) this value is read-only.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).')
adminAgentDhcpServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adminAgentDhcpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: adminAgentDhcpServerIpAddress.setDescription('The IP address of the last used DHCP server.')
adminAgentVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentVlanId.setStatus('current')
if mibBuilder.loadTexts: adminAgentVlanId.setDescription('The VLAN-ID assigned to the agent. \n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).')
adminAgentPrioValue = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAgentPrioValue.setStatus('current')
if mibBuilder.loadTexts: adminAgentPrioValue.setDescription('The IEEE802.1Q priority value and queue assigned to all frames transmitted\n\t\tby the agent.\n\t\tThe definition between value, service class and queue are as follows:\n\t\t0=Best Effort (queue=0),\n\t\t1=Background (queue=0),\n\t\t2=Reserved (queue=1),\n\t\t3=Excellent Effort (queue=1),\n\t\t4=Controlled Load (queue=2),\n\t\t5=Video (queue=2),\n\t\t6=Voice (queue=3),\n\t\t7=Network Control (queue=3)')
adminAddrAgingTimeMinutes = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 68)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAddrAgingTimeMinutes.setStatus('current')
if mibBuilder.loadTexts: adminAddrAgingTimeMinutes.setDescription('The timeout period in minutes for aging out dynamically\n\t\tlearned MAC addresses . The allowed range is 1 minute\n\t\tto 68 minutes.')
adminSwitchPortMirror = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchPortMirror.setStatus('current')
if mibBuilder.loadTexts: adminSwitchPortMirror.setDescription("If set to enable(1), the switch doesn't use address learning.\n\t\tThis affects that any received packet will be forwarded to all ports\n\t\tof the particular VLAN. The switch acts like a hub within each VLAN.")
adminMgmtAccessList = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disable", 1), ("enableForNexManAccess", 2), ("enableForAllAccess", 3), ("enableForSnmpAccess", 4))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminMgmtAccessList.setStatus('current')
if mibBuilder.loadTexts: adminMgmtAccessList.setDescription('If set to enableForNexManAccess(2) or enableForAllAccess(3), the\n\t\tswitch only accepts read or write requests from IP addresses which\n\t\tare listed in the management accesslist.')
adminSwitchPoEPowerLimit = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchPoEPowerLimit.setStatus('current')
if mibBuilder.loadTexts: adminSwitchPoEPowerLimit.setDescription('The limit for the POE input power from the power supply in VA.\n\t\tIf the current power exceeds this value a overload conditions occurs and \n\t\tthe inline power for the highest port number will be switched off.')
adminSwitchVlanTableMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("staticMode", 1), ("dynamicMode", 2), ("staticModeVlans64", 3), ("staticModePortBased", 4))).clone('staticMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSwitchVlanTableMode.setStatus('current')
if mibBuilder.loadTexts: adminSwitchVlanTableMode.setDescription("If set to staticMode(1) or staticModeVlans64(3) any existing VLAN table entry\n\t\tmust be removed manually by management. With staticMode(1) total 16 VLAN-ID's \n\t\tand with staticModeVlans64(3) total 64 VLAN-ID's are supported. \n\t\tIf set to dynamicMode(2) all unused VLAN-ID's are removed automatically by the \n\t\tswitch. This means, that all VLAN-ID's not assigned to a port Default-VLAND or \n\t\tto the Unsecure-VLAN will be removed.")
adminUnsecureVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminUnsecureVlanId.setStatus('current')
if mibBuilder.loadTexts: adminUnsecureVlanId.setDescription('The VLAN-ID of the unsecure VLAN')
adminDot1xAuthFailureVlanId = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminDot1xAuthFailureVlanId.setStatus('current')
if mibBuilder.loadTexts: adminDot1xAuthFailureVlanId.setDescription('The VLAN-ID in the case of an IEEE802.1X authentication failure.\n\t\t Setting the VLAN-ID to 0 disables the authentication failure VLAN.')
adminTftpAccess = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tftpAccessDisable", 1), ("tftpAccessReadOnly", 2), ("tftpAccessReadWrite", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminTftpAccess.setStatus('current')
if mibBuilder.loadTexts: adminTftpAccess.setDescription("If 'TFTP authentication via SNMP' is disabled, this value is allways\n\t\t tftpAccessDisable(1).\n                 If 'TFTP authentication via SNMP' is read/only or read/write, an this\n\t\t object is read, the value is tftpAccessReadOnly(2) and the agent allowes\n\t\t a single TFTP read access of the switch configuration.\n                 If 'TFTP authentication via SNMP' is read/write, this value can be set\n\t\t to tftpAccessReadWrite(3) and the agent allowes a single TFTP read or\n\t\t write access to the configuration or a single firmware upgrade.\n\t\t After finishing the TFTP transfer, this value will return to\n\t\t ftpAccessDisable(1) automatically.\n\t\t Note: If the 'NexMan authentication mode' is set to 'none',\n\t\t TFTP read and write access is allways allowed.")
adminSnmpMacTableMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("listAllPorts", 1), ("listUserPortsOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminSnmpMacTableMode.setStatus('current')
if mibBuilder.loadTexts: adminSnmpMacTableMode.setDescription('If set to listAllPorts(1) the BRIDGE-MIBs dot1dTpFdbTable lits MAC address\n\t\t of all ports.\n\t\t If set to listUserPortsOnly(2) the BRIDGE-MIBs dot1dTpFdbTable lits only \n\t\t MAC addresses of user ports. MAC addresses of uplink/downlink ports\n\t\t are ignored.')
adminAlarmM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmLinkDown", 2), ("alarmOnForced", 3), ("alarmOffForced", 4), ("alarmPowerSupply1Failure", 5), ("alarmPowerSupply2Failure", 6), ("alarmPowerSupply1or2Failure", 7), ("alarmLocalFunctionInputShorted", 8), ("alarmLocalFunctionInputOpen", 9), ("alarmRemoteFunctionInput", 10), ("alarmRemoteAlarmDestination", 11), ("alarmLocalAlarmDestination", 12), ("alarmForceContactShorted", 13), ("alarmForceContactOpen", 14), ("alarmForceContactOpenShorted", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmM1.setStatus('current')
if mibBuilder.loadTexts: adminAlarmM1.setDescription('The current setup of the industrial alarm output M1.')
adminAlarmM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notSupported", 1), ("alarmLinkDown", 2), ("alarmOnForced", 3), ("alarmOffForced", 4), ("alarmPowerSupply1Failure", 5), ("alarmPowerSupply2Failure", 6), ("alarmPowerSupply1or2Failure", 7), ("alarmLocalFunctionInputShorted", 8), ("alarmLocalFunctionInputOpen", 9), ("alarmRemoteFunctionInput", 10), ("alarmRemoteAlarmDestination", 11), ("alarmLocalAlarmDestination", 12), ("alarmForceContactShorted", 13), ("alarmForceContactOpen", 14), ("alarmForceContactOpenShorted", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmM2.setStatus('current')
if mibBuilder.loadTexts: adminAlarmM2.setDescription('The current setup of the industrial alarm output M2.')
adminMemoryCardMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("mcEnabled", 2), ("mcDisabled", 3), ("mcPermanentDisabled", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminMemoryCardMode.setStatus('current')
if mibBuilder.loadTexts: adminMemoryCardMode.setDescription("If set to mcDisabled(2), the memory card is disabled but may\n\t\t be re-enabled later by writing mcEnabled(1).\n\t\t If set to mcPermanentDisabled(3), the memory card is disabled \n\t\t permanently and can't be re-enabled by management or any\n\t\t kind of hardware reset.")
adminAlarmNameM1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmNameM1.setStatus('current')
if mibBuilder.loadTexts: adminAlarmNameM1.setDescription('An administratively assigned name for alarm output M1.\n\t\t The configured name will be send as part of alarm message\n\t\t switchIndustrialAlarmM1.')
adminAlarmNameM2 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminAlarmNameM2.setStatus('current')
if mibBuilder.loadTexts: adminAlarmNameM2.setDescription('An administratively assigned name for alarm output M1.\n\t\t The configured name will be send as part of alarm message\n\t\t switchIndustrialAlarmM2.')
adminFunctionInputNameF1 = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('not defined')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminFunctionInputNameF1.setStatus('current')
if mibBuilder.loadTexts: adminFunctionInputNameF1.setDescription('An administratively assigned name for function input F1.\n\t\t The configured name will be send as part of alarm message\n\t\t switchFunctionInputAlarm.')
adminLedGlobalMode = MibScalar((1, 3, 6, 1, 4, 1, 266, 20, 2, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ledGlobalModeNotSupported", 1), ("ledGlobalModeStandard", 2), ("ledGlobalModeAllOff", 3), ("ledGlobalModeAllOn", 4), ("ledGlobalModeMgmtOnly", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: adminLedGlobalMode.setStatus('current')
if mibBuilder.loadTexts: adminLedGlobalMode.setDescription('Set the global mode for all front side LEDs.')
bmSwitchPortTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 3, 1), )
if mibBuilder.loadTexts: bmSwitchPortTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchPortTable.setDescription('A list of port entries for the switch.\tThe number of\n\t\tentries is defined by ifNumber.')
bmSwitchPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "portIndex"))
if mibBuilder.loadTexts: bmSwitchPortEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchPortEntry.setDescription('A port entry in the table containing information about a\n\t\tport in the switch.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('current')
if mibBuilder.loadTexts: portIndex.setDescription('A unique value for each port.  Its value ranges between 1\n\t\tand the value of ifNumber.\n\t\tThe port identified by a particular value of this index is\n\t\tthe same port as identified by the same value of ifIndex.')
portDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDescr.setStatus('current')
if mibBuilder.loadTexts: portDescr.setDescription('A textual string containing information about the\n\t\tinterface. Same as ifDescr.')
portName = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portName.setStatus('current')
if mibBuilder.loadTexts: portName.setDescription('An administratively assigned name for this port.')
portAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("allwaysEnable", 1), ("enable", 2), ("adminDisable", 3), ("securityDisable", 4), ("loopDisable", 5), ("bpduDisable", 6), ("udldDisable", 7), ("linkFlapDisable", 8), ("errorCountDisable", 9), ("sfpErrorDisable", 10), ("redundanyLoopDisable", 11)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminState.setStatus('current')
if mibBuilder.loadTexts: portAdminState.setDescription('A value indicating the current state of the port.\n\t\tA SET to this object enables (2) or disables (3) the port.\n\t\t\tThe possible values returned by GET are:\n\t\t\tallwaysEnable(1)\n\t\t\t\tThe port is always enabled (usually the uplink port).\n\t\t\tenable(2)\n\t\t\t\tThe port is active to transmit or receive data.\n\t\t\tdisable(3)\n\t\t\t\tThe port is inactive and unable to transmit or receive data.\n\t\t\tsecurityDisable(4)\n\t\t\t\tThe port has been automatically disabled because of security \n\t\t\t\tviolation.\n\t\t\tloopDisable(5)\n\t\t\t\tThe port has been automatically disabled because of the\n\t\t\t\tactive loop protection.\n\t\t\tbpduDisable(6)\n\t\t\t\tThe port has been automatically disabled because a BPDU has been \n\t\t\t\treceived on a Spanning Tree disabled port.\n\t\t\tudldDisable(7)\n\t\t\t\tThe port has been automatically disabled because of the\n\t\t\t\tUDLD function.\n\t\t\tlinkFlapDisable(8)\n\t\t\t\tThe port has been automatically disabled because of the\n\t\t\t\tlink flap protection.\n\t\t\terrorCountDisable(9)\n\t\t\t\tThe port has been automatically disabled because of the\n\t\t\t\terror counter incrementation detection.\n\t\t\tsfpErrorDisable(10)\n\t\t\t\tThe port has been automatically disabled because of wromg\n\t\t\t\tSFP inserted or SFP malfunction.\n\t\t\tredundanyLoopDisable(11)\n\t\t\t\tThe port has been automatically disabled because of loop\n\t\t\t\tdetection while spannung tree was enabled')
portSpeedDuplexSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("autoneg", 1), ("fix10Hdx", 2), ("fix10Fdx", 3), ("fix100Hdx", 4), ("fix100Fdx", 5), ("fix1000Hdx", 7), ("fix1000Fdx", 8), ("eco", 9), ("ecoOverTemp", 10), ("ecoPowerSave", 11), ("fix1000fdxNoAutoneg", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSpeedDuplexSetup.setStatus('current')
if mibBuilder.loadTexts: portSpeedDuplexSetup.setDescription('A value indicating the current speed and duplex link setup.\n\t\tIndependent of portSpeedDuplexSetup the port may be disabled\n\t\tby portAdminState.')
portLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("up10Hdx", 2), ("up10Fdx", 3), ("up100Hdx", 4), ("up100Fdx", 5), ("up1000Hdx", 6), ("up1000Fdx", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkState.setStatus('current')
if mibBuilder.loadTexts: portLinkState.setDescription('A value indicating the current link state.')
portErrorCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrorCounter.setStatus('current')
if mibBuilder.loadTexts: portErrorCounter.setDescription('Errors are usually caused by a FDX/HDX mismatch between the switch port\n\t\tand the connected port. If the switch detects a incrementation of this\n\t\tcounter, he will send a portErrorCountFailure trap.\n\t\tThe counted errors are depending on the switch type.\n\t\tFor BM-A, BM+ and Access Switches:\n\t        - Received packets with bad CRC,\n\t        - Received packets with bad alignment,\n\t        - Late collisions (only valid if Link State is 10HDX or 100HDX).\n\t      For old BM Switches:\n\t        - Received packets with bad CRC')
portRemoteFault = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRemoteFault.setStatus('current')
if mibBuilder.loadTexts: portRemoteFault.setDescription('If portRemoteFault is enabled for this port, the port transmitter will\n\t\tbe only enabled if the port receiver has a valid link (portLinkState must\n\t\tnot be down).')
portDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: portDefaultVlanId.setDescription('The Default-VLAN-ID assigned to this port.\n\t\tThis Default-VLAN-ID has differnt affects depending on received\n\t\tor transmited frames:\n\t\ta) All received frames, which have no VLAN-tag, will\n\t\t\tbe assigned to the Default-VLAN-ID.\n\t\tb) All transmited frames, which belong to the Default-VLAN,\n\t\t\tare send without a VLAN-tag.\n\t\tIf portTrunkingMode is set to dot1qTagging, all frames are transmited\n\t\twith a VLAN-tag, except frames which belong to the Default-VLAN-ID.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).\n\t\tSetting this value to 0 for a port with dot1qTagging will disable the\n\t\tDefault-VLAN. This means, that all frames are send tagged.')
portTrunkingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1qTagging", 1), ("disable", 2), ("enableWithoutTagging", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrunkingMode.setStatus('current')
if mibBuilder.loadTexts: portTrunkingMode.setDescription('If portTrunkingMode is set to dot1qTagging, all frames are transmited\n\t\twith a VLAN-tag, except frames which belong to portNativeVlanId. \n\t\tIf portTrunkingMode is set to enableWithoutTagging, all frames are transmited\n\t\twithout a VLAN-tag. \n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).')
portDot1qDefaultPrioValue = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDot1qDefaultPrioValue.setStatus('current')
if mibBuilder.loadTexts: portDot1qDefaultPrioValue.setDescription('The default IEEE802.1Q priority and queue assigned all frames received\n\t\ton this port, for which no other priorisation applies (IEEE801.1q Tag or \n\t\tIPv4/IPv6). \n\t\tThe definition between value, service class and queue are as follows:\n\t\t0=Best Effort (queue=0),\n\t\t1=Background (queue=0),\n\t\t2=Reserved (queue=1),\n\t\t3=Excellent Effort (queue=1),\n\t\t4=Controlled Load (queue=2),\n\t\t5=Video (queue=2),\n\t\t6=Voice (queue=3),\n\t\t7=Network Control (queue=3)')
portDefaultPrioQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDefaultPrioQueue.setStatus('current')
if mibBuilder.loadTexts: portDefaultPrioQueue.setDescription('The default priority queue assigned all frames received on this port,\n\t\tfor which no other priorisation applies (IEEE801.1q Tag or IPv4/IPv6). \n\t\tA value of 0 means the lowest priority level.\n\t\tA value of 3 means the highest priority level.\n\t\tTo change this default queue use object portDot1qDefaultPrioValue.')
portLEDGreen = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("showLinkState", 2), ("blink", 3), ("allwaysOff", 4), ("allwaysOn", 5), ("showLinkSpeedDuplex", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLEDGreen.setStatus('current')
if mibBuilder.loadTexts: portLEDGreen.setDescription('The function of the green port LED. Only supported for user ports')
portLEDYellow = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("showDuplexState", 2), ("blink", 3), ("allwaysOff", 4), ("allwaysOn", 5), ("showPoeEnabled", 6), ("showSpeed", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLEDYellow.setStatus('current')
if mibBuilder.loadTexts: portLEDYellow.setDescription('The function of the yellow port LED. Only supported for user ports')
portBandwidthLimitRxd = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("limit128k", 3), ("limit256k", 4), ("limit512k", 5), ("limit1M", 6), ("limit2M", 7), ("limit4M", 8), ("limit8M", 9), ("limit16M", 10), ("limit32M", 11), ("limit64M", 12), ("limit128M", 13), ("limit256M", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBandwidthLimitRxd.setStatus('current')
if mibBuilder.loadTexts: portBandwidthLimitRxd.setDescription('The bandwidth limiter for received packets. If set to disable(2) the\n\t\tlimiter will be disabled.')
portBandwidthLimitTxd = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("limit128k", 3), ("limit256k", 4), ("limit512k", 5), ("limit1M", 6), ("limit2M", 7), ("limit4M", 8), ("limit8M", 9), ("limit16M", 10), ("limit32M", 11), ("limit64M", 12), ("limit128M", 13), ("limit256M", 14)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portBandwidthLimitTxd.setStatus('current')
if mibBuilder.loadTexts: portBandwidthLimitTxd.setDescription('The bandwidth limiter for transmitted packets. If set to disable(2) the\n\t\tlimiter will be disabled.')
portSecurityAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("notSupported", 1), ("disable", 2), ("manualSettingMacAddr", 3), ("autoAllowOneMacAddr", 4), ("autoAllowTwoMacAddr", 5), ("autoAllowThreeMacAddr", 6), ("radiusAllowOneMacAddr", 7), ("radiusAllowTwoMacAddr", 8), ("radiusAllowThreeMacAddr", 9), ("renew", 10), ("ieee802AllowOneMacAddr", 11), ("vendorSettingMacAddr", 12), ("ieee802AllowMultiMacAddr", 13), ("ieee802OrRadiusOneMac", 14), ("ieee802AndRadiusTwoMac", 15), ("learnOneMacAddr", 16), ("learnTwoMacAddr", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityAdminState.setStatus('current')
if mibBuilder.loadTexts: portSecurityAdminState.setDescription('Enables the port security feature for that port. \n\t\t A value of notSupported(1) means, that port security ist not supported or \n\t\t disabled for that port (i.e. uplink port). The command renew(10) clears\n\t\t all learned MAC addresses and enables the port if it is disabled.\n\t\t See documentation for more details.')
portSecurityMacAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 18), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr1.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr1.setDescription('The first MAC address used for port security.\n\t\tIf portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3)\n\t\tor vendorSettingMacAddr(12) then this object will be read-write.\n\t\tIn any other mode this object will be read-only and shows the first automatically\n\t\tlearned MAC addresses for that port.')
portSecurityMacAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 19), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr2.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr2.setDescription('The second MAC address used for port security.\n\t\tIf portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3)\n\t\tor vendorSettingMacAddr(12) then this object will be read-write.\n\t\tIn any other mode this object will be read-only and shows the second automatically\n\t\tlearned MAC addresses for that port.')
portSecurityMacAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 20), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMacAddr3.setStatus('current')
if mibBuilder.loadTexts: portSecurityMacAddr3.setDescription('The third MAC address used for port security.\n\t\tIf portSecurityAdminState has the value disable(2), portSecurityManualSettingMacAddr(3)\n\t\tor vendorSettingMacAddr(12) then this object will be read-write.\n\t\tIn any other mode this object will be read-only and shows the third automatically\n\t\tlearned MAC addresses for that port.')
portPoeAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("forcedOn", 3), ("autoOn", 4), ("overloadFail", 5), ("reset", 6), ("afHighPower", 7), ("atHighPower", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPoeAdminState.setStatus('current')
if mibBuilder.loadTexts: portPoeAdminState.setDescription('If no POE adapter is installed this object is read-only and will always\n\t\treport notSupported(1). The possible values are:\n\t\t\tnotSupported(1):\n\t\t\t\tNo adapter installed or not supported for that port (i.e. uplink port).\n\t\t\toff(2):\n\t\t\t\tAdapter installed but inline power for that port is switched off.\n\t\t\tforcedOn(3):\n\t\t\t\tAdapter installed and inline power is asserted permanently. In the case\n\t\t\t\tof an IEEE802.3af adapter this setting will disable the IEEE802.3af automatic\n\t\t\t\tdetection.\n\t\t\tautoOn(4):\n\t\t\t\tThis setting is only supported if a IEEE802.3af adapter is installed.\n\t\t\t\tThe adapter automatically detects if the connected device\n\t\t\t\tis IEEE802.3af compliant and will assert the power if possible.\n\t\t\toverloadFail(5):\n\t\t\t\tAdapter installed but inline power for that port is automatically\n\t\t\t\tswitched off because of a overload condition at that port.')
portPoeVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoeVoltage.setStatus('current')
if mibBuilder.loadTexts: portPoeVoltage.setDescription('The current PoE output voltage at this port in volts.')
portPoeCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoeCurrent.setStatus('current')
if mibBuilder.loadTexts: portPoeCurrent.setDescription('The current PoE output current at this port in milliampere.')
portPoePower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPoePower.setStatus('current')
if mibBuilder.loadTexts: portPoePower.setDescription('The current PoE output power at this port in milliwatt. The output\n\t\tpower is the product of portPoeVoltage and portPoeCurrent.')
portSecurityForwardingState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("notSupported", 1), ("portAdminDisabled", 2), ("waitingForLink", 3), ("unsecureVLAN", 4), ("portAuthenticated", 5), ("portSecurityDisabled", 6), ("portLoopDisabled", 7), ("authFailureVLAN", 8), ("securityWarning", 9), ("authenticatingClients", 10), ("waitingForMacAddress", 11), ("allRadiusServersDown", 12), ("portBpduDisabled", 13), ("portUdldDisabled", 14), ("portLinkFlapDisabled", 15), ("portErrorCountDisabled", 16), ("portSfpErrorDisabled", 17), ("portRedundanyLoopDisable", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityForwardingState.setStatus('current')
if mibBuilder.loadTexts: portSecurityForwardingState.setDescription('The port security forwarding state of that port.\n\t\t See documentation for details.')
portPoePowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPoePowerLimit.setStatus('current')
if mibBuilder.loadTexts: portPoePowerLimit.setDescription('The limit for the POE output power at this port in VA. If the\n\t\tcurrent power exceeds this value a overload conditions occurs and \n\t\tthe inline power for that port will be switched off.')
portLimiterPacketType = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("limitAllPackets", 2), ("limitLoopBcastPackets", 3), ("limitAllPacketsBurstsAllowed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLimiterPacketType.setStatus('current')
if mibBuilder.loadTexts: portLimiterPacketType.setDescription('The packet type for bandwidth limiter. If set to limitAllPacktes(2)\n\t\tthen all packets are limited. If set to limitLoppBcastPackets(3) only\n\t\tflooted loop- and broadcast-pakets are limited.')
portAcApSetup = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("allwaysEnable", 2), ("enable", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAcApSetup.setStatus('current')
if mibBuilder.loadTexts: portAcApSetup.setDescription('If portAcApSetup is enabled, the switch will perform Autocrossover\n\t\tand Autopolarity for this port. This function should only be enabled\n\t\tif portSpeedDuplexSetup ist set to autoneg.')
portLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("user", 1), ("userWithLoopProtection", 2), ("upDownlink", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portLinkType.setStatus('current')
if mibBuilder.loadTexts: portLinkType.setDescription('The link type of that port. If set to upDownlink(3) the portAdminState \n\t\t will be forced to enable.')
portVoiceVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portVoiceVlanId.setStatus('current')
if mibBuilder.loadTexts: portVoiceVlanId.setDescription('The Voide-VLAN-ID assigned to this port.\n\t\tPackets of this Voice-VLAN are allway send with a VLAN-Tag, because\n\t\tIP-Phones normaly need a tagged VLAN.\n\t\tIf portTrunkingMode is set to dot1qTagging, ALL frames are transmited\n\t\twith a VLAN-tag, except frames which belong to the Default-VLAN-ID. In\n\t\tthis case the Voice-VLAN-ID has no effect.\n\t\tChanges of this value will take affect after the next switch reboot or\n\t\tafter setting adminReset to renewIpAndVlanParameter(5).\n\t\tSetting this value to 0 will disable the Voice-VLAN.')
portPrioDot1p = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prioDot1pDisabled", 1), ("prioDot1pEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPrioDot1p.setStatus('current')
if mibBuilder.loadTexts: portPrioDot1p.setDescription('Defines whether port prioritisation for IEEE802.1p packets is enabled.')
portPrioIp = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("prioIpDisabled", 1), ("prioIpEnabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portPrioIp.setStatus('current')
if mibBuilder.loadTexts: portPrioIp.setDescription('Defines whether port prioritisation for IPv4/IPv6 packets is enabled.')
bmSwitchVlanTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 4, 1), )
if mibBuilder.loadTexts: bmSwitchVlanTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchVlanTable.setDescription('A list of Virtual LAN instances.')
bmSwitchVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "vlanIndex"))
if mibBuilder.loadTexts: bmSwitchVlanEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchVlanEntry.setDescription('VLAN entry.')
vlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanIndex.setStatus('current')
if mibBuilder.loadTexts: vlanIndex.setDescription('A unique value for each VLAN entry. Its value ranges between 1 and 16.')
vlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanId.setStatus('current')
if mibBuilder.loadTexts: vlanId.setDescription("The VLAN-ID assigned to this entry. Only entries with a VLAN-ID greater\n\t\tthen 0 are valid entries.\n\t\tSetting a valid VLAN-ID to 0 will disable that entry and also delete the\n\t\tvlanDescr\n\t\tTo add a new VLAN-ID first set an valid or non valid entry to the\n\t\tdesired\tVLAN-ID. In a second step you may set the vlanDescr.\n\t\tOnly VLAN-ID's listed in the vlanTable are forwarded by the switch.")
vlanDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanDescr.setStatus('current')
if mibBuilder.loadTexts: vlanDescr.setDescription('A textual string containing information about the VLAN.')
bmSwitchSfpTable = MibTable((1, 3, 6, 1, 4, 1, 266, 20, 5, 1), )
if mibBuilder.loadTexts: bmSwitchSfpTable.setStatus('current')
if mibBuilder.loadTexts: bmSwitchSfpTable.setDescription('A list of SFP entries for the switch. The number of\n\t\t entries is defined by ifNumber.')
bmSwitchSfpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1), ).setIndexNames((0, "NEXANS-BM-MIB", "sfpPortIndex"))
if mibBuilder.loadTexts: bmSwitchSfpEntry.setStatus('current')
if mibBuilder.loadTexts: bmSwitchSfpEntry.setDescription('A SFP entry in the table containing information about a\n\t\tSFP in the switch.')
sfpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpPortIndex.setStatus('current')
if mibBuilder.loadTexts: sfpPortIndex.setDescription('A unique value for each port. Its value ranges between 1\n\t\tand the value of ifNumber.\n\t\tThe port identified by a particular value of this index is\n\t\tthe same port as identified by the same value of ifIndex.')
sfpState = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("noSfpInserted", 2), ("validSfpNoDiagnostic", 3), ("validSfpWithDiagnostic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpState.setStatus('current')
if mibBuilder.loadTexts: sfpState.setDescription("A value indicating the current state of the SFP module.\n\t\tThe possible values returned are:\n\t\tnotSupported(1)\n\t\t\tThe port has no SFP slot.\n\t\tnoSfpInserted(2)\n\t\t\tThe port has a SFP slot but there is no valid SFP module inserted.\n\t\tvalidSfpNoDiagnostic(3)\n\t\t\tA valid SFP module is inserted but the module doesn't supports \n\t\t\tdiagnostic values.\n\t\tvalidSfpWithDiagnostic(4)\n\t\t\tA valid SFP module which supports diagnostic is inserted.")
sfpInfoVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoVendorName.setStatus('current')
if mibBuilder.loadTexts: sfpInfoVendorName.setDescription('A textual string containing the vendor name of the SFP module.')
sfpInfoPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoPartNumber.setDescription('A textual string containing the part number of the SFP module.')
sfpInfoRevisionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoRevisionNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoRevisionNumber.setDescription('A textual string containing the revision number of the SFP module.')
sfpInfoSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: sfpInfoSerialNumber.setDescription('A textual string containing the serial number \tof the SFP module.')
sfpInfoDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoDateCode.setStatus('current')
if mibBuilder.loadTexts: sfpInfoDateCode.setDescription('A textual string containing the date code of the SFP module.')
sfpInfoBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoBitRate.setStatus('current')
if mibBuilder.loadTexts: sfpInfoBitRate.setDescription('A textual string containing the bit rate of the SFP module.\n\t\tThe unit is Mbit/s')
sfpInfoWavelength = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoWavelength.setStatus('current')
if mibBuilder.loadTexts: sfpInfoWavelength.setDescription('A textual string containing the wavelength of the SFP module.\n\t\tThe unit is nm.')
sfpInfoLength9um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength9um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength9um.setDescription('A textual string containing the typically supported\n\t\tfiber length for 9um fiber cable. The unit is meters.')
sfpInfoLength50um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength50um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength50um.setDescription('A textual string containing the typically supported\n\t\tfiber length for 50um fiber cable. The unit is meters.')
sfpInfoLength62um = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoLength62um.setStatus('current')
if mibBuilder.loadTexts: sfpInfoLength62um.setDescription('A textual string containing the typically supported\n\t\tfiber length for 62.5um fiber cable. The unit is meters.')
sfpInfoConnectorDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpInfoConnectorDescr.setStatus('current')
if mibBuilder.loadTexts: sfpInfoConnectorDescr.setDescription('A textual string containing the connector description\n\t\tof the SFP module.')
sfpDiagTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTemperature.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTemperature.setDescription('The current temperature of the SFP module in degree celsius.')
sfpDiagSupplyVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagSupplyVoltage.setStatus('current')
if mibBuilder.loadTexts: sfpDiagSupplyVoltage.setDescription('The current supply voltage of the SFP module in millivolt.')
sfpDiagTxBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxBiasCurrent.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxBiasCurrent.setDescription('The current transmitter bias current of the SFP module in milliampere.')
sfpDiagTxOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxOutputPower.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxOutputPower.setDescription('The current transmitter output power of the SFP module in microwatt.')
sfpDiagTxOutputPowerDbm = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagTxOutputPowerDbm.setStatus('current')
if mibBuilder.loadTexts: sfpDiagTxOutputPowerDbm.setDescription('The current transmitter output power of the SFP module in dbm.')
sfpDiagRxIntputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagRxIntputPower.setStatus('current')
if mibBuilder.loadTexts: sfpDiagRxIntputPower.setDescription('The current receiver input power of the SFP module in microwatt.')
sfpDiagRxInputPowerDbm = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfpDiagRxInputPowerDbm.setStatus('current')
if mibBuilder.loadTexts: sfpDiagRxInputPowerDbm.setDescription('The current receiver input power of the SFP module in dbm.')
sfpAlarmTxBiasCurrentUpperLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmTxBiasCurrentUpperLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmTxBiasCurrentUpperLimit.setDescription('The maximum allowed transmitter bias current in milliampere.\n\t\tIf the current value indicated by sfpDiagTxBiasCurrent\n\t\texceeds sfpAlarmTxBiasCurrentUpperLimit, the switch sends an \n\t\tsfpEvent alarm trap.\n\t\tIf the value of this limit is 0 no alarm will be send.')
sfpAlarmTxOutputPowerLowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmTxOutputPowerLowerLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmTxOutputPowerLowerLimit.setDescription('The minimum required transmitter output power in microwatt.\n\t\tIf the power value indicated by sfpDiagTxOutputPower\n\t\tfalls below sfpAlarmTxOutputPowerLowerLimit, the switch sends an \n\t\tsfpEvent alarm trap.\n\t\tIf the value of this limit is 0 no alarm will be send.')
sfpAlarmRxInputPowerLowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 266, 20, 5, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfpAlarmRxInputPowerLowerLimit.setStatus('current')
if mibBuilder.loadTexts: sfpAlarmRxInputPowerLowerLimit.setDescription('The minimum required received input power in microwatt.\n\t\tIf the power value indicated by sfpDiagRxInputPower\n\t\tfalls below sfpAlarmRxInputPowerLowerLimit, the switch sends an \n\t\tsfpEvent alarm trap.\n\t\tIf the value of this limit is 0 no alarm will be send.')
switchTemperatureFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 1)).setObjects(("NEXANS-BM-MIB", "infoTemperature"))
if mibBuilder.loadTexts: switchTemperatureFailure.setStatus('current')
if mibBuilder.loadTexts: switchTemperatureFailure.setDescription('A TemperatureFailure signifies that the switch hardware\n\t\t\thas detected under- or overtemperature condition.')
portLinkChange = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 2)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portLinkState"))
if mibBuilder.loadTexts: portLinkChange.setStatus('current')
if mibBuilder.loadTexts: portLinkChange.setDescription('The trap is sent whenever the link state of a port changes\n\t\t\tfrom link-up to link-down or from link-down to link-up')
portNewMacAddress = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 3)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoNewMacAddr"))
if mibBuilder.loadTexts: portNewMacAddress.setStatus('current')
if mibBuilder.loadTexts: portNewMacAddress.setDescription('A new source MAC address has been detected on a switch port. This trap is only\n\t\t\tsend for ports which have port-security enabled with the setting \n\t\t\tautoAllowOneMacAddr, autoAllowTwoMacAddr or autoAllowThreeMacAddr.')
portSecurityFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 4)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoSecurityFailMacAddr"))
if mibBuilder.loadTexts: portSecurityFailure.setStatus('current')
if mibBuilder.loadTexts: portSecurityFailure.setDescription('An unauthorized source MAC address has accessed a port which has port-security\n\t\t\tenabled.')
portErrorCountFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 5)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portErrorCounter"))
if mibBuilder.loadTexts: portErrorCountFailure.setStatus('current')
if mibBuilder.loadTexts: portErrorCountFailure.setDescription('The port error counter has incremented by 2 or more within a timewindow of\n\t\t\ttwo seconds. An counter increment by 1 ist not reported because single increments\n\t\t\toften may result because of link-changes.')
switchMgmtAuthFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 6)).setObjects(("NEXANS-BM-MIB", "infoUnauthIpAddr"))
if mibBuilder.loadTexts: switchMgmtAuthFailure.setStatus('current')
if mibBuilder.loadTexts: switchMgmtAuthFailure.setDescription('A station has tried to access the switch management with a wrong \n\t\t\tauthentication. This includes wrong user/password for telnet, wrong\n\t\t\tcommunity for SNMP read/write and wrong accessrights in the accesslist.')
radiusMgmtAuthReject = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 7)).setObjects(("NEXANS-BM-MIB", "infoUnauthIpAddr"))
if mibBuilder.loadTexts: radiusMgmtAuthReject.setStatus('current')
if mibBuilder.loadTexts: radiusMgmtAuthReject.setDescription('A station has tried to access the switch management with radius  \n\t\t\tauthentication enabled and the radius server has rejected the request.')
radiusPortSecurityReject = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 8)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoSecurityFailMacAddr"))
if mibBuilder.loadTexts: radiusPortSecurityReject.setStatus('current')
if mibBuilder.loadTexts: radiusPortSecurityReject.setDescription('A station has tried to access the switch with radius port security   \n\t\t\tauthentication enabled and the radius server has rejected the request.')
portLoopBcastFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 9)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: portLoopBcastFailure.setStatus('current')
if mibBuilder.loadTexts: portLoopBcastFailure.setDescription('The port broadcast/multicast counter has incremented by 25 packets/second for \n\t\t\tmore then 10 successive seconds. Excessive multicast or broadcast packets may\n\t\t\tresult in case of a loop between two port of the switch.')
switchPoeVoltageFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 10)).setObjects(("NEXANS-BM-MIB", "infoPoeInputVoltage"))
if mibBuilder.loadTexts: switchPoeVoltageFailure.setStatus('current')
if mibBuilder.loadTexts: switchPoeVoltageFailure.setDescription('The switch has detected a PoE over- or undervoltage conditions.')
switchPoeOverloadFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 11)).setObjects(("NEXANS-BM-MIB", "infoPoeInputPower"))
if mibBuilder.loadTexts: switchPoeOverloadFailure.setStatus('current')
if mibBuilder.loadTexts: switchPoeOverloadFailure.setDescription('The switch has detected a overload for the PoE power supply.')
portPoeOverloadFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 12)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portPoePower"))
if mibBuilder.loadTexts: portPoeOverloadFailure.setStatus('current')
if mibBuilder.loadTexts: portPoeOverloadFailure.setDescription('The switch has detected a PoE overload condition at the port.')
portActiveLoopDetectionFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 13)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: portActiveLoopDetectionFailure.setStatus('current')
if mibBuilder.loadTexts: portActiveLoopDetectionFailure.setDescription('The active loop protection has disabled the port.')
switchIndustrialAlarmM1 = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 14)).setObjects(("NEXANS-BM-MIB", "infoAlarmStateM1"), ("NEXANS-BM-MIB", "adminAlarmNameM1"))
if mibBuilder.loadTexts: switchIndustrialAlarmM1.setStatus('current')
if mibBuilder.loadTexts: switchIndustrialAlarmM1.setDescription('The alarm state of the industrial alarm output M1 has changed.')
switchIndustrialAlarmM2 = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 15)).setObjects(("NEXANS-BM-MIB", "infoAlarmStateM2"), ("NEXANS-BM-MIB", "adminAlarmNameM2"))
if mibBuilder.loadTexts: switchIndustrialAlarmM2.setStatus('current')
if mibBuilder.loadTexts: switchIndustrialAlarmM2.setDescription('The alarm state of the industrial alarm output M2 has changed.')
switchInternalVoltageFailure = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 16)).setObjects(("NEXANS-BM-MIB", "infoPowerVoltage2500"), ("NEXANS-BM-MIB", "infoPowerVoltage3300"))
if mibBuilder.loadTexts: switchInternalVoltageFailure.setStatus('current')
if mibBuilder.loadTexts: switchInternalVoltageFailure.setDescription('The switch has detected a internal over- or undervoltage conditions.')
tftpMessage = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 17)).setObjects(("NEXANS-BM-MIB", "infoLastTftpMessage"))
if mibBuilder.loadTexts: tftpMessage.setStatus('current')
if mibBuilder.loadTexts: tftpMessage.setDescription('An successful or failed TFTP transfer has been occured.\n\t\t\t This does not include TFTP transfers executed from Nexan Manager.')
sfpEvent = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 18)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "infoLastSfpEventMessage"))
if mibBuilder.loadTexts: sfpEvent.setStatus('current')
if mibBuilder.loadTexts: sfpEvent.setDescription('The switch has detected one of the following SFP events:\n\t\t\t- a SFP module has been inserted\n\t\t\t- a SFP module has been removed\n\t\t\t- the optical receive power has fallen below the configured threshold\n\t\t\t- the optical transmit power has fallen below the configured threshold\n\t\t\t- the laser bias current has exceeded the configured threshold\n\t\t\tIn the case of a threshold event, the trap will only send out every\n\t\t\tfive minutes.')
clientRemoved = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 19)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"))
if mibBuilder.loadTexts: clientRemoved.setStatus('current')
if mibBuilder.loadTexts: clientRemoved.setDescription("The client on this port has been removed because the link down time\n\t\t\t has exceeded the configured 'Link Down Timeout'.")
internalMgmtWarning = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 20)).setObjects(("NEXANS-BM-MIB", "infoLastInternalMgmtWarning"))
if mibBuilder.loadTexts: internalMgmtWarning.setStatus('current')
if mibBuilder.loadTexts: internalMgmtWarning.setDescription('An internal management warning has been detected. Please consult \n\t\t\t Nexans for further informations regarding the reported warning code.')
switchFunctionInputAlarm = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 21)).setObjects(("NEXANS-BM-MIB", "infoFunctionInputStateF1"), ("NEXANS-BM-MIB", "adminFunctionInputNameF1"))
if mibBuilder.loadTexts: switchFunctionInputAlarm.setStatus('current')
if mibBuilder.loadTexts: switchFunctionInputAlarm.setDescription('The state of the function input has changed.')
switchConfigurationChanged = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 22)).setObjects(("NEXANS-BM-MIB", "infoTotalConfigChanges"))
if mibBuilder.loadTexts: switchConfigurationChanged.setStatus('current')
if mibBuilder.loadTexts: switchConfigurationChanged.setDescription('The configuration of the switch has been changed.')
portErrorDisabled = NotificationType((1, 3, 6, 1, 4, 1, 266, 20, 0, 23)).setObjects(("NEXANS-BM-MIB", "portIndex"), ("NEXANS-BM-MIB", "portDescr"), ("NEXANS-BM-MIB", "portName"), ("NEXANS-BM-MIB", "portAdminState"))
if mibBuilder.loadTexts: portErrorDisabled.setStatus('current')
if mibBuilder.loadTexts: portErrorDisabled.setDescription('The port has been error disabled.')
mibBuilder.exportSymbols("NEXANS-BM-MIB", switchPoeOverloadFailure=switchPoeOverloadFailure, infoTemperatureMaxAllowed=infoTemperatureMaxAllowed, portDefaultVlanId=portDefaultVlanId, portLinkType=portLinkType, portIndex=portIndex, portRemoteFault=portRemoteFault, infoProductNo=infoProductNo, infoMgmtFirmwareVersion=infoMgmtFirmwareVersion, infoPowerVoltage3300=infoPowerVoltage3300, adminLedGlobalMode=adminLedGlobalMode, portPrioIp=portPrioIp, switchIndustrialAlarmM1=switchIndustrialAlarmM1, sfpAlarmTxOutputPowerLowerLimit=sfpAlarmTxOutputPowerLowerLimit, infoTemperature=infoTemperature, adminAgentDefRouterIpAddress=adminAgentDefRouterIpAddress, PYSNMP_MODULE_ID=bmSwitchMIB, bmSwitchSfpTable=bmSwitchSfpTable, sfpState=sfpState, sfpInfoLength9um=sfpInfoLength9um, portPoeAdminState=portPoeAdminState, bmSwitchSfp=bmSwitchSfp, infoLastTftpMessage=infoLastTftpMessage, sfpDiagRxInputPowerDbm=sfpDiagRxInputPowerDbm, switchConfigurationChanged=switchConfigurationChanged, sfpDiagTxOutputPowerDbm=sfpDiagTxOutputPowerDbm, bmSwitchVlan=bmSwitchVlan, tftpMessage=tftpMessage, portDescr=portDescr, bmSwitchMIB=bmSwitchMIB, adminAlarmM2=adminAlarmM2, infoFunctionInputStateF1=infoFunctionInputStateF1, portLEDGreen=portLEDGreen, infoLastInternalMgmtWarning=infoLastInternalMgmtWarning, sfpAlarmRxInputPowerLowerLimit=sfpAlarmRxInputPowerLowerLimit, bmTraps=bmTraps, sfpInfoWavelength=sfpInfoWavelength, sfpInfoConnectorDescr=sfpInfoConnectorDescr, portAdminState=portAdminState, adminAgentDhcp=adminAgentDhcp, vlanDescr=vlanDescr, sfpInfoVendorName=sfpInfoVendorName, adminMgmtAccessList=adminMgmtAccessList, switchTemperatureFailure=switchTemperatureFailure, adminMemoryCardMode=adminMemoryCardMode, adminReset=adminReset, portVoiceVlanId=portVoiceVlanId, portDefaultPrioQueue=portDefaultPrioQueue, bmSwitchInfo=bmSwitchInfo, portSecurityAdminState=portSecurityAdminState, portLinkState=portLinkState, adminSwitchPortMirror=adminSwitchPortMirror, switchMgmtAuthFailure=switchMgmtAuthFailure, switchInternalVoltageFailure=switchInternalVoltageFailure, portPoeOverloadFailure=portPoeOverloadFailure, adminAgentPrioValue=adminAgentPrioValue, radiusPortSecurityReject=radiusPortSecurityReject, portActiveLoopDetectionFailure=portActiveLoopDetectionFailure, sfpInfoSerialNumber=sfpInfoSerialNumber, portLimiterPacketType=portLimiterPacketType, portErrorCountFailure=portErrorCountFailure, portAcApSetup=portAcApSetup, adminSnmpMacTableMode=adminSnmpMacTableMode, sfpInfoLength50um=sfpInfoLength50um, sfpDiagTemperature=sfpDiagTemperature, portBandwidthLimitTxd=portBandwidthLimitTxd, bmSwitchAdmin=bmSwitchAdmin, adminAgentNetmask=adminAgentNetmask, adminUnsecureVlanId=adminUnsecureVlanId, portNewMacAddress=portNewMacAddress, infoDescr=infoDescr, sfpInfoDateCode=sfpInfoDateCode, infoMgmtHardwareVersion=infoMgmtHardwareVersion, portName=portName, sfpInfoBitRate=sfpInfoBitRate, portSecurityMacAddr2=portSecurityMacAddr2, sfpDiagRxIntputPower=sfpDiagRxIntputPower, infoPoeInputVoltage=infoPoeInputVoltage, infoLastSfpEventMessage=infoLastSfpEventMessage, sfpInfoRevisionNumber=sfpInfoRevisionNumber, adminAddrAgingTimeMinutes=adminAddrAgingTimeMinutes, portPoeCurrent=portPoeCurrent, infoAlarmStateM1=infoAlarmStateM1, portLoopBcastFailure=portLoopBcastFailure, infoManufactureDate=infoManufactureDate, sfpDiagTxBiasCurrent=sfpDiagTxBiasCurrent, portBandwidthLimitRxd=portBandwidthLimitRxd, portSpeedDuplexSetup=portSpeedDuplexSetup, portErrorDisabled=portErrorDisabled, adminAlarmNameM1=adminAlarmNameM1, sfpAlarmTxBiasCurrentUpperLimit=sfpAlarmTxBiasCurrentUpperLimit, adminSwitchVlanTableMode=adminSwitchVlanTableMode, adminSwitchPoEPowerLimit=adminSwitchPoEPowerLimit, infoUnauthIpAddr=infoUnauthIpAddr, portSecurityMacAddr3=portSecurityMacAddr3, portPrioDot1p=portPrioDot1p, infoPowerVoltage2500=infoPowerVoltage2500, bmSwitchVlanTable=bmSwitchVlanTable, infoSeriesNo=infoSeriesNo, infoPoeInputPower=infoPoeInputPower, portSecurityMacAddr1=portSecurityMacAddr1, internalMgmtWarning=internalMgmtWarning, sfpInfoLength62um=sfpInfoLength62um, infoTotalConfigChanges=infoTotalConfigChanges, radiusMgmtAuthReject=radiusMgmtAuthReject, clientRemoved=clientRemoved, portTrunkingMode=portTrunkingMode, infoNoOfPorts=infoNoOfPorts, adminAgentIpAddress=adminAgentIpAddress, sfpDiagTxOutputPower=sfpDiagTxOutputPower, adminAgentDhcpServerIpAddress=adminAgentDhcpServerIpAddress, vlanId=vlanId, adminAlarmNameM2=adminAlarmNameM2, portPoePowerLimit=portPoePowerLimit, adminDot1xAuthFailureVlanId=adminDot1xAuthFailureVlanId, adminFunctionInputNameF1=adminFunctionInputNameF1, sfpDiagSupplyVoltage=sfpDiagSupplyVoltage, infoNewMacAddr=infoNewMacAddr, vlanIndex=vlanIndex, bmSwitchSfpEntry=bmSwitchSfpEntry, adminAgentPhysAddress=adminAgentPhysAddress, sfpInfoPartNumber=sfpInfoPartNumber, portSecurityForwardingState=portSecurityForwardingState, bmSwitchVlanEntry=bmSwitchVlanEntry, sfpPortIndex=sfpPortIndex, adminTftpAccess=adminTftpAccess, bmSwitchPortEntry=bmSwitchPortEntry, adminAlarmM1=adminAlarmM1, portLinkChange=portLinkChange, infoType=infoType, infoSwitchHardwareVersion=infoSwitchHardwareVersion, switchIndustrialAlarmM2=switchIndustrialAlarmM2, sfpEvent=sfpEvent, switchFunctionInputAlarm=switchFunctionInputAlarm, portPoePower=portPoePower, infoNoOfReboots=infoNoOfReboots, portPoeVoltage=portPoeVoltage, bmSwitchPortTable=bmSwitchPortTable, infoSerie=infoSerie, portErrorCounter=portErrorCounter, switchPoeVoltageFailure=switchPoeVoltageFailure, portDot1qDefaultPrioValue=portDot1qDefaultPrioValue, adminAgentVlanId=adminAgentVlanId, infoSecurityFailMacAddr=infoSecurityFailMacAddr, infoAlarmStateM2=infoAlarmStateM2, portLEDYellow=portLEDYellow, bmSwitchPort=bmSwitchPort, portSecurityFailure=portSecurityFailure)
