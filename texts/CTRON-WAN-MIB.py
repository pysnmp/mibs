#
# PySNMP MIB module CTRON-WAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-WAN-MIB
# Produced by pysmi-1.1.12 at Thu Nov 28 02:57:37 2024
# On host fv-az885-149 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
ctWan, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctWan")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, TimeTicks, ModuleIdentity, Bits, Counter32, ObjectIdentity, NotificationType, Unsigned32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Gauge32, MibIdentifier, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "TimeTicks", "ModuleIdentity", "Bits", "Counter32", "ObjectIdentity", "NotificationType", "Unsigned32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Gauge32", "MibIdentifier", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class Index(Integer32):
    pass

class DLCI(Integer32):
    pass

ctWanConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1))
ctWanDs1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2))
ctWanRs232 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3))
ctFrDcp = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4))
ctDDS = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5))
ctDs1Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6))
ctIPPQFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7))
ctWanHDSLExt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8))
wanNumConnections = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanNumConnections.setStatus('mandatory')
if mibBuilder.loadTexts: wanNumConnections.setDescription('This objects describes the number of wan connections on the\n                platform. A wan connection may have one or two physical ports\n                of which only one can be active at any time.')
wanConnTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2), )
if mibBuilder.loadTexts: wanConnTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnTable.setDescription('A list of wan connection entries. The number of wan\n                connection entries is given by the value of wanNumConnections.')
wanConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "wanConnIndex"))
if mibBuilder.loadTexts: wanConnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnEntry.setDescription('A wan connection entry containing objects relating to\n                the particular wan connection.')
wanConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnIndex.setDescription('A unique value for each wan connection. Its value ranges\n                between 1 and the value wanNumConnections.')
wanConnNumPhysPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanConnNumPhysPorts.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnNumPhysPorts.setDescription('The number of physical ports that exist on this wan\n                 connection.')
wanConnDefaultPhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanConnDefaultPhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnDefaultPhysPort.setDescription('The default physical port for this connection.  This\n                indicates the physical port that should be used on this wan\n                connection. If redundancy is not enabled, this physical port\n                will always be used. If redundancy is enabled, the physical\n                port given here will be considered the primary physical port.\n                The value of this object must be set to the index of a\n                valid physical port (wanPhysPortIndex) for this wan connection.')
wanConnActivePhysPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanConnActivePhysPort.setStatus('mandatory')
if mibBuilder.loadTexts: wanConnActivePhysPort.setDescription('The physical port that is currently active for this wan\n                connection. The value of this object indicates the\n                wanPhysPortIndex for the active port.')
wanPhysPortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3), )
if mibBuilder.loadTexts: wanPhysPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortTable.setDescription('A list of the descriptions of the physical ports of this\n                 platform. The number of entries is given by the value\n                 of wanConnNumPhysPort for each Wan Connection.')
wanPhysPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "wanPhysPortConnectionIndex"), (0, "CTRON-WAN-MIB", "wanPhysPortIndex"))
if mibBuilder.loadTexts: wanPhysPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortEntry.setDescription('A physical port entry. It contains objects relating to a\n                given physical port')
wanPhysPortConnectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortConnectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortConnectionIndex.setDescription('A value indicating the wan connection this physical port\n                is located on.')
wanPhysPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortIndex.setDescription('A unique value for each physical port on a wan connection.\n                Its value ranges between 1 and the value wanConnNumPhysPorts.')
wanPhysPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("none", 1), ("t1", 2), ("e1", 3), ("synchronous", 4), ("dds", 5), ("di", 6), ("hdsl", 7), ("bri", 8), ("ds30", 9), ("t1DDS", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortType.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortType.setDescription('The type of physical port that this entry describes. None\n                indicates that the physical port has no connector.')
wanPhysPortSpecificMib = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 3, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanPhysPortSpecificMib.setStatus('mandatory')
if mibBuilder.loadTexts: wanPhysPortSpecificMib.setDescription('This object identifies an instance of the index object in\n         the first group of objects in the MIB specific to the\n         physical port.')
wanInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4), )
if mibBuilder.loadTexts: wanInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceTable.setDescription('The interface table for a physical port on a wan connection.\n                It is a list of items that are pertinent to the interfaces\n                that are part of this physical port. The number of entries\n                is dependent on the wanPhysPortType for the interface.\n                If the wanPhysPortType is none, there will be no entries\n                in the table for the port. If the wanPhysPortType is t1,\n                there will be 24 entries in this table for the port.\n                If the wanPhysPortType is e1, there will be 30 entries\n                in this table for the port. If the wanPhysPortType is\n                synchronous, there will be one entry in this table for the\n                port. ')
wanInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "wanInterfaceConnectionIndex"), (0, "CTRON-WAN-MIB", "wanInterfacePhysPortIndex"), (0, "CTRON-WAN-MIB", "wanInterfaceEntryIndex"))
if mibBuilder.loadTexts: wanInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntry.setDescription('A wan connection physical port interface entry. It\n                contains objects relating to an interface that is defined\n                for this physical port and this wan connection.')
wanInterfaceConnectionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceConnectionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceConnectionIndex.setDescription('This value is the wan connection that this interface\n                 exists on.')
wanInterfacePhysPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfacePhysPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfacePhysPortIndex.setDescription('This value is the physical port of the wan connection\n                that this interface exists on.')
wanInterfaceEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryIndex.setDescription("A unique value for each interface of this physical port.\n                It is a value between 1 and the number of interfaces that\n                exist for the current port. The number of interfaces for\n                each type of port is: 24 for a port type (wanPhysPortType)\n                of 't1', 30 for a port type of 'e1',  and 1 for a port type\n                of 'synchronous'. There will be no entries if the port type\n                is 'none'.")
wanInterfaceEntryIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceEntryIfIndex.setReference('rfc-1213')
if mibBuilder.loadTexts: wanInterfaceEntryIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryIfIndex.setDescription('The ifIndex of the interface. This is the index of this entry\n                in the ifTable.')
wanInterfaceEntryProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryProtocol.setReference('rfc-1213, product literature')
if mibBuilder.loadTexts: wanInterfaceEntryProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryProtocol.setDescription('The protocol that should be run on this interface. Values\n                are equivalent to those defined for ifType in Mib-II.\n                Accepted values are product dependent.')
wanInterfaceEntryCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryCompression.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryCompression.setDescription('Indicates whether data compression should take\n                place on this interface.')
wanInterfaceEntryMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryMTU.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryMTU.setDescription('The MTU to be negotiated for this interface. This will not\n                be updated with the actual MTU, which can be found in the\n                ifTable.')
wanInterfaceEntryLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("jBZS", 2), ("invHDLC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryLineCoding.setReference('rfc-1406')
if mibBuilder.loadTexts: wanInterfaceEntryLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryLineCoding.setDescription('This object describes the variety of Zero Code suppression\n                on this interface. For an interface on a Ds1 Port, the valid\n                values depend on the value of the Ds1ConfigLineCode object.\n                If that object is set to ds1xB8ZS, then this object can be\n                set to none, JBZS, or InvHDLC. If the value of\n                Ds1ConfigLineCode is set to ds1xAMI, then this object can\n                only be set to JBZS, or InvHDLC.  For an interface on a\n                Synchronous Port, the valid values are none or InvHDLC.\n                JBZS refers to Jammed Bit Zero suppression, which forces a\n                1 bit every 8 bit periods. InvHDLC refers to inverting\n                the HDLC data for the interface. None refers to a mode\n                in which some other means, such as with the Ds1ConfigLineCode\n                object set to dsx1B8ZS, is used to insure pulse density\n                requirements.')
wanInterfaceEntryCrcLength = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sixteen-bits", 1), ("thirty-two-bits", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryCrcLength.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryCrcLength.setDescription('The Length of the CRC for this interface. Not all platforms\n                will allow all options.')
wanInterfaceEntryLexProtocolEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryLexProtocolEnable.setStatus('deprecated')
if mibBuilder.loadTexts: wanInterfaceEntryLexProtocolEnable.setDescription('This switch acts in concert with the wanInterfaceEntryProtocol\n                object.  To activate LEX, this object should first be set to\n                enable (1), then set the wanInterfaceEntryProtocol to PPP.  The \n                enable will have no effect if PPP is not selected.  If the\n                wanInterfaceEntryProtocol is selected first, the default NCP of\n                BNCP will be selected.  To De-select LEX, you must set this \n                object to disable (2), and wanInterfaceEntryProtocol to NONE or\n                reset the device.  Just selecting disable (2) will not tear down\n                the connection.')
wanInterfaceEntryLexProtocolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bound", 1), ("unbound", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceEntryLexProtocolStatus.setStatus('deprecated')
if mibBuilder.loadTexts: wanInterfaceEntryLexProtocolStatus.setDescription('This object reflects the current state of the link.  The device\n                is said to be bound to the router when the physical link is OK,\n                the LEX negotiation is successful, and the router has been\n                configured correctly to communicate with this particular LAN\n                Extender.')
wanInterfaceEntryCompRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceEntryCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryCompRatio.setDescription('The ratio of uncompressed to compressed transmitted data. \n                If the data compression status is off, 1:1 will be displayed')
wanInterfaceEntryCompStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanInterfaceEntryCompStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryCompStatus.setDescription('On indicates that the compression has been successfully\n                 negotiated and is operating. Off indicates that the\n                 compression negotiation has failed and compression is not\n                 operating at this time, or compression has been terminated\n                 by either peer.')
wanInterfaceEntryBackUpIfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanInterfaceEntryBackUpIfEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wanInterfaceEntryBackUpIfEnable.setDescription('This object is used to select the Call-backup option.\n                 A value of 1 is used to enable the option and a value of\n                 2 to disable it.')
wanDs1ExtensionsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1), )
if mibBuilder.loadTexts: wanDs1ExtensionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsTable.setDescription('This table is an extension to the standard ds1 configuration\n                table. It is a list of items that are pertinent to ds1 ports\n                on a platform. There is one entry per ds1 physical port on\n                the platform')
wanDs1ExtensionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "wanDs1ExtensionsEntryIndex"))
if mibBuilder.loadTexts: wanDs1ExtensionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsEntry.setDescription('A ds1 extensions entry containing objects relating to\n                 the particular ds1 physical port')
wanDs1ExtensionsEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsEntryIndex.setDescription('A unique value for each ds1 physical port on the platform.')
wanDs1ExtensionsNumInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsNumInterfaces.setReference('rfc-1213')
if mibBuilder.loadTexts: wanDs1ExtensionsNumInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsNumInterfaces.setDescription('The number of interfaces on this physical port. This\n                number indicates the number of  entries this physical port\n                uses in the ifTable.')
wanDs1ExtensionsToggleFracTable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("update-table", 1), ("display-new", 2), ("display-old", 3), ("restore-old", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsToggleFracTable.setReference('rfc-1406')
if mibBuilder.loadTexts: wanDs1ExtensionsToggleFracTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsToggleFracTable.setDescription('Setting this object to 1 will cause the Ds1 Fractional Table\n                 to be updated with the new values, as entered.\n                 Setting this object to 2, will cause the Ds1 Fractional Table\n                 to view as the table being entered.\n                 Setting this object to 3, will cause the Ds1 Fractional Table\n                 to be the table that is currently in use, regardless of\n                 any changes being entered.\n                 Setting this object to 4, will cause any changes that have\n                 been made to the Ds1 Fractional Table since the last\n                 update-table to be deleted.\n                 For physical ports of type synchronous, this object will\n                 have no affect, and will always return a 1.')
wanDs1ExtensionsLineBuildOut = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("zero", 2), ("minus-7point5", 3), ("minus-15", 4), ("a133to266feet", 5), ("a266to399feet", 6), ("a399to533feet", 7), ("a533to655feet", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsLineBuildOut.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsLineBuildOut.setDescription('The line build out setting for this ds1 physical port.\n                Unknown indicates that the setting is neither readable or\n                writable.')
wanDs1ExtensionsCFADuration = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsCFADuration.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsCFADuration.setDescription('The length of time (in seconds), that the ds1 port will\n                remain in the Carrier Failure Alarm state after the\n                alarm condition has cleared.')
wanDs1ExtensionsDIEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("diDataEnabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsDIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsDIEnable.setDescription('Enables or disables Drop and Insert functionality on a\n                D/I WPIM.  If enabled, all zero assigned timeslots will \n                designate D/I interface channels, if disabled all zero \n                channels will designate dummy channels as on a T1 or E1.\n                If this object is set to diDataEnabled the zero channels\n                will designate D/I interface channels and data to and\n                from the device will be transmitted or received on the\n                D/I port instead of the N/I port.')
wanDs1ExtensionsTotalValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsTotalValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsTotalValidIntervals.setDescription('The number of  previous  intervals  for  which\n                valid data was collected for the DS1 mib, which\n                is currently RFC1406.  This counter is similar to\n                RFC1406 dsx1ValidIntervals except that the count\n                represents the total number of complete 15 minute\n                intervals since the ds1 interface has been online,\n                and does not stop at the 24 hour period.')
wanDs1ExtensionsBertTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("internal", 2), ("manual", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestMode.setDescription('This object is used to request that a type of\n                process be in control of the testing function.\n                This is used to differentiate between automated test \n                procedures and those manually controlled by a user.  \n                When read, this object reflects which type of process \n                is actually in control of the testing function.  The \n                implementation is free to prioritize or deny requests\n                in a proprietary manner.')
wanDs1ExtensionsBertRun = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsBertRun.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertRun.setDescription('Controls the sending of test data over this physical \n                port.  The data is a pattern described by \n                wanDs1ExtensionsBertTestPattern.')
wanDs1ExtensionsBertCurrentResults = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertCurrentResults.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertCurrentResults.setDescription('Indicates the results of the testing for the\n                last completed sampling period.  A non-negative\n                number is the error rate in bits per million bits.')
wanDs1ExtensionsBertCumulativeResults = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertCumulativeResults.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertCumulativeResults.setDescription('Indicates the total number of errors since the\n                testing was enabled.  It is not a rate.')
wanDs1ExtensionsBertPeakResults = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertPeakResults.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertPeakResults.setDescription('Indicates the highest value of \n                wanDs1ExtensionsBertCurrentResults since the testing \n                was enabled.  A non-negative number is the error rate \n                in bits per million bits.')
wanDs1ExtensionsBertAverageResult = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertAverageResult.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertAverageResult.setDescription('Indicates the average value of \n                wanDs1ExtensionsBertCurrentResults since the testing \n                was enabled.  A non-negative number is the error rate \n                in bits per million bits.')
wanDs1ExtensionsBertTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("patternOther", 1), ("pattern1s", 2), ("pattern63", 3), ("pattern511", 4), ("pattern2047", 5), ("pattern3in24", 6), ("patternQRSS", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestPattern.setDescription('This object is used to specify the pattern of the \n                test data.')
wanDs1ExtensionsBertSamplePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsBertSamplePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertSamplePeriod.setDescription('This object is the duration of time in seconds at\n                which the current test results will be periodically\n                written to wanDs1ExtensionsBertCurrentResults.  The \n                range is 1 to 3600, with a default value of 10.')
wanDs1ExtensionsBertNumPeriods = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertNumPeriods.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertNumPeriods.setDescription(' The number of sampling periods that have elapsed\n                during the current test run.')
wanDs1ExtensionsBertTestTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertTestTraps.setDescription('This object is used to enable or disable the sending\n                of a trap at the conclusion of the measurement period.\n                The trap will contain the information described by\n                ctDs1BertCurrentResults.  The default value is disabled.')
wanDs1ExtensionsBertDataStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 1), ("waitingForLink", 2), ("waitingForLoopback", 3), ("running", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanDs1ExtensionsBertDataStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wanDs1ExtensionsBertDataStatus.setDescription('This object provides the operating status of the\n                transmission of test data packets.')
wanRs232ExtensionsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3, 1), )
if mibBuilder.loadTexts: wanRs232ExtensionsTable.setReference('rfc-1317')
if mibBuilder.loadTexts: wanRs232ExtensionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wanRs232ExtensionsTable.setDescription('This table is an extension to the standard rs232-like mib.\n                It is a list of items that are pertinent to rs232-like ports\n                on a platform. There is one entry per synchronous physical\n                port on the platform.')
wanRs232ExtensionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3, 1, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "wanRs232ExtensionsEntryIndex"))
if mibBuilder.loadTexts: wanRs232ExtensionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wanRs232ExtensionsEntry.setDescription('A rs232-like extensions entry containing objects relating to\n                the particular rs232-like physical port.')
wanRs232ExtensionsEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wanRs232ExtensionsEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wanRs232ExtensionsEntryIndex.setDescription('A unique value for each rs232-like physical port on\n                the platform.')
wanRs232ExtensionsCTSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanRs232ExtensionsCTSEnable.setReference('rfc-1317')
if mibBuilder.loadTexts: wanRs232ExtensionsCTSEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wanRs232ExtensionsCTSEnable.setDescription('This object indicates whether the platform should generate\n                CTS. When disabled the platform will not generate CTS, when\n                enabled, the platform will generate CTS.  The actual state\n                of the CTS line is available in the rs-232 like mib.')
wanRs232ExtensionsDSREnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wanRs232ExtensionsDSREnable.setReference('rfc-1317 ')
if mibBuilder.loadTexts: wanRs232ExtensionsDSREnable.setStatus('mandatory')
if mibBuilder.loadTexts: wanRs232ExtensionsDSREnable.setDescription('This object indicates whether the platform should generate\n                DSR. When disabled the platform will not generate DSR, when\n                enabled, the platform will generate DSR.  The actual state\n                of the DSR line is available in the rs-232 like mib.')
frDcpCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1), )
if mibBuilder.loadTexts: frDcpCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitTable.setDescription('A table containing data compression information about \n                specific Data Link Connection Identifiers and corresponding\n                virtual circuit. This information is used to support the\n                frCircuitTable following RFC-1315.')
frDcpCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "frDcpCircuitIfIndex"), (0, "CTRON-WAN-MIB", "frDcpCircuitDlci"))
if mibBuilder.loadTexts: frDcpCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitEntry.setDescription('The data compression information regarding a single Data \n                Link Connection Identifier.')
frDcpCircuitIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1, 1), Index()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDcpCircuitIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitIfIndex.setDescription('The ifIndex value of ifEntry that this DCP virtual circuit \n                object is layered onto.')
frDcpCircuitDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1, 2), DLCI()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDcpCircuitDlci.setReference('Draft American National Standard T1.618-1991, Section 3.3.6')
if mibBuilder.loadTexts: frDcpCircuitDlci.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitDlci.setDescription('The Data Link Connection Identifier for this DCP virtual \n                circuit object.')
frDcpCircuitEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frDcpCircuitEnable.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitEnable.setDescription('Indicates whether data compression should take place on\n                this particular end side virtual circuit.')
frDcpCircuitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDcpCircuitStatus.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitStatus.setDescription('On indicates that the compression has been successfully\n                 negotiated and is operating. Off indicates that the\n                 compression negotiation has failed and compression is not\n                 operating at this time, or compression has been terminated\n                 by either peer.')
frDcpCircuitRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 4, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: frDcpCircuitRatio.setStatus('mandatory')
if mibBuilder.loadTexts: frDcpCircuitRatio.setDescription('The ratio of uncompressed to compressed transmitted data. \n                If the data compression status is off, 1:1 will be displayed')
ddsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1), )
if mibBuilder.loadTexts: ddsConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ddsConfigTable.setDescription('The DDS Configuration Table')
ddsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ddsLineIndex"))
if mibBuilder.loadTexts: ddsConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ddsConfigEntry.setDescription('An Entry in the DDS Configuration Table')
ddsLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddsLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ddsLineIndex.setDescription('A unique value for each dds physical port on the \n                         platform')
ddsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ddsIfIndex.setDescription('Index associated with this dds physical port')
ddsLineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ddsPri", 1), ("ddsCc", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddsLineMode.setStatus('mandatory')
if mibBuilder.loadTexts: ddsLineMode.setDescription('DDS-PRI is full duplex 56k link, No framing in loop \n                        data so loop speed is also 56k. Data stream:\n                                --d1 d2 d3 d4 d5 d6 d7--        \n\n                        DDS-CC is full duplex 64k link. Does not require framing\n                        bit but uses a same format as SC, ninth bit position is \n                        lumped with primary channel and not used for control.\n                        Loop speed is 72k, Primary channel rate is 64k.\n                                --d1 d2 d3 d4 d5 d6 d7 F d8--')
ddsLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ddsNone", 1), ("ddsJBZS", 2), ("otherLineCode", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddsLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: ddsLineCoding.setDescription('This object describes the variety of Zero Code \n                        suppression on this interface.  JBZS refers to Jammed \n                        Bit Zero suppression, which forces a 1 bit every 8 bit \n                        periods. None refers to a mode in which some other \n                        means is used to insure pulse density requirements.')
ddsLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ddsNoLoop", 1), ("ddsLineLoop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddsLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: ddsLoopbackConfig.setDescription('This variable represents the loop-back configuration \n                        of the DDS interface.  ddsNoLoop means the interface is\n                        not in loop-back state, and LineLoop means the the\n                        received data is looped back out.')
ddsLineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ddsNoAlarm", 1), ("ddsLossOfSignal", 2), ("ddsOutOfService", 3), ("ddsOutOfFrame", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddsLineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ddsLineStatus.setDescription('This describes the current operational\n                        status of DDS line.')
ddsTxClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ddsLoopTiming", 1), ("ddsLocalTiming", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddsTxClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: ddsTxClockSource.setDescription('The source of Transmit clock.\n                        ddsLoopTiming - indicates that the recovered receive \n                        clock is used as transmit clock.\n                        ddsLocalTiming - indicates that a local clock source is\n                        used.')
ddsPortInSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddsPortInSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ddsPortInSpeed.setDescription(' This variable describes the current operational \n                         receive speed of DDS line.  It is a read only value\n                         based entirely on DDS type (CC or PRI).')
ddsPortOutSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddsPortOutSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: ddsPortOutSpeed.setDescription('This variable describes the current operational\n                         transmit speed of DDS line.  It is a read only value\n                         based entirely on DDS type CC or PRI')
ds1AlarmsGlobalConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1))
ds1AlarmGlobalAdmin = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalAdmin.setDescription('Used to enable and disable the DS1 Alarm\n                        Monitoring Application for all DS1 circuits on the \n                        device.')
ds1AlarmGlobalAutoRecovery = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalAutoRecovery.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalAutoRecovery.setDescription('Used to enable and disable the DS1 Alarm\n                        Automatic Recovery feature for all DS1 circuits on \n                        the device. For those devices that support ds1\n                        alarm monitoring, but do not support the automatic\n                        recovery feature, this object always returns disabled,\n                        and performs no action when written.')
ds1AlarmGlobalTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalTrapEnable.setDescription('Used to enable and disable the DS1 Alarm\n                        SNMP Trap generation feature for all DS1 circuits on \n                        the device.  This object operates in conjunction with \n                        configuration of objects in the ctron-trap-mib.txt')
ds1AlarmGlobalESCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalESCount.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalESCount.setDescription('Used in conjuction with ctDs1AlarmESInterval to set \n                        the threshold for alarm generation when the number of \n                        Errored Seconds for a specified time interval, \n                        measured in minutes, is exceeded.  The default \n                        Errored Seconds alarm condition is 100 errored seconds \n                        over a 6 minute time interval.')
ds1AlarmGlobalESInterval = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalESInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalESInterval.setDescription('Used in conjuction with ds1AlarmGlobalESCount to \n                        set the threshold for alarm generation when the number \n                        of Errored Seconds for a specified time interval, \n                        measured in minutes, is exceeded.  The default\n                        Errored Seconds alarm condition is 100 errored seconds \n                        over a 6 minute time interval.')
ds1AlarmGlobalBPVErrorRate = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalBPVErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalBPVErrorRate.setDescription("Used to specify the negative exponent of 10, used in\n                        monitoring Bipolar Violations (Code Violations for E1)\n                        over intervals defined by ds1AlarmGlobalBPVInterval.  \n                        For example, for a ds1AlarmGlobalBPVErrorRate value \n                        of 6 used with a ds1AlarmGlobalBPVInterval of 15, \n                        an alarm is generated when a 15 minute period has an \n                        average error rate which exceeds 1 Bipolar Violation \n                        (Code Violation for E1) per million bits.\n                        For those devices that support ds1 alarm monitoring\n                        but who's hardware does not support detect bipolar\n                        violations, this object always returns the default,\n                        and performs no action when written.")
ds1AlarmGlobalBPVInterval = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalBPVInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalBPVInterval.setDescription("Used to specify the interval, used in monitoring \n                        Bipolar Violations (Code Violations for E1)\n                        with thresholds defined by ds1AlarmGlobalBPVErrorRate.\n                        For example, for a ds1AlarmGlobalBPVErrorRate value \n                        of 6 used with a ds1AlarmGlobalBPVInterval of 15, an \n                        alarm is generated when a 15 minute period has an \n                        average error rate which exceeds 1 Bipolar Violation \n                        (Code Violation for E1) per million bits.\n                        For those devices that support ds1 alarm monitoring\n                        but who's hardware does not detect bipolar\n                        violations, this object always returns the default,\n                        and performs no action when written.")
ds1AlarmGlobalManualRecovery = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("recover", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmGlobalManualRecovery.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmGlobalManualRecovery.setDescription('To cause a manual recovery to occur on all Ds1 circuits, this\n                        object is set to a 1.  It is always read as a 1.  The recovery \n                        will occur only when automatic recovery is disabled.')
ds1AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2), )
if mibBuilder.loadTexts: ds1AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmConfigTable.setDescription('Table containing objects used to configure DS1 alarm \n                        functionality on a per DS1 basis.')
ds1AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ds1PhysNum"))
if mibBuilder.loadTexts: ds1AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmConfigEntry.setDescription('A description of a single entry.')
ds1PhysNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1PhysNum.setStatus('mandatory')
if mibBuilder.loadTexts: ds1PhysNum.setDescription('The value for this object is equal to the value\n                        of a unique physical connection identifier associated\n                        with this DS1 which is clearly labeled on the device.\n                        For those products that do not have a DS1 identifier\n                        labeled on the device, the value for this object is\n                        the same as rfc1406 dsx1LineIndex.')
ds1AlarmAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmAdmin.setDescription('Used to enable and disable the DS1 Alarm\n                        Monitoring Application for this DS1 circuit.')
ds1AlarmAutoRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmAutoRecovery.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmAutoRecovery.setDescription('Used to enable and disable the DS1 Alarm\n                        Automatic Recovery feature for this DS1 circuit.\n                        For those devices that support ds1\n                        alarm monitoring, but do not support the automatic\n                        recovery feature, this object always returns disabled,\n                        and performs no action when written.')
ds1AlarmTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmTrapEnable.setDescription('Used to enable and disable the DS1 Alarm\n                        SNMP Trap generation feature for this DS1 circuit.\n                        This object operates in conjunction with configuration \n                        of objects in the ctron-trap-mib.txt')
ds1AlarmESCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmESCount.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmESCount.setDescription('Used in conjuction with ctDs1AlarmESInterval to set \n                        the threshold for alarm generation when the number of \n                        Errored Seconds for a specified time interval, measured \n                        in minutes, is exceeded.  The default Errored Seconds \n                        alarm condition is 100 errored seconds over a 6 minute\n                        time interval.')
ds1AlarmESInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmESInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmESInterval.setDescription('Used in conjuction with ctDs1AlarmESCount to set the \n                        threshold for alarm generation when the number of \n                        Errored Seconds for a specified time interval, measured \n                        in minutes, is exceeded.  The default Errored Seconds \n                        alarm condition is 100 errored seconds over a 6 minute \n                        time interval.')
ds1AlarmBPVErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmBPVErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmBPVErrorRate.setDescription("Used to specify the negative exponent of 10, used in\n                        monitoring Bipolar Violations (Code Violations for E1)\n                        over intervals defined by ds1AlarmBPVInterval.  For \n                        example, for a ds1AlarmBPVErrorRate value of 6 used \n                        with a ds1AlarmBPVInterval of 15, an alarm is generated \n                        when a 15 minute period has an average error rate which \n                        exceeds 1 Bipolar Violation (Code Violation for E1) per\n                        million bits.\n                        For those devices that support ds1 alarm monitoring\n                        but who's hardware does not support detect bipolar\n                        violations, this object always returns the default,\n                        and performs no action when written.")
ds1AlarmBPVInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmBPVInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmBPVInterval.setDescription("Used to specify the interval, used in\n                        monitoring Bipolar Violations (Code Violations for E1)\n                        with thresholds defined by ds1AlarmBPVErrorRate.  For \n                        example, for a ds1AlarmBPVErrorRate value of 6 used \n                        with a ds1AlarmBPVInterval of 15, an alarm is generated \n                        when a 15 minute period has an average error rate\n                        which exceeds 1 Bipolar Violation (Code Violation for \n                        E1) per million bits.\n                        For those devices that support ds1 alarm monitoring\n                        but who's hardware does not support detect bipolar\n                        violations, this object always returns the default,\n                        and performs no action when written.")
ds1AlarmManualRecovery = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("recover", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds1AlarmManualRecovery.setStatus('mandatory')
if mibBuilder.loadTexts: ds1AlarmManualRecovery.setDescription('To cause a manual recovery to occur, this object is set\n                        to a 1.  It is always read as a 1.  The recovery will \n                        occur only when automatic recovery is disabled.')
ipPQConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1))
ipPQAdmin = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPQAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: ipPQAdmin.setDescription('Used to enable and disable the IP Priority Queue\n                        Forwarding Application.')
iPPQMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPPQMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: iPPQMaxEntries.setDescription('Returns the maximum number of IP address entries \n                        supported by the IP Priority Queue application on \n                        this device.')
iPPQNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPPQNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: iPPQNumEntries.setDescription('Get the number of IP address entries currently\n                        programmed in the ipPQAddressTable.')
iPPQAddAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPPQAddAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iPPQAddAddress.setDescription('Add an IP address to the ipPQAddressTable. Always\n                        read as a 0.0.0.0.')
iPPQDelAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPPQDelAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iPPQDelAddress.setDescription('Delete an IP address from the ipPQAddressTable.\n                        Always read as a 0.0.0.0.')
ipPQAddressTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 2), )
if mibBuilder.loadTexts: ipPQAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipPQAddressTable.setDescription('Table containing IP addresses, used in an\n                        IP Priority Queue Forwarding function.')
ipPQAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 2, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ipPQAddressId"))
if mibBuilder.loadTexts: ipPQAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipPQAddressEntry.setDescription('A description of a single entry.')
ipPQAddressId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPQAddressId.setStatus('mandatory')
if mibBuilder.loadTexts: ipPQAddressId.setDescription('A unique value identifying an element in a sequence\n                        of IP PQ address entries.')
ipPQIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 7, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipPQIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: ipPQIPAddress.setDescription('Returns an IP address associated with a specific\n                        entry in this table.')
ctWanHDSLPerformance15mTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1), )
if mibBuilder.loadTexts: ctWanHDSLPerformance15mTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance15mTable.setDescription('HDSL 15 minute performance table. This table provides the \n             accumulated counts of errored seconds (ES) and unavailable \n             seconds (UAS) for the HDSL line including the local, remote\n             units and any doublers in between during a 15 minutes period\n             for the last 24 hours. \n\n             The table is indexed by the non-empty slot in the device and\n             the 15-minute history slot within the last 24 hours period.')
ctWanHDSLPerformance15mEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLPerformance15mConnIndex"), (0, "CTRON-WAN-MIB", "ctWanHDSLPerformance15mSlotIndex"))
if mibBuilder.loadTexts: ctWanHDSLPerformance15mEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance15mEntry.setDescription('Entries in the 15 minute performance table')
ctWanHDSLPerformance15mConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPerformance15mConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance15mConnIndex.setDescription('Identify the HDSL connection within the device, indexing from\n             1 to the maximum allowed number of HDSL connections in the\n             device.')
ctWanHDSLPerformance15mSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPerformance15mSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance15mSlotIndex.setDescription('Define which 15-minute slot history of the HDSL within the\n             24 hour period. Indexing from 1 - 97 with the first index \n             representing the current 15-minute history')
ctWanHDSLHLULoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop1UAS15m.setDescription('Unavailable seconds (UAS) on LOOP 1 of the local line unit during\n             the 15-minute period.')
ctWanHDSLHLULoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop1ES15m.setDescription('Errored seconds (ES) on LOOP 1 of the local line unit during\n             the 15-minute period.')
ctWanHDSLHLULoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop2UAS15m.setDescription('Unavailable seconds (UAS) on LOOP 2 of the local line unit during\n             the 15-minute period.')
ctWanHDSLHLULoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop2ES15m.setDescription('Errored seconds (ES) on LOOP 2 of the local line unit during\n             the 15-minute period.')
ctWanHDSLHRULoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop1UAS15m.setDescription('Unavailable seconds (UAS) on LOOP 1 of the remote line unit during\n             the 15-minute period.')
ctWanHDSLHRULoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop1ES15m.setDescription('Errored seconds (ES) on LOOP 1 of the remote line unit during\n             the 15-minute period.')
ctWanHDSLHRULoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop2UAS15m.setDescription('Unavailable seconds (UAS) on LOOP 2 of the remote line unit during\n             the 15-minute period.')
ctWanHDSLHRULoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop2ES15m.setDescription('Errored seconds (ES) on LOOP 2 of the remote line unit during\n             the 15-minute period.')
ctWanHDSLDb1NetworkLoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 1 of the first doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb1NetworkLoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1ES15m.setDescription("Errored seconds (ES) on LOOP 1 of the first doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb1NetworkLoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 2 of the first doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb1NetworkLoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2ES15m.setDescription("Errored seconds (ES) on LOOP 2 of the first doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb1CustomerLoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 1 of the first doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb1CustomerLoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1ES15m.setDescription("Errored seconds (ES) on LOOP 1 of the first doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb1CustomerLoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 2 of the first doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb1CustomerLoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2ES15m.setDescription("Errored seconds (ES) on LOOP 2 of the first doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb2NetworkLoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 1 of the second doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb2NetworkLoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1ES15m.setDescription("Errored seconds (ES) on LOOP 2 of the second doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb2NetworkLoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 2 of the second doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb2NetworkLoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2ES15m.setDescription("Errored seconds (ES) on LOOP 2 of the second doubler unit's\n             network side during the 15-minute period.")
ctWanHDSLDb2CustomerLoop1UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 1 of the second doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb2CustomerLoop1ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1ES15m.setDescription("Errored seconds (ES) on LOOP 1 of the second doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb2CustomerLoop2UAS15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2UAS15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2UAS15m.setDescription("Unavailable seconds (UAS) on LOOP 2 of the second doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLDb2CustomerLoop2ES15m = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2ES15m.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2ES15m.setDescription("Errored seconds (ES) on LOOP 2 of the second doubler unit's\n             customer side during the 15-minute period.")
ctWanHDSLPerformance24hTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2), )
if mibBuilder.loadTexts: ctWanHDSLPerformance24hTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance24hTable.setDescription('HDSL 24-hour performance table. This table provides the\n             accumulated counts of errored seconds (ES) and unavailable\n             seconds (UAS) for the HDSL line including the local, remote\n             units and any doublers in between during a 24-hour period\n             for the last 7 days.\n \n             The table is indexed by the non-empty slot in the device and\n             the 24-hour history slot within the last 7 days period.')
ctWanHDSLPerformance24hEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLPerformance24hConnIndex"), (0, "CTRON-WAN-MIB", "ctWanHDSLPerformance24hSlotIndex"))
if mibBuilder.loadTexts: ctWanHDSLPerformance24hEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance24hEntry.setDescription('Entries in the 24-hour ctWanHDSLPerformance table')
ctWanHDSLPerformance24hConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPerformance24hConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance24hConnIndex.setDescription('Identify the HDSL connection within the device, indexing from\n             1 to the maximum allowed number of HDSL connections in the\n             device.')
ctWanHDSLPerformance24hSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPerformance24hSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPerformance24hSlotIndex.setDescription('Define which 24-hour slot history of the HDSL within the\n             last 7 days period. Indexing from 1 - 8 with the first index\n             representing the current 24 hour history')
ctWanHDSLHLULoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop1UAS24h.setDescription('Unavailable seconds (UAS) on LOOP 1 of the local line unit during\n             the 24-hour period.')
ctWanHDSLHLULoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop1ES24h.setDescription('Errored seconds (ES) on LOOP 1 of the local line unit during\n             the 24-hour period.')
ctWanHDSLHLULoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop2UAS24h.setDescription('Unavailable seconds (UAS) on LOOP 2 of the local line unit during\n             the 24-hour period.')
ctWanHDSLHLULoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLULoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLULoop2ES24h.setDescription('Errored seconds (ES) on LOOP 2 of the local line unit during\n             the 24-hour period.')
ctWanHDSLHRULoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop1UAS24h.setDescription('Unavailable seconds (UAS) on LOOP 1 of the remote line unit during\n             the 24-hour period.')
ctWanHDSLHRULoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop1ES24h.setDescription('Errored seconds (ES) on LOOP 1 of the remote line unit during\n             the 24-hour period.')
ctWanHDSLHRULoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop2UAS24h.setDescription('Unavailable seconds (UAS) on LOOP 2 of the remote line unit during\n             the 24-hour period.')
ctWanHDSLHRULoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRULoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRULoop2ES24h.setDescription('Errored seconds (ES) on LOOP 2 of the remote line unit during\n             the 24-hour period.')
ctWanHDSLDb1NetworkLoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 1 of the first doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb1NetworkLoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop1ES24h.setDescription("Errored seconds (ES) on LOOP 1 of the first doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb1NetworkLoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 2 of the first doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb1NetworkLoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1NetworkLoop2ES24h.setDescription("Errored seconds (ES) on LOOP 2 of the first doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb1CustomerLoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 1 of the first doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb1CustomerLoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop1ES24h.setDescription("Errored seconds (ES) on LOOP 1 of the first doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb1CustomerLoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 2 of the first doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb1CustomerLoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb1CustomerLoop2ES24h.setDescription("Errored seconds (ES) on LOOP 2 of the first doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb2NetworkLoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 1 of the second doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb2NetworkLoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop1ES24h.setDescription("Errored seconds (ES) on LOOP 1 of the second doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb2NetworkLoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 2 of the second doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb2NetworkLoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2NetworkLoop2ES24h.setDescription("Errored seconds (ES) on LOOP 2 of the second doubler unit's\n             network side during the 24-hour period.")
ctWanHDSLDb2CustomerLoop1UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 1 of the second doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb2CustomerLoop1ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop1ES24h.setDescription("Errored seconds (ES) on LOOP 1 of the second doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb2CustomerLoop2UAS24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2UAS24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2UAS24h.setDescription("Unavailable seconds (UAS) on LOOP 2 of the second doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLDb2CustomerLoop2ES24h = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2ES24h.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDb2CustomerLoop2ES24h.setDescription("Errored seconds (ES) on LOOP 2 of the second doubler unit's\n             customer side during the 24-hour period.")
ctWanHDSLStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3), )
if mibBuilder.loadTexts: ctWanHDSLStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLStatisticsTable.setDescription('This table collects the statistics for the Signal noise ratio \n             (SNR), and the pulse attenuation of the HDSL line, including\n             the local, remote units and the doublers in between.')
ctWanHDSLStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLStatisticsHLUConnIndex"))
if mibBuilder.loadTexts: ctWanHDSLStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLStatisticsEntry.setDescription('Entries of the HDSL statistics table ')
ctWanHDSLStatisticsHLUConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLStatisticsHLUConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLStatisticsHLUConnIndex.setDescription('Identify the HDSL connection occupied in the device,\n             indexing from 1 to the maximum allowed connections in\n             the device.')
ctWanHDSLSNRHLULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHLULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHLULoop1.setDescription('Current SNR on LOOP 1 of the local line unit.')
ctWanHDSLSNRLowHLULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowHLULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowHLULoop1.setDescription('Lowest SNR on LOOP 1 of the local line unit.')
ctWanHDSLSNRHighHLULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighHLULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighHLULoop1.setDescription('Highest SNR on LOOP 1 of the local line unit.')
ctWanHDSLSNRHLULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHLULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHLULoop2.setDescription('Current SNR on LOOP 2 of the local line unit.')
ctWanHDSLSNRLowHLULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowHLULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowHLULoop2.setDescription('Lowest SNR on LOOP 2 of the local line unit.')
ctWanHDSLSNRHighHLULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighHLULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighHLULoop2.setDescription('Highest SNR on LOOP 2 of the local line unit.')
ctWanHDSLPulseAttenuationHLULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHLULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHLULoop1.setDescription('pulse Attenuation on LOOP 1 of the local line unit.')
ctWanHDSLPulseAttenuationHLULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHLULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHLULoop2.setDescription('pulse Attenuation on LOOP 2 of the local line unit.')
ctWanHDSLBitStat1HLU = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLBitStat1HLU.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLBitStat1HLU.setDescription('A byte value which contains product specific information:\n\n             bit  0 - System in AIS on the local line unit.\n                  1 - System in AIS on the remote line unit.\n                  2 - Channels are reversed on the remote line unit.\n                  3 - Channels are reversed on the doubler 1.\n                  4 - Channels are reversed on the doubler 2.\n                  5 - Power is fed to the next unit on the local line unit.\n                  6 - Power is fed to the next unit on the remote line unit.\n                  7 - Smartloop is active on remote line unit. (HiGain only)')
ctWanHDSLSNRHRULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHRULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHRULoop1.setDescription('Current SNR on LOOP 1 of the remote line unit.')
ctWanHDSLSNRLowHRULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowHRULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowHRULoop1.setDescription('Lowest SNR on LOOP 1 of the remote line unit.')
ctWanHDSLSNRHighHRULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighHRULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighHRULoop1.setDescription('Highest SNR on LOOP 1 of the remote line unit.')
ctWanHDSLSNRHRULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHRULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHRULoop2.setDescription('Current SNR on LOOP 2 of the remote line unit.')
ctWanHDSLSNRLowHRULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowHRULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowHRULoop2.setDescription('Lowest SNR on LOOP 2 of the remote line unit.')
ctWanHDSLSNRHighHRULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighHRULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighHRULoop2.setDescription('Highest SNR on LOOP 2 of the remote line unit.')
ctWanHDSLPulseAttenuationHRULoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHRULoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHRULoop1.setDescription('pulse Attenuation on LOOP 1 of the remote line unit.')
ctWanHDSLPulseAttenuationHRULoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHRULoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationHRULoop2.setDescription('pulse Attenuation on LOOP 2 of the remote line unit.')
ctWanHDSLDs1FrameHRU = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLDs1FrameHRU.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLDs1FrameHRU.setDescription('Byte value shows DS1 frame and code information for the remote \n             line unit (HiGain only):\n          \n             bit 0:1 -\n                 0 - frame format is SF.\n                 1 - frame format is ESF.\n                 2 - Frame format is unframed.\n                 3 - no activity.\n \n             bit 2:3 -\n                 reserved.\n \n             bit 4  -\n                 0 - line code is AMI\n                 1 - line code is B8ZS.\n \n             bit 5:7 -\n                 reserved.')
ctWanHDSLSNRDb1NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb1NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb1NetworkLoop1.setDescription("Current SNR on LOOP 1 of doubler 1's network side")
ctWanHDSLSNRLowDb1NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1NetworkLoop1.setDescription("Lowest SNR on LOOP 1 of doubler 1's network side")
ctWanHDSLSNRHighDb1NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1NetworkLoop1.setDescription("Highest SNR on LOOP 1 of doubler 1's network side")
ctWanHDSLSNRDb1NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb1NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb1NetworkLoop2.setDescription("Current SNR on LOOP 2 of doubler 1's network side.")
ctWanHDSLSNRLowDb1NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1NetworkLoop2.setDescription("Lowest SNR on LOOP 2 of doubler 1's network side.")
ctWanHDSLSNRHighDb1NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1NetworkLoop2.setDescription("Highest SNR on  LOOP 2 of doubler 1's network side.")
ctWanHDSLSNRDb1CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb1CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb1CustomerLoop1.setDescription("Current SNR on LOOP 1 of doubler 1's customer side.")
ctWanHDSLSNRLowDb1CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1CustomerLoop1.setDescription("Lowest SNR on LOOP 1 of doubler 1's customer side.")
ctWanHDSLSNRHighDb1CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1CustomerLoop1.setDescription("Highest SNR on LOOP 1 of doubler 1's customer side.")
ctWanHDSLSNRDb1CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb1CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb1CustomerLoop2.setDescription("Current SNR on LOOP 2 of doubler 1's customer side.")
ctWanHDSLSNRLowDb1CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb1CustomerLoop2.setDescription("Lowest SNR on LOOP 2 of doubler 1's customer side.")
ctWanHDSLSNRHighDb1CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb1CustomerLoop2.setDescription("Highest SNR on LOOP 2 of doubler 1's customer side.")
ctWanHDSLPulseAttenuationDb1NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1NetworkLoop1.setDescription("Pulse Attenuation on LOOP 1 of doubler 1's network side.")
ctWanHDSLPulseAttenuationDb1NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1NetworkLoop2.setDescription("Pulse Attenuation on LOOP 2 of doubler 1's network side.")
ctWanHDSLPulseAttenuationDb1CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1CustomerLoop1.setDescription("Pulse Attenuation on LOOP 1 of doubler 1's customer side.")
ctWanHDSLPulseAttenuationDb1CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb1CustomerLoop2.setDescription("pulse Attenuation on LOOP 2 of doubler 1's customer side.")
ctWanHDSLSNRDb2NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb2NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb2NetworkLoop1.setDescription("Current SNR on LOOP 1 of doubler 2's network side.")
ctWanHDSLSNRLowDb2NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2NetworkLoop1.setDescription("Lowest SNR on LOOP 1 of doubler 2's network side.")
ctWanHDSLSNRHighDb2NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2NetworkLoop1.setDescription("Highest SNR on LOOP 1 of doubler 2's network side.")
ctWanHDSLSNRDb2NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb2NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb2NetworkLoop2.setDescription("Current SNR on LOOP 2 of doubler 2's network side.")
ctWanHDSLSNRLowDb2NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2NetworkLoop2.setDescription("Lowest SNR on LOOP 2 of doubler 2's network side.")
ctWanHDSLSNRHighDb2NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2NetworkLoop2.setDescription("Highest SNR on LOOP 2 of doubler 2's network side.")
ctWanHDSLSNRDb2CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb2CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb2CustomerLoop1.setDescription("Current SNR on LOOP 1 of doubler 2's customer side.")
ctWanHDSLSNRLowDb2CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2CustomerLoop1.setDescription("Lowest SNR on LOOP 1 of doubler 2's customer side.")
ctWanHDSLSNRHighDb2CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2CustomerLoop1.setDescription("Highest SNR on LOOP 1 of doubler 2's customer side.")
ctWanHDSLSNRDb2CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRDb2CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRDb2CustomerLoop2.setDescription("Current SNR on LOOP 2 of doubler 2's customer side.")
ctWanHDSLSNRLowDb2CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRLowDb2CustomerLoop2.setDescription("Lowest SNR on LOOP 2 of doubler 2's customer side.")
ctWanHDSLSNRHighDb2CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLSNRHighDb2CustomerLoop2.setDescription("Highest SNR on LOOP 2 of doubler 2's customer side.")
ctWanHDSLPulseAttenuationDb2NetworkLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2NetworkLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2NetworkLoop1.setDescription("Pulse Attenuation on LOOP 1 of doubler 2's network side")
ctWanHDSLPulseAttenuationDb2NetworkLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2NetworkLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2NetworkLoop2.setDescription("Pulse Attenuation on LOOP 2 of doubler 2's network side.")
ctWanHDSLPulseAttenuationDb2CustomerLoop1 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2CustomerLoop1.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2CustomerLoop1.setDescription("pulse Attenuation on LOOP 1 of doubler 2's customer side.")
ctWanHDSLPulseAttenuationDb2CustomerLoop2 = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 3, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2CustomerLoop2.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLPulseAttenuationDb2CustomerLoop2.setDescription("Pulse Attenuation on LOOP 2 of doubler 2's customer side.")
ctWanHDSLTestTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4), )
if mibBuilder.loadTexts: ctWanHDSLTestTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLTestTable.setDescription('Test result for the HDSL line, the current test results only\n             apply to the local line unit. ')
ctWanHDSLTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLTestHLUConnIndex"))
if mibBuilder.loadTexts: ctWanHDSLTestEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLTestEntry.setDescription('Entries of the HDSL test results table.')
ctWanHDSLTestHLUConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLTestHLUConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLTestHLUConnIndex.setDescription('Identify the slot of the HDSL within the device that the user\n             wants to conduct the line unit test. Slot number start from \n             1 to maximum slots available in the device.')
ctWanHDSLTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctWanHDSLTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLTestMode.setDescription("This object may only be successfully set on a master device.\n             When this object is set, the local unit's test mode is\n             defined by these values when set:\n\n                1 - Normal operation\n                3 - Self test mode\n                4 - PROM check test\n                5 - External RAM test\n                6 - DS1 loop test\n                7 - MUX-DMUX test\n                9 - Analog loopback mode\n               13 - Transceiver mode\n             \n             When getting this object, the value returned represents\n             the last value this object had been set to.")
ctWanHDSLHLUTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHLUTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHLUTestResult.setDescription('Test result for the local line unit (1 - test failed, 0 - success):\n                 bit 0 - 2180 DS1 frame sync test (HiGain only)\n                     1 - 2180 DS1 data test (HiGain only)\n                     2 - LIU DS1 frame sync test (HiGain only)\n                     3 - LIU DS1 data test (HiGain only)\n                     4 - External DS1 frame sync test (HiGain only)\n                     5 - External DS1 data test.\n                     6 - Mux sync test on HDSL LOOP 1\n                     7 - Mux sync test on HDSL LOOP 2\n                     8 - Reserved.\n                     9 - Mux frame error test on HDSL LOOP 1\n                    10 - Mux frame error test on HDSL LOOP 2\n                    11 - Mux CRC test on HDSL LOOP 1\n                    12 - Mux CRC test on HDSL LOOP 2\n                    13 - Mux DL test on HDSL LOOP 1\n                    14 - Mux DL test on HDSL LOOP 2\n                    15 - Analog loopback test.\n                    16 - Digital loop test.\n                    17 - HGF HDSL loop test (HiGain only)\n                    18 - HGF write/readback test (HiGain only)\n                    19 - HGF poll lock test (HiGain only).\n                    20 - HGF activity monitor test (HiGain only).\n                    21 - HGF zeroes TX and detect test (HiGain only).\n                    22 - HGF ones TX and detect test (HiGain only).\n                    23 - Transceiver poll test on HDSL LOOP 1\n                    24 - Transceiver poll test on HDSL LOOP 2\n                    25 - PROM check test.\n                    26 - External RAM test.\n                    27 - Non-Volatile RAM test.\n             ')
ctWanHDSLHRUTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLHRUTestResult.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLHRUTestResult.setDescription('Test results for the remote line unit,\n             Bit definitions correspond to those defined for\n             ctWanHDSLHLUTestResult. ')
ctWanHDSLAlarmsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 5), )
if mibBuilder.loadTexts: ctWanHDSLAlarmsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmsTable.setDescription('This table collects the existing alarms information for the HDSL\n             line, including the local, remote line units and the doublers.')
ctWanHDSLAlarmsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 5, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLAlarmsHLUConnIndex"))
if mibBuilder.loadTexts: ctWanHDSLAlarmsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmsEntry.setDescription('Entries for the ctWanHDSL alarms information')
ctWanHDSLAlarmsHLUConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlarmsHLUConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmsHLUConnIndex.setDescription('Identify which HDSL connection within the device that\n             the user wants to retrieve the alarm information.')
ctWanHDSLAlarmsBackplane = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlarmsBackplane.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmsBackplane.setDescription("Specific information that's related to the HDSL alarms, each bit\n             in the two bytes value has the following meaning if set: \n\n             Bit 0 : Local Loss of Signal on DS1 line (HiGain only).\n                 1 : Remote Loss of Signal on DS1 list (HiGain only).\n                 2 - 7 : reserved.\n                 8 : Loss of Sync word on LOOP 1 of the local line unit.\n                 9 : Loss of Sync word on LOOP 2 of the local line unit. \n                10  : Loss of Sync word on LOOP 1 of the first doubler.\n                11 : Loss of sync word on LOOP 2 of the first doubler.\n                12 : Loss of Sync word on LOOP 1 of the second doubler.\n                13 : Loss of sync word on LOOP 2 of the second doubler.")
ctWanHDSLAlarmsES = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlarmsES.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmsES.setDescription("A two bytes value for the Errored Second indication of the HDSL \n             line unit, including local, remote line units and the doublers.\n             each bit in the two bytes value has the following meaning if set: \n\n             Bit 0 : Errored Second on LOOP 1 of local line unit.\n                 1 : Errored Second on LOOP 2 of local line unit. \n                 2 : Errored Second on LOOP 1 of remote line unit.\n                 3 : Errored Second on LOOP 2 of remote line unit.  \n                 4 : Errored Second on LOOP 1 of local line unit's network side.\n                 5 : Errored Second on LOOP 2 of local line unit's network side.\n                 6 : Errored Second on LOOP 1 of local line unit's customer side.\n                 7 : Errored Second on LOOP 2 of local line unit's customer side.")
ctWanHDSLAlarmHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6), )
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryTable.setDescription('HDSL Alarm History table. This table provides the accumulated \n             counts of Errored Seconds (ES) and Loss of Sync words (LOS)\n             as well as the time stamp of the above events occurred for both\n             of the HDSL loops.\n\n             The time stamps show the date in MMDDYYYYHHMM format.')
ctWanHDSLAlarmHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLAlarmHistoryConnIndex"))
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryEntry.setDescription('Entries in the Alarm History table')
ctWanHDSLAlarmHistoryConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlarmHistoryConnIndex.setDescription("Defines which HDSL connection's alarm history within the\n             device.")
ctWanHDSLAlHistLLOSFirst = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSFirst.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSFirst.setDescription('Time stamp of the first time the DS1 Loss Of Signal (LOS) \n             occurred on the local side of the HDSL.')
ctWanHDSLAlHistLLOSLast = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSLast.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSLast.setDescription('Time stamp of the last time the DS1 Loss Of Signal (LOS) \n             occurred on the local side of the HDSL.')
ctWanHDSLAlHistLLOSCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSCurrent.setDescription('Set if the DS1 Loss Of Signal (LOS) still occurred on the \n             local side of the HDSL.')
ctWanHDSLAlHistLLOSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLLOSCount.setDescription('Number of times the DS1 Loss Of Signal (LOS) occurred since \n             we last cleared the alarm history on the local side of the HDSL. \n             (HiGain only)')
ctWanHDSLAlHistRLOSFirst = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSFirst.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSFirst.setDescription('Time stamp of the first time  the DS1 Loss Of Signal (LOS) \n             occurred on the remote side of the HDSL. (HiGain only)')
ctWanHDSLAlHistRLOSLast = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSLast.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSLast.setDescription('Time stamp of the last time the DS1 Loss Of Signal (LOS) occurred\n             on the remote side of the HDSL. (HiGain only)')
ctWanHDSLAlHistRLOSCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSCurrent.setDescription('Set if the DS1 Loss Of Signal (LOS) still occurred on the remote \n             site of the HDSL. (HiGain only)')
ctWanHDSLAlHistRLOSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSCount.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistRLOSCount.setDescription('Number of times the DS1 Loss Of Signal (LOS) occurred since we \n             last cleared the alarm history on the remote site of the HDSL. \n             (HiGain only)')
ctWanHDSLAlHistLOSW1First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1First.setDescription('Time stamp of the first time the Loss Of Sync Word (LOSW) occurred\n             on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistLOSW1Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Last.setDescription('Time stamp of the last time the Loss Of Sync Word (LOSW) occurred\n             on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistLOSW1Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Current.setDescription('Set if the Loss Of Sync Word (LOSW) still occurred on the LOOP 1 \n             of the HDSL link.')
ctWanHDSLAlHistLOSW1Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW1Count.setDescription('Number of times the Loss Of Sync Word (LOSW) occurred since we \n             last cleared the history on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistLOSW2First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2First.setDescription('Time stamp of the first time the Loss Of Sync Word (LOSW) occurred\n             on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistLOSW2Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Last.setDescription('Time stamp of the last time the Loss Of Sync Word (LOSW) occurred\n             on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistLOSW2Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Current.setDescription('Set if the Loss Of Sync Word (LOSW) still occurred on the LOOP 2 \n             of the HDSL link.')
ctWanHDSLAlHistLOSW2Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistLOSW2Count.setDescription('Number of times the Loss Of Sync Word (LOSW) occurred since we \n             last cleared the history on the LOOP 2 of the HDSL link. ')
ctWanHDSLAlHistES1First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES1First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES1First.setDescription('Time stamp of the first time the Errored Seconds (ES) occurred\n             on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistES1Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Last.setDescription('Time stamp of the last time the Errored Seconds (ES) occurred\n             on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistES1Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Current.setDescription('Set if the Errored Seconds (ES) still occurred on the LOOP 1 of \n             the HDSL link.')
ctWanHDSLAlHistES1Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES1Count.setDescription('Number of times the Errored Seconds (ES) occurred since we last\n             cleared the alarm history on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistES2First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES2First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES2First.setDescription('Time stamp of the first time the Errored Seconds (ES) occurred\n             on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistES2Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Last.setDescription('Time stamp of the last time the Errored Seconds (ES) occurred\n             on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistES2Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Current.setDescription('Set if the Errored Seconds (ES) still occurred on the LOOP 2 of \n             the HDSL link.')
ctWanHDSLAlHistES2Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistES2Count.setDescription('Number of times the Errored Seconds (ES) occurred since we last\n             cleared the history on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistMargin1First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1First.setDescription('Time stamp of the first time the alarms exceeded the \n             Margin Threshold on LOOP 1 of the HDSL link.')
ctWanHDSLAlHistMargin1Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Last.setDescription('Time stamp of the last time the alarms exceeded the Margin\n             Threshold  on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistMargin1Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Current.setDescription('Set if the alarms still exceeded the Margin Threshold\n             on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistMargin1Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin1Count.setDescription('Number of times the alarm exceeded the Margin Threshold since \n             we last cleared the alarm history on the LOOP 1 of the HDSL link.')
ctWanHDSLAlHistMargin2First = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2First.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2First.setDescription('Time stamp of the first time the alarms exceeded the Margin\n             Threshold on LOOP 2 of the HDSL link.')
ctWanHDSLAlHistMargin2Last = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Last.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Last.setDescription('Time stamp of the last time  the alarms exceeded the Margin \n             Threshold  on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistMargin2Current = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Current.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Current.setDescription('Set if the alarms still exceeded the Margin Threshold\n             on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistMargin2Count = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Count.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistMargin2Count.setDescription('Number of times the alarm exceeded the Margin Threshold since\n             we last cleared the alarm history on the LOOP 2 of the HDSL link.')
ctWanHDSLAlHistCleared = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLAlHistCleared.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistCleared.setDescription('Time stamp of the time user requested to clear the alarm history.')
ctWanHDSLAlHistClearit = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 6, 1, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctWanHDSLAlHistClearit.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLAlHistClearit.setDescription('set to a 1 to  clear the alarm history.\n             A read of this value always returns a 1.\n\n             NOTE: the setting of this object also causes the SNR low\n             value, SNR high value, and the performance history to be\n             reset.')
ctWanHDSLLoopbacksTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 7), )
if mibBuilder.loadTexts: ctWanHDSLLoopbacksTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLLoopbacksTable.setDescription('HDSL Loopback table. This table provides the certain loopback \n            settings for the HDSL link.')
ctWanHDSLLoopbacksEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 7, 1), ).setIndexNames((0, "CTRON-WAN-MIB", "ctWanHDSLLoopbacksHLUConnIndex"))
if mibBuilder.loadTexts: ctWanHDSLLoopbacksEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLLoopbacksEntry.setDescription('Entries in the HDSL Loopback table.')
ctWanHDSLLoopbacksHLUConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLLoopbacksHLUConnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLLoopbacksHLUConnIndex.setDescription('Identify the HDSL connection within the device')
ctWanHDSLLoopbacksAdminType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 7, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctWanHDSLLoopbacksAdminType.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLLoopbacksAdminType.setDescription('This is the requested loopback type for the HDSL.\n\n             loopbacks setting:\n                 1 : Smartjack - loopback to network at remote line unit. \n                 2 : Loopback to network at local line unit. \n                 3 : Loopback to network at remote line unit. \n                 4 : Loopback to customer at local line unit. \n                 5 : Loopback to customer at remote line unit. \n                 6 : Loopback to customer at first doubler.\n                 7 : Loopback to customer at second doubler. \n                 8 : Loopback to network at first doubler.\n                 9 : Loopback to network at second doubler.\n                 10: No loopback (turn loopback off). ')
ctWanHDSLLoopbacksOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 7, 1, 8, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctWanHDSLLoopbacksOperType.setStatus('mandatory')
if mibBuilder.loadTexts: ctWanHDSLLoopbacksOperType.setDescription('This is the operational loopback type for the HDSL.\n\n             loopbacks setting:\n                 1 : Smartjack - loopback to network at remote line unit. \n                 2 : Loopback to network at local line unit. \n                 3 : Loopback to network at remote line unit. \n                 4 : Loopback to customer at local line unit. \n                 5 : Loopback to customer at remote line unit. \n                 6 : Loopback to customer at first doubler.\n                 7 : Loopback to customer at second doubler. \n                 8 : Loopback to network at first doubler.\n                 9 : Loopback to network at second doubler.\n                 10: No loopback (turn loopback off). ')
mibBuilder.exportSymbols("CTRON-WAN-MIB", wanDs1ExtensionsBertCurrentResults=wanDs1ExtensionsBertCurrentResults, ctWanHDSLDb2NetworkLoop2UAS24h=ctWanHDSLDb2NetworkLoop2UAS24h, ctWanHDSLSNRHighDb2NetworkLoop1=ctWanHDSLSNRHighDb2NetworkLoop1, wanDs1ExtensionsBertCumulativeResults=wanDs1ExtensionsBertCumulativeResults, ctWanHDSLSNRLowDb1NetworkLoop1=ctWanHDSLSNRLowDb1NetworkLoop1, ctWanHDSLAlHistLLOSCount=ctWanHDSLAlHistLLOSCount, ctWanHDSLAlHistMargin1Last=ctWanHDSLAlHistMargin1Last, ctWanRs232=ctWanRs232, ddsLineMode=ddsLineMode, ctWanHDSLDb2NetworkLoop2ES24h=ctWanHDSLDb2NetworkLoop2ES24h, ctWanHDSLSNRHighHLULoop1=ctWanHDSLSNRHighHLULoop1, ipPQAddressEntry=ipPQAddressEntry, ctWanHDSLSNRLowDb2CustomerLoop1=ctWanHDSLSNRLowDb2CustomerLoop1, wanConnNumPhysPorts=wanConnNumPhysPorts, ctWanHDSLDb2NetworkLoop1ES15m=ctWanHDSLDb2NetworkLoop1ES15m, ctWanHDSLSNRDb2CustomerLoop1=ctWanHDSLSNRDb2CustomerLoop1, ctWanHDSLAlHistES2Last=ctWanHDSLAlHistES2Last, ctWanHDSLPulseAttenuationHRULoop2=ctWanHDSLPulseAttenuationHRULoop2, ctWanHDSLAlHistLOSW1First=ctWanHDSLAlHistLOSW1First, ctWanHDSLHRULoop2ES24h=ctWanHDSLHRULoop2ES24h, wanInterfaceEntryCompRatio=wanInterfaceEntryCompRatio, wanDs1ExtensionsEntryIndex=wanDs1ExtensionsEntryIndex, ctWanHDSLPulseAttenuationHRULoop1=ctWanHDSLPulseAttenuationHRULoop1, ctWanHDSLAlarmsEntry=ctWanHDSLAlarmsEntry, ds1AlarmBPVErrorRate=ds1AlarmBPVErrorRate, ctWanHDSLDb2CustomerLoop2UAS15m=ctWanHDSLDb2CustomerLoop2UAS15m, wanConnEntry=wanConnEntry, wanDs1ExtensionsTable=wanDs1ExtensionsTable, ds1AlarmAdmin=ds1AlarmAdmin, wanInterfaceEntryIfIndex=wanInterfaceEntryIfIndex, ds1AlarmBPVInterval=ds1AlarmBPVInterval, ctWanHDSLSNRHighDb1CustomerLoop2=ctWanHDSLSNRHighDb1CustomerLoop2, ctWanHDSLPulseAttenuationDb1NetworkLoop1=ctWanHDSLPulseAttenuationDb1NetworkLoop1, wanInterfaceEntryIndex=wanInterfaceEntryIndex, wanInterfacePhysPortIndex=wanInterfacePhysPortIndex, wanConnIndex=wanConnIndex, ddsLineCoding=ddsLineCoding, ctWanHDSLAlHistCleared=ctWanHDSLAlHistCleared, wanRs232ExtensionsTable=wanRs232ExtensionsTable, ctWanHDSLAlHistES2Count=ctWanHDSLAlHistES2Count, wanInterfaceEntryLexProtocolEnable=wanInterfaceEntryLexProtocolEnable, wanRs232ExtensionsCTSEnable=wanRs232ExtensionsCTSEnable, ctWanHDSLPerformance24hConnIndex=ctWanHDSLPerformance24hConnIndex, wanDs1ExtensionsTotalValidIntervals=wanDs1ExtensionsTotalValidIntervals, ctWanHDSLSNRHRULoop1=ctWanHDSLSNRHRULoop1, ctWanHDSLDb1CustomerLoop2ES24h=ctWanHDSLDb1CustomerLoop2ES24h, ctWanHDSLAlHistRLOSFirst=ctWanHDSLAlHistRLOSFirst, ctWanHDSLAlHistLOSW1Last=ctWanHDSLAlHistLOSW1Last, ctWanHDSLAlHistLOSW1Count=ctWanHDSLAlHistLOSW1Count, ctWanHDSLSNRDb2NetworkLoop2=ctWanHDSLSNRDb2NetworkLoop2, ctWanHDSLPulseAttenuationDb2CustomerLoop1=ctWanHDSLPulseAttenuationDb2CustomerLoop1, frDcpCircuitEnable=frDcpCircuitEnable, ctWanHDSLSNRLowDb2CustomerLoop2=ctWanHDSLSNRLowDb2CustomerLoop2, ctWanHDSLPulseAttenuationDb1CustomerLoop1=ctWanHDSLPulseAttenuationDb1CustomerLoop1, ctIPPQFilters=ctIPPQFilters, ctWanHDSLDb1CustomerLoop1ES15m=ctWanHDSLDb1CustomerLoop1ES15m, wanInterfaceEntryMTU=wanInterfaceEntryMTU, ctWanHDSLPerformance24hTable=ctWanHDSLPerformance24hTable, ctWanHDSLStatisticsEntry=ctWanHDSLStatisticsEntry, wanDs1ExtensionsBertTestTraps=wanDs1ExtensionsBertTestTraps, ctWanHDSLSNRHighHLULoop2=ctWanHDSLSNRHighHLULoop2, wanInterfaceEntryProtocol=wanInterfaceEntryProtocol, ctWanHDSLDb1CustomerLoop2ES15m=ctWanHDSLDb1CustomerLoop2ES15m, ctWanHDSLAlHistLOSW2First=ctWanHDSLAlHistLOSW2First, ctWanHDSLAlHistES1Last=ctWanHDSLAlHistES1Last, wanConnTable=wanConnTable, ctWanHDSLDb2NetworkLoop1UAS15m=ctWanHDSLDb2NetworkLoop1UAS15m, ctWanHDSLAlarmsTable=ctWanHDSLAlarmsTable, ctWanHDSLAlHistLLOSCurrent=ctWanHDSLAlHistLLOSCurrent, ctWanHDSLDb2CustomerLoop1UAS15m=ctWanHDSLDb2CustomerLoop1UAS15m, ctWanHDSLSNRDb1CustomerLoop2=ctWanHDSLSNRDb1CustomerLoop2, ds1PhysNum=ds1PhysNum, ctWanHDSLAlarmHistoryEntry=ctWanHDSLAlarmHistoryEntry, ctWanHDSLDb1NetworkLoop2ES15m=ctWanHDSLDb1NetworkLoop2ES15m, ctWanHDSLPerformance15mConnIndex=ctWanHDSLPerformance15mConnIndex, ctWanHDSLHLULoop1UAS24h=ctWanHDSLHLULoop1UAS24h, ctWanHDSLAlarmsHLUConnIndex=ctWanHDSLAlarmsHLUConnIndex, frDcpCircuitTable=frDcpCircuitTable, ctWanHDSLAlHistLOSW2Count=ctWanHDSLAlHistLOSW2Count, wanDs1ExtensionsBertSamplePeriod=wanDs1ExtensionsBertSamplePeriod, wanRs232ExtensionsDSREnable=wanRs232ExtensionsDSREnable, ctWanHDSLHLULoop2ES24h=ctWanHDSLHLULoop2ES24h, ctWanHDSLLoopbacksHLUConnIndex=ctWanHDSLLoopbacksHLUConnIndex, wanDs1ExtensionsBertDataStatus=wanDs1ExtensionsBertDataStatus, ctWanHDSLSNRDb2NetworkLoop1=ctWanHDSLSNRDb2NetworkLoop1, wanPhysPortConnectionIndex=wanPhysPortConnectionIndex, ctWanHDSLAlHistLLOSLast=ctWanHDSLAlHistLLOSLast, wanInterfaceConnectionIndex=wanInterfaceConnectionIndex, ddsLineStatus=ddsLineStatus, ctWanHDSLSNRLowHRULoop1=ctWanHDSLSNRLowHRULoop1, ctWanHDSLDb1CustomerLoop2UAS15m=ctWanHDSLDb1CustomerLoop2UAS15m, wanDs1ExtensionsToggleFracTable=wanDs1ExtensionsToggleFracTable, wanDs1ExtensionsBertPeakResults=wanDs1ExtensionsBertPeakResults, Index=Index, wanNumConnections=wanNumConnections, wanInterfaceEntryCompression=wanInterfaceEntryCompression, ipPQIPAddress=ipPQIPAddress, ctWanHDSLAlarmsES=ctWanHDSLAlarmsES, wanDs1ExtensionsBertNumPeriods=wanDs1ExtensionsBertNumPeriods, ctWanHDSLSNRLowDb1CustomerLoop1=ctWanHDSLSNRLowDb1CustomerLoop1, ctWanHDSLAlarmHistoryTable=ctWanHDSLAlarmHistoryTable, ctWanHDSLHLULoop1ES24h=ctWanHDSLHLULoop1ES24h, ctWanHDSLDb1NetworkLoop1ES24h=ctWanHDSLDb1NetworkLoop1ES24h, ctWanHDSLSNRDb1NetworkLoop1=ctWanHDSLSNRDb1NetworkLoop1, ctWanHDSLAlHistMargin1Current=ctWanHDSLAlHistMargin1Current, ctWanHDSLPulseAttenuationHLULoop1=ctWanHDSLPulseAttenuationHLULoop1, ctWanHDSLLoopbacksEntry=ctWanHDSLLoopbacksEntry, ctWanHDSLDb1NetworkLoop1UAS15m=ctWanHDSLDb1NetworkLoop1UAS15m, ctWanHDSLAlHistRLOSCount=ctWanHDSLAlHistRLOSCount, ctWanHDSLStatisticsTable=ctWanHDSLStatisticsTable, ctWanHDSLPulseAttenuationDb2NetworkLoop1=ctWanHDSLPulseAttenuationDb2NetworkLoop1, ctWanHDSLHRUTestResult=ctWanHDSLHRUTestResult, ctWanHDSLHLULoop2UAS15m=ctWanHDSLHLULoop2UAS15m, wanDs1ExtensionsBertRun=wanDs1ExtensionsBertRun, iPPQNumEntries=iPPQNumEntries, ctWanHDSLDb2CustomerLoop1UAS24h=ctWanHDSLDb2CustomerLoop1UAS24h, ctWanHDSLSNRDb1CustomerLoop1=ctWanHDSLSNRDb1CustomerLoop1, ctWanHDSLAlHistLOSW2Last=ctWanHDSLAlHistLOSW2Last, ddsTxClockSource=ddsTxClockSource, ds1AlarmGlobalESInterval=ds1AlarmGlobalESInterval, ctWanHDSLSNRLowDb1CustomerLoop2=ctWanHDSLSNRLowDb1CustomerLoop2, ctWanHDSLAlHistMargin1First=ctWanHDSLAlHistMargin1First, iPPQAddAddress=iPPQAddAddress, ctWanHDSLSNRHighDb1NetworkLoop2=ctWanHDSLSNRHighDb1NetworkLoop2, wanConnDefaultPhysPort=wanConnDefaultPhysPort, ctWanHDSLAlHistES1Current=ctWanHDSLAlHistES1Current, wanDs1ExtensionsNumInterfaces=wanDs1ExtensionsNumInterfaces, ctWanHDSLSNRHighHRULoop2=ctWanHDSLSNRHighHRULoop2, ctWanHDSLDs1FrameHRU=ctWanHDSLDs1FrameHRU, ctWanConnection=ctWanConnection, ctWanHDSLDb2NetworkLoop2UAS15m=ctWanHDSLDb2NetworkLoop2UAS15m, ctWanHDSLAlHistMargin2First=ctWanHDSLAlHistMargin2First, wanDs1ExtensionsCFADuration=wanDs1ExtensionsCFADuration, wanInterfaceEntryCrcLength=wanInterfaceEntryCrcLength, ctWanHDSLPerformance15mSlotIndex=ctWanHDSLPerformance15mSlotIndex, ds1AlarmGlobalTrapEnable=ds1AlarmGlobalTrapEnable, ctWanHDSLDb2CustomerLoop2ES24h=ctWanHDSLDb2CustomerLoop2ES24h, ddsLineIndex=ddsLineIndex, ctWanHDSLHRULoop1ES15m=ctWanHDSLHRULoop1ES15m, ctWanDs1=ctWanDs1, ctWanHDSLHLULoop1UAS15m=ctWanHDSLHLULoop1UAS15m, ctWanHDSLAlHistMargin1Count=ctWanHDSLAlHistMargin1Count, frDcpCircuitStatus=frDcpCircuitStatus, wanDs1ExtensionsBertTestPattern=wanDs1ExtensionsBertTestPattern, ctWanHDSLAlHistLOSW2Current=ctWanHDSLAlHistLOSW2Current, ddsIfIndex=ddsIfIndex, ctWanHDSLPulseAttenuationDb2CustomerLoop2=ctWanHDSLPulseAttenuationDb2CustomerLoop2, ctWanHDSLDb1NetworkLoop1ES15m=ctWanHDSLDb1NetworkLoop1ES15m, ds1AlarmsGlobalConfigGroup=ds1AlarmsGlobalConfigGroup, ctWanHDSLDb2CustomerLoop1ES15m=ctWanHDSLDb2CustomerLoop1ES15m, wanPhysPortIndex=wanPhysPortIndex, ctWanHDSLSNRLowHRULoop2=ctWanHDSLSNRLowHRULoop2, ctWanHDSLSNRDb2CustomerLoop2=ctWanHDSLSNRDb2CustomerLoop2, ds1AlarmConfigTable=ds1AlarmConfigTable, ds1AlarmAutoRecovery=ds1AlarmAutoRecovery, wanInterfaceEntryLineCoding=wanInterfaceEntryLineCoding, ctWanHDSLHRULoop2ES15m=ctWanHDSLHRULoop2ES15m, wanRs232ExtensionsEntry=wanRs232ExtensionsEntry, ctWanHDSLDb2CustomerLoop2ES15m=ctWanHDSLDb2CustomerLoop2ES15m, ctWanHDSLTestMode=ctWanHDSLTestMode, ctDs1Alarms=ctDs1Alarms, ctWanHDSLHLULoop1ES15m=ctWanHDSLHLULoop1ES15m, ds1AlarmGlobalManualRecovery=ds1AlarmGlobalManualRecovery, wanDs1ExtensionsLineBuildOut=wanDs1ExtensionsLineBuildOut, ds1AlarmManualRecovery=ds1AlarmManualRecovery, ctWanHDSLDb1NetworkLoop2UAS15m=ctWanHDSLDb1NetworkLoop2UAS15m, ctWanHDSLDb2NetworkLoop2ES15m=ctWanHDSLDb2NetworkLoop2ES15m, ctWanHDSLSNRHighDb1NetworkLoop1=ctWanHDSLSNRHighDb1NetworkLoop1, ctWanHDSLAlHistRLOSLast=ctWanHDSLAlHistRLOSLast, ctWanHDSLAlHistES1Count=ctWanHDSLAlHistES1Count, wanInterfaceEntryBackUpIfEnable=wanInterfaceEntryBackUpIfEnable, ctWanHDSLPerformance24hSlotIndex=ctWanHDSLPerformance24hSlotIndex, wanConnActivePhysPort=wanConnActivePhysPort, ddsPortOutSpeed=ddsPortOutSpeed, ctWanHDSLHRULoop1UAS24h=ctWanHDSLHRULoop1UAS24h, ctWanHDSLDb1NetworkLoop1UAS24h=ctWanHDSLDb1NetworkLoop1UAS24h, ds1AlarmConfigEntry=ds1AlarmConfigEntry, ctWanHDSLHRULoop2UAS24h=ctWanHDSLHRULoop2UAS24h, ctWanHDSLDb1NetworkLoop2UAS24h=ctWanHDSLDb1NetworkLoop2UAS24h, ctWanHDSLLoopbacksAdminType=ctWanHDSLLoopbacksAdminType, wanDs1ExtensionsBertTestMode=wanDs1ExtensionsBertTestMode, ds1AlarmGlobalBPVInterval=ds1AlarmGlobalBPVInterval, ctWanHDSLPulseAttenuationHLULoop2=ctWanHDSLPulseAttenuationHLULoop2, ctWanHDSLTestHLUConnIndex=ctWanHDSLTestHLUConnIndex, ddsLoopbackConfig=ddsLoopbackConfig, ddsConfigTable=ddsConfigTable, ctWanHDSLHRULoop1UAS15m=ctWanHDSLHRULoop1UAS15m, ctWanHDSLSNRHighDb2NetworkLoop2=ctWanHDSLSNRHighDb2NetworkLoop2, ctWanHDSLHLUTestResult=ctWanHDSLHLUTestResult, ctWanHDSLBitStat1HLU=ctWanHDSLBitStat1HLU, ipPQAddressTable=ipPQAddressTable, ctWanHDSLAlHistMargin2Count=ctWanHDSLAlHistMargin2Count, frDcpCircuitRatio=frDcpCircuitRatio, ctWanHDSLDb2NetworkLoop1UAS24h=ctWanHDSLDb2NetworkLoop1UAS24h, wanPhysPortTable=wanPhysPortTable, frDcpCircuitEntry=frDcpCircuitEntry, wanInterfaceTable=wanInterfaceTable, ctWanHDSLHLULoop2UAS24h=ctWanHDSLHLULoop2UAS24h, ctWanHDSLDb2CustomerLoop2UAS24h=ctWanHDSLDb2CustomerLoop2UAS24h, ctWanHDSLSNRHighDb1CustomerLoop1=ctWanHDSLSNRHighDb1CustomerLoop1, ctWanHDSLPulseAttenuationDb1NetworkLoop2=ctWanHDSLPulseAttenuationDb1NetworkLoop2, ctWanHDSLAlHistES2First=ctWanHDSLAlHistES2First, ctFrDcp=ctFrDcp, ctDDS=ctDDS, wanDs1ExtensionsDIEnable=wanDs1ExtensionsDIEnable, ctWanHDSLSNRLowDb2NetworkLoop2=ctWanHDSLSNRLowDb2NetworkLoop2, ctWanHDSLPerformance15mTable=ctWanHDSLPerformance15mTable, ctWanHDSLAlarmsBackplane=ctWanHDSLAlarmsBackplane, frDcpCircuitDlci=frDcpCircuitDlci, wanRs232ExtensionsEntryIndex=wanRs232ExtensionsEntryIndex, ds1AlarmGlobalESCount=ds1AlarmGlobalESCount, ctWanHDSLSNRLowDb1NetworkLoop2=ctWanHDSLSNRLowDb1NetworkLoop2, wanInterfaceEntryLexProtocolStatus=wanInterfaceEntryLexProtocolStatus, ipPQConfigGroup=ipPQConfigGroup, ctWanHDSLSNRHLULoop2=ctWanHDSLSNRHLULoop2, wanPhysPortEntry=wanPhysPortEntry, ds1AlarmGlobalAutoRecovery=ds1AlarmGlobalAutoRecovery, ctWanHDSLSNRLowHLULoop2=ctWanHDSLSNRLowHLULoop2, ctWanHDSLAlHistES2Current=ctWanHDSLAlHistES2Current, wanDs1ExtensionsBertAverageResult=wanDs1ExtensionsBertAverageResult, ctWanHDSLHLULoop2ES15m=ctWanHDSLHLULoop2ES15m, wanDs1ExtensionsEntry=wanDs1ExtensionsEntry, wanInterfaceEntryCompStatus=wanInterfaceEntryCompStatus, ddsPortInSpeed=ddsPortInSpeed, ctWanHDSLDb1CustomerLoop1UAS24h=ctWanHDSLDb1CustomerLoop1UAS24h, ctWanHDSLDb1CustomerLoop1UAS15m=ctWanHDSLDb1CustomerLoop1UAS15m, ctWanHDSLAlarmHistoryConnIndex=ctWanHDSLAlarmHistoryConnIndex, ctWanHDSLPulseAttenuationDb1CustomerLoop2=ctWanHDSLPulseAttenuationDb1CustomerLoop2, ctWanHDSLSNRHighHRULoop1=ctWanHDSLSNRHighHRULoop1, ctWanHDSLDb2NetworkLoop1ES24h=ctWanHDSLDb2NetworkLoop1ES24h, ctWanHDSLLoopbacksTable=ctWanHDSLLoopbacksTable, ctWanHDSLAlHistLLOSFirst=ctWanHDSLAlHistLLOSFirst, ds1AlarmGlobalBPVErrorRate=ds1AlarmGlobalBPVErrorRate, wanPhysPortSpecificMib=wanPhysPortSpecificMib, ctWanHDSLTestTable=ctWanHDSLTestTable, ds1AlarmESInterval=ds1AlarmESInterval, ctWanHDSLHRULoop1ES24h=ctWanHDSLHRULoop1ES24h, ctWanHDSLStatisticsHLUConnIndex=ctWanHDSLStatisticsHLUConnIndex, frDcpCircuitIfIndex=frDcpCircuitIfIndex, ctWanHDSLDb1CustomerLoop2UAS24h=ctWanHDSLDb1CustomerLoop2UAS24h, ctWanHDSLSNRDb1NetworkLoop2=ctWanHDSLSNRDb1NetworkLoop2, ctWanHDSLLoopbacksOperType=ctWanHDSLLoopbacksOperType, ctWanHDSLPulseAttenuationDb2NetworkLoop2=ctWanHDSLPulseAttenuationDb2NetworkLoop2, ctWanHDSLSNRHLULoop1=ctWanHDSLSNRHLULoop1, ctWanHDSLDb2CustomerLoop1ES24h=ctWanHDSLDb2CustomerLoop1ES24h, ctWanHDSLAlHistLOSW1Current=ctWanHDSLAlHistLOSW1Current, ctWanHDSLAlHistRLOSCurrent=ctWanHDSLAlHistRLOSCurrent, wanPhysPortType=wanPhysPortType, ds1AlarmTrapEnable=ds1AlarmTrapEnable, ctWanHDSLAlHistMargin2Current=ctWanHDSLAlHistMargin2Current, ctWanHDSLExt=ctWanHDSLExt, ctWanHDSLHRULoop2UAS15m=ctWanHDSLHRULoop2UAS15m, ctWanHDSLSNRLowDb2NetworkLoop1=ctWanHDSLSNRLowDb2NetworkLoop1, ctWanHDSLDb1CustomerLoop1ES24h=ctWanHDSLDb1CustomerLoop1ES24h)
mibBuilder.exportSymbols("CTRON-WAN-MIB", DLCI=DLCI, ddsConfigEntry=ddsConfigEntry, ctWanHDSLSNRLowHLULoop1=ctWanHDSLSNRLowHLULoop1, ctWanHDSLTestEntry=ctWanHDSLTestEntry, ctWanHDSLPerformance24hEntry=ctWanHDSLPerformance24hEntry, ctWanHDSLDb1NetworkLoop2ES24h=ctWanHDSLDb1NetworkLoop2ES24h, ipPQAddressId=ipPQAddressId, ds1AlarmESCount=ds1AlarmESCount, ctWanHDSLSNRHRULoop2=ctWanHDSLSNRHRULoop2, ctWanHDSLAlHistClearit=ctWanHDSLAlHistClearit, ctWanHDSLSNRHighDb2CustomerLoop1=ctWanHDSLSNRHighDb2CustomerLoop1, ctWanHDSLSNRHighDb2CustomerLoop2=ctWanHDSLSNRHighDb2CustomerLoop2, iPPQMaxEntries=iPPQMaxEntries, ds1AlarmGlobalAdmin=ds1AlarmGlobalAdmin, ctWanHDSLPerformance15mEntry=ctWanHDSLPerformance15mEntry, ctWanHDSLAlHistMargin2Last=ctWanHDSLAlHistMargin2Last, wanInterfaceEntry=wanInterfaceEntry, iPPQDelAddress=iPPQDelAddress, ipPQAdmin=ipPQAdmin, ctWanHDSLAlHistES1First=ctWanHDSLAlHistES1First)
