#
# PySNMP MIB module CTRON-IGMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-IGMP-MIB
# Produced by pysmi-1.1.12 at Wed May 29 08:01:24 2024
# On host fv-az1024-251 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
dot1dBasePort, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePort")
ctIGMPBranch, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctIGMPBranch")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
VlanId, PortList = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "PortList")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Bits, Gauge32, ObjectIdentity, TimeTicks, Integer32, Counter32, Unsigned32, iso, ModuleIdentity, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Bits", "Gauge32", "ObjectIdentity", "TimeTicks", "Integer32", "Counter32", "Unsigned32", "iso", "ModuleIdentity", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
TextualConvention, TruthValue, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "RowStatus", "DisplayString")
ctIGMP = ModuleIdentity((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1))
ctIGMP.setRevisions(('2005-05-09 20:30', '2005-03-15 20:38', '2003-12-10 14:56',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ctIGMP.setRevisionsDescriptions((' Added the IgmpProtocolClassTc, and IgmpProtocolIdTc\n              TEXTUAL CONVENTIONS, added the \n              ctIGMPProtocolClassificationTable.', 'Deprecated the ctIGMPPolicyTable and the ctIGMPStaticTable.\n             Added ctIGMPStaticGroupTable, ctIGMPExtCacheTable,\n             ctIGMPDiscoveredRouterTable, ctIGMPPortTable, and the\n             ctIGMPStatsCntrs groups.', 'Added the ctIGMPStaticEntry Table for static multicast\n             configuration.',))
if mibBuilder.loadTexts: ctIGMP.setLastUpdated('200505092030Z')
if mibBuilder.loadTexts: ctIGMP.setOrganization('Enterasys Networks, Inc')
if mibBuilder.loadTexts: ctIGMP.setContactInfo('Postal:  Enterasys Networks\n                  50 Minuteman Rd.\n                  Andover, MA 01810-1008\n                  USA\n         Phone:   +1 978 684 1000\n         E-mail:  support@enterasys.com\n         WWW:     http://www.enterasys.com')
if mibBuilder.loadTexts: ctIGMP.setDescription('This MIB module defines a portion of the SNMP enterprise MIBs\n             under the Cabletron enterprise OID pertaining to configuration\n             of IGMP.')
class IgmpPortModeTc(TextualConvention, Integer32):
    description = 'This textual convention maps out possible igmp port modes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("reporter", 1), ("source", 2))

class IgmpProtocolClassTc(TextualConvention, Integer32):
    description = 'This textual convention describes the possible ways\n         IGMP can classify received frames.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("multicastData", 1), ("routingProtocol", 2), ("ignore", 3))

class IgmpProtocolIdTc(TextualConvention, Bits):
    description = 'Bit definitions for each of the IP protocol numbers assigned by\n         IANA.'
    status = 'current'
    namedValues = NamedValues(("hopopt", 0), ("icmp", 1), ("igmp", 2), ("ggp", 3), ("ip", 4), ("st", 5), ("tcp", 6), ("cbt", 7), ("egp", 8), ("igp", 9), ("bbnRccMon", 10), ("nvpII", 11), ("pup", 12), ("argus", 13), ("emcon", 14), ("xnet", 15), ("chaos", 16), ("udp", 17), ("mux", 18), ("dcnMeas", 19), ("hmp", 20), ("prm", 21), ("xnsIdp", 22), ("trunk1", 23), ("trunk2", 24), ("leaf1", 25), ("leaf2", 26), ("rdp", 27), ("irtp", 28), ("isoTp4", 29), ("netblt", 30), ("mfeNsp", 31), ("meritInp", 32), ("sep", 33), ("x3pc", 34), ("idpr", 35), ("xtp", 36), ("ddp", 37), ("idprCmtp", 38), ("tpPlusPlus", 39), ("il", 40), ("ipv6", 41), ("sdrp", 42), ("ipv6Route", 43), ("ipv6Frag", 44), ("idrp", 45), ("rsvp", 46), ("gre", 47), ("mhrp", 48), ("bna", 49), ("esp", 50), ("ah", 51), ("inlsp", 52), ("swipe", 53), ("narp", 54), ("mobile", 55), ("tlsp", 56), ("skip", 57), ("ipv6Icmp", 58), ("ipv6NoNxt", 59), ("ipv6Opts", 60), ("ipProt61", 61), ("cftp", 62), ("ipProt63", 63), ("satExpak", 64), ("kryptolan", 65), ("rvd", 66), ("ippc", 67), ("ipProt64", 68), ("satMon", 69), ("visa", 70), ("ipcv", 71), ("cpnx", 72), ("cphb", 73), ("wsn", 74), ("pvp", 75), ("brSatMon", 76), ("sunNd", 77), ("wbMon", 78), ("wbExpak", 79), ("isoIp", 80), ("vmtp", 81), ("secureVmtp", 82), ("vines", 83), ("ttp", 84), ("nsfnetIgp", 85), ("dgp", 86), ("tcf", 87), ("eigrp", 88), ("ospfIgp", 89), ("spriteRpc", 90), ("larp", 91), ("mtp", 92), ("ax25", 93), ("ipip", 94), ("micp", 95), ("sccSp", 96), ("etherIp", 97), ("encap", 98), ("ipProt99", 99), ("gmtp", 100), ("ifmp", 101), ("pnni", 102), ("pim", 103), ("aris", 104), ("scps", 105), ("qnx", 106), ("an", 107), ("ipComp", 108), ("snp", 109), ("compaqPeer", 110), ("ipxInIp", 111), ("vrrp", 112), ("pgm", 113), ("ipProt114", 114), ("l2tp", 115), ("ddx", 116), ("iatp", 117), ("stp", 118), ("srp", 119), ("uti", 120), ("smp", 121), ("sm", 122), ("ptp", 123), ("isisIpv4", 124), ("fire", 125), ("crtp", 126), ("crudp", 127), ("sscopmce", 128), ("iplt", 129), ("sps", 130), ("pipe", 131), ("sctp", 132), ("fc", 133), ("rsvpE2eIgn", 134), ("mobHeader", 135), ("udpLite", 136), ("mpls", 137), ("ipProto138", 138), ("ipProto139", 139), ("ipProto140", 140), ("ipProto141", 141), ("ipProto142", 142), ("ipProto143", 143), ("ipProto144", 144), ("ipProto145", 145), ("ipProto146", 146), ("ipProto147", 147), ("ipProto148", 148), ("ipProto149", 149), ("ipProto150", 150), ("ipProto151", 151), ("ipProto152", 152), ("ipProto153", 153), ("ipProto154", 154), ("ipProto155", 155), ("ipProto156", 156), ("ipProto157", 157), ("ipProto158", 158), ("ipProto159", 159), ("ipProto160", 160), ("ipProto161", 161), ("ipProto162", 162), ("ipProto163", 163), ("ipProto164", 164), ("ipProto165", 165), ("ipProto166", 166), ("ipProto167", 167), ("ipProto168", 168), ("ipProto169", 169), ("ipProto170", 170), ("ipProto171", 171), ("ipProto172", 172), ("ipProto173", 173), ("ipProto174", 174), ("ipProto175", 175), ("ipProto176", 176), ("ipProto177", 177), ("ipProto178", 178), ("ipProto179", 179), ("ipProto180", 180), ("ipProto181", 181), ("ipProto182", 182), ("ipProto183", 183), ("ipProto184", 184), ("ipProto185", 185), ("ipProto186", 186), ("ipProto187", 187), ("ipProto188", 188), ("ipProto189", 189), ("ipProto190", 190), ("ipProto191", 191), ("ipProto192", 192), ("ipProto193", 193), ("ipProto194", 194), ("ipProto195", 195), ("ipProto196", 196), ("ipProto197", 197), ("ipProto198", 198), ("ipProto199", 199), ("ipProto200", 200), ("ipProto201", 201), ("ipProto202", 202), ("ipProto203", 203), ("ipProto204", 204), ("ipProto205", 205), ("ipProto206", 206), ("ipProto207", 207), ("ipProto208", 208), ("ipProto209", 209), ("ipProto210", 210), ("ipProto211", 211), ("ipProto212", 212), ("ipProto213", 213), ("ipProto214", 214), ("ipProto215", 215), ("ipProto216", 216), ("ipProto217", 217), ("ipProto218", 218), ("ipProto219", 219), ("ipProto220", 220), ("ipProto221", 221), ("ipProto222", 222), ("ipProto223", 223), ("ipProto224", 224), ("ipProto225", 225), ("ipProto226", 226), ("ipProto227", 227), ("ipProto228", 228), ("ipProto229", 229), ("ipProto230", 230), ("ipProto231", 231), ("ipProto232", 232), ("ipProto233", 233), ("ipProto234", 234), ("ipProto235", 235), ("ipProto236", 236), ("ipProto237", 237), ("ipProto238", 238), ("ipProto239", 239), ("ipProto240", 240), ("ipProto241", 241), ("ipProto242", 242), ("ipProto243", 243), ("ipProto244", 244), ("ipProto245", 245), ("ipProto246", 246), ("ipProto247", 247), ("ipProto248", 248), ("ipProto249", 249), ("ipProto250", 250), ("ipProto251", 251), ("ipProto252", 252), ("ipProto253", 253), ("ipProto254", 254)) + NamedValues(("ipProto255", 255))

ctIGMPConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 1))
ctIGMPNewDefaultState = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPNewDefaultState.setStatus('current')
if mibBuilder.loadTexts: ctIGMPNewDefaultState.setDescription("This object defines the state in which IGMP will view new VLAN IDs \n           added to the system.  A value of Enable (1), indicates that IGMP will\n           create entries for all new VLANs in the ENABLE state.  A value of \n           Disable (2), indicates IGMP will create entries for all new VLANs in\n           the DISABLED or 'not in service' state.")
ctIGMPMibRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPMibRev.setStatus('current')
if mibBuilder.loadTexts: ctIGMPMibRev.setDescription('This object defines the revision of the IGMP MIB in the firmware.')
ctIGMPMibRevString = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPMibRevString.setStatus('current')
if mibBuilder.loadTexts: ctIGMPMibRevString.setDescription('This object is a textual representation of the revision of the IGMP\n           MIB in the firmware.')
ctIGMPConfigGroupTblFullAction = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("routers", 1), ("flood", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPConfigGroupTblFullAction.setStatus('current')
if mibBuilder.loadTexts: ctIGMPConfigGroupTblFullAction.setDescription('This object defines the behavior of IGMP when its group table\n           is full.  The user may choose to send multicast frames to\n           known routers, or flood these frames to the vlan.')
ctIGMPVlanTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2), )
if mibBuilder.loadTexts: ctIGMPVlanTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanTable.setDescription('The (conceptual) table listing the VLANs on which IGMP\n          is enabled.')
ctIGMPVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPVlanId"))
if mibBuilder.loadTexts: ctIGMPVlanEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanEntry.setDescription('An entry (conceptual row) representing a VLAN on\n          which IGMP is enabled.')
ctIGMPVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 1), VlanId())
if mibBuilder.loadTexts: ctIGMPVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanId.setDescription('The VlanId value of the Vlan for which IGMP is enabled.')
ctIGMPVlanQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 2), Integer32().clone(125)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanQueryInterval.setReference('Network Working Group RFC2236, November 1997. Section 8.2')
if mibBuilder.loadTexts: ctIGMPVlanQueryInterval.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQueryInterval.setDescription('The frequency at which IGMP Host-Query packets are\n          transmitted on this Vlan.')
ctIGMPVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanStatus.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanStatus.setDescription('The activation of a row enables IGMP on the Vlan. The\n          destruction of a row disables IGMP on the Vlan.')
ctIGMPVlanVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("version1", 1), ("version2", 2))).clone('version2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanVersion.setReference('Network Working Group RFC2236, November 1997. Section 4')
if mibBuilder.loadTexts: ctIGMPVlanVersion.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanVersion.setDescription('The version of IGMP which is running on this Vlan.\n          This object can be used to configure a switch capable of\n          either value. For IGMP to function correctly, all\n          and routers on a Vlan must be configured to run the\n          same version of IGMP on that Vlan.')
ctIGMPVlanQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPVlanQuerier.setReference('Network Working Group RFC2236, November 1997. Section 3')
if mibBuilder.loadTexts: ctIGMPVlanQuerier.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQuerier.setDescription('The address of the IGMP Querier on the Vlan to which\n          this switch is attached.')
ctIGMPVlanQueryMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanQueryMaxResponseTime.setReference('Network Working Group RFC2236, November 1997. Section 8.3')
if mibBuilder.loadTexts: ctIGMPVlanQueryMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQueryMaxResponseTime.setDescription('The maximum query response time advertised in IGMPv2\n          queries on this Vlan.')
ctIGMPVlanRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 7), Integer32().clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanRobustness.setReference('Network Working Group RFC2236, November 1997. Section 8.1')
if mibBuilder.loadTexts: ctIGMPVlanRobustness.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanRobustness.setDescription('The Robustness Variable allows tuning for the expected\n          packet loss on a Vlan. If a Vlan is expected to be\n          lossy, the Robustness Variable may be increased. IGMP is\n          robust to (Robustness Variable-1) packet losses.')
ctIGMPVlanLastMembQueryIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 8), Integer32().clone(10)).setUnits('tenths of seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanLastMembQueryIntvl.setReference('Network Working Group RFC2236, November 1997. Section 8.8')
if mibBuilder.loadTexts: ctIGMPVlanLastMembQueryIntvl.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanLastMembQueryIntvl.setDescription('The Last Member Query Interval is the Max Response Time\n          inserted into Group-Specific Queries sent in response to\n          Leave Group messages, and is also the amount of time between\n          Group-Specific Query messages. This value may be tuned to\n          modify the leave latency of the network. A reduced value\n          results in reduced time to detect the loss of the last\n          member of a group.')
ctIGMPVlanQuerierUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 9), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPVlanQuerierUpTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQuerierUpTime.setDescription('The number of seconds since ctIGMPVlanQuerier was last\n         changed.')
ctIGMPVlanQuerierExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 10), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPVlanQuerierExpiryTime.setReference('Network Working Group RFC2236, November 1997. Section 8.5')
if mibBuilder.loadTexts: ctIGMPVlanQuerierExpiryTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQuerierExpiryTime.setDescription('The number of seconds remaining before the Other Querier\n          Present Timer expires. If the local system is the querier,\n          the value of this object is zero.')
ctIGMPVlanQuerierIP = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 2, 1, 11), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPVlanQuerierIP.setReference('Network Working Group RFC2236, November 1997. Section 7')
if mibBuilder.loadTexts: ctIGMPVlanQuerierIP.setStatus('current')
if mibBuilder.loadTexts: ctIGMPVlanQuerierIP.setDescription('The source IP address used by a switch when acting as IGMP\n           querier for a Vlan. The value chosen must be in the valid\n           IP address space for any attached routed interface(s) on\n           the Vlan. A value of 0.0.0.0 indicates that the switch will\n           not act as querier for the Vlan.')
ctIGMPCacheTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3), )
if mibBuilder.loadTexts: ctIGMPCacheTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheTable.setDescription('The (conceptual) table listing the IP multicast groups for\n          vlans with members on a particular interface.')
ctIGMPCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPCacheAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPCacheVlanId"), (0, "CTRON-IGMP-MIB", "ctIGMPCacheIfIndex"))
if mibBuilder.loadTexts: ctIGMPCacheEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheEntry.setDescription('An entry (conceptual row) in the ctIGMPCacheTable.')
ctIGMPCacheAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: ctIGMPCacheAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheAddress.setDescription('The IP multicast group address for which this entry\n          contains information.')
ctIGMPCacheVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 2), VlanId())
if mibBuilder.loadTexts: ctIGMPCacheVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheVlanId.setDescription('The VlanId for which this entry contains information.')
ctIGMPCacheIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 3), InterfaceIndex())
if mibBuilder.loadTexts: ctIGMPCacheIfIndex.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheIfIndex.setDescription('The interface for which this entry contains information for\n          an IP multicast group address.')
ctIGMPCacheLastReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPCacheLastReporter.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheLastReporter.setDescription('The IP address of the source of the last membership report\n          received for this IP Multicast group address on this\n          interface. If no membership report has been received, this\n          object has the value 0.0.0.0.')
ctIGMPCacheUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPCacheUpTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheUpTime.setDescription('The time since the system joined this group address, or\n          zero if the system is not currently a member.')
ctIGMPCacheExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPCacheExpiryTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheExpiryTime.setDescription('The minimum amount of time remaining before this entry will\n          be aged out.')
ctIGMPCacheVersion1HostTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 3, 1, 7), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPCacheVersion1HostTimer.setReference('Network Working Group RFC2236, November 1997. Section 8.11')
if mibBuilder.loadTexts: ctIGMPCacheVersion1HostTimer.setStatus('current')
if mibBuilder.loadTexts: ctIGMPCacheVersion1HostTimer.setDescription('The time remaining until the local switch will assume that\n          there are no longer any IGMP version 1 members on the IP\n          subnet attached to this interface.  Upon hearing any IGMPv1\n          Membership Report, this value is reset to the group\n          membership timer.  While this time remaining is non-zero,\n          the local switch ignores any IGMPv2 Leave messages for this\n          group that it receives on this interface.')
ctIGMPPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4), )
if mibBuilder.loadTexts: ctIGMPPolicyTable.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyTable.setDescription('The (conceptual) table listing the IGMP group policy\n          for vlans with members on a particular interface.')
ctIGMPPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPPolicyAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPPolicyVlanId"), (0, "CTRON-IGMP-MIB", "ctIGMPPolicyIfIndex"))
if mibBuilder.loadTexts: ctIGMPPolicyEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyEntry.setDescription('An entry (conceptual row) in the ctigmpPolicyTable.')
ctIGMPPolicyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1, 1), IpAddress())
if mibBuilder.loadTexts: ctIGMPPolicyAddress.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyAddress.setDescription('The IP multicast group address for which this entry\n          contains information. A value of 224.0.0.0 indicates\n          all multicast groups.')
ctIGMPPolicyVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: ctIGMPPolicyVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyVlanId.setDescription('The VlanId for which this entry contains information.')
ctIGMPPolicyIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1, 3), InterfaceIndex())
if mibBuilder.loadTexts: ctIGMPPolicyIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyIfIndex.setDescription('The interface for which this entry contains information for\n          an IP multicast group address. A value of zero indicates all\n          ports.')
ctIGMPPolicyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPPolicyStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyStatus.setDescription('The activation of a row enables IGMP policy for this entry.\n           The destruction of a row disables any IGMP policy for this\n           entry.')
ctIGMPPolicyInclusion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("include", 1), ("exclude", 2))).clone('exclude')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPPolicyInclusion.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPPolicyInclusion.setDescription('The IGMP policy for this entry.')
ctIGMPStaticTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5), )
if mibBuilder.loadTexts: ctIGMPStaticTable.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticTable.setDescription('The (conceptual) table listing the static IGMP entries.')
ctIGMPStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPStaticGroupAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPStaticVlanId"))
if mibBuilder.loadTexts: ctIGMPStaticEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticEntry.setDescription('An entry (conceptual row) representing a static entry that\n         IGMP will act upon.')
ctIGMPStaticGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5, 1, 1), IpAddress())
if mibBuilder.loadTexts: ctIGMPStaticGroupAddress.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticGroupAddress.setDescription(' The IP multicast group address for IGMP to send\n         multicast data to.')
ctIGMPStaticVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: ctIGMPStaticVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticVlanId.setDescription('The VlanId for IGMP to send multicast data to.')
ctIGMPStaticOutPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPStaticOutPortList.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticOutPortList.setDescription('The set of ports configured by management for this multicast\n          group and this VLAN to which multicast group-addressed\n          data frames are to be forwarded.')
ctIGMPStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 5, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPStaticRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: ctIGMPStaticRowStatus.setDescription('The activation of a row creates a static entry.\n          The destruction of a row deletes a static entry.')
ctIGMPStaticGroupTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6), )
if mibBuilder.loadTexts: ctIGMPStaticGroupTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupTable.setDescription('The (conceptual) table listing the static IGMP entries.')
ctIGMPStaticGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPStaticGroupIPAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPStaticGroupVlanId"), (0, "CTRON-IGMP-MIB", "ctIGMPStaticGroupSourceIPAddress"))
if mibBuilder.loadTexts: ctIGMPStaticGroupEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupEntry.setDescription('An entry (conceptual row) representing a static entry that\n         IGMP will act upon.')
ctIGMPStaticGroupIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 1), IpAddress())
if mibBuilder.loadTexts: ctIGMPStaticGroupIPAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupIPAddress.setDescription('The IP multicast group address for IGMP to send\n         multicast data to.')
ctIGMPStaticGroupVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 2), VlanId())
if mibBuilder.loadTexts: ctIGMPStaticGroupVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupVlanId.setDescription('The VlanId for IGMP to send multicast data to.')
ctIGMPStaticGroupSourceIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 3), IpAddress())
if mibBuilder.loadTexts: ctIGMPStaticGroupSourceIPAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupSourceIPAddress.setDescription('The IP source address of this entry. For IGMP Version 2,\n          use 0.0.0.0')
ctIGMPStaticGroupIncludeList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPStaticGroupIncludeList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupIncludeList.setDescription('The set of ports configured by management for this multicast\n          group and this VLAN to which multicast group-addressed\n          data frames are to be forwarded.')
ctIGMPStaticGroupExcludeList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 5), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPStaticGroupExcludeList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupExcludeList.setDescription(' The set of ports configured by management for this multicast\n           group and this VLAN for which received IGMP reports will not\n           be accepted.')
ctIGMPStaticGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 6, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ctIGMPStaticGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStaticGroupRowStatus.setDescription('The activation of a row creates a static entry.\n          The destruction of a row deletes a static entry.\n          Not in service disables a static entry')
ctIGMPExtCacheTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7), )
if mibBuilder.loadTexts: ctIGMPExtCacheTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheTable.setDescription('The (conceptual) table listing the IP multicast groups for\n          vlans with members on a particular interface. This table\n          provides a version 3 capable ctIGMPCacheTable, with a bridge\n          portlist leaf vs mib2 interface index.')
ctIGMPExtCacheEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPExtCacheAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPExtCacheVlanId"), (0, "CTRON-IGMP-MIB", "ctIGMPExtCacheSourceIPAddress"))
if mibBuilder.loadTexts: ctIGMPExtCacheEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheEntry.setDescription(' An entry (conceptual row) in the ctIGMPCacheTable.')
ctIGMPExtCacheAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 1), IpAddress())
if mibBuilder.loadTexts: ctIGMPExtCacheAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheAddress.setDescription(' The IP multicast group address for this entry.')
ctIGMPExtCacheVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 2), VlanId())
if mibBuilder.loadTexts: ctIGMPExtCacheVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheVlanId.setDescription(' The VlanId for this entry')
ctIGMPExtCacheSourceIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 3), IpAddress())
if mibBuilder.loadTexts: ctIGMPExtCacheSourceIPAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheSourceIPAddress.setDescription(' The IP source address of this entry.')
ctIGMPExtCacheLastReporter = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheLastReporter.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheLastReporter.setDescription(' The IP address of the source of the last membership report\n          received for this IP Multicast group address on this\n          interface. If no membership report has been received, this\n          object has the value 0.0.0.0.')
ctIGMPExtCacheUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheUpTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheUpTime.setDescription(' The time since the system joined this group address, or\n          zero if the system is not currently a member.')
ctIGMPExtCacheExpiryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheExpiryTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheExpiryTime.setDescription(' The minimum amount of time remaining before this entry will\n          be aged out.')
ctIGMPExtCacheVersion1HostTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 7), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheVersion1HostTimer.setReference('Network Working Group RFC2236, November 1997. Section 8.11')
if mibBuilder.loadTexts: ctIGMPExtCacheVersion1HostTimer.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheVersion1HostTimer.setDescription(' The time remaining until the local switch will assume that\n          there are no longer any IGMP version 1 members on the IP\n          subnet attached to this interface.  Upon hearing any IGMPv1\n          Membership Report, this value is reset to the group\n          membership timer.  While this time remaining is non-zero,\n          the local switch ignores any IGMPv2 Leave messages for this\n          group that it receives on this interface.')
ctIGMPExtCacheOutPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 8), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheOutPortList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheOutPortList.setDescription(' The set of bridge ports for this multicast group, VLAN, and\n           source IP address, to which multicast group-addressed\n           data frames are being forwarded.')
ctIGMPExtCacheSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPExtCacheSrcPort.setStatus('current')
if mibBuilder.loadTexts: ctIGMPExtCacheSrcPort.setDescription(' The source bridge port of the multicast data stream if available')
ctIGMPDiscoveredRouterTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8), )
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterTable.setDescription('The (conceptual) table listing the routers seen on particular ports\n          of a vlan through either protocol snooping or ICMP Router Discovery.')
ctIGMPDiscoveredRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPDiscoveredRouterVlanId"))
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterEntry.setDescription('An entry representing the routers seen on particular ports on a\n          given vlan id.')
ctIGMPDiscoveredRouterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8, 1, 2), VlanId())
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterVlanId.setDescription('The VlanId for IGMP to send multicast data to.')
ctIGMPDiscoveredRouterPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8, 1, 3), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterPortList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterPortList.setDescription('The set of bridge ports that IGMP has seen routing \n          protocols, IGMP queries, or ICMP Router Discovery frames on.')
ctIGMPDiscoveredRouterEgressPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8, 1, 4), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterEgressPortList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterEgressPortList.setDescription('The set of bridge ports that IGMP believes has valid\n          egress.')
ctIGMPDiscoveredRouterStaticPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 8, 1, 5), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterStaticPortList.setStatus('current')
if mibBuilder.loadTexts: ctIGMPDiscoveredRouterStaticPortList.setDescription(' The set of bridge ports to flood all multicast frames to for\n            this vlan id. This leaf is OPTIONAL')
ctIGMPPortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9), )
if mibBuilder.loadTexts: ctIGMPPortTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTable.setDescription("The (conceptual) table listing a bridge port's bindings to multicast\n          group addresses, vlan ids, and source addresses.")
ctIGMPPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPPortMode"), (0, "BRIDGE-MIB", "dot1dBasePort"), (0, "CTRON-IGMP-MIB", "ctIGMPPortTableGroupAddress"), (0, "CTRON-IGMP-MIB", "ctIGMPPortTableVlanId"), (0, "CTRON-IGMP-MIB", "ctIGMPPortTableSourceIPAddress"))
if mibBuilder.loadTexts: ctIGMPPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTableEntry.setDescription('An entry representing the binding of bridge port to multicast group\n          address, vlan id, and source IP address.')
ctIGMPPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1, 1), IgmpPortModeTc())
if mibBuilder.loadTexts: ctIGMPPortMode.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortMode.setDescription('The mode of the given bridge port.')
ctIGMPPortTableGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1, 2), IpAddress())
if mibBuilder.loadTexts: ctIGMPPortTableGroupAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTableGroupAddress.setDescription(' The multicast group address bound to this port entry.')
ctIGMPPortTableVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1, 3), VlanId())
if mibBuilder.loadTexts: ctIGMPPortTableVlanId.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTableVlanId.setDescription(' The vlan id bound to this port entry.')
ctIGMPPortTableSourceIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1, 4), IpAddress())
if mibBuilder.loadTexts: ctIGMPPortTableSourceIPAddress.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTableSourceIPAddress.setDescription(' The IP source address bound to this port entry.')
ctIGMPPortTableExpireTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 9, 1, 5), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPPortTableExpireTime.setStatus('current')
if mibBuilder.loadTexts: ctIGMPPortTableExpireTime.setDescription(' The time in seconds that this port will expire in.')
ctIGMPStatsCntrs = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10))
ctIGMPStatsCntrsGroupFull = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsGroupFull.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsGroupFull.setDescription(' Flag to indicate if the group table is full(true) or not(false).')
ctIGMPStatsCntrsNumV1QueriesSent = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV1QueriesSent.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV1QueriesSent.setDescription(' The number of IGMP Version 1 queries this device has sent out.')
ctIGMPStatsCntrsNumV2QueriesSent = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV2QueriesSent.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV2QueriesSent.setDescription(' The number of IGMP Version 2 queries this device has sent out.')
ctIGMPStatsCntrsNumV3QueriesSent = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV3QueriesSent.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV3QueriesSent.setDescription(' The number of IGMP Version 3 queries this device has sent out.')
ctIGMPStatsCntrsNumGSQueriesSent = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumGSQueriesSent.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumGSQueriesSent.setDescription(' The number of Group Specific queries this device has sent out.')
ctIGMPStatsCntrsNumQueriesRcvd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumQueriesRcvd.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumQueriesRcvd.setDescription(' The number of IGMP queries this device has seen from the network.')
ctIGMPStatsCntrsNumV1ReportsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV1ReportsRcvd.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV1ReportsRcvd.setDescription(' The number of IGMP Version 1 reports this device has received.')
ctIGMPStatsCntrsNumV2ReportsRcvd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV2ReportsRcvd.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV2ReportsRcvd.setDescription(' The number of IGMP Version 2 reports this device has received.')
ctIGMPStatsCntrsNumV3ReportsReceived = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV3ReportsReceived.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumV3ReportsReceived.setDescription(' The number of IGMP Version 3 reports this device has received.')
ctIGMPStatsCntrsNumLeavesReceived = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumLeavesReceived.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumLeavesReceived.setDescription(' The number of IGMP leaves this device has received.')
ctIGMPStatsCntrsNumDroppedFrames = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 10, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumDroppedFrames.setStatus('current')
if mibBuilder.loadTexts: ctIGMPStatsCntrsNumDroppedFrames.setDescription(' The number of frames dropped by IGMP on this device.')
ctIGMPProtocolClassificationTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 11), )
if mibBuilder.loadTexts: ctIGMPProtocolClassificationTable.setStatus('current')
if mibBuilder.loadTexts: ctIGMPProtocolClassificationTable.setDescription(" This table contains a listing of how IGMP will\n           classify received IP protocol frames. For example,\n           for a UDP multicast frame received which is IP type 17,\n           IGMP can classify that frame in one of three ways.\n           It can be classified as a multicast data frame, a routing protocol,\n           or it can be ignored. A user may have a need to multicast\n           TCP frames, but still want to send them ONLY to IGMP clients.\n           To do this one would set protocol id 6(TCP) to 'multicastPata'")
ctIGMPProtocolClassificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 11, 1), ).setIndexNames((0, "CTRON-IGMP-MIB", "ctIGMPProtocolClassification"))
if mibBuilder.loadTexts: ctIGMPProtocolClassificationEntry.setStatus('current')
if mibBuilder.loadTexts: ctIGMPProtocolClassificationEntry.setDescription(' An entry representing the binding of IP protocol id, to\n           the IGMP classification of a received frame.')
ctIGMPProtocolClassification = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 11, 1, 1), IgmpProtocolClassTc())
if mibBuilder.loadTexts: ctIGMPProtocolClassification.setStatus('current')
if mibBuilder.loadTexts: ctIGMPProtocolClassification.setDescription(' The classification of this protocol id.\n           1 - Classify as multicast data frame.\n           2 - Classify as a routing protocol.\n           3 - Classify as Ignore.')
ctIGMPProtocolIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 3, 5, 1, 11, 1, 2), IgmpProtocolIdTc()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctIGMPProtocolIdentifier.setStatus('current')
if mibBuilder.loadTexts: ctIGMPProtocolIdentifier.setDescription(" The set of IP protocol ids to apply the classification to.\n           Example: If this set has protocols(bits) 1 and 5 set to a\n           '1', and the classification is 'multicastData', this will\n           force IGMP to treat received frames with IP protocol ids of\n           1 and 5 as 'multicast data', and forward those frames to \n           IGMP joined clients. Similarly if ids 1 and 5 were set to \n           'routing protocol' then IGMP would treat received frames with\n           these ids as routing protocols, etc. ")
mibBuilder.exportSymbols("CTRON-IGMP-MIB", ctIGMPStaticGroupRowStatus=ctIGMPStaticGroupRowStatus, ctIGMPVlanQueryInterval=ctIGMPVlanQueryInterval, ctIGMPNewDefaultState=ctIGMPNewDefaultState, ctIGMPPolicyStatus=ctIGMPPolicyStatus, ctIGMPPortMode=ctIGMPPortMode, ctIGMPStatsCntrsNumLeavesReceived=ctIGMPStatsCntrsNumLeavesReceived, ctIGMPProtocolClassificationTable=ctIGMPProtocolClassificationTable, ctIGMPProtocolClassification=ctIGMPProtocolClassification, ctIGMPDiscoveredRouterStaticPortList=ctIGMPDiscoveredRouterStaticPortList, ctIGMPPolicyIfIndex=ctIGMPPolicyIfIndex, ctIGMPExtCacheExpiryTime=ctIGMPExtCacheExpiryTime, ctIGMPStaticGroupSourceIPAddress=ctIGMPStaticGroupSourceIPAddress, ctIGMPStatsCntrsNumV3ReportsReceived=ctIGMPStatsCntrsNumV3ReportsReceived, ctIGMPStatsCntrsNumV1QueriesSent=ctIGMPStatsCntrsNumV1QueriesSent, ctIGMPDiscoveredRouterTable=ctIGMPDiscoveredRouterTable, ctIGMPVlanId=ctIGMPVlanId, ctIGMPStaticGroupAddress=ctIGMPStaticGroupAddress, ctIGMPStaticGroupIPAddress=ctIGMPStaticGroupIPAddress, ctIGMPConfigGroupTblFullAction=ctIGMPConfigGroupTblFullAction, ctIGMPVlanLastMembQueryIntvl=ctIGMPVlanLastMembQueryIntvl, ctIGMPCacheVlanId=ctIGMPCacheVlanId, ctIGMPStaticGroupIncludeList=ctIGMPStaticGroupIncludeList, ctIGMPExtCacheOutPortList=ctIGMPExtCacheOutPortList, ctIGMPCacheEntry=ctIGMPCacheEntry, ctIGMPExtCacheSourceIPAddress=ctIGMPExtCacheSourceIPAddress, ctIGMPStatsCntrsNumGSQueriesSent=ctIGMPStatsCntrsNumGSQueriesSent, ctIGMPStaticVlanId=ctIGMPStaticVlanId, ctIGMPPortTableVlanId=ctIGMPPortTableVlanId, ctIGMPStaticGroupExcludeList=ctIGMPStaticGroupExcludeList, ctIGMPDiscoveredRouterPortList=ctIGMPDiscoveredRouterPortList, ctIGMPCacheUpTime=ctIGMPCacheUpTime, ctIGMPVlanStatus=ctIGMPVlanStatus, IgmpProtocolIdTc=IgmpProtocolIdTc, ctIGMPVlanQuerierUpTime=ctIGMPVlanQuerierUpTime, ctIGMPPortTableSourceIPAddress=ctIGMPPortTableSourceIPAddress, ctIGMPPolicyVlanId=ctIGMPPolicyVlanId, ctIGMPMibRev=ctIGMPMibRev, ctIGMPExtCacheVlanId=ctIGMPExtCacheVlanId, ctIGMPPortTable=ctIGMPPortTable, ctIGMPStaticGroupTable=ctIGMPStaticGroupTable, ctIGMPExtCacheLastReporter=ctIGMPExtCacheLastReporter, ctIGMPCacheIfIndex=ctIGMPCacheIfIndex, ctIGMPDiscoveredRouterEgressPortList=ctIGMPDiscoveredRouterEgressPortList, ctIGMPStatsCntrsNumQueriesRcvd=ctIGMPStatsCntrsNumQueriesRcvd, ctIGMPConfig=ctIGMPConfig, ctIGMPPortTableGroupAddress=ctIGMPPortTableGroupAddress, ctIGMPVlanQueryMaxResponseTime=ctIGMPVlanQueryMaxResponseTime, ctIGMPPortTableEntry=ctIGMPPortTableEntry, ctIGMPStatsCntrsNumV2ReportsRcvd=ctIGMPStatsCntrsNumV2ReportsRcvd, ctIGMPPolicyTable=ctIGMPPolicyTable, ctIGMPVlanQuerier=ctIGMPVlanQuerier, ctIGMPStatsCntrsGroupFull=ctIGMPStatsCntrsGroupFull, ctIGMPExtCacheTable=ctIGMPExtCacheTable, ctIGMPDiscoveredRouterEntry=ctIGMPDiscoveredRouterEntry, ctIGMPVlanTable=ctIGMPVlanTable, ctIGMPVlanVersion=ctIGMPVlanVersion, ctIGMP=ctIGMP, ctIGMPStaticTable=ctIGMPStaticTable, ctIGMPExtCacheEntry=ctIGMPExtCacheEntry, IgmpProtocolClassTc=IgmpProtocolClassTc, ctIGMPProtocolClassificationEntry=ctIGMPProtocolClassificationEntry, ctIGMPStatsCntrsNumV3QueriesSent=ctIGMPStatsCntrsNumV3QueriesSent, ctIGMPStatsCntrsNumDroppedFrames=ctIGMPStatsCntrsNumDroppedFrames, ctIGMPPolicyInclusion=ctIGMPPolicyInclusion, ctIGMPVlanRobustness=ctIGMPVlanRobustness, ctIGMPPolicyEntry=ctIGMPPolicyEntry, ctIGMPStaticGroupVlanId=ctIGMPStaticGroupVlanId, ctIGMPVlanEntry=ctIGMPVlanEntry, ctIGMPStaticEntry=ctIGMPStaticEntry, ctIGMPStaticOutPortList=ctIGMPStaticOutPortList, ctIGMPStatsCntrsNumV2QueriesSent=ctIGMPStatsCntrsNumV2QueriesSent, IgmpPortModeTc=IgmpPortModeTc, ctIGMPProtocolIdentifier=ctIGMPProtocolIdentifier, ctIGMPVlanQuerierExpiryTime=ctIGMPVlanQuerierExpiryTime, ctIGMPCacheVersion1HostTimer=ctIGMPCacheVersion1HostTimer, ctIGMPVlanQuerierIP=ctIGMPVlanQuerierIP, ctIGMPCacheLastReporter=ctIGMPCacheLastReporter, ctIGMPCacheExpiryTime=ctIGMPCacheExpiryTime, ctIGMPCacheAddress=ctIGMPCacheAddress, ctIGMPPolicyAddress=ctIGMPPolicyAddress, ctIGMPPortTableExpireTime=ctIGMPPortTableExpireTime, ctIGMPCacheTable=ctIGMPCacheTable, ctIGMPStatsCntrs=ctIGMPStatsCntrs, ctIGMPExtCacheSrcPort=ctIGMPExtCacheSrcPort, ctIGMPMibRevString=ctIGMPMibRevString, PYSNMP_MODULE_ID=ctIGMP, ctIGMPDiscoveredRouterVlanId=ctIGMPDiscoveredRouterVlanId, ctIGMPStaticRowStatus=ctIGMPStaticRowStatus, ctIGMPStatsCntrsNumV1ReportsRcvd=ctIGMPStatsCntrsNumV1ReportsRcvd, ctIGMPExtCacheAddress=ctIGMPExtCacheAddress, ctIGMPExtCacheVersion1HostTimer=ctIGMPExtCacheVersion1HostTimer, ctIGMPExtCacheUpTime=ctIGMPExtCacheUpTime, ctIGMPStaticGroupEntry=ctIGMPStaticGroupEntry)
