#
# PySNMP MIB module HMPRIV-MGMT-SNMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/hirschmann/hmpriv.mib
# Produced by pysmi-1.1.12 at Wed Jul  3 12:23:34 2024
# On host fv-az1022-995 platform Linux version 6.5.0-1022-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
dot1dStaticAddress, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dStaticAddress")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
TimeFilter, = mibBuilder.importSymbols("RMON2-MIB", "TimeFilter")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Gauge32, ObjectIdentity, IpAddress, Counter32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, TimeTicks, Unsigned32, iso, MibIdentifier, Integer32, NotificationType, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Gauge32", "ObjectIdentity", "IpAddress", "Counter32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "TimeTicks", "Unsigned32", "iso", "MibIdentifier", "Integer32", "NotificationType", "Counter64")
RowStatus, MacAddress, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "MacAddress", "TruthValue", "DisplayString", "TextualConvention")
hmConfiguration = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 14))
hmConfiguration.setRevisions(('2008-06-03 12:00', '2007-12-11 12:00', '2007-09-13 12:00', '2010-01-29 12:00', '2012-09-04 12:00', '2012-11-01 12:00', '2012-11-02 12:00', '2012-11-07 12:00', '2012-11-12 12:00', '2012-11-26 12:00', '2013-01-17 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hmConfiguration.setRevisionsDescriptions(('Update for Eagle 20 version 04.3.00', 'Update for plattform version 04.1.00', 'First release in SMIv2', '29.01.2010/HG: hmRestrictedMgtAccessGroup added', 'Update for platform version 07.1.04: hmGmrpUnknownMode added', 'Update for platform version 8.0: hmNetPTP2TCProfile and \r\n\t\t  hmNetPTP2TCPowerTLVCheck added', 'Update for platform version 8.0: hmRelayIfaceDhcpRelayAdminState and \r\n          hmRelayIfaceDhcpRelayOperState added', 'Update for platform version 8.0: hmIfaceExtAcceptableFrameTypes added', 'Update for platform version 8.0: IEC61850 related objects \r\n          hmIEC61850ConfigGroup and hmIEC61850StatisticsGroup added', 'Update for platform version 8.0: hmConfigurationSignature added', 'new variable hmSysModAdminState added;\r\n           value 2 (none) added for hmSysModType MIB',))
if mibBuilder.loadTexts: hmConfiguration.setLastUpdated('201301171200Z')
if mibBuilder.loadTexts: hmConfiguration.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hmConfiguration.setContactInfo('Customer Support\r\n           Postal: \r\n           Hirschmann Automation and Control GmbH\r\n           Stuttgarter Str. 45-51\r\n           72654 Neckartenzlingen\r\n           Germany\r\n           Tel: +49 7127 14 1981\r\n           Web: http://www.hicomcenter.com/\r\n           E-Mail: hicomcenter@hirschmann.com')
if mibBuilder.loadTexts: hmConfiguration.setDescription('The Hirschmann Private MIB definitions for Platform devices.')
class HmLargeDisplayString(TextualConvention, OctetString):
    description = "Represents textual information taken from the NVT ASCII\r\n            character set, as defined in pages 4, 10-11 of RFC 854.\r\n\r\n            To summarize RFC 854, the NVT ASCII repertoire specifies:\r\n\r\n              - the use of character codes 0-127 (decimal)\r\n\r\n              - the graphics characters (32-126) are interpreted as\r\n                US ASCII\r\n\r\n              - NUL, LF, CR, BEL, BS, HT, VT and FF have the special\r\n                meanings specified in RFC 854\r\n\r\n              - the other 25 codes have no standard interpretation\r\n\r\n              - the sequence 'CR LF' means newline\r\n\r\n              - the sequence 'CR NUL' means carriage-return\r\n\r\n              - an 'LF' not preceded by a 'CR' means moving to the\r\n                same column on the next line.\r\n\r\n              - the sequence 'CR x' for any x other than LF or NUL is\r\n                illegal.  (Note that this also means that a string may\r\n                end with either 'CR LF' or 'CR NUL', but not with CR.)\r\n\r\n            Any object defined using this syntax may not exceed 2048\r\n            characters in length."
    status = 'current'
    displayHint = '2048a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 2048)

class HmAgentLogSeverity(TextualConvention, Integer32):
    reference = 'RFC3164 - 4.1.1: Table 2'
    description = 'Severity code used in determining the SysLog Priority value.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("emergency", 0), ("alert", 1), ("critical", 2), ("error", 3), ("warning", 4), ("notice", 5), ("informational", 6), ("debug", 7))

class LEDState(TextualConvention, Integer32):
    description = 'Color of the LED'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("off", 1), ("green", 2), ("yellow", 3), ("red", 4))

class DIPSwitchState(TextualConvention, Integer32):
    description = 'Status of the DIP switch.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("on", 1), ("off", 2))

class PTPTimeInterval(TextualConvention, OctetString):
    reference = 'IEEE P1588 D2.21 Draft Standard for a Precision Clock\r\n\t\t\t Synchronization Protocol for Networked\r\n\t\t\t Measurement and Control Systems page 18'
    description = 'The scaledNanoseconds member is the time interval expressed in units of nanoseconds and multiplied by\r\n\t\t\t 2^+16. Positive or negative time intervals outside the maximum range of this data type shall be encoded as the\r\n\t\t\t largest positive and negative values of the data type respectively.\r\n\t\t\t For example: 2.5 ns is expressed as: (hex) 0x0000 0000 0002 8000'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class PTPPortIdentity(TextualConvention, OctetString):
    reference = 'IEEE P1588 D2.21 Draft Standard for a Precision Clock\r\n\t\t\t Synchronization Protocol for Networked\r\n\t\t\t Measurement and Control Systems page 19'
    description = "The PTPPortIdentity type identifies a PTP port.\r\n\t\t\t The first 8 octets within this value specifies the ClockIdentity.\r\n\t\t\t The last 2 octetes within this value specifies the port number.\r\n\t\t\t For example: '00 80 63 FF FF 00 00 00 00 01'. ClockIdentity is\r\n\t\t\t '008063FFFF000000' and port number is '0001'"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(10, 10)
    fixedLength = 10

class PTPClockIdentity(TextualConvention, OctetString):
    reference = 'IEEE P1588 D2.21 Draft Standard for a Precision Clock\r\n\t\t\t Synchronization Protocol for Networked\r\n\t\t\t Measurement and Control Systems page 19'
    description = "The PTPClockIdentity type identifies a PTP clock.\r\n\t\t\t The PTPClockIdentity shall be in the IEEE EUI-64\r\n\t\t\t format.\r\n\t\t\t For example: '008063FFFF000000'"
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class PTPClockQuality(TextualConvention, OctetString):
    reference = 'IEEE P1588 D2.21 Draft Standard for a Precision Clock\r\n\t\t\t Synchronization Protocol for Networked\r\n\t\t\t Measurement and Control Systems page 19'
    description = 'The PTPClockQuality represents the quality of a clock.\r\n\t\t\t The first octet represents the clock class. The second\r\n\t\t\t octet represents the clockAccuracy and the last two octets\r\n\t\t\t represent the offsetScaledLogVariance\r\n\t\t\t For example: '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class PTPSubdomainName(TextualConvention, OctetString):
    reference = 'IEEE P1588 D2.21 Draft Standard for a Precision Clock\r\n\t\t\t Synchronization Protocol for Networked\r\n\t\t\t Measurement and Control Systems page 19'
    description = 'The values of the octets for the subdomain name may be\r\n\t\t\tchosen from the set consisting of the values of the printable\r\n\t\t\tASCII characters starting with hex value 0x21 (!) up to and\r\n\t\t\tincluding hex value 0x7E (~).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

class BridgeIdOrNull(TextualConvention, OctetString):
    description = 'The Bridge-Identifier as used in the Spanning Tree or Null, if\r\n   \t\t\t no valid data is available'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), )
hirschmann = MibIdentifier((1, 3, 6, 1, 4, 1, 248))
hmChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1))
hmAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2))
hmProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10))
rs2 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 2))
mach3000 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 3))
ms2108_2 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 4)).setLabel("ms2108-2")
ms3124_4 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 5)).setLabel("ms3124-4")
rs2_16 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 6)).setLabel("rs2-16")
rs2_4r = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 7)).setLabel("rs2-4r")
ms4128_5 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 10)).setLabel("ms4128-5")
eagle = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 20))
rr_epl = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 21)).setLabel("rr-epl")
eagle_mguard = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 22)).setLabel("eagle-mguard")
eagle20 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 23))
eagleone = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 24))
ms20 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 30))
ms30 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 31))
rs20 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 40))
rs30 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 41))
rsb20 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 44))
osb20 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 45))
mach4002_48_4G = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 50)).setLabel("mach4002-48-4G")
octopus = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 60))
mach4002_24G = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 70)).setLabel("mach4002-24G")
mach4002_24G_3X = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 71)).setLabel("mach4002-24G-3X")
mach4002_48G = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 75)).setLabel("mach4002-48G")
mach4002_48G_3X = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 76)).setLabel("mach4002-48G-3X")
ruggedswitch = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 90))
railswitchrugged = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 100))
mach100 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 110))
octopus_os = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 120)).setLabel("octopus-os")
mach100ge = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 130))
mach1000ge = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 131))
eem1 = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 200))
gecko = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 10, 300))
hmSystemTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1))
hmSysProduct = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 10, 11, 12, 20, 21, 100, 101, 102, 110, 111, 112, 120, 121, 122, 130, 131, 132, 140, 141, 142, 200, 201, 202, 210, 211, 212, 220, 221, 222, 230, 231, 232, 240, 241, 242, 300, 301, 302, 303, 304, 311, 312, 313, 401, 410, 420, 421, 425, 426, 500, 501, 502, 503, 504, 505, 506, 507, 520, 521, 522, 523, 524, 525, 526, 527, 530, 531, 532, 533, 534, 535, 536, 537, 540, 541, 542, 543, 544, 545, 546, 547, 550, 551, 560, 561, 562, 563, 564, 565, 600, 601, 620, 621, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 720, 721, 722, 723, 724, 725, 730, 731, 732, 733, 734, 740, 780, 800, 801, 802, 803, 804, 810, 811, 812, 820, 821, 822, 823, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1200, 1300))).clone(namedValues=NamedValues(("rs2-tx-tx", 1), ("rs2-fx-fx", 2), ("rs2-fxsm-fxsm", 3), ("mach3002", 10), ("mach3005", 11), ("mach3001", 12), ("ms2108-2", 20), ("ms3124-4", 21), ("rs2-16m", 100), ("rs2-15m", 101), ("rs2-14m", 102), ("rs2-16m-1mm-sc", 110), ("rs2-16m-1sm-sc", 111), ("rs2-16m-1lh-sc", 112), ("rs2-15m-1mm-sc", 120), ("rs2-15m-1sm-sc", 121), ("rs2-15m-1lh-sc", 122), ("rs2-16m-2mm-sc", 130), ("rs2-16m-2sm-sc", 131), ("rs2-16m-2lh-sc", 132), ("rs2-16m-1mm-sc-1sm-sc", 140), ("rs2-16m-1mm-sc-1lh-sc", 141), ("rs2-16m-1sm-sc-1lh-sc", 142), ("rs2-8m", 200), ("rs2-7m", 201), ("rs2-6m", 202), ("rs2-8m-1mm-sc", 210), ("rs2-8m-1sm-sc", 211), ("rs2-8m-1lh-sc", 212), ("rs2-7m-1mm-sc", 220), ("rs2-7m-1sm-sc", 221), ("rs2-7m-1lh-sc", 222), ("rs2-8m-2mm-sc", 230), ("rs2-8m-2sm-sc", 231), ("rs2-8m-2lh-sc", 232), ("rs2-8m-1mm-sc-1sm-sc", 240), ("rs2-8m-1mm-sc-1lh-sc", 241), ("rs2-8m-1sm-sc-1lh-sc", 242), ("rs2-4r", 300), ("rs2-4r-1mm-sc", 301), ("rs2-4r-1sm-sc", 302), ("rs2-4r-1lh-sc", 303), ("rs2-4r-1fl-st", 304), ("rs2-4r-2mm-sc", 311), ("rs2-4r-2sm-sc", 312), ("rs2-4r-2lh-sc", 313), ("ms4128-5", 401), ("mach4002-48-4G", 410), ("mach4002-24G", 420), ("mach4002-24G-3X", 421), ("mach4002-48G", 425), ("mach4002-48G-3X", 426), ("eagle-tx-tx", 500), ("eagle-tx-mm-sc", 501), ("eagle-tx-sm-sc", 502), ("eagle-tx-lh-sc", 503), ("eagle-mm-sc-tx", 504), ("eagle-mm-sc-mm-sc", 505), ("eagle-mm-sc-sm-sc", 506), ("eagle-mm-sc-lh-sc", 507), ("eagle-fw-tx-tx", 520), ("eagle-fw-tx-mm-sc", 521), ("eagle-fw-tx-sm-sc", 522), ("eagle-fw-tx-lh-sc", 523), ("eagle-fw-mm-sc-tx", 524), ("eagle-fw-mm-sc-mm-sc", 525), ("eagle-fw-mm-sc-sm-sc", 526), ("eagle-fw-mm-sc-lh-sc", 527), ("eagle-mguard-tx-tx", 530), ("eagle-mguard-tx-mm-sc", 531), ("eagle-mguard-tx-sm-sc", 532), ("eagle-mguard-tx-lh-sc", 533), ("eagle-mguard-mm-sc-tx", 534), ("eagle-mguard-mm-sc-mm-sc", 535), ("eagle-mguard-mm-sc-sm-sc", 536), ("eagle-mguard-mm-sc-lh-sc", 537), ("eagle20-tx-tx", 540), ("eagle20-tx-mm-sc", 541), ("eagle20-tx-sm-sc", 542), ("eagle20-tx-lh-sc", 543), ("eagle20-mm-sc-tx", 544), ("eagle20-mm-sc-mm-sc", 545), ("eagle20-mm-sc-sm-sc", 546), ("eagle20-mm-sc-lh-sc", 547), ("rr-epl-tx-tx", 550), ("rr-epl-tx-mm-sc", 551), ("eagleone-tx-tx", 560), ("eagleone-tx-mm", 561), ("eagleone-mm-tx", 562), ("eagleone-mm-mm", 563), ("eagleone-tx-sm", 564), ("eagleone-sm-tx", 565), ("ms20-0800", 600), ("ms20-2400", 601), ("ms30-0802", 620), ("ms30-2402", 621), ("rs20-0400", 700), ("rs20-0400m1", 701), ("rs20-0400m2", 702), ("rs20-0800", 703), ("rs20-0800m2", 704), ("rs20-1600", 705), ("rs20-1600m2", 706), ("rs20-2400", 707), ("rs20-2400m2", 708), ("rs20-0900m3", 709), ("rs20-1700m3", 710), ("rs20-2500m3", 711), ("rs30-0802", 720), ("rs30-1602", 721), ("rs30-2402", 722), ("rs30-0802m4", 723), ("rs30-1602m4", 724), ("rs30-2402m4", 725), ("rsb20-8tx", 730), ("rsb20-8tx-1fx", 731), ("rsb20-6tx-2fx", 732), ("rsb20-6tx-3fx", 733), ("rsb20-6tx-3sfp", 734), ("rs40-0009", 740), ("cs30-0202", 780), ("octopus-8m", 800), ("octopus-16m", 801), ("octopus-24m", 802), ("octopus-8m-2g", 803), ("octopus-16m-2g", 804), ("os-000800", 810), ("os-000802", 811), ("os-001000", 812), ("osb20-9tx", 820), ("osb24-9tx-8poe", 821), ("osb20-10tx", 822), ("osb24-10tx-8poe", 823), ("mar1020", 900), ("mar1030", 901), ("mar1030-4g", 902), ("mar1022", 903), ("mar1032", 904), ("mar1032-4g", 905), ("mar1120", 906), ("mar1130", 907), ("mar1130-4g", 908), ("mar1122", 909), ("mar1132", 910), ("mar1132-4g", 911), ("mar1040", 912), ("mar1042", 913), ("mar1140", 914), ("mar1142", 915), ("rsr30-07sfp-03sfp", 1000), ("rsr30-06tp-03combo", 1001), ("rsr30-06tp-02sfp-02combo", 1002), ("rsr30-06tp-02sfp-02sfp", 1003), ("rsr30-08tp-02combo", 1004), ("rsr30-08tp-02sfp", 1005), ("rsr20-06tp-03fx", 1006), ("rsr20-06tp-02fx", 1007), ("rsr20-08tp", 1008), ("mach100", 1100), ("mach104-20tx-f", 1101), ("mach104-20tx-fr", 1102), ("mach104-20tx-f-4poe", 1103), ("mach104-16tx-poep", 1104), ("mach104-16tx-poep-r", 1105), ("mach104-16tx-poep-e", 1106), ("mach104-16tx-poep-2x", 1107), ("mach104-16tx-poep-2x-r", 1108), ("mach104-16tx-poep-2x-e", 1109), ("eem1", 1200), ("gecko-4tx-tx", 1300)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysProduct.setStatus('current')
if mibBuilder.loadTexts: hmSysProduct.setDescription('Manufacturer-defined product identifier.')
hmSysVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysVersion.setStatus('current')
if mibBuilder.loadTexts: hmSysVersion.setDescription('This value is a string that contains at least the\r\n\t\t\t\t  following data :\r\n\t\t\t\t   SW:\t Version number of software\r\n\t\t\t\t   CH:\t Version number of chassis\r\n\t\t\t\t   BP:\t Version number of backplane')
hmSysGroupCapacity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupCapacity.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupCapacity.setDescription('The hmSysGroupCapacity is the number of groups that can\r\n\t\t\t\t be contained within the chassis. Within each managed\r\n\t\t\t\t chassis/switch, the groups are uniquely numbered in the\r\n\t\t\t\t range from 1 to hmSysGroupCapacity.\r\n\r\n\t\t\t\t Some groups may not be present in the chassis, in which\r\n\t\t\t\t case the actual number of groups present will be less than\r\n\t\t\t\t hmSysGroupCapacity.  The number of groups present will never be\r\n\t\t\t\t greater than hmSysGroupCapacity.')
hmSysGroupMap = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupMap.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupMap.setDescription("This string represents the current configuration of the chassis,\r\n\t\t\t\t encoded as an octet string. Each module is represented by a\r\n\t\t\t\t single octet. If the value of a single octet is the ascii representation\r\n\t\t\t\t of the character '1', it indicates that the module represented\r\n\t\t\t\t by that octet is present, if '0', the module is absent.\r\n\t\t\t\t The number of octets in the string is given by hmSysGroupCapacity.\r\n\t\t\t\t If the value of this variable changes, a hmGroupMapChange trap\r\n\t\t\t\t is sent.")
hmSysMaxPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysMaxPowerSupply.setStatus('current')
if mibBuilder.loadTexts: hmSysMaxPowerSupply.setDescription('Maximum number of power supplies for this chassis. Within\r\n\t\t\t\t each managed chassis/switch, the groups are uniquely numbered\r\n\t\t\t\t in the range from 1 to hmSysMaxPowerSupply.')
hmSysMaxFan = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysMaxFan.setStatus('current')
if mibBuilder.loadTexts: hmSysMaxFan.setDescription('Maximum number of fans for this chassis. Within each managed\r\n\t\t\t\t chassis/switch, the fans are uniquely numbered in the range\r\n\t\t\t\t from 0 to hmSysMaxFan.')
hmSysGroupModuleCapacity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupModuleCapacity.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupModuleCapacity.setDescription('Maximum number of modules that an individual group can\r\n\t\t\t\t contain in this system.')
hmSysModulePortCapacity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModulePortCapacity.setStatus('current')
if mibBuilder.loadTexts: hmSysModulePortCapacity.setDescription('Maximum number of ports that an individual module can\r\n\t\t\t\t contain in this system.')
hmSysGroupTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9), )
if mibBuilder.loadTexts: hmSysGroupTable.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupTable.setDescription('This table contains variables for a closer description of\r\n\t\t\t\t a group.')
hmSysGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSysGroupID"))
if mibBuilder.loadTexts: hmSysGroupEntry.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupEntry.setDescription('The entry of the hmSysGroupTable.')
hmSysGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupID.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupID.setDescription('index to identify an interface card. This value is never\r\n\t\t\t\t greater than hmSysGroupCapacity.')
hmSysGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 20, 21, 22, 23, 30, 31, 40, 41, 42, 44, 45, 50, 60, 70, 71, 75, 76, 90, 110, 130, 131, 200, 300))).clone(namedValues=NamedValues(("unknown", 1), ("m-basic4", 10), ("ms2108-2", 20), ("ms3124-4", 21), ("rs2", 22), ("ms4128-5", 23), ("ms20", 30), ("ms30", 31), ("rs20", 40), ("rs30", 41), ("rs40", 42), ("rsb20", 44), ("osb2x", 45), ("mach4002-48-4G", 50), ("octopus", 60), ("mach4002-24G", 70), ("mach4002-24G-3X", 71), ("mach4002-48G", 75), ("mach4002-48G-3X", 76), ("ruggedswitch", 90), ("mach100", 110), ("mach100ge", 130), ("mach1000ge", 131), ("eem1", 200), ("gecko", 300)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupType.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupType.setDescription('Type of interface card.')
hmSysGroupDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupDescription.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupDescription.setDescription('Description of interface card.')
hmSysGroupHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupHwVersion.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupHwVersion.setDescription('Hardware version of interface card.')
hmSysGroupSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupSwVersion.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupSwVersion.setDescription('Software version of interface card.')
hmSysGroupModuleMap = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupModuleMap.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupModuleMap.setDescription("This string represents the current configuration of a group,\r\n\t\t\t\t encoded as an octet string. Each module is represented by a\r\n\t\t\t\t single octet. If the value of a single octet is the ascii representation\r\n\t\t\t\t of the character '1', it indicates that the module represented\r\n\t\t\t\t by that octet is present, if '0', the module is absent. If the character is\r\n\t\t\t\t 'C', then the card is configurable but absent. The ports can be configured\r\n\t\t\t\t and by setting hmSysModStatus to remove(3) the card can be logically\r\n\t\t\t\t removed. The number of bytes in the string is given by\r\n\t\t\t\t hmSysGroupModuleCapacity.")
hmSysGroupAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 10))).clone(namedValues=NamedValues(("other", 1), ("reset", 2), ("resetStats", 3), ("resetFDB", 4), ("resetARP", 5), ("resetL3Stats", 6), ("resetL4-7Stats", 7), ("hotRestart", 10))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysGroupAction.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupAction.setDescription("This object, when read, always returns a value of other(1).\r\n\t\t\t\t A value of reset(2) has the same effect as a power-on sequence\r\n\t\t\t\t (coldstart). When set to resetStats(3), a reset of all statistic\r\n\t\t\t\t counters of the card's ports will be forced. Any other value\r\n\t\t\t\t results in a badValue status code.")
hmSysGroupActionResult = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupActionResult.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupActionResult.setDescription('Result of the last activated action. A value of zero\r\n\t\t\t\t indicates that the result is ok. Bits set in the result\r\n\t\t\t\t indicate error conditions.')
hmSysGroupIsolateMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysGroupIsolateMode.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupIsolateMode.setDescription('Setting this variable to enable(1) separates the group from\r\n\t\t\t\t  the rest of the chassis, so that it will act like a\r\n\t\t\t\t  standalone-switch.')
hmSysGroupSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupSerialNum.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupSerialNum.setDescription('The serial number provided by vendor (ASCII). ')
hmSysGroupActionDelayPreset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysGroupActionDelayPreset.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupActionDelayPreset.setDescription('Time in seconds until a reset(2) or\r\n\t\t\t    hotRestart(10) that was triggered over\r\n\t\t\t    the hmSysGroupAction object is executed. Writing\r\n\t\t\t    a zero will cancel any scheduled reset.')
hmSysGroupActionDelayCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 9, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysGroupActionDelayCurrent.setStatus('current')
if mibBuilder.loadTexts: hmSysGroupActionDelayCurrent.setDescription('If a delayed reset is scheduled this object\r\n\t\t\t    will incrementing from the start value to zero.')
hmSysModuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10), )
if mibBuilder.loadTexts: hmSysModuleTable.setStatus('current')
if mibBuilder.loadTexts: hmSysModuleTable.setDescription('This table contains variables for a closer description of a\r\n\t\t\t\t module.')
hmSysModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSysModGroupID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmSysModID"))
if mibBuilder.loadTexts: hmSysModuleEntry.setStatus('current')
if mibBuilder.loadTexts: hmSysModuleEntry.setDescription('The entry of the hmSysModuleTable.')
hmSysModGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModGroupID.setStatus('current')
if mibBuilder.loadTexts: hmSysModGroupID.setDescription('index to identify an interface card. This value is never\r\n\t\t\t\t greater than hmSysGroupCapacity.')
hmSysModID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModID.setStatus('current')
if mibBuilder.loadTexts: hmSysModID.setDescription('index to identify a module on an interface card. This value\r\n\t\t\t\t is never greater than hmSysGroupModuleCapacity.')
hmSysModType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 100, 101, 102, 103, 104, 200, 201, 300, 400, 401, 402, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1299, 1300, 1301, 1302, 1303, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1501, 1502, 1503, 1550, 1600, 1601, 1610, 1611, 1612, 1613, 1614, 1615, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1750, 1751, 1752, 1753, 1850))).clone(namedValues=NamedValues(("unknown", 1), ("none", 2), ("m-fast-8tp-rj", 100), ("m-fast-8mm-mt", 101), ("m-fast-2mm-sc", 102), ("m-fast-2sm-sc", 103), ("m-eth-4mm-st", 104), ("m-giga-2sx-sc", 200), ("m-giga-1lx-sc", 201), ("m-router", 300), ("m-giga-2sx-sc-2", 400), ("m-giga-1lx-sc-2", 401), ("m-giga-2tp-rj", 402), ("mm2-4tx1", 1000), ("mm2-2flm4", 1001), ("mm2-2fls4", 1002), ("mm3-4flm4", 1003), ("mm3-4fls4", 1004), ("mm3-2aui", 1005), ("mm3-4tx5", 1006), ("mm2-4fxm3", 1100), ("mm2-2fxm2", 1101), ("mm2-2fxs2", 1102), ("mm3-4fxm2", 1103), ("mm3-4fxs2", 1104), ("mm3-4fxm4", 1105), ("mm2-2fxp4", 1106), ("mm3-4fxp4", 1107), ("mm2-2fxm3-2tx1", 1201), ("mm3-2fxm2-2tx1", 1202), ("mm3-2fxs2-2tx1", 1203), ("mm3-1fxl2-3tx1", 1204), ("mm3-1fxs2-3tx1", 1205), ("mm3-1fxm2-3tx1", 1206), ("mm3-2fxm4-2tx1", 1207), ("mm3-3tx1-1fxm2", 1208), ("mm3-4tx5-relay", 1209), ("mm3-3fxxx-1tx1", 1299), ("mm3-4tx1-rt", 1300), ("mm3-2fxm2-2tx1-rt", 1301), ("mm3-2fxs2-2tx1-rt", 1302), ("mm3-2flm3-2tx1-rt", 1303), ("mm4-4tx-sfp", 1401), ("mm4-2tx-sfp", 1402), ("mm3-4tx1-poe", 1403), ("mm3-4sfp", 1404), ("mm3-4tx5-poe", 1405), ("mm3-3tx5-poe-1tx5", 1406), ("mm23-t1t1t1t1", 1407), ("mm23-m2m2t1t1", 1408), ("mm23-s2s2t1t1", 1409), ("mm23-f4f4t1t1", 1410), ("mm33-07079999", 1411), ("mm4-2tx-sfp-giga", 1412), ("mm4-2tx-giga", 1413), ("m4-8tp-rj45", 1501), ("m4-fast-8sfp", 1502), ("m4-fast-8tp-rj45-poe", 1503), ("m4-giga-8sfp", 1550), ("m4-base-giga-4tp-sfp", 1600), ("m4-base-fast-16tp", 1601), ("m4-base-48g-16tp", 1610), ("m4-base-48g-8tp-sfp-8tp", 1611), ("m4-base-48g-3xfp", 1612), ("m4-base-24g-8tp", 1613), ("m4-base-24g-8tp-sfp", 1614), ("m4-base-24g-3xfp", 1615), ("mach102-8tp", 1701), ("m1-8tp-rj45", 1702), ("m1-8mm-sc", 1703), ("m1-8sm-sc", 1704), ("m1-8sfp", 1705), ("mach104-20tx-f", 1706), ("mach104-20tx-fr", 1707), ("mach104-20tx-f-4poe", 1708), ("m1-8tp-rj45-poe", 1709), ("mach104-16tx-poep", 1710), ("mach104-16tx-poep-r", 1711), ("mach104-16tx-poep-e", 1712), ("mach104-16tx-poep-2x", 1713), ("mach104-16tx-poep-2x-r", 1714), ("mach104-16tx-poep-2x-e", 1715), ("mar1040", 1750), ("mar1042", 1751), ("mar1140", 1752), ("mar1142", 1753), ("mm20-ioioioio", 1850)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModType.setStatus('current')
if mibBuilder.loadTexts: hmSysModType.setDescription('Type of a module.')
hmSysModDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModDescription.setStatus('current')
if mibBuilder.loadTexts: hmSysModDescription.setDescription('Description of the module.')
hmSysModVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModVersion.setStatus('current')
if mibBuilder.loadTexts: hmSysModVersion.setDescription('version of the module.')
hmSysModNumOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModNumOfPorts.setStatus('current')
if mibBuilder.loadTexts: hmSysModNumOfPorts.setDescription('The numberOfPorts is the number of ports contained within\r\n\t\t\t\t the module. Within each module, the ports are uniquely\r\n\t\t\t\t numbered in the range from 1 to numberOfPorts.')
hmSysModFirstMauIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModFirstMauIndex.setStatus('current')
if mibBuilder.loadTexts: hmSysModFirstMauIndex.setDescription('value of the first mauIndex used by the module.')
hmSysModStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("physical", 1), ("configurable", 2), ("remove", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysModStatus.setStatus('current')
if mibBuilder.loadTexts: hmSysModStatus.setDescription('status of hot-pluggable modules, only for PowerMICE.\r\n\t\t\t\t  If the value is physical(1), then the module is plugged in,\r\n\t\t\t\t  if the value is configurable, the ports can be configured,\r\n\t\t\t\t  but the card is absent, with the value remove(3) written to\r\n\t\t\t\t  the agent the card can be logically removed.')
hmSysModSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysModSerialNum.setStatus('current')
if mibBuilder.loadTexts: hmSysModSerialNum.setDescription('The serial number provided by vendor (ASCII). ')
hmSysModAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysModAdminState.setStatus('current')
if mibBuilder.loadTexts: hmSysModAdminState.setDescription('Enable or disable the module. If disabled, module \r\n             plugged in this slot will not be activated. ')
hmInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11), )
if mibBuilder.loadTexts: hmInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmInterfaceTable.setDescription('This table contains variables for each interface of\r\n\t\t\t\t the switch.')
hmInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmIfaceGroupID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmIfaceID"))
if mibBuilder.loadTexts: hmInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmInterfaceEntry.setDescription('The entry of the hmInterfaceTable.')
hmIfaceGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceGroupID.setStatus('current')
if mibBuilder.loadTexts: hmIfaceGroupID.setDescription('index to identify an interface card. This value is never\r\n\t\t\t\t greater than hmSysGroupCapacity.')
hmIfaceID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceID.setStatus('current')
if mibBuilder.loadTexts: hmIfaceID.setDescription('index to identify an interface within an interface card.')
hmIfaceStpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceStpEnable.setStatus('current')
if mibBuilder.loadTexts: hmIfaceStpEnable.setDescription('Enable or disable spanning tree protocol.')
hmIfaceLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("user", 1), ("uplink", 2))).clone('user')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceLinkType.setStatus('current')
if mibBuilder.loadTexts: hmIfaceLinkType.setDescription('Describes the link type of the interface.')
hmIfaceAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetStats", 2))).clone('noAction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceAction.setStatus('current')
if mibBuilder.loadTexts: hmIfaceAction.setDescription('This object, when read, always returns a value of noAction(1).\r\n\t\t\t\t When set to resetStats(2), a reset of all statistic counters\r\n\t\t\t\t within this interfacecard will be forced.')
hmIfaceNextHopMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceNextHopMacAddress.setStatus('current')
if mibBuilder.loadTexts: hmIfaceNextHopMacAddress.setDescription('The macaddress of the next switch agent reachable via this\r\n\t\t\t\t interface. If the value is 0:0:0:0:0:0, no other switch is\r\n\t\t\t\t seen via this interface.')
hmIfaceFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceFlowControl.setStatus('current')
if mibBuilder.loadTexts: hmIfaceFlowControl.setDescription('Enables or disables flow control per port')
hmIfacePriorityThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfacePriorityThreshold.setStatus('current')
if mibBuilder.loadTexts: hmIfacePriorityThreshold.setDescription('This object is used to support the dot1dTrafficClassTable.\r\n\t\t\t\t\t\t It defines the thresholds of the available priority-classes.\r\n\t\t\t\t\t\t Starting at MACH Release 2.20 this variable is not used any more.')
hmIfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceName.setStatus('current')
if mibBuilder.loadTexts: hmIfaceName.setDescription('User configurable textual description of the interface. On devices\r\n                         which support Power over Ethernet (IEEE 802.af), this object is \r\n                         mapped to pethPsePortType of the RFC3621 MIB.')
hmIfaceTrunkID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceTrunkID.setStatus('current')
if mibBuilder.loadTexts: hmIfaceTrunkID.setDescription('If the value of this variable is greater 0 then it belongs\r\n\t\t\t\t\t\t to the link aggregation instance with the same index. If \r\n\t\t\t\t\t\t the value is 0 no link aggregation uses this interface.')
hmIfacePrioTOSEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfacePrioTOSEnable.setStatus('current')
if mibBuilder.loadTexts: hmIfacePrioTOSEnable.setDescription('Enable or disable Priority setting from IP TOS field.')
hmIfaceBcastLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceBcastLimit.setStatus('current')
if mibBuilder.loadTexts: hmIfaceBcastLimit.setDescription('Broadcast rate: maximum number of broadcasts to be sent  \r\n\t\t\t\t on this port within one second, use 0 for no limitation.')
hmIfaceUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceUtilization.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilization.setDescription('The best estimate of the mean physical layer\r\n\t\t\t\t  network utilization on this interface during the \r\n\t\t\t\t  last sampling interval, in hundredths of a percent.\r\n\t\t\t\t  The first historyControlInterval (rfc1757) of this\r\n\t\t\t\t  interface is used as sampling interval.')
hmIfaceUtilizationControlInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceUtilizationControlInterval.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilizationControlInterval.setDescription('The interval in seconds over which the data is\r\n\t\t\t\tsampled for hmIfaceUtilization.\r\n\t\t\t\tThis interval can be any number of seconds\r\n\t\t\t\tbetween 1 and 3600 (1 hour).\r\n\t\t\t\tThe first historyControlInterval (rfc1757) of this\r\n\t\t\t\tinterface is used as sampling interval.')
hmIfaceStpBpduGuardEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceStpBpduGuardEnable.setStatus('current')
if mibBuilder.loadTexts: hmIfaceStpBpduGuardEnable.setDescription('Enabled or disabled the BPDU guard functionality per port.\r\n                 If BPDU guard functionality are global enabled (hmSysStpBPDUGuardEnable=enable(1)),\r\n                 and BPDU guard are enabled per port (hmIfaceStpBpduGuardEnable=enable(1)) and (R)STP are globally enabled\r\n                 and an BPDU are received on the port, then hmIfaceStpBpduGuardStatus is set to true(1) for this port and \r\n                 IfAdminStatus for this port is set to down(2).\r\n                 Variable hmIfaceStpBpduGuardStatus can be reset to their original value (=false) with switching BPDU guard\r\n                 functionality globally off.\r\n                 IfAdminStatus can be reset to to their original values up() only manually.')
hmIfaceStpBpduGuardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceStpBpduGuardStatus.setStatus('current')
if mibBuilder.loadTexts: hmIfaceStpBpduGuardStatus.setDescription('Advertised the state of BPDU guard functionality for this port.\r\n                  If BPDU guard functionality fot this port is disabled or guard \r\n                  functionality is enabled, but no BPDUs are received on this port, \r\n                  then hmIfaceStpBpduGuardStatus is set to false(2) for this port.\r\n                  If BPDU is received on an port with enabled BPDU guard functionality for this port \r\n                  (hmIfaceStpBpduGuardEnable=enable(1)) and globally (hmSysStpBPDUGuardEnable=enable(1))\r\n                  then hmIfaceStpBpduGuardStatus is set to true(1) and additionally IfAdminStatus for \r\n                  this port is set to down(2).\r\n                  Variable hmIfaceStpBpduGuardStatus can be reset (to their original values (=false)) \r\n                  with switching BPDU guard functionality globally off.\r\n                  IfAdminStatus can be again reset to to their original values up() only manually.')
hmIfaceCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceCapability.setStatus('current')
if mibBuilder.loadTexts: hmIfaceCapability.setDescription('Capability of the interface coded as an integer value\r\n\t\t\twith each bit representing a special capability.\r\n\t\t\t\r\n\t\t\tMeaning of the bits:\r\n\t\t\tBit 0: cabletest capability\r\n\t\t\tBit 1: realtime capability according to IEEE 1588.\r\n\t\t\t')
hmIfaceIngressLimiterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("bc", 2), ("bc-mc", 3), ("bc-mc-uuc", 4))).clone('bc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceIngressLimiterMode.setStatus('current')
if mibBuilder.loadTexts: hmIfaceIngressLimiterMode.setDescription('The ingress limiter can work in different modes.\r\n                         Mode all limits the complete ingress traffic.\r\n                         Mode bc limits only the ingress broadcast traffic.\r\n                         Mode bc_mc limits the ingress broadcast and multicast traffic.\r\n                         Mode bc_mc_uuc limits the ingress broadcast, multicast and \r\n                         unknown unicast traffic.\r\n                         The limiter is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIfaceIngressLimiterCalculationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bytebased", 1), ("packetbased", 2))).clone('bytebased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceIngressLimiterCalculationMode.setStatus('current')
if mibBuilder.loadTexts: hmIfaceIngressLimiterCalculationMode.setDescription('The ingress limiter can measure the traffic\r\n                         on a bytes per second\r\n                         or on a packets per second basis.\r\n                         The limiter calculation mode is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIfaceIngressLimiterRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceIngressLimiterRate.setStatus('current')
if mibBuilder.loadTexts: hmIfaceIngressLimiterRate.setDescription('The rate of the ingress limiter.\r\n                         The value 0 disables the limiter.\r\n\t\t\t')
hmIfaceEgressLimiterMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("bc", 2), ("bc-mc", 3), ("bc-mc-uuc", 4))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceEgressLimiterMode.setStatus('current')
if mibBuilder.loadTexts: hmIfaceEgressLimiterMode.setDescription('The egress limiter can work in different modes.\r\n                         Mode all limits the complete egress traffic.\r\n                         Mode bc limits only the egress broadcast traffic.\r\n                         Mode bc_mc limits the egress broadcast and multicast traffic.\r\n                         Mode bc_mc_uuc limits the egress broadcast, multicast and \r\n                         unknown unicast traffic.\r\n                         The limiter is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIfaceEgressLimiterCalculationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bytebased", 1), ("packetbased", 2))).clone('bytebased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceEgressLimiterCalculationMode.setStatus('current')
if mibBuilder.loadTexts: hmIfaceEgressLimiterCalculationMode.setDescription('The egress limiter can measure the traffic\r\n                         on a bytes per second\r\n                         or on a packets per second basis.\r\n                         The limiter calculation mode is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIfaceEgressLimiterRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceEgressLimiterRate.setStatus('current')
if mibBuilder.loadTexts: hmIfaceEgressLimiterRate.setDescription('The rate of the egress limiter.\r\n                         The value 0 disables the limiter.\r\n                        ')
hmIfaceUtilizationAlarmUpperThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmUpperThreshold.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmUpperThreshold.setDescription('Surveys the interface utilization hmIfaceUtilization and\r\n\t\t\t\t   generates an alarm for this interfaces, if the given\r\n\t\t\t\t   limit is exceeded. \r\n\t\t\t\t   A value of 0 disables the alarm generation.')
hmIfaceUtilizationAlarmLowerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmLowerThreshold.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmLowerThreshold.setDescription('Surveys the interface utilization hmInfaceUtilization and\r\n\t\t\t\t   removes the alarm condition for this interfaces, if  \r\n\t\t\t\t   the utilization value is below the given limit.\r\n\t\t\t\t   A value of 0 disables the alarm removal.')
hmIfaceUtilizationAlarmCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 26), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmCondition.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilizationAlarmCondition.setDescription('The alarm condition is given (true), if the given\r\n\t\t\t\t   hmIfaceUtilizationAlarmUpperThreshold limit is exceeded \r\n\t\t\t\t   by the interface utilization. The alarm condition\r\n\t\t\t\t   will be removed, when the interface utilization falls\r\n\t\t\t\t   below the hmIfaceUtilizationAlarmLowerThreshold.')
hmIfaceCableCrossing = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("unsupported", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceCableCrossing.setStatus('current')
if mibBuilder.loadTexts: hmIfaceCableCrossing.setDescription("This variable configures the cable crossing\r\n\t\t\t       on twisted pair cables.\r\n\t\t\t       When set to 'enable', the port uses\r\n\t\t\t       the crossover mode.\r\n\t\t\t       When set to 'disable', the port does not use\r\n\t\t\t       the crossover mode.\r\n\t\t\t       'Unsupported' is shown, if a port does not\r\n\t\t\t       support cable crossing.\r\n\t\t\t       It is not possible to set 'unsupported' to\r\n\t\t\t       any type of port.")
hmIfacePhyFastLinkDetection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("unsupported", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfacePhyFastLinkDetection.setStatus('current')
if mibBuilder.loadTexts: hmIfacePhyFastLinkDetection.setDescription("This variable configures the PHY specific\r\n\t\t\t\t\tfast link detection feature on this port.\r\n\t\t\t\t\t'Unsupported' is shown, if a port does not\r\n\t\t\t\t\tsupport this feature.\r\n\t\t\t\t\tIt is not possible to set 'unsupported' to\r\n\t\t\t\t\tany type of port.")
hmIfaceAcceptableFrameTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 11, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("admitAll", 1), ("admitOnlyVlanTagged", 2), ("admitOnlyUntagged", 3))).clone('admitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceAcceptableFrameTypes.setStatus('obsolete')
if mibBuilder.loadTexts: hmIfaceAcceptableFrameTypes.setDescription("This object is 'obsolete' and is replaced by hmIfaceExtAcceptableFrameTypes.\r\n\t\t\t\t\t When this is admitOnlyVlanTagged(2) the device will\r\n\t\t\t\t\t discard untagged frames received on this port. \r\n\t\t\t\t\t When admitOnlyUntagged(3), the device will discard any \r\n\t\t\t\t\t frames with a VLAN tag. When admitAll(1), all frames are \r\n\t\t\t\t\t accepted and untagged or Priority-Tagged frames received \r\n\t\t\t\t\t on this port will be assigned to the PVID for this port.\r\n\r\n\t\t\t\t\t This control does not affect VLAN independent BPDU\r\n\t\t\t\t\t frames, such as GVRP and STP.  It does affect VLAN\r\n\t\t\t\t\t dependent BPDU frames, such as GMRP.")
hmInterfaceExtTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 100), )
if mibBuilder.loadTexts: hmInterfaceExtTable.setStatus('current')
if mibBuilder.loadTexts: hmInterfaceExtTable.setDescription('This table contains variables for each interface of\r\n\t\t\t\t the switch.')
hmInterfaceExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 100, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmInterfaceExtEntry.setStatus('current')
if mibBuilder.loadTexts: hmInterfaceExtEntry.setDescription('The entry of the hmInterfaceExtTable.')
hmIfaceExtAcceptableFrameTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("admitAll", 1), ("admitOnlyVlanTagged", 2), ("admitOnlyUntagged", 3))).clone('admitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIfaceExtAcceptableFrameTypes.setStatus('current')
if mibBuilder.loadTexts: hmIfaceExtAcceptableFrameTypes.setDescription('When this is admitOnlyVlanTagged(2) the device will\r\n\t\t\t\tdiscard untagged frames received on this port. \r\n\t\t\t\tWhen admitOnlyUntagged(3), the device will discard any \r\n\t\t\t\tframes with a VLAN tag. When admitAll(1), all frames are \r\n\t\t\t\taccepted and untagged or Priority-Tagged frames received \r\n\t\t\t\ton this port will be assigned to the PVID for this port.\r\n\r\n\t\t\t\tThis control does not affect VLAN independent BPDU\r\n\t\t\t\tframes, such as GVRP and STP.  It does affect VLAN\r\n\t\t\t\tdependent BPDU frames, such as GMRP.')
hmTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12), )
if mibBuilder.loadTexts: hmTrunkTable.setStatus('current')
if mibBuilder.loadTexts: hmTrunkTable.setDescription('This table contains variables for each trunk of\r\n\t\t\t\t the switch.')
hmTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmTrunkID"))
if mibBuilder.loadTexts: hmTrunkEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrunkEntry.setDescription('The entry of the hmTrunkTable.')
hmTrunkID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrunkID.setStatus('current')
if mibBuilder.loadTexts: hmTrunkID.setDescription('Index to identify a link aggregation instance')
hmTrunkInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrunkInterfaces.setStatus('current')
if mibBuilder.loadTexts: hmTrunkInterfaces.setDescription('List of interfaces which are aggregated in the trunk.\r\n\t\t\t\t each octet pair contains the slotID and interfaceID.\r\n\t\t\t\t Interfaces are added or deleteted using the variable\r\n\t\t\t\t hmIfaceTrunkID.')
hmTrunkName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrunkName.setStatus('current')
if mibBuilder.loadTexts: hmTrunkName.setDescription('Textual description of the trunk')
hmTrunkAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAction", 1), ("resetStats", 2))).clone('noAction')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrunkAction.setStatus('current')
if mibBuilder.loadTexts: hmTrunkAction.setDescription('action according to hmIfaceAction which is performed\r\n\t\t\t\t for all interfaces in the trunk')
hmTrunkAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrunkAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmTrunkAdminStatus.setDescription('The desired state of the trunk. if this variable\r\n\t\t\t\t  is set to down(2), all interfaces which are aggregated\r\n\t\t\t\t  in the trunk are switched off simultaneously. Reading\r\n\t\t\t\t  this variable returns up(1) if at least one interface \r\n\t\t\t\t  of the trunk is operational (up).')
hmTrunkOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrunkOperStatus.setStatus('current')
if mibBuilder.loadTexts: hmTrunkOperStatus.setDescription('The operational state of the trunk. Reading this\r\n\t\t\t\t  variable returns up(1) if at least one interface \r\n\t\t\t\t  of the trunk is operational (up).')
hmTrunkLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 12, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrunkLastChange.setStatus('current')
if mibBuilder.loadTexts: hmTrunkLastChange.setDescription('Time since system boot when there was a change in either\r\n\t\t\t\t the operational state of the trunk or the list of aggregated\r\n\t\t\t\t interfaces.')
hmSFPTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13), )
if mibBuilder.loadTexts: hmSFPTable.setStatus('current')
if mibBuilder.loadTexts: hmSFPTable.setDescription('This table contains variables for each SFP.')
hmSFPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSfpGroupID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmSfpID"))
if mibBuilder.loadTexts: hmSFPEntry.setStatus('current')
if mibBuilder.loadTexts: hmSFPEntry.setDescription('Entry for a detected SFP.')
hmSfpGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: hmSfpGroupID.setStatus('current')
if mibBuilder.loadTexts: hmSfpGroupID.setDescription('Index to identify a module.\r\n\t\t\t This value is never greater than hmSysGroupModuleCapacity.')
hmSfpID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)))
if mibBuilder.loadTexts: hmSfpID.setStatus('current')
if mibBuilder.loadTexts: hmSfpID.setDescription('Index to identify an interface within a module.\r\n\t\t\t This value is never greater than hmSysModulePortCapacity.')
hmSfpConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 7, 8, 11, 33))).clone(namedValues=NamedValues(("non-sfp", 1), ("fiberjack", 6), ("lc", 7), ("mt-rj", 8), ("optical-pigtail", 11), ("copper-pigtail", 33)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpConnector.setStatus('current')
if mibBuilder.loadTexts: hmSfpConnector.setDescription("The SFP's Connector Type.")
hmSfpTransceiver = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 30, 31, 32, 40, 41))).clone(namedValues=NamedValues(("ge-1000-base-sx", 1), ("ge-1000-base-lx", 2), ("ge-1000-base-cx", 4), ("ge-1000-base-t", 8), ("unsupported", 9), ("oc3-mm-sr", 10), ("oc3-sm-ir", 11), ("oc3-sm-lr", 12), ("oc12-mm-sr", 13), ("oc12-sm-ir", 14), ("oc12-sm-lr", 15), ("oc48-sr", 16), ("oc48-ir", 17), ("oc48-lr", 18), ("xfp-10gbase-sr", 30), ("xfp-10gbase-lr", 31), ("xfp-10gbase-er", 32), ("microfx", 40), ("pof", 41)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpTransceiver.setStatus('current')
if mibBuilder.loadTexts: hmSfpTransceiver.setDescription("The SFP's Transceiver type.")
hmSfpVendorOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpVendorOUI.setStatus('current')
if mibBuilder.loadTexts: hmSfpVendorOUI.setDescription("The SFP's vendor IEEE company ID (OUI). ")
hmSfpVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpVendorName.setStatus('current')
if mibBuilder.loadTexts: hmSfpVendorName.setDescription("The SFP's vendor name (ASCII). ")
hmSfpPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpPartNumber.setStatus('current')
if mibBuilder.loadTexts: hmSfpPartNumber.setDescription("The SFP's part description number (ASCII). ")
hmSfpPartRev = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpPartRev.setStatus('current')
if mibBuilder.loadTexts: hmSfpPartRev.setDescription("The SFP's part revision number (ASCII).")
hmSfpSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpSerialNum.setStatus('current')
if mibBuilder.loadTexts: hmSfpSerialNum.setDescription("The SFP's serial number provided by vendor (ASCII). ")
hmSfpDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpDateCode.setStatus('current')
if mibBuilder.loadTexts: hmSfpDateCode.setDescription("The SFP's vendor manufacturing date code. Format is YY:MM:DD.")
hmSfpBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpBitRate.setStatus('current')
if mibBuilder.loadTexts: hmSfpBitRate.setDescription("The SFP's nominal bitrate in units of MBits/sec. \r\n\t\t\t\t Contains -1 in case of a device read error.")
hmSfpTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpTemperature.setStatus('current')
if mibBuilder.loadTexts: hmSfpTemperature.setDescription('This signed integer is used to identify\r\n \t\t\t\tthe temperature within the SFP in units of centigrade (celsius). \r\n \t\t\t\tContains -1000 in case of a device read error.')
hmSfpTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpTxPower.setStatus('current')
if mibBuilder.loadTexts: hmSfpTxPower.setDescription("The SFP's internally measured Tx Power in units of milliWatts.\r\n\t\t\t\t(ASCII representation of floating point number).")
hmSfpRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpRxPower.setStatus('current')
if mibBuilder.loadTexts: hmSfpRxPower.setDescription("The SFP's internally measured Rx Power in units of milliWatts.\r\n\t\t\t\t(ASCII representation of floating point number).")
hmSfpTxPowerInt = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpTxPowerInt.setStatus('current')
if mibBuilder.loadTexts: hmSfpTxPowerInt.setDescription("The SFP's internally measured Tx Power in units of 1/10 microWatts.")
hmSfpRxPowerInt = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpRxPowerInt.setStatus('current')
if mibBuilder.loadTexts: hmSfpRxPowerInt.setDescription("The SFP's internally measured Rx Power in units of 1/10 microWatts.")
hmSfpRxPowerState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("alarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpRxPowerState.setStatus('current')
if mibBuilder.loadTexts: hmSfpRxPowerState.setDescription("The state of the SFP's internally measured Rx.")
hmSfpInfoVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpInfoVersion.setStatus('current')
if mibBuilder.loadTexts: hmSfpInfoVersion.setDescription("Version of SFP's Hirschmann Information. \r\n\t\t\t\tContains -1 in case of a device read error.")
hmSfpInfoPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpInfoPartNumber.setStatus('current')
if mibBuilder.loadTexts: hmSfpInfoPartNumber.setDescription("Part Number of SFP's Hirschmann Information.")
hmSfpInfoPartId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpInfoPartId.setStatus('current')
if mibBuilder.loadTexts: hmSfpInfoPartId.setDescription("Part Identifier of SFP's Hirschmann Information.")
hmSfpInfoMagic = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpInfoMagic.setStatus('current')
if mibBuilder.loadTexts: hmSfpInfoMagic.setDescription('1, if SFP contains vendor specific information by Hirschmann, otherwise 0.')
hmSfpSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpSupported.setStatus('current')
if mibBuilder.loadTexts: hmSfpSupported.setDescription('Indicates if the local agent supports this SFP.')
hmSfpMaxLength_fiber_9 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 30), Integer32()).setLabel("hmSfpMaxLength-fiber-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_9.setStatus('current')
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_9.setDescription("Max. usable length for the cable type '9/125 micrometer fiber'\r\n\t\t            with this SFP in units of meters. ")
hmSfpMaxLength_fiber_50 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 31), Integer32()).setLabel("hmSfpMaxLength-fiber-50").setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_50.setStatus('current')
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_50.setDescription("Max. usable length for the cable type '50/125 micrometer fiber'\r\n\t\t            with this SFP in units of meters. ")
hmSfpMaxLength_fiber_62_5 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 32), Integer32()).setLabel("hmSfpMaxLength-fiber-62-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_62_5.setStatus('current')
if mibBuilder.loadTexts: hmSfpMaxLength_fiber_62_5.setDescription("Max. usable length for the cable type '62.5/125 micrometer fiber'\r\n\t\t            with this SFP in units of meters. ")
hmSfpMaxLength_copper = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 33), Integer32()).setLabel("hmSfpMaxLength-copper").setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpMaxLength_copper.setStatus('current')
if mibBuilder.loadTexts: hmSfpMaxLength_copper.setDescription("Max. usable length for the cable type 'copper'\r\n\t\t            with this SFP in units of meters. ")
hmSfpTxPowerdBm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 34), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpTxPowerdBm.setStatus('current')
if mibBuilder.loadTexts: hmSfpTxPowerdBm.setDescription("The SFP's internally measured Tx Power in units of dBm.\r\n\t\t\t\t(ASCII representation of floating point number).")
hmSfpRxPowerdBm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 13, 1, 35), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSfpRxPowerdBm.setStatus('current')
if mibBuilder.loadTexts: hmSfpRxPowerdBm.setDescription("The SFP's internally measured Rx Power in units of dBm.\r\n\t\t\t\t(ASCII representation of floating point number).")
hmSysChassisName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysChassisName.setStatus('current')
if mibBuilder.loadTexts: hmSysChassisName.setDescription('This displaystring represents the name of the Chassis.\r\n\t\t\t\t Any change of this variable will cause an automatically\r\n\t\t\t\t update of this value on each Basic Board in this Chassis.')
hmSysStpEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysStpEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysStpEnable.setDescription('This variable controls the STP operation of the entire\r\n\t\t\t\t switch. To control the STP function of each port use\r\n\t\t\t\t hmIfaceStpEnable')
hmSysFlowControl = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysFlowControl.setStatus('current')
if mibBuilder.loadTexts: hmSysFlowControl.setDescription('enables or disables flow control for the switch unit.')
hmSysBOOTPEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysBOOTPEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysBOOTPEnable.setDescription('Enable/Disable BOOTP operation. A (1) enables, a (2) disables.\r\n\t\t\t\t When disabled, no BOOTPs are transmitted by the system.\r\n\t\t\t\t When enabled, the system sends BOOTP requests at booting.')
hmSysDHCPEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysDHCPEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysDHCPEnable.setDescription('Enable/Disable DHCP operation. A (1) enables, a (2) disables.\r\n\t\t\t\t When disabled, no DHCPs are transmitted by the system.\r\n\t\t\t\t When enabled, the system sends DHCP requests at booting.')
hmSysTelnetEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysTelnetEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysTelnetEnable.setDescription('Enable/Disable Telnet operation. A (1) enables, a (2) disables.\r\n\t\t\t\t When disabled, no Telnet sessions are allowed by the system.')
hmSysHTTPEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysHTTPEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysHTTPEnable.setDescription('Enable/Disable HTTP connection. A (1) enables, a (2) disables.\r\n\t\t\t\t When disabled, no HTTP is allowed by the system.')
hmSysPlugAndPlay = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysPlugAndPlay.setStatus('current')
if mibBuilder.loadTexts: hmSysPlugAndPlay.setDescription('Enable/Disable Plug&Play feature. A (1) enables, a (2) disables.\r\n\t\t\t\t if this variable is set to enable(1), special Plug&Play actions are\r\n\t\t\t\t performed at boot time and after a successful completion the value\r\n\t\t\t\t is automatically reset to the disable(2) state.')
hmBcastLimiterMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmBcastLimiterMode.setStatus('current')
if mibBuilder.loadTexts: hmBcastLimiterMode.setDescription('Global configuration of feature broadcast limiter.\r\n\t\t\t\tIf enabled, for each port the maximum rate of broadcasts\r\n\t\t\t\tcan be specified.')
hmSystemTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 30), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSystemTime.setStatus('current')
if mibBuilder.loadTexts: hmSystemTime.setDescription('Time measured in seconds since 00:00:00 UTC, January 1, 1970.\r\n\t\t\t\t The clock of the agents may be set using this variable.\r\n\t\t\t\t Changing this variable on one agent automatically updates\r\n\t\t\t\t the value on the other agents in the same chassis.')
hmSystemTimeSource = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 1), ("sntp", 2), ("ptp", 3), ("gps", 4), ("ntp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSystemTimeSource.setStatus('current')
if mibBuilder.loadTexts: hmSystemTimeSource.setDescription('Shows the source of the system time.')
hmSysStpBPDUGuardEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysStpBPDUGuardEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysStpBPDUGuardEnable.setDescription('This variable controls the BPDU Guard operation of the entire\r\n\t\t\t\t switch (globally). To control the BPDU Guard function of each port use\r\n\t\t\t\t hmIfaceStpBpduGuardEnable. \r\n                 If BPDU guard functionality are global enabled (hmSysStpBPDUGuardEnable=enable(1)),\r\n                 and BPDU guard are enabled per port (hmIfaceStpBpduGuardEnable=enable(1)) and (R)STP are globally enabled \r\n                 and an BPDU are received on the port, then hmIfaceStpBpduGuardStatus is set to true(1) for this port and \r\n                 IfAdminStatus is set to down(2) for this port.\r\n                 Variable hmIfaceStpBpduGuardStatus can be reset (to their original values (=false)) with switching \r\n                 BPDU guard functionality globally off (hmSysStpBPDUGuardEnable=disable(2)).\r\n                 IfAdminStatus can be again reset to to their original values up() only manually.\r\n                 The default value of hmSysStpBPDUGuardEnable is disable(2).')
hmSysSTPErrorNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSTPErrorNumber.setStatus('current')
if mibBuilder.loadTexts: hmSysSTPErrorNumber.setDescription('Advertised the reason why (R)STP could not be switched on. \r\n\t\t\t\t  Error reasons are coded as OR operation bit by bit, see values:\r\n\t\t\t\t  0x00  - no errors - (R)STP is switched on,\r\n                  0x01  - (R)STP cannot be switched on, because of standby mode,\r\n                  0x02  - (R)STP cannot be switched on, because of kopp Local Active,\r\n                  0x04  - (R)STP cannot be switched on, because of kopp Slave Active,\r\n                  0x08  - (R)STP cannot be switched on, because of kopp Master Active,\r\n                  0x10  - (R)STP cannot be switched on, because of sysRingOn and sysRMMode,\r\n                  0x20  - (R)STP cannot be switched on, because of error if BB_SetParameter is occured.\r\n                  ')
hmSysSoftwareCapability = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 34), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSoftwareCapability.setStatus('current')
if mibBuilder.loadTexts: hmSysSoftwareCapability.setDescription('This variable shows the capability of the running software. \r\n                 The string is formated as follow:\r\n                 Byte 1 : Always L (for Layer)\r\n                 Byte 2 : 2 or 3 (dependend if the software supports onyl switching (2) \r\n                          or also routing (3))\r\n                 Byte 3 : E or P (Enhanced or Professional software functionality)\r\n                 ')
hmLEDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35))
hmLEDRSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 1))
hmLEDRSPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 1, 1), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSPowerSupply.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSPowerSupply.setDescription('Status from the PowerSupply LED.')
hmLEDRStandby = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 1, 2), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRStandby.setStatus('current')
if mibBuilder.loadTexts: hmLEDRStandby.setDescription('Status from the Standby LED.')
hmLEDRSRedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 1, 3), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRedundancyManager.setDescription('Status from the RM LED.')
hmLEDRSFault = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 1, 4), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSFault.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSFault.setDescription('Status from the Fault LED.')
hmLEDOctGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 2))
hmLEDOctPowerSupply1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 2, 1), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDOctPowerSupply1.setStatus('current')
if mibBuilder.loadTexts: hmLEDOctPowerSupply1.setDescription('Status from the PowerSupply 1 LED.')
hmLEDOctPowerSupply2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 2, 2), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDOctPowerSupply2.setStatus('current')
if mibBuilder.loadTexts: hmLEDOctPowerSupply2.setDescription('Status from the PowerSupply 2 LED.')
hmLEDOctRedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 2, 3), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDOctRedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmLEDOctRedundancyManager.setDescription('Status from the RM LED.')
hmLEDOctFault = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 2, 4), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDOctFault.setStatus('current')
if mibBuilder.loadTexts: hmLEDOctFault.setDescription('Status from the Fault LED.')
hmLEDRSRGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3))
hmLEDRSRPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 1), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRPowerSupply.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRPowerSupply.setDescription('Status from the PowerSupply LED.')
hmLEDRSRStandby = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 2), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRStandby.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRStandby.setDescription('Status from the Standby LED.')
hmLEDRSRRedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 3), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRRedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRRedundancyManager.setDescription('Status from the RM LED.')
hmLEDRSRFault = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 4), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRFault.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRFault.setDescription('Status from the Fault LED.')
hmLEDRSRRelay1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 5), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRRelay1.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRRelay1.setDescription('Status from the Relay1 LED.')
hmLEDRSRRelay2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 3, 6), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDRSRRelay2.setStatus('current')
if mibBuilder.loadTexts: hmLEDRSRRelay2.setDescription('Status from the Relay2 LED.')
hmLEDMarGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4))
hmLEDMarPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 1), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarPowerSupply.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarPowerSupply.setDescription('Status from the PowerSupply LED.')
hmLEDMarStandby = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 2), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarStandby.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarStandby.setDescription('Status from the Standby LED.')
hmLEDMarRedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 3), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarRedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarRedundancyManager.setDescription('Status from the RM LED.')
hmLEDMarFault = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 4), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarFault.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarFault.setDescription('Status from the Fault LED.')
hmLEDMarRelay1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 5), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarRelay1.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarRelay1.setDescription('Status from the Relay1 LED.')
hmLEDMarRelay2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 35, 4, 6), LEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLEDMarRelay2.setStatus('current')
if mibBuilder.loadTexts: hmLEDMarRelay2.setDescription('Status from the Relay2 LED.')
hmDIPSwitchGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36))
hmDIPSwitchRSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 1))
hmDIPSwitchRSRedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 1, 1), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchRSRedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchRSRedundancyManager.setDescription('Status from redundancy manager DIP switch.')
hmDIPSwitchRSStandby = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 1, 2), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchRSStandby.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchRSStandby.setDescription('Status from Standby DIP switch.')
hmDIPSwitchMICEGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 2))
hmDIPSwitchMICERedundancyManager = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 2, 1), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchMICERedundancyManager.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchMICERedundancyManager.setDescription('Status from redundancy manager DIP switch.')
hmDIPSwitchMICERingPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 2, 2), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchMICERingPort.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchMICERingPort.setDescription('Status from ring ports DIP switch.\r\n\t\ton  (1) indicates port 1 on module 1 and port 1 on module 2 are used as ring ports.\r\n\t\toff (2) indicates port 1 and 2 on module 1 are used as ring ports.')
hmDIPSwitchMICEStandby = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 2, 3), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchMICEStandby.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchMICEStandby.setDescription('Status from Standby DIP switch.')
hmDIPSwitchMICEConfig = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 2, 4), DIPSwitchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchMICEConfig.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchMICEConfig.setDescription('Status from DIP switch configuration.\r\n\t\ton  (1) indicates DIP switch configuration is enabled.\r\n\t\toff (2) indicates DIP switch configuration is disabled.')
hmDIPSwitchAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDIPSwitchAdminState.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchAdminState.setDescription('Enable or Disable the DIP switch configuration. \r\n          If set to disable DIP switches are ignored.')
hmDIPSwitchConflict = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 36, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDIPSwitchConflict.setStatus('current')
if mibBuilder.loadTexts: hmDIPSwitchConflict.setDescription('TRUE if hmDIPSwitchAdminState is set to disable and hardware DIP \r\n         switch setting is enabled.')
hmSysMaxTrunks = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysMaxTrunks.setStatus('current')
if mibBuilder.loadTexts: hmSysMaxTrunks.setDescription('Maximum number of trunks for this chassis.')
hmLimiterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38))
hmIngressLimiterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1))
hmIngressLimiterEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIngressLimiterEnable.setStatus('current')
if mibBuilder.loadTexts: hmIngressLimiterEnable.setDescription('The global ingress limiter can be enabled or disabled.\r\n\t\t\t')
hmIngressLimiterMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 1), ("bc", 2), ("bc-mc", 3), ("bc-mc-uuc", 4))).clone('bc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIngressLimiterMode.setStatus('current')
if mibBuilder.loadTexts: hmIngressLimiterMode.setDescription('The global ingress limiter can work in different modes.\r\n                         Mode all limits the complete ingress traffic.\r\n                         Mode bc limits only the ingress broadcast traffic.\r\n                         Mode bc_mc limits the ingress broadcast and multicast traffic.\r\n                         Mode bc_mc_uuc limits the ingress broadcast, multicast and \r\n                         unknown unicast traffic.\r\n                         The limiter is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIngressUnknUcLimiterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 3))
hmIngressUnknUcLimiterMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIngressUnknUcLimiterMode.setStatus('current')
if mibBuilder.loadTexts: hmIngressUnknUcLimiterMode.setDescription('The global unknown unicast ingress limiter can be enabled or disabled.\r\n                         The limiter is hardware dependend. \r\n\t\t\t')
hmIngressUnknUcLimiterCalculationMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bytebased", 1), ("packetbased", 2))).clone('bytebased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIngressUnknUcLimiterCalculationMode.setStatus('current')
if mibBuilder.loadTexts: hmIngressUnknUcLimiterCalculationMode.setDescription('The global unknown unicast ingress limiter\r\n                         can measure the traffic on a bytes per second\r\n                         or on a packets per second basis.\r\n                         The limiter calculation mode is hardware dependend. \r\n                         Not all modes are available on every hardware.\r\n\t\t\t')
hmIngressUnknUcLimiterRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 1, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIngressUnknUcLimiterRate.setStatus('current')
if mibBuilder.loadTexts: hmIngressUnknUcLimiterRate.setDescription('The rate of the global unknown unicast ingress limiter.\r\n                         The value 0 disables the limiter.\r\n\t\t\t')
hmEgressLimiterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 2))
hmEgressLimiterEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 38, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmEgressLimiterEnable.setStatus('current')
if mibBuilder.loadTexts: hmEgressLimiterEnable.setDescription('The global egress limiter can be enabled or disabled.\r\n\t\t\t')
hmSysUSBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 39))
hmSysMaxUSBPorts = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 39, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysMaxUSBPorts.setStatus('current')
if mibBuilder.loadTexts: hmSysMaxUSBPorts.setDescription('Maximum number of USB ports in this chassis.')
hmSysSwitchGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40))
hmSysSwitchLearning = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchLearning.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchLearning.setDescription('Controls address learning by the switch.\r\n\t\t\t\t When disabled the address database of the switch will\r\n\t\t\t\t not be updated with dynamic filtering entries.\r\n\t\t\t\t Static Filtering Entries and Group Registration Entries\r\n\t\t\t\t are not affected.')
hmSysSwitchMRU = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1522, 1552, 1632, 9022))).clone(namedValues=NamedValues(("size1522", 1522), ("size1552", 1552), ("size1632", 1632), ("size9022", 9022))).clone('size1522')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchMRU.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchMRU.setDescription('The Maximum Receive Unit MRU that \r\n\t\t\t\t can be received by the switch.')
hmSysSwitchFastLinkDetection = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchFastLinkDetection.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchFastLinkDetection.setDescription('Controls if the fast link detection is enabled or not.')
hmSysSwitchAddressRelearnDetection = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchAddressRelearnDetection.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchAddressRelearnDetection.setDescription('Controls if detection of address relearns\r\n\t\t\t\tis enabled or not.')
hmSysSwitchAddressRelearnThreshold = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchAddressRelearnThreshold.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchAddressRelearnThreshold.setDescription('The value of relearnd addresses to signal address\r\n\t\t\trelearn threshold exceeded.')
hmSysSwitchDuplexMismatchDetection = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchDuplexMismatchDetection.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchDuplexMismatchDetection.setDescription('Controls if duplex mismatch detection\r\n\t\t\t\tis enabled or not.')
hmSysSwitchFDBFullCounter = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchFDBFullCounter.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchFDBFullCounter.setDescription('The number of FDB Full indications that the agent has detected since reboot.')
hmSysSwitchFDBHashOptimizingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchFDBHashOptimizingMode.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchFDBHashOptimizingMode.setDescription('Mode to optimize the MAC address table hashing algorithm.\r\n\t\t\t\tWhich modes can be configured is hardware dependend.\r\n\t\t\t\tAfter configuration a reboot is needed.')
hmSysSwitchFDBHashOptimizingStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchFDBHashOptimizingStatus.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchFDBHashOptimizingStatus.setDescription('Shows the current hash mode of this device.')
hmSysSwitchVLANGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 10))
hmSysSwitchVLANLearningMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ivl", 1), ("svl", 2))).clone('ivl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchVLANLearningMode.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchVLANLearningMode.setDescription('Controls the VLAN learning mode by the switch.\r\n\t\t\t\tWhen set to IVL Independend VLAN Learning is active.\r\n\t\t\t\tWhen set to SVL Shared VLAN Learning is active.\r\n\t\t\t\tAfter setting this variable the switch have to be restarted.')
hmSysSwitchVLANLearningStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ivl", 1), ("svl", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchVLANLearningStatus.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchVLANLearningStatus.setDescription('Shows the current VLAN learning mode.\r\n\t\t\t\tWhen set to IVL Independend VLAN Learning is active.\r\n\t\t\t\tWhen set to SVL Shared VLAN Learning is active.')
hmSysSwitchServiceModeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 11))
hmSysSwitchServiceMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchServiceMode.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchServiceMode.setDescription('Enables the service mode.\r\n\t\t\tIf enabled, the switch can be separated into two switching areas \r\n\t\t\twith the redundant power supply.\r\n\t\t\tThe two HIPER Ring ports are in area one.\r\n\t\t\tThe other ports are in area two.\r\n\t\t\tArea one is VLAN capable, area two is not VLAN capable.\r\n\t\t\t')
hmSysSwitchServiceVlan = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 11, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchServiceVlan.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchServiceVlan.setDescription('Defined the Vlan for the service mode.\r\n\t\t\tThe Vlan must be a valid Vlan and neither Vlan 0 (mgmt vlan)\r\n\t\t\tnor Vlan 1 (Default Vlan).')
hmSysSwitchServiceModeOperState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchServiceModeOperState.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchServiceModeOperState.setDescription('If enabled, the switch has been separated into two switching areas \r\n\t\t\twith the redundant power supply.\r\n\t\t\tThe two HIPER Ring ports are in area one.\r\n\t\t\tThe other ports are in area two.\r\n\t\t\tArea one is VLAN capable, area two is not VLAN capable.\r\n\t\t\t')
hmSysSwitchRedundancyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 20))
hmSysSwitchRedundancyRstpMrpMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpMode.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpMode.setDescription('Rstp Mrp is enabled if this object is set to enable(1).\r\n\t\t\t Rstp Mrp is disabled if this object is set to disable(2).')
hmSysSwitchRedundancyRstpMrpConfigError = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 20, 2), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpConfigError.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpConfigError.setDescription('This object indicates a Rstp Mrp fail configuration if the value\r\n\t\t\t true is shown.')
hmSysSwitchRedundancyRstpMrpConfigErrorBridge = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 40, 20, 3), BridgeIdOrNull()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpConfigErrorBridge.setStatus('current')
if mibBuilder.loadTexts: hmSysSwitchRedundancyRstpMrpConfigErrorBridge.setDescription('The identifier of the device which has a Rstp Mrp fail\r\n\t\t\t configuration or Null if there is no fail configuration.')
hmSysSelftestGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41))
hmSysSelftestRAM = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSelftestRAM.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestRAM.setDescription('Controls RAM selftest on coldstart of the device.\r\n\t\t\t\t When disabled the device booting time is reduced.')
hmSysSelftestRebootOnError = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSelftestRebootOnError.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestRebootOnError.setDescription('If enabled the software does make a reboot if there is a \r\n                      serious error detected.')
hmSysSelftestMMUStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysSelftestMMUStatus.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestMMUStatus.setDescription('Status of the memory managment unit.')
hmSysSelftestRebootOnHdxError = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSelftestRebootOnHdxError.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestRebootOnHdxError.setDescription('If enabled the software does a reboot if there is a \r\n                   Half duplex mismatch error is detected. The option depends on hmSysSelftestRebootOnError.')
hmSysSelftestSysMon = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 41, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSelftestSysMon.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestSysMon.setDescription('Enable or disable the System Monitor access during \r\n\t\t\t  the boot phase. Please note: If the System Monitor \r\n\t\t\t  is disabled, it is possible to lose access to the \r\n\t\t\t  device permanently in case of loosing administrator\r\n\t\t\t  password or misconfiguration.')
hmSysOEMGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 42))
hmSysOEMID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 42, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysOEMID.setStatus('current')
if mibBuilder.loadTexts: hmSysOEMID.setDescription('Unique OEM ID.')
hmSysMaxSignalContacts = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysMaxSignalContacts.setStatus('current')
if mibBuilder.loadTexts: hmSysMaxSignalContacts.setDescription('Maximum number of signal contacts for this chassis. Within\r\n\t\t\t\t each managed chassis/switch, the groups are uniquely numbered\r\n\t\t\t\t in the range from 1 to hmSysMaxSignalContacts.')
hmSysHttpsEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysHttpsEnable.setStatus('current')
if mibBuilder.loadTexts: hmSysHttpsEnable.setDescription('Enables/Disables HTTPS access to the device. A (1) enables, a (2) disables.')
hmSysHttpsPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(443)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysHttpsPortNumber.setStatus('current')
if mibBuilder.loadTexts: hmSysHttpsPortNumber.setDescription('The port number of the HTTPS web server.')
hmSysSkipAcaOnBoot = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysSkipAcaOnBoot.setStatus('current')
if mibBuilder.loadTexts: hmSysSkipAcaOnBoot.setDescription('Enable/disable loading from ACA on startup.')
hmSysConsoleServiceShellAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysConsoleServiceShellAdminState.setStatus('current')
if mibBuilder.loadTexts: hmSysConsoleServiceShellAdminState.setDescription('Admin State of service shell. (1=enable, 2=disable).')
hmSysHttpsCertFingerPrintType = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sha1", 1), ("sha256", 2))).clone('sha256')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSysHttpsCertFingerPrintType.setStatus('current')
if mibBuilder.loadTexts: hmSysHttpsCertFingerPrintType.setDescription("Controls HTTPS certificate fingerprint generation. If set to 'sha1' hmSysHttpsCertFingerPrint\r\n         \t will show the SHA1 fingerprint of the certificate.")
hmSysHttpsCertFingerPrint = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 1, 49), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSysHttpsCertFingerPrint.setStatus('current')
if mibBuilder.loadTexts: hmSysHttpsCertFingerPrint.setDescription('The HTTPS certificate fingerprint as hash. The type of the hash is defined with hmSysHttpsCertFingerPrintType.')
hmPSTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 2), )
if mibBuilder.loadTexts: hmPSTable.setStatus('current')
if mibBuilder.loadTexts: hmPSTable.setDescription('This table contains all variables related to the power supply\r\n\t\t\t\t units of the chassis/switch. For each power supply slot exists\r\n\t\t\t\t one instance.')
hmPSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPSSysID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmPSID"))
if mibBuilder.loadTexts: hmPSEntry.setStatus('current')
if mibBuilder.loadTexts: hmPSEntry.setDescription('The entry of the hmPSTable.')
hmPSSysID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSSysID.setStatus('current')
if mibBuilder.loadTexts: hmPSSysID.setDescription('The value of SysID is assigned so as to uniquely identify a\r\n\t\t\t\t chassis/switch among the subordinate managed objects of the\r\n\t\t\t\t system.')
hmPSID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSID.setStatus('current')
if mibBuilder.loadTexts: hmPSID.setDescription('This Index is used to identify the associated power supply\r\n\t\t\t\t unit.')
hmPSState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("failed", 2), ("notInstalled", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSState.setStatus('current')
if mibBuilder.loadTexts: hmPSState.setDescription('Indicates the operational state of the associated power\r\n\t\t\t\t supply. If the value of this variable changes, a hmPowerSupply\r\n\t\t\t\t trap is sent.')
hmPSType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("ac-dc", 2), ("dc-dc-24v-1", 3), ("dc-dc-48v-1", 4), ("dc-dc-24v-2", 5), ("dc-dc-48v-2", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSType.setStatus('current')
if mibBuilder.loadTexts: hmPSType.setDescription('Type of the associated power supply.')
hmPSVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSVersion.setStatus('current')
if mibBuilder.loadTexts: hmPSVersion.setDescription('Version of the associated power supply.')
hmPSDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSDescription.setStatus('current')
if mibBuilder.loadTexts: hmPSDescription.setDescription('Description of the associated power supply.')
hmPSSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSSerialNumber.setStatus('current')
if mibBuilder.loadTexts: hmPSSerialNumber.setDescription('Serial number of the associated power supply.')
hmPSProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSProductCode.setStatus('current')
if mibBuilder.loadTexts: hmPSProductCode.setDescription('Product code of the associated power supply.')
hmPSPowerBudget = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPSPowerBudget.setStatus('current')
if mibBuilder.loadTexts: hmPSPowerBudget.setDescription('Power budget of the associated power supply.')
hmFanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 3), )
if mibBuilder.loadTexts: hmFanTable.setStatus('current')
if mibBuilder.loadTexts: hmFanTable.setDescription('This table contains all variables related to the fan units\r\n\t\t\t\t of the chassis/switch. For each fan slot exists one instance.')
hmFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 3, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmFanSysID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmFanID"))
if mibBuilder.loadTexts: hmFanEntry.setStatus('current')
if mibBuilder.loadTexts: hmFanEntry.setDescription('The entry of the hmFanTable.')
hmFanSysID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFanSysID.setStatus('current')
if mibBuilder.loadTexts: hmFanSysID.setDescription('The value of SysID is assigned so as to uniquely identify a\r\n\t\t\t\t chassis among the subordinate managed objects of the system.')
hmFanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFanID.setStatus('current')
if mibBuilder.loadTexts: hmFanID.setDescription('This Index is used to identify the associated fan.')
hmFanState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFanState.setStatus('current')
if mibBuilder.loadTexts: hmFanState.setDescription('Indicates the operational state of the associated fan.')
hmFwdPriorityConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 4))
hmPrioTOSEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioTOSEnable.setStatus('current')
if mibBuilder.loadTexts: hmPrioTOSEnable.setDescription('Global configuration of feature IP-TOS priority to \r\n\t\t\t\t802.1D-1998 priority. If enabled, the priority of the\r\n\t\t\t\tTOS field is mapped to 802.1D priority')
hmPrioMACAddressEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioMACAddressEnable.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACAddressEnable.setDescription('Global configuration of feature priority by MAC address.\r\n\t\t\t\tIf enabled, for each static MAC address a priority\r\n\t\t\t\tcould be specified')
hmPrioVlan0TagTransparentMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioVlan0TagTransparentMode.setStatus('current')
if mibBuilder.loadTexts: hmPrioVlan0TagTransparentMode.setDescription('enables or disables the transparent mode for\r\n\t\t\t\t priority tagged frames (frames with  VLAN-ID 0)\r\n\t\t\t\t for the switch unit.')
hmPrioMACAddressTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10), )
if mibBuilder.loadTexts: hmPrioMACAddressTable.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACAddressTable.setDescription('Table for assigning priority to MAC addresses')
hmPrioMACAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPrioMACAddress"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmPrioMACReceivePort"))
if mibBuilder.loadTexts: hmPrioMACAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACAddressEntry.setDescription('The entry of the hmPrioMACAddressTable.')
hmPrioMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPrioMACAddress.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACAddress.setDescription('same as dot1dStaticAddress')
hmPrioMACReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPrioMACReceivePort.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACReceivePort.setDescription('to be compatible with dot1dStaticTable')
hmPrioMACPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioMACPriority.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACPriority.setDescription('priority value for the frame with the specific\r\n\t\t\t\t  destination MAC address.\r\n\t\t\t\t  0..7: priority\r\n\t\t\t\t  8   : disabled (no priority by MAC address)\r\n\t\t\t\t  9   : discard the frame ')
hmPrioMACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioMACStatus.setStatus('current')
if mibBuilder.loadTexts: hmPrioMACStatus.setDescription('status flag according to dot1dStaticStatus')
hmPrioTrafficClassTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 11), )
if mibBuilder.loadTexts: hmPrioTrafficClassTable.setStatus('current')
if mibBuilder.loadTexts: hmPrioTrafficClassTable.setDescription('Translation table for traffic classes to 802.1D-1998 priority')
hmPrioTrafficClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 11, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPrioTrafficClassID"))
if mibBuilder.loadTexts: hmPrioTrafficClassEntry.setStatus('current')
if mibBuilder.loadTexts: hmPrioTrafficClassEntry.setDescription('The entry of the hmPrioTrafficClassTable.')
hmPrioTrafficClassID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPrioTrafficClassID.setStatus('current')
if mibBuilder.loadTexts: hmPrioTrafficClassID.setDescription('This index is used to identify the associated traffic class')
hmPrioTrafficClassWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPrioTrafficClassWeight.setStatus('current')
if mibBuilder.loadTexts: hmPrioTrafficClassWeight.setDescription('With this parameter the queue mode of each \r\n\t\t\t\t traffic class can be set.\r\n\t\t\t\t 2..99: weight for WFQ (Weighted-Fair-Queuing)\r\n\t\t\t\t 100:\tstrict priority')
hmPrioTosToPrioTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 12), )
if mibBuilder.loadTexts: hmPrioTosToPrioTable.setStatus('current')
if mibBuilder.loadTexts: hmPrioTosToPrioTable.setDescription('Translation table IP-TOS priority to 802.1D-1998 priority')
hmPrioTosToPrioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 12, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPrioTTPTos"))
if mibBuilder.loadTexts: hmPrioTosToPrioEntry.setStatus('current')
if mibBuilder.loadTexts: hmPrioTosToPrioEntry.setDescription('The entry of the hmPrioTosToPrioEntry.')
hmPrioTTPTos = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPrioTTPTos.setStatus('current')
if mibBuilder.loadTexts: hmPrioTTPTos.setDescription('This index is used to identify the associated TOS value')
hmPrioTTPPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPrioTTPPrio.setStatus('current')
if mibBuilder.loadTexts: hmPrioTTPPrio.setDescription('This index is used to identify the associated 802.1D priority')
hmCurrentAddressTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 5), )
if mibBuilder.loadTexts: hmCurrentAddressTable.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressTable.setDescription('A table containing filtering information\r\n\t\t\t\t\t  configured into the bridge by (local or network)\r\n\t\t\t\t\t  management or dynamic by GMRP or IGMP Snooping\r\n\t\t\t\t\t  specifying the set of ports to which\r\n\t\t\t\t\t  frames received from specific ports and containing\r\n\t\t\t\t\t  specific destination addresses are allowed to be\r\n\t\t\t\t\t  forwarded.  The value of zero in this table as the\r\n\t\t\t\t\t  port number from which frames with a specific\r\n\t\t\t\t\t  destination address are received, is used to\r\n\t\t\t\t\t  specify all ports for which there is no specific\r\n\t\t\t\t\t  entry in this table for that particular\r\n\t\t\t\t\t  destination address.\tEntries are valid for\r\n\t\t\t\t\t  unicast and for group/broadcast addresses.')
hmCurrentAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmCurrentAddress"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmCurrentAddressReceivePort"))
if mibBuilder.loadTexts: hmCurrentAddressEntry.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressEntry.setDescription('Filtering information configured into the bridge\r\n\t\t\t\t\t  by (local or network) management specifying the\r\n\t\t\t\t\t  set of ports to which frames received from a\r\n\t\t\t\t\t  specific port and containing a specific\r\n\t\t\t\t\t  destination address are allowed to be forwarded.')
hmCurrentAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCurrentAddress.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddress.setDescription("The destination MAC address in a frame to which\r\n\t\t\t\t\t  this entry's filtering information applies.  This\r\n\t\t\t\t\t  object can take the value of a unicast address, a\r\n\t\t\t\t\t  group address or the broadcast address.")
hmCurrentAddressReceivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCurrentAddressReceivePort.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressReceivePort.setDescription("Either the value '0', or the port number of the\r\n\t\t\t\t\t  port from which a frame must be received in order\r\n\t\t\t\t\t  for this entry's filtering information to apply.\r\n\t\t\t\t\t  A value of zero indicates that this entry applies\r\n\t\t\t\t\t  on all ports of the bridge for which there is no\r\n\t\t\t\t\t  other applicable entry.")
hmCurrentAddressStaticEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCurrentAddressStaticEgressPorts.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressStaticEgressPorts.setDescription("The set of ports to which frames received from a\r\n\t\t\t\t\t  specific port and destined for a specific MAC\r\n\t\t\t\t\t  address, are allowed to be forwarded.  Each octet\r\n\t\t\t\t\t  within the value of this object specifies a set of\r\n\t\t\t\t\t  eight ports, with the first octet specifying ports\r\n\t\t\t\t\t  1 through 8, the second octet specifying ports 9\r\n\t\t\t\t\t  through 16, etc.\tWithin each octet, the most\r\n\t\t\t\t\t  significant bit represents the lowest numbered\r\n\t\t\t\t\t  port, and the least significant bit represents the\r\n\t\t\t\t\t  highest numbered port.  Thus, each port of the\r\n\t\t\t\t\t  bridge is represented by a single bit within the\r\n\t\t\t\t\t  value of this object.  If that bit has a value of\r\n\t\t\t\t\t  '1' then that port is included in the set of\r\n\t\t\t\t\t  ports; the port is not included if its bit has a\r\n\t\t\t\t\t  value of '0'.  (Note that the setting of the bit\r\n\t\t\t\t\t  corresponding to the port from which a frame is\r\n\t\t\t\t\t  received is irrelevant.)\tThe default value of\r\n\t\t\t\t\t  this object is a string of ones of appropriate\r\n\t\t\t\t\t  length.")
hmCurrentAddressEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCurrentAddressEgressPorts.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressEgressPorts.setDescription("The complete set of ports, to which frames destined\r\n\t\t\t\t\t  for this Group MAC Address are currently being forwarded.\r\n\t\t\t\t\t  This includes Group MAC Addresses which were set statically\r\n\t\t\t\t\t  or which were learnt by GMRP or some other dynamic mechanism.\r\n\t\t\t\t\t  Each octet within the value of this object specifies\r\n\t\t\t\t\t  a set of eight ports, with the first octet specifying\r\n\t\t\t\t\t  ports 1 through 8, the second octet specifying ports 9\r\n\t\t\t\t\t  through 16, etc.\tWithin each octet, the most\r\n\t\t\t\t\t  significant bit represents the lowest numbered\r\n\t\t\t\t\t  port, and the least significant bit represents the\r\n\t\t\t\t\t  highest numbered port.  Thus, each port of the\r\n\t\t\t\t\t  bridge is represented by a single bit within the\r\n\t\t\t\t\t  value of this object.  If that bit has a value of\r\n\t\t\t\t\t  '1' then that port is included in the set of\r\n\t\t\t\t\t  ports; the port is not included if its bit has a\r\n\t\t\t\t\t  value of '0'.  (Note that the setting of the bit\r\n\t\t\t\t\t  corresponding to the port from which a frame is\r\n\t\t\t\t\t  received is irrelevant.)\tThe default value of\r\n\t\t\t\t\t  this object is a string of ones of appropriate\r\n\t\t\t\t\t  length.")
hmCurrentAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permanent", 3), ("deleteOnReset", 4), ("deleteOnTimeout", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCurrentAddressStatus.setStatus('current')
if mibBuilder.loadTexts: hmCurrentAddressStatus.setDescription('This object indicates the status of this entry.\r\n\t\t\t\t\t  The default value is permanent(3).\r\n \r\n\t\t\t\t\t\t   other(1) - this entry is currently in use but\r\n\t\t\t\t\t\t\t\tthe conditions under which it will\r\n\t\t\t\t\t\t\t\tremain so are different from each of the\r\n\t\t\t\t\t\t\t\tfollowing values.\r\n\t\t\t\t\t\t   invalid(2) - writing this value to the object\r\n\t\t\t\t\t\t\t\tremoves the corresponding entry.\r\n\t\t\t\t\t\t   permanent(3) - this entry is currently in use\r\n\t\t\t\t\t\t\t\tand will remain so after the next reset\r\n\t\t\t\t\t\t\t\tof the bridge.\r\n\t\t\t\t\t\t   deleteOnReset(4) - this entry is currently in\r\n\t\t\t\t\t\t\t\tuse and will remain so until the next\r\n\t\t\t\t\t\t\t\treset of the bridge.\r\n\t\t\t\t\t\t   deleteOnTimeout(5) - this entry is currently\r\n\t\t\t\t\t\t\t\tin use and will remain so until it is\r\n\t\t\t\t\t\t\t\taged out.')
hmRS2ext = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10))
hmRS2OperMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("normal", 1), ("standby-active", 2), ("standby-inactive", 3), ("redundancy-manager-active", 4), ("redundancy-manager-inactive", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2OperMode.setStatus('current')
if mibBuilder.loadTexts: hmRS2OperMode.setDescription('hmRS2OperMode shows the operational mode of the system:\r\n\t\t\t\t\tnormal: \t\t  normal mode,\r\n\t\t\t\t\tstandby-active:   standby mode, but switch is active, because\r\n\t\t\t\t\t\t\t\t\t  the master switch is e.g. not reachable,\r\n\t\t\t\t\tstandby-inactive: stand by mode,\r\n\t\t\t\t\tredundancy-manager-active: redundancy mode and redundancy-manager has \r\n\t\t\t\t\t\t\t\t\t  closed RS2 ring,\r\n\t\t\t\t\tredundancy-manager-inactive: redundancy mode and redundancy-manager has \r\n\t\t\t\t\t\t\t\t\t  opened RS2 ring.\r\n\t\t\t\t If the value changes, a trap is sent.')
hmRS2ConfigError = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-error", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2ConfigError.setStatus('current')
if mibBuilder.loadTexts: hmRS2ConfigError.setDescription('RS2hmConfigError indicates a configuration error of the\r\n\t\t\t\t system:\r\n\t\t\t\t\tno error: no configuration error,\r\n\t\t\t\t\terror: in normal mode hmConfigError indicates failure of\r\n\t\t\t\t\t\t   control line or connection of 2 RS2 in normal mode,\r\n\t\t\t\t\t\t   in stand by mode hmConfigError indicates absence of\r\n\t\t\t\t\t\t   control line, failure of control line or connection\r\n\t\t\t\t\t\t   of 2 RS2 in stand by mode.')
hmRS2SigRelayState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2SigRelayState.setStatus('current')
if mibBuilder.loadTexts: hmRS2SigRelayState.setDescription('hmRS2SigRelayState shows the state of the (non potential)\r\n\t\t\t\t signalling relay in standard mode:\r\n\t\t\t\t\toff: ok,\r\n\t\t\t\t\ton: powersupply not ok or linkstate of a port not ok or\r\n\t\t\t\t\t\tconfiguration error, see power supply table or\r\n\t\t\t\t\t\tifMauTable (attribute ifMauMediaAvailable) or\r\n\t\t\t\t\t\thmConfigError for details.')
hmSigLinkTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 4), )
if mibBuilder.loadTexts: hmSigLinkTable.setStatus('current')
if mibBuilder.loadTexts: hmSigLinkTable.setDescription('This table contains all variables to mask an alarm for the\r\n\t\t\t\t signalling relay, produced by a link. The index for a link\r\n\t\t\t\t corresponds with ifMauIfIndex.')
hmSigLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 4, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSigLinkID"))
if mibBuilder.loadTexts: hmSigLinkEntry.setStatus('current')
if mibBuilder.loadTexts: hmSigLinkEntry.setDescription('The entry of the hmSigLinkTable.')
hmSigLinkID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigLinkID.setStatus('current')
if mibBuilder.loadTexts: hmSigLinkID.setDescription('This index is used to identify the associated link and\r\n\t\t\t\t corresponds with ifMauIfIndex.')
hmSigLinkAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigLinkAlarm.setStatus('current')
if mibBuilder.loadTexts: hmSigLinkAlarm.setDescription('Indicates whether an alarm for the signalling relay of the\r\n                 associated link will be produced or not, so you can mask the\r\n                 value of ifMauMediaAvailable.')
hmSigTrapReason = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigTrapReason.setStatus('current')
if mibBuilder.loadTexts: hmSigTrapReason.setDescription('This object identifies the reason for a trap. There are\r\n\t\t\t\t three reasons for a trap:\r\n\t\t\t\t\t hmRS2ConfigError\r\n\t\t\t\t\t ifMauMediaAvailable\r\n\t\t\t\t\t hmPSState\r\n\t\t\t\t The entity which produces the trap, is specified by\r\n\t\t\t\t hmSigReasonIndex.')
hmSigReasonIndex = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigReasonIndex.setStatus('current')
if mibBuilder.loadTexts: hmSigReasonIndex.setDescription('This attribute specifies the entity which produces the trap.\r\n\t\t\t\t\t 1 - n: index of powersupply table / interfaces table\r\n\t\t\t\t\t 0: config-error.')
hmRS2TopologyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7))
hmRS2PartnerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2PartnerIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmRS2PartnerIpAddress.setDescription('This variable can be used to set manually the \r\n\t\t\tredundancy partner of the RS2 agent.')
hmRS2TopologyTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7, 2), )
if mibBuilder.loadTexts: hmRS2TopologyTable.setStatus('current')
if mibBuilder.loadTexts: hmRS2TopologyTable.setDescription('This table describes the topology of rs2-rings.')
hmRS2TopologyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmRS2TopologyLinkID"))
if mibBuilder.loadTexts: hmRS2TopologyEntry.setStatus('current')
if mibBuilder.loadTexts: hmRS2TopologyEntry.setDescription('The entry of the hmRS2TopologyTable.')
hmRS2TopologyLinkID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2TopologyLinkID.setStatus('current')
if mibBuilder.loadTexts: hmRS2TopologyLinkID.setDescription('This index is used to identify the associated link and\r\n\t\t\tcorresponds with ifMauIfIndex.')
hmRS2TopologyIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 7, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2TopologyIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmRS2TopologyIpAddress.setDescription('This variable can be used to set manually the next RS2 agent.')
hmRS2ConnectionMirroringGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 8))
hmRS2ConnectionMirroringStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2ConnectionMirroringStatus.setStatus('current')
if mibBuilder.loadTexts: hmRS2ConnectionMirroringStatus.setDescription('Set this variable to configure the status of the\r\n\t\t\tconnection mirroring functionality. \t\t\t\t\t\r\n\t\t\tThe definition of a destination port is not required.')
hmRS2ConnectionMirroringPortOne = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2ConnectionMirroringPortOne.setStatus('current')
if mibBuilder.loadTexts: hmRS2ConnectionMirroringPortOne.setDescription('Set this variable to the first port to be mirrored.')
hmRS2ConnectionMirroringPortTwo = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 8, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2ConnectionMirroringPortTwo.setStatus('current')
if mibBuilder.loadTexts: hmRS2ConnectionMirroringPortTwo.setDescription('Set this variable to the second port to be mirrored.')
hmRS2DisableLearningGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 9))
hmRS2DisableLearningStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 9, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2DisableLearningStatus.setStatus('current')
if mibBuilder.loadTexts: hmRS2DisableLearningStatus.setDescription('When set to active the Learning Process is disabled,\r\n\t\t\tno new Dynamic Filtering Entries are created and\r\n\t\t\texsisting Dynamic Filtering Entries are removed from\r\n\t\t\tthe Filtering Database.\r\n\t\t\tStatic Filtering Entries and Group Registration Entries\r\n\t\t\tare not affected.')
hmRS2SigRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 10))
hmRS2SigRelayMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("standard", 1), ("manual", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2SigRelayMode.setStatus('current')
if mibBuilder.loadTexts: hmRS2SigRelayMode.setDescription('When set to standard, this is the default,\r\n\t\t\tthe signalling relay shows the state of\r\n\t\t\thmRS2SigRelayState.\r\n\t\t\tWhen set to manual, the relay is controlled\r\n\t\t\tby hmRS2SigRelayManualState.')
hmRS2SigRelayManualState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2SigRelayManualState.setStatus('current')
if mibBuilder.loadTexts: hmRS2SigRelayManualState.setDescription('When set to on, this is the default,\r\n\t\t\tthe signalling relay is opened.\r\n\t\t\tWhen set to off the relay is closed.')
hmRS2VlanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 11))
hmRS2VlanMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2VlanMode.setStatus('current')
if mibBuilder.loadTexts: hmRS2VlanMode.setDescription('Enables/disables the VLAN mode on this device.\r\n\t\t\tWhen enabled the switch will operate in 802.1Q mode,\r\n\t\t\telse in 802.1d mode.\r\n\t\t\tAfter setting this variable the switch have to be reset.\r\n\t\t\tThe default value is disable.')
hmRS2VlanStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2VlanStatus.setStatus('current')
if mibBuilder.loadTexts: hmRS2VlanStatus.setDescription('Shows the current VLAN mode of this device.\r\n\t\t\tWhen enabled the switch operates in 802.1Q mode,\r\n\t\t\telse in 802.1d mode.')
hmRS2SelftestGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 12))
hmRS2SelftestResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2SelftestResult.setStatus('current')
if mibBuilder.loadTexts: hmRS2SelftestResult.setDescription('Result of the selftest coded as an integer value\r\n\t\t\twith each bit representing the result of a different\r\n\t\t\tsub part test. Bits set in the result indicate error\r\n\t\t\tconditions of the sub part tests.\r\n\t\t\t\r\n\t\t\tMeaning of the bits:\r\n\t\t\tBit  0: error switch memory\r\n\t\t\t')
hmRS2SelftestMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 12, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2SelftestMode.setStatus('current')
if mibBuilder.loadTexts: hmRS2SelftestMode.setDescription('Mode of the selftest coded as an integer value\r\n\t\t\twith each bit representing a special behaviour\r\n\t\t\tof the tests. \r\n\t\t\t\r\n\t\t\tMeaning of the bits:\r\n\t\t\tBit  0: reboot on failure\r\n\t\t\tBit  1: show failure with hmRS2SigRelayState \r\n\t\t\t     (a trap will be send also)\r\n\t\t\tBit  2: do switch memory test on start up\r\n\t\t\tBit  3: Clear Bit 2 after next reboot if test has been \r\n\t\t\t        successfully completed\r\n\t\t\t')
hmRS2PSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 13))
hmRS2PSAlarm = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2PSAlarm.setStatus('current')
if mibBuilder.loadTexts: hmRS2PSAlarm.setDescription('Enables/disables an alarm for the signalling relay of the\r\n\t\t\tpowersupply state.')
hmRS2RedundancyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 14))
hmRS2RedNotGuaranteedAlarm = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2RedNotGuaranteedAlarm.setStatus('current')
if mibBuilder.loadTexts: hmRS2RedNotGuaranteedAlarm.setDescription("When enabled the message 'redundancy not guaranteed' will be\r\n\t\t\tsignalled on the signalling relay.")
hmRS4RGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15))
hmRS4RVlanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15, 1))
hmRS4RVlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15, 1, 1), )
if mibBuilder.loadTexts: hmRS4RVlanPortTable.setStatus('current')
if mibBuilder.loadTexts: hmRS4RVlanPortTable.setDescription('This table describes private vlan enhancements of rs2-4r devices.')
hmRS4RVlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15, 1, 1, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmRS4RVlanPortID"))
if mibBuilder.loadTexts: hmRS4RVlanPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmRS4RVlanPortEntry.setDescription('The entry of the hmRS4RVlanPortTable.')
hmRS4RVlanPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: hmRS4RVlanPortID.setStatus('current')
if mibBuilder.loadTexts: hmRS4RVlanPortID.setDescription('This index is used to identify the port.')
hmRS4RVlanPortTagFormatRstp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 15, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS4RVlanPortTagFormatRstp.setStatus('current')
if mibBuilder.loadTexts: hmRS4RVlanPortTagFormatRstp.setDescription('When enabled all tags are removed when sending packets on the port (egress).\r\n\t\t\tWhen disabled tag format is not changed, but RSTP frames are sent tagged.\r\n\t\t\tThis variable is only used if RSTP is enabled.\r\n\t\t\tThe default value is enable.')
hmRS2FDBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 16))
hmRS2FDBHashGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 16, 1))
hmRS2FDBHashOptimizingMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRS2FDBHashOptimizingMode.setStatus('current')
if mibBuilder.loadTexts: hmRS2FDBHashOptimizingMode.setDescription('Enables/disables the hash optimizing mode on this device.\r\n\t\t\tWhen enabled the switch will use another hash algorithm \r\n\t\t\toptimized for incrementing addresses.\r\n\t\t\tAfter setting this variable the switch have to be reset.\r\n\t\t\tThe default value is disable.')
hmRS2FDBHashOptimizingStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 10, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRS2FDBHashOptimizingStatus.setStatus('current')
if mibBuilder.loadTexts: hmRS2FDBHashOptimizingStatus.setDescription('Shows the current hash mode of this device.\r\n\t\t\tWhen enabled the switch uses the optimized hash mode,\r\n\t\t\telse the normal mode.')
hmMACH3ChassisExt = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 11))
hmSelfTestResults = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1))
hmSelfTestCpuResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestCpuResult.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestCpuResult.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits 0..15 set in the result indicate \r\n\t\t\t\t warning conditions, bits 16..31 indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: default configuration activated and running\r\n\t\t\t\t \r\n\t\t\t\t Bit  2: BB_DATAMEM_ERROR caused by log-entry:\r\n                         S_mmcssp_CRC_ERROR_DATAMEM   ( in mmcNP5400Int() )\r\n                         S_mmcssp_LEN_ERROR_DATAMEM   ( in mmcNP5400Int() )\r\n\t\t\t\t Bit  3: BB_PARITY_ERROR caused by log-entry:\r\n                         S_mmcssp_PER_ON_VIX_OR_IPC   ( in mmcNP5400Int() )\r\n                         S_mmcssp_PE_PIF_VIX_DATA     ( in mmcEpifPintProc(), mmcGpifPintProc(), mmcXpifPintProc() )\r\n                         S_mmcssp_PE_PIF_GGI          ( in mmcGpifPintProc(), mmcXpifPintProc() )\r\n\t\t\t\t Bit  4: BOOT_ERROR_PIF caused by log-entry:\r\n                         S_mmcssp_PIF_BOOT_ERROR      ( in mmcEpifPintProc(), mmcGpifPintProc(), mmcXpifPintProc() )\r\n                 Bit  5: MMC_PORT_PROBLEM caused by log-entry:\r\n                         S_mmcssp_WRONG_PORT_IN_MSG   ( in mmcGotAliveMsg() )\r\n                         S_mmcssp_NO_ADDRESS_FOR_PORT ( in mmcPortConfig() )\r\n \r\n                 Bit  16: configuration data in bootblock of flash was invalid through startup\r\n\t\t\t\t Bit  17: configuration in flash is corrupted\r\n\t\t\t\t ')
hmSelfTestBBResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestBBResult.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestBBResult.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: selftest error of backplane port no 1\r\n\t\t\t\t Bit  1: selftest error of backplane port no 2\r\n\t\t\t\t Bit  2: selftest error of backplane port no 3\r\n\t\t\t\t Bit  3: selftest error of backplane port no 4\r\n\t\t\t\t Bit  8: selftest error of network processor no 1\r\n\t\t\t\t Bit  9: selftest error of network processor no 2\r\n\t\t\t\t Bit 10: selftest error of network processor no 3\r\n\t\t\t\t Bit 11: selftest error of network processor no 4\r\n\t\t\t\t Bit 12: selftest error of xpif no 1\r\n\t\t\t\t Bit 13: selftest error of xpif no 2\r\n\t\t\t\t Bit 14: selftest error of xpif no 3\r\n\t\t\t\t Bit 15: selftest error of xpif no 4\r\n\t\t\t\t Bit 16: error packet memory size\r\n\t\t\t\t Bit 30: error on board eeprom')
hmSelfTestBPResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestBPResult.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestBPResult.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: communication error with card 1\r\n\t\t\t\t Bit  1: communication error with card 2\r\n\t\t\t\t Bit  2: communication error with card 3\r\n\t\t\t\t Bit  3: communication error with card 4\r\n\t\t\t\t Bit  4: communication error with card 5\r\n\t\t\t\t Bit 24: main and redundant eeprom 2 are different\r\n\t\t\t\t Bit 25: main and redundant eeprom 1 are different\r\n\t\t\t\t Bit 27: error on redundant eeprom 2\r\n\t\t\t\t Bit 28: error on redundant eeprom 1\r\n\t\t\t\t Bit 29: error on main eeprom 2\r\n\t\t\t\t Bit 30: error on main eeprom 1')
hmSelfTestM1Result = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestM1Result.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestM1Result.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: selftest error of port no 1\r\n\t\t\t\t Bit  1: selftest error of port no 2\r\n\t\t\t\t Bit  2: selftest error of port no 3\r\n\t\t\t\t Bit  3: selftest error of port no 4\r\n\t\t\t\t Bit  4: selftest error of port no 5\r\n\t\t\t\t Bit  5: selftest error of port no 6\r\n\t\t\t\t Bit  6: selftest error of port no 7\r\n\t\t\t\t Bit  7: selftest error of port no 8\r\n\t\t\t\t Bit 16: selftest error of pif no 1\r\n\t\t\t\t Bit 17: selftest error of pif no 2\r\n\t\t\t\t Bit 30: error on module eeprom')
hmSelfTestM2Result = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestM2Result.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestM2Result.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: selftest error of port no 1\r\n\t\t\t\t Bit  1: selftest error of port no 2\r\n\t\t\t\t Bit  2: selftest error of port no 3\r\n\t\t\t\t Bit  3: selftest error of port no 4\r\n\t\t\t\t Bit  4: selftest error of port no 5\r\n\t\t\t\t Bit  5: selftest error of port no 6\r\n\t\t\t\t Bit  6: selftest error of port no 7\r\n\t\t\t\t Bit  7: selftest error of port no 8\r\n\t\t\t\t Bit 16: selftest error of pif no 1\r\n\t\t\t\t Bit 17: selftest error of pif no 2\r\n\t\t\t\t Bit 30: error on module eeprom')
hmSelfTestM3Result = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestM3Result.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestM3Result.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: selftest error of port no 1\r\n\t\t\t\t Bit  1: selftest error of port no 2\r\n\t\t\t\t Bit  2: selftest error of port no 3\r\n\t\t\t\t Bit  3: selftest error of port no 4\r\n\t\t\t\t Bit  4: selftest error of port no 5\r\n\t\t\t\t Bit  5: selftest error of port no 6\r\n\t\t\t\t Bit  6: selftest error of port no 7\r\n\t\t\t\t Bit  7: selftest error of port no 8\r\n\t\t\t\t Bit 16: selftest error of pif no 1\r\n\t\t\t\t Bit 17: selftest error of pif no 2\r\n\t\t\t\t Bit 30: error on module eeprom')
hmSelfTestM4Result = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSelfTestM4Result.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestM4Result.setDescription('Result of the selftest coded as an integer value\r\n\t\t\t\t with each bit representing the result of a different\r\n\t\t\t\t sub part test. Bits set in the result indicate error\r\n\t\t\t\t conditions of the sub part tests.\r\n\t\t\t\t \r\n\t\t\t\t Meaning of the bits:\r\n\t\t\t\t Bit  0: selftest error of port no 1\r\n\t\t\t\t Bit  1: selftest error of port no 2\r\n\t\t\t\t Bit  2: selftest error of port no 3\r\n\t\t\t\t Bit  3: selftest error of port no 4\r\n\t\t\t\t Bit  4: selftest error of port no 5\r\n\t\t\t\t Bit  5: selftest error of port no 6\r\n\t\t\t\t Bit  6: selftest error of port no 7\r\n\t\t\t\t Bit  7: selftest error of port no 8\r\n\t\t\t\t Bit 16: selftest error of pif no 1\r\n\t\t\t\t Bit 17: selftest error of pif no 2\r\n\t\t\t\t Bit 30: error on module eeprom')
hmSelfTestMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSelfTestMode.setStatus('current')
if mibBuilder.loadTexts: hmSelfTestMode.setDescription('Setting this variable to enable(1) results in a full\r\n\t\t\t\t  report of all detected selftest errors.\r\n\t\t\t\t  The default value is disable(2). ')
hmMgmtBusSelected = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("redundant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMgmtBusSelected.setStatus('current')
if mibBuilder.loadTexts: hmMgmtBusSelected.setDescription('this variable indicates which management bus is selected.')
hmSerialNumbers = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3))
hmSerialNumCpu = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumCpu.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumCpu.setDescription('Serial Number of the CPU board.')
hmSerialNumBB = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumBB.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumBB.setDescription('Serial Number of the basic board.')
hmSerialNumBP = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumBP.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumBP.setDescription('Serial Number of the packplane unit.')
hmSerialNumM1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumM1.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumM1.setDescription('Serial Number of module 1.')
hmSerialNumM2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumM2.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumM2.setDescription('Serial Number of module 2.')
hmSerialNumM3 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumM3.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumM3.setDescription('Serial Number of module 3.')
hmSerialNumM4 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 3, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSerialNumM4.setStatus('current')
if mibBuilder.loadTexts: hmSerialNumM4.setDescription('Serial Number of module 4.')
hmPlugAndPlay = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 4))
hmAutoConfigState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("inProgess", 2), ("ready", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoConfigState.setStatus('current')
if mibBuilder.loadTexts: hmAutoConfigState.setDescription('state of the configuration retrieval from a neighbour card')
hmMACH3Misc = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 5))
hmUserGroupStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 1, 11, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmUserGroupStatus.setStatus('current')
if mibBuilder.loadTexts: hmUserGroupStatus.setDescription('state of the user group configuration')
hmAUIGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 1, 12))
hmAUIModuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 10), )
if mibBuilder.loadTexts: hmAUIModuleTable.setStatus('current')
if mibBuilder.loadTexts: hmAUIModuleTable.setDescription('This table contains all AUI variables\r\n\t\t\t\tthat are module dependend.')
hmAUIModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 10, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAUIModuleID"))
if mibBuilder.loadTexts: hmAUIModuleEntry.setStatus('current')
if mibBuilder.loadTexts: hmAUIModuleEntry.setDescription('The entry of the hmAUIModuleTable.')
hmAUIModuleID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAUIModuleID.setStatus('current')
if mibBuilder.loadTexts: hmAUIModuleID.setDescription('This index is used to identify a specific module.')
hmAUIModuleDTEPowerMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAUIModuleDTEPowerMonitor.setStatus('current')
if mibBuilder.loadTexts: hmAUIModuleDTEPowerMonitor.setDescription('This variable shows the DTE Power Monitor DIP switch\r\n\t\t\t\tsetting on the AUI module.')
hmAUIPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 11), )
if mibBuilder.loadTexts: hmAUIPortTable.setStatus('current')
if mibBuilder.loadTexts: hmAUIPortTable.setDescription('This table contains all AUI variables\r\n\t\t\t\tthat are port dependend.')
hmAUIPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 11, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAUIPortID"))
if mibBuilder.loadTexts: hmAUIPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmAUIPortEntry.setDescription('The entry of the hmAUIPortTable.')
hmAUIPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAUIPortID.setStatus('current')
if mibBuilder.loadTexts: hmAUIPortID.setDescription('This index is used to identify a specific port.')
hmAUIPortDTEPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAUIPortDTEPower.setStatus('current')
if mibBuilder.loadTexts: hmAUIPortDTEPower.setDescription('This variable shows the DTE Power value\r\n\t\t\t\tof the AUI port.')
hmAUIPortSQETest = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 1, 12, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAUIPortSQETest.setStatus('current')
if mibBuilder.loadTexts: hmAUIPortSQETest.setDescription('This variable shows the SQE Test DIP switch\r\n\t\t\t\tsetting on the AUI port.')
hmAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 10, 12))).clone(namedValues=NamedValues(("other", 1), ("reset", 2), ("resetStats", 3), ("resetFDB", 4), ("resetARP", 5), ("resetL3Stats", 6), ("resetL4-7Stats", 7), ("hotRestart", 10), ("gbl-reset", 12))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAction.setStatus('current')
if mibBuilder.loadTexts: hmAction.setDescription('This object, when read, always returns a value of other(1).\r\n\t\t\t\t A value of reset(2) has the same effect as a power-on sequence\r\n\t\t\t\t (coldstart). Writing a value of hotRestart(10) leads to a warmstart. \r\n\t\t\t\t When set to resetStats(3), a reset of all statistic\r\n\t\t\t\t counters within the whole switch will be forced. A value of \r\n\t\t\t\t resetFDB(4) will clear the forwarding database.\r\n\t\t\t\t If set to resetARP(5), the ARP table will be flushed.\r\n\t\t\t\t The value gbl-reset(12) will result in a reset of the whole \r\n\t\t\t\t chassis. Any other value results in a badValue status code.')
hmActionResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmActionResult.setStatus('current')
if mibBuilder.loadTexts: hmActionResult.setDescription('Result of the last activated action. A value of zero\r\n\t\t\t\t indicates that the result is ok. Bits set in the result\r\n\t\t\t\t indicate error conditions.')
hmNetwork = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3))
hmNetLocalIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetLocalIPAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetLocalIPAddr.setDescription('IP address of the management agent board.\r\n                 Changing this value will take effect after activating with hmNetAction.')
hmNetLocalPhysAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetLocalPhysAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetLocalPhysAddr.setDescription('Physical base address (MAC-address) of the agent.')
hmNetGatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetGatewayIPAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetGatewayIPAddr.setDescription('IP address of the default gateway.\r\n\t\t\t\t Changing this value will take effect after activating with hmNetAction.')
hmNetMask = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetMask.setStatus('current')
if mibBuilder.loadTexts: hmNetMask.setDescription('Subnet mask.\r\n\t\t\t\t Changing this value will take effect after activating with hmNetAction.')
hmNetPPPBaseIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPPPBaseIPAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetPPPBaseIPAddr.setDescription('Base address of the IP address range used by the\r\n\t\t\t\t  point-to-point protocol. The IP addresses\r\n\t\t\t\t  hmNetPPPBaseAddress..hmNetPPPBaseAddress+4 are assigned\r\n\t\t\t\t  to the client machines attached to management agents 1..5.\r\n\t\t\t\t  The management agents can be reached using addresses\r\n\t\t\t\t  hmNetPPPBaseAddress+10..hmNetPPPBaseAddress+14.\r\n\t\t\t\t  Changing this variable on one agent automatically updates\r\n\t\t\t\t  the value on the other agents in the same chassis.')
hmNetPPPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPPPNetMask.setStatus('current')
if mibBuilder.loadTexts: hmNetPPPNetMask.setDescription('Subnet mask used by the point-to-point protocol.\r\n\t\t\t\t  Changing this variable on one agent automatically updates\r\n\t\t\t\t  the value on the other agents in the same chassis.')
hmNetAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("activate", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetAction.setStatus('current')
if mibBuilder.loadTexts: hmNetAction.setDescription('This object, when read, always returns a value of other(1).\r\n\t\t\t\t Setting the object to activate(2) causes a reconfiguration\r\n\t\t\t\t of the IP protocol stack with the current values of \r\n\t\t\t\t hmNetLocalIPAddr, hmNetGatewayIPAddr and hmNetMask.')
hmNetVlanID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetVlanID.setStatus('current')
if mibBuilder.loadTexts: hmNetVlanID.setDescription('Vlan ID of the IP protocol stack. If the value is 0,\r\n                 Traffic from all Vlans is accepted. Every other value means\r\n                 that only traffic of the appropriate Vlan is accepted and outgoing\r\n                 traffic uses this Vlan ID.')
hmNetLocalPhysAddrRange = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetLocalPhysAddrRange.setStatus('current')
if mibBuilder.loadTexts: hmNetLocalPhysAddrRange.setDescription('The number of MAC addresses reserved for this device, starting from hmNetLocalPhysAddr.')
hmNetVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hmNetVlanPriority.setDescription('Vlan Priority which is used in management replies.')
hmNetIpDscpPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetIpDscpPriority.setStatus('current')
if mibBuilder.loadTexts: hmNetIpDscpPriority.setDescription('IP DSCP value which is used in management replies.')
hmNetACDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12))
hmNetACDStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("activeDetectionOnly", 3), ("passiveDetectionOnly", 4))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetACDStatus.setDescription("Sets the mode of the ip address conflict detection mechanism on this device.\r\n\t\t\tenable(1): Both active and passive detection are active.\r\n\t\t\tdisable(2): No detection takes place.\r\n\t\t\tactiveDetectionOnly(3): During configuration of a local ip address \r\n\t\t\tthe device actively probes the network for this ip address.\r\n\t\t\tpassiveDetectionOnly(4): The device listens passively on the network \r\n\t\t\tif another device with an already locally configured ip address appears. \r\n\t\t\tIn this case the own ip address is actively defended by transmitting gratituous arp's.")
hmNetACDOngoingProbeStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDOngoingProbeStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetACDOngoingProbeStatus.setDescription('If enabled, the device sends periodic arp probes.')
hmNetACDDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDDelay.setStatus('current')
if mibBuilder.loadTexts: hmNetACDDelay.setDescription('The maximum detection delay time in milliseconds. \r\n  \t\t\t Time gap between arp probes.')
hmNetACDReleaseDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDReleaseDelay.setStatus('current')
if mibBuilder.loadTexts: hmNetACDReleaseDelay.setDescription('Delay in seconds to the next arp probe cycle\r\n  \t\t\t after an ip address conflict was detected.')
hmNetACDMaxProtection = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDMaxProtection.setStatus('current')
if mibBuilder.loadTexts: hmNetACDMaxProtection.setDescription('Maximum number of frequent address protections.')
hmNetACDProtectInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetACDProtectInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetACDProtectInterval.setDescription('Delay in milliseconds between two protections.')
hmNetACDFaultState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDFaultState.setStatus('current')
if mibBuilder.loadTexts: hmNetACDFaultState.setDescription('true(1) if an active address conflict is detected.\r\n  \t\t\tfalse(2) if no present address conflict.')
hmNetACDAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20), )
if mibBuilder.loadTexts: hmNetACDAddrTable.setStatus('current')
if mibBuilder.loadTexts: hmNetACDAddrTable.setDescription('This table contains address conflict detection information\r\n             on the local system known to this agent.')
hmNetACDAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmNetACDTimeMark"))
if mibBuilder.loadTexts: hmNetACDAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hmNetACDAddrEntry.setDescription('IP Address conflict detection information about a particular \r\n            address on the local system kown to this agent.\r\n            There may be multiple addresses configured on the system.\r\n            Entries may be created and deleted in this table by the\r\n            agent.')
hmNetACDTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: hmNetACDTimeMark.setStatus('current')
if mibBuilder.loadTexts: hmNetACDTimeMark.setDescription('A TimeFilter for this entry.  See the TimeFilter textual\r\n            convention in IETF RFC 2021 and \r\n            http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt\r\n            to see how TimeFilter works.')
hmNetACDAddrSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1, 3), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDAddrSubtype.setStatus('current')
if mibBuilder.loadTexts: hmNetACDAddrSubtype.setDescription("The type of management address identifier encoding used in\r\n            the associated 'hmNetACDAddr' object.")
hmNetACDAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetACDAddr.setDescription('The string value used to identify the management address\r\n            component associated with the local system.')
hmNetACDMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDMAC.setStatus('current')
if mibBuilder.loadTexts: hmNetACDMAC.setDescription('The physical address of the device that was detected \r\n            causing the ip address conflict.')
hmNetACDIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 12, 20, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetACDIfId.setStatus('current')
if mibBuilder.loadTexts: hmNetACDIfId.setDescription('The integer value used to identify the interface number\r\n            on the local system where the ip address conflict was detected.')
hmNetMacACDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 13))
hmNetMacACDStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetMacACDStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetMacACDStatus.setDescription('Sets the status of the MAC address conflict detection mechanism on this device.')
hmNetMacACDConflictAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 13, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetMacACDConflictAddress.setStatus('current')
if mibBuilder.loadTexts: hmNetMacACDConflictAddress.setDescription('MAC address in case of a conflict.')
hmNetHiDiscoveryGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 20))
hmNetHiDiscoveryStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("readOnly", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetHiDiscoveryStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetHiDiscoveryStatus.setDescription('Enables/disables the HiDiscovery protocol\r\n\t\t\ton this device.\r\n\t\t\tThis protocol allows a remote host to detect\r\n\t\t\tdevices without an ip configuration.\r\n\t\t\tIt also allows the host to set ip parameters,\r\n\t\t\tlike the ip address, the netmask and \r\n\t\t\tthe gateway address.\r\n\t\t\tIf only detection and no configuration is allowed\r\n\t\t\tset this object to readOnly(3).')
hmNetHiDiscoveryRelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 20, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetHiDiscoveryRelay.setStatus('current')
if mibBuilder.loadTexts: hmNetHiDiscoveryRelay.setDescription('Relay/bridge HiDiscovery frames.')
hmNetHiDiscoveryProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 20, 3), Bits().clone(namedValues=NamedValues(("none", 0), ("v1", 1), ("v2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetHiDiscoveryProtocol.setStatus('current')
if mibBuilder.loadTexts: hmNetHiDiscoveryProtocol.setDescription('Shows the HiDiscovery protocols supported by the device.')
hmNetSNTPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30))
hmNetSNTPStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPStatus.setDescription('Enables/disables the Simple Network Time Protocol\r\n\t\t    on this device.')
hmNetSNTPServer = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPServer.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPServer.setDescription('The IP Address of an external Time Server.')
hmNetSNTPTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 3), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPTime.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPTime.setDescription('The time in seconds since 01/01/1900 UTC.')
hmNetSNTPLocalOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1000, 1000)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPLocalOffset.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPLocalOffset.setDescription('The difference between local time and UTC in minutes.')
hmNetSNTPServer2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPServer2.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPServer2.setDescription('IP address of a secondary (backup) time server.')
hmNetSNTPSyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPSyncInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPSyncInterval.setDescription('SNTP synchronisation interval in seconds.')
hmNetSNTPAcceptBroadcasts = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPAcceptBroadcasts.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPAcceptBroadcasts.setDescription('This MIB variable specifies whether SNTP broadcasts will\r\n\t\t\tbe allowed to synchronize the local clock.\r\n\t\t\tIf hmNetSNTPStatus is enabled,\r\n\t\t\tthis variable will be ignored and broadcasts will not set\r\n\t\t\tthe local clock.')
hmNetSNTPAnycastAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPAnycastAddr.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPAnycastAddr.setDescription('Destination address for SNTP broadcasts.\r\n\t\t\tA broadcast, multicast or unicast address may be specified.\r\n\t\t\tSetting the address to 0.0.0.0 disables SNTP broadcasts.')
hmNetSNTPAnycastVlan = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPAnycastVlan.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPAnycastVlan.setDescription('Vlan for anycast mode.')
hmNetSNTPAnycastInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPAnycastInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPAnycastInterval.setDescription('Interval of SNTP broadcast messages in seconds.')
hmNetSNTPOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetSNTPOperStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPOperStatus.setDescription('Operational status of the SNTP sub-system.\r\n\t\t\t The value is a bit mask:\r\n\t\t\t    0  SNTP disabled\r\n\t\t\t    1  local system clock synchronized\r\n\t\t\t    2  SNTP loop detected\r\n\t\t\t    4  generic error\r\n\t\t\t    8  once synced, client disabled\r\n\t\t\t  100  server 1 not synchronized\r\n\t\t\t  200  server 1 bad protocol version\r\n\t\t\t  400  server 1 not responding\r\n\t\t\t10000  server 2 not synchronized\r\n\t\t\t20000  server 2 bad protocol version\r\n\t\t\t40000  server 2 not responding\r\n\t\t\t (Note that all values are hexadecimal.)')
hmNetSNTPTimeAdjustThreshold = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPTimeAdjustThreshold.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPTimeAdjustThreshold.setDescription('The threshold in milli-seconds whether to decide to set the received \r\n\t\t\tSNTP time directly to the local clock or not. If the hmNetSNTPTimeAdjustThreshold\r\n\t\t\tvalue is 0, the received SNTP time will be set directly to the local clock every\r\n\t\t\ttime a SNTP message is received. If the difference between the local clock time\r\n\t\t\tand the received SNTP time is fewer than the hmNetSNTPTimeAdjustThreshold\r\n\t\t\tvalue, the local clock will not be set. If the difference between the local clock time\r\n\t\t\tand the received SNTP time is equal or larger than the hmNetSNTPTimeAdjustThreshold\r\n\t\t\tvalue, the local clock will be set. Value must be in the <0-2000> milliseconds interval.')
hmNetSNTPOnceAtStartup = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPOnceAtStartup.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPOnceAtStartup.setDescription('If enabled, SNTP ist automaticaly disabled after once synchronized to an SNTP Server.')
hmNetSNTPServerOnlyIfSync = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPServerOnlyIfSync.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPServerOnlyIfSync.setDescription('The SNTP server is enabled only if synchronized to another external time reference. (e.g. SNTP or PTP)')
hmNetSNTPServerStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPServerStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPServerStatus.setDescription('Enables/disables the SNTP server on this device if hmNetSNTPStatus is enabled.')
hmNetSNTPClientStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 30, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNTPClientStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNTPClientStatus.setDescription('Enables/disables the SNTP client on this device if hmNetSNTPStatus is enabled.')
hmNetNTPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31))
hmNetNTPOperation = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("off", 1), ("symmetric-active", 2), ("symmetric-passive", 3), ("client", 4), ("server", 5), ("client-server", 6), ("broadcast-client", 7))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPOperation.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPOperation.setDescription('Selects operation mode for NTP.')
hmNetNTPServer1AddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 2), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPServer1AddrType.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPServer1AddrType.setDescription('Address type for server 1.\r\n\t\t\t     Currently, only ipv4 is supported.')
hmNetNTPServer1Address = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 3), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPServer1Address.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPServer1Address.setDescription('The address of the first external time server.')
hmNetNTPServer2AddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 4), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPServer2AddrType.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPServer2AddrType.setDescription('Address type for server 2.\r\n\t\t\t     Currently, only ipv4 is supported.')
hmNetNTPServer2Address = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPServer2Address.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPServer2Address.setDescription('The address of the second external time server.')
hmNetNTPSyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPSyncInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPSyncInterval.setDescription('NTP synchronisation interval in seconds.\r\n\t\t\t     NTP will round down the value to a power of 2.\r\n\t\t\t     The protocol will use an interval between the\r\n\t\t\t     rounded value and the next power of 2.')
hmNetNTPAnycastAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 7), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPAnycastAddrType.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPAnycastAddrType.setDescription('Address type for anycasts.\r\n\t\t\t     Currently, only ipv4 is supported.')
hmNetNTPAnycastAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 8), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPAnycastAddress.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPAnycastAddress.setDescription('Destination address for NTP broadcasts.\r\n\t\t\t     A broadcast, multicast or unicast address may be specified.\r\n\t\t\t     Setting the address to 0.0.0.0 disables NTP broadcasts.')
hmNetNTPAnycastInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetNTPAnycastInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPAnycastInterval.setDescription('Interval of NTP broadcast messages in seconds.\r\n\t\t\t     NTP will round down the value to a power of 2.')
hmNetNTPStatusText = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetNTPStatusText.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPStatusText.setDescription('Operational status of the NTP sub-system.')
hmNetNTPStatusCode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 31, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetNTPStatusCode.setStatus('current')
if mibBuilder.loadTexts: hmNetNTPStatusCode.setDescription('Operational status of the NTP sub-system.\r\n\t\t\t     The value is a bit mask:\r\n                        1  local system clock synchronized\r\n                        2  generic error (see hmNetNTPStatusText)\r\n                      100  server 1 not synchronized\r\n                      200  server 1 protocol error\r\n                      400  server 1 not responding\r\n                      800  server 1 synchronization in progress\r\n                    10000  server 2 not synchronized\r\n                    20000  server 2 protocol error\r\n                    40000  server 2 not responding\r\n                    80000  server 2 synchronization in progress\r\n                 (Note that all values are hexadecimal.)')
hmNetPTPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40))
hmNetPTPConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1))
hmNetPTPEnable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPEnable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPEnable.setDescription('Enable or disable the Precision Time Protocol\r\n\t\t\ton this node.')
hmNetPTPAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("init-with-default", 2), ("init-with-nvm", 3))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPAction.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPAction.setDescription('Initialize the PTP Clock. Value 2: The specification \r\n\t\t\tinitialization set shall be used. Value 3: The initialization \r\n\t\t\tset stored in nonvolatile storage for recovery \r\n\t\t\tafter a power fail shall be used. Value 1: no action.\r\n\t\t\tIn GET operations the variable always returns other(1)')
hmNetPTPClockMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7, 9))).clone(namedValues=NamedValues(("v1-boundary-clock", 1), ("v1-simple-mode", 4), ("v2-boundary-clock-onestep", 5), ("v2-boundary-clock-twostep", 6), ("v2-transparent-clock", 7), ("v2-simple-mode", 9))).clone('v1-simple-mode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPClockMode.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPClockMode.setDescription("This members value shall indicate which clock mode is used.\r\n\t\t\tThe ptp-mode-boundary-clock mode specifies the mode as described in the IEEE1588 standard.\r\n\t\t\tIn the 'ptp-mode-simple-ptp' mode the device only accepts PTP sync messages, sets the time\r\n\t\t\tdirectly and no BMC algorithm will run. If the clock mode is changed, PTP will be initialized.")
hmNetPTPSlavePort = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPSlavePort.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPSlavePort.setDescription('This members value shall indicate the slave port where this clock is synchronized \r\n\t\t\tin the ptp-mode-static-boundary-clock mode.\r\n\t\t\tThe default value is 0 (i.e. clock is grandmaster).')
hmNetPTPIsSynchronized = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPIsSynchronized.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPIsSynchronized.setDescription('If the clock is synchronized to the current Master this object is set to true. \r\n\t\t\tOtherwise it is set to false. The clock sets this object to true, if the offset (ns)\r\n\t\t\tto the current Master is less than hmNetPTPSyncLowerBound. The clock sets this object to false, \r\n\t\t\tif the offset (ns) to the current Master is bigger than hmNetPTPSyncUpperBound.')
hmNetPTPSyncLowerBound = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999999999)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPSyncLowerBound.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPSyncLowerBound.setDescription('This object defines when the hmNetPTPIsSynchronized object is set to true. \r\n\t\t\tIf the absolute value of the offset is smaller than hmNetPTPSyncLowerBound, \r\n\t\t\tthe hmNetPTPIsSynchronized is set true.\r\n\t\t\tThe value is interpreted as nanoseconds.')
hmNetPTPSyncUpperBound = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(31, 1000000000)).clone(5000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPSyncUpperBound.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPSyncUpperBound.setDescription('This object defines when the hmNetPTPIsSynchronized object is set to false. \r\n\t\t\tIf the absolute value of the offset is bigger than hmNetPTPSyncUpperBound, the hmNetPTPIsSynchronized is set false.\r\n\t\t\tThe value is interpreted as nanoseconds.')
hmNetPTPClockStratum = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 8), Integer32().clone(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPClockStratum.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPClockStratum.setDescription('The clock stratum, or stratum number, \r\n\t\t\tdescribes one measure of the quality of a clock. Each clock\r\n\t\t\tshall be characterized by a stratum number to be used by \r\n\t\t\tthe best master clock algorithm as one parameter of clock\r\n\t\t\tquality. A clock stratum of 1 is the best,\r\n\t\t\twhere the default clock stratum is 255.')
hmNetPTPClockIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPClockIdentifier.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPClockIdentifier.setDescription('The clock identifier indicates the nature and expected \r\n\t\t\tabsolute accuracy and epoch of a given clock. Possible\r\n\t\t\tvalues are ATOM, GPS, NTP, HAND, INIT, DFLT. Values with\r\n\t\t\tless characters than the maximum allowed length will be\r\n\t\t\tpadded with zero characters.')
hmNetPTPClockVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767)).clone(-16256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPClockVariance.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPClockVariance.setDescription('The clock variance reflects the inherent characteristics of the clock. \r\n\t\t\tIt is an estimate of the local clock from a linear time scale when it \r\n \t\t\tis not synchronized to another PTP clock using the PTP protocol.')
hmNetPTPPreferredMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPPreferredMaster.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPreferredMaster.setDescription('A clock may be administratively designated as part of a\r\n\t\t\tpreferred master clock set. This creates a set of clocks\r\n\t\t\tthat will be favored over those not so designated in the\r\n\t\t\tselection of master clocks within a subdomain. The purpose\r\n\t\t\tof this designation is to allow users to specify a clock\r\n\t\t\tthat will remain master in the presence of disconnection\r\n\t\t\tor connection of other clocks.')
hmNetPTPSyncInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 8, 16, 64))).clone(namedValues=NamedValues(("sec-1", 1), ("sec-2", 2), ("sec-8", 8), ("sec-16", 16), ("sec-64", 64))).clone('sec-2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPSyncInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPSyncInterval.setDescription('The sync interval shall be the interval in seconds between\r\n\t\t\tsuccessive Sync messages issued by master clocks. \r\n\t\t\tIt shall have the same value for all clocks in a subdomain.\r\n\t\t\tThe value of sync interval is a compromise between the\r\n\t\t\tinherent stability of the clocks, the responsiveness of the\r\n\t\t\tclocks in a subdomain to change, and the communication load\r\n\t\t\timposed by PTP. Allowed values are 1,2,8,16 and 64. \r\n\t\t\tChanges are applied after the initialization with the init \r\n\t\t\tkey init-with-nvm or after reboot if the configuration was saved.')
hmNetPTPSubdomainName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 13), PTPSubdomainName()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPSubdomainName.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPSubdomainName.setDescription('Each subdomain shall be characterized by a name recognized\r\n\t\t\tby all PTP clocks in the subdomain as the basis for sending\r\n\t\t\tand receiving PTP communications. Changes are applied after \r\n\t\t\tthe initialization with the init key init-with-nvm or afer \r\n\t\t\treboot if the configuration was saved.')
hmNetPTPOffsetFromMasterNanoSecs = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPOffsetFromMasterNanoSecs.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPOffsetFromMasterNanoSecs.setDescription('Current offset between its parent and this node in nanoseconds.\r\n\t\t\tValues greater than 1 second or less than -1 second are\r\n\t\t\tindicated by the maximum or minimum INTEGER values.')
hmNetPTPAbsMaxOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPAbsMaxOffset.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPAbsMaxOffset.setDescription('This members value shall indicate the absolute value for the maximum offset between its parent and this node. \r\n\t\t\tThe value is set to zero if the offset is the first time smaller than hmNetPTPSyncLowerBound.\r\n\t\t\tOffsets bigger than +/-1 second is indicated by the maximum value')
hmNetPTPOneWayDelayNanoSecs = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPOneWayDelayNanoSecs.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPOneWayDelayNanoSecs.setDescription('Current one_way_delay between its parent and this node in nanoseconds.\r\n\t\t\tValues greater than 1 second or less than -1 second are\r\n\t\t\tindicated by the maximum or minimum INTEGER values.')
hmNetPTPTimeSeconds = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPTimeSeconds.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPTimeSeconds.setDescription('This members value shall indicate PTP time in seconds since 1.1.1970.')
hmNetPTPObservedDrift = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPObservedDrift.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPObservedDrift.setDescription('Relative rate (frequency or drift) between its parent and this node in nanoseconds.\r\n\t\t\tValues greater than 1 second or less than -1 second are\r\n\t\t\tindicated by the maximum or minimum INTEGER values.')
hmNetPTPPiIntegral = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000)).clone(6250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPPiIntegral.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPiIntegral.setDescription('A digital PI servo has the following difference equation \r\n\t\t\ty(k) = y(k-1) + (Kp + Ki* T )* x(k) +  Kp * x(k-1).\r\n\t\t\tThis object specifies the Ki* 100000 term (integral part). Kp is 0.5.\r\n\t\t\tThe default value of this object is 6250 that is Ki=1/16.')
hmNetPTPParentUUID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 20), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPParentUUID.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPParentUUID.setDescription('The UUID of its Parent. For Ethernet this is the MAC\r\n\t\t\taddress of the management agent.')
hmNetPTPGrandmasterUUID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 21), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPGrandmasterUUID.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPGrandmasterUUID.setDescription('The UUID of its Grandmaster. For Ethernet this is the MAC\r\n\t\t\taddress of the management agent.')
hmNetPTPCurrentUTCOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPCurrentUTCOffset.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPCurrentUTCOffset.setDescription('UTC time differs from the TAI time by a constant offset. \r\n\t\t\tThis offset is modified on occasion by adding or subtracting\r\n\t\t\tleap seconds. The current number of leap seconds is represented\r\n\t\t\tin PTP by the value of hmNetPTPCurrentUTCOffset.')
hmNetPTPleap59 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPleap59.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPleap59.setDescription('When TRUE the last minute of the current day will contain 59 seconds.')
hmNetPTPleap61 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPleap61.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPleap61.setDescription('When TRUE the last minute of the current day will contain 61 seconds.')
hmNetPTPStepsRemoved = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPStepsRemoved.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPStepsRemoved.setDescription('This members value shall be the number of communication paths traversed between the local clock and \r\n\t\t\tthe grandmaster clock. For example, steps_removed in a slave clock on the same PTP communication path as\r\n\t\t\tthe grandmaster clock will have a value of 1, indicating that a single path was traversed.')
hmNetPTPEpochNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPEpochNumber.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPEpochNumber.setDescription('The PTP epoch began at 0 hours on 1 January 1970. Times measured\r\n\t\t\tsince this epoch are designated in this standard as PTP Seconds.\r\n\t\t\tWhen the epoch is the PTP epoch, the value of the epoch number\r\n\t\t\tshall be the current number of times the 32-bit seconds clock\r\n\t\t\thas rolled over since the PTP epoch.')
hmNetPTPStaticDrift = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-500000000, 500000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPStaticDrift.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPStaticDrift.setDescription('Relative rate (frequency or drift) between a reference clock and this node \r\n\t\t\tin nanoseconds per second (ns/s). This value is only applied if no port is in \r\n\t\t\tslave state.')
hmNetPTPPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2), )
if mibBuilder.loadTexts: hmNetPTPPortTable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortTable.setDescription('This table contains variables for each PTP port of\r\n\t\t\tthe switch.')
hmNetPTPPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmNetPTPPortID"))
if mibBuilder.loadTexts: hmNetPTPPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortEntry.setDescription('Entry for one port.')
hmNetPTPPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPPortID.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortID.setDescription('Index to identify a port of the switch unit. \r\n\t\t\tThis value is never greater than hmSysGroupCapacity.')
hmNetPTPPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("pre-master", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTPPortState.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortState.setDescription('State of the PTP port intance.')
hmNetPTPPortBurstEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPPortBurstEnable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortBurstEnable.setDescription('Controls the burst enable flag.')
hmNetPTPPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 40, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTPPortEnable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTPPortEnable.setDescription('The respective PTP Port of the Boundary Clock can be set to true (enabled) or set to false (disabled).\r\n\t\t\tIf the port is disabled no PTP packets will be processed for the respective port.')
hmNetPTP2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41))
hmNetPTP2Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1))
hmNetPTP2TwoStepClock = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2TwoStepClock.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TwoStepClock.setDescription('')
hmNetPTP2ClockIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 2), PTPClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2ClockIdentity.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2ClockIdentity.setDescription('')
hmNetPTP2Priority1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2Priority1.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2Priority1.setDescription('')
hmNetPTP2Priority2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2Priority2.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2Priority2.setDescription('')
hmNetPTP2DomainNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2DomainNumber.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2DomainNumber.setDescription('')
hmNetPTP2StepsRemoved = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2StepsRemoved.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2StepsRemoved.setDescription('')
hmNetPTP2OffsetFromMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 7), PTPTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2OffsetFromMaster.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2OffsetFromMaster.setDescription('')
hmNetPTP2MeanPathDelay = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 8), PTPTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2MeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2MeanPathDelay.setDescription('')
hmNetPTP2ParentPortIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 9), PTPPortIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2ParentPortIdentity.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2ParentPortIdentity.setDescription('')
hmNetPTP2ParentStats = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2ParentStats.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2ParentStats.setDescription('')
hmNetPTP2ObservedParentOffsetScaledLogVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2ObservedParentOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2ObservedParentOffsetScaledLogVariance.setDescription('')
hmNetPTP2ObservedParentClockPhaseChangeRate = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2ObservedParentClockPhaseChangeRate.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2ObservedParentClockPhaseChangeRate.setDescription('')
hmNetPTP2GrandmasterIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 13), PTPClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterIdentity.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterIdentity.setDescription('')
hmNetPTP2GrandmasterClockQuality = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 14), PTPClockQuality()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockQuality.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockQuality.setDescription('')
hmNetPTP2GrandmasterPriority1 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterPriority1.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterPriority1.setDescription('')
hmNetPTP2GrandmasterPriority2 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterPriority2.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterPriority2.setDescription('')
hmNetPTP2CurrentUtcOffset = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2CurrentUtcOffset.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2CurrentUtcOffset.setDescription('')
hmNetPTP2CurrentUtcOffsetValid = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 18), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2CurrentUtcOffsetValid.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2CurrentUtcOffsetValid.setDescription('')
hmNetPTP2Leap59 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2Leap59.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2Leap59.setDescription('')
hmNetPTP2Leap61 = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2Leap61.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2Leap61.setDescription('')
hmNetPTP2TimeTraceable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TimeTraceable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TimeTraceable.setDescription('')
hmNetPTP2FrequencyTraceable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2FrequencyTraceable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2FrequencyTraceable.setDescription('')
hmNetPTP2PtpTimescale = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 23), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2PtpTimescale.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PtpTimescale.setDescription('')
hmNetPTP2TimeSource = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160))).clone(namedValues=NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOscillator", 160)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TimeSource.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TimeSource.setDescription('')
hmNetPTP2GrandmasterClockClass = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockClass.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockClass.setDescription('')
hmNetPTP2GrandmasterClockAccuracy = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))).clone(namedValues=NamedValues(("within25ns", 32), ("within100ns", 33), ("within250ns", 34), ("within1000ns", 35), ("within2500ns", 36), ("within10us", 37), ("within25us", 38), ("within100us", 39), ("within250us", 40), ("within1000us", 41), ("within2500us", 42), ("within10ms", 43), ("within25ms", 44), ("within100ms", 45), ("within250ms", 46), ("within1s", 47), ("within10s", 48), ("beyond10s", 49), ("unknown", 254)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockAccuracy.setDescription('')
hmNetPTP2GrandmasterClockVariance = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockVariance.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2GrandmasterClockVariance.setDescription('')
hmNetPTP2PortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2), )
if mibBuilder.loadTexts: hmNetPTP2PortTable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PortTable.setDescription('This table contains variables for each PTP2 port of\r\n\t\t\tthe switch.')
hmNetPTP2PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmNetPTPPortID"))
if mibBuilder.loadTexts: hmNetPTP2PortEntry.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PortEntry.setDescription('Entry for one port.')
hmNetPTP2PortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2PortEnable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PortEnable.setDescription('')
hmNetPTP2PortState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initializing", 1), ("faulty", 2), ("disabled", 3), ("listening", 4), ("pre-master", 5), ("master", 6), ("passive", 7), ("uncalibrated", 8), ("slave", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2PortState.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PortState.setDescription('State of the PTP2 port intance.')
hmNetPTP2LogDelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2LogDelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2LogDelayReqInterval.setDescription('')
hmNetPTP2PeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 4), PTPTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2PeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PeerMeanPathDelay.setDescription('')
hmNetPTP2LogAnnounceInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("sec-1", 0), ("sec-2", 1), ("sec-4", 2), ("sec-8", 3), ("sec-16", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2LogAnnounceInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2LogAnnounceInterval.setDescription('')
hmNetPTP2AnnounceReceiptTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2AnnounceReceiptTimeout.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2AnnounceReceiptTimeout.setDescription('')
hmNetPTP2LogSyncInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-2, -1, 0, 1))).clone(namedValues=NamedValues(("msec-250", -2), ("msec-500", -1), ("sec-1", 0), ("sec-2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2LogSyncInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2LogSyncInterval.setDescription('')
hmNetPTP2DelayMechanism = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 254))).clone(namedValues=NamedValues(("e2e", 1), ("p2p", 2), ("disabled", 254))).clone('e2e')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2DelayMechanism.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2DelayMechanism.setDescription('')
hmNetPTP2LogPdelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sec-1", 0), ("sec-2", 1), ("sec-4", 2), ("sec-8", 3), ("sec-16", 4), ("sec-32", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2LogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2LogPdelayReqInterval.setDescription('')
hmNetPTP2VersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptpVersion1", 1), ("ptpVersion2", 2))).clone('ptpVersion2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2VersionNumber.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2VersionNumber.setDescription('')
hmNetPTP2NetworkProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("udpIpv4", 1), ("ieee8023", 3))).clone('udpIpv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2NetworkProtocol.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2NetworkProtocol.setDescription('')
hmNetPTP2V1Compatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2V1Compatibility.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2V1Compatibility.setDescription('')
hmNetPTP2DelayAsymmetry = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 13), PTPTimeInterval().clone(hexValue="0000000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2DelayAsymmetry.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2DelayAsymmetry.setDescription('')
hmNetPTP2PortCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 14), Bits().clone(namedValues=NamedValues(("reserved", 0), ("one-step", 1), ("e2e-delay", 2), ("p2p-delay", 3), ("ptp2Ieee8023", 4), ("ptp2UdpIpv4", 5), ("ptp2UdpIpv6", 6), ("asymmCorrection", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2PortCapability.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2PortCapability.setDescription('This object shows the capability of the ptp port.')
hmNetPTP2VlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4042)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2VlanID.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2VlanID.setDescription('VLAN in which PTP packets are send. With a value of -1 all packets are send untagged')
hmNetPTP2VlanPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 41, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2VlanPriority.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2VlanPriority.setDescription('VLAN priority of tagged ptp packets')
hmNetPTP2TCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42))
hmNetPTP2TCConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1))
hmNetPTP2TCClockIdentity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 1), PTPClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2TCClockIdentity.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCClockIdentity.setDescription('')
hmNetPTP2TCDelayMechanism = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 254))).clone(namedValues=NamedValues(("e2e", 1), ("p2p", 2), ("e2e-optimized", 3), ("disabled", 254))).clone('e2e')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCDelayMechanism.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCDelayMechanism.setDescription('')
hmNetPTP2TCPrimaryDomain = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCPrimaryDomain.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPrimaryDomain.setDescription('')
hmNetPTP2TCSyntonized = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCSyntonized.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCSyntonized.setDescription('')
hmNetPTP2TCNetworkProtocol = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("udpIpv4", 1), ("ieee8023", 3))).clone('udpIpv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCNetworkProtocol.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCNetworkProtocol.setDescription('')
hmNetPTP2TCCurrentMaster = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 6), PTPPortIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2TCCurrentMaster.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCCurrentMaster.setDescription('')
hmNetPTP2TCManagement = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCManagement.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCManagement.setDescription('')
hmNetPTP2TCMultiDomainMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCMultiDomainMode.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCMultiDomainMode.setDescription('')
hmNetPTP2TCSyncLocalClock = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCSyncLocalClock.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCSyncLocalClock.setDescription('Enable synchronisation of the local clock. This is only valid if syntonization is enabled')
hmNetPTP2TCVlanID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4042)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCVlanID.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCVlanID.setDescription('VLAN in which PTP packets are send. With a value of -1 all packets are send untagged')
hmNetPTP2TCVlanPriority = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCVlanPriority.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCVlanPriority.setDescription('VLAN priority of tagged ptp packets')
hmNetPTP2TCProfile = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("user-defined", 1), ("default-e2e", 2), ("default-p2p", 3), ("power", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCProfile.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCProfile.setDescription('Configures PTP parameters to a specific profile. Setting the object\r\n\t\t\t to user-defined (1) has no effect.')
hmNetPTP2TCPowerTLVCheck = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCPowerTLVCheck.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPowerTLVCheck.setDescription('If set to true only Announce messages including the TLVs specified in \r\n \t\t\tthe Power Profile (C37.238) are accepted for syntonization')
hmNetPTP2TCPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2), )
if mibBuilder.loadTexts: hmNetPTP2TCPortTable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPortTable.setDescription('This table contains variables for each PTP2 TC port of\r\n\t\t\tthe switch.')
hmNetPTP2TCPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmNetPTPPortID"))
if mibBuilder.loadTexts: hmNetPTP2TCPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPortEntry.setDescription('Entry for one port.')
hmNetPTP2TCPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1, 1), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCPortEnable.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPortEnable.setDescription('')
hmNetPTP2TCLogPdelayReqInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("sec-1", 0), ("sec-2", 1), ("sec-4", 2), ("sec-8", 3), ("sec-16", 4), ("sec-32", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCLogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCLogPdelayReqInterval.setDescription('')
hmNetPTP2TCFaulty = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2TCFaulty.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCFaulty.setDescription('')
hmNetPTP2TCPeerMeanPathDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1, 4), PTPTimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetPTP2TCPeerMeanPathDelay.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCPeerMeanPathDelay.setDescription('')
hmNetPTP2TCDelayAsymmetry = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 42, 2, 1, 5), PTPTimeInterval().clone(hexValue="0000000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetPTP2TCDelayAsymmetry.setStatus('current')
if mibBuilder.loadTexts: hmNetPTP2TCDelayAsymmetry.setDescription('')
hmNetSNMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50))
hmNetSNMPv1Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPv1Status.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPv1Status.setDescription('Enables/disables the SNMP Version 1 protocol.')
hmNetSNMPv2Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPv2Status.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPv2Status.setDescription('Enables/disables the SNMP Version 2 protocol.')
hmNetSNMPv3Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPv3Status.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPv3Status.setDescription('Enables/disables the SNMP Version 3 protocol.')
hmNetSNMPAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("readOnly", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPAccessStatus.setDescription('Enables/disables the SNMP protocol access\r\n\t\t\ton this device.\r\n\t\t\tIf only read access is allowed set this object\r\n\t\t\tto readOnly(3).')
hmNetSNMPSynchronizeV1V3Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPSynchronizeV1V3Status.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPSynchronizeV1V3Status.setDescription('Enables/disables the synchronization between\r\n\t\t\tthe SNMPv1 community and the SNMPv3 password.\r\n\t\t\tIf enabled the first read-write community in hmAuthCommTable\r\n\t\t\tis used for the SNMPv3 admin password.\r\n\t\t\tThis is the same password that is used in the user- and\r\n\t\t\twebinterface.\r\n\t\t\tFurther, if enabled the first read-only community in \r\n\t\t\thmAuthCommTable is used for the SNMPv3 user password.')
hmNetSNMPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(161)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPPortNumber.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPPortNumber.setDescription('The port number of the snmp server.\r\n\t\t\tTo activate the port number the device\r\n\t\t\thas to be restarted.')
hmNetSNMPRadiusAuthenticate = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPRadiusAuthenticate.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPRadiusAuthenticate.setDescription('Enables/disables authentication of SNMPv3\r\n\t\t\tusers via RADIUS server')
hmNetSNMPv3EncryptionReadWriteStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPv3EncryptionReadWriteStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPv3EncryptionReadWriteStatus.setDescription('Enables/disables the SNMPv3 admin Data Encryption.')
hmNetSNMPv3EncryptionReadOnlyStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPv3EncryptionReadOnlyStatus.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPv3EncryptionReadOnlyStatus.setDescription('Enables/disables the SNMPv3 user Data Encryption.')
hmNetSNMPSynchronizeV3V1Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 50, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetSNMPSynchronizeV3V1Status.setStatus('current')
if mibBuilder.loadTexts: hmNetSNMPSynchronizeV3V1Status.setDescription('Enables/disables the synchronization between the SNMPv3 password table (hmAgentUserConfigTable) \r\n\t\t\tand the SNMPv1/v2 community table (hmAgentSnmpCommunityConfigTable).')
hmNetGPSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 60))
hmNetGPSIsAvailable = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 60, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetGPSIsAvailable.setStatus('current')
if mibBuilder.loadTexts: hmNetGPSIsAvailable.setDescription('Indicates if a GPS module is available.')
hmNetGPSIsSynchronized = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 60, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetGPSIsSynchronized.setStatus('current')
if mibBuilder.loadTexts: hmNetGPSIsSynchronized.setDescription('Indicates if the GPS module is synchronized to the GPS signal.')
hmNetGPSMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 60, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gpsIn", 1), ("gpsOut", 2))).clone('gpsIn')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetGPSMode.setStatus('current')
if mibBuilder.loadTexts: hmNetGPSMode.setDescription('Shows the mode of the GPS module. If hmNetGPSMode is gpsIn(1), the GPS\r\n\t\t\tmodule reads the signal from a GPS receiver in the format given in\r\n\t\t\thmNetGPSTimeStringFormat. If the mode is gpsOut(2), the GPS module\r\n\t\t\tsends out a signal in the format given in hmNetGPSTimeStringFormat.')
hmNetGPSTimeStringFormat = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 60, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("meinberg", 1))).clone('meinberg')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmNetGPSTimeStringFormat.setStatus('current')
if mibBuilder.loadTexts: hmNetGPSTimeStringFormat.setDescription('These are the GPS time string formats which a GPS module can read or write.')
hmRestrictedMgtAccessGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70))
hmRMAOperation = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMAOperation.setStatus('current')
if mibBuilder.loadTexts: hmRMAOperation.setDescription('Enables/disables Management Access globally')
hmRMATable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2), )
if mibBuilder.loadTexts: hmRMATable.setStatus('current')
if mibBuilder.loadTexts: hmRMATable.setDescription('A list of Management Access Entries (Rules) to increase security ')
hmRMAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmRMAIndex"))
if mibBuilder.loadTexts: hmRMAEntry.setStatus('current')
if mibBuilder.loadTexts: hmRMAEntry.setDescription('An entry contains a rule for the Management Access.')
hmRMAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRMAIndex.setStatus('current')
if mibBuilder.loadTexts: hmRMAIndex.setDescription('The unique index used for each row in the RMA Table')
hmRMARowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmRMARowStatus.setStatus('current')
if mibBuilder.loadTexts: hmRMARowStatus.setDescription('Describes the status of a row in this table if it is active or not available ...')
hmRMAIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMAIpAddr.setStatus('current')
if mibBuilder.loadTexts: hmRMAIpAddr.setDescription('Allowed IP address')
hmRMANetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMANetMask.setStatus('current')
if mibBuilder.loadTexts: hmRMANetMask.setDescription('Network Mask')
hmRMASrvHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMASrvHttp.setStatus('current')
if mibBuilder.loadTexts: hmRMASrvHttp.setDescription('Enables/disables HTTP access')
hmRMASrvSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMASrvSnmp.setStatus('current')
if mibBuilder.loadTexts: hmRMASrvSnmp.setDescription('Enables/disbales SNMP access')
hmRMASrvTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMASrvTelnet.setStatus('current')
if mibBuilder.loadTexts: hmRMASrvTelnet.setDescription('Enables/disables Telnet access')
hmRMASrvSsh = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMASrvSsh.setStatus('current')
if mibBuilder.loadTexts: hmRMASrvSsh.setDescription('Enables/disables SSH access')
hmRMASrvHttps = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 3, 70, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRMASrvHttps.setStatus('current')
if mibBuilder.loadTexts: hmRMASrvHttps.setDescription('Enables/disables HTTPS access')
hmFSTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 4))
hmFSUpdFileName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSUpdFileName.setStatus('current')
if mibBuilder.loadTexts: hmFSUpdFileName.setDescription('Full specified filename of the update file\r\n\t\t\t\te.g. tftp://192.9.200.1/upd/bootrom.v3 .')
hmFSConfFileName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSConfFileName.setStatus('current')
if mibBuilder.loadTexts: hmFSConfFileName.setDescription('Full specified name of the configuration file\r\n\t\t\t\te.g. tftp://192.9.200.1/cfg/config1.sav .')
hmFSLogFileName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSLogFileName.setStatus('current')
if mibBuilder.loadTexts: hmFSLogFileName.setDescription('Local or full specified url of the log file. \r\n\t\t\t\tIf value is local, the log will be written to the flash.\r\n\t\t\t\te.g. tftp://192.9.200.1/log/log300599.log or local.')
hmFSUserName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSUserName.setStatus('current')
if mibBuilder.loadTexts: hmFSUserName.setDescription('login name for the used file transport protocol.')
hmFSTPPassword = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSTPPassword.setStatus('current')
if mibBuilder.loadTexts: hmFSTPPassword.setDescription('password for the used file transport protocol.')
hmFSAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 15, 16, 20, 21))).clone(namedValues=NamedValues(("other", 1), ("update", 2), ("config-load", 3), ("config-save", 4), ("config-load-remote", 5), ("config-save-remote", 6), ("log-save", 7), ("config-load-default", 8), ("set-to-factory", 9), ("log-clear", 10), ("gbl-update", 12), ("config-load-backup", 13), ("config-remote-and-save", 15), ("updateBootcode", 16), ("toggleImage", 20), ("config-save-remote-script", 21))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSAction.setStatus('current')
if mibBuilder.loadTexts: hmFSAction.setDescription('This object, when read, always returns a value of other (1).\r\n\t\t\t\t When set to update (2), the updatefile specified by\r\n\t\t\t\t hmFSUpdFileName will be loaded. config-load (3) will load the\r\n\t\t\t\t configuration stored in the local flash. config-save (4) will\r\n\t\t\t\t write the present configuration to the flash.\r\n\t\t\t\t config-load-remote (5) will load the configuration stored in\r\n\t\t\t\t a file specified by hmFSConfigFileName (which may be in binary\r\n\t\t\t\t or script format).\r\n\t\t\t\t config-save-remote (6) will save the present configuration in a\r\n\t\t\t\t file specified by hmFSConfigFileName.\r\n\t\t\t\t log-save (7) will save the local logfile to a file specified\r\n\t\t\t\t with hmFSLogFileName. config-load-default (8) will restore the\r\n\t\t\t\t default settings and set-to-factory (9) will apply the factory \r\n\t\t\t\t settings to the system and save the configuration to flash.\r\n                 log-clear (10) will clear the logfile of the agent.\r\n                 gbl-update (12) will perform a software update of the whole chassis.\r\n                 config-load-backup (13) loads an automatically saved backup configuration\r\n                 config-remote-and-save (15) loads a configuration via tftp and saves it \r\n                 to the flash. toggleImage (20) switches between main and backup\r\n                 software image to be active (so it will be loaded after the next coldstart).\r\n                 config-save-remote-script (21) saves the current configuration in script \r\n                 format to the file specified by hmFSConfigFileName.\r\n\t\t\t\t Any other value results in a badValue status code.')
hmFSActionResult = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("pending", 2), ("ok", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSActionResult.setStatus('current')
if mibBuilder.loadTexts: hmFSActionResult.setDescription('Result of the last activated action.')
hmFSBootConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("local", 2))).clone('local')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSBootConfiguration.setStatus('current')
if mibBuilder.loadTexts: hmFSBootConfiguration.setDescription('By setting this MIB variable the user can control which\r\n\t\t\t\t configuration should be read during system initialization:\r\n\t\t\t\t default(1) \t  : boot with factory settings\r\n\t\t\t\t local(2)\t\t  : boot with locally stored configuration')
hmFSRunningConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("boot", 1), ("local", 2), ("remote", 3))).clone('boot')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmFSRunningConfiguration.setStatus('current')
if mibBuilder.loadTexts: hmFSRunningConfiguration.setDescription('By setting this MIB variable the user can control which\r\n\t\t\t\t configuration should be read after switch initialization:\r\n\t\t\t\t boot(1)\t   : the one which is selected \r\n\t\t\t\t\t\t\t\t by hmFSBootConfiguration\r\n\t\t\t\t local(2)\t\t  : boot with locally stored configuration\r\n\t\t\t\t remote(3)\t   : use the remotely stored configuration \r\n\t\t\t\t\t\t\t\t\taccording to hmFSConfFileName')
hmFSLastMessage = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSLastMessage.setStatus('current')
if mibBuilder.loadTexts: hmFSLastMessage.setDescription("error message of the last hmFSAction performed. If there was no error\r\n                 encountered, the value of this variable will be 'OK'")
hmConfigurationStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("notInSync", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmConfigurationStatus.setStatus('current')
if mibBuilder.loadTexts: hmConfigurationStatus.setDescription("Status of the local configuration.\r\n\t\t\tok(1):         Local and running configuration match.\r\n\t\t\tnotInSync(2):  Local and running configuration don't match,\r\n\t\t\t\t\t\t   configuration has not yet been saved.")
hmConfigurationSignature = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmConfigurationSignature.setStatus('current')
if mibBuilder.loadTexts: hmConfigurationSignature.setDescription('Signature of the stored configuration. The signature \r\n                 changes each time the configuration is saved.')
hmFSFileTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100), )
if mibBuilder.loadTexts: hmFSFileTable.setStatus('current')
if mibBuilder.loadTexts: hmFSFileTable.setDescription('a directory of the internal file system')
hmFSFileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmFSFileID"))
if mibBuilder.loadTexts: hmFSFileEntry.setStatus('current')
if mibBuilder.loadTexts: hmFSFileEntry.setDescription('The entry of the hmFSFileTable.')
hmFSFileID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSFileID.setStatus('current')
if mibBuilder.loadTexts: hmFSFileID.setDescription('This index is used to identify the associated file')
hmFSFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSFileName.setStatus('current')
if mibBuilder.loadTexts: hmFSFileName.setDescription('file name excluding path')
hmFSFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSFileSize.setStatus('current')
if mibBuilder.loadTexts: hmFSFileSize.setDescription('file size in bytes')
hmFSFileDate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 100, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmFSFileDate.setStatus('current')
if mibBuilder.loadTexts: hmFSFileDate.setDescription('date in UNIX format (seconds since 1 jan 1970)')
hmAutoconfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 200))
hmAutoconfigAdapterStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 200, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notPresent", 1), ("removed", 2), ("ok", 3), ("notInSync", 4), ("outOfMemory", 5), ("wrongMachine", 6), ("checksumErr", 7), ("genericErr", 8), ("autodisabled", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoconfigAdapterStatus.setStatus('current')
if mibBuilder.loadTexts: hmAutoconfigAdapterStatus.setDescription("Status of the AutoConfiguration Adapter.\r\n\t\t\t\tnotPresent(1): AutoConfiguration Adapter has not been detected.\r\n\t\t\t\tremoved(2): Configuration was loaded from adapter, but adapter \r\n\t\t\t\t\twas removed in running mode of the agent.\r\n\t\t\t\tok(3):        Configuration of adapter and switch match.\r\n\t\t\t\tnotInSync(4): Configuration of adapter and switch don't match,\r\n\t\t\t\t\te.g. configuration has not yet been written into\r\n\t\t\t\t\tthe adapter.\r\n\t\t\t\toutOfMemory(5): Configuration is too large for the adapter.\r\n\t\t\t\twrongMachine(6): Adapter contains configuration which cannot\r\n\t\t\t\t\tbe loaded into this machine because it was\r\n\t\t\t\t\tcreated by a different type of switch.\r\n\t\t\t\tchecksumErr(7): Data in adapter fails consistency check.\r\n\t\t\t\tgenericErr(8): Any other failure, e.g. hardware malfunction.\r\n\t\t\t\tautodisabled(9): USB port has been disabled for safety reasons.")
hmAutoconfigAdapterSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 200, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoconfigAdapterSerialNum.setStatus('current')
if mibBuilder.loadTexts: hmAutoconfigAdapterSerialNum.setDescription('The serial number provided by vendor (ASCII). ')
hmConfigWatchdogGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201))
hmConfigWatchdogAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmConfigWatchdogAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmConfigWatchdogAdminStatus.setDescription('Administrative status of the configuration watchdog.\r\n\t\t\t\tenable(1): start/trigger the watchdog timer\r\n\t\t\t\tdisable(2): turn off the watchdog\r\n\r\n\t\t\t\tThis feature provides recovery from situations where the\r\n\t\t\t\tswitch cannot be reached by the management station anymore.\r\n\r\n\t\t\t\tWhenever this variable is set to enable(1), the value of\r\n\t\t\t\thmConfigWatchdogTimeInterval is loaded into the watchdog timer.\r\n\t\t\t\tThis timer must be triggered before hmConfigWatchdogTimerValue\r\n\t\t\t\treaches 0. If the watchdog timer expires, the last saved\r\n\t\t\t\tconfiguration of the switch will be restored.\r\n\t\t\t\t\r\n\t\t\t\tThe watchdog is triggered with MIB read and write accesses')
hmConfigWatchdogOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmConfigWatchdogOperStatus.setStatus('current')
if mibBuilder.loadTexts: hmConfigWatchdogOperStatus.setDescription('Operational status of the configuration watchdog.\r\n\t\t\t\tenable(1): watchdog up and running\r\n\t\t\t\tdisable(2): watchdog inactive')
hmConfigWatchdogTimeInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmConfigWatchdogTimeInterval.setStatus('current')
if mibBuilder.loadTexts: hmConfigWatchdogTimeInterval.setDescription('Period of the watchdog timer in seconds.')
hmConfigWatchdogTimerValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmConfigWatchdogTimerValue.setStatus('current')
if mibBuilder.loadTexts: hmConfigWatchdogTimerValue.setDescription('Current count-down value of the watchdog timer in seconds.')
hmConfigWatchdogIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 4, 201, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmConfigWatchdogIPAddress.setStatus('current')
if mibBuilder.loadTexts: hmConfigWatchdogIPAddress.setDescription('Current IP Adress of station that triggers the watchdog.')
hmTempTable = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 5))
hmTemperature = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTemperature.setStatus('current')
if mibBuilder.loadTexts: hmTemperature.setDescription('This signed integer is used to identify the temperature\r\n\t\t\t\twithin the agent in units of centigrade (celsius).')
hmTempUprLimit = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-99, 99)).clone(70)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTempUprLimit.setStatus('current')
if mibBuilder.loadTexts: hmTempUprLimit.setDescription('This value is used to define a maximum level for the\r\n\t\t\t\ttemperature within an agent. If the temperature rises above\r\n\t\t\t\tthis upper limit, the management station will be notified by\r\n\t\t\t\ta hmTemperature trap.')
hmTempLwrLimit = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 5, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-99, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTempLwrLimit.setStatus('current')
if mibBuilder.loadTexts: hmTempLwrLimit.setDescription('This value is used to define a minimum level for the\r\n\t\t\t\ttemperature within a concentrator. If the temperature falls\r\n\t\t\t\tbelow this lower limit, the management station will be notified\r\n\t\t\t\tby a hmTemperature trap.')
hmNeighbourAgentTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 6), )
if mibBuilder.loadTexts: hmNeighbourAgentTable.setStatus('current')
if mibBuilder.loadTexts: hmNeighbourAgentTable.setDescription('A list of the neighbour agents in a chassis')
hmNeighbourAgentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 6, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmNeighbourSlot"))
if mibBuilder.loadTexts: hmNeighbourAgentEntry.setStatus('current')
if mibBuilder.loadTexts: hmNeighbourAgentEntry.setDescription('The entry of the hmNeighbourAgentTable.')
hmNeighbourSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNeighbourSlot.setStatus('current')
if mibBuilder.loadTexts: hmNeighbourSlot.setDescription('An index that uniquely identifies an agent by the\r\n\t\t\t\t  slot in the chassis.')
hmNeighbourIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNeighbourIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmNeighbourIpAddress.setDescription('The IP Address of the agent.')
hmAuthGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 7))
hmAuthHostTableEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAuthHostTableEntriesMax.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostTableEntriesMax.setDescription('The maximum possible number of entries in the hmAuthHostTable.\r\n\t\t\t This value equates to the total number of trusted Hosts which\r\n\t\t\t potentially may be recognized.')
hmAuthCommTableEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAuthCommTableEntriesMax.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommTableEntriesMax.setDescription('The maximum possible number of entries in the hmAuthCommTable.\r\n\t\t\t This value equates to the total number of communities which\r\n\t\t\t ly may be recognized.')
hmAuthCommTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3), )
if mibBuilder.loadTexts: hmAuthCommTable.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommTable.setDescription('A list of valid SNMP Community Entries.')
hmAuthCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAuthCommIndex"))
if mibBuilder.loadTexts: hmAuthCommEntry.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommEntry.setDescription('A list of SNMP Community properties.')
hmAuthCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAuthCommIndex.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommIndex.setDescription('An index that uniquely identifies an ordered entry in the\r\n\t\t\t   SNMP Community Table.')
hmAuthCommName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthCommName.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommName.setDescription('The name of this SNMP Community Entry, e.g. public.\r\n               This object can only be written.')
hmAuthCommPerm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("perm-ro", 1), ("perm-rw", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthCommPerm.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommPerm.setDescription('The Read/Write (GET/SET) permission for the community. A (1)\r\n\t\t\t   indicates perm-ro (GET) permission. A (2) indicates perm-wr\r\n\t\t\t   (GET/SET) permission.')
hmAuthCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthCommState.setStatus('current')
if mibBuilder.loadTexts: hmAuthCommState.setDescription('The state of this community entry.  Enable (1) defines an entry\r\n\t\t\t   that is valid.  Disable (2) defines an entry that is valid but\r\n\t\t\t   not enabled.  Delete (3) removes an entry from the table.\r\n\t\t\t   Invalid (4) defines an entry that is no longer valid (e.g., an\r\n\t\t\t   entry that was deleted) and should be ignored. An attempt to set\r\n\t\t\t   a value of invalid (4) causes the agent to return SNMP_BADVALUE.')
hmAuthHostTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4), )
if mibBuilder.loadTexts: hmAuthHostTable.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostTable.setDescription('A list of valid SNMP Trusted Host Entries.')
hmAuthHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAuthHostIndex"))
if mibBuilder.loadTexts: hmAuthHostEntry.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostEntry.setDescription('A list of SNMP Host properties.')
hmAuthHostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAuthHostIndex.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostIndex.setDescription('An index that uniquely identifies an ordered entry in\r\n\t\t\t   the SNMP Trusted Host Table.')
hmAuthHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthHostName.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostName.setDescription('The name of this SNMP Trusted Host Entry, e.g. host1.')
hmAuthHostCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthHostCommIndex.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostCommIndex.setDescription("The index of this SNMP Trusted Host Entry's community entry in\r\n\t\t\t   the hmAuthCommTable.")
hmAuthHostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthHostIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostIpAddress.setDescription("The IP Address for the host. This identified host has\r\n\t\t\t   permission to access information in this device's MIB tables,\r\n\t\t\t   providing the SNMP security toggle is on (see hmMiscSNMPSecurity).")
hmAuthHostIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthHostIpMask.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostIpMask.setDescription('The Network Mask for the trusted Host entry.')
hmAuthHostState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 7, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAuthHostState.setStatus('current')
if mibBuilder.loadTexts: hmAuthHostState.setDescription('The state of this trusted host entry. Enable (1) defines an\r\n\t\t\t   entry that is valid. Disable (2) defines an entry that is\r\n\t\t\t   valid but not enabled. Delete (3) removes an entry from the\r\n\t\t\t   table. Invalid (4) defines an entry that is no longer valid\r\n\t\t\t   (e.g., an entry that was deleted) and should be ignored.  An\r\n\t\t\t   attempt to set a value of invalid (4) causes the agent to\r\n\t\t\t   return SNMP_BADVALUE.')
hmTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 8))
hmTrapCommTableEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrapCommTableEntriesMax.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommTableEntriesMax.setDescription('The total number of entries in the hmTrapCommTable. This value\r\n\t\t\t   equates to the total number of communities which potentially can\r\n\t\t\t   be recognized.')
hmTrapDestTableEntriesMax = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrapDestTableEntriesMax.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestTableEntriesMax.setDescription('The total number of entries in the hmTrapDestTable. This\r\n\t\t\t   equates to the total number of hosts which can potentially\r\n\t\t\t   be sent SNMP traps.')
hmTrapCommTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3), )
if mibBuilder.loadTexts: hmTrapCommTable.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommTable.setDescription('A list of valid SNMP Community Entries used for Traps.')
hmTrapCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmTrapCommIndex"))
if mibBuilder.loadTexts: hmTrapCommEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommEntry.setDescription('A list of SNMP Trap Community properties.')
hmTrapCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrapCommIndex.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommIndex.setDescription('An index that uniquely identifies an ordered entry in\r\n\t\t\t   the SNMP Community Trap Table.')
hmTrapCommCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommCommIndex.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommCommIndex.setDescription('The communities entry index of this SNMP Trap Community Entry.')
hmTrapCommColdStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommColdStart.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommColdStart.setDescription('Enable (1) or Disable (2) the SNMP ColdStart Trap for this\r\n\t\t\t   SNMP community.')
hmTrapCommLinkDown = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommLinkDown.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommLinkDown.setDescription('Enable (1) or Disable (2) the SNMP Link Down traps for this\r\n\t\t\t   SNMP community.')
hmTrapCommLinkUp = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommLinkUp.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommLinkUp.setDescription('Enable (1) or Disable (2) the SNMP Link Up traps for this\r\n\t\t\t   SNMP community.')
hmTrapCommAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommAuthentication.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommAuthentication.setDescription('Enable (1) or Disable (2) the SNMP Authentication traps for\r\n\t\t\t   this SNMP community.')
hmTrapCommBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommBridge.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommBridge.setDescription('Enable (1) or Disable (2) the SNMP Bridge MIB traps for this\r\n\t\t\t   SNMP community.\r\n\t\t\t   Available Traps:\r\n\t\t\t   newRoot\t\t(MACH)\r\n\t\t\t   topologyChange\t(MACH)')
hmTrapCommRMON = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommRMON.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommRMON.setDescription('Enable (1) or Disable (2) the SNMP RMON traps for this SNMP\r\n\t\t\t   community.\r\n\t\t\t   Available Traps:\r\n\t\t\t   risingAlarm\t(MACH, MICE, RS2)\r\n\t\t\t   fallingAlarm (MACH, MICE, RS2)')
hmTrapCommUsergroup = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommUsergroup.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommUsergroup.setDescription('Enable (1) or Disable (2) the SNMP Enterprise usergroup traps\r\n\t\t\t   for this SNMP community.\r\n\t\t\t   Available Traps:\r\n\t\t\t   hmNewUserTrap\t\t(MACH)\r\n\t\t\t   hmPortSecurityTrap\t\t(MACH, MICE, RS2)\r\n\t\t\t   hmPortSecConfigErrorTrap\t(MACH)')
hmTrapCommDualHoming = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommDualHoming.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommDualHoming.setDescription('Enable (1) or Disable (2) the SNMP Enterprise dual homing traps\r\n\t\t\t   for this SNMP community.\r\n\t\t\t   Available Traps:\r\n\t\t\t   hmDuHmReconfig\t(MACH)\r\n\t\t\t   hmDuHmRedundancy\t(MACH)\r\n\t\t\t   hmRingRedReconfig\t(MACH, MICE)')
hmTrapCommChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommChassis.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommChassis.setDescription('Enable (1) or Disable (2) the SNMP Enterprise chassis traps\r\n\t\t\t   for this SNMP community.\r\n\t\t\t   Available Traps:\r\n\t\t\t   hmGroupMapChange\t\t(MACH)\r\n\t\t\t   hmPowerSupply\t\t(MACH, MICE, RS2)\r\n\t\t\t   hmFan\t\t\t(MACH)\r\n\t\t\t   hmSignallingRelay\t\t(MICE, RS2)\r\n\t\t\t   hmStandby\t\t\t(MACH, MICE, RS2)\r\n\t\t\t   hmSelfTestError\t\t(MACH)\r\n\t\t\t   hmModuleMapChange\t\t(MICE)\r\n\t\t\t   hmTemperature\t\t(MACH)\r\n\t\t\t   hmLoginTrap\t\t\t(MACH)\r\n\t\t\t   hmDuplicateStaticAddressTrap\t(MACH)')
hmTrapCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapCommState.setStatus('current')
if mibBuilder.loadTexts: hmTrapCommState.setDescription('The state of this community entry. Enable (1) defines an entry\r\n\t\t\t   that is valid.  Disable (2) defines an entry that is valid but\r\n\t\t\t   not enabled.  Delete (3) removes an entry from the table.\r\n\t\t\t   Invalid (4) defines an entry that is no longer valid (e.g.,\r\n\t\t\t   an entry that was deleted) and should be ignored.  An attempt\r\n\t\t\t   to set a value of invalid (4) causes the agent to return\r\n\t\t\t   SNMP_BADVALUE.')
hmTrapDestTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4), )
if mibBuilder.loadTexts: hmTrapDestTable.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestTable.setDescription('A list of valid SNMP Trap Trusted Host Destination entries.')
hmTrapDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmTrapDestIndex"))
if mibBuilder.loadTexts: hmTrapDestEntry.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestEntry.setDescription('A list of SNMP Trap Trusted Host Destination properties.')
hmTrapDestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmTrapDestIndex.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestIndex.setDescription('An index that uniquely identifies an ordered entry in\r\n\t\t\t   the SNMP Trusted Host Destination Table.')
hmTrapDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapDestName.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestName.setDescription('The name of this SNMP Trusted Host Destination Entry, e.g. Admin.')
hmTrapDestCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapDestCommIndex.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestCommIndex.setDescription("The communities entry index of this SNMP Trusted Host\r\n\t\t\t   Destination Entry's community.")
hmTrapDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapDestIpAddress.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestIpAddress.setDescription("The IP Address for the host. This identified host has permission\r\n\t\t\t   to access information in this device's MIB tables, providing the\r\n\t\t\t   SNMP security toggle is on (see hmMiscSNMPSecurity).")
hmTrapDestIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapDestIpMask.setStatus('obsolete')
if mibBuilder.loadTexts: hmTrapDestIpMask.setDescription('The Network Mask for the trusted Host Destination entry.')
hmTrapDestState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 8, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("delete", 3), ("invalid", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmTrapDestState.setStatus('current')
if mibBuilder.loadTexts: hmTrapDestState.setDescription('The state of this trusted trap destination entry.  Enable (1)\r\n\t\t\t   defines an entry that is valid.\tDisable (2) defines an entry\r\n\t\t\t   that is valid but not enabled.  Delete (3) removes an entry\r\n\t\t\t   from the table.\tInvalid (4) defines an entry that is no\r\n\t\t\t   longer valid (e.g., an entry that was deleted) and should be\r\n\t\t\t   ignored.  An attempt to set a value of invalid (4) causes the\r\n\t\t\t   agent to return SNMP_BADVALUE.')
hmLastAccessGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 9))
hmLastIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 9, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLastIpAddr.setStatus('current')
if mibBuilder.loadTexts: hmLastIpAddr.setDescription('IP Address specified in the last request.')
hmLastPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 9, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLastPort.setStatus('current')
if mibBuilder.loadTexts: hmLastPort.setDescription('UDP port specified in the last request.')
hmLastCommunity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 9, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLastCommunity.setStatus('current')
if mibBuilder.loadTexts: hmLastCommunity.setDescription('Last community string used.')
hmLastLoginUserName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 9, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmLastLoginUserName.setStatus('current')
if mibBuilder.loadTexts: hmLastLoginUserName.setDescription('Last login user name used.')
hmMulticast = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10))
hmIGMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1))
hmIGMPSnoop = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2))
hmIGMPSnoopStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopStatus.setDescription('Enables/disables IGMP Snooping on this device.\r\n    The default value is disable.')
hmIGMPSnoopAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopAgingTime.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopAgingTime.setDescription('The timeout period in seconds for aging out Multicast Groups\r\n    dynamically learned with IGMP Snooping.  Note that aging operates\r\n    on a per interface per multicast group basis.\r\n    This interval is also used to age out ports that have received\r\n    IGMP Router Query PDUs.\r\n    The default is 260 seconds and the range is 3 to 3600 seconds.')
hmIGMPSnoopUnknownMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("flood", 2), ("query-ports", 3))).clone('flood')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopUnknownMode.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopUnknownMode.setDescription('Sets the mode how unknown Multicast packets \r\n     will be treated.\r\n     The default value is flood(2).')
hmIGMPSnoopUnknownAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 3600)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopUnknownAgingTime.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopUnknownAgingTime.setDescription('The timeout period in seconds approximately for aging out Unknown Multicast Groups\r\n     dynamically learned with traffic snooping. The exactly value is\r\n     UnknownLookupInterval/(UnknownLookupInterval-UnknownLookupResponseTime)*UnknownAgingTime.\r\n     Note that aging operates on a per unknown multicast group basis.\r\n     The default is 260 seconds and the range is 3 to 3600 seconds.')
hmIGMPSnoopUnknownLookupInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 3599)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopUnknownLookupInterval.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopUnknownLookupInterval.setDescription('The frequency at which Unknown Multicast Groups\r\n     dynamically learned with traffic snooping are\r\n     traffic checked by the switch in seconds.\r\n     So this is the time between periodic traffic checking\r\n     in which unknown multicast groups being aged on the switch\r\n     when it is acting as Trafficsnooper.\r\n     Large values lead to traffic checking less often.\r\n     The default is 125 seconds and the range is 2 to 3599 seconds.')
hmIGMPSnoopUnknownLookupResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3598)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopUnknownLookupResponseTime.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopUnknownLookupResponseTime.setDescription('The unknown lookup response time in seconds in which Unknown Multicast Groups\r\n     dynamically learned with traffic snooping are traffic checked.\r\n     So this is the time in which response traffic to the Trafficsnooper allowing\r\n     the update of unknown multicast group aging timer.\r\n     This variable enables the checking of bursty unknown multicast traffic.\r\n     Small values lead to bad traffic checking but few snooper load and\r\n     large values lead to good traffic checking but more snooper load.\r\n     The default is 10 seconds and the range is 1 to 3598 seconds.')
hmIGMPSnoopQuerierToPortmask = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopQuerierToPortmask.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQuerierToPortmask.setDescription('Enables or disables the addition of query ports \r\n    to multicast filter portmasks.')
hmIGMPSnoopQuerierIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIGMPSnoopQuerierIPAddress.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQuerierIPAddress.setDescription('Shows the IP address of the active querier.')
hmIGMPSnoopQueryTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 10), )
if mibBuilder.loadTexts: hmIGMPSnoopQueryTable.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryTable.setDescription('A table displaying the IGMP Router Query PDU ports.')
hmIGMPSnoopQueryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 10, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmIGMPSnoopQueryVlanIndex"))
if mibBuilder.loadTexts: hmIGMPSnoopQueryEntry.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryEntry.setDescription('A table displaying the IGMP Router Query PDU ports.\r\n    These are maintained on a per VLAN basis.')
hmIGMPSnoopQueryVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: hmIGMPSnoopQueryVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryVlanIndex.setDescription('This is the VLAN index for which this entry is valid.\r\n\t If the switch only supports shared vlan learning (SVL),\r\n\t the value is always 1 and there is only 1 instance in \r\n\t the table.')
hmIGMPSnoopQueryPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 10, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIGMPSnoopQueryPorts.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryPorts.setDescription('This read-only object displays the set of ports that have received\r\n    IGMP Router Query PDUs for this VLAN as determined by the IGMP\r\n    Snooping task.')
hmIGMPSnoopFilterTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 11), )
if mibBuilder.loadTexts: hmIGMPSnoopFilterTable.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopFilterTable.setDescription('A table containing the multicast filtering information\r\n    on a per vlan basis learned with IGMP Snooping.')
hmIGMPSnoopFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 11, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmIGMPSnoopFilterVlanIndex"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmIGMPSnoopFilterAddress"))
if mibBuilder.loadTexts: hmIGMPSnoopFilterEntry.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopFilterEntry.setDescription('The entry of the hmIGMPSnoopFilterTable.')
hmIGMPSnoopFilterVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: hmIGMPSnoopFilterVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopFilterVlanIndex.setDescription('This is the VLAN index for which this entry is valid.\r\n\t If the switch only supports shared vlan learning (SVL),\r\n\t the value is always 1 and there is only 1 instance in \r\n\t the table.')
hmIGMPSnoopFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 11, 1, 2), MacAddress())
if mibBuilder.loadTexts: hmIGMPSnoopFilterAddress.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopFilterAddress.setDescription("The multicast destination MAC address in a frame to which\r\n    this entry's filtering information applies.")
hmIGMPSnoopFilterLearntPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 11, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIGMPSnoopFilterLearntPorts.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopFilterLearntPorts.setDescription("The set of ports, to which frames destined for this Group\r\n    MAC Address learned by IGMP Snooping are currently being\r\n    forwarded.\r\n    Each octet within the value of this object specifies\r\n    a set of eight ports, with the first octet specifying\r\n    ports 1 through 8, the second octet specifying ports 9\r\n    through 16, etc.\r\n    Within each octet, the most significant bit represents\r\n    the lowest numbered port, and the least significant bit\r\n    represents the highest numbered port.\r\n    Thus, each port of the bridge is represented by a single\r\n    bit within the value of this object.\r\n    If that bit has a value of '1' then that port is included\r\n    in the set of ports; the port is not included if its bit\r\n    has a value of '0'.\r\n    (Note that the setting of the bit corresponding to the port\r\n    from which a frame is received is irrelevant.)")
hmIGMPSnoopForwardAllTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 12), )
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllTable.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllTable.setDescription('A table containing forwarding information for each\r\n    VLAN, specifying the set of ports to which forwarding of\r\n    all multicasts applies, configured statically by\r\n    management.\r\n    An entry appears in this table for all VLANs that are currently\r\n    instantiated.')
hmIGMPSnoopForwardAllEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 12, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmIGMPSnoopForwardAllVlanIndex"))
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllEntry.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllEntry.setDescription('Forwarding information for a VLAN, specifying the set\r\n    of ports to which all multicasts should be forwarded,\r\n    configured statically by management.')
hmIGMPSnoopForwardAllVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllVlanIndex.setDescription('This is the VLAN index for which this entry is valid.\r\n\t If the switch only supports shared vlan learning (SVL),\r\n\t the value is always 1 and there is only 1 instance in \r\n\t the table.')
hmIGMPSnoopForwardAllStaticPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 12, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllStaticPorts.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopForwardAllStaticPorts.setDescription('The set of ports configured by management in this VLAN\r\n    to which all multicast group-addressed frames learned by\r\n    IGMP are to be forwarded. \r\n    This value will be restored after the device is reset.')
hmIGMPSnoopQueryStaticTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13), )
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticTable.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticTable.setDescription('A table displaying the IGMP Static Query ports.')
hmIGMPSnoopQueryStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmIGMPSnoopQueryStaticVlanIndex"))
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticEntry.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticEntry.setDescription('The entry of the hmIGMPSnoopQueryStaticTable.')
hmIGMPSnoopQueryStaticVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticVlanIndex.setDescription('This is the VLAN index for which this entry is valid.\r\n\t If the switch only supports shared vlan learning (SVL),\r\n\t the value is always 1 and there is only 1 instance in \r\n\t the table.')
hmIGMPSnoopQueryStaticPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticPorts.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticPorts.setDescription('The set of ports explicitly configured by management to\r\n     be IGMP-forwarding ports.')
hmIGMPSnoopQueryStaticAutomaticPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticAutomaticPorts.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticAutomaticPorts.setDescription('The set of ports that are automatically learned by LLDP protocol to\r\n     be IGMP-forwarding ports.')
hmIGMPSnoopQueryStaticAutomaticPortsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 13, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticAutomaticPortsEnable.setStatus('current')
if mibBuilder.loadTexts: hmIGMPSnoopQueryStaticAutomaticPortsEnable.setDescription('The set of ports that are allowed to be learned automatically by LLDP protocol to\r\n     be IGMP-forwarding ports.')
hmIGMPQuerierGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100))
hmIGMPQuerierStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPQuerierStatus.setStatus('current')
if mibBuilder.loadTexts: hmIGMPQuerierStatus.setDescription('Enables/disables IGMP Querier on this device.\r\n    IGMP queries are only sent when hmIGMPSnoopStatus is also set.\r\n    The default value is disable.')
hmIGMPQuerierMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("querier", 1), ("non-querier", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmIGMPQuerierMode.setStatus('current')
if mibBuilder.loadTexts: hmIGMPQuerierMode.setDescription('Shows the current mode of the IGMP Querier.')
hmIGMPQuerierTransmitInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 3599)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPQuerierTransmitInterval.setStatus('current')
if mibBuilder.loadTexts: hmIGMPQuerierTransmitInterval.setDescription('The frequency at which IGMP general query packets are\r\n    transmitted by the querying switch in seconds.\r\n    So this is the time between general periodic queries being\r\n    sent out of the switch when it is acting as the IGMP querier.\r\n    Large values lead to IGMP queries being sent less often.\r\n    The default is 125 seconds and the range is 2 to 3599 seconds.\r\n    Note: The following dependency is needed: Max. Response Time < Querier Transmit Interval < Group Membership Interval.')
hmIGMPQuerierMaxResponseTime = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3598)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPQuerierMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: hmIGMPQuerierMaxResponseTime.setDescription('The maximum query response time in seconds advertised in IGMP v2\r\n    queries on this VLAN if the switch is the querier. Smaller values\r\n    allow a switch to prune groups faster. So it is the maximum response\r\n    time inserted into the general periodic queries. This variable \r\n    enables the tuning of the burstiness of the IGMP traffic.\r\n    If it is increased the responses have a larger time span in which\r\n    to be generated by the hosts.\r\n    The default is 10 seconds and the range is 1 to 3598 seconds.')
hmIGMPQuerierProtocolVersion = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 1, 2, 100, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIGMPQuerierProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: hmIGMPQuerierProtocolVersion.setDescription('The Querier protocol version.\r\n    The default is version 2.')
hmGMRPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 2))
hmGMRP = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 2, 1))
hmGmrpUnknownMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("flood", 2))).clone('flood')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmGmrpUnknownMode.setStatus('current')
if mibBuilder.loadTexts: hmGmrpUnknownMode.setDescription('Sets the mode how unknown multicast packets will be treated.\r\n     The default value is flood(2).')
hmRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 11))
hmRelayOption82Status = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayOption82Status.setStatus('current')
if mibBuilder.loadTexts: hmRelayOption82Status.setDescription('Enables/disables the DHCP Option 82 defined in RFC 3046\r\n\t\t     on this device.')
hmRelayOptionRemoteIDType = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2), ("client-id", 3), ("other", 4))).clone('mac')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayOptionRemoteIDType.setStatus('current')
if mibBuilder.loadTexts: hmRelayOptionRemoteIDType.setDescription("This option determines the content of the Agent Remote ID (sub-option 2).\r\n\t\t\t ip(1) inserts the ip address of the relay's mgmt-interface \r\n\t\t\t and encodes it with sub option type A1.\r\n\t\t\t mac(2) inserts the mac adress of the relay's mgmt-interface\r\n\t\t\t and encodes it with sub option type 00.\r\n \t\t\t client-id(3) inserts the client identifier (sysName) of the relay's mgmt-interface\r\n\t\t\t and encodes it with sub option type A2.\r\n \t\t\t other(4) inserts the value in hmRelayOptionRemoteIDValue\r\n\t\t\t and encodes it with sub option type A3.")
hmRelayOptionRemoteID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayOptionRemoteID.setStatus('current')
if mibBuilder.loadTexts: hmRelayOptionRemoteID.setDescription('Displays the actual content of the Remote ID sub option for this relay agent.\r\n\t\t\t\t The value is encoded in TLV (Type-Length-Value) format. \r\n\t\t\t\t The following type values are currently defined:\r\n\t\t\t\t 00 = mac adress\r\n\t\t\t\t A1 = ip address\r\n\t\t\t\t A2 = client identifier\r\n\t\t\t     A3 = string in hmRelayOptionRemoteIDValue')
hmRelayOptionRemoteIDValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayOptionRemoteIDValue.setStatus('current')
if mibBuilder.loadTexts: hmRelayOptionRemoteIDValue.setDescription('Contains an octet string to be used as value for \r\n\t\t\t\t  Agent Remote ID Sub-option type A3')
hmRelayServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 10))
hmRelayDHCPServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 10, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayDHCPServerIpAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hmRelayDHCPServerIpAddr.setDescription("This object is 'obsolete' and is replaced by hmRelayServerAddrEntry.\r\n             The IP address of the first DHCP-server to be addressed \r\n\t\t     by the relay agent.\r\n             If 0.0.0.0, DHCP relaying is switched off for this entry.")
hmRelayDHCPServer2IpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 10, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayDHCPServer2IpAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hmRelayDHCPServer2IpAddr.setDescription("This object is 'obsolete' and is replaced by hmRelayServerAddrEntry.\r\n             The IP address of the second DHCP-server to be addressed\r\n\t\t     by the relay agent.\r\n             If 0.0.0.0, DHCP relaying is switched off for this entry.")
hmRelayDHCPServer3IpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 10, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayDHCPServer3IpAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hmRelayDHCPServer3IpAddr.setDescription("This object is 'obsolete' and is replaced by hmRelayServerAddrEntry.\r\n             The IP address of the third DHCP-server to be addressed\r\n\t\t     by the relay agent.\r\n             If 0.0.0.0, DHCP relaying is switched off for this entry.")
hmRelayDHCPServer4IpAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 10, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayDHCPServer4IpAddr.setStatus('obsolete')
if mibBuilder.loadTexts: hmRelayDHCPServer4IpAddr.setDescription("This object is 'obsolete' and is replaced by hmRelayServerAddrEntry.\r\n             The IP address of the fourth DHCP-server to be addressed \r\n\t\t     by the relay agent.\r\n             If 0.0.0.0, DHCP relaying is switched off for this entry.")
hmRelayInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11), )
if mibBuilder.loadTexts: hmRelayInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmRelayInterfaceTable.setDescription('This table contains variables for each interface of\r\n\t\t\t the switch.')
hmRelayInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmRelayIfaceGroupID"), (0, "HMPRIV-MGMT-SNMP-MIB", "hmRelayIfaceID"))
if mibBuilder.loadTexts: hmRelayInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmRelayInterfaceEntry.setDescription('The entry of the hmRelayInterfaceTable.')
hmRelayIfaceGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayIfaceGroupID.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceGroupID.setDescription('index to identify an interface card. This value is never\r\n\t\t\t greater than hmSysGroupCapacity.')
hmRelayIfaceID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayIfaceID.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceID.setDescription('index to identify an interface within an interface card.')
hmRelayIfaceOption82Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayIfaceOption82Enable.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceOption82Enable.setDescription('Enable or disable DHCP Option 82 on this physical port.')
hmRelayIfaceBCRequestFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("discard", 2))).clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayIfaceBCRequestFwd.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceBCRequestFwd.setDescription('Enable or disable relaying of incoming broadcasted \r\n                BOOTP/DHCP request packets on this physical port. \r\n                Hirschmann Multicast BOOTP/DHCP requests will always be relayed.')
hmRelayIfaceCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayIfaceCircuitID.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceCircuitID.setDescription('Contains the actual Circuit ID sub option for this interface of the relay agent.\r\n\t\t\t\t It is a best guess value, since some information is not known \r\n\t\t\t\t before the actual reception of a BOOTP/DHCP request message.')
hmRelayIfaceDhcpRelayAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmRelayIfaceDhcpRelayAdminState.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceDhcpRelayAdminState.setDescription('Enable or disable DHCP Relay Agent on this physical port.')
hmRelayIfaceDhcpRelayOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disable", 1), ("relay", 2), ("server", 3))).clone('disable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayIfaceDhcpRelayOperState.setStatus('current')
if mibBuilder.loadTexts: hmRelayIfaceDhcpRelayOperState.setDescription('Current active DHCP protocol on this physical port.')
hmRelayServerAddrTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12), )
if mibBuilder.loadTexts: hmRelayServerAddrTable.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerAddrTable.setDescription('This table contains objects to configure\r\n         DHCP Servers.')
hmRelayServerAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmRelayServerAddrIndex"))
if mibBuilder.loadTexts: hmRelayServerAddrEntry.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerAddrEntry.setDescription('The DHCP Server objects.')
hmRelayServerAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: hmRelayServerAddrIndex.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerAddrIndex.setDescription('Index for server table.')
hmRelayServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmRelayServerAddr.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerAddr.setDescription('The address of the external DHCP server.')
hmRelayServerInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmRelayServerInterface.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerInterface.setDescription('If an Interface is set, only DHCP packets from this interface are relayed to the server.')
hmRelayServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 12, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hmRelayServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: hmRelayServerRowStatus.setDescription("Indicates the status of an entry in this table,\r\n         and is used to create/delete entries. Objects\r\n         within this table can by changed while the status\r\n         is 'active'.")
hmRelayBCPktInCnt = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayBCPktInCnt.setStatus('current')
if mibBuilder.loadTexts: hmRelayBCPktInCnt.setDescription('The number of BOOTP/DHCP broadcast request packets received\r\n\t\t\t by the relay agent.')
hmRelayMCPktInCnt = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayMCPktInCnt.setStatus('current')
if mibBuilder.loadTexts: hmRelayMCPktInCnt.setDescription('The number of BOOTP/DHCP multicast request packets received\r\n\t\t\t by the relay agent.')
hmRelayPktServerRelayCnt = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayPktServerRelayCnt.setStatus('current')
if mibBuilder.loadTexts: hmRelayPktServerRelayCnt.setDescription('The number of BOOTP/DHCP requests relayed to the DHCP Server.')
hmRelayPktClientRelayCnt = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayPktClientRelayCnt.setStatus('current')
if mibBuilder.loadTexts: hmRelayPktClientRelayCnt.setDescription('The number of BOOTP/DHCP replies relayed to the Client.')
hmRelayErrCnt = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayErrCnt.setStatus('current')
if mibBuilder.loadTexts: hmRelayErrCnt.setDescription('The number of errors encountered within the relay agent.')
hmRelayLastDuplicateIP = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 11, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmRelayLastDuplicateIP.setStatus('current')
if mibBuilder.loadTexts: hmRelayLastDuplicateIP.setDescription('The last duplicate ip address encounterd by the relay agent.')
hmDeviceMonitoringGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 12))
hmSigConConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1), )
if mibBuilder.loadTexts: hmSigConConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmSigConConfigTable.setDescription('This table contains all variables to configure the behaviour\r\n\t\t\t\t of the signalling contacts.')
hmSigConConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSigConID"))
if mibBuilder.loadTexts: hmSigConConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmSigConConfigEntry.setDescription('The entry of the hmSigConConfigTable.')
hmSigConID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigConID.setStatus('current')
if mibBuilder.loadTexts: hmSigConID.setDescription('This index is used to identify the associated \r\n\t\t\t\t  signalling contact.')
hmSigConTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hmSigConTrapEnable.setDescription('Determines wether a trap shall be sent or not, when\r\n\t\t\t\t  the signal contact operating state changes.')
hmSigConTrapCause = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("linkFailure", 2), ("controlLine", 3), ("redNotGuaranteed", 4), ("psState", 5), ("temperature", 6), ("moduleRemoval", 7), ("acaRemoval", 8), ("fanFailure", 9), ("acaNotInSync", 10), ("sRedNotGuaranteed", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigConTrapCause.setStatus('current')
if mibBuilder.loadTexts: hmSigConTrapCause.setDescription('This object identifies the cause for a trap. \r\n\t\t\t\t The index of the entity which produces the trap\r\n\t\t\t\t is specified by hmSigConTrapCauseIndex.')
hmSigConTrapCauseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigConTrapCauseIndex.setStatus('current')
if mibBuilder.loadTexts: hmSigConTrapCauseIndex.setDescription('This attribute specifies the entity which produces the trap.\r\n\t\t\t\t\t 1 - n: index of powersupply table / interfaces table\r\n\t\t\t\t\t 0: other errors')
hmSigConMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("monitor", 2), ("devicestate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConMode.setStatus('current')
if mibBuilder.loadTexts: hmSigConMode.setDescription('This attribute specifies the behaviour of the relay contact.\r\n\t\t\t\t  The factory settings for signal contact 1 is monitoring the\r\n\t\t\t\t  correct operation of entries specified to be survied.\r\n\t\t\t\t  When the device has also a second signal contact, the factory \r\n\t\t\t\t  setting for it is the manual mode.')
hmSigConManualActivate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("close", 1), ("open", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConManualActivate.setStatus('current')
if mibBuilder.loadTexts: hmSigConManualActivate.setDescription('When operating in manual mode, the signal contact state can\r\n\t\t\t\t  be set by this attribute.')
hmSigConOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("open", 1), ("close", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigConOperState.setStatus('current')
if mibBuilder.loadTexts: hmSigConOperState.setDescription('This attribute shows the current operating state of the\r\n\t\t\t\t  signal contact.')
hmSigConSenseLinkFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseLinkFailure.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseLinkFailure.setDescription('Sets the monitoring of the network connection(s).')
hmSigConSenseControlLine = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseControlLine.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseControlLine.setDescription('Sets the monitoring of the ring/network coupling.')
hmSigConSenseRedNotGuaranteed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseRedNotGuaranteed.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseRedNotGuaranteed.setDescription('Sets the monitoring of the HIPER-Ring, MRP-Ring or Fast HIPER-Ring.')
hmSigConSensePS1State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS1State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS1State.setDescription('Sets the monitoring of the power supply 1.')
hmSigConSensePS2State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS2State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS2State.setDescription('Sets the monitoring of the power supply 2.')
hmSigConSenseTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseTemperature.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseTemperature.setDescription('Sets the monitoring of the device temperature.')
hmSigConSenseModuleRemoval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseModuleRemoval.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseModuleRemoval.setDescription('Sets the monitoring of module removal (platform dependant).')
hmSigConSenseACARemoval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseACARemoval.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseACARemoval.setDescription('Sets the monitoring of the auto configuration adapter removal.')
hmSigConSensePS3State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS3State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS3State.setDescription('Sets the monitoring of the power supply 3 (platform dependant).')
hmSigConSensePS4State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS4State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS4State.setDescription('Sets the monitoring of the power supply 4 (platform dependant).')
hmSigConSenseFan1State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseFan1State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseFan1State.setDescription('Sets the monitoring of the cooling fan (platform dependant).')
hmSigConSensePS5State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS5State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS5State.setDescription('Sets the monitoring of the power supply 5 (platform dependant).')
hmSigConSensePS6State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS6State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS6State.setDescription('Sets the monitoring of the power supply 6 (platform dependant).')
hmSigConSensePS7State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS7State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS7State.setDescription('Sets the monitoring of the power supply 7 (platform dependant).')
hmSigConSensePS8State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSensePS8State.setStatus('current')
if mibBuilder.loadTexts: hmSigConSensePS8State.setDescription('Sets the monitoring of the power supply 8 (platform dependant).')
hmSigConSenseACANotInSync = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseACANotInSync.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseACANotInSync.setDescription('Sets the monitoring whether the configuration on ACA is in\r\n\t\t\t sync with the configuration in NVRAM.')
hmSigConSenseSRedNotGuaranteed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConSenseSRedNotGuaranteed.setStatus('current')
if mibBuilder.loadTexts: hmSigConSenseSRedNotGuaranteed.setDescription('Sets the monitoring of sub-rings if configured and activated on the device.')
hmSigConLinkTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 2), )
if mibBuilder.loadTexts: hmSigConLinkTable.setStatus('current')
if mibBuilder.loadTexts: hmSigConLinkTable.setDescription('This table contains all variables to mask an alarm for the\r\n\t\t\t\t signalling relay, produced by a link. The index for a link\r\n\t\t\t\t corresponds with ifMauIfIndex. The table is also used\r\n\t\t\t\t for the device monitoring configuration.')
hmSigConLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmSigConLinkID"))
if mibBuilder.loadTexts: hmSigConLinkEntry.setStatus('current')
if mibBuilder.loadTexts: hmSigConLinkEntry.setDescription('The entry of the hmSigConLinkTable.')
hmSigConLinkID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmSigConLinkID.setStatus('current')
if mibBuilder.loadTexts: hmSigConLinkID.setDescription('This index is used to identify the associated link and\r\n\t\t\t\t corresponds with ifMauIfIndex.')
hmSigConLinkAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmSigConLinkAlarm.setStatus('current')
if mibBuilder.loadTexts: hmSigConLinkAlarm.setDescription('Indicates whether an alarm for the signalling relay of the\r\n                 associated link will be produced or not, so you can mask the\r\n                 value of ifMauMediaAvailable.')
hmDevMonConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3), )
if mibBuilder.loadTexts: hmDevMonConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmDevMonConfigTable.setDescription('This table contains all variables to configure the behaviour\r\n\t\t\t\t of the device state.')
hmDevMonConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmDevMonID"))
if mibBuilder.loadTexts: hmDevMonConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmDevMonConfigEntry.setDescription('Configuration of the device monitoring.')
hmDevMonID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDevMonID.setStatus('current')
if mibBuilder.loadTexts: hmDevMonID.setDescription('This index is used to identify the associated \r\n\t\t\t\t  device status (currently only one).')
hmDevMonTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonTrapEnable.setStatus('current')
if mibBuilder.loadTexts: hmDevMonTrapEnable.setDescription('Determines wether a trap shall be sent or not, when\r\n\t\t\t\t  the device monitoring state changes.')
hmDevMonTrapCause = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("other", 1), ("linkFailure", 2), ("controlLine", 3), ("redNotGuaranteed", 4), ("psState", 5), ("temperature", 6), ("moduleRemoval", 7), ("acaRemoval", 8), ("fanFailure", 9), ("acaNotInSync", 10), ("sRedNotGuaranteed", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDevMonTrapCause.setStatus('current')
if mibBuilder.loadTexts: hmDevMonTrapCause.setDescription('This object identifies the cause for a trap. \r\n\t\t\t\t The index of the entity which produces the trap\r\n\t\t\t\t is specified by hmDevMonTrapCauseIndex.')
hmDevMonTrapCauseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDevMonTrapCauseIndex.setStatus('current')
if mibBuilder.loadTexts: hmDevMonTrapCauseIndex.setDescription('This attribute specifies the entity which produces the trap.\r\n\t\t\t\t\t 1 - n: index of powersupply table / interfaces table\r\n\t\t\t\t\t 0: other errors')
hmDevMonSwitchState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("noerror", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmDevMonSwitchState.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSwitchState.setDescription('This attribute shows the current state of the\r\n\t\t\t\t  device monitoring.')
hmDevMonSenseLinkFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseLinkFailure.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseLinkFailure.setDescription('Sets the monitoring of the network connection(s).')
hmDevMonSenseControlLine = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseControlLine.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseControlLine.setDescription('Sets the monitoring of the ring/network coupling.')
hmDevMonSenseRedNotGuaranteed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseRedNotGuaranteed.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseRedNotGuaranteed.setDescription('Sets the monitoring of the HIPER-Ring, MRP-Ring or Fast HIPER-Ring.')
hmDevMonSensePS1State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS1State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS1State.setDescription('Sets the monitoring of the power supply 1.')
hmDevMonSensePS2State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS2State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS2State.setDescription('Sets the monitoring of the power supply 2.')
hmDevMonSenseTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseTemperature.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseTemperature.setDescription('Sets the monitoring of the device temperature.')
hmDevMonSenseModuleRemoval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseModuleRemoval.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseModuleRemoval.setDescription('Sets the monitoring of module removal (platform dependant).')
hmDevMonSenseACARemoval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseACARemoval.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseACARemoval.setDescription('Sets the monitoring of the auto configuration adapter removal.')
hmDevMonSensePS3State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS3State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS3State.setDescription('Sets the monitoring of the power supply 3 (platform dependant).')
hmDevMonSensePS4State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS4State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS4State.setDescription('Sets the monitoring of the power supply 4 (platform dependant).')
hmDevMonSenseFan1State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseFan1State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseFan1State.setDescription('Sets the monitoring of the cooling fan (platform dependant).')
hmDevMonSensePS5State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS5State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS5State.setDescription('Sets the monitoring of the power supply 5 (platform dependant).')
hmDevMonSensePS6State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS6State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS6State.setDescription('Sets the monitoring of the power supply 6 (platform dependant).')
hmDevMonSensePS7State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS7State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS7State.setDescription('Sets the monitoring of the power supply 7 (platform dependant).')
hmDevMonSensePS8State = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSensePS8State.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSensePS8State.setDescription('Sets the monitoring of the power supply 8 (platform dependant).')
hmDevMonSenseACANotInSync = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseACANotInSync.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseACANotInSync.setDescription('Sets the monitoring whether the configuration on ACA is in sync with the configuration in NVRAM.')
hmDevMonSenseSRedNotGuaranteed = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 12, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("error", 1), ("ignore", 2))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmDevMonSenseSRedNotGuaranteed.setStatus('current')
if mibBuilder.loadTexts: hmDevMonSenseSRedNotGuaranteed.setDescription('Sets the monitoring of sub-rings if configured and activated on the device.')
hmAgentSnmpConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 13))
hmAgentSnmpCommunityCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityCreate.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityCreate.setDescription('Creates a new SNMP Community entry.\r\n                     Defaults: IPAddress  0.0.0.0\r\n                               IpMask     0.0.0.0\r\n                               AccessMode read-only\r\n                               Status     config')
hmAgentSnmpCommunityConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2), )
if mibBuilder.loadTexts: hmAgentSnmpCommunityConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityConfigTable.setDescription("A table of the switch's SNMP Config entries")
hmAgentSnmpCommunityConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAgentSnmpCommunityIndex"))
if mibBuilder.loadTexts: hmAgentSnmpCommunityConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityConfigEntry.setDescription("Switch's SNMP Config entry")
hmAgentSnmpCommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSnmpCommunityIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityIndex.setDescription("The switch's Snmp Community Index")
hmAgentSnmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityName.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityName.setDescription("The switch's Snmp Community Name\r\n                     This name identifies each SNMP community; \r\n                     the name can be up to 32 characters, and it is case-sensitive.\r\n                     Community names in the SNMP community must be unique. \r\n                     If you make multiple entries using the same community name, \r\n                     the first entry is kept and processed and all duplicate entries are ignored. \r\n                     ")
hmAgentSnmpCommunityIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityIPAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityIPAddress.setDescription("The switch's Snmp Community IP Address\r\n                     Client IP Address - This attribute is an IP address (or portion thereof) \r\n                     from which this device will accept SNMP packets with the associated \r\n                     community. The requesting entity's IP address is logical-ANDed with \r\n                     the Client IP Mask and the result must match the Client IP Address. \r\n                     Note: If the Client IP Mask is set \r\n                     to 0.0.0.0, a Client IP Address of 0.0.0.0 matches all IP addresses.  \r\n                     ")
hmAgentSnmpCommunityIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityIPMask.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityIPMask.setDescription("The switch's Snmp Community IP Mask\r\n                     Client IP Mask - This attribute is a mask to be logical-ANDed with the\r\n                     requesting entity's IP address before comparison with the Client IP Address. \r\n                     If the result matches with Client IP Address then the address is an \r\n                     authenticated IP address. For example, if the Client IP Address \r\n                     is 9.47.128.0 and the corresponding Client IP Mask is 255.255.255.0, \r\n                     a range of incoming IP addresses would match, that is, the incoming IP \r\n                     addresses could be a value in the following range: 9.47.128.0 to 9.47.128.255.\r\n                     To have a specific IP address be the only authenticated IP address, set the \r\n                     Client IP Address to the required IP address and set the Client IP Mask \r\n                     to 255.255.255.255.")
hmAgentSnmpCommunityAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityAccessMode.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityAccessMode.setDescription("The switch's Snmp Community Access Mode\r\n                     Access Mode - This value can be read-only or read/write. \r\n                     A community with a read-only access allows for switch information to be\r\n                     displayed. A community with a read/write access allows for configuration \r\n                     changes to be made and for information to be displayed.\r\n                     ")
hmAgentSnmpCommunityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("config", 3), ("destroy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpCommunityStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityStatus.setDescription("The switch's Snmp Community Status.\r\n                     \r\n                     active(1)        - This community is active, allowing SNMP managers associated \r\n                                        with this community to manage the switch according to its \r\n                                        access right. \r\n                     \r\n                     notInService(2)  - This community is not active; no SNMP requests using this \r\n                                        community will be accepted. In this case the SNMP manager \r\n                                        associated with this community cannot manage the switch until \r\n                                        the Status is changed back to active(1).\r\n                                        \r\n                     config(3)        - The community Status must be set to this value in order to \r\n                                        configure it.  When creating a new community entry, initial \r\n                                        Status will be set to this value.\r\n                     \r\n                     destroy(4)       - Set to this value to remove the community from the agent.")
hmAgentSnmpLoggingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 8))
hmAgentSnmpLogGetRequest = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpLogGetRequest.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpLogGetRequest.setDescription('Enable logging of SNMP GET requests.')
hmAgentSnmpLogSetRequest = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpLogSetRequest.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpLogSetRequest.setDescription('Enable logging of SNMP SET requests.')
hmAgentSnmpLogGetSeverity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 8, 3), HmAgentLogSeverity().clone('notice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpLogGetSeverity.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpLogGetSeverity.setDescription('Define the log severity for SNMP GET requests.')
hmAgentSnmpLogSetSeverity = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 8, 4), HmAgentLogSeverity().clone('notice')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpLogSetSeverity.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpLogSetSeverity.setDescription('Define the log severity for SNMP SET requests.')
hmAgentSnmpTrapReceiverCreate = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverCreate.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverCreate.setDescription('Creates a new trap receiver entry.  \r\n                     Defaults: IPAddress 0.0.0.0\r\n                               status    config')
hmAgentSnmpTrapReceiverConfigTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4), )
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverConfigTable.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverConfigTable.setDescription('Trap messages are sent across a network to an SNMP Network Manager. \r\n                     These messages alert the manager to events occurring within the switch \r\n                     or on the network. Up to six simultaneous trap receivers are supported. \r\n                     ')
hmAgentSnmpTrapReceiverConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAgentSnmpTrapReceiverIndex"))
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverConfigEntry.setDescription("Switch's Snmp Trace Receiver Config entry")
hmAgentSnmpTrapReceiverIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverIndex.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverIndex.setDescription("The switch's Snmp Trap Receiver Index")
hmAgentSnmpTrapReceiverCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverCommunityName.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverCommunityName.setDescription("The switch's Snmp Trap Receiver Community Name.\r\n                     This is the SNMP community name of the remote network manager; \r\n                     the name can be up to 16 characters, and is case-sensitive. \r\n                     ")
hmAgentSnmpTrapReceiverIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverIPAddress.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverIPAddress.setDescription('IP Address - Each IP address parameter is four integer numbers. \r\n                     The numbers range from 0 to 255. \r\n                     ')
hmAgentSnmpTrapReceiverStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("config", 3), ("destroy", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverStatus.setDescription("The switch's Snmp Trap Reciever Status.\r\n                     active(1)        - This trap receiver is active, allowing SNMP Traps to \r\n                                        be sent to this receiver.                     \r\n                                        \r\n                     notInService(2)  - This trap reciever is not active; no SNMP Traps will \r\n                                        be sent to this reciever until it's set back to active(1).\r\n                                        \r\n                                        \r\n                     config(3)        - The trap reciever Status must be set to this value in order \r\n                                        to configure it.  When creating a new trap receiver entry, \r\n                                        the Status will initially be set to this value.\r\n                                        Note: hmAgentSnmpTrapReceiverIPAddress must be set to non-zero\r\n                                        before changing to active(1) or notInService(2).\r\n                     \r\n                     destroy(4)       - Set to this value to remove the trap receiver entry from \r\n                                        the agent.")
hmAgentSnmpTrapFlagsConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5))
hmAgentSnmpAuthenticationTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpAuthenticationTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpAuthenticationTrapFlag.setDescription('Authentication Flag - Enable/Disable authentication Flag.')
hmAgentSnmpLinkUpDownTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpLinkUpDownTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpLinkUpDownTrapFlag.setDescription('Link Up/Down Flag - Enable/Disable Link Up/Link Down traps for the \r\n                     entire switch. When set to Enable, the Link Up/Down traps will be \r\n                     sent only if the Link Trap flag setting associated with the port \r\n                     (Port Configuration Menu) is set to Enable.\r\n                     ')
hmAgentSnmpMultipleUsersTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpMultipleUsersTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpMultipleUsersTrapFlag.setDescription('Multiple Users Flag - Enable/Disable Multiple User traps. When the value\r\n                     is set to Enable, a Multiple User Trap is sent whenever someone logs in \r\n                     to the terminal interface (EIA 232 or Telnet) and there is already an \r\n                     existing terminal interface session.\r\n                     ')
hmAgentSnmpSpanningTreeTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpSpanningTreeTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpSpanningTreeTrapFlag.setDescription('Spanning Tree Flag - This flag enables the sending of new root traps and \r\n                     topology change notification traps.')
hmAgentSnmpBroadcastStormTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpBroadcastStormTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpBroadcastStormTrapFlag.setDescription('Broadcast Storm Flag - This flag enables or disables the broadcast \r\n                     storm trap. You must also enable Broadcast Storm Recovery Mode \r\n                     (see the Switch Configuration Menu). When this \r\n                     value is set to Enable and Broadcast Storm Recovery mode is set to Enable, \r\n                     the Broadcast Storm Start/End traps are sent when the switch enters and \r\n                     leaves Broadcast Storm Recovery.\r\n                     ')
hmAgentSnmpChassisTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpChassisTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpChassisTrapFlag.setDescription('Chassis Flag - Enable/Disable traps for\r\n\t\t\t\t\t  hmTemperatureTrap\r\n\t\t\t\t\t  hmModuleMapChange\r\n\t\t\t\t\t  hmPowerSupplyTrap\r\n\t\t\t\t\t  hmAutoconfigAdapterTrap                     \r\n                     ')
hmAgentSnmpL2RedundancyTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpL2RedundancyTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpL2RedundancyTrapFlag.setDescription('Chassis Flag - Enable/Disable traps\r\n\t\t\t\t\t  hmRingRedReconfig and hmRingCplReconfig \r\n                     ')
hmAgentSnmpPortSecurityTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentSnmpPortSecurityTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpPortSecurityTrapFlag.setDescription('PortSecurity Flag - enable/disable all port security traps.')
hmAgentSnmpCommunityMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSnmpCommunityMaxEntries.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpCommunityMaxEntries.setDescription('Max number of Entries in hmAgentSnmpCommunityConfigEntry')
hmAgentSnmpTrapReceiverMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 13, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverMaxEntries.setStatus('current')
if mibBuilder.loadTexts: hmAgentSnmpTrapReceiverMaxEntries.setDescription('Max number of Entries in hmAgentSnmpTrapReceiverConfigEntry')
hmPOEGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 14))
hmPOEGlobalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 1))
hmPOEStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEStatus.setStatus('current')
if mibBuilder.loadTexts: hmPOEStatus.setDescription('Enables/disables Power over Ethernet on this device.\r\n    The default value is enable.')
hmPOEScanning = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEScanning.setStatus('current')
if mibBuilder.loadTexts: hmPOEScanning.setDescription('Enables/disables port scanning on this device.\r\n    The default value is enable.')
hmPOEReservedPower = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEReservedPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEReservedPower.setDescription('Reserved system power for active Power over Ethernet ports in Watts.')
hmPOEFastStartup = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEFastStartup.setStatus('current')
if mibBuilder.loadTexts: hmPOEFastStartup.setDescription('Enables/disables Fast Power over Ethernet on this device.\r\n    The default value is disabled.')
hmPOEPortTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2), )
if mibBuilder.loadTexts: hmPOEPortTable.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortTable.setDescription('This table contains variables for each Power over Ethernet interface of\r\n\tthe switch.')
hmPOEPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPOEPortIndex"))
if mibBuilder.loadTexts: hmPOEPortEntry.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortEntry.setDescription('The entry of the hmPOEPortTable.')
hmPOEPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEPortIndex.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortIndex.setDescription('Index to identify an Power over Ethernet interface.')
hmPOEPortConsumptionPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEPortConsumptionPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortConsumptionPower.setDescription('Measured usage power per interface expressed in Milliwatts.')
hmPOEPortMaxConsumptionPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEPortMaxConsumptionPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortMaxConsumptionPower.setDescription('The  maximum observed power consumption (hmPOEPortConsumptionPower)   \r\n\tvalue expressed in milliwatts used by the PD. \r\n\tThe value is reset to 0 if the PoE admin state is set to disable \r\n\tor if a disconnect of the PD is detected.')
hmPOEPortPowerLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEPortPowerLimit.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortPowerLimit.setDescription('The power limit per port expressed in milliwatts. If set to\r\n\tzero the power consumption limitation is disabled.')
hmPOEModuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3), )
if mibBuilder.loadTexts: hmPOEModuleTable.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleTable.setDescription('This table contains objects for each plugged PoE+ module of\r\n\tthe switch. If the device is non-modular and supports PoE+ it\r\n\tcontains only one entry.')
hmPOEModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPOEModuleIndex"))
if mibBuilder.loadTexts: hmPOEModuleEntry.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleEntry.setDescription('The entries of the hmPOEModuleTable.')
hmPOEModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEModuleIndex.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleIndex.setDescription('Slot number of the plugged PoE+ module.')
hmPOEModulePower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEModulePower.setStatus('current')
if mibBuilder.loadTexts: hmPOEModulePower.setDescription('Configurable power budget per module expressed in Watts. The default\r\n\tvalue is hmPOEModuleMaximumPower and depends on the hardware.')
hmPOEModuleMaximumPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEModuleMaximumPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleMaximumPower.setDescription('Maximum available power budget per module expressed in Watts. This\r\n\tvalue depends on the device or module.')
hmPOEModuleReservedPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEModuleReservedPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleReservedPower.setDescription('The reserved power (depending on actual power classes) \r\n\tper module expressed in Watts.')
hmPOEModuleDeliveredPower = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPOEModuleDeliveredPower.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleDeliveredPower.setDescription('The measured usage power per module expressed in Watts.')
hmPOEModuleUsageThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEModuleUsageThreshold.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleUsageThreshold.setDescription('The usage power threshold per module expressed in percent. \r\nIf this threshold is exceeded a alarm is initiated.')
hmPOEModuleNotificationControlEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 14, 3, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPOEModuleNotificationControlEnable.setStatus('current')
if mibBuilder.loadTexts: hmPOEModuleNotificationControlEnable.setDescription('This object controls, on a per-module basis, whether\r\n\tor not notifications from the agent are enabled. ')
hmSwitchResources = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 15))
hmCpuResources = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 2))
hmMemoryResources = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 3))
hmNetworkResources = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 4))
hmEnableMeasurement = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmEnableMeasurement.setStatus('current')
if mibBuilder.loadTexts: hmEnableMeasurement.setDescription('Enable or disable the resources measurement If disabled, the\r\n             task - needed for measurement - is also deleted.')
hmCpuUtilization = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCpuUtilization.setStatus('current')
if mibBuilder.loadTexts: hmCpuUtilization.setDescription('The current cpu utilization of the switch in percent.')
hmCpuAverageUtilization = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCpuAverageUtilization.setStatus('current')
if mibBuilder.loadTexts: hmCpuAverageUtilization.setDescription('The average cpu utilization of the switch in percent,\r\n             max. measured over the last 30 minutes.')
hmCpuRunningProcesses = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCpuRunningProcesses.setStatus('current')
if mibBuilder.loadTexts: hmCpuRunningProcesses.setDescription('The current number of processes running.')
hmCpuMaxRunningProcesses = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmCpuMaxRunningProcesses.setStatus('current')
if mibBuilder.loadTexts: hmCpuMaxRunningProcesses.setDescription('The maximum number of processes running, max. since\r\n             the last 30 minutes.')
hmMemoryAllocated = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('kBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMemoryAllocated.setStatus('current')
if mibBuilder.loadTexts: hmMemoryAllocated.setDescription('The current allocated memory of the switch in kBytes.')
hmMemoryFree = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('kBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMemoryFree.setStatus('current')
if mibBuilder.loadTexts: hmMemoryFree.setDescription('The current free memory of the switch in kBytes.')
hmMemoryAllocatedAverage = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('kBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMemoryAllocatedAverage.setStatus('current')
if mibBuilder.loadTexts: hmMemoryAllocatedAverage.setDescription('The average allocated memory of the switch in kBytes,\r\n             measured over the last 30 minutes.')
hmMemoryFreeAverage = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setUnits('kBytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMemoryFreeAverage.setStatus('current')
if mibBuilder.loadTexts: hmMemoryFreeAverage.setDescription('The average free memory of the switch in kBytes,\r\n             measured over the last 30 minutes.')
hmNetworkCpuIfUtilization = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('precent').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetworkCpuIfUtilization.setStatus('current')
if mibBuilder.loadTexts: hmNetworkCpuIfUtilization.setDescription('The current network utilization of the internal cpu interface in percent.')
hmNetworkCpuIfAverageUtilization = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 15, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('precent').setMaxAccess("readonly")
if mibBuilder.loadTexts: hmNetworkCpuIfAverageUtilization.setStatus('current')
if mibBuilder.loadTexts: hmNetworkCpuIfAverageUtilization.setDescription('The average network utilization of the internal cpu interface in percent,\r\n             measured over the last 30 minutes.')
hmIndustrialEthernetProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16))
hmProfinetIOConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1))
hmProfinetIOStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 2))
hmEthernetIPConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3))
hmEthernetIPStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 4))
hmIEC61850ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 5))
hmIEC61850StatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 6))
hmPNIOAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPNIOAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmPNIOAdminStatus.setDescription('Enables/disables the ProfinetIO functionality\r\n\t\t     on this device. \r\n\t\t     If disabled(2), the ProfinetIO protocol is inactive, \r\n\t\t     but the ProfinetIO MIBs can be accessed. \r\n\t\t     The default value is disabled.')
hmPNIODeviceID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIODeviceID.setStatus('current')
if mibBuilder.loadTexts: hmPNIODeviceID.setDescription('Identifier of the device family.\r\n\t\t\t Values 1 .. 65635 are valid device IDs.')
hmPNIOModuleIdentNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIOModuleIdentNumber.setStatus('current')
if mibBuilder.loadTexts: hmPNIOModuleIdentNumber.setDescription('Identifier ID of the device of port or module.')
hmPNIOOrderID = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIOOrderID.setStatus('current')
if mibBuilder.loadTexts: hmPNIOOrderID.setDescription('Product (switch) order ID. \r\n\t\t\t The size is restricted to 64 characters.')
hmPNIODeviceTypeDetails = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIODeviceTypeDetails.setStatus('current')
if mibBuilder.loadTexts: hmPNIODeviceTypeDetails.setDescription('Switch device type details, for example: \r\n\t\t\t  4 Port Rail Switch.')
hmPNIOSoftwareRelease = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIOSoftwareRelease.setStatus('current')
if mibBuilder.loadTexts: hmPNIOSoftwareRelease.setDescription('This value is a string that contains Version number of \r\n\t\t  software in profinetio format, for example: 01.0.03.')
hmPNIOHardwareRelease = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIOHardwareRelease.setStatus('current')
if mibBuilder.loadTexts: hmPNIOHardwareRelease.setDescription('Version number of switch hardware in profinetio format.')
hmPNIOOrderID9th = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIOOrderID9th.setStatus('current')
if mibBuilder.loadTexts: hmPNIOOrderID9th.setDescription('Product (switch) order ID. \r\n\t\t\t The size is restricted to 32 characters\r\n\t\t\t (In the form of the 9-th numbers).')
hmPNIODcpModeTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 10), )
if mibBuilder.loadTexts: hmPNIODcpModeTable.setStatus('current')
if mibBuilder.loadTexts: hmPNIODcpModeTable.setDescription('Table of DCP mode entries')
hmPNIODcpModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 10, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmPNIODcpModePortID"))
if mibBuilder.loadTexts: hmPNIODcpModeEntry.setStatus('current')
if mibBuilder.loadTexts: hmPNIODcpModeEntry.setDescription('DCP mode entry')
hmPNIODcpModePortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIODcpModePortID.setStatus('current')
if mibBuilder.loadTexts: hmPNIODcpModePortID.setDescription('Port ID for the DCP mode table entry')
hmPNIODcpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ingress", 1), ("egress", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPNIODcpMode.setStatus('current')
if mibBuilder.loadTexts: hmPNIODcpMode.setDescription('DCP mode for one port.\r\n         Allowed values none(0), ingress(1), egress(2) or both(3) which is default.')
hmPNIONameOfStation = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPNIONameOfStation.setStatus('current')
if mibBuilder.loadTexts: hmPNIONameOfStation.setDescription('Device name. \r\n          The size is restricted to 240 characters.\r\n          It must be conform to the restrictions \r\n          as decribed in PNIO protocol specification.')
hmPNIONumActiveApplicationRelations = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPNIONumActiveApplicationRelations.setStatus('current')
if mibBuilder.loadTexts: hmPNIONumActiveApplicationRelations.setDescription('Returns the number of active application relations.')
hmPNIOMgmtSEEErrorIDGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 100))
hmPNIOApplicationRelationActive = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 1, 100, 1))
if mibBuilder.loadTexts: hmPNIOApplicationRelationActive.setStatus('current')
if mibBuilder.loadTexts: hmPNIOApplicationRelationActive.setDescription('Set not allowed, a Profinet application relation is active.')
hmEtherNetIPAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmEtherNetIPAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPAdminStatus.setDescription('Enables/disables the EtherNet/IP(TM) functionality\r\n\t\t     on this device. \r\n\t\t     If disabled(2), the EtherNet/IP protocol is deactivated, \r\n\t\t     but the EtherNet/IP MIBs can be accessed.  \r\n\t\t     The default value is disabled.')
hmEtherNetIPErrorCode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPErrorCode.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPErrorCode.setDescription('Read the error code within EtherNet/IP(TM) action. \r\n\t\t     ')
hmEtherNetIPProductCode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPProductCode.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPProductCode.setDescription('Read the Product Code as shown in the Identity Object\r\n\t\t\t of EtherNet/IP(TM). Values 1 .. 65635 are valid product codes.')
hmEtherNetIPRevisionMajor = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPRevisionMajor.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPRevisionMajor.setDescription('Read the major revision number as shown in the Identity Object\r\n\t\t\t of EtherNet/IP(TM). Values 1 .. 255 are valid revisions.')
hmEtherNetIPRevisionMinor = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPRevisionMinor.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPRevisionMinor.setDescription('Read the minor revision number as shown in the Identity Object\r\n\t\t\t of EtherNet/IP(TM). Values 1 .. 255 are valid revisions.')
hmEtherNetIPProductName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPProductName.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPProductName.setDescription('Read the product name as shown in the Identity Object\r\n\t\t\t of EtherNet/IP(TM). The size is restricted to 32 Characters.')
hmEtherNetIPCatalogName = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 3, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPCatalogName.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPCatalogName.setDescription('Read the catolog name as provided in the EDS file\r\n\t\t\t for EtherNet/IP(TM). The size is restricted to 255 Characters.')
hmEtherNetIPConnEstablished = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPConnEstablished.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPConnEstablished.setDescription('Statistics: number of connections that have been established\r\n\t\t\t within EtherNet/IP.')
hmEtherNetIPConnTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPConnTimeouts.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPConnTimeouts.setDescription('Statistics: number of connection timeouts that have been occurred\r\n\t\t\t within EtherNet/IP.')
hmEtherNetIPVendorObjRequests = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmEtherNetIPVendorObjRequests.setStatus('current')
if mibBuilder.loadTexts: hmEtherNetIPVendorObjRequests.setDescription('Statistics: number of requests to the vendor specific objects\r\n\t\t\t within EtherNet/IP.')
hmIEC61850MMSServerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIEC61850MMSServerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmIEC61850MMSServerAdminStatus.setDescription('Enables/disables the IEC61850 MMS server functionality\r\n\t\t     on this device. \r\n\t\t     If disabled(2), the MMS Server is deactivated, \r\n\t\t     but the IEC61850 MIBs can be accessed.  \r\n\t\t     The default value is disabled.')
hmIEC61850MMSServerWriteAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIEC61850MMSServerWriteAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hmIEC61850MMSServerWriteAccessStatus.setDescription('Enables/disables the Read/Write capability of the IEC61850 MMS. \r\n\t\t     If disabled(2), the MMS Server is accessible Read-Only,  \r\n\t\t     if enabled(2) the devices configuration can be changed using \r\n\t\t     the IEC61850 MMS protocol.  \r\n\t\t     The default value is disabled.')
hmIEC61850MMSServerTechnicalKey = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 16, 5, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmIEC61850MMSServerTechnicalKey.setStatus('current')
if mibBuilder.loadTexts: hmIEC61850MMSServerTechnicalKey.setDescription("The IEC61850 MMS server technical key setting corresponds to the IEC61850 IED name. \r\n\t\t\t This name is used to identify the device via a IEC61850 MMS client. \r\n\t\t\t The size is restricted to 32 characters. According to IEC61850-7-2 Ed. the TechnicalKey represents\r\n\t\t\t an IEC61850 VisibleString. Thus the following characters are allowed:\r\n\t\t\t VisibleString ( FROM\r\n\t\t\t\t('A'|'a'|'B'|'b'|'C'|'c'|'D'|'d'|'E'|'e'|'F'|'f'|\r\n\t\t\t\t'G'|'g'|'H'|'h'|'I'|'i'|'J'|'j'|'K'|'k'|'L'|'l'|\r\n\t\t\t\t'M'|'m'|'N'|'n'|'O'|'o'|'P'|'p'|'Q'|'q'|'R'|'r'|\r\n\t\t\t\t'S'|'s'|'T'|'t'|'U'|'u'|'V'|'v'|'W'|'w'|'X'|'x'|\r\n\t\t\t\t'Y'|'y'|'Z'|'z'|'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|\r\n\t\t\t\t'7'|'8'|'9') )")
hmAgentLoginGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 17))
hmAgentLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 17, 1), HmLargeDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLoginBanner.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginBanner.setDescription("The text added in this variable by the user will be displayed in\r\n \t\t\t\t the system login page as banner on every login into the CLI \r\n \t\t\t\t (local or remote) or when performing login into the system web interface.\r\n \t\t\t\t The default value is an empty string, which will not be displayed.\r\n \t\t\t\t Special meaning have the sequences '\\t' and '\\n' which\r\n \t\t\t\t allow the user to format the string with tabulator (t) \r\n \t\t\t\t and newline (n) format instructions. The percent character ('%') is not allowed.")
hmAgentLoginBannerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 17, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentLoginBannerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentLoginBannerAdminStatus.setDescription('Enables/disables the display of the pre login banner text.')
hmAgentCliBannerText = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 17, 3), HmLargeDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 2048))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCliBannerText.setStatus('current')
if mibBuilder.loadTexts: hmAgentCliBannerText.setDescription("The text added in this variable by the user will be displayed in\r\n\t\t\t the system login page (local or remote) instead of the systemoverview.\r\n\t\t\t The default value is an empty string.\r\n\t\t\t Special meaning have the sequences '\\t' and '\\n' which\r\n\t\t\t allow the user to format the string with tabulator (\\t) \r\n\t\t\t and newline (\\n) format instructions.\r\n\t\t\t The Banner must be enabled using hmAgentCliBannerAdminStatus.")
hmAgentCliBannerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 17, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAgentCliBannerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hmAgentCliBannerAdminStatus.setDescription('Enables/disables the display of the cli login banner text\r\n\t\t\t instead of the standard login banner.')
hmPortMonitorGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18))
hmPortMonitorAdminMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorAdminMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorAdminMode.setDescription('Global switch to enable / disable the port state actions,\r\n\t\t\t\t\t\t\twhich are performed if a condition becomes true')
hmPortMonitorIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 2), )
if mibBuilder.loadTexts: hmPortMonitorIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorIntfTable.setDescription('Port state mode interface table.')
hmPortMonitorIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorIntfEntry.setDescription('Port state mode interface entry.')
hmPortMonitorIntfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 2, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorIntfMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorIntfMode.setDescription('Port monitor interface mode.')
hmPortMonitorIntfReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 2, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorIntfReset.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorIntfReset.setDescription('Port monitor interface reset.')
hmPortMonitorIntfAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("port-disable", 1), ("trap-only", 2), ("auto-disable", 3))).clone('auto-disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorIntfAction.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorIntfAction.setDescription('Interface link disable state.')
hmPortMonitorConditionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3))
hmPortMonitorConditionIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1), )
if mibBuilder.loadTexts: hmPortMonitorConditionIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionIntfTable.setDescription('Port state condition interface table.')
hmPortMonitorConditionIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorConditionIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionIntfEntry.setDescription('Port state action interface entry.')
hmPortMonitorConditionLinkFlapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapMode.setDescription('Interface link flap mode.')
hmPortMonitorConditionCrcFragmentsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsMode.setDescription('Interface CrcFragments mode.')
hmPortMonitorConditionOverloadDetectionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionMode.setDescription('Interface Overload Detection mode.')
hmPortMonitorConditionSpeedDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexMode.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexMode.setDescription('Interface Speed and Duplex monitor mode.')
hmPortMonitorConditionField = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 1, 1, 3), Bits().clone(namedValues=NamedValues(("none", 0), ("link-flap", 1), ("crcFragments", 2), ("overload-detection", 3), ("speed-duplex", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPortMonitorConditionField.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionField.setDescription('Condition type field.')
hmPortMonitorConditionLinkFlapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2))
hmPortMonitorConditionLinkFlapInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 180)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapInterval.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapInterval.setDescription('Measure interval in seconds (1-180s) for link flap detection.')
hmPortMonitorConditionLinkFlapCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCount.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCount.setDescription('Link flap counter (1-100).')
hmPortMonitorConditionLinkFlapIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 3), )
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapIntfTable.setDescription('Port condition link flap interface table.')
hmPortMonitorConditionLinkFlapIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapIntfEntry.setDescription('Port condition link flap interface entry.')
hmPortMonitorConditionLinkFlapCountInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCountInterval.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCountInterval.setDescription('Link flap count that occured in last interval.')
hmPortMonitorConditionLinkFlapCountTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCountTotal.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionLinkFlapCountTotal.setDescription('Total link flap count.')
hmPortMonitorConditionCrcFragmentsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3))
hmPortMonitorConditionCrcFragmentsInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 180)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsInterval.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsInterval.setDescription('Measure interval in seconds (5-180s) for CrcFragments detection.')
hmPortMonitorConditionCrcFragmentsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCount.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCount.setDescription('CrcFragments counter (1-1000000).')
hmPortMonitorConditionCrcFragmentsIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 3), )
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsIntfTable.setDescription('Port condition CrcFragments interface table.')
hmPortMonitorConditionCrcFragmentsIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsIntfEntry.setDescription('Port condition CrcFragments interface entry.')
hmPortMonitorConditionCrcFragmentsCountInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCountInterval.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCountInterval.setDescription('CrcFragments count that occured in last interval.')
hmPortMonitorConditionCrcFragmentsCountTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCountTotal.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionCrcFragmentsCountTotal.setDescription('Total CrcFragments count.')
hmPortMonitorConditionOverloadDetectionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4))
hmPortMonitorConditionOverloadDetectionInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionInterval.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionInterval.setDescription('Measure interval in seconds (1-20s) for overload detection.')
hmPortMonitorConditionOverloadDetectionIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2), )
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionIntfTable.setDescription('Port condition overload detection interface table.')
hmPortMonitorConditionOverloadDetectionIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionIntfEntry.setDescription('Port condition overload detection interface entry.')
hmPortMonitorConditionOverloadDetectionTrafficType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("bc", 2), ("bc-mc", 3))).clone('bc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionTrafficType.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionTrafficType.setDescription('Overload detection conditon traffic type.')
hmPortMonitorConditionOverloadDetectionThresholdType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pps", 1), ("kbps", 2), ("link-capacity", 3))).clone('pps')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionThresholdType.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionThresholdType.setDescription('Overload detection conditon threshold type.')
hmPortMonitorConditionOverloadDetectionLowerThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionLowerThresholdValue.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionLowerThresholdValue.setDescription('Overload detection conditon lower threshold value.')
hmPortMonitorConditionOverloadDetectionUpperThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionUpperThresholdValue.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionOverloadDetectionUpperThresholdValue.setDescription('Overload detection condition upper threshold value.')
hmPortMonitorConditionSpeedDuplexGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 5))
hmPortMonitorConditionSpeedDuplexTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 5, 1), )
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexTable.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexTable.setDescription('Port condition speed-duplex interface table.')
hmPortMonitorConditionSpeedDuplexEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 5, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexEntry.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexEntry.setDescription('Port condition speed-duplex interface entry.')
hmPortMonitorConditionSpeedDuplexValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 18, 3, 5, 1, 1, 1), Bits().clone(namedValues=NamedValues(("hdx-10", 0), ("fdx-10", 1), ("hdx-100", 2), ("fdx-100", 3), ("hdx-1000", 4), ("fdx-1000", 5), ("fdx-10000", 6))).clone(namedValues=NamedValues(("hdx-10", 0), ("fdx-10", 1), ("hdx-100", 2), ("fdx-100", 3), ("hdx-1000", 4), ("fdx-1000", 5), ("fdx-10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexValue.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorConditionSpeedDuplexValue.setDescription('Speed and duplex combination allowed by port-monitor.')
hmAutoDisGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 2, 19))
hmAutoDisIntfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1), )
if mibBuilder.loadTexts: hmAutoDisIntfTable.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfTable.setDescription('Port Auto Disable interface table.')
hmAutoDisIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmAutoDisIntfEntry.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfEntry.setDescription('Port Auto Disable interface entry.')
hmAutoDisIntfRemainingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoDisIntfRemainingTime.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfRemainingTime.setDescription('Remaining time in seconds until the activation of the port.')
hmAutoDisIntfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoDisIntfComponentName.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfComponentName.setDescription('Name of the component that triggered the error')
hmAutoDisIntfErrorReason = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 0), ("link-flap", 1), ("crc-error", 2), ("overload-detection", 3), ("speed-duplex", 4), ("port-security", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoDisIntfErrorReason.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfErrorReason.setDescription('Error disable reason')
hmAutoDisIntfTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(30, 2147483), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAutoDisIntfTimer.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfTimer.setDescription('Timer value in seconds after which a deactivated port is activated again.\r\n\t\t   Possible values are: 30-2147483.\r\n\t\t   A value of 0 disables the timer.')
hmAutoDisIntfReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAutoDisIntfReset.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfReset.setDescription('Port Auto Disable interface reset.')
hmAutoDisIntfOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmAutoDisIntfOperState.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisIntfOperState.setDescription('Status of Auto Disable interface admin state')
hmAutoDisReasonTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 2), )
if mibBuilder.loadTexts: hmAutoDisReasonTable.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisReasonTable.setDescription('Possible reasons for Auto Disable')
hmAutoDisReasonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 2, 1), ).setIndexNames((0, "HMPRIV-MGMT-SNMP-MIB", "hmAutoDisReasons"))
if mibBuilder.loadTexts: hmAutoDisReasonEntry.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisReasonEntry.setDescription('Port Auto Disable interface entry.')
hmAutoDisReasons = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("link-flap", 1), ("crc-error", 2), ("overload-detection", 3), ("speed-duplex", 4), ("port-security", 5))))
if mibBuilder.loadTexts: hmAutoDisReasons.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisReasons.setDescription('Reason for deactivation a port')
hmAutoDisReasonOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 2, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmAutoDisReasonOperation.setStatus('current')
if mibBuilder.loadTexts: hmAutoDisReasonOperation.setDescription('Enables/disables recovery by reason on this device.')
hmMACNotificationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 17))
hmMACNotifyMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 17, 1))
hmMACNotifyInterfaceMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 14, 17, 2))
hmMACNotifyAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmMACNotifyAdminState.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyAdminState.setDescription('Enable or disable MAC Notification global.')
hmMACNotifyInterval = MibScalar((1, 3, 6, 1, 4, 1, 248, 14, 17, 1, 2), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmMACNotifyInterval.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterval.setDescription('MAC Notification interval in seconds.\r\n        Range is between 0 and 2147483647.')
hmMACNotifyInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1), )
if mibBuilder.loadTexts: hmMACNotifyInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceTable.setDescription('A table containing current configuration information\r\n        for each interface.')
hmMACNotifyInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hmMACNotifyInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceEntry.setDescription('A logical row in the hmMACNotifyInterfaceTable.')
hmMACNotifyInterfaceAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmMACNotifyInterfaceAdminState.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceAdminState.setDescription('Enable or disable MAC Notification on this interface.')
hmMACNotifyInterfaceMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMACNotifyInterfaceMACAddr.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceMACAddr.setDescription('Last MAC address on this interface that have been added or \r\n        removed from the address table.')
hmMACNotifyInterfaceMACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("added", 2), ("removed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hmMACNotifyInterfaceMACStatus.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceMACStatus.setDescription('Status of the last MAC address on this interface.')
hmMACNotifyInterfaceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 14, 17, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("remove", 2), ("addAndRemove", 3))).clone('addAndRemove')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hmMACNotifyInterfaceMode.setStatus('current')
if mibBuilder.loadTexts: hmMACNotifyInterfaceMode.setDescription("Setting this object to 'add' (1) causes that only notifications are sent when entries are added to the FDB.\r\n\t\t Setting this object to 'remove' (2) causes that only notifications are sent when entries are removed from the FDB.\r\n\t\t Setting this object to 'addAndRemove' (3) causes that notifications are sent when entries are added or removed in the FDB.")
hmChassisEvent = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 14, 1, 0))
if mibBuilder.loadTexts: hmChassisEvent.setStatus('current')
if mibBuilder.loadTexts: hmChassisEvent.setDescription('The events of hmChassis.')
hmAgentEvent = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 14, 2, 0))
if mibBuilder.loadTexts: hmAgentEvent.setStatus('current')
if mibBuilder.loadTexts: hmAgentEvent.setDescription('The events of hmAgent.')
hmGroupMapChange = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 1)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSysGroupMap"), ("HMPRIV-MGMT-SNMP-MIB", "hmNeighbourSlot"), ("HMPRIV-MGMT-SNMP-MIB", "hmNeighbourIpAddress"))
if mibBuilder.loadTexts: hmGroupMapChange.setStatus('current')
if mibBuilder.loadTexts: hmGroupMapChange.setDescription('This trap is sent when a change occurs in the group\r\n\t\t\t\tstructure of a switch. This occurs only when a\r\n\t\t\t\tgroup is logically removed from or added to a switch.\r\n\t\t\t\tThe varBind list contains the updated value of the\r\n\t\t\t\thmSysGroupMap variable. hmNeighbourSlot identifies the\r\n\t\trelated slot. hmNeighbourIpAddress shows whether a group\r\n\t\twas logically removed (0.0.0.0) or added (correct ipAddress).')
hmPowerSupply = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 2)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmPSState"))
if mibBuilder.loadTexts: hmPowerSupply.setStatus('current')
if mibBuilder.loadTexts: hmPowerSupply.setDescription('This trap is sent if the state of a power supply unit changes.')
hmFan = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 3)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmFanState"))
if mibBuilder.loadTexts: hmFan.setStatus('current')
if mibBuilder.loadTexts: hmFan.setDescription('This trap is sent if the value of hmFanCtrl changes.')
hmSignallingRelay = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 4)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmRS2SigRelayState"), ("HMPRIV-MGMT-SNMP-MIB", "hmSigTrapReason"), ("HMPRIV-MGMT-SNMP-MIB", "hmSigReasonIndex"))
if mibBuilder.loadTexts: hmSignallingRelay.setStatus('current')
if mibBuilder.loadTexts: hmSignallingRelay.setDescription('This trap is sent if the value of hmRS2SigRelayState changes its value.\r\n\t\t\t\tVariables included in this trap are hmRS2SigRelayState, hmSigTrapReason,\r\n\t\t\t\thmSigReasonIndex.')
hmStandby = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 5)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmRS2OperMode"))
if mibBuilder.loadTexts: hmStandby.setStatus('current')
if mibBuilder.loadTexts: hmStandby.setDescription('This trap is sent if the value of hmRS2OperMode changes.')
hmSelftestError = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 6)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestCpuResult"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestBBResult"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestBPResult"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestM1Result"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestM2Result"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestM3Result"), ("HMPRIV-MGMT-SNMP-MIB", "hmSelfTestM4Result"))
if mibBuilder.loadTexts: hmSelftestError.setStatus('current')
if mibBuilder.loadTexts: hmSelftestError.setDescription('This trap is sent if the value of one of the selftest \r\n\t\t\t\t results is not zero or if a value changes while the \r\n\t\t\t\t agent is running.')
hmModuleMapChange = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 7)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSysGroupModuleMap"))
if mibBuilder.loadTexts: hmModuleMapChange.setStatus('current')
if mibBuilder.loadTexts: hmModuleMapChange.setDescription('This trap is sent when a change occurs in the module\r\n\t\t\t\tstructure of a switch. This occurs only when a\r\n\t\t\t\tmodule is logically removed from or added to a switch.\r\n\t\t\t\tThe varBind list contains the updated value of the\r\n\t\tvariable hmSysGroupModuleMap.')
hmBPDUGuardTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 8)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmIfaceStpBpduGuardStatus"))
if mibBuilder.loadTexts: hmBPDUGuardTrap.setStatus('current')
if mibBuilder.loadTexts: hmBPDUGuardTrap.setDescription('This trap is sent if on this port an BPDU guard \r\n                  functionality is enabled (globally or only for this port) \r\n                  and an (R)STP BPDU are received on this port. That means when \r\n                  hmIfaceStpBpduGuardStatus is set to true(1) for this port.\r\n                  Then IfAdminStatus for this port is set to down(2). \r\n                  If needed, it must be changed by hand to up(1)')
hmSigConRelayChange = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 10)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSigConOperState"), ("HMPRIV-MGMT-SNMP-MIB", "hmSigConTrapCause"), ("HMPRIV-MGMT-SNMP-MIB", "hmSigConTrapCauseIndex"))
if mibBuilder.loadTexts: hmSigConRelayChange.setStatus('current')
if mibBuilder.loadTexts: hmSigConRelayChange.setDescription('This trap is sent if the value of hmSigConOperState changes its value.\r\n\t\t\t\tVariables included in this trap are hmSigConOperState, hmSigConTrapCause,\r\n\t\t\t\thmSigConTrapCauseIndex.')
hmSFPChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 11)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmIfaceGroupID"), ("HMPRIV-MGMT-SNMP-MIB", "hmIfaceID"))
if mibBuilder.loadTexts: hmSFPChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hmSFPChangeTrap.setDescription('This trap is sent when a SFP has been added or removed.\r\n\t\t\t\tIt is also sent for an otherwise unsupported SFP.')
hmIfaceUtilizationTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 12)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmIfaceUtilizationAlarmCondition"), ("HMPRIV-MGMT-SNMP-MIB", "hmIfaceUtilization"))
if mibBuilder.loadTexts: hmIfaceUtilizationTrap.setStatus('current')
if mibBuilder.loadTexts: hmIfaceUtilizationTrap.setDescription('This trap is sent if the value of hmIfaceUtilization exceeds or\r\n\t\t\t\tfalls back below the interface untilization threshholds\r\n\t\t\t\thmIfaceUtilizationAlarmConditionThreshold and \r\n\t\t\t\thmIfaceUtilizationAlarmRemovalThreshold.')
hmDevMonStateChange = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 13)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmDevMonSwitchState"), ("HMPRIV-MGMT-SNMP-MIB", "hmDevMonTrapCause"), ("HMPRIV-MGMT-SNMP-MIB", "hmDevMonTrapCauseIndex"))
if mibBuilder.loadTexts: hmDevMonStateChange.setStatus('current')
if mibBuilder.loadTexts: hmDevMonStateChange.setDescription('This trap is sent if the value of hmDevMonSwitchState changes its value.\r\n\t\t\t\tVariables included in this trap are hmDevMonSwitchState, hmDevMonTrapCause,\r\n\t\t\t\thmDevMonTrapCauseIndex.')
hmSFPRxPowerChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 14)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSfpRxPowerState"))
if mibBuilder.loadTexts: hmSFPRxPowerChangeTrap.setStatus('current')
if mibBuilder.loadTexts: hmSFPRxPowerChangeTrap.setDescription('This trap is sent when the state of the rx power of a SFP changes.')
hmSysSelftestRebootOnErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 1, 0, 15)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSysSelftestRebootOnError"))
if mibBuilder.loadTexts: hmSysSelftestRebootOnErrorTrap.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestRebootOnErrorTrap.setDescription('This trap is sent when the agent wants to reboot due to an internal circumstance.')
hmTemperatureTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 1)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmTemperature"), ("HMPRIV-MGMT-SNMP-MIB", "hmTempUprLimit"), ("HMPRIV-MGMT-SNMP-MIB", "hmTempLwrLimit"))
if mibBuilder.loadTexts: hmTemperatureTrap.setStatus('current')
if mibBuilder.loadTexts: hmTemperatureTrap.setDescription('This trap is sent\tif the value of hmTemperature leaves or\r\n\t\t\t\tenters the range of the agent temperature threshholds\r\n\t\t\t\thmTempUprLimit and hmTempLwrLimit.')
hmLoginTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 2)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmLastIpAddr"), ("HMPRIV-MGMT-SNMP-MIB", "hmLastCommunity"))
if mibBuilder.loadTexts: hmLoginTrap.setStatus('current')
if mibBuilder.loadTexts: hmLoginTrap.setDescription("This trap is sent if a user attemps to login via telnet \r\n\t\t\t\tor serial connection. hmLastIpAddr contains the IP address of the \r\n\t\t\t\tlogin request. the value is 0.0.0.0, if the request was sent via serial \r\n\t\t\t\tconnection. hmLastCommunity contains the used password. If the login was \r\n\t\t\t\tsuccessfull, '******' will be sent instead.")
hmDuplicateStaticAddressTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 3)).setObjects(("BRIDGE-MIB", "dot1dStaticAddress"))
if mibBuilder.loadTexts: hmDuplicateStaticAddressTrap.setStatus('current')
if mibBuilder.loadTexts: hmDuplicateStaticAddressTrap.setDescription('This trap is sent if a user attemps to set the same static unicast \r\n\t\t\t\taddress at more than one agent of a chassis')
hmAutoconfigAdapterTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 4)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmAutoconfigAdapterStatus"))
if mibBuilder.loadTexts: hmAutoconfigAdapterTrap.setStatus('current')
if mibBuilder.loadTexts: hmAutoconfigAdapterTrap.setDescription('This trap reports a status change of the Autoconfiguration Adapter.')
hmRelayDuplicateIPTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 5)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmRelayLastDuplicateIP"))
if mibBuilder.loadTexts: hmRelayDuplicateIPTrap.setStatus('current')
if mibBuilder.loadTexts: hmRelayDuplicateIPTrap.setDescription('This trap reports the detection of a duplicate ip address \r\n\t\t\t\tby the relay agent.')
hmSNTPTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 6)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmNetSNTPOperStatus"))
if mibBuilder.loadTexts: hmSNTPTrap.setStatus('current')
if mibBuilder.loadTexts: hmSNTPTrap.setDescription('This trap reports SNTP error conditions. For a list of\r\n\t\t\t\t possible error conditions refer to hmNetSNTPOperStatus.')
hmNetACDNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 7)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmNetACDTimeMark"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetACDAddrSubtype"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetACDAddr"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetACDMAC"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetACDIfId"))
if mibBuilder.loadTexts: hmNetACDNotification.setStatus('current')
if mibBuilder.loadTexts: hmNetACDNotification.setDescription('This trap reports an address conflict detection.')
hmConfigurationSavedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 8)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmAutoconfigAdapterStatus"))
if mibBuilder.loadTexts: hmConfigurationSavedTrap.setStatus('current')
if mibBuilder.loadTexts: hmConfigurationSavedTrap.setDescription('This trap is sent after the configuration of the\r\n\t\t\t\tagent was successfully saved.')
hmConfigurationChangedTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 9)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmConfigurationStatus"))
if mibBuilder.loadTexts: hmConfigurationChangedTrap.setStatus('current')
if mibBuilder.loadTexts: hmConfigurationChangedTrap.setDescription("This trap is sent if the local and the running\r\n\t\t\t\tconfiguration doesn't match.")
hmAddressRelearnDetectTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 10)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmSysSwitchAddressRelearnThreshold"))
if mibBuilder.loadTexts: hmAddressRelearnDetectTrap.setStatus('current')
if mibBuilder.loadTexts: hmAddressRelearnDetectTrap.setDescription('This trap is sent if the relearn threshold is exceeded.')
hmDuplexMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 11)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmIfaceGroupID"), ("HMPRIV-MGMT-SNMP-MIB", "hmIfaceID"))
if mibBuilder.loadTexts: hmDuplexMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: hmDuplexMismatchTrap.setDescription('This trap indicates a possible serious situation.\r\n\t\t\t\tCheck for duplex mismatch, or EMI, or too many cascaded hubs, or exceeded maximum distance at HDX port.')
hmNTPTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 12)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmNetNTPStatusCode"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetNTPStatusText"))
if mibBuilder.loadTexts: hmNTPTrap.setStatus('current')
if mibBuilder.loadTexts: hmNTPTrap.setDescription('This trap reports NTP error conditions. For a list of\r\n                 possible error conditions refer to hmNetNTPStatusCode.')
hmPortMonitorPortDisabledTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 13)).setObjects(("IF-MIB", "ifIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmPortMonitorConditionField"))
if mibBuilder.loadTexts: hmPortMonitorPortDisabledTrap.setStatus('current')
if mibBuilder.loadTexts: hmPortMonitorPortDisabledTrap.setDescription('This trap is sent if a port has been disabled by port disable action by port monitor.')
hmPOEModulePowerUsageOnNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 14)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmPOEModuleIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmPOEModuleDeliveredPower"))
if mibBuilder.loadTexts: hmPOEModulePowerUsageOnNotification.setStatus('current')
if mibBuilder.loadTexts: hmPOEModulePowerUsageOnNotification.setDescription('This trap reports POE error condition. This Notification \r\n\tindicate PSE Threshold usage indication is on, the usage power \r\n\tis above the threshold. At least 500 msec must elapse between\r\n\tnotifications being emitted by the same object instance.')
hmPOEModulePowerUsageOffNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 15)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmPOEModuleIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmPOEModuleDeliveredPower"))
if mibBuilder.loadTexts: hmPOEModulePowerUsageOffNotification.setStatus('current')
if mibBuilder.loadTexts: hmPOEModulePowerUsageOffNotification.setDescription('This trap reports POE error condition. This Notification \r\n\tindicate PSE Threshold usage indication is on, the usage power \r\n\tis below the threshold. At least 500 msec must elapse between\r\n\tnotifications being emitted by the same object instance.')
hmSysSelftestPortError = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 16)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmIfaceGroupID"), ("HMPRIV-MGMT-SNMP-MIB", "hmIfaceID"))
if mibBuilder.loadTexts: hmSysSelftestPortError.setStatus('current')
if mibBuilder.loadTexts: hmSysSelftestPortError.setDescription('This trap is sent when the agent wants to reboot due to Opal Workaround 4. It shows\r\n\tthat the specific port is in an error state and a device reboot is needed.')
hmMACNotificationTrap = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 17)).setObjects(("IF-MIB", "ifIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmMACNotifyInterfaceMACAddr"), ("HMPRIV-MGMT-SNMP-MIB", "hmMACNotifyInterfaceMACStatus"))
if mibBuilder.loadTexts: hmMACNotificationTrap.setStatus('current')
if mibBuilder.loadTexts: hmMACNotificationTrap.setDescription('This trap is sent when a MAC address has been added to or \r\n        removed from the FDB on a specific interface.')
hmPOEPortMaxConfiguredPowerLimitExceeded = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 18)).setObjects(("HMPRIV-MGMT-SNMP-MIB", "hmPOEPortIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmPOEPortMaxConsumptionPower"), ("HMPRIV-MGMT-SNMP-MIB", "hmPOEPortPowerLimit"))
if mibBuilder.loadTexts: hmPOEPortMaxConfiguredPowerLimitExceeded.setStatus('current')
if mibBuilder.loadTexts: hmPOEPortMaxConfiguredPowerLimitExceeded.setDescription('This trap reports an exceeding of the configured power limit. \r\n\t\tThis notification indicates that a PD consumes more power that the maximum configured on the port and the system reserved the maximum power required for the negotiated class.')
hmNetMacACDNotification = NotificationType((1, 3, 6, 1, 4, 1, 248, 14, 2, 0, 19)).setObjects(("IF-MIB", "ifIndex"), ("HMPRIV-MGMT-SNMP-MIB", "hmNetMacACDConflictAddress"))
if mibBuilder.loadTexts: hmNetMacACDNotification.setStatus('current')
if mibBuilder.loadTexts: hmNetMacACDNotification.setDescription("This trap reports a MAC address conflict with it's own MAC address.")
mibBuilder.exportSymbols("HMPRIV-MGMT-SNMP-MIB", hmNetPTPClockIdentifier=hmNetPTPClockIdentifier, hmSysSTPErrorNumber=hmSysSTPErrorNumber, hmLEDOctFault=hmLEDOctFault, hmNetMacACDGroup=hmNetMacACDGroup, hmNetVlanPriority=hmNetVlanPriority, hmRelayMCPktInCnt=hmRelayMCPktInCnt, hmSigConSenseControlLine=hmSigConSenseControlLine, hmSigConSenseFan1State=hmSigConSenseFan1State, hmPortMonitorConditionOverloadDetectionThresholdType=hmPortMonitorConditionOverloadDetectionThresholdType, hmNetPTPSyncUpperBound=hmNetPTPSyncUpperBound, hmAgentEvent=hmAgentEvent, hmFSActionResult=hmFSActionResult, hmRelayDHCPServer2IpAddr=hmRelayDHCPServer2IpAddr, hmTrapCommTableEntriesMax=hmTrapCommTableEntriesMax, hmSysModType=hmSysModType, hmNetPTPPortEntry=hmNetPTPPortEntry, hmAgentSnmpSpanningTreeTrapFlag=hmAgentSnmpSpanningTreeTrapFlag, hmSysMaxSignalContacts=hmSysMaxSignalContacts, hmNetPTPClockVariance=hmNetPTPClockVariance, hmAgentSnmpTrapReceiverConfigEntry=hmAgentSnmpTrapReceiverConfigEntry, hmPortMonitorConditionCrcFragmentsCountInterval=hmPortMonitorConditionCrcFragmentsCountInterval, hmTrunkOperStatus=hmTrunkOperStatus, hmPrioTOSEnable=hmPrioTOSEnable, hmNetPTP2TCCurrentMaster=hmNetPTP2TCCurrentMaster, hmAuthHostIndex=hmAuthHostIndex, hmGMRPGroup=hmGMRPGroup, hmAUIModuleDTEPowerMonitor=hmAUIModuleDTEPowerMonitor, hmTrapCommEntry=hmTrapCommEntry, hmDevMonSensePS8State=hmDevMonSensePS8State, hmSysModDescription=hmSysModDescription, hmAddressRelearnDetectTrap=hmAddressRelearnDetectTrap, hmAuthHostName=hmAuthHostName, hmDIPSwitchMICEGroup=hmDIPSwitchMICEGroup, hmLimiterGroup=hmLimiterGroup, PTPClockIdentity=PTPClockIdentity, hmIfaceExtAcceptableFrameTypes=hmIfaceExtAcceptableFrameTypes, hmLEDOctRedundancyManager=hmLEDOctRedundancyManager, hmRelayServerInterface=hmRelayServerInterface, hmDevMonSenseRedNotGuaranteed=hmDevMonSenseRedNotGuaranteed, hmSfpTemperature=hmSfpTemperature, hmGmrpUnknownMode=hmGmrpUnknownMode, hmPOEPortMaxConfiguredPowerLimitExceeded=hmPOEPortMaxConfiguredPowerLimitExceeded, hmSysSoftwareCapability=hmSysSoftwareCapability, hmSwitchResources=hmSwitchResources, mach4002_48G=mach4002_48G, hmSysConsoleServiceShellAdminState=hmSysConsoleServiceShellAdminState, hmRS2VlanStatus=hmRS2VlanStatus, hmNetPTP2TCNetworkProtocol=hmNetPTP2TCNetworkProtocol, hmNeighbourIpAddress=hmNeighbourIpAddress, hmSysSwitchAddressRelearnThreshold=hmSysSwitchAddressRelearnThreshold, hmAgentSnmpCommunityCreate=hmAgentSnmpCommunityCreate, hmPortMonitorGroup=hmPortMonitorGroup, mach4002_24G=mach4002_24G, hmPNIODcpMode=hmPNIODcpMode, hmNetAction=hmNetAction, hmPortMonitorConditionOverloadDetectionTrafficType=hmPortMonitorConditionOverloadDetectionTrafficType, hmNetPTP2StepsRemoved=hmNetPTP2StepsRemoved, hmRestrictedMgtAccessGroup=hmRestrictedMgtAccessGroup, hmPortMonitorConditionSpeedDuplexGroup=hmPortMonitorConditionSpeedDuplexGroup, hmConfigurationChangedTrap=hmConfigurationChangedTrap, hmNetPTP2Leap59=hmNetPTP2Leap59, hmLastIpAddr=hmLastIpAddr, hmDIPSwitchAdminState=hmDIPSwitchAdminState, hmSfpInfoMagic=hmSfpInfoMagic, hmAutoDisIntfTable=hmAutoDisIntfTable, hmNetworkResources=hmNetworkResources, hmNetACDOngoingProbeStatus=hmNetACDOngoingProbeStatus, hmNetPTP2GrandmasterIdentity=hmNetPTP2GrandmasterIdentity, hmPOEModuleUsageThreshold=hmPOEModuleUsageThreshold, hmPortMonitorConditionLinkFlapIntfEntry=hmPortMonitorConditionLinkFlapIntfEntry, hmSysSwitchFDBFullCounter=hmSysSwitchFDBFullCounter, hmPNIOSoftwareRelease=hmPNIOSoftwareRelease, hmSysModuleTable=hmSysModuleTable, hmEtherNetIPRevisionMinor=hmEtherNetIPRevisionMinor, hmSysSelftestMMUStatus=hmSysSelftestMMUStatus, hmSelfTestBPResult=hmSelfTestBPResult, hmPortMonitorConditionGroup=hmPortMonitorConditionGroup, hmFSFileDate=hmFSFileDate, hmNetPTP2TCDelayMechanism=hmNetPTP2TCDelayMechanism, hmIfaceLinkType=hmIfaceLinkType, hmSerialNumM3=hmSerialNumM3, hmRelayPktServerRelayCnt=hmRelayPktServerRelayCnt, hmLoginTrap=hmLoginTrap, hmSfpBitRate=hmSfpBitRate, hmNetSNTPTimeAdjustThreshold=hmNetSNTPTimeAdjustThreshold, hmMACNotificationGroup=hmMACNotificationGroup, hmAgentSnmpLoggingGroup=hmAgentSnmpLoggingGroup, hmDevMonSenseControlLine=hmDevMonSenseControlLine, hmSFPRxPowerChangeTrap=hmSFPRxPowerChangeTrap, hmNetPTP2TCPortTable=hmNetPTP2TCPortTable, hmNetACDIfId=hmNetACDIfId, hmNetSNMPSynchronizeV3V1Status=hmNetSNMPSynchronizeV3V1Status, hmRS2FDBGroup=hmRS2FDBGroup, hmEtherNetIPRevisionMajor=hmEtherNetIPRevisionMajor, hmAutoDisIntfOperState=hmAutoDisIntfOperState, hmTrapCommChassis=hmTrapCommChassis, hmAuthCommIndex=hmAuthCommIndex, eagle20=eagle20, hmSigLinkTable=hmSigLinkTable, hmAgentSnmpCommunityAccessMode=hmAgentSnmpCommunityAccessMode, hmIGMPQuerierGroup=hmIGMPQuerierGroup, hmSfpMaxLength_fiber_62_5=hmSfpMaxLength_fiber_62_5, hmSysSkipAcaOnBoot=hmSysSkipAcaOnBoot, hmSigConTrapCause=hmSigConTrapCause, hmCurrentAddress=hmCurrentAddress, hmNetPTPPortState=hmNetPTPPortState, hmRS2SelftestMode=hmRS2SelftestMode, hmNetPTP2OffsetFromMaster=hmNetPTP2OffsetFromMaster, hmBcastLimiterMode=hmBcastLimiterMode, hmRelayDHCPServer3IpAddr=hmRelayDHCPServer3IpAddr, hmLEDGroup=hmLEDGroup, hmSysSwitchVLANGroup=hmSysSwitchVLANGroup, hmNetPTP2TCGroup=hmNetPTP2TCGroup, hmLEDMarStandby=hmLEDMarStandby, mach1000ge=mach1000ge, hmFSConfFileName=hmFSConfFileName, hmUserGroupStatus=hmUserGroupStatus, hmTrapCommTable=hmTrapCommTable, hmNetPTPStepsRemoved=hmNetPTPStepsRemoved, hmRMASrvTelnet=hmRMASrvTelnet, hmNetGPSGroup=hmNetGPSGroup, hmTrunkTable=hmTrunkTable, hmPOEPortConsumptionPower=hmPOEPortConsumptionPower, hmDIPSwitchMICEConfig=hmDIPSwitchMICEConfig, hmDIPSwitchRSGroup=hmDIPSwitchRSGroup, hmNetSNMPv3Status=hmNetSNMPv3Status, hmIfaceIngressLimiterCalculationMode=hmIfaceIngressLimiterCalculationMode, hmNetPTP2TCMultiDomainMode=hmNetPTP2TCMultiDomainMode, hmRelayInterfaceTable=hmRelayInterfaceTable, hmSelfTestM4Result=hmSelfTestM4Result, hmDIPSwitchMICEStandby=hmDIPSwitchMICEStandby, hmIGMPSnoopUnknownAgingTime=hmIGMPSnoopUnknownAgingTime, hmMACNotifyInterfaceMibObjects=hmMACNotifyInterfaceMibObjects, hmSigConRelayChange=hmSigConRelayChange, hmIGMPSnoopQueryEntry=hmIGMPSnoopQueryEntry, hmGroupMapChange=hmGroupMapChange, hmSfpSerialNum=hmSfpSerialNum, hmNetwork=hmNetwork, hmNetSNTPServer=hmNetSNTPServer, hmSysHttpsPortNumber=hmSysHttpsPortNumber, hmIGMPSnoopFilterEntry=hmIGMPSnoopFilterEntry, hmSysHTTPEnable=hmSysHTTPEnable, hmSysSwitchVLANLearningMode=hmSysSwitchVLANLearningMode, hmDevMonConfigEntry=hmDevMonConfigEntry, hmRelayOptionRemoteIDValue=hmRelayOptionRemoteIDValue, hmPNIODcpModeEntry=hmPNIODcpModeEntry, hmPortMonitorConditionLinkFlapCountInterval=hmPortMonitorConditionLinkFlapCountInterval, hmRS2SigRelayState=hmRS2SigRelayState, hmPortMonitorConditionOverloadDetectionInterval=hmPortMonitorConditionOverloadDetectionInterval, hmIfaceUtilizationTrap=hmIfaceUtilizationTrap, hmNetHiDiscoveryProtocol=hmNetHiDiscoveryProtocol, hmSysGroupHwVersion=hmSysGroupHwVersion, hmAgentSnmpLinkUpDownTrapFlag=hmAgentSnmpLinkUpDownTrapFlag, hmPrioMACReceivePort=hmPrioMACReceivePort, hmNetSNMPSynchronizeV1V3Status=hmNetSNMPSynchronizeV1V3Status, hmNetNTPServer2Address=hmNetNTPServer2Address, hmRS2RedundancyGroup=hmRS2RedundancyGroup, hmPortMonitorAdminMode=hmPortMonitorAdminMode, hmAutoconfigGroup=hmAutoconfigGroup, hmPOEPortPowerLimit=hmPOEPortPowerLimit, hmNetACDAddrSubtype=hmNetACDAddrSubtype, hmPOEReservedPower=hmPOEReservedPower, hmPSSerialNumber=hmPSSerialNumber, rs2=rs2, hmIfaceUtilizationAlarmLowerThreshold=hmIfaceUtilizationAlarmLowerThreshold, hmSigLinkEntry=hmSigLinkEntry, hmLEDRSRGroup=hmLEDRSRGroup, hmRS4RVlanPortTable=hmRS4RVlanPortTable, hmRelayOptionRemoteID=hmRelayOptionRemoteID, hmDevMonConfigTable=hmDevMonConfigTable, hmNetSNMPPortNumber=hmNetSNMPPortNumber, hmSysGroupSerialNum=hmSysGroupSerialNum, hmPrioVlan0TagTransparentMode=hmPrioVlan0TagTransparentMode, hmRMASrvHttps=hmRMASrvHttps, hmLEDRStandby=hmLEDRStandby, hmPOEModuleTable=hmPOEModuleTable, hmSigConSensePS6State=hmSigConSensePS6State, hmMACNotifyInterfaceMode=hmMACNotifyInterfaceMode, mach4002_48G_3X=mach4002_48G_3X, hmNetPTPTimeSeconds=hmNetPTPTimeSeconds, hmDIPSwitchMICERedundancyManager=hmDIPSwitchMICERedundancyManager, hmNetPTP2VlanID=hmNetPTP2VlanID, hmTrapCommLinkUp=hmTrapCommLinkUp, hmSysSelftestGroup=hmSysSelftestGroup, hmNetSNTPAnycastVlan=hmNetSNTPAnycastVlan, hmNetACDDelay=hmNetACDDelay, hmIngressLimiterEnable=hmIngressLimiterEnable, hmRS2PartnerIpAddress=hmRS2PartnerIpAddress, hmNetPTP2TCLogPdelayReqInterval=hmNetPTP2TCLogPdelayReqInterval, hmSysSwitchRedundancyGroup=hmSysSwitchRedundancyGroup, hmMACNotifyInterfaceEntry=hmMACNotifyInterfaceEntry, hmIGMPSnoopUnknownLookupInterval=hmIGMPSnoopUnknownLookupInterval, hmNetSNMPv1Status=hmNetSNMPv1Status, hmSysHttpsCertFingerPrint=hmSysHttpsCertFingerPrint, hmAuthCommEntry=hmAuthCommEntry, hmDevMonSenseSRedNotGuaranteed=hmDevMonSenseSRedNotGuaranteed, PTPClockQuality=PTPClockQuality, hmPSSysID=hmPSSysID, hmRelayBCPktInCnt=hmRelayBCPktInCnt, hmRelayDHCPServer4IpAddr=hmRelayDHCPServer4IpAddr, hmIfacePhyFastLinkDetection=hmIfacePhyFastLinkDetection, hmNetIpDscpPriority=hmNetIpDscpPriority, hmSNTPTrap=hmSNTPTrap, hmNetACDAddrEntry=hmNetACDAddrEntry, hmNetSNTPOperStatus=hmNetSNTPOperStatus, hmSysGroupID=hmSysGroupID, hmIGMPSnoopStatus=hmIGMPSnoopStatus, hmIEC61850ConfigGroup=hmIEC61850ConfigGroup, hmNetPTP2GrandmasterPriority1=hmNetPTP2GrandmasterPriority1, hmNetPTPAction=hmNetPTPAction, hmNetPTP2NetworkProtocol=hmNetPTP2NetworkProtocol, hmDevMonSensePS7State=hmDevMonSensePS7State, hmAUIModuleTable=hmAUIModuleTable, hmAutoDisIntfTimer=hmAutoDisIntfTimer, hmAgentSnmpTrapReceiverMaxEntries=hmAgentSnmpTrapReceiverMaxEntries, hmAutoDisReasonOperation=hmAutoDisReasonOperation, hmNetPTP2DelayMechanism=hmNetPTP2DelayMechanism, hmNeighbourAgentTable=hmNeighbourAgentTable, hmSigConTrapEnable=hmSigConTrapEnable, hmRMAEntry=hmRMAEntry, hmIGMPGroup=hmIGMPGroup, hmRMAOperation=hmRMAOperation, hmPOEScanning=hmPOEScanning, hmCurrentAddressTable=hmCurrentAddressTable, hmAuthCommTable=hmAuthCommTable, hmAgentCliBannerText=hmAgentCliBannerText, hmSysVersion=hmSysVersion, hmNetPTP2PortState=hmNetPTP2PortState, hmRelayIfaceID=hmRelayIfaceID, hmNetPTP2TCProfile=hmNetPTP2TCProfile, hmFSFileTable=hmFSFileTable, hmPOEPortIndex=hmPOEPortIndex, hmRelayIfaceCircuitID=hmRelayIfaceCircuitID, hmSfpTxPower=hmSfpTxPower, hmCurrentAddressStatus=hmCurrentAddressStatus, hmSysOEMGroup=hmSysOEMGroup, hmRS2SigRelayGroup=hmRS2SigRelayGroup, hirschmann=hirschmann, hmSysGroupDescription=hmSysGroupDescription, hmPSProductCode=hmPSProductCode, hmAgent=hmAgent, hmIngressUnknUcLimiterMode=hmIngressUnknUcLimiterMode, hmSFPEntry=hmSFPEntry, hmPOEModulePowerUsageOnNotification=hmPOEModulePowerUsageOnNotification, hmRS2TopologyIpAddress=hmRS2TopologyIpAddress, hmDevMonSenseACARemoval=hmDevMonSenseACARemoval, hmPOEModuleIndex=hmPOEModuleIndex, hmPSState=hmPSState, hmNetPTP2PortEnable=hmNetPTP2PortEnable, hmAgentSnmpLogGetSeverity=hmAgentSnmpLogGetSeverity, hmPortMonitorIntfTable=hmPortMonitorIntfTable, hmSysFlowControl=hmSysFlowControl, hmCpuAverageUtilization=hmCpuAverageUtilization, hmSerialNumM4=hmSerialNumM4)
mibBuilder.exportSymbols("HMPRIV-MGMT-SNMP-MIB", hmEnableMeasurement=hmEnableMeasurement, hmIngressLimiterMode=hmIngressLimiterMode, hmSysModuleEntry=hmSysModuleEntry, hmEtherNetIPAdminStatus=hmEtherNetIPAdminStatus, hmPSID=hmPSID, hmNetNTPServer1Address=hmNetNTPServer1Address, hmPortMonitorConditionOverloadDetectionGroup=hmPortMonitorConditionOverloadDetectionGroup, hmNetLocalPhysAddr=hmNetLocalPhysAddr, hmNetPTP2TCVlanPriority=hmNetPTP2TCVlanPriority, hmIfaceStpEnable=hmIfaceStpEnable, hmDevMonSenseFan1State=hmDevMonSenseFan1State, hmNetACDProtectInterval=hmNetACDProtectInterval, hmSfpRxPowerState=hmSfpRxPowerState, hmNetPTP2LogSyncInterval=hmNetPTP2LogSyncInterval, hmFanEntry=hmFanEntry, hmPOEModuleNotificationControlEnable=hmPOEModuleNotificationControlEnable, hmSfpRxPowerdBm=hmSfpRxPowerdBm, hmPOEGroup=hmPOEGroup, hmNetACDStatus=hmNetACDStatus, hmSysSwitchFastLinkDetection=hmSysSwitchFastLinkDetection, hmRS2TopologyLinkID=hmRS2TopologyLinkID, hmNetSNTPStatus=hmNetSNTPStatus, hmPortMonitorConditionField=hmPortMonitorConditionField, hmNetSNTPAnycastInterval=hmNetSNTPAnycastInterval, hmRMARowStatus=hmRMARowStatus, hmPOEModuleReservedPower=hmPOEModuleReservedPower, hmAutoDisIntfReset=hmAutoDisIntfReset, PYSNMP_MODULE_ID=hmConfiguration, hmIfaceEgressLimiterCalculationMode=hmIfaceEgressLimiterCalculationMode, hmNetPTP2TCConfiguration=hmNetPTP2TCConfiguration, hmIGMPSnoopQueryStaticEntry=hmIGMPSnoopQueryStaticEntry, hmNetLocalIPAddr=hmNetLocalIPAddr, hmLastAccessGroup=hmLastAccessGroup, hmSysGroupAction=hmSysGroupAction, hmSelfTestM2Result=hmSelfTestM2Result, hmPSType=hmPSType, hmSigConID=hmSigConID, hmAuthCommPerm=hmAuthCommPerm, hmCpuMaxRunningProcesses=hmCpuMaxRunningProcesses, hmPortMonitorIntfEntry=hmPortMonitorIntfEntry, hmPrioTrafficClassTable=hmPrioTrafficClassTable, hmNetNTPServer1AddrType=hmNetNTPServer1AddrType, hmNetPTP2LogPdelayReqInterval=hmNetPTP2LogPdelayReqInterval, hmSysModulePortCapacity=hmSysModulePortCapacity, hmPOEPortEntry=hmPOEPortEntry, mach3000=mach3000, hmNetPTP2PtpTimescale=hmNetPTP2PtpTimescale, hmRelayIfaceBCRequestFwd=hmRelayIfaceBCRequestFwd, hmEtherNetIPVendorObjRequests=hmEtherNetIPVendorObjRequests, hmSelfTestM3Result=hmSelfTestM3Result, hmSigConTrapCauseIndex=hmSigConTrapCauseIndex, hmLEDMarRedundancyManager=hmLEDMarRedundancyManager, hmRelayInterfaceEntry=hmRelayInterfaceEntry, hmPOEModuleEntry=hmPOEModuleEntry, hmDeviceMonitoringGroup=hmDeviceMonitoringGroup, hmSysModNumOfPorts=hmSysModNumOfPorts, hmLEDRSFault=hmLEDRSFault, hmRelayDHCPServerIpAddr=hmRelayDHCPServerIpAddr, hmAgentLoginBannerAdminStatus=hmAgentLoginBannerAdminStatus, hmSigConSensePS4State=hmSigConSensePS4State, hmIfaceUtilizationAlarmCondition=hmIfaceUtilizationAlarmCondition, hmTrapCommUsergroup=hmTrapCommUsergroup, hmIfaceCableCrossing=hmIfaceCableCrossing, mach4002_24G_3X=mach4002_24G_3X, hmNetSNTPAcceptBroadcasts=hmNetSNTPAcceptBroadcasts, hmMemoryAllocated=hmMemoryAllocated, hmSysGroupActionDelayPreset=hmSysGroupActionDelayPreset, octopus_os=octopus_os, hmNetGatewayIPAddr=hmNetGatewayIPAddr, hmNetPPPNetMask=hmNetPPPNetMask, hmNeighbourSlot=hmNeighbourSlot, hmLEDOctPowerSupply2=hmLEDOctPowerSupply2, hmIfaceEgressLimiterMode=hmIfaceEgressLimiterMode, hmIEC61850MMSServerWriteAccessStatus=hmIEC61850MMSServerWriteAccessStatus, hmRS2RedNotGuaranteedAlarm=hmRS2RedNotGuaranteedAlarm, railswitchrugged=railswitchrugged, hmPrioMACAddressEntry=hmPrioMACAddressEntry, hmTrunkID=hmTrunkID, hmIGMPSnoopFilterAddress=hmIGMPSnoopFilterAddress, hmIfacePriorityThreshold=hmIfacePriorityThreshold, hmTrapDestIpAddress=hmTrapDestIpAddress, rr_epl=rr_epl, hmAgentSnmpCommunityIPAddress=hmAgentSnmpCommunityIPAddress, hmNetPTP2DelayAsymmetry=hmNetPTP2DelayAsymmetry, hmNetPTP2TCDelayAsymmetry=hmNetPTP2TCDelayAsymmetry, hmNetNTPAnycastAddress=hmNetNTPAnycastAddress, hmNetPTP2Leap61=hmNetPTP2Leap61, hmSysSelftestRAM=hmSysSelftestRAM, hmNetPTP2ObservedParentOffsetScaledLogVariance=hmNetPTP2ObservedParentOffsetScaledLogVariance, hmSysSwitchGroup=hmSysSwitchGroup, hmLEDRSGroup=hmLEDRSGroup, hmIGMPSnoopForwardAllEntry=hmIGMPSnoopForwardAllEntry, hmEtherNetIPConnEstablished=hmEtherNetIPConnEstablished, hmNetNTPAnycastAddrType=hmNetNTPAnycastAddrType, ms30=ms30, hmPortMonitorConditionLinkFlapInterval=hmPortMonitorConditionLinkFlapInterval, hmPortMonitorConditionSpeedDuplexTable=hmPortMonitorConditionSpeedDuplexTable, hmSysSwitchRedundancyRstpMrpConfigErrorBridge=hmSysSwitchRedundancyRstpMrpConfigErrorBridge, hmLEDMarRelay2=hmLEDMarRelay2, hmFwdPriorityConfiguration=hmFwdPriorityConfiguration, hmBPDUGuardTrap=hmBPDUGuardTrap, hmNetPTP2Priority2=hmNetPTP2Priority2, hmSysUSBGroup=hmSysUSBGroup, hmSigConSensePS8State=hmSigConSensePS8State, hmRS2PSAlarm=hmRS2PSAlarm, hmNetPTP2LogDelayReqInterval=hmNetPTP2LogDelayReqInterval, hmAgentSnmpTrapReceiverCreate=hmAgentSnmpTrapReceiverCreate, hmMemoryAllocatedAverage=hmMemoryAllocatedAverage, hmRS4RVlanGroup=hmRS4RVlanGroup, hmAuthCommState=hmAuthCommState, rsb20=rsb20, hmSysStpEnable=hmSysStpEnable, hmNetPTP2PeerMeanPathDelay=hmNetPTP2PeerMeanPathDelay, hmTrapDestName=hmTrapDestName, hmSysSwitchServiceMode=hmSysSwitchServiceMode, hmNetPTPSyncInterval=hmNetPTPSyncInterval, hmDuplexMismatchTrap=hmDuplexMismatchTrap, hmNetSNMPv2Status=hmNetSNMPv2Status, hmAgentSnmpLogSetRequest=hmAgentSnmpLogSetRequest, hmPortMonitorConditionIntfTable=hmPortMonitorConditionIntfTable, hmNetACDMaxProtection=hmNetACDMaxProtection, hmMACH3Misc=hmMACH3Misc, hmSysSwitchServiceModeGroup=hmSysSwitchServiceModeGroup, hmNetACDFaultState=hmNetACDFaultState, hmAgentSnmpAuthenticationTrapFlag=hmAgentSnmpAuthenticationTrapFlag, eagle=eagle, hmAUIPortDTEPower=hmAUIPortDTEPower, hmDevMonTrapCause=hmDevMonTrapCause, hmMACNotifyInterfaceTable=hmMACNotifyInterfaceTable, hmRS2TopologyEntry=hmRS2TopologyEntry, hmNetPTPSyncLowerBound=hmNetPTPSyncLowerBound, hmSystemTime=hmSystemTime, hmAuthHostTableEntriesMax=hmAuthHostTableEntriesMax, hmPortMonitorConditionCrcFragmentsCountTotal=hmPortMonitorConditionCrcFragmentsCountTotal, hmRS2ConnectionMirroringGroup=hmRS2ConnectionMirroringGroup, hmNetPTP2CurrentUtcOffsetValid=hmNetPTP2CurrentUtcOffsetValid, hmLEDRSRedundancyManager=hmLEDRSRedundancyManager, hmAgentSnmpCommunityConfigTable=hmAgentSnmpCommunityConfigTable, hmSysModID=hmSysModID, hmIngressLimiterGroup=hmIngressLimiterGroup, hmSigTrapReason=hmSigTrapReason, hmDIPSwitchConflict=hmDIPSwitchConflict, hmSigConLinkEntry=hmSigConLinkEntry, hmSysGroupCapacity=hmSysGroupCapacity, hmPrioMACAddressTable=hmPrioMACAddressTable, hmMgmtBusSelected=hmMgmtBusSelected, hmNetNTPGroup=hmNetNTPGroup, hmNetNTPStatusText=hmNetNTPStatusText, hmAgentSnmpCommunityConfigEntry=hmAgentSnmpCommunityConfigEntry, hmDIPSwitchGroup=hmDIPSwitchGroup, hmDevMonSenseTemperature=hmDevMonSenseTemperature, hmNetSNTPTime=hmNetSNTPTime, hmNetPTPObservedDrift=hmNetPTPObservedDrift, hmNetACDNotification=hmNetACDNotification, hmEgressLimiterEnable=hmEgressLimiterEnable, hmNetSNTPSyncInterval=hmNetSNTPSyncInterval, hmIEC61850MMSServerAdminStatus=hmIEC61850MMSServerAdminStatus, hmNetPTPSubdomainName=hmNetPTPSubdomainName, hmFanState=hmFanState, hmRMANetMask=hmRMANetMask, hmIfaceUtilizationAlarmUpperThreshold=hmIfaceUtilizationAlarmUpperThreshold, hmRS2PSGroup=hmRS2PSGroup, hmMemoryFreeAverage=hmMemoryFreeAverage, hmPNIOApplicationRelationActive=hmPNIOApplicationRelationActive, hmPrioTrafficClassWeight=hmPrioTrafficClassWeight, hmTemperatureTrap=hmTemperatureTrap, hmNetPTPAbsMaxOffset=hmNetPTPAbsMaxOffset, hmNetACDAddrTable=hmNetACDAddrTable, hmRelayIfaceOption82Enable=hmRelayIfaceOption82Enable, hmSerialNumBP=hmSerialNumBP, hmSysGroupType=hmSysGroupType, hmAction=hmAction, hmNetHiDiscoveryStatus=hmNetHiDiscoveryStatus, hmPortMonitorConditionCrcFragmentsIntfTable=hmPortMonitorConditionCrcFragmentsIntfTable, hmSysMaxPowerSupply=hmSysMaxPowerSupply, hmAutoDisReasons=hmAutoDisReasons, hmMACNotificationTrap=hmMACNotificationTrap, hmSysSelftestSysMon=hmSysSelftestSysMon, hmRMASrvSnmp=hmRMASrvSnmp, hmNetPTP2PortEntry=hmNetPTP2PortEntry, hmTrapDestCommIndex=hmTrapDestCommIndex, hmSysModFirstMauIndex=hmSysModFirstMauIndex, hmDuplicateStaticAddressTrap=hmDuplicateStaticAddressTrap, hmIGMPSnoopQuerierIPAddress=hmIGMPSnoopQuerierIPAddress, hmFSFileID=hmFSFileID, hmSysProduct=hmSysProduct, hmAutoconfigAdapterSerialNum=hmAutoconfigAdapterSerialNum, hmCpuResources=hmCpuResources, hmRelayServerAddr=hmRelayServerAddr, hmMulticast=hmMulticast, hmCpuRunningProcesses=hmCpuRunningProcesses, hmAuthCommName=hmAuthCommName, hmRelayGroup=hmRelayGroup, hmSFPTable=hmSFPTable, hmSigConSenseACARemoval=hmSigConSenseACARemoval, hmConfigurationStatus=hmConfigurationStatus, hmCurrentAddressEgressPorts=hmCurrentAddressEgressPorts, hmPNIODeviceTypeDetails=hmPNIODeviceTypeDetails, hmPortMonitorConditionOverloadDetectionUpperThresholdValue=hmPortMonitorConditionOverloadDetectionUpperThresholdValue, hmSigConSenseSRedNotGuaranteed=hmSigConSenseSRedNotGuaranteed, hmSigConSenseACANotInSync=hmSigConSenseACANotInSync, hmSfpTxPowerInt=hmSfpTxPowerInt, hmPlugAndPlay=hmPlugAndPlay, hmRS2FDBHashGroup=hmRS2FDBHashGroup, hmNetPTP2ObservedParentClockPhaseChangeRate=hmNetPTP2ObservedParentClockPhaseChangeRate, hmConfigWatchdogTimeInterval=hmConfigWatchdogTimeInterval, mach100=mach100, hmIndustrialEthernetProtocols=hmIndustrialEthernetProtocols, hmNetNTPSyncInterval=hmNetNTPSyncInterval, hmSigConSenseLinkFailure=hmSigConSenseLinkFailure, hmSfpRxPower=hmSfpRxPower, hmDevMonSensePS5State=hmDevMonSensePS5State, hmTrapDestTable=hmTrapDestTable, hmSysModSerialNum=hmSysModSerialNum, hmFSFileEntry=hmFSFileEntry, hmIGMPSnoopQueryPorts=hmIGMPSnoopQueryPorts, hmPOEModulePowerUsageOffNotification=hmPOEModulePowerUsageOffNotification, hmIfaceIngressLimiterRate=hmIfaceIngressLimiterRate, hmNetSNMPv3EncryptionReadOnlyStatus=hmNetSNMPv3EncryptionReadOnlyStatus, hmIGMPQuerierProtocolVersion=hmIGMPQuerierProtocolVersion, hmIfaceEgressLimiterRate=hmIfaceEgressLimiterRate, hmAgentSnmpTrapFlagsConfigGroup=hmAgentSnmpTrapFlagsConfigGroup, hmPortMonitorConditionLinkFlapIntfTable=hmPortMonitorConditionLinkFlapIntfTable, hmRS2TopologyGroup=hmRS2TopologyGroup, hmPOEModulePower=hmPOEModulePower, hmNetNTPStatusCode=hmNetNTPStatusCode, hmFSLogFileName=hmFSLogFileName, hmNetPTP2TimeSource=hmNetPTP2TimeSource, hmNetACDAddr=hmNetACDAddr, hmAgentSnmpCommunityIndex=hmAgentSnmpCommunityIndex, hmFSUserName=hmFSUserName, hmNeighbourAgentEntry=hmNeighbourAgentEntry, rs30=rs30, hmTrunkEntry=hmTrunkEntry, hmFSFileSize=hmFSFileSize, hmSfpID=hmSfpID, hmSigReasonIndex=hmSigReasonIndex, hmNetPTP2PortTable=hmNetPTP2PortTable, hmIGMPSnoopUnknownLookupResponseTime=hmIGMPSnoopUnknownLookupResponseTime, hmAutoDisReasonTable=hmAutoDisReasonTable, hmRS2TopologyTable=hmRS2TopologyTable, hmSysHttpsCertFingerPrintType=hmSysHttpsCertFingerPrintType, hmInterfaceExtTable=hmInterfaceExtTable, hmSfpPartNumber=hmSfpPartNumber, hmSysSwitchVLANLearningStatus=hmSysSwitchVLANLearningStatus, hmIfaceAcceptableFrameTypes=hmIfaceAcceptableFrameTypes, hmRelayServerAddrIndex=hmRelayServerAddrIndex, ms2108_2=ms2108_2, hmNTPTrap=hmNTPTrap, hmIGMPSnoopUnknownMode=hmIGMPSnoopUnknownMode, hmNetPTPSlavePort=hmNetPTPSlavePort, hmPNIOMgmtSEEErrorIDGroup=hmPNIOMgmtSEEErrorIDGroup, hmNetSNMPGroup=hmNetSNMPGroup, hmNetPTP2TwoStepClock=hmNetPTP2TwoStepClock)
mibBuilder.exportSymbols("HMPRIV-MGMT-SNMP-MIB", hmRS2ext=hmRS2ext, hmSigConConfigEntry=hmSigConConfigEntry, hmPNIONameOfStation=hmPNIONameOfStation, hmIGMPSnoopFilterTable=hmIGMPSnoopFilterTable, hmSigConLinkAlarm=hmSigConLinkAlarm, hmRS2VlanGroup=hmRS2VlanGroup, hmSigConSensePS1State=hmSigConSensePS1State, hmPOEModuleMaximumPower=hmPOEModuleMaximumPower, hmRS2ConnectionMirroringStatus=hmRS2ConnectionMirroringStatus, hmPOEPortTable=hmPOEPortTable, hmSerialNumM2=hmSerialNumM2, hmEtherNetIPProductName=hmEtherNetIPProductName, hmSfpConnector=hmSfpConnector, hmIGMPSnoopForwardAllStaticPorts=hmIGMPSnoopForwardAllStaticPorts, hmPrioTosToPrioEntry=hmPrioTosToPrioEntry, hmStandby=hmStandby, hmTrapDestTableEntriesMax=hmTrapDestTableEntriesMax, hmNetGPSIsSynchronized=hmNetGPSIsSynchronized, hmPrioMACAddressEnable=hmPrioMACAddressEnable, hmPrioTTPTos=hmPrioTTPTos, hmSysSwitchFDBHashOptimizingMode=hmSysSwitchFDBHashOptimizingMode, hmSysMaxFan=hmSysMaxFan, hmModuleMapChange=hmModuleMapChange, hmActionResult=hmActionResult, hmPOEModuleDeliveredPower=hmPOEModuleDeliveredPower, hmIGMPSnoopQueryStaticPorts=hmIGMPSnoopQueryStaticPorts, hmIngressUnknUcLimiterCalculationMode=hmIngressUnknUcLimiterCalculationMode, hmMemoryFree=hmMemoryFree, hmSfpRxPowerInt=hmSfpRxPowerInt, hmAutoConfigState=hmAutoConfigState, hmEtherNetIPProductCode=hmEtherNetIPProductCode, HmLargeDisplayString=HmLargeDisplayString, hmLEDMarGroup=hmLEDMarGroup, hmFan=hmFan, hmPortMonitorConditionSpeedDuplexMode=hmPortMonitorConditionSpeedDuplexMode, hmSysGroupTable=hmSysGroupTable, hmPSTable=hmPSTable, hmRelayLastDuplicateIP=hmRelayLastDuplicateIP, hmNetPTP2MeanPathDelay=hmNetPTP2MeanPathDelay, hmAuthHostIpMask=hmAuthHostIpMask, hmSysSelftestRebootOnHdxError=hmSysSelftestRebootOnHdxError, hmRelayOptionRemoteIDType=hmRelayOptionRemoteIDType, hmNetPTPPortEnable=hmNetPTPPortEnable, hmSigConSenseTemperature=hmSigConSenseTemperature, hmConfigWatchdogIPAddress=hmConfigWatchdogIPAddress, hmTrapCommCommIndex=hmTrapCommCommIndex, hmTrapCommDualHoming=hmTrapCommDualHoming, hmSelfTestResults=hmSelfTestResults, hmLEDRSRStandby=hmLEDRSRStandby, hmConfigurationSignature=hmConfigurationSignature, octopus=octopus, hmSysModVersion=hmSysModVersion, hmNetPTP2Priority1=hmNetPTP2Priority1, hmNetSNTPOnceAtStartup=hmNetSNTPOnceAtStartup, hmAgentSnmpPortSecurityTrapFlag=hmAgentSnmpPortSecurityTrapFlag, hmRS2DisableLearningGroup=hmRS2DisableLearningGroup, hmConfigWatchdogOperStatus=hmConfigWatchdogOperStatus, hmAUIPortSQETest=hmAUIPortSQETest, hmSysModAdminState=hmSysModAdminState, hmSysSwitchRedundancyRstpMrpMode=hmSysSwitchRedundancyRstpMrpMode, hmAgentSnmpTrapReceiverConfigTable=hmAgentSnmpTrapReceiverConfigTable, hmAgentCliBannerAdminStatus=hmAgentCliBannerAdminStatus, hmIngressUnknUcLimiterRate=hmIngressUnknUcLimiterRate, hmNetMacACDNotification=hmNetMacACDNotification, hmIngressUnknUcLimiterGroup=hmIngressUnknUcLimiterGroup, hmCurrentAddressStaticEgressPorts=hmCurrentAddressStaticEgressPorts, hmRS4RGroup=hmRS4RGroup, hmNetPTPGrandmasterUUID=hmNetPTPGrandmasterUUID, hmIGMPQuerierStatus=hmIGMPQuerierStatus, hmIGMPQuerierMode=hmIGMPQuerierMode, hmNetSNTPServer2=hmNetSNTPServer2, hmIfaceFlowControl=hmIfaceFlowControl, hmRMASrvHttp=hmRMASrvHttp, hmAuthHostIpAddress=hmAuthHostIpAddress, hmLEDMarRelay1=hmLEDMarRelay1, hmAgentSnmpL2RedundancyTrapFlag=hmAgentSnmpL2RedundancyTrapFlag, hmAgentSnmpConfigGroup=hmAgentSnmpConfigGroup, hmPrioTrafficClassEntry=hmPrioTrafficClassEntry, hmNetPTP2GrandmasterPriority2=hmNetPTP2GrandmasterPriority2, hmSysSwitchLearning=hmSysSwitchLearning, hmEgressLimiterGroup=hmEgressLimiterGroup, hmSigConMode=hmSigConMode, hmPNIOAdminStatus=hmPNIOAdminStatus, hmRelayIfaceDhcpRelayOperState=hmRelayIfaceDhcpRelayOperState, hmNetPTP2GrandmasterClockVariance=hmNetPTP2GrandmasterClockVariance, hmTemperature=hmTemperature, hmProfinetIOConfigGroup=hmProfinetIOConfigGroup, hmRS2SelftestResult=hmRS2SelftestResult, hmSysSelftestRebootOnErrorTrap=hmSysSelftestRebootOnErrorTrap, hmPortMonitorIntfAction=hmPortMonitorIntfAction, hmNetGPSTimeStringFormat=hmNetGPSTimeStringFormat, hmSfpPartRev=hmSfpPartRev, hmAUIPortID=hmAUIPortID, hmNetNTPOperation=hmNetNTPOperation, hmNetPTPPortBurstEnable=hmNetPTPPortBurstEnable, hmTrapGroup=hmTrapGroup, hmPrioTrafficClassID=hmPrioTrafficClassID, hmRS2ConnectionMirroringPortOne=hmRS2ConnectionMirroringPortOne, hmNetPTPleap61=hmNetPTPleap61, hmSystemTimeSource=hmSystemTimeSource, hmNetSNTPGroup=hmNetSNTPGroup, hmPortMonitorConditionSpeedDuplexValue=hmPortMonitorConditionSpeedDuplexValue, hmCurrentAddressEntry=hmCurrentAddressEntry, DIPSwitchState=DIPSwitchState, hmSfpInfoPartId=hmSfpInfoPartId, hmAgentSnmpLogSetSeverity=hmAgentSnmpLogSetSeverity, hmSfpMaxLength_fiber_9=hmSfpMaxLength_fiber_9, hmNetGPSIsAvailable=hmNetGPSIsAvailable, hmNetPTP2TCClockIdentity=hmNetPTP2TCClockIdentity, hmAutoDisIntfRemainingTime=hmAutoDisIntfRemainingTime, hmDevMonSensePS6State=hmDevMonSensePS6State, hmConfigWatchdogTimerValue=hmConfigWatchdogTimerValue, hmDevMonSensePS4State=hmDevMonSensePS4State, hmPOEFastStartup=hmPOEFastStartup, hmNetPTP2Group=hmNetPTP2Group, hmNetPTP2TCPortEntry=hmNetPTP2TCPortEntry, hmNetSNTPLocalOffset=hmNetSNTPLocalOffset, hmConfigurationSavedTrap=hmConfigurationSavedTrap, hmNetPTP2TCPowerTLVCheck=hmNetPTP2TCPowerTLVCheck, hmSelfTestMode=hmSelfTestMode, PTPTimeInterval=PTPTimeInterval, hmPNIODcpModeTable=hmPNIODcpModeTable, hmSysPlugAndPlay=hmSysPlugAndPlay, hmSysSwitchAddressRelearnDetection=hmSysSwitchAddressRelearnDetection, hmPrioTTPPrio=hmPrioTTPPrio, hmAuthCommTableEntriesMax=hmAuthCommTableEntriesMax, hmChassis=hmChassis, hmPortMonitorConditionCrcFragmentsIntfEntry=hmPortMonitorConditionCrcFragmentsIntfEntry, hmPortMonitorPortDisabledTrap=hmPortMonitorPortDisabledTrap, hmSysBOOTPEnable=hmSysBOOTPEnable, hmSysGroupModuleCapacity=hmSysGroupModuleCapacity, hmTrunkAdminStatus=hmTrunkAdminStatus, hmNetSNMPAccessStatus=hmNetSNMPAccessStatus, hmAgentSnmpTrapReceiverCommunityName=hmAgentSnmpTrapReceiverCommunityName, hmAgentSnmpCommunityMaxEntries=hmAgentSnmpCommunityMaxEntries, hmSysStpBPDUGuardEnable=hmSysStpBPDUGuardEnable, hmNetPTPEpochNumber=hmNetPTPEpochNumber, hmTrapCommState=hmTrapCommState, hmNetSNMPRadiusAuthenticate=hmNetSNMPRadiusAuthenticate, hmTrapDestIndex=hmTrapDestIndex, hmTrapDestState=hmTrapDestState, hmPortMonitorIntfReset=hmPortMonitorIntfReset, hmSysGroupModuleMap=hmSysGroupModuleMap, hmIfaceCapability=hmIfaceCapability, hmSigConConfigTable=hmSigConConfigTable, hmSfpInfoVersion=hmSfpInfoVersion, hmSysGroupActionResult=hmSysGroupActionResult, hmIfaceNextHopMacAddress=hmIfaceNextHopMacAddress, hmSysSwitchServiceModeOperState=hmSysSwitchServiceModeOperState, hmDevMonSenseModuleRemoval=hmDevMonSenseModuleRemoval, hmRelayIfaceDhcpRelayAdminState=hmRelayIfaceDhcpRelayAdminState, hmIGMPSnoopQueryVlanIndex=hmIGMPSnoopQueryVlanIndex, hmNetSNMPv3EncryptionReadWriteStatus=hmNetSNMPv3EncryptionReadWriteStatus, hmLEDRSRFault=hmLEDRSRFault, hmMemoryResources=hmMemoryResources, hmNetPTP2ParentStats=hmNetPTP2ParentStats, eagle_mguard=eagle_mguard, hmLastPort=hmLastPort, hmAUIPortEntry=hmAUIPortEntry, hmSfpSupported=hmSfpSupported, hmDevMonTrapCauseIndex=hmDevMonTrapCauseIndex, hmPortMonitorConditionCrcFragmentsCount=hmPortMonitorConditionCrcFragmentsCount, hmEthernetIPConfigGroup=hmEthernetIPConfigGroup, hmNetPTPCurrentUTCOffset=hmNetPTPCurrentUTCOffset, hmDIPSwitchRSRedundancyManager=hmDIPSwitchRSRedundancyManager, hmAgentSnmpTrapReceiverIPAddress=hmAgentSnmpTrapReceiverIPAddress, hmPrioTosToPrioTable=hmPrioTosToPrioTable, hmSfpVendorOUI=hmSfpVendorOUI, hmNetMacACDConflictAddress=hmNetMacACDConflictAddress, hmSysDHCPEnable=hmSysDHCPEnable, hmIGMPSnoopQueryStaticAutomaticPortsEnable=hmIGMPSnoopQueryStaticAutomaticPortsEnable, hmSysSwitchDuplexMismatchDetection=hmSysSwitchDuplexMismatchDetection, hmNetPTP2V1Compatibility=hmNetPTP2V1Compatibility, hmTrunkAction=hmTrunkAction, hmNetPTPEnable=hmNetPTPEnable, hmSfpGroupID=hmSfpGroupID, hmLEDRSRPowerSupply=hmLEDRSRPowerSupply, hmTrapCommBridge=hmTrapCommBridge, hmNetSNTPClientStatus=hmNetSNTPClientStatus, hmNetPTP2TimeTraceable=hmNetPTP2TimeTraceable, hmEtherNetIPCatalogName=hmEtherNetIPCatalogName, hmSignallingRelay=hmSignallingRelay, hmNetPTPClockStratum=hmNetPTPClockStratum, ms3124_4=ms3124_4, hmNetPTPConfiguration=hmNetPTPConfiguration, hmPortMonitorConditionOverloadDetectionLowerThresholdValue=hmPortMonitorConditionOverloadDetectionLowerThresholdValue, hmTrapCommLinkDown=hmTrapCommLinkDown, hmSysOEMID=hmSysOEMID, hmIfaceBcastLimit=hmIfaceBcastLimit, hmNetMacACDStatus=hmNetMacACDStatus, hmNetNTPServer2AddrType=hmNetNTPServer2AddrType, hmPNIOOrderID=hmPNIOOrderID, hmTempUprLimit=hmTempUprLimit, hmAUIModuleEntry=hmAUIModuleEntry, hmFanSysID=hmFanSysID, hmIGMPSnoopQueryStaticAutomaticPorts=hmIGMPSnoopQueryStaticAutomaticPorts, hmNetACDReleaseDelay=hmNetACDReleaseDelay, hmConfigWatchdogGroup=hmConfigWatchdogGroup, hmPNIODeviceID=hmPNIODeviceID, hmPortMonitorConditionSpeedDuplexEntry=hmPortMonitorConditionSpeedDuplexEntry, hmPortMonitorIntfMode=hmPortMonitorIntfMode, hmEthernetIPStatisticsGroup=hmEthernetIPStatisticsGroup, hmMACNotifyAdminState=hmMACNotifyAdminState, hmCurrentAddressReceivePort=hmCurrentAddressReceivePort, hmTrunkName=hmTrunkName, hmNetPTP2TCFaulty=hmNetPTP2TCFaulty, hmAuthHostTable=hmAuthHostTable, hmIGMPQuerierTransmitInterval=hmIGMPQuerierTransmitInterval, hmSysGroupSwVersion=hmSysGroupSwVersion, hmPortMonitorConditionIntfEntry=hmPortMonitorConditionIntfEntry, hmSysModStatus=hmSysModStatus, hmIfaceName=hmIfaceName, hmNetACDMAC=hmNetACDMAC, hmMACNotifyInterfaceMACStatus=hmMACNotifyInterfaceMACStatus, hmNetPPPBaseIPAddr=hmNetPPPBaseIPAddr, hmDevMonSensePS2State=hmDevMonSensePS2State, hmAutoconfigAdapterTrap=hmAutoconfigAdapterTrap, hmSelfTestM1Result=hmSelfTestM1Result, hmNetPTPClockMode=hmNetPTPClockMode, hmDevMonTrapEnable=hmDevMonTrapEnable, hmPortMonitorConditionLinkFlapCount=hmPortMonitorConditionLinkFlapCount, hmAutoDisGroup=hmAutoDisGroup, hmIfaceUtilizationControlInterval=hmIfaceUtilizationControlInterval, hmPortMonitorConditionCrcFragmentsMode=hmPortMonitorConditionCrcFragmentsMode, hmAutoDisReasonEntry=hmAutoDisReasonEntry, PTPSubdomainName=PTPSubdomainName, hmPrioMACAddress=hmPrioMACAddress, hmSysGroupEntry=hmSysGroupEntry, hmLastCommunity=hmLastCommunity, hmLEDRSRRedundancyManager=hmLEDRSRRedundancyManager, hmPNIOHardwareRelease=hmPNIOHardwareRelease, hmAgentSnmpTrapReceiverIndex=hmAgentSnmpTrapReceiverIndex, hmNetPTP2VlanPriority=hmNetPTP2VlanPriority, hmPNIONumActiveApplicationRelations=hmPNIONumActiveApplicationRelations, hmNetGPSMode=hmNetGPSMode, hmDIPSwitchMICERingPort=hmDIPSwitchMICERingPort, hmNetPTPStaticDrift=hmNetPTPStaticDrift, hmIGMPSnoopQueryStaticTable=hmIGMPSnoopQueryStaticTable, hmAgentSnmpCommunityName=hmAgentSnmpCommunityName, hmSysSelftestPortError=hmSysSelftestPortError, hmSysChassisName=hmSysChassisName, hmTempTable=hmTempTable, hmPortMonitorConditionOverloadDetectionIntfTable=hmPortMonitorConditionOverloadDetectionIntfTable, hmRS4RVlanPortID=hmRS4RVlanPortID, hmMACH3ChassisExt=hmMACH3ChassisExt, hmPSEntry=hmPSEntry, hmSysGroupIsolateMode=hmSysGroupIsolateMode, hmFSBootConfiguration=hmFSBootConfiguration, hmIfaceStpBpduGuardEnable=hmIfaceStpBpduGuardEnable, hmAgentLoginBanner=hmAgentLoginBanner, hmRMATable=hmRMATable, hmIfacePrioTOSEnable=hmIfacePrioTOSEnable, hmIGMPSnoopFilterLearntPorts=hmIGMPSnoopFilterLearntPorts, hmIGMPSnoop=hmIGMPSnoop)
mibBuilder.exportSymbols("HMPRIV-MGMT-SNMP-MIB", hmLEDRSRRelay1=hmLEDRSRRelay1, rs2_4r=rs2_4r, hmRS2SelftestGroup=hmRS2SelftestGroup, hmLEDOctPowerSupply1=hmLEDOctPowerSupply1, hmNetPTP2AnnounceReceiptTimeout=hmNetPTP2AnnounceReceiptTimeout, hmRS2ConnectionMirroringPortTwo=hmRS2ConnectionMirroringPortTwo, hmNetPTP2PortCapability=hmNetPTP2PortCapability, hmNetworkCpuIfUtilization=hmNetworkCpuIfUtilization, rs20=rs20, hmSigConSensePS3State=hmSigConSensePS3State, hmPSPowerBudget=hmPSPowerBudget, hmDevMonSensePS3State=hmDevMonSensePS3State, hmIGMPSnoopAgingTime=hmIGMPSnoopAgingTime, hmRelayOption82Status=hmRelayOption82Status, hmRS2ConfigError=hmRS2ConfigError, hmAgentSnmpLogGetRequest=hmAgentSnmpLogGetRequest, hmNetPTP2GrandmasterClockAccuracy=hmNetPTP2GrandmasterClockAccuracy, hmSelfTestCpuResult=hmSelfTestCpuResult, hmNetPTP2GrandmasterClockClass=hmNetPTP2GrandmasterClockClass, osb20=osb20, BridgeIdOrNull=BridgeIdOrNull, hmAutoDisIntfEntry=hmAutoDisIntfEntry, hmIfaceID=hmIfaceID, hmSigLinkAlarm=hmSigLinkAlarm, hmDevMonSensePS1State=hmDevMonSensePS1State, hmPortMonitorConditionOverloadDetectionMode=hmPortMonitorConditionOverloadDetectionMode, hmPortMonitorConditionLinkFlapGroup=hmPortMonitorConditionLinkFlapGroup, hmSigConSensePS5State=hmSigConSensePS5State, hmNetPTP2TCPeerMeanPathDelay=hmNetPTP2TCPeerMeanPathDelay, hmLEDMarPowerSupply=hmLEDMarPowerSupply, hmRS2FDBHashOptimizingStatus=hmRS2FDBHashOptimizingStatus, hmTrapCommColdStart=hmTrapCommColdStart, hmDevMonID=hmDevMonID, hmSerialNumBB=hmSerialNumBB, hmAuthHostState=hmAuthHostState, hmSysMaxUSBPorts=hmSysMaxUSBPorts, hmNetPTP2Configuration=hmNetPTP2Configuration, hmLEDMarFault=hmLEDMarFault, hmPNIODcpModePortID=hmPNIODcpModePortID, hmPOEStatus=hmPOEStatus, hmAuthHostCommIndex=hmAuthHostCommIndex, hmSFPChangeTrap=hmSFPChangeTrap, hmSigConSenseRedNotGuaranteed=hmSigConSenseRedNotGuaranteed, hmNetPTPPortID=hmNetPTPPortID, hmGMRP=hmGMRP, hmRelayServerAddrTable=hmRelayServerAddrTable, ms4128_5=ms4128_5, hmRelayServerGroup=hmRelayServerGroup, hmNetPTPleap59=hmNetPTPleap59, rs2_16=rs2_16, hmNetPTP2TCVlanID=hmNetPTP2TCVlanID, hmAutoconfigAdapterStatus=hmAutoconfigAdapterStatus, hmSelfTestBBResult=hmSelfTestBBResult, hmTempLwrLimit=hmTempLwrLimit, hmIGMPSnoopFilterVlanIndex=hmIGMPSnoopFilterVlanIndex, hmPrioMACStatus=hmPrioMACStatus, hmRelayIfaceGroupID=hmRelayIfaceGroupID, hmSysGroupActionDelayCurrent=hmSysGroupActionDelayCurrent, hmRS4RVlanPortEntry=hmRS4RVlanPortEntry, hmSysMaxTrunks=hmSysMaxTrunks, hmRelayPktClientRelayCnt=hmRelayPktClientRelayCnt, hmProfinetIOStatisticsGroup=hmProfinetIOStatisticsGroup, hmIfaceUtilization=hmIfaceUtilization, hmAgentSnmpCommunityIPMask=hmAgentSnmpCommunityIPMask, hmIEC61850StatisticsGroup=hmIEC61850StatisticsGroup, hmRMAIpAddr=hmRMAIpAddr, hmNetPTPParentUUID=hmNetPTPParentUUID, hmNetPTP2GrandmasterClockQuality=hmNetPTP2GrandmasterClockQuality, hmIEC61850MMSServerTechnicalKey=hmIEC61850MMSServerTechnicalKey, hmIfaceAction=hmIfaceAction, hmRMAIndex=hmRMAIndex, hmPSDescription=hmPSDescription, hmProducts=hmProducts, hmNetSNTPServerStatus=hmNetSNTPServerStatus, hmNetSNTPServerOnlyIfSync=hmNetSNTPServerOnlyIfSync, hmIGMPSnoopForwardAllTable=hmIGMPSnoopForwardAllTable, hmMACNotifyInterfaceAdminState=hmMACNotifyInterfaceAdminState, hmRelayDuplicateIPTrap=hmRelayDuplicateIPTrap, hmNetPTP2TCManagement=hmNetPTP2TCManagement, hmSigConSensePS7State=hmSigConSensePS7State, hmAgentSnmpChassisTrapFlag=hmAgentSnmpChassisTrapFlag, hmFSRunningConfiguration=hmFSRunningConfiguration, hmAgentLoginGroup=hmAgentLoginGroup, hmConfiguration=hmConfiguration, hmIfaceStpBpduGuardStatus=hmIfaceStpBpduGuardStatus, hmSfpMaxLength_copper=hmSfpMaxLength_copper, hmPortMonitorConditionCrcFragmentsGroup=hmPortMonitorConditionCrcFragmentsGroup, hmNetMask=hmNetMask, hmRelayErrCnt=hmRelayErrCnt, eem1=eem1, hmNetPTP2TCSyncLocalClock=hmNetPTP2TCSyncLocalClock, hmSfpMaxLength_fiber_50=hmSfpMaxLength_fiber_50, hmLEDRSRRelay2=hmLEDRSRRelay2, hmSelftestError=hmSelftestError, hmSigLinkID=hmSigLinkID, PTPPortIdentity=PTPPortIdentity, hmNetPTP2TCPrimaryDomain=hmNetPTP2TCPrimaryDomain, LEDState=LEDState, mach4002_48_4G=mach4002_48_4G, hmIfaceIngressLimiterMode=hmIfaceIngressLimiterMode, hmDIPSwitchRSStandby=hmDIPSwitchRSStandby, hmTrapCommAuthentication=hmTrapCommAuthentication, hmPortMonitorConditionOverloadDetectionIntfEntry=hmPortMonitorConditionOverloadDetectionIntfEntry, hmSysSwitchServiceVlan=hmSysSwitchServiceVlan, hmNetPTP2DomainNumber=hmNetPTP2DomainNumber, hmRS2OperMode=hmRS2OperMode, hmAgentSnmpBroadcastStormTrapFlag=hmAgentSnmpBroadcastStormTrapFlag, hmEtherNetIPConnTimeouts=hmEtherNetIPConnTimeouts, hmFanTable=hmFanTable, hmNetNTPAnycastInterval=hmNetNTPAnycastInterval, hmConfigWatchdogAdminStatus=hmConfigWatchdogAdminStatus, hmSysSwitchFDBHashOptimizingStatus=hmSysSwitchFDBHashOptimizingStatus, HmAgentLogSeverity=HmAgentLogSeverity, hmNetPTPPortTable=hmNetPTPPortTable, hmFSTPPassword=hmFSTPPassword, hmRS2DisableLearningStatus=hmRS2DisableLearningStatus, mach100ge=mach100ge, hmFSAction=hmFSAction, hmNetPTP2TCPortEnable=hmNetPTP2TCPortEnable, hmNetPTPGroup=hmNetPTPGroup, hmMACNotifyMibObjects=hmMACNotifyMibObjects, hmInterfaceEntry=hmInterfaceEntry, hmSigConManualActivate=hmSigConManualActivate, hmFSFileName=hmFSFileName, hmSigConLinkID=hmSigConLinkID, hmFSUpdFileName=hmFSUpdFileName, hmAUIPortTable=hmAUIPortTable, hmNetPTPPiIntegral=hmNetPTPPiIntegral, hmNetPTPPreferredMaster=hmNetPTPPreferredMaster, hmIGMPSnoopQueryStaticVlanIndex=hmIGMPSnoopQueryStaticVlanIndex, hmDevMonSenseLinkFailure=hmDevMonSenseLinkFailure, hmNetPTP2ClockIdentity=hmNetPTP2ClockIdentity, hmTrunkLastChange=hmTrunkLastChange, hmTrapCommRMON=hmTrapCommRMON, hmAgentSnmpTrapReceiverStatus=hmAgentSnmpTrapReceiverStatus, hmDevMonSwitchState=hmDevMonSwitchState, hmSysGroupMap=hmSysGroupMap, hmNetHiDiscoveryGroup=hmNetHiDiscoveryGroup, hmNetPTP2CurrentUtcOffset=hmNetPTP2CurrentUtcOffset, hmFSTable=hmFSTable, hmSigConSenseModuleRemoval=hmSigConSenseModuleRemoval, eagleone=eagleone, hmSerialNumbers=hmSerialNumbers, hmNetHiDiscoveryRelay=hmNetHiDiscoveryRelay, hmNetPTPOneWayDelayNanoSecs=hmNetPTPOneWayDelayNanoSecs, hmMACNotifyInterfaceMACAddr=hmMACNotifyInterfaceMACAddr, hmSysModGroupID=hmSysModGroupID, hmSysSwitchRedundancyRstpMrpConfigError=hmSysSwitchRedundancyRstpMrpConfigError, hmIGMPSnoopQuerierToPortmask=hmIGMPSnoopQuerierToPortmask, hmSfpInfoPartNumber=hmSfpInfoPartNumber, hmIfaceTrunkID=hmIfaceTrunkID, hmSfpTxPowerdBm=hmSfpTxPowerdBm, hmLEDRSPowerSupply=hmLEDRSPowerSupply, hmLastLoginUserName=hmLastLoginUserName, hmCpuUtilization=hmCpuUtilization, hmSfpDateCode=hmSfpDateCode, hmNetACDGroup=hmNetACDGroup, hmTrapCommIndex=hmTrapCommIndex, hmIGMPSnoopForwardAllVlanIndex=hmIGMPSnoopForwardAllVlanIndex, hmAutoDisIntfComponentName=hmAutoDisIntfComponentName, hmSerialNumCpu=hmSerialNumCpu, hmNetSNTPAnycastAddr=hmNetSNTPAnycastAddr, hmAuthGroup=hmAuthGroup, hmNetPTPIsSynchronized=hmNetPTPIsSynchronized, hmChassisEvent=hmChassisEvent, ms20=ms20, hmNetPTPOffsetFromMasterNanoSecs=hmNetPTPOffsetFromMasterNanoSecs, hmDevMonSenseACANotInSync=hmDevMonSenseACANotInSync, hmPOEGlobalGroup=hmPOEGlobalGroup, hmEtherNetIPErrorCode=hmEtherNetIPErrorCode, hmRS2SigRelayMode=hmRS2SigRelayMode, hmSysSelftestRebootOnError=hmSysSelftestRebootOnError, hmPNIOModuleIdentNumber=hmPNIOModuleIdentNumber, hmIGMPQuerierMaxResponseTime=hmIGMPQuerierMaxResponseTime, hmSigConOperState=hmSigConOperState, hmNetACDTimeMark=hmNetACDTimeMark, hmSigConLinkTable=hmSigConLinkTable, hmSfpTransceiver=hmSfpTransceiver, hmRS4RVlanPortTagFormatRstp=hmRS4RVlanPortTagFormatRstp, hmFanID=hmFanID, hmNetLocalPhysAddrRange=hmNetLocalPhysAddrRange, hmInterfaceTable=hmInterfaceTable, hmPortMonitorConditionLinkFlapCountTotal=hmPortMonitorConditionLinkFlapCountTotal, hmNetPTP2TCSyntonized=hmNetPTP2TCSyntonized, hmPowerSupply=hmPowerSupply, hmSerialNumM1=hmSerialNumM1, hmMACNotifyInterval=hmMACNotifyInterval, hmNetPTP2VersionNumber=hmNetPTP2VersionNumber, hmSysSwitchMRU=hmSysSwitchMRU, hmRS2SigRelayManualState=hmRS2SigRelayManualState, hmRS2FDBHashOptimizingMode=hmRS2FDBHashOptimizingMode, hmIfaceGroupID=hmIfaceGroupID, hmNetVlanID=hmNetVlanID, hmLEDOctGroup=hmLEDOctGroup, hmRMASrvSsh=hmRMASrvSsh, hmAUIGroup=hmAUIGroup, hmAUIModuleID=hmAUIModuleID, hmNetworkCpuIfAverageUtilization=hmNetworkCpuIfAverageUtilization, hmNetPTP2ParentPortIdentity=hmNetPTP2ParentPortIdentity, hmPSVersion=hmPSVersion, hmIGMPSnoopQueryTable=hmIGMPSnoopQueryTable, hmPortMonitorConditionCrcFragmentsInterval=hmPortMonitorConditionCrcFragmentsInterval, hmSysHttpsEnable=hmSysHttpsEnable, hmNetPTP2LogAnnounceInterval=hmNetPTP2LogAnnounceInterval, hmAgentSnmpMultipleUsersTrapFlag=hmAgentSnmpMultipleUsersTrapFlag, hmPNIOOrderID9th=hmPNIOOrderID9th, gecko=gecko, hmPrioMACPriority=hmPrioMACPriority, hmNetPTP2FrequencyTraceable=hmNetPTP2FrequencyTraceable, hmSystemTable=hmSystemTable, hmRS2VlanMode=hmRS2VlanMode, hmFSLastMessage=hmFSLastMessage, hmRelayServerRowStatus=hmRelayServerRowStatus, hmPortMonitorConditionLinkFlapMode=hmPortMonitorConditionLinkFlapMode, hmAutoDisIntfErrorReason=hmAutoDisIntfErrorReason, hmRelayServerAddrEntry=hmRelayServerAddrEntry, hmInterfaceExtEntry=hmInterfaceExtEntry, hmTrunkInterfaces=hmTrunkInterfaces, hmSfpVendorName=hmSfpVendorName, hmAuthHostEntry=hmAuthHostEntry, hmTrapDestIpMask=hmTrapDestIpMask, ruggedswitch=ruggedswitch, hmPOEPortMaxConsumptionPower=hmPOEPortMaxConsumptionPower, hmAgentSnmpCommunityStatus=hmAgentSnmpCommunityStatus, hmSigConSensePS2State=hmSigConSensePS2State, hmDevMonStateChange=hmDevMonStateChange, hmTrapDestEntry=hmTrapDestEntry, hmSysTelnetEnable=hmSysTelnetEnable)
