#
# PySNMP MIB module RADLAN-QOS-CLI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radlan/RADLAN-QOS-CLI-MIB
# Produced by pysmi-1.1.8 at Fri Jan  7 15:37:02 2022
# On host fv-az42-180 platform Linux version 5.11.0-1022-azure by user runner
# Using Python version 3.10.1 (main, Dec 14 2021, 13:12:05) [GCC 9.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
Percents, rnd = mibBuilder.importSymbols("RADLAN-MIB", "Percents", "rnd")
RowStatus, TruthValue, RowPointer = mibBuilder.importSymbols("RADLAN-SNMPv2", "RowStatus", "TruthValue", "RowPointer")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Counter64, iso, ObjectIdentity, ModuleIdentity, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Bits, Unsigned32, IpAddress, NotificationType, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "iso", "ObjectIdentity", "ModuleIdentity", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Bits", "Unsigned32", "IpAddress", "NotificationType", "Integer32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
rlQosCliMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 88))
rlQosCliMib.setRevisions(('2005-03-14 00:00', '2005-02-07 00:00', '2005-01-27 00:00', '2004-11-15 00:00', '2003-09-29 00:00', '2003-09-21 00:00', '2005-04-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlQosCliMib.setRevisionsDescriptions(('Add rlQosPortRateLimitStatus,rlQosCirPortRateLimit, rlQosCbsPortRateLimit\n                  to   rlQosIfPolicyTable', 'Add vpt,ether-type,tcp-flags,icmp-type,icmp-code,igmp-type to ClassTupleType\n                 Add mac-Offset,ip-ICMP,ip-IGMP To AceObjectType\n                 Add vpt,ethertype To ClassOffsetType', 'Add new advanced action : trustCosDscp', 'Add DSCP to Queue Default map table.', 'Add textual convention to QosObjectMode (service).', 'Added this MODULE-IDENTITY clause, changed IMPORT, removed ranges in\n                 SEQUENCE elements, changed access of rlQosCliQosMode, rlQosCliBasicModeCfg and\n                 rlQosMaxNumOfAce.', 'Added rlQosDscpToDpTable',))
if mibBuilder.loadTexts: rlQosCliMib.setLastUpdated('200503140000Z')
if mibBuilder.loadTexts: rlQosCliMib.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rlQosCliMib.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlQosCliMib.setDescription('The private MIB module definition for Quality Of Service CLI\n                 in Radlan devices.')
class ClassOffsetType(TextualConvention, Integer32):
    description = 'Specifies one of 6 offset types:\n         1- Absolute-start of the packet.\n         2- Layer 2-start of MAC header.\n         3- MPLS-start of MPLS header.\n         4- Layer 3-start of layer 3 header.\n         5- Layer 4-start of layer 4 header.\n         6- Layer 5-after TCP/UDP header.\n         7- VLAN.\n         8- input device port.\n         9- input device port.\n         10-VPT.\n         11-EtherType.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("packetStart", 1), ("layer2-start", 2), ("mpls-start", 3), ("layer3-start", 4), ("layer4-start", 5), ("layer5-start", 6), ("vlan", 7), ("in-port", 8), ("out-port", 9), ("vpt", 10), ("ethertype", 11))

class ClassTupleType(TextualConvention, Integer32):
    description = 'Specifies one of Tuple types '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))
    namedValues = NamedValues(("protocol", 1), ("ip-src", 2), ("ip-dest", 3), ("dscp", 4), ("ip-precedence", 5), ("udp-port-src", 6), ("udp-port-dest", 7), ("tcp-port-src", 8), ("tcp-port-dest", 9), ("mac-src", 10), ("mac-dest", 11), ("vlan", 12), ("in-port", 13), ("out-port", 14), ("general", 15), ("vpt", 16), ("ether-type", 17), ("tcp-flags", 18), ("icmp-type", 19), ("icmp-code", 20), ("igmp-type", 21))

class AceActionType(TextualConvention, Integer32):
    description = 'Specifies one of 3 ACE Actions:\n         1- Permit- permit to the traffic that define\n                by the parameters.\n         2- Deny- deny the traffic that define\n                by the parameter.\n         3- Deny- deny the traffic that define\n                by the parameters and disable the port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("permit", 1), ("deny", 2), ("deny-DisablePort", 3))

class AceObjectType(TextualConvention, Integer32):
    description = 'Specifies one of 8 ACE types:\n        1- IP ACE.\n        2- IP-TCP ACE.\n        3- IP-UDP ACE.\n        4- IP-offset ACE.\n        5- MAC ACE.\n        6- MAC-offset ACE.\n        7- IP-ICMP ACE.\n        8- IP-IGMP ACE.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("ip", 1), ("ip-TCP", 2), ("ip-UDP", 3), ("ip-Offset", 4), ("mac", 5), ("mac-Offset", 6), ("ip-ICMP", 7), ("ip-IGMP", 8))

class AclObjectType(TextualConvention, Integer32):
    description = 'Specifies one of 2 ACL types:\n         1- MAC ACL.\n         2- IP ACL'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("mac", 1), ("ip", 2))

class ClassMapType(TextualConvention, Integer32):
    description = 'Specifies one of 2 Class-map types:\n        1- Match all. logical and between all statements.\n        2- Match any. logical or between all statements.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("matchAll", 1), ("matchAny", 2))

class ClassMapAction(TextualConvention, Integer32):
    description = 'Specifies one of 8 Class-map actios:\n         1- no action.\n         2- Mark IP-Precedence.\n         3- Mark DSCP.\n         4- Set Egress queueu\n         5- Mark VPT\n         6- Choose queue by the VPT.\n         7- Choose queue by the DSCP.\n         8- Choose queue by the TCP/UDP port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))
    namedValues = NamedValues(("none", 1), ("setIP-Precedence", 2), ("setDSCP", 3), ("setQueue", 4), ("setCos", 5), ("trustCos", 6), ("trustDSCP", 7), ("trustTCP-UDPport", 8), ("trustCosDscp", 9))

class PolicerType(TextualConvention, Integer32):
    description = 'Specifies one of 3 Policer types:\n         1- Single policer only per one class map.\n         2- Aggregate policer can be applied to several\n            class maps.\n         3- Cascade policer.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("single", 1), ("aggregate", 2), ("cascade", 3))

class PolicerAction(TextualConvention, Integer32):
    description = 'Specifies one of 4 Policer Action:\n         1- No Action\n         2- Drop out of profile packets.\n         3- Remark out of profile packets.\n         4- Remark to explicit value out of profile packets\n         5- this policer is part of cascade chain'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("drop", 2), ("remark", 3), ("explicit-remark", 4), ("cascadePointer", 5))

class QosObjectMode(TextualConvention, Integer32):
    description = 'Specifies one of 3 QoS mode:\n         1- disable no QoS on the system\n         2- Basic Qos mode only trust mode with ACL are enabled.\n         3- Advance mode all Qos option are enabled.\n         4- Service Mode all Qos option are enabled only in\n            service mode configuration'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("disable", 1), ("basic", 2), ("advance", 3), ("service", 4))

class QosObjectBasicMode(TextualConvention, Integer32):
    description = 'Specifies one of 6 QoS Basic mode:\n         1- none. means that only ACL can be applied.\n         2- 802.1p. queue is set by the VPT field.\n         3- DSCP. queue is set by the DSCP field\n         4- DSCP-Mutation. the DSCP mutate in the ingress and\n            then the queue is set by the DSCP\n         5- TCP/UDP. the queue is set by the port number '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("vpt", 2), ("dscp", 3), ("dscp-mutation", 4), ("tcp-udp", 5))

class BinaryStatus(TextualConvention, Integer32):
    description = 'Specifies Disable or enable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disable", 1), ("enable", 2))

class QueueType(TextualConvention, Integer32):
    description = 'Queue type Ef or WRR.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ef", 1), ("wrr", 2))

class AclDefaultAction(TextualConvention, Integer32):
    description = 'Default action when the ACL reach end point.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("deny-all", 1), ("forward-all", 2))

class InterfaceType(TextualConvention, Integer32):
    description = 'Interface type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("vlan", 1), ("port", 2))

rlQosCliQosMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 1), QosObjectMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosCliQosMode.setStatus('current')
if mibBuilder.loadTexts: rlQosCliQosMode.setDescription('This scalar define in which mode the\n         system will work: basic , advance or none.')
rlQosCliBasicModeCfg = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 2), QosObjectBasicMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosCliBasicModeCfg.setStatus('current')
if mibBuilder.loadTexts: rlQosCliBasicModeCfg.setDescription('This scalar define in which Basic mode the\n                 system will work:802.1p or DSCP or\n                 DSCP-Mutation or TCP/UDP or none.')
rlQosMaxNumOfAce = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosMaxNumOfAce.setStatus('current')
if mibBuilder.loadTexts: rlQosMaxNumOfAce.setDescription('This scalar define in which Basic mode the\n                 system will work:802.1p or DSCP or\n                 DSCP-Mutation or TCP/UDP or none.')
rlQosOffsetTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 4), )
if mibBuilder.loadTexts: rlQosOffsetTable.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetTable.setDescription('This table specifies Offset Table information')
rlQosOffsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 4, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosOffsetIndex"))
if mibBuilder.loadTexts: rlQosOffsetEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetEntry.setDescription('Each entry in this table describes one classifier field.\n        The information includes: Offset Type the offset the mask and the\n        Pattern.\n        if the type is vlan then the value will be the vlan tag.\n        if the Type is in/out port it will be the device in/out port.\n        The index is sequential integer represent by rlQosOffsetIndex')
rlQosOffsetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosOffsetIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetIndex.setDescription('An arbitrary incremental Index\n         for the offset table.')
rlQosOffsetType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 2), ClassOffsetType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetType.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetType.setDescription('Start of the offset.')
rlQosOffsetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetValue.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetValue.setDescription('The Offset value.')
rlQosOffsetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetMask.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetMask.setDescription('Define which bit to be extracted from the offset.')
rlQosOffsetPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetPattern.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetPattern.setDescription('The value to match too.')
rlQosOffsetTuplePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetTuplePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetTuplePointer.setDescription('Pointer for the relevant Tuple.')
rlQosOffsetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosOffsetStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosTupleTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 5), )
if mibBuilder.loadTexts: rlQosTupleTable.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleTable.setDescription('This table specifies Tuple Table information')
rlQosTupleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 5, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosTupleIndex"))
if mibBuilder.loadTexts: rlQosTupleEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleEntry.setDescription('Each entry in this table describes one Tuple.\n        The information includes: Tuple Type and the Tuples values.\n        The index is sequential integer represent by rlQosTupleIndex')
rlQosTupleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosTupleIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleIndex.setDescription('An arbitrary incremental Index\n         for the offset table.')
rlQosTupleType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 2), ClassTupleType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleType.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleType.setDescription('Start of the offset.')
rlQosTupleValue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleValue1.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleValue1.setDescription('The Tuple no.1 value can be regular integer\n         values only.')
rlQosTupleValue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleValue2.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleValue2.setDescription('The Tuple no.2 value can be IP/MAC address\n         or protocol number with mask')
rlQosTupleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosAceTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 6), )
if mibBuilder.loadTexts: rlQosAceTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTable.setDescription('This table specifies ACE table information')
rlQosAceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 6, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAceIndex"))
if mibBuilder.loadTexts: rlQosAceEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAceEntry.setDescription("Each entry in this table describes one Classifier Element.\n        The information includes: Action the ACE's Type the up to 8 tuples\n        pointers. The index is sequential integer represent by rlQosAceIndex")
rlQosAceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAceIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceIndex.setDescription('An arbitrary incremental Index\n         for the ACE table.')
rlQosAceAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 2), AceActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAceAction.setDescription('ACE Action to take.')
rlQosAceType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 3), AceObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceType.setStatus('current')
if mibBuilder.loadTexts: rlQosAceType.setDescription('ACE Type')
rlQosAceTuple1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple1.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple1.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple2.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple2.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple3.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple3.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple4.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple4.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple5.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple5.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple6.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple6.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple7.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple7.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple8.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple8.setDescription('ACE Tuple 1 pointer.')
rlQosAceAccount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 12), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceAccount.setStatus('current')
if mibBuilder.loadTexts: rlQosAceAccount.setDescription("ACE Accounting state.\n         When set to 'enabled' than appropriate statistic's\n         counter is provided for an ACE.\n         For Broadcom ASICs this counter shows number of\n         matched with ACE criteria packets.\n         For Marvell ASICs TBD.")
rlQosAceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAceStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosAclTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 7), )
if mibBuilder.loadTexts: rlQosAclTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclTable.setDescription('This table specifies ACL table information')
rlQosAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 7, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclIndex"))
if mibBuilder.loadTexts: rlQosAclEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclEntry.setDescription('Each entry in this table describes one Classifier Element.\n         The information includes: Action and the row status. The ACE pointer\n         are in the ACL-ACE reference table.\n         The index is sequential integer represent by rlQosAceIndex')
rlQosAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclIndex.setDescription('An arbitrary incremental Index\n                 for the ACE table.')
rlQosAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclName.setStatus('current')
if mibBuilder.loadTexts: rlQosAclName.setDescription('Name ACL.')
rlQosAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 3), AclObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclType.setStatus('current')
if mibBuilder.loadTexts: rlQosAclType.setDescription('ACL Type.')
rlQosAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAclStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosAclAceRefTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 8), )
if mibBuilder.loadTexts: rlQosAclAceRefTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefTable.setDescription('This table specifies the ACE to ACL\n         relationship.')
rlQosAclAceRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 8, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclAceRefAcePointer"))
if mibBuilder.loadTexts: rlQosAclAceRefEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefEntry.setDescription('Each entry in this table describes the relationship\n         between ACE to ACL. Show which ACE include in one ACL.\n         The index is the ACE pointer represent\n         by rlQosAclAceRefAcePointer')
rlQosAclAceRefAcePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAclAceRefAcePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefAcePointer.setDescription('The Index is the ACE pointer')
rlQosAclAceRefAclPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclAceRefAclPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefAclPointer.setDescription('ACL index Pointer')
rlQosAclAceRefStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclAceRefStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosClassMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 9), )
if mibBuilder.loadTexts: rlQosClassMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapTable.setDescription('This table specifies CCL table information')
rlQosClassMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 9, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosClassMapIndex"))
if mibBuilder.loadTexts: rlQosClassMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapEntry.setDescription('Each entry in this table describes one Class Map Element.\n        The information includes: Classes Name,Class Action,\n        Policer pointer, and 1 match statements.\n        The index is sequential integer represent by rlQosClassMapIndex')
rlQosClassMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosClassMapIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapIndex.setDescription('Class Map Index')
rlQosClassMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapName.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapName.setDescription('Name of the Class Map.')
rlQosClassMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 3), ClassMapType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapType.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapType.setDescription('Class map type')
rlQosClassMapAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 4), ClassMapAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapAction.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapAction.setDescription('Class Map Action.')
rlQosClassMapMarkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMarkValue.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMarkValue.setDescription('Mark value when mark action has been chosen in\n         Class Map Action field.')
rlQosClassMapPolicer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapPolicer.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapPolicer.setDescription('Policer  pointer. 0-means no policer.')
rlQosClassMapMatch1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMatch1.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMatch1.setDescription('Match ACL 1 pointer.')
rlQosClassMapMatch2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMatch2.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMatch2.setDescription('Match ACL 2 pointer.')
rlQosClassMapMarkVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 9), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMarkVlan.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMarkVlan.setDescription("If 'enabled', than the classified\n         traffic will be remarked with new VLAN id.\n         If 'disabled' VLAN id is not changed.")
rlQosClassMapNewVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapNewVlan.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapNewVlan.setDescription("If rlQosClassMapMarkVlan 'enabled',\n         than the classified traffic will be\n         remarked with new VLAN id.\n         The value of this field sets new VLAN id.")
rlQosClassMapNewPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapNewPort.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapNewPort.setDescription('If value not zero, than the classified\n         traffic will be redirected to the new\n         egress physical port. The value of this\n         field sets new egress port.')
rlQosClassMapCopyPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapCopyPort.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapCopyPort.setDescription('If value not zero, than the classified\n         traffic will be copied to the desination\n         copy port. The value of this field sets\n         desination copy port.')
rlQosClassMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosPolicerTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 10), )
if mibBuilder.loadTexts: rlQosPolicerTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerTable.setDescription('This table specifies All the Policers in the system Information')
rlQosPolicerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 10, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicerIndex"))
if mibBuilder.loadTexts: rlQosPolicerEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerEntry.setDescription('Each entry in this table describes one policer.\n        The information includes: Policer name, Policer type, Committed Rate,\n        Committed Burst, Out-of-Profile Action.\n        The index is sequential integer represent by rlQosPolicerIndex')
rlQosPolicerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicerIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerIndex.setDescription('Policer Index.')
rlQosPolicerName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerName.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerName.setDescription('Name of the Policer.')
rlQosPolicerType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 3), PolicerType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerType.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerType.setDescription('Policer type')
rlQosPolicerCir = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 4), Unsigned32()).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCir.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCir.setDescription('Committed rate value.')
rlQosPolicerCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 5), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCbs.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCbs.setDescription('Committed rate Value.')
rlQosPolicerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 6), PolicerAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerAction.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerAction.setDescription('Out of profile Action.')
rlQosPolicerCasPointerRemVal = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCasPointerRemVal.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCasPointerRemVal.setDescription('Pointer to use whan the type is\n         cascade policer. 0-means no cascade policer. It can also be\n         Remark value in case of explicit remark')
rlQosPolicerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosPolicyMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 11), )
if mibBuilder.loadTexts: rlQosPolicyMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapTable.setDescription('This table specifies Policy Map Table Information')
rlQosPolicyMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 11, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyMapIndex"))
if mibBuilder.loadTexts: rlQosPolicyMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapEntry.setDescription('Each entry in this table describes one policy map.\n        The information includes: Index, Policy Map name,\n        Up to 6 class map names.\n        The index is sequential integer represent by rlQosPolicerIndex')
rlQosPolicyMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicyMapIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapIndex.setDescription('Policy map Index.')
rlQosPolicyMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyMapName.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapName.setDescription('Policy map Name.')
rlQosPolicyMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosPolicyClassRefTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 12), )
if mibBuilder.loadTexts: rlQosPolicyClassRefTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefTable.setDescription('This table specifies The relationship\n         between policy map to class map')
rlQosPolicyClassRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 12, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyClassRefClassPointer"))
if mibBuilder.loadTexts: rlQosPolicyClassRefEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefEntry.setDescription('Each entry in this table describes the connection\n         between class-map entry to policy map by using pointers.\n         The index is Class map pointer\n         represent by rlQosPolicyClassRefClassPointer')
rlQosPolicyClassRefClassPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicyClassRefClassPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefClassPointer.setDescription('The Index is the Class-map pointer')
rlQosPolicyClassRefPolicyPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassRefPolicyPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefPolicyPointer.setDescription('Policy map index Pointer')
rlQosPolicyClassRefStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassRefStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosIfPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 13), )
if mibBuilder.loadTexts: rlQosIfPolicyTable.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyTable.setDescription('This table specifies for each interface\n                        the Policy Map attach to it')
rlQosIfPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 13, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlIfType"))
if mibBuilder.loadTexts: rlQosIfPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyEntry.setDescription('Each entry in this table describes what policy\n         Map attached to specific Interface.\n         The index is Interface Index represent by rlIfIndex and\n         the interface type represent by rlIfType')
rlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIfIndex.setDescription('Interface Index.')
rlIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 2), InterfaceType())
if mibBuilder.loadTexts: rlIfType.setStatus('current')
if mibBuilder.loadTexts: rlIfType.setDescription('Interface Type(vlan/port).')
rlQosIfPolicyMapPointerIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerIn.setDescription('Policy map pointer Input.')
rlQosIfPolicyMapPointerOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerOut.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerOut.setDescription('Policy map pointer Output.')
rlQosIfTrustActive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 5), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfTrustActive.setStatus('current')
if mibBuilder.loadTexts: rlQosIfTrustActive.setDescription('Interface Basic Mode Trust is active or not .')
rlQosPortShaperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 6), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPortShaperStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPortShaperStatus.setDescription('If there is shaper on the port')
rlQosCirPortShaper = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 7), Integer32()).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirPortShaper.setStatus('current')
if mibBuilder.loadTexts: rlQosCirPortShaper.setDescription('The CIR for the port shaper.\n         N/A when the shper is disabled')
rlQosCbsPortShaper = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 8), Integer32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsPortShaper.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsPortShaper.setDescription('The CBS for the port shaper.\n         N/A when the shper is disabled')
rlQosIfProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfilePointer.setDescription('Interface Profile name pointer.')
rlQosQueueProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfilePointer.setDescription(' Queue Profile name pointer.')
rlQosQueueShapeProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueShapeProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfilePointer.setDescription(' Queue shape Profile pointer.')
rlQosAclDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 12), AclDefaultAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclDefaultAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAclDefaultAction.setDescription(' When one ACL is enterd then what to do for the last rull.')
rlQosIfPolicyMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosIfAclIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfAclIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfAclIn.setDescription('Index of an ACL in the rlQosAclTable, which is applied\n         to the ingress of an interface.\n         0 - means no ACL applied.')
rlQosIfAclOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfAclOut.setStatus('current')
if mibBuilder.loadTexts: rlQosIfAclOut.setDescription('Index of an ACL in the rlQosAclTable, which is applied\n         to the egress of an interface.\n         0 - means no ACL applied.')
rlQosIfPolicerIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicerIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicerIn.setDescription('Index of an Policer in the rlQosPolicerTable, which is applied\n         to the ingress of an interface.\n         0 - means no Policer applied.')
rlQosPortRateLimitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 17), BinaryStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPortRateLimitStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPortRateLimitStatus.setDescription('If there is Rate limit on the port')
rlQosCirPortRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 18), Integer32()).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: rlQosCirPortRateLimit.setDescription('The CIR for the port rate limit.\n         N/A when the Rate limit is disabled')
rlQosCbsPortRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 19), Integer32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsPortRateLimit.setDescription('The CBS for the port Rate limit.\n         N/A when the Rate limit is disabled')
rlQosIfProfileCfgTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 14), )
if mibBuilder.loadTexts: rlQosIfProfileCfgTable.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfileCfgTable.setDescription('This table specifies for each Queue the Tail\n         Drop or WRED parameters and the EF of WRR\n         parameters.')
rlQosIfProfileCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 14, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfProfileName"), (0, "RADLAN-QOS-CLI-MIB", "rlQosQueueId"))
if mibBuilder.loadTexts: rlQosIfProfileCfgEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfileCfgEntry.setDescription('Each entry in this table describes one queue\n         parameters: Tail-drop threshold for drop precedence\n         0,1,3 and the WRED min-max threshold and the probability\n         factor for Drop precedence 0,1,2 and the WRED Q factor\n         and the EF priority and the WRR weight.\n         The index is Interface Index represent by rlIfProfileName\n         and queue-id represent by rlQosQueueId')
rlIfProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlIfProfileName.setStatus('current')
if mibBuilder.loadTexts: rlIfProfileName.setDescription('Interface Index.')
rlQosQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: rlQosQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueId.setDescription('Queue id Index.')
rlQosTdThersholdDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp0.setDescription('Tail Drop Threshold for Drop Precedence 0.')
rlQosTdThersholdDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp1.setDescription('Tail Drop Threshold for Drop Precedence 1.')
rlQosTdThersholdDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp2.setDescription('Tail Drop Threshold for Drop Precedence 2.')
rlQosRedMinDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp0.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp0.setDescription('WRED Max Threshold for Drop Precedence 0.')
rlQosRedProbDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp0.setDescription('WRED probability for Drop Precedence 0.')
rlQosRedMinDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp1.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp1.setDescription('WRED Max Threshold for Drop Precedence 1.')
rlQosRedProbDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp1.setDescription('WRED probability for Drop Precedence 1.')
rlQosRedMinDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp2.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp2.setDescription('WRED Max Threshold for Drop Precedence 2.')
rlQosRedProbDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp2.setDescription('WRED probability for Drop Precedence 2.')
rlQosRedQweight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedQweight.setStatus('current')
if mibBuilder.loadTexts: rlQosRedQweight.setDescription('Q factor for WRED.')
rlQosIfprofileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfprofileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosIfprofileStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosDscpMutationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 15), )
if mibBuilder.loadTexts: rlQosDscpMutationTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpMutationTable.setDescription('This table specifies The DSCP\n         Mutation table')
rlQosDscpMutationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 15, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosOldDscp"))
if mibBuilder.loadTexts: rlQosDscpMutationEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpMutationEntry.setDescription('Each entry in this table describes the new\n         DSCP for the packet.\n         The index is Old DSCP represent by rlQosOldDscp')
rlQosOldDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosOldDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosOldDscp.setDescription('Old DSCP.')
rlQosNewDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosNewDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosNewDscp.setDescription('New DSCP.')
rlQosDscpRemarkTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 16), )
if mibBuilder.loadTexts: rlQosDscpRemarkTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpRemarkTable.setDescription('This table specifies The DSCP\n         Remark table')
rlQosDscpRemarkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 16, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosRmOldDscp"))
if mibBuilder.loadTexts: rlQosDscpRemarkEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpRemarkEntry.setDescription('Each entry in this table describes the new\n         DSCP for the packet.\n         The index is Old DSCP represent by rlQosOldDscp')
rlQosRmOldDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosRmOldDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosRmOldDscp.setDescription('Old DSCP.')
rlQosRmNewDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 16, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRmNewDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosRmNewDscp.setDescription('New DSCP.')
rlQosCosQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 17), )
if mibBuilder.loadTexts: rlQosCosQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueTable.setDescription('This table specifies The Cos\n         to queue map table')
rlQosCosQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 17, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosCosIndex"))
if mibBuilder.loadTexts: rlQosCosQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueEntry.setDescription('Each entry in this table describes queue ID.\n         The index is CoS represent by rlQosCosIndex')
rlQosCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: rlQosCosIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosCosIndex.setDescription('CoS value (0-7).')
rlQosCosQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCosQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueId.setDescription('Queue ID.')
rlQosDscpQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 18), )
if mibBuilder.loadTexts: rlQosDscpQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueTable.setDescription('This table specifies The DSCP\n         to Queue map table')
rlQosDscpQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 18, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscpIndex"))
if mibBuilder.loadTexts: rlQosDscpQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueEntry.setDescription('Each entry in this table describes The\n         Queue Number.\n         The index is DSCP represent by rlQosDscpIndex')
rlQosDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosDscpIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpIndex.setDescription('DSCP value.')
rlQosQueueNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueNum.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueNum.setDescription('Queue Number.')
rlQosTcpPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 19), )
if mibBuilder.loadTexts: rlQosTcpPortQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueTable.setDescription('This table specifies TCP\n         Port to Queue map table')
rlQosTcpPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 19, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosTcpPort"))
if mibBuilder.loadTexts: rlQosTcpPortQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueEntry.setDescription('Each entry in this table describes The\n         Queue Number.\n         The index is TCP/UDP port represent by rlQosTcpUdpPort')
rlQosTcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosTcpPort.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPort.setDescription('TCP port number.')
rlQosTcpQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTcpQueueValue.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpQueueValue.setDescription('Queue Number.')
rlQosTcpPortQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTcpPortQueueStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosUdpPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 20), )
if mibBuilder.loadTexts: rlQosUdpPortQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueTable.setDescription('This table specifies UDP\n         Port to Queue map table')
rlQosUdpPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 20, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosUdpPort"))
if mibBuilder.loadTexts: rlQosUdpPortQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueEntry.setDescription('Each entry in this table describes The\n         Queue Number.\n         The index is UDP port represent by rlQosTcpUdpPort')
rlQosUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosUdpPort.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPort.setDescription('UDP port number.')
rlQosUdpQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosUdpQueueValue.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpQueueValue.setDescription('Queue value.')
rlQosUdpPortQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosUdpPortQueueStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosEfManageTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 21), )
if mibBuilder.loadTexts: rlQosEfManageTable.setStatus('current')
if mibBuilder.loadTexts: rlQosEfManageTable.setDescription('This table specifies UDP\n         Port to DSCP map table')
rlQosEfManageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 21, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosEfQueueId"))
if mibBuilder.loadTexts: rlQosEfManageEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosEfManageEntry.setDescription('This Table describes The\n         EF management for the system.\n         The index is UDP port represent by rlQosEfQueueId')
rlQosEfQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: rlQosEfQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosEfQueueId.setDescription('Queue-ID.')
rlQosEfState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 2), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosEfState.setStatus('current')
if mibBuilder.loadTexts: rlQosEfState.setDescription('Enable/disable')
rlQosEfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosEfPriority.setStatus('current')
if mibBuilder.loadTexts: rlQosEfPriority.setDescription('The priority of the queue')
rlQosQueueProfileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 22), )
if mibBuilder.loadTexts: rlQosQueueProfileTable.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileTable.setDescription('This table describes the queue managment profiles ')
rlQosQueueProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 22, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQueueProfileName"))
if mibBuilder.loadTexts: rlQosQueueProfileEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileEntry.setDescription('Each entry in this table describes The\n         queue managment profile Value.\n         The index is profile name represent by rlQueueProfileName')
rlQueueProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlQueueProfileName.setStatus('current')
if mibBuilder.loadTexts: rlQueueProfileName.setDescription('Profile name for the Queue profile.')
rlQosTypeQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 2), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue1.setDescription('EF or WRR')
rlQosValueQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue1.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 4), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue2.setDescription('EF or WRR')
rlQosValueQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue2.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 6), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue3.setDescription('EF or WRR')
rlQosValueQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue3.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 8), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue4.setDescription('EF or WRR')
rlQosValueQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue4.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 10), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue5.setDescription('EF or WRR')
rlQosValueQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue5.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 12), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue6.setDescription('EF or WRR')
rlQosValueQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue6.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 14), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue7.setDescription('EF or WRR')
rlQosValueQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue7.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 16), QueueType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosTypeQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue8.setDescription('EF or WRR')
rlQosValueQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue8.setDescription('for EF read-only for wrr the weight')
rlQosQueueProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueProfileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosNumOfIfConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosNumOfIfConnections.setStatus('current')
if mibBuilder.loadTexts: rlQosNumOfIfConnections.setDescription('how many time this entry connected to the if policy table')
rlQosQueueShapeProfileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 23), )
if mibBuilder.loadTexts: rlQosQueueShapeProfileTable.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileTable.setDescription('This table specifies the queue shaper profile')
rlQosQueueShapeProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 23, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosQueueShapeIndex"))
if mibBuilder.loadTexts: rlQosQueueShapeProfileEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileEntry.setDescription('Each entry in this table describes The\n         shaper profile for all queues.\n         The index sequencial index represent by rlQosQueueShapeIndex')
rlQosQueueShapeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosQueueShapeIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeIndex.setDescription('Profile Index.')
rlQosCirQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue1.setDescription('CIR for Queue1 0 for not active')
rlQosCbsQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue1.setDescription('CBS for Queue1 0 for not active')
rlQosCirQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue2.setDescription('CIR for Queue2 0 for not active')
rlQosCbsQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue2.setDescription('CBS for Queue2 0 for not active')
rlQosCirQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue3.setDescription('CIR for Queue3 0 for not active')
rlQosCbsQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue3.setDescription('CBS for Queue3 0 for not active')
rlQosCirQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue4.setDescription('CIR for Queue4 0 for not active')
rlQosCbsQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue4.setDescription('CBS for Queue4 0 for not active')
rlQosCirQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue5.setDescription('CIR for Queue5 0 for not active')
rlQosCbsQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue5.setDescription('CBS for Queue5 0 for not active')
rlQosCirQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue6.setDescription('CIR for Queue6 0 for not active')
rlQosCbsQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue6.setDescription('CBS for Queue6 0 for not active')
rlQosCirQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue7.setDescription('CIR for Queue7 0 for not active')
rlQosCbsQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue7.setDescription('CBS for Queue7 0 for not active')
rlQosCirQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue8.setDescription('CIR for Queue8 0 for not active')
rlQosCbsQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue8.setDescription('CBS for Queue8 0 for not active')
rlQosQueueShapeProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueShapeProfileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosAclCounterTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 24), )
if mibBuilder.loadTexts: rlQosAclCounterTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterTable.setDescription('The  table is used to show statistics for\n         ACL applied on an interface.')
rlQosAclCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 24, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterInterface"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterAclIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterAceIndex"))
if mibBuilder.loadTexts: rlQosAclCounterEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterEntry.setDescription('This entry shows value of conter for a\n         particular ACE of an ACL.')
rlQosAclCounterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterInterface.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterInterface.setDescription('Interface Index on which ACL is applied.')
rlQosAclCounterAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterAclIndex.setDescription('Index of ACL, which was applied on the IfIndex.')
rlQosAclCounterAceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterAceIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterAceIndex.setDescription('Index of ACE, which is belong to an ACL.')
rlQosAclCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterValue.setDescription('The value of the ACE counter.\n         For Broadcom ASICs it shows number\n         of matched packets.\n         For Marvel ASICs -TBD.')
rlQosFreeIndexesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 25), )
if mibBuilder.loadTexts: rlQosFreeIndexesTable.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesTable.setDescription("The  table is used to get free indexes of tables to create\n         new entries. The algorithm for free indexes depends on\n         table's type:\n         Tuple table      - first free index.\n         Offset table     - first free index.\n         ACE table        - last used index + ACE indexes delta.\n         ACL table        - first free index.\n         Class Map table  - last used index + Class Map indexes delta.\n         Policy Map table - first free index.\n         Policer Table    - first free index.\n         The ACE indexes delta and Class Map indexes delta are used\n         to supply QoS MIB user easy insert entry capabilities.\n         Values of these deltas depend on the MIB implementation.\n         The 'Get and increment' approach is used in all cases. ")
rlQosFreeIndexesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 25, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosFreeIndexesTableId"))
if mibBuilder.loadTexts: rlQosFreeIndexesEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesEntry.setDescription('The entry is used to get free index for particular table.')
rlQosFreeIndexesTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tuple", 1), ("offset", 2), ("ace", 3), ("acl", 4), ("class", 5), ("policy", 6), ("policer", 7), ("shaper", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosFreeIndexesTableId.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesTableId.setDescription('Identification of the table, for which free index\n         is retrieved.')
rlQosFreeIndexesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosFreeIndexesValue.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesValue.setDescription('Free index for table. 0 means no free entries.')
rlQosNamesToIndexesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 26), )
if mibBuilder.loadTexts: rlQosNamesToIndexesTable.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesTable.setDescription('The table is used to get the ACL,Class-Map and Policy-Map\n          indexes from the name.')
rlQosNamesToIndexesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 26, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosNamesToIndexesTableId"), (0, "RADLAN-QOS-CLI-MIB", "rlQosNamesToIndexesName"))
if mibBuilder.loadTexts: rlQosNamesToIndexesEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosNamesToIndexesTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("acl", 1), ("class", 2), ("policy", 3), ("policer", 4))))
if mibBuilder.loadTexts: rlQosNamesToIndexesTableId.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesTableId.setDescription('Identification of the table, for which the index\n         is retrieved.')
rlQosNamesToIndexesName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlQosNamesToIndexesName.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesName.setDescription('The name of the entry')
rlQosNamesToIndexesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosNamesToIndexesValue.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesValue.setDescription('the index for table')
rlQosStackControlQueue = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosStackControlQueue.setStatus('current')
if mibBuilder.loadTexts: rlQosStackControlQueue.setDescription('This scalar object defines queue ID, which is\n         used for stack control information transfer.\n         For standalone systems the scalar value equals 0.\n         This scalar object can be used for warning messages\n         when users assign a QoS map item, or a Class to the\n         stack control queue.')
rlQosStackControlCos = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosStackControlCos.setStatus('current')
if mibBuilder.loadTexts: rlQosStackControlCos.setDescription('This scalar object defines CoS (VPT), which is used\n         for stack control information transfer.\n         For standalone systems the scalar value equals 8\n         (not valid for VPT).\n         This scalar object can be used for warning messages\n         when users assign a stack control CoS to a non-stacking\n         control queue.')
rlQosCosQueueDefaultMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 29), )
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapTable.setDescription('The table is used to set default 802.1p map (vpt to queue)')
rlQosCosQueueDefaultMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 29, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosCosQueueDefaultMapVpt"))
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosCosQueueDefaultMapVpt = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 29, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapVpt.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapVpt.setDescription('vlan priority tag , 3 bits of priority which determine\n        the service class.')
rlQosCosQueueDefaultMapQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 29, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapQueueId.setDescription('the queue id vary from the first queue id to Max Number of queues supported')
rlQosPredefBlockAclTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 30), )
if mibBuilder.loadTexts: rlQosPredefBlockAclTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclTable.setDescription("The table is used apply predefined ACLs to interfaces.\n         Predefined ACLs is ACL to filter particular protocol or\n         protocol's family. These ACL may operate simultaneously\n         with IP and MAC ACLs.")
rlQosPredefBlockAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 30, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPredefBlockAclIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosPredefBlockAclIfType"))
if mibBuilder.loadTexts: rlQosPredefBlockAclEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclEntry.setDescription('The entry is used to apply predefined ACLs to the interface.')
rlQosPredefBlockAclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlQosPredefBlockAclIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclIfIndex.setDescription('IfIndex of port/trunk or VLAN tag of VLAN\n         on which predefined ACLa will be configured.')
rlQosPredefBlockAclIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 2), InterfaceType())
if mibBuilder.loadTexts: rlQosPredefBlockAclIfType.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclIfType.setDescription('Interface Type(vlan/port).')
rlQosPredefBlockAclMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPredefBlockAclMask.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclMask.setDescription('This bitmap defines predefined ACL which are applied\n         on an interface. The table below defines bitmasks for\n         supported predefined ACL.\n         Protocol/Family     bitmask Description\n         =====================================================\n         LLC NetBuei/NetBios 0x01    ACL filters out LLC encapsulated\n                                      NetBuei/NetBios frames\n         IP NetBuei/NetBios  0x02    ACL filters out IP encapsulated\n                                      NetBuei/NetBios frames\n         ')
rlQosPredefBlockAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPredefBlockAclStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosAceTidxTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 31), )
if mibBuilder.loadTexts: rlQosAceTidxTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTable.setDescription('This table specifies ACE table with two index information')
rlQosAceTidxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 31, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAceTidxAclIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAceTidxIndex"))
if mibBuilder.loadTexts: rlQosAceTidxEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxEntry.setDescription("Each entry in this table describes one Classifier Element.\n        The information includes: Action the ACE's Type the up to 8 tuples\n        pointers. The index is sequential integer represent by\n        rlQosAceTidxAclIndex ACL index and rlQosAceTidxIndex ACE index")
rlQosAceTidxAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAceTidxAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAclIndex.setDescription('An arbitrary incremental Index\n         for the ACL ACE connection.')
rlQosAceTidxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 2), Integer32())
if mibBuilder.loadTexts: rlQosAceTidxIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxIndex.setDescription('An arbitrary incremental Index\n         for the ACE table.')
rlQosAceTidxAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 3), AceActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAction.setDescription('ACE Action to take.')
rlQosAceTidxType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 4), AceObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxType.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxType.setDescription('ACE Type')
rlQosAceTidxTuple1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple1.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple1.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple2.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple2.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple3.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple3.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple4.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple4.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple5.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple5.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple6.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple6.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple7.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple7.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple8.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple8.setDescription('ACE Tuple pointer.')
rlQosAceTidxAccount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 13), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxAccount.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAccount.setDescription("ACE Accounting state.\n         When set to 'enabled' than appropriate statistic's\n         counter is provided for an ACE.\n         For Broadcom ASICs this counter shows number of\n         matched with ACE criteria packets.\n         For Marvell ASICs TBD.")
rlQosAceTidxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxStatus.setDescription('The status of a table entry.\n        It is used to delete/Add an entry from this table.')
rlQosMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlQosMibVersion.setDescription("MIB's version, the current version is 8\n         1 - original version\n         2 - Add new two MIB's items.\n             - rlQosAceTidxTable - Ace table with two indexes\n             - rlQosMibVersion.\n             Change the unit in Policer table from bps to kbps\n         3 - Add new MIB's value for Textual convention QosObjectMode\n         4 - Add new MIBs rlQosDscpQueueDefaultMapTable\n         5 - Add new advanced action : trustCosDscp\n         6 - Add vpt,ether-type,tcp-flags,icmp-type,icmp-code,igmp-type to ClassTupleType\n             Add ip-ICMP,ip-IGMP To AceObjectType\n             Add vpt,ethertype To ClassOffsetType\n         7-  Add rlQosPortRateLimitStatus,rlQosCirPortRateLimit, rlQosCbsPortRateLimit\n             to   rlQosIfPolicyTable\n         8 - Add Added rlQosDscpToDpTable")
rlQosDscpQueueDefaultMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 33), )
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapTable.setDescription('The table is used to set default dscp to queue map')
rlQosDscpQueueDefaultMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 33, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscpQueueDefaultMapDscp"))
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosDscpQueueDefaultMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 33, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapDscp.setDescription('dscp , 6 bits of priority which determine\n        the service class.')
rlQosDscpQueueDefaultMapQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 33, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapQueueId.setDescription('the queue id vary from the first queue id to Max Number of queues supported')
rlQosDscpToDpTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 34), )
if mibBuilder.loadTexts: rlQosDscpToDpTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpToDpTable.setDescription('This table specifies The DSCP\n         To Dp table')
rlQosDscpToDpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 34, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscp"))
if mibBuilder.loadTexts: rlQosDscpToDpEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpToDpEntry.setDescription('Each entry in this table describes the new\n         DP for the packet.\n         The index is DSCP represent by rlQosDscp')
rlQosDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 34, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosDscp.setDescription('Packet DSCP.')
rlQosDp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 34, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosDp.setStatus('current')
if mibBuilder.loadTexts: rlQosDp.setDescription('New DP.')
mibBuilder.exportSymbols("RADLAN-QOS-CLI-MIB", rlQosAclCounterAclIndex=rlQosAclCounterAclIndex, rlQosAceAction=rlQosAceAction, rlQosClassMapCopyPort=rlQosClassMapCopyPort, rlQosClassMapIndex=rlQosClassMapIndex, rlQosAclName=rlQosAclName, rlQosTypeQueue2=rlQosTypeQueue2, rlQosAceTidxAction=rlQosAceTidxAction, rlQosAceTidxTuple3=rlQosAceTidxTuple3, rlQosAceTidxTuple6=rlQosAceTidxTuple6, rlQosAceTuple6=rlQosAceTuple6, AceObjectType=AceObjectType, rlQosOffsetMask=rlQosOffsetMask, QosObjectMode=QosObjectMode, rlQosUdpPort=rlQosUdpPort, rlQosQueueShapeProfileStatus=rlQosQueueShapeProfileStatus, rlQosCosQueueDefaultMapQueueId=rlQosCosQueueDefaultMapQueueId, rlQosCirQueue1=rlQosCirQueue1, rlQosAceStatus=rlQosAceStatus, rlQosRedMaxDp2=rlQosRedMaxDp2, rlQosAceEntry=rlQosAceEntry, rlQosDscpQueueTable=rlQosDscpQueueTable, rlQosNamesToIndexesValue=rlQosNamesToIndexesValue, rlQosAceTable=rlQosAceTable, rlQosTypeQueue5=rlQosTypeQueue5, rlQosQueueShapeProfileEntry=rlQosQueueShapeProfileEntry, rlQosClassMapNewVlan=rlQosClassMapNewVlan, rlQosValueQueue7=rlQosValueQueue7, rlQosCliBasicModeCfg=rlQosCliBasicModeCfg, rlQosNewDscp=rlQosNewDscp, rlQosNamesToIndexesEntry=rlQosNamesToIndexesEntry, rlIfIndex=rlIfIndex, rlQosOffsetTable=rlQosOffsetTable, rlQosCirPortShaper=rlQosCirPortShaper, rlQosAceTidxEntry=rlQosAceTidxEntry, rlQosAclAceRefTable=rlQosAclAceRefTable, rlQosIfAclIn=rlQosIfAclIn, rlQosAceTuple2=rlQosAceTuple2, rlQosTupleTable=rlQosTupleTable, rlQosOffsetStatus=rlQosOffsetStatus, rlQosDscpRemarkEntry=rlQosDscpRemarkEntry, rlQosCbsQueue1=rlQosCbsQueue1, rlQosUdpPortQueueStatus=rlQosUdpPortQueueStatus, rlQosRedProbDp0=rlQosRedProbDp0, rlQosRedMinDp1=rlQosRedMinDp1, rlQosCbsQueue6=rlQosCbsQueue6, rlQosPolicerEntry=rlQosPolicerEntry, rlQosPolicyMapEntry=rlQosPolicyMapEntry, rlQosEfManageEntry=rlQosEfManageEntry, rlQosCirQueue3=rlQosCirQueue3, rlQosDscpIndex=rlQosDscpIndex, rlQosAclCounterInterface=rlQosAclCounterInterface, rlQosIfProfileCfgEntry=rlQosIfProfileCfgEntry, rlQosAclStatus=rlQosAclStatus, rlQosEfManageTable=rlQosEfManageTable, rlQosAclCounterValue=rlQosAclCounterValue, rlQosAclCounterAceIndex=rlQosAclCounterAceIndex, rlQosAceTidxStatus=rlQosAceTidxStatus, rlQosRedMaxDp1=rlQosRedMaxDp1, rlQosRedQweight=rlQosRedQweight, BinaryStatus=BinaryStatus, rlQosAclAceRefStatus=rlQosAclAceRefStatus, rlQosQueueProfileStatus=rlQosQueueProfileStatus, rlQosQueueShapeIndex=rlQosQueueShapeIndex, rlQosMaxNumOfAce=rlQosMaxNumOfAce, rlQueueProfileName=rlQueueProfileName, rlQosIfTrustActive=rlQosIfTrustActive, rlQosValueQueue2=rlQosValueQueue2, rlQosOffsetValue=rlQosOffsetValue, rlQosValueQueue6=rlQosValueQueue6, rlQosPolicerCbs=rlQosPolicerCbs, rlQosCosQueueDefaultMapTable=rlQosCosQueueDefaultMapTable, rlQosAceTidxAccount=rlQosAceTidxAccount, rlQosAceTuple1=rlQosAceTuple1, rlQosAceTidxTuple5=rlQosAceTidxTuple5, rlQosUdpPortQueueEntry=rlQosUdpPortQueueEntry, rlQosClassMapMarkValue=rlQosClassMapMarkValue, rlQosTdThersholdDp0=rlQosTdThersholdDp0, rlQosCliQosMode=rlQosCliQosMode, rlQosAceTidxTable=rlQosAceTidxTable, rlQosCbsPortRateLimit=rlQosCbsPortRateLimit, rlQosIfPolicyEntry=rlQosIfPolicyEntry, rlQosPolicerTable=rlQosPolicerTable, rlQosIfPolicyMapPointerOut=rlQosIfPolicyMapPointerOut, QueueType=QueueType, rlQosTdThersholdDp2=rlQosTdThersholdDp2, rlQosRedProbDp2=rlQosRedProbDp2, rlQosAceIndex=rlQosAceIndex, rlQosCbsQueue4=rlQosCbsQueue4, rlQosAceAccount=rlQosAceAccount, rlQosAclType=rlQosAclType, rlQosEfQueueId=rlQosEfQueueId, rlQosCbsQueue7=rlQosCbsQueue7, rlQosDscpQueueDefaultMapTable=rlQosDscpQueueDefaultMapTable, rlQosIfPolicyMapPointerIn=rlQosIfPolicyMapPointerIn, rlQosPolicerStatus=rlQosPolicerStatus, rlQosPolicyMapTable=rlQosPolicyMapTable, rlQosDscpMutationEntry=rlQosDscpMutationEntry, rlQosDscpRemarkTable=rlQosDscpRemarkTable, rlQosIfAclOut=rlQosIfAclOut, rlQosTcpPortQueueEntry=rlQosTcpPortQueueEntry, rlQosPolicerIndex=rlQosPolicerIndex, rlQosCirPortRateLimit=rlQosCirPortRateLimit, rlQosAceTidxAclIndex=rlQosAceTidxAclIndex, rlQosDscpToDpTable=rlQosDscpToDpTable, rlQosPolicerType=rlQosPolicerType, rlQosQueueProfilePointer=rlQosQueueProfilePointer, rlQosValueQueue1=rlQosValueQueue1, QosObjectBasicMode=QosObjectBasicMode, rlQosCbsPortShaper=rlQosCbsPortShaper, rlQosOldDscp=rlQosOldDscp, rlQosTupleIndex=rlQosTupleIndex, rlQosCosQueueEntry=rlQosCosQueueEntry, rlQosAceTuple5=rlQosAceTuple5, rlQosPredefBlockAclEntry=rlQosPredefBlockAclEntry, rlQosPredefBlockAclMask=rlQosPredefBlockAclMask, rlQosCosQueueId=rlQosCosQueueId, rlQosAceTuple4=rlQosAceTuple4, rlIfProfileName=rlIfProfileName, rlQosCosQueueDefaultMapEntry=rlQosCosQueueDefaultMapEntry, rlQosNamesToIndexesName=rlQosNamesToIndexesName, rlQosValueQueue4=rlQosValueQueue4, rlQosDscpQueueEntry=rlQosDscpQueueEntry, rlQosTypeQueue7=rlQosTypeQueue7, rlQosAclTable=rlQosAclTable, rlQosPolicyMapIndex=rlQosPolicyMapIndex, rlQosPolicyClassRefClassPointer=rlQosPolicyClassRefClassPointer, rlQosTcpQueueValue=rlQosTcpQueueValue, rlQosTypeQueue8=rlQosTypeQueue8, rlQosQueueNum=rlQosQueueNum, ClassMapType=ClassMapType, rlQosTupleType=rlQosTupleType, rlQosCbsQueue2=rlQosCbsQueue2, rlQosPortRateLimitStatus=rlQosPortRateLimitStatus, rlQosAceTidxTuple7=rlQosAceTidxTuple7, rlQosClassMapTable=rlQosClassMapTable, rlQosDscpToDpEntry=rlQosDscpToDpEntry, AceActionType=AceActionType, rlQosFreeIndexesValue=rlQosFreeIndexesValue, rlQosAceTidxType=rlQosAceTidxType, rlQosDscp=rlQosDscp, rlQosAceTuple7=rlQosAceTuple7, rlQosRedMinDp0=rlQosRedMinDp0, ClassOffsetType=ClassOffsetType, rlQosOffsetType=rlQosOffsetType, rlQosFreeIndexesTable=rlQosFreeIndexesTable, rlQosPolicyClassRefEntry=rlQosPolicyClassRefEntry, rlQosTypeQueue1=rlQosTypeQueue1, rlQosValueQueue3=rlQosValueQueue3, rlQosCbsQueue8=rlQosCbsQueue8, rlQosOffsetEntry=rlQosOffsetEntry, rlQosIfProfilePointer=rlQosIfProfilePointer, ClassMapAction=ClassMapAction, PolicerAction=PolicerAction, rlQosClassMapMatch2=rlQosClassMapMatch2, rlQosIfPolicyMapStatus=rlQosIfPolicyMapStatus, rlQosRedMinDp2=rlQosRedMinDp2, rlQosAclCounterEntry=rlQosAclCounterEntry, rlQosClassMapName=rlQosClassMapName, rlQosPolicyClassRefTable=rlQosPolicyClassRefTable, rlQosTcpPortQueueTable=rlQosTcpPortQueueTable, rlQosValueQueue5=rlQosValueQueue5, rlQosCirQueue8=rlQosCirQueue8, InterfaceType=InterfaceType, rlQosAclAceRefEntry=rlQosAclAceRefEntry, rlQosClassMapStatus=rlQosClassMapStatus, rlQosIfPolicyTable=rlQosIfPolicyTable, rlQosPredefBlockAclIfIndex=rlQosPredefBlockAclIfIndex, rlQosPredefBlockAclStatus=rlQosPredefBlockAclStatus, rlQosUdpQueueValue=rlQosUdpQueueValue, rlQosAceTidxTuple1=rlQosAceTidxTuple1, rlQosRmOldDscp=rlQosRmOldDscp, rlQosPolicyMapStatus=rlQosPolicyMapStatus, rlQosAceTuple3=rlQosAceTuple3, rlQosOffsetIndex=rlQosOffsetIndex, rlQosUdpPortQueueTable=rlQosUdpPortQueueTable, rlQosTypeQueue3=rlQosTypeQueue3, rlQosClassMapNewPort=rlQosClassMapNewPort, rlQosEfPriority=rlQosEfPriority, rlQosStackControlCos=rlQosStackControlCos, rlQosMibVersion=rlQosMibVersion, rlQosPolicerCir=rlQosPolicerCir, PolicerType=PolicerType, rlQosDscpQueueDefaultMapEntry=rlQosDscpQueueDefaultMapEntry, rlQosAclIndex=rlQosAclIndex, rlQosTypeQueue4=rlQosTypeQueue4, rlQosRedProbDp1=rlQosRedProbDp1, rlQosDp=rlQosDp, rlQosTupleValue2=rlQosTupleValue2, rlQosClassMapMatch1=rlQosClassMapMatch1, rlQosOffsetTuplePointer=rlQosOffsetTuplePointer, rlQosClassMapType=rlQosClassMapType, rlQosPolicerCasPointerRemVal=rlQosPolicerCasPointerRemVal, rlQosAclAceRefAclPointer=rlQosAclAceRefAclPointer, rlQosCirQueue4=rlQosCirQueue4, AclDefaultAction=AclDefaultAction, rlQosPolicyClassRefStatus=rlQosPolicyClassRefStatus, rlQosAclCounterTable=rlQosAclCounterTable, rlQosQueueProfileTable=rlQosQueueProfileTable, AclObjectType=AclObjectType, rlQosValueQueue8=rlQosValueQueue8, rlQosOffsetPattern=rlQosOffsetPattern, rlQosAclEntry=rlQosAclEntry, rlQosPolicyMapName=rlQosPolicyMapName, rlQosPortShaperStatus=rlQosPortShaperStatus, rlQosCosQueueTable=rlQosCosQueueTable, rlQosPredefBlockAclIfType=rlQosPredefBlockAclIfType, rlQosRedMaxDp0=rlQosRedMaxDp0, rlQosTcpPortQueueStatus=rlQosTcpPortQueueStatus, rlQosAceTidxTuple4=rlQosAceTidxTuple4, rlQosTypeQueue6=rlQosTypeQueue6, PYSNMP_MODULE_ID=rlQosCliMib, rlQosClassMapMarkVlan=rlQosClassMapMarkVlan, rlQosQueueProfileEntry=rlQosQueueProfileEntry, rlQosAceType=rlQosAceType, rlQosNumOfIfConnections=rlQosNumOfIfConnections, rlQosPolicerAction=rlQosPolicerAction, rlQosTupleEntry=rlQosTupleEntry, rlQosDscpMutationTable=rlQosDscpMutationTable, rlQosCosIndex=rlQosCosIndex, rlQosAclDefaultAction=rlQosAclDefaultAction, rlQosTdThersholdDp1=rlQosTdThersholdDp1, rlQosQueueShapeProfileTable=rlQosQueueShapeProfileTable, rlQosPredefBlockAclTable=rlQosPredefBlockAclTable, rlQosAceTuple8=rlQosAceTuple8, rlQosClassMapEntry=rlQosClassMapEntry, rlQosPolicyClassRefPolicyPointer=rlQosPolicyClassRefPolicyPointer, rlQosStackControlQueue=rlQosStackControlQueue, rlQosDscpQueueDefaultMapQueueId=rlQosDscpQueueDefaultMapQueueId, rlQosTupleValue1=rlQosTupleValue1, ClassTupleType=ClassTupleType, rlQosCirQueue7=rlQosCirQueue7, rlQosCirQueue6=rlQosCirQueue6, rlQosAclAceRefAcePointer=rlQosAclAceRefAcePointer, rlQosIfProfileCfgTable=rlQosIfProfileCfgTable, rlQosCbsQueue3=rlQosCbsQueue3, rlQosQueueShapeProfilePointer=rlQosQueueShapeProfilePointer, rlQosRmNewDscp=rlQosRmNewDscp, rlQosAceTidxTuple2=rlQosAceTidxTuple2, rlQosTupleStatus=rlQosTupleStatus, rlQosTcpPort=rlQosTcpPort, rlQosEfState=rlQosEfState, rlQosCbsQueue5=rlQosCbsQueue5, rlQosCirQueue5=rlQosCirQueue5, rlQosDscpQueueDefaultMapDscp=rlQosDscpQueueDefaultMapDscp, rlQosClassMapAction=rlQosClassMapAction, rlQosCliMib=rlQosCliMib, rlIfType=rlIfType, rlQosQueueId=rlQosQueueId, rlQosIfprofileStatus=rlQosIfprofileStatus, rlQosCosQueueDefaultMapVpt=rlQosCosQueueDefaultMapVpt, rlQosPolicerName=rlQosPolicerName, rlQosIfPolicerIn=rlQosIfPolicerIn, rlQosCirQueue2=rlQosCirQueue2, rlQosNamesToIndexesTable=rlQosNamesToIndexesTable)
mibBuilder.exportSymbols("RADLAN-QOS-CLI-MIB", rlQosClassMapPolicer=rlQosClassMapPolicer, rlQosFreeIndexesTableId=rlQosFreeIndexesTableId, rlQosNamesToIndexesTableId=rlQosNamesToIndexesTableId, rlQosAceTidxIndex=rlQosAceTidxIndex, rlQosFreeIndexesEntry=rlQosFreeIndexesEntry, rlQosAceTidxTuple8=rlQosAceTidxTuple8)
