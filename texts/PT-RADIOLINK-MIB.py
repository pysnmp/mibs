#
# PySNMP MIB module PT-RADIOLINK-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/ericsson/PT-RADIOLINK-MIB
# Produced by pysmi-1.1.12 at Wed May 29 02:43:15 2024
# On host fv-az569-426 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ifEntry, = mibBuilder.importSymbols("IF-MIB", "ifEntry")
InetAddressIPv6, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6")
pt, = mibBuilder.importSymbols("PT-MIB", "pt")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ObjectIdentity, Bits, Integer32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, IpAddress, NotificationType, TimeTicks, Counter64, Gauge32, MibIdentifier, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Bits", "Integer32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "IpAddress", "NotificationType", "TimeTicks", "Counter64", "Gauge32", "MibIdentifier", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ptRadioLink = ModuleIdentity((1, 3, 6, 1, 4, 1, 193, 223, 2, 7))
ptRadioLink.setRevisions(('2017-12-01 16:00', '2017-04-05 10:00', '2017-01-18 10:00', '2016-12-06 14:00', '2016-05-22 10:30',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ptRadioLink.setRevisionsDescriptions(('Added plcAdminStatus and plcOperStatus.', 'Added channelSpacing enums.', 'Added mlhcAdminStatus, mlhcOperStatus and mlhcMplsConfig.', 'Added more MOs in ctTable and rltTable. Added G.826 tables.', 'The initial version of this MIB module\n                            with OID for MINI-LINK.',))
if mibBuilder.loadTexts: ptRadioLink.setLastUpdated('201712011600Z')
if mibBuilder.loadTexts: ptRadioLink.setOrganization('Ericsson')
if mibBuilder.loadTexts: ptRadioLink.setContactInfo('Anders Ekvall\n             Postal: Ericsson AB,\n             E-Mail: anders.ekvall@ericsson.com')
if mibBuilder.loadTexts: ptRadioLink.setDescription('This is the MIB for Radio Link specifics in PT')
ptRadioLinkConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 2))
ctPerformance = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4))
class AcmTC(TextualConvention, Integer32):
    description = 'An integer which indicates the ACM.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36))
    namedValues = NamedValues(("acmHalfBpsk", 1), ("acmHalfBpskLight", 2), ("acmHalfBpskStrong", 3), ("acmBpsk", 4), ("acmBpskLight", 5), ("acmBpskStrong", 6), ("acm4Qam", 7), ("acm4QamLight", 8), ("acm4QamStrong", 9), ("acm16Qam", 10), ("acm16QamLight", 11), ("acm16QamStrong", 12), ("acm32Qam", 13), ("acm32QamLight", 14), ("acm32QamStrong", 15), ("acm64Qam", 16), ("acm64QamLight", 17), ("acm64QamStrong", 18), ("acm128Qam", 19), ("acm128QamLight", 20), ("acm128QamStrong", 21), ("acm256Qam", 22), ("acm256QamLight", 23), ("acm256QamStrong", 24), ("acm512Qam", 25), ("acm512QamLight", 26), ("acm512QamStrong", 27), ("acm1024Qam", 28), ("acm1024QamLight", 29), ("acm1024QamStrong", 30), ("acm2048Qam", 31), ("acm2048QamLight", 32), ("acm2048QamStrong", 33), ("acm4096Qam", 34), ("acm4096QamLight", 35), ("acm4096QamStrong", 36))

class EnableStatusTC(TextualConvention, Integer32):
    description = 'An integer which indicates the enabled status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2), ("unknown", 3))

class XpicMimoTC(TextualConvention, Integer32):
    description = 'An integer which indicates the XPIC or MIMO status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("notAvailable", 1), ("locked", 2), ("unlocked", 3), ("unknown", 4))

ctTable = MibTable((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1), )
if mibBuilder.loadTexts: ctTable.setStatus('current')
if mibBuilder.loadTexts: ctTable.setDescription('A table of CT Table entries.')
ctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1), )
ifEntry.registerAugmentions(("PT-RADIOLINK-MIB", "ctEntry"))
ctEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: ctEntry.setStatus('current')
if mibBuilder.loadTexts: ctEntry.setDescription('An entry of CT application.')
actualInputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualInputPower.setStatus('current')
if mibBuilder.loadTexts: actualInputPower.setDescription('Actual input power of the CT in dBm')
actualOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualOutputPower.setStatus('current')
if mibBuilder.loadTexts: actualOutputPower.setDescription('Actual output power of the CT in dBm')
actualRxAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualRxAcm.setStatus('current')
if mibBuilder.loadTexts: actualRxAcm.setDescription('Actual rx modulation and coding')
actualTxAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualTxAcm.setStatus('current')
if mibBuilder.loadTexts: actualTxAcm.setDescription('Actual tx modulation and coding')
ctDistinguishedName = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctDistinguishedName.setStatus('current')
if mibBuilder.loadTexts: ctDistinguishedName.setDescription('Unique id/name of the carrier termination, according to FDN (rack/slot/port/class)')
description = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: description.setStatus('current')
if mibBuilder.loadTexts: description.setDescription('User description of the carrior termination.')
carrierId = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("c", 3), ("d", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: carrierId.setStatus('current')
if mibBuilder.loadTexts: carrierId.setDescription('Id of the carrier. (A, B, C, D)\n                Used in XPIC & MIMO configurations to check that the carrier termination is connected to the correct far end carrier termination. \n                Should be the same id on both sides of the hop. Defaulted when not MIMO or XPIC.\n                Sometimes also referred to as preamble')
ctStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("up", 2), ("na", 3), ("unknown", 4), ("degraded", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctStatus.setStatus('current')
if mibBuilder.loadTexts: ctStatus.setDescription('The status of the carrier termination, hop')
frameId = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: frameId.setStatus('current')
if mibBuilder.loadTexts: frameId.setDescription('A unique identifier for the radio frame to be used. \n            Wanted frameId, txFrequency, rxFrequency, referenceSec, selectedMinAcm and selectedMaxAcm must be a valid combination.')
txFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txFrequency.setStatus('current')
if mibBuilder.loadTexts: txFrequency.setDescription('Selected frequency on the transmitter (kHz). \n                Wanted frameId, txFrequency, rxFrequency, referenceSec, selectedMinAcm and selectedMaxAcm must be a valid combination.')
minTxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minTxFrequency.setStatus('current')
if mibBuilder.loadTexts: minTxFrequency.setDescription('Minimum Tx frequency possible to use, given by the selected frame-id')
maxTxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxTxFrequency.setStatus('current')
if mibBuilder.loadTexts: maxTxFrequency.setDescription('Maximum Tx frequency possible to use, given by the selected frame-id')
rxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rxFrequency.setStatus('current')
if mibBuilder.loadTexts: rxFrequency.setDescription('Selected frequency on the receiver (kHz). \n                Wanted frameId, txFrequency, rxFrequency, referenceSec, selectedMinAcm and selectedMaxAcm must be a valid combination.')
minRxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: minRxFrequency.setStatus('current')
if mibBuilder.loadTexts: minRxFrequency.setDescription('Minimum Rx frequency possible to use, given by the selected frame-id')
maxRxFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxRxFrequency.setStatus('current')
if mibBuilder.loadTexts: maxRxFrequency.setDescription('Maximum Rx frequency possible to use, given by the selected frame-id')
frequencyStepSize = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: frequencyStepSize.setStatus('current')
if mibBuilder.loadTexts: frequencyStepSize.setDescription('Frequency step size in kHz')
duplexDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: duplexDistance.setStatus('current')
if mibBuilder.loadTexts: duplexDistance.setDescription('Distance between Tx and Rx frequencies (kHz)')
duplexType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("variable", 1), ("fixed", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: duplexType.setStatus('current')
if mibBuilder.loadTexts: duplexType.setDescription('The duplex type is given by the equipment (Fixed,Variable)')
duplexConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 19), EnableStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duplexConfig.setStatus('current')
if mibBuilder.loadTexts: duplexConfig.setDescription('Enabling or disabling configuration of Rx freq using duplex distance')
autoFreqSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("master", 2), ("slave", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFreqSelection.setStatus('current')
if mibBuilder.loadTexts: autoFreqSelection.setDescription('Automatic frequency selection mode')
autoFreqSelectedChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoFreqSelectedChannel.setStatus('current')
if mibBuilder.loadTexts: autoFreqSelectedChannel.setDescription('Automatic frequency selected channel')
autoFreqSelectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("idle", 1), ("searchingForSlave", 2), ("requestingInfoFromSlave", 3), ("waitingForMaster", 4), ("waitingForChannelInfoRequest", 5), ("inProgress", 6), ("initializing", 7), ("finished", 8), ("failed", 9), ("unknown", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: autoFreqSelectionStatus.setStatus('current')
if mibBuilder.loadTexts: autoFreqSelectionStatus.setDescription('Automatic frequency status')
channelSpacing = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("cs7MHz", 1), ("cs10MHz", 2), ("cs14MHz", 3), ("cs20MHz", 4), ("cs28MHz", 5), ("cs30MHz", 6), ("cs40MHz", 7), ("cs50MHz", 8), ("cs56MHz", 9), ("cs250MHz", 10), ("cs60MHz", 11), ("cs500MHz", 12), ("cs750MHz", 13), ("cs100MHz", 14), ("cs150MHz", 15), ("cs200MHz", 16), ("cs125MHz", 17), ("cs80MHz", 18), ("cs112MHz", 19), ("cs1000MHz", 20), ("cs1250MHz", 21), ("cs1500MHz", 22), ("cs62p5MHz", 23), ("cs2000MHz", 24), ("unknown", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelSpacing.setStatus('current')
if mibBuilder.loadTexts: channelSpacing.setDescription('Channel spacing')
polarization = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSpecified", 1), ("horizontal", 2), ("vertical", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: polarization.setStatus('current')
if mibBuilder.loadTexts: polarization.setDescription('Antenna polarization')
txOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("off", 2), ("on", 3), ("standby", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOperStatus.setStatus('current')
if mibBuilder.loadTexts: txOperStatus.setDescription('Operative status of the transmitter')
txAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: txAdminStatus.setStatus('current')
if mibBuilder.loadTexts: txAdminStatus.setDescription('Administrative status of the transmitter')
selectedOutputPowerType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standard", 1), ("high", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selectedOutputPowerType.setStatus('current')
if mibBuilder.loadTexts: selectedOutputPowerType.setDescription('Selected output power type')
availableOutputPowerType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standard", 1), ("high", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: availableOutputPowerType.setStatus('current')
if mibBuilder.loadTexts: availableOutputPowerType.setDescription('Available output power type')
selectedMinOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selectedMinOutputPower.setStatus('current')
if mibBuilder.loadTexts: selectedMinOutputPower.setDescription('Selected min output power.\n       Selected min & max output power should be set to the same value for RTPC mode, otherwise the hop operates in ATPC mode.')
selectedMaxOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 30), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selectedMaxOutputPower.setStatus('current')
if mibBuilder.loadTexts: selectedMaxOutputPower.setDescription('Selected max output power.\n       Selected min & max output power should be set to the same value for RTPC mode, otherwise the hop operates in ATPC mode.')
availableMinOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMinOutputPower.setStatus('current')
if mibBuilder.loadTexts: availableMinOutputPower.setDescription('The minimum output power supported (dBm).\n        The system shows a value if the equipment is available and a frame id has been selected.')
availableMaxOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMaxOutputPower.setStatus('current')
if mibBuilder.loadTexts: availableMaxOutputPower.setDescription('The maximum output power supported (dBm).\n            The system shows a value if the equipment is available and a frame id has been selected.')
referenceSec = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 7, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("noAvailable", 1), ("sec2", 2), ("sec4L", 4), ("sec4H", 5), ("sec5B", 7), ("sec6B", 9), ("sec5LB", 10), ("sec5HB", 11), ("sec6LB", 12), ("sec6HB", 13), ("sec7B", 14), ("unknown", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: referenceSec.setStatus('current')
if mibBuilder.loadTexts: referenceSec.setDescription('Each modulation is compliant to a Reference Spectrum Efficiency Class (RSEC). \n            When running Adaptive Coding/Modulation, one SEC has to be selected for all the coding/modulations between selectedMinACM and selectedMaxACM.\n            This parameter is called Reference SEC. This setting will affect availableMaxOutputPower, in order to fulfill spectrum requirements.\n            Wanted frameId, txFrequency, rxFrequency, referenceSec, selectedMinAcm and selectedMaxAcm must be a valid combination.')
targetInputPowerFarEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: targetInputPowerFarEnd.setStatus('current')
if mibBuilder.loadTexts: targetInputPowerFarEnd.setDescription('The wanted input power at far end (dBm), when running ATPC')
berAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tenExpMinus6", 1), ("tenExpMinus3", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: berAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: berAlarmThreshold.setDescription('Threshold for the BER alarm')
inputPowerAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inputPowerAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: inputPowerAlarmThreshold.setDescription('Threshold for the input power alarm')
plannedAlignmentInputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 37), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plannedAlignmentInputPower.setStatus('current')
if mibBuilder.loadTexts: plannedAlignmentInputPower.setDescription('The planned received input power (dBm) dependent upon selected minimum ACM and corresponding output power.\n                    Used when doing alignment')
atpcFallback = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 38), EnableStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atpcFallback.setStatus('current')
if mibBuilder.loadTexts: atpcFallback.setDescription('Enable or disable the output power fall back function')
atpcFallbackTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atpcFallbackTimer.setStatus('current')
if mibBuilder.loadTexts: atpcFallbackTimer.setDescription('Specifies the timer for output power fall back (# of seconds)')
atpcFallbackOutputPower = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atpcFallbackOutputPower.setStatus('current')
if mibBuilder.loadTexts: atpcFallbackOutputPower.setDescription('The ATPC fallback output power')
xpicStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 41), XpicMimoTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: xpicStatus.setStatus('current')
if mibBuilder.loadTexts: xpicStatus.setDescription('Status of the XPIC function.')
mimoStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 42), XpicMimoTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mimoStatus.setStatus('current')
if mibBuilder.loadTexts: mimoStatus.setDescription('Status of the MIMO function.')
actualSnir = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 43), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualSnir.setStatus('current')
if mibBuilder.loadTexts: actualSnir.setDescription('Actual signal to noise plus interference ratio (dB).')
actualXpi = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 44), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualXpi.setStatus('current')
if mibBuilder.loadTexts: actualXpi.setDescription('The carrier to cross-polar interference level (dBc).')
actualSi = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 45), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualSi.setStatus('current')
if mibBuilder.loadTexts: actualSi.setDescription('Spatial interference between the CTs when MIMO is configured.')
actualTxCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualTxCapacity.setStatus('current')
if mibBuilder.loadTexts: actualTxCapacity.setDescription('Actual capacity supported by the carrier termination.')
licensedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licensedCapacity.setStatus('current')
if mibBuilder.loadTexts: licensedCapacity.setDescription('Wanted or installed license for the capacity allowed for the carrier termination.')
availableMinCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMinCapacity.setStatus('current')
if mibBuilder.loadTexts: availableMinCapacity.setDescription('Minimum capacity possible to use. Given by the selected frame-id (kbit/s)')
availableMaxCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMaxCapacity.setStatus('current')
if mibBuilder.loadTexts: availableMaxCapacity.setDescription('Maximum capacity possible to use. Given by the selected frame-id (kbit/s)')
selectedMinCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selectedMinCapacity.setStatus('current')
if mibBuilder.loadTexts: selectedMinCapacity.setDescription('Selected minimum capacity, derived from selected minimum ACM (kbit/s)')
selectedMaxCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selectedMaxCapacity.setStatus('current')
if mibBuilder.loadTexts: selectedMaxCapacity.setDescription('Selected maximum capacity, derived from selected maximum ACM (kbit/s)')
wantedLicensedCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 52), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wantedLicensedCapacity.setStatus('current')
if mibBuilder.loadTexts: wantedLicensedCapacity.setDescription('Wanted licensed capacity and creation of LRF for the carrier termination (kbit/s)')
availableMinAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 53), AcmTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMinAcm.setStatus('current')
if mibBuilder.loadTexts: availableMinAcm.setDescription('Minimum ACM possible to use, given by the selected frame id.')
availableMaxAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 54), AcmTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: availableMaxAcm.setStatus('current')
if mibBuilder.loadTexts: availableMaxAcm.setDescription('Maximum ACM possible to use, given by the selected frame id')
selectedMinAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 55), AcmTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selectedMinAcm.setStatus('current')
if mibBuilder.loadTexts: selectedMinAcm.setDescription('Selected minimum coding/modulation. If selectedMinACM = selectedMaxACM, then the modulation is fixed')
selectedMaxAcm = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 56), AcmTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: selectedMaxAcm.setStatus('current')
if mibBuilder.loadTexts: selectedMaxAcm.setDescription('Selected maximum coding/modulation. If selectedMinACM = selectedMaxACM, then the modulation is fixed')
actualRxAcmTC = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 57), AcmTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualRxAcmTC.setStatus('current')
if mibBuilder.loadTexts: actualRxAcmTC.setDescription('Actual rx modulation and coding')
actualTxAcmTC = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 58), AcmTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualTxAcmTC.setStatus('current')
if mibBuilder.loadTexts: actualTxAcmTC.setDescription('Actual tx modulation and coding')
alignmentMode = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 59), EnableStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: alignmentMode.setStatus('current')
if mibBuilder.loadTexts: alignmentMode.setDescription('Enable or disable the alignment mode')
rfLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 1, 1, 60), EnableStatusTC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rfLoop.setStatus('current')
if mibBuilder.loadTexts: rfLoop.setDescription('Enable or disable the rf loop')
rltTable = MibTable((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3), )
if mibBuilder.loadTexts: rltTable.setStatus('current')
if mibBuilder.loadTexts: rltTable.setDescription('A table of RLT Table entries.')
rltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1), )
ifEntry.registerAugmentions(("PT-RADIOLINK-MIB", "rltEntry"))
rltEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: rltEntry.setStatus('current')
if mibBuilder.loadTexts: rltEntry.setDescription('An entry of RLT application.')
rltDistinguishedName = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rltDistinguishedName.setStatus('current')
if mibBuilder.loadTexts: rltDistinguishedName.setDescription('Unique id/name of the radio link termination, according to FDN (rack/slot/port/class)')
neIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: neIpAddress.setStatus('current')
if mibBuilder.loadTexts: neIpAddress.setDescription('NE IP address')
neIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 3), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: neIpv6Address.setStatus('current')
if mibBuilder.loadTexts: neIpv6Address.setDescription('NE IP V6 address')
neName = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: neName.setStatus('current')
if mibBuilder.loadTexts: neName.setDescription('NE Name')
neType = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("mle", 2), ("xfMle", 3), ("tn", 4), ("cn", 5), ("pt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: neType.setStatus('current')
if mibBuilder.loadTexts: neType.setDescription('NE Type')
id = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: id.setStatus('current')
if mibBuilder.loadTexts: id.setDescription('User defined id of the radio link terminal')
rltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("down", 1), ("up", 2), ("na", 3), ("unknown", 4), ("degraded", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rltStatus.setStatus('current')
if mibBuilder.loadTexts: rltStatus.setDescription('The status of the radio link terminal')
mode = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("mode1plus0", 1), ("mode1plus1CSB", 2), ("mode1plus1RLP", 3), ("mode2plus0RLB", 4), ("mode2plus1CSB", 5), ("mode2plus1RLP", 6), ("mode2plus2CSB", 7), ("mode2plus2RLP", 8), ("mode3plus0RLB", 9), ("mode4plus0RLB", 10), ("notAvailable11", 11), ("notAvailable12", 12), ("notAvailable13", 13), ("notAvailable14", 14), ("mode3plus1RLP", 15), ("mode3plus2RLP", 16), ("mode3plus3RLP", 17), ("mode4plus1RLP", 18), ("mode4plus2RLP", 19), ("mode4plus3RLP", 20), ("mode4plus4RLP", 21), ("notAvailable22", 22), ("notAvailable23", 23), ("notAvailable24", 24), ("notAvailable25", 25), ("notAvailable26", 26), ("notAvailable27", 27), ("mode3plus1CSB", 28), ("mode3plus2CSB", 29), ("mode3plus3CSB", 30), ("mode4plus1CSB", 31), ("mode4plus2CSB", 32), ("mode4plus3CSB", 33), ("mode4plus4CSB", 34), ("unknown", 35)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mode.setStatus('current')
if mibBuilder.loadTexts: mode.setDescription('The status of the radio link terminal')
actualTxTotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: actualTxTotalCapacity.setStatus('current')
if mibBuilder.loadTexts: actualTxTotalCapacity.setDescription('Actual aggregated total (packet + TDM) transmitter capacity for the radio link termination.\n                  Limited by licenses & configuration (=nearEndLimitedCapacity) and depending on actual modulation/coding used at the moment.')
limitedTotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitedTotalCapacity.setStatus('current')
if mibBuilder.loadTexts: limitedTotalCapacity.setDescription('Maximum total capacity allowed by the current configuration and installed licenses.\n                    Aggregated from the constituent carrier termination values.')
protectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unprotected", 1), ("protected", 2), ("unableToProtect", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionStatus.setStatus('current')
if mibBuilder.loadTexts: protectionStatus.setDescription('Status of a protected node.')
revertiveWaitToRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: revertiveWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: revertiveWaitToRestore.setDescription('The time, in number of seconds, to wait before switching back to the preferred Tx.')
revertivePreferredTx = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ct11", 1), ("ct12", 2), ("ct21", 3), ("ct22", 4), ("notApplicable", 5), ("unknown", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: revertivePreferredTx.setStatus('current')
if mibBuilder.loadTexts: revertivePreferredTx.setDescription('The preferred carrier termination transmitter.')
protectionSwitchMode = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("auto", 1), ("manual", 2), ("autoAndRevertive", 3), ("unknown", 4), ("notApplicable", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protectionSwitchMode.setStatus('current')
if mibBuilder.loadTexts: protectionSwitchMode.setDescription('.The mode in which the switching mechanism is configured')
fadeNotificationTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fadeNotificationTimer.setStatus('current')
if mibBuilder.loadTexts: fadeNotificationTimer.setDescription('Notification is sent if fading is longer than this timer, applicable for protection.')
expectedFarEndId = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: expectedFarEndId.setStatus('current')
if mibBuilder.loadTexts: expectedFarEndId.setDescription('Expected id of far-end terminal')
farEndIdCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: farEndIdCheck.setStatus('current')
if mibBuilder.loadTexts: farEndIdCheck.setDescription('Enabling of far end id check.')
cpriMode = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("notApplicable", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpriMode.setStatus('current')
if mibBuilder.loadTexts: cpriMode.setDescription('Set the mode of the CPRI front-haul product.')
cpriStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("idle", 1), ("waitingOnRtcSync", 2), ("waitingOnCpri", 3), ("waitingOnRxRequest", 4), ("waitingOnTxRequest", 5), ("inSync", 6), ("unknown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpriStatus.setStatus('current')
if mibBuilder.loadTexts: cpriStatus.setDescription('The status of the CPRI front-haul product.')
manualSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ct11", 1), ("ct12", 2), ("ct21", 3), ("ct22", 4), ("notApplicable", 5), ("unknown", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: manualSwitch.setStatus('current')
if mibBuilder.loadTexts: manualSwitch.setDescription('Manual switch of protected carrier termination transmitter.')
mlhcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mlhcOperStatus.setStatus('current')
if mibBuilder.loadTexts: mlhcOperStatus.setDescription('Operative status of multi layer header compression.')
mlhcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mlhcAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mlhcAdminStatus.setDescription('Administrative status of multi layer header compression.')
mlhcMplsConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("controlWord", 1), ("l2", 2), ("l3", 3), ("mplsOnly", 4), ("unknown", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mlhcMplsConfig.setStatus('current')
if mibBuilder.loadTexts: mlhcMplsConfig.setDescription('MLHC/MPLS configuration.')
plcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: plcOperStatus.setStatus('current')
if mibBuilder.loadTexts: plcOperStatus.setDescription('Operative status of payload compression.')
plcAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 3, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("unknown", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: plcAdminStatus.setStatus('current')
if mibBuilder.loadTexts: plcAdminStatus.setDescription('Administrative status of payload compression.')
ctG826ContinuousTable = MibTable((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1), )
if mibBuilder.loadTexts: ctG826ContinuousTable.setStatus('current')
if mibBuilder.loadTexts: ctG826ContinuousTable.setDescription('A table of CT G826 Performance Continuous counters entries.\n              The counters are reset by ctG826Reset')
ctG826ContinuousEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1), )
ifEntry.registerAugmentions(("PT-RADIOLINK-MIB", "ctG826ContinuousEntry"))
ctG826ContinuousEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: ctG826ContinuousEntry.setStatus('current')
if mibBuilder.loadTexts: ctG826ContinuousEntry.setDescription('An entry of CT G826 Performance Continuous counters.')
ctG826TimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctG826TimeElapsed.setStatus('current')
if mibBuilder.loadTexts: ctG826TimeElapsed.setDescription('Time elapsed in seconds since last PMReset')
ctBBE = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBBE.setStatus('current')
if mibBuilder.loadTexts: ctBBE.setDescription('Background Block Errors')
ctBBER = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBBER.setStatus('current')
if mibBuilder.loadTexts: ctBBER.setDescription('Background Block Errors Ratio')
ctES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctES.setStatus('current')
if mibBuilder.loadTexts: ctES.setDescription('Error seconds')
ctESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctESR.setStatus('current')
if mibBuilder.loadTexts: ctESR.setDescription('Error seconds Ratio')
ctSES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctSES.setStatus('current')
if mibBuilder.loadTexts: ctSES.setDescription('Severely error seconds')
ctSESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctSESR.setStatus('current')
if mibBuilder.loadTexts: ctSESR.setDescription('Severely error seconds Ratio')
ctBB = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBB.setStatus('current')
if mibBuilder.loadTexts: ctBB.setDescription('Background blocks')
ctUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctUAS.setStatus('current')
if mibBuilder.loadTexts: ctUAS.setDescription('Unavailable seconds ')
ctG826Reset = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("noReset", 2), ("reset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctG826Reset.setStatus('current')
if mibBuilder.loadTexts: ctG826Reset.setDescription('Reset the continuous PM counters')
ctG826Current15mTable = MibTable((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2), )
if mibBuilder.loadTexts: ctG826Current15mTable.setStatus('current')
if mibBuilder.loadTexts: ctG826Current15mTable.setDescription('A table of CT Performance G826 15 m current counters Table entries.')
ctG826Current15mEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1), )
ifEntry.registerAugmentions(("PT-RADIOLINK-MIB", "ctG826Current15mEntry"))
ctG826Current15mEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: ctG826Current15mEntry.setStatus('current')
if mibBuilder.loadTexts: ctG826Current15mEntry.setDescription('An entry of CT Performance G826 15 m current Table counters.')
ctG826Current15mTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctG826Current15mTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: ctG826Current15mTimeElapsed.setDescription('Time elapsed in seconds since last PMReset')
ctCurrent15mBBE = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mBBE.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mBBE.setDescription('Background Block Errors')
ctCurrent15mBBER = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mBBER.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mBBER.setDescription('Background Block Errors Ratio')
ctCurrent15mES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mES.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mES.setDescription('Error seconds')
ctCurrent15mESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mESR.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mESR.setDescription('Error seconds Ratio')
ctCurrent15mSES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mSES.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mSES.setDescription('Severely error seconds')
ctCurrent15mSESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mSESR.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mSESR.setDescription('Severely error seconds Ratio')
ctCurrent15mBB = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mBB.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mBB.setDescription('Background blocks')
ctCurrent15mUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent15mUAS.setStatus('current')
if mibBuilder.loadTexts: ctCurrent15mUAS.setDescription('Unavailable seconds ')
ctG826Current24hTable = MibTable((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3), )
if mibBuilder.loadTexts: ctG826Current24hTable.setStatus('current')
if mibBuilder.loadTexts: ctG826Current24hTable.setDescription('A table of CT Performance G826 Current 24h counters entries.')
ctG826Current24hEntry = MibTableRow((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1), )
ifEntry.registerAugmentions(("PT-RADIOLINK-MIB", "ctG826Current24hEntry"))
ctG826Current24hEntry.setIndexNames(*ifEntry.getIndexNames())
if mibBuilder.loadTexts: ctG826Current24hEntry.setStatus('current')
if mibBuilder.loadTexts: ctG826Current24hEntry.setDescription('An entry of CT Performance G826 Current 24 h counters.')
ctG826Current24hTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctG826Current24hTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: ctG826Current24hTimeElapsed.setDescription('Time elapsed in seconds since last PMReset')
ctCurrent24hBBE = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hBBE.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hBBE.setDescription('Background Block Errors')
ctCurrent24hBBER = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hBBER.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hBBER.setDescription('Background Block Errors Ratio')
ctCurrent24hES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hES.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hES.setDescription('Error seconds')
ctCurrent24hESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hESR.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hESR.setDescription('Error seconds Ratio')
ctCurrent24hSES = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hSES.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hSES.setDescription('Severely error seconds')
ctCurrent24hSESR = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hSESR.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hSESR.setDescription('Severely error seconds Ratio')
ctCurrent24hBB = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hBB.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hBB.setDescription('Background blocks')
ctCurrent24hUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 4, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctCurrent24hUAS.setStatus('current')
if mibBuilder.loadTexts: ctCurrent24hUAS.setDescription('Unavailable seconds ')
ptRadioLinkCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 2, 1))
ptRadioLinkGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 2, 2))
ptRadioLinkFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 2, 1, 1)).setObjects(("PT-RADIOLINK-MIB", "ptRadioLinkCompleteGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptRadioLinkFullCompliance = ptRadioLinkFullCompliance.setStatus('current')
if mibBuilder.loadTexts: ptRadioLinkFullCompliance.setDescription('The compliance statement for SNMP entities which implement everything.')
ptRadioLinkCompleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 193, 223, 2, 7, 2, 2, 1)).setObjects(("PT-RADIOLINK-MIB", "actualInputPower"), ("PT-RADIOLINK-MIB", "actualOutputPower"), ("PT-RADIOLINK-MIB", "actualRxAcm"), ("PT-RADIOLINK-MIB", "actualRxAcmTC"), ("PT-RADIOLINK-MIB", "actualSi"), ("PT-RADIOLINK-MIB", "actualSnir"), ("PT-RADIOLINK-MIB", "actualTxAcm"), ("PT-RADIOLINK-MIB", "actualTxAcmTC"), ("PT-RADIOLINK-MIB", "actualTxCapacity"), ("PT-RADIOLINK-MIB", "actualTxTotalCapacity"), ("PT-RADIOLINK-MIB", "actualXpi"), ("PT-RADIOLINK-MIB", "alignmentMode"), ("PT-RADIOLINK-MIB", "atpcFallback"), ("PT-RADIOLINK-MIB", "atpcFallbackTimer"), ("PT-RADIOLINK-MIB", "atpcFallbackOutputPower"), ("PT-RADIOLINK-MIB", "autoFreqSelectedChannel"), ("PT-RADIOLINK-MIB", "autoFreqSelection"), ("PT-RADIOLINK-MIB", "autoFreqSelectionStatus"), ("PT-RADIOLINK-MIB", "availableMaxAcm"), ("PT-RADIOLINK-MIB", "availableMaxCapacity"), ("PT-RADIOLINK-MIB", "availableMaxOutputPower"), ("PT-RADIOLINK-MIB", "availableMinAcm"), ("PT-RADIOLINK-MIB", "availableMinCapacity"), ("PT-RADIOLINK-MIB", "availableMinOutputPower"), ("PT-RADIOLINK-MIB", "availableOutputPowerType"), ("PT-RADIOLINK-MIB", "berAlarmThreshold"), ("PT-RADIOLINK-MIB", "carrierId"), ("PT-RADIOLINK-MIB", "channelSpacing"), ("PT-RADIOLINK-MIB", "cpriMode"), ("PT-RADIOLINK-MIB", "cpriStatus"), ("PT-RADIOLINK-MIB", "ctDistinguishedName"), ("PT-RADIOLINK-MIB", "ctCurrent15mBB"), ("PT-RADIOLINK-MIB", "ctCurrent15mBBE"), ("PT-RADIOLINK-MIB", "ctCurrent15mBBER"), ("PT-RADIOLINK-MIB", "ctCurrent15mES"), ("PT-RADIOLINK-MIB", "ctCurrent15mESR"), ("PT-RADIOLINK-MIB", "ctCurrent15mSES"), ("PT-RADIOLINK-MIB", "ctCurrent15mSESR"), ("PT-RADIOLINK-MIB", "ctCurrent15mUAS"), ("PT-RADIOLINK-MIB", "ctG826Current15mTimeElapsed"), ("PT-RADIOLINK-MIB", "ctCurrent24hBB"), ("PT-RADIOLINK-MIB", "ctCurrent24hBBE"), ("PT-RADIOLINK-MIB", "ctCurrent24hBBER"), ("PT-RADIOLINK-MIB", "ctCurrent24hES"), ("PT-RADIOLINK-MIB", "ctCurrent24hESR"), ("PT-RADIOLINK-MIB", "ctCurrent24hSES"), ("PT-RADIOLINK-MIB", "ctCurrent24hSESR"), ("PT-RADIOLINK-MIB", "ctCurrent24hUAS"), ("PT-RADIOLINK-MIB", "ctG826Current24hTimeElapsed"), ("PT-RADIOLINK-MIB", "ctBB"), ("PT-RADIOLINK-MIB", "ctBBE"), ("PT-RADIOLINK-MIB", "ctBBER"), ("PT-RADIOLINK-MIB", "ctES"), ("PT-RADIOLINK-MIB", "ctESR"), ("PT-RADIOLINK-MIB", "ctG826Reset"), ("PT-RADIOLINK-MIB", "ctSES"), ("PT-RADIOLINK-MIB", "ctSESR"), ("PT-RADIOLINK-MIB", "ctG826TimeElapsed"), ("PT-RADIOLINK-MIB", "ctUAS"), ("PT-RADIOLINK-MIB", "ctStatus"), ("PT-RADIOLINK-MIB", "description"), ("PT-RADIOLINK-MIB", "duplexConfig"), ("PT-RADIOLINK-MIB", "duplexDistance"), ("PT-RADIOLINK-MIB", "duplexType"), ("PT-RADIOLINK-MIB", "expectedFarEndId"), ("PT-RADIOLINK-MIB", "fadeNotificationTimer"), ("PT-RADIOLINK-MIB", "farEndIdCheck"), ("PT-RADIOLINK-MIB", "frameId"), ("PT-RADIOLINK-MIB", "frequencyStepSize"), ("PT-RADIOLINK-MIB", "id"), ("PT-RADIOLINK-MIB", "inputPowerAlarmThreshold"), ("PT-RADIOLINK-MIB", "licensedCapacity"), ("PT-RADIOLINK-MIB", "limitedTotalCapacity"), ("PT-RADIOLINK-MIB", "manualSwitch"), ("PT-RADIOLINK-MIB", "maxRxFrequency"), ("PT-RADIOLINK-MIB", "maxTxFrequency"), ("PT-RADIOLINK-MIB", "mimoStatus"), ("PT-RADIOLINK-MIB", "minRxFrequency"), ("PT-RADIOLINK-MIB", "minTxFrequency"), ("PT-RADIOLINK-MIB", "mlhcAdminStatus"), ("PT-RADIOLINK-MIB", "mlhcMplsConfig"), ("PT-RADIOLINK-MIB", "mlhcOperStatus"), ("PT-RADIOLINK-MIB", "plcAdminStatus"), ("PT-RADIOLINK-MIB", "plcOperStatus"), ("PT-RADIOLINK-MIB", "mode"), ("PT-RADIOLINK-MIB", "neIpAddress"), ("PT-RADIOLINK-MIB", "neIpv6Address"), ("PT-RADIOLINK-MIB", "neName"), ("PT-RADIOLINK-MIB", "neType"), ("PT-RADIOLINK-MIB", "plannedAlignmentInputPower"), ("PT-RADIOLINK-MIB", "polarization"), ("PT-RADIOLINK-MIB", "protectionStatus"), ("PT-RADIOLINK-MIB", "protectionSwitchMode"), ("PT-RADIOLINK-MIB", "referenceSec"), ("PT-RADIOLINK-MIB", "revertivePreferredTx"), ("PT-RADIOLINK-MIB", "revertiveWaitToRestore"), ("PT-RADIOLINK-MIB", "rfLoop"), ("PT-RADIOLINK-MIB", "rltDistinguishedName"), ("PT-RADIOLINK-MIB", "rltStatus"), ("PT-RADIOLINK-MIB", "rxFrequency"), ("PT-RADIOLINK-MIB", "selectedMaxAcm"), ("PT-RADIOLINK-MIB", "selectedMaxCapacity"), ("PT-RADIOLINK-MIB", "selectedMaxOutputPower"), ("PT-RADIOLINK-MIB", "selectedMinAcm"), ("PT-RADIOLINK-MIB", "selectedMinCapacity"), ("PT-RADIOLINK-MIB", "selectedMinOutputPower"), ("PT-RADIOLINK-MIB", "selectedOutputPowerType"), ("PT-RADIOLINK-MIB", "targetInputPowerFarEnd"), ("PT-RADIOLINK-MIB", "txAdminStatus"), ("PT-RADIOLINK-MIB", "txFrequency"), ("PT-RADIOLINK-MIB", "txOperStatus"), ("PT-RADIOLINK-MIB", "wantedLicensedCapacity"), ("PT-RADIOLINK-MIB", "xpicStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptRadioLinkCompleteGroup = ptRadioLinkCompleteGroup.setStatus('current')
if mibBuilder.loadTexts: ptRadioLinkCompleteGroup.setDescription('A collection of all current objects in this MIB module.')
mibBuilder.exportSymbols("PT-RADIOLINK-MIB", availableMaxCapacity=availableMaxCapacity, availableMinAcm=availableMinAcm, selectedMinAcm=selectedMinAcm, ctBBE=ctBBE, ctESR=ctESR, ptRadioLinkCompliances=ptRadioLinkCompliances, atpcFallbackOutputPower=atpcFallbackOutputPower, selectedOutputPowerType=selectedOutputPowerType, txOperStatus=txOperStatus, XpicMimoTC=XpicMimoTC, ctCurrent24hSES=ctCurrent24hSES, actualInputPower=actualInputPower, atpcFallback=atpcFallback, ctCurrent24hBBER=ctCurrent24hBBER, neIpAddress=neIpAddress, ctCurrent24hBBE=ctCurrent24hBBE, ctCurrent15mBB=ctCurrent15mBB, berAlarmThreshold=berAlarmThreshold, frequencyStepSize=frequencyStepSize, ctDistinguishedName=ctDistinguishedName, ctCurrent15mSES=ctCurrent15mSES, availableMinOutputPower=availableMinOutputPower, licensedCapacity=licensedCapacity, selectedMinCapacity=selectedMinCapacity, neType=neType, targetInputPowerFarEnd=targetInputPowerFarEnd, ctCurrent24hESR=ctCurrent24hESR, ctPerformance=ctPerformance, actualRxAcmTC=actualRxAcmTC, ctG826Reset=ctG826Reset, availableMaxOutputPower=availableMaxOutputPower, ctCurrent15mSESR=ctCurrent15mSESR, description=description, actualXpi=actualXpi, ctCurrent24hSESR=ctCurrent24hSESR, maxRxFrequency=maxRxFrequency, ctCurrent24hES=ctCurrent24hES, expectedFarEndId=expectedFarEndId, PYSNMP_MODULE_ID=ptRadioLink, revertiveWaitToRestore=revertiveWaitToRestore, ctCurrent15mESR=ctCurrent15mESR, actualSi=actualSi, ctG826TimeElapsed=ctG826TimeElapsed, ctTable=ctTable, ctBBER=ctBBER, plcAdminStatus=plcAdminStatus, actualTxCapacity=actualTxCapacity, farEndIdCheck=farEndIdCheck, maxTxFrequency=maxTxFrequency, id=id, protectionStatus=protectionStatus, selectedMaxAcm=selectedMaxAcm, ctG826Current24hEntry=ctG826Current24hEntry, plannedAlignmentInputPower=plannedAlignmentInputPower, actualRxAcm=actualRxAcm, ctG826Current15mTimeElapsed=ctG826Current15mTimeElapsed, fadeNotificationTimer=fadeNotificationTimer, channelSpacing=channelSpacing, wantedLicensedCapacity=wantedLicensedCapacity, duplexType=duplexType, EnableStatusTC=EnableStatusTC, ctBB=ctBB, txFrequency=txFrequency, actualTxAcmTC=actualTxAcmTC, actualTxTotalCapacity=actualTxTotalCapacity, plcOperStatus=plcOperStatus, autoFreqSelection=autoFreqSelection, carrierId=carrierId, manualSwitch=manualSwitch, rltStatus=rltStatus, rltTable=rltTable, ctG826Current15mTable=ctG826Current15mTable, cpriMode=cpriMode, ctG826Current24hTimeElapsed=ctG826Current24hTimeElapsed, referenceSec=referenceSec, availableOutputPowerType=availableOutputPowerType, duplexDistance=duplexDistance, atpcFallbackTimer=atpcFallbackTimer, selectedMaxOutputPower=selectedMaxOutputPower, limitedTotalCapacity=limitedTotalCapacity, ctCurrent15mES=ctCurrent15mES, neIpv6Address=neIpv6Address, selectedMinOutputPower=selectedMinOutputPower, ctCurrent24hUAS=ctCurrent24hUAS, AcmTC=AcmTC, alignmentMode=alignmentMode, mlhcOperStatus=mlhcOperStatus, mlhcMplsConfig=mlhcMplsConfig, actualOutputPower=actualOutputPower, ptRadioLinkGroups=ptRadioLinkGroups, ctG826ContinuousTable=ctG826ContinuousTable, ctEntry=ctEntry, availableMaxAcm=availableMaxAcm, rfLoop=rfLoop, rxFrequency=rxFrequency, ctSESR=ctSESR, ptRadioLinkFullCompliance=ptRadioLinkFullCompliance, protectionSwitchMode=protectionSwitchMode, availableMinCapacity=availableMinCapacity, ctCurrent15mBBER=ctCurrent15mBBER, ctG826Current24hTable=ctG826Current24hTable, frameId=frameId, polarization=polarization, ctStatus=ctStatus, mode=mode, ctSES=ctSES, ctES=ctES, ctG826ContinuousEntry=ctG826ContinuousEntry, revertivePreferredTx=revertivePreferredTx, txAdminStatus=txAdminStatus, neName=neName, actualSnir=actualSnir, ctCurrent15mBBE=ctCurrent15mBBE, ptRadioLink=ptRadioLink, ptRadioLinkCompleteGroup=ptRadioLinkCompleteGroup, ptRadioLinkConformance=ptRadioLinkConformance, autoFreqSelectedChannel=autoFreqSelectedChannel, mimoStatus=mimoStatus, minRxFrequency=minRxFrequency, cpriStatus=cpriStatus, rltEntry=rltEntry, mlhcAdminStatus=mlhcAdminStatus, actualTxAcm=actualTxAcm, ctCurrent24hBB=ctCurrent24hBB, rltDistinguishedName=rltDistinguishedName, inputPowerAlarmThreshold=inputPowerAlarmThreshold, selectedMaxCapacity=selectedMaxCapacity, autoFreqSelectionStatus=autoFreqSelectionStatus, duplexConfig=duplexConfig, ctG826Current15mEntry=ctG826Current15mEntry, ctUAS=ctUAS, ctCurrent15mUAS=ctCurrent15mUAS, minTxFrequency=minTxFrequency, xpicStatus=xpicStatus)
