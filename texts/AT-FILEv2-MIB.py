#
# PySNMP MIB module AT-FILEv2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/allied/AT-FILEv2-MIB
# Produced by pysmi-1.1.8 at Fri Jan 27 15:40:12 2023
# On host fv-az551-95 platform Linux version 5.15.0-1031-azure by user runner
# Using Python version 3.10.9 (main, Dec  7 2022, 08:16:13) [GCC 11.3.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
modules, = mibBuilder.importSymbols("AT-SMI-MIB", "modules")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Integer32, Counter64, TimeTicks, NotificationType, Gauge32, Bits, ObjectIdentity, Counter32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Unsigned32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "Counter64", "TimeTicks", "NotificationType", "Gauge32", "Bits", "ObjectIdentity", "Counter32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Unsigned32", "iso")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
atFilev2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600))
atFilev2.setRevisions(('2017-03-31 00:00', '2014-04-30 00:00', '2014-04-23 00:00', '2014-04-16 00:00', '2014-01-17 00:00', '2012-09-27 00:00', '2012-09-21 00:00', '2012-05-22 05:00', '2012-05-07 00:00', '2011-09-12 00:00', '2011-05-30 00:00', '2011-04-21 00:00', '2011-03-24 00:00', '2011-01-26 00:00', '2010-09-07 00:00', '2010-06-14 04:59', '2008-12-05 00:00', '2008-11-11 00:00', '2008-09-24 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atFilev2.setRevisionsDescriptions(("Remove '_' in the MIB object names to comply with the ASN.1 standard.", 'Updated decriptions to refer to chassisMappingTable', 'Added more descriptions to atFilev2FileViewerDevice', 'Added more descriptions to atFilev2StackID, atFilev2SourceStackID,\n                 atFilev2DestinationStackID, atFilev2DirStackID, atFilev2USBMediaStackMemberId,\n                 atFilev2FileViewerStackId for VCStack Plus.', 'Obsoleted atFilev2InfoTable table, so this cannot be used in the future', 'Deprecate atFilev2InfoTable table, since this has been replaced by\n                atFilev2FileViewer table.', 'Added chassis switch (e.g. SBx8100) descriptions to stack-related MIB objects', 'Change syntax of atFilev2DirFileSystem to have USB in line with\n                its definition in other parts of the MIB.', 'Added atFilev2FileViewer group. This allows a directory at a\n                time view of files on the device. This change also foreshadows\n                the deprecation of the atFilev2InfoTable, which the\n                atFilev2FileViewer group replaces. However, the InfoTable will\n                be left in place as a transition mechanism. However, support for\n                SD cards and USB memory devices has been removed from this table.', 'Added support for USB media.', 'Updated enumeration type to use INTEGER.', 'Clarified object descriptions.', 'Obsoleted existing file listing objects and created\n                replacements.', 'Added new objects to manipulate directories.', 'Generic syntax tidy up', 'MIB revision history dates in descriptions updated.', 'Added SD card table.', 'Normalised object names.', 'Initial revision.',))
if mibBuilder.loadTexts: atFilev2.setLastUpdated('201703310000Z')
if mibBuilder.loadTexts: atFilev2.setOrganization('Allied Telesis Labs New Zealand')
if mibBuilder.loadTexts: atFilev2.setContactInfo('http://www.alliedtelesis.com')
if mibBuilder.loadTexts: atFilev2.setDescription('The AT File v2 MIB, for listing file contents of flash, nvs\n                and sd-cards on local and stacked devices, and copying, moving\n                and deleting files from local, stacked and remote sources.')
atFilev2TableOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 1))
atFilev2Recursive = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2Recursive.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2Recursive.setDescription("Set a value of '1' to enable recursive listing of directories\n                in the atFilev2Table listing.\n                \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.")
atFilev2AllFiles = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2AllFiles.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2AllFiles.setDescription("Set a value of '1' to enable listing of all files (including\n                hidden etc) in the atFilev2Table listing.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.")
atFilev2Device = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2Device.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2Device.setDescription('Set a value that corresponds with the various devices listed\n                below:\n\n                1. Flash (default)\n                2. Card\n                3. NVS\n\n                Subsequent SNMP queries to the atFilev2Table will use this as\n                the device to generate a file listing from.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2StackID = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 1, 4), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2StackID.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2StackID.setDescription('Set an integer to correspond to the stack ID of a stack\n                member. For devices that are not capable of being stacked, set\n                with the value 1. For a chassis switch, it corresponds to the\n                card ID. For VCStack Plus, 1-12 refers to the cards on VCS stack\n                member 1 and 13-24 refers to the cards on VCS stack member 2.\n                Refer to chassisMappingTable for more details.\n\n                Subsequent SNMP queries to the atFilev2Table will use this as\n                the stack member to generate a file listing from.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2Table = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2), )
if mibBuilder.loadTexts: atFilev2Table.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2Table.setDescription('A list of files present on the device and stack-member\n                specified by the atFilev2Device and atFilev2StackID objects.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2, 1), ).setIndexNames((0, "AT-FILEv2-MIB", "atFilev2Filename"))
if mibBuilder.loadTexts: atFilev2Entry.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2Entry.setDescription('An entry in the list of files containing information about a\n                single file.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2Filename = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 112))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2Filename.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2Filename.setDescription("The name of the file. Files are sorted in alphabetical order.\n                Directory names end with / and have a 'd' present in the\n                atFilev2FileAttribs object.\n\n                The filename is truncated at 112 characters due to SNMP OID\n                length limitations. If two files are not uniquely\n                distinguishable within the first 112 characters, the listing\n                will halt after the first file.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.")
atFilev2FileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileSize.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2FileSize.setDescription('The size of the file in bytes.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2FileCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileCreationTime.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2FileCreationTime.setDescription('File creation time in the form <MMM DD YYYY HH:MM:SS>.\n                Eg: Sep 7 2008 06:07:54.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2FileAttribs = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileAttribs.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2FileAttribs.setDescription('The standard file accessibility attributes in the form <drwx>.\n\n                d - directory\n                r - readable\n                w - writeable\n                x - executable\n\n                If a file does not have a particular attribute set, the\n                respective position will contain a -. For example, <-r-x>\n                indicates a readable and executable file that is not a\n                directory or writeable.\n            \n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2FileOperation = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3))
atFilev2SourceStackID = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2SourceStackID.setStatus('current')
if mibBuilder.loadTexts: atFilev2SourceStackID.setDescription('Set to the stack ID of the source device to be used for the\n                file operation. For devices that are not capable of being\n                stacked, set with the value 1. For a chassis switch, it\n                corresponds to the card ID. For VCStack Plus, 1-12 refers\n                to the cards on VCS stack member 1 and 13-24 refers to the\n                cards on VCS stack member 2. Refer to chassisMappingTable\n                for more details.\n                \n                This value is ignored if the source device is set to TFTP.')
atFilev2SourceDevice = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flash", 1), ("card", 2), ("nvs", 3), ("tftp", 4), ("usb", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2SourceDevice.setStatus('current')
if mibBuilder.loadTexts: atFilev2SourceDevice.setDescription('Set to the value representing the source file system to be\n                used for the file operation:\n\n                  1. Flash\n                  2. Card\n                  3. NVS\n                  4. TFTP\n                  5. USB\n\n                For copying files, any combination of source and destination\n                file system types may be selected, with the exception of TFTP\n                to TFTP, which is not supported.\n\n                For moving files, TFTP may not be selected as the source or\n                destination file system type.\n\n                For deleting files, the source file system type cannot be TFTP.\n\n                All required parameters must be fully configured before an\n                operation can commence. Where a TFTP operation is configured,\n                an IP address must also be set via atFilev2TftpIPAddr.')
atFilev2SourceFilename = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2SourceFilename.setStatus('current')
if mibBuilder.loadTexts: atFilev2SourceFilename.setDescription('The filename of the source file to be copied, moved or deleted.\n                Include any path as required, but the file system type is not\n                necessary.\n\n                For example, to copy the file latest.cfg from the\n                backupconfigs/routers directory on the TFTP server, this object\n                should be set to:\n\n                  backupconfigs/routers/latest.cfg')
atFilev2DestinationStackID = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DestinationStackID.setStatus('current')
if mibBuilder.loadTexts: atFilev2DestinationStackID.setDescription('Set to the stack ID of the destination device to be used for\n                the file operation. For devices that are not capable of being\n                stacked, set with the value 1. For a chassis switch, it\n                corresponds to the card ID. For VCStack Plus, 1-12 refers to\n                the cards on VCS stack member 1 and 13-24 refers to the cards\n                on VCS stack member 2. Refer to chassisMappingTable for more details.\n\n                This value is ignored if the destination device is set to TFTP,\n                or if a deletion operation is carried out.')
atFilev2DestinationDevice = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flash", 1), ("card", 2), ("nvs", 3), ("tftp", 4), ("usb", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DestinationDevice.setStatus('current')
if mibBuilder.loadTexts: atFilev2DestinationDevice.setDescription('Set to the value representing the destination file system to\n                be used for the file operation:\n\n                  1. Flash\n                  2. Card\n                  3. NVS\n                  4. TFTP\n                  5. USB\n\n                For copying files, any combination of source and destination\n                file system types may be selected, with the exception of TFTP\n                to TFTP, which is not supported.\n\n                For moving files, TFTP may not be selected as the source or\n                destination file system type.\n\n                For deleting files, this object is ignored.\n\n                All required parameters must be fully configured before an\n                operation can commence. Where a TFTP operation is configured,\n                an IP address must also be set via atFilev2TftpIPAddr.')
atFilev2DestinationFilename = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DestinationFilename.setStatus('current')
if mibBuilder.loadTexts: atFilev2DestinationFilename.setDescription('The destination filename for the copy or move operation.\n                Include any path as required, but the file system type is not\n                necessary. The destination filename does not need to be the\n                same as the source filename, and this object is ignored for\n                file deletion operations.\n\n                For example, to copy a release file from a TFTP server to the\n                backuprelease directory on the flash file system, this object\n                should be set to:\n\n                  backuprelease/latest.rel\n\n                Note: Any file at the destination that shares the destination\n                filename will be overwritten by a move or copy operation.')
atFilev2CopyBegin = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2CopyBegin.setStatus('current')
if mibBuilder.loadTexts: atFilev2CopyBegin.setDescription("A read on this object can return several possible values,\n                depending on the current status of the system and the\n                various file operation objects:\n\n                idle                               There is no file operation\n                                                   in progress and all required\n                                                   objects have been set\n                                                   correctly. Setting a '1' to\n                                                   this object will begin the\n                                                   file copy.\n\n                Error codes: [1-7]                 A copy operation cannot be\n                                                   started until these errors\n                                                   are resolved. See below for\n                                                   key.\n\n                [action]ing x [--> y]              A file operation is\n                                                   currently in progress. You\n                                                   cannot start another\n                                                   operation while the object\n                                                   is returning this value.\n\n                [action] x [--> y] success         The last copy, move or\n                                                   delete operation was\n                                                   successfully completed.\n\n                [action] x [--> y] failure: [err]  The last copy, move or\n                                                   delete operation failed,\n                                                   with the error message\n                                                   attached. Common failures\n                                                   include lack of space on the\n                                                   destination file system,\n                                                   incorrect source file names\n                                                   or communication errors with\n                                                   remote services.\n\n                Upon reading a success or failure message, the message will be\n                cleared and the next read will result in either an 'idle'\n                message or an 'Error codes' message if not all required objects\n                have been correctly set. If a read returns 'idle', a new file\n                operation can be started.\n\n                Error codes for file copy:\n\n                1 - atFilev2SourceDevice has not been set\n                2 - atFilev2SourceFilename has not been set\n                3 - atFilev2DestinationDevice has not been set\n                4 - atFilev2DestinationFilename has not been set\n                5 - atFilev2SourceDevice and atFilev2DestinationDevice are both\n                    set to TFTP\n                6 - the combination of source device, stackID and filename is\n                    the same as the destination device, stackID and filename\n                    (i.e. it is not valid to copy a file onto itself.\n                7 - TFTP IP address has not been set and TFTP has been set for\n                    one of the devices\n\n                Note that if the above requirements are met and the operation\n                would result in a system file being modified, then an SNMP set\n                to this object will be disallowed.\n                \n                For valid operations, immediately upon executing the SNMP set\n                operation on this object, the file copy will begin and will\n                continue on the device until either it has completed, or a\n                failure occurs. For large files, operations can take several\n                minutes to complete.\n\n                Subsequent reads of the object will return one of the messages\n                shown above, to track the progress of the copy operation.")
atFilev2MoveBegin = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2MoveBegin.setStatus('current')
if mibBuilder.loadTexts: atFilev2MoveBegin.setDescription("A read on this object can return several possible values,\n                depending on the current status of the system and the various\n                file operation objects:\n\n                idle                               There is no file operation\n                                                   in progress and all required\n                                                   objects have been set\n                                                   correctly. Setting a '1' to\n                                                   this object will begin the\n                                                   file move.\n\n                Error codes: [1-6]                 A move operation cannot be\n                                                   started until these errors\n                                                   are resolved. See below for\n                                                   key.\n\n                [action]ing x [--> y]              A file operation is\n                                                   currently in progress. You\n                                                   cannot start another\n                                                   operation while the object\n                                                   is returning this value.\n\n                [action] x [--> y] success         The last copy, move or\n                                                   delete operation was\n                                                   successfully completed.\n\n                [action] x [--> y] failure: [err]  The last copy, move or\n                                                   delete operation failed,\n                                                   with the error message\n                                                   attached. Common failures\n                                                   include lack of space on the\n                                                   destination file system,\n                                                   incorrect source file names\n                                                   or communication errors with\n                                                   remote services.\n\n                Upon reading a success or failure message, the message will be\n                cleared and the next read will result in either an 'idle'\n                message or an 'Error codes' message if not all required objects\n                have been correctly set. If a read returns 'idle', a new file\n                operation can be started.\n\n                Error codes for file move:\n\n                1 - atFilev2SourceDevice has not been set\n                2 - atFilev2SourceFilename has not been set\n                3 - atFilev2DestinationDevice has not been set\n                4 - atFilev2DestinationFilename has not been set\n                5 - either atFilev2SourceDevice or atFilev2DestinationDevice\n                    are set to TFTP\n                6 - the combination of source device, stackID and filename is\n                    the same as the destination device, stackID and filename\n                    (i.e. it is not valid to move a file onto itself.\n\n                Note that if the above requirements are met and the operation\n                would result in a system file being modified or deleted, then\n                an SNMP set to this object will be disallowed.\n                \n                For valid operations, immediately upon executing the SNMP set\n                operation on this object, the file move will begin and will\n                continue on the device until either it has completed, or a\n                failure occurs. For large files, operations can take several\n                minutes to complete.\n\n                Subsequent reads of the object will return one of the messages\n                shown above, to track the progress of the move operation.")
atFilev2DeleteBegin = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DeleteBegin.setStatus('current')
if mibBuilder.loadTexts: atFilev2DeleteBegin.setDescription("A read on this object can return several possible values,\n                depending on the current status of the system and the various\n                file operation objects:\n\n                idle                               There is no file operation\n                                                   in progress and all required\n                                                   objects have been set\n                                                   correctly. Setting a '1' to\n                                                   this object will begin the\n                                                   file deletion.\n\n                Error codes: [1-3]                 A delete operation cannot be\n                                                   started until these errors\n                                                   are resolved. See below for\n                                                   key.\n\n                [action]ing x [--> y]              A file operation is\n                                                   currently in progress. You\n                                                   cannot start another\n                                                   operation while the object\n                                                   is returning this value.\n\n                [action] x [--> y] success         The last copy, move or\n                                                   delete operation was\n                                                   successfully completed.\n\n                [action] x [--> y] failure: [err]  The last copy, move or\n                                                   delete operation failed,\n                                                   with the error message\n                                                   attached. Common failures\n                                                   include lack of space on the\n                                                   destination file system,\n                                                   incorrect source file names\n                                                   or communication errors with\n                                                   remote services.\n\n                Upon reading a success or failure message, the message will be\n                cleared and the next read will result in either an 'idle'\n                message or an 'Error codes' message if not all required objects\n                have been correctly set. If a read returns 'idle', a new file\n                operation can be started.\n\n                File deletion operations ignore the values set in the\n                atFilev2DestinationStackID, atFilev2DestinationDevice and\n                atFilev2DestinationFilename objects.\n\n                Error codes for file deletion:\n\n                1 - atFilev2SourceDevice has not been set\n                2 - atFilev2SourceFilename has not been set\n                3 - atFilev2SourceDevice has been set to TFTP\n\n                Note that if the above requirements are met and the operation\n                would result in a system file being deleted, then an SNMP set\n                to this object will be disallowed.\n                \n                For valid operations, immediately upon executing the SNMP set\n                operation on this object, the file deletion will begin and will\n                continue on the device until either it has completed, or a\n                failure occurs. For large files, operations can take several\n                minutes to complete.\n\n                Subsequent reads of the object will return one of the messages\n                shown above, to track the progress of the deletion operation.")
atFilev2Flash1 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 10))
atFilev2Card2 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 11))
atFilev2Nvs3 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 12))
atFilev2Tftp4 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 13))
atFilev2TftpIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 13, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2TftpIPAddr.setStatus('current')
if mibBuilder.loadTexts: atFilev2TftpIPAddr.setDescription('The IP address of the TFTP server that is to be used for the\n                file copy process. This IP address needs to be reachable from\n                the device or the file copy will fail.')
atFilev2Usb5 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 15))
atFilev2DirOperation = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14))
atFilev2DirStackID = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DirStackID.setStatus('current')
if mibBuilder.loadTexts: atFilev2DirStackID.setDescription('Set to the stack ID of the device containing the directory to\n\t              be renamed or deleted, or to the stack ID of the device on\n\t              which to create a new directory. For devices that are not\n                      capable of being stacked, set with the value 1. For a chassis\n                      switch, it corresponds to the card ID. For VCStack Plus,\n                      1-12 refers to the cards on VCS stack member 1 and 13-24 refers\n                      to the cards on VCS stack member 2.\n                      Refer to chassisMappingTable for more details.')
atFilev2DirFileSystem = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("flash", 1), ("card", 2), ("nvs", 3), ("usb", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DirFileSystem.setStatus('current')
if mibBuilder.loadTexts: atFilev2DirFileSystem.setDescription('Set to the value representing the file system on which the\n\t              existing directory resides, or on which a new directory should\n\t              be created:\n\n\t                1. Flash\n\t                2. Card\n\t                3. NVS\n\t                5. USB')
atFilev2DirPath = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DirPath.setStatus('current')
if mibBuilder.loadTexts: atFilev2DirPath.setDescription("This object should be set to the path of the directory to be\n\t              created/deleted/renamed, but should not include the name of the\n\t              directory itself, or the file system on which it resides.\n\n\t              For example, to delete directory 'backupconfigs/old' from the\n\t              flash filesystem, this object should be set to 'backupconfigs'.")
atFilev2SourceDirName = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2SourceDirName.setStatus('current')
if mibBuilder.loadTexts: atFilev2SourceDirName.setDescription("This object is required for directory deletion or rename\n\t              operations only. It should be set to the name of the directory\n\t              to be deleted/renamed, but should not include any path data.\n                Operations on hidden directories are not supported.\n\n\t              For example, to delete directory 'backupconfigs/old' from the\n\t              flash filesystem, this object should be set to 'old'.")
atFilev2DestDirName = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2DestDirName.setStatus('current')
if mibBuilder.loadTexts: atFilev2DestDirName.setDescription("This object is required for directory creation or rename\n\t              operations only. It should be set to the name of the directory\n\t              to be created, or the destination directory name for a rename\n\t              operation. It should not include any path data and operations\n\t              on hidden directories are not supported.\n\n\t              For example, to create directory 'backupconfigs/old' on the\n\t              flash filesystem, this object should be set to 'old'.")
atFilev2BeginDirOperation = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 1), ("createDir", 2), ("renameDir", 3), ("deleteEmptyDir", 4), ("deleteForceDir", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2BeginDirOperation.setStatus('current')
if mibBuilder.loadTexts: atFilev2BeginDirOperation.setDescription("A read of this object will always return 'idle' (1). All\n\t              applicable objects above must have been set correctly in order\n\t              to commence an operation.\n\t              \n\t              The following values may be set to perform the operations\n\t              described:\n\n\t                createDir (2) :      This will create a new directory with a\n\t                                     name equating to atFilev2DestDirName, on\n\t                                     the device indicated by\n\t                                     atFilev2DirStackID, and the file system\n\t                                     indicated by atFilev2DirFileSystem, with\n\t                                     the path to the directory being\n\t                                     indicated by atFilev2DirPath. The given\n\t                                     path structure must already exist.\n\n\t                renameDir (3) :      This will rename an existing directory\n\t                                     with a name equating to\n\t                                     atFilev2SourceDirName, to a name\n\t                                     equating to atFilev2DestDirName on the\n\t                                     device indicated by atFilev2DirStackID,\n\t                                     and the file system indicated by\n\t                                     atFilev2DirFileSystem, with the path to\n\t                                     the directory being indicated by\n\t                                     atFilev2DirPath. The given path\n\t                                     structure and source directory must\n\t                                     already exist, and a rename operation\n\t                                     cannot change the path where the\n\t                                     directory currently resides.\n\n\t                deleteEmptyDir (4) : This will delete an existing directory\n\t                                     with a name equating to\n\t                                     atFilev2SourceDirName, on the device\n\t                                     indicated by atFilev2DirStackID, and the\n\t                                     file system indicated by\n\t                                     atFilev2DirFileSystem, with the path to\n\t                                     the directory being indicated by\n\t                                     atFilev2DirPath. However, the operation\n\t                                     will fail if the specified directory is\n\t                                     not empty. Only sub-directories within\n\t                                     the specified file system can be\n\t                                     deleted.\n\n\t                deleteForceDir (5) : This will delete an existing directory\n\t                                     with a name equating to\n\t                                     atFilev2SourceDirName, on the device\n\t                                     indicated by atFilev2DirStackID, and the\n\t                                     file system indicated by\n\t                                     atFilev2DirFileSystem, with the path to\n\t                                     the directory being indicated by\n\t                                     atFilev2DirPath. The operation will also\n\t                                     automatically delete any contents within\n\t                                     the specified directory. Only sub-\n\t                                     directories within the specified file\n\t                                     system can be deleted.")
atFilev2LastDirOpResult = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 3, 14, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2LastDirOpResult.setStatus('current')
if mibBuilder.loadTexts: atFilev2LastDirOpResult.setDescription('Gives an indication of the result of the last completed SNMP\n\t              directory operation.')
atFilev2SDcardTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 4), )
if mibBuilder.loadTexts: atFilev2SDcardTable.setStatus('current')
if mibBuilder.loadTexts: atFilev2SDcardTable.setDescription('A table of information about SD cards.')
atFilev2SDcardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 4, 1), ).setIndexNames((0, "AT-FILEv2-MIB", "atFilev2SDcardStackMemberId"))
if mibBuilder.loadTexts: atFilev2SDcardEntry.setStatus('current')
if mibBuilder.loadTexts: atFilev2SDcardEntry.setDescription('Data pertaining to an SD card instance.')
atFilev2SDcardStackMemberId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 4, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2SDcardStackMemberId.setStatus('current')
if mibBuilder.loadTexts: atFilev2SDcardStackMemberId.setDescription('The index of the stack member hosting this SD card. For\n                devices that are not capable of being stacked, this object will\n                always return the value 1.')
atFilev2SDcardPresence = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2SDcardPresence.setStatus('current')
if mibBuilder.loadTexts: atFilev2SDcardPresence.setDescription('This object indicates whether or not an SD card is inserted\n                in a slot.')
atFilev2InfoTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5), )
if mibBuilder.loadTexts: atFilev2InfoTable.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoTable.setDescription('A list of all files, including pathnames, that are present on\n                the device. Hidden system files are not displayed.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1), ).setIndexNames((1, "AT-FILEv2-MIB", "atFilev2InfoFilepath"))
if mibBuilder.loadTexts: atFilev2InfoEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoEntry.setDescription('An entry in the list of files, containing information about a\n                single file.\n\n                NOTE: atFilev2Table and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFilepath = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 112))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFilepath.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFilepath.setDescription('The full path and name of the file. Files are sorted in\n                alphabetical order, and any filepath that is longer than 112\n                characters will not be displayed due to SNMP OID length\n                limitations.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileSize.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileSize.setDescription('The size of the file in bytes.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileCreationTime.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileCreationTime.setDescription('File creation time in the form <MMM DD YYYY HH:MM:SS>.\n                Eg: Sep 7 2008 06:07:54.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileIsDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileIsDirectory.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileIsDirectory.setDescription('Returns TRUE if the entry is a directory, FALSE otherwise.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileIsReadable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileIsReadable.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileIsReadable.setDescription('Returns TRUE if the file is readable, FALSE otherwise.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileIsWriteable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileIsWriteable.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileIsWriteable.setDescription('Returns TRUE if the file is writeable, FALSE otherwise.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2InfoFileIsExecutable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 5, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2InfoFileIsExecutable.setStatus('obsolete')
if mibBuilder.loadTexts: atFilev2InfoFileIsExecutable.setDescription('Returns TRUE if the file is executable, FALSE otherwise.\n\n                NOTE: atFilev2InfoTable and associated objects have been replaced\n                by atFilev2FileViewer.')
atFilev2USBMediaTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 6), )
if mibBuilder.loadTexts: atFilev2USBMediaTable.setStatus('current')
if mibBuilder.loadTexts: atFilev2USBMediaTable.setDescription('A table of information about USB media.')
atFilev2USBMediaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 6, 1), ).setIndexNames((0, "AT-FILEv2-MIB", "atFilev2USBMediaStackMemberId"))
if mibBuilder.loadTexts: atFilev2USBMediaEntry.setStatus('current')
if mibBuilder.loadTexts: atFilev2USBMediaEntry.setDescription('Data pertaining to an USB media instance.')
atFilev2USBMediaStackMemberId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 6, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2USBMediaStackMemberId.setStatus('current')
if mibBuilder.loadTexts: atFilev2USBMediaStackMemberId.setDescription('The index of the stack member hosting this USB media. For\n                devices that are not capable of being stacked, this object will\n                always return the value 1. For a chassis switch, it corresponds\n                to the card ID. For VCStack Plus, 1-12 refers to the cards on\n                VCS stack member 1 and 13-24 refers to the cards on VCS stack\n                member 2. Refer to chassisMappingTable for more details.')
atFilev2USBMediaPresence = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2USBMediaPresence.setStatus('current')
if mibBuilder.loadTexts: atFilev2USBMediaPresence.setDescription('This object indicates whether or not an USB media is inserted\n                in a slot.')
atFilev2FileViewer = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7))
atFilev2FileViewerStackId = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 1), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2FileViewerStackId.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerStackId.setDescription("The stack ID of the stack member for which files will be displayed\n                in the FileViewer table. For devices that are not capable of being\n                stacked, this variable will always read as 1, and will cause an error\n                on being written to with any value other than 1.\n\n                Write this variable with the stack ID of the stack member for which\n                a view of files is required. If the stack member doesn't exist, an\n                error will be returned. For a chassis switch, it corresponds to\n                the card ID. For VCStack Plus, 1-12 refers to the cards on VCS stack\n                member 1 and 13-24 refers to the cards on VCS stack member 2.\n                Refer to chassisMappingTable for more details.\n\n                Note that the other variables specifying the files to view will\n                not be altered by changing the stack ID, which means that the\n                file view table could be empty if a non-existant device or path\n                has been referenced previously.")
atFilev2FileViewerDevice = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("flash", 1), ("card", 2), ("nvs", 3), ("tftp", 4), ("usb", 5))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2FileViewerDevice.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerDevice.setDescription("The file system device for which files will be displayed in the\n                FileViewer table. The values supported for this variable are\n                identical to the values for other variables in the MIB, although not\n                all values will actually result in the display of files.\n\n                The different devices and whether they will result in the display\n                of files are:\n\n                  1. Flash - Onboard Flash - supported\n                  2. Card - Removable SD card - supported\n                  3. NVS - Onboard battery backed RAM - supported\n                  4. TFTP - not supported\n                  5. USB - Removable USB media - supported\n\n                Note: Card and USB are supported on the stack master or Active\n                CFC. The devices cannot be read if atFilev2FileViewerStackId is\n                set with the ID of a different stack member or chassis card.\n\n                Setting this variable to an unsupported value will result in an error,\n                but setting to a value that is supported but on a system that doesn't\n                contain that type of device will not. However, no files will be\n                displayed in the File Viewer table in this case.")
atFilev2FileViewerCurrentPath = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atFilev2FileViewerCurrentPath.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerCurrentPath.setDescription("The file system path for which files will be displayed in\n                the FileViewer table. This path will always read as a full\n                pathname starting with the '/' character.\n\n                Setting this variable will specify a new directory for which\n                files will be displayed. The path specified must be the full\n                path, relative setting of path does not work. Only paths with\n                invalid characters in them will cause an error, paths specifying\n                non-existant directories will be accepted, but no files will be\n                displayed in the File Viewer table in this case.")
atFilev2FileViewerTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4), )
if mibBuilder.loadTexts: atFilev2FileViewerTable.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerTable.setDescription('A list of all files, not including pathnames, that are present\n                on the device specified by atFilev2FileViewerStackId and\n                atFilev2FileViewerDevice, in the path specified by\n                atFilev2FileViewerCurrentPath.\n\n                Hidden and system files are not displayed.\n\n                If the Stack ID, device and path are invalid (the path is for\n                a non-existant directory), the table will be empty. This will\n                allow a MIB walk through the table even though the setup\n                parameters are incorrect.')
atFilev2FileViewerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1), ).setIndexNames((1, "AT-FILEv2-MIB", "atFilev2FileViewerName"))
if mibBuilder.loadTexts: atFilev2FileViewerEntry.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerEntry.setDescription('An entry in the list of files, containing information about a\n                single file.')
atFilev2FileViewerName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 112))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerName.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerName.setDescription('The name of the file. Files are sorted in alphabetical order,\n                and any name that is longer than 112 characters will not be\n                displayed due to SNMP OID length limitations.')
atFilev2FileViewerSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerSize.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerSize.setDescription('The size of the file in bytes.')
atFilev2FileViewerCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerCreationTime.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerCreationTime.setDescription('File creation time in the form <MMM DD YYYY HH:MM:SS>.\n                Eg: Sep 7 2008 06:07:54.')
atFilev2FileViewerIsDirectory = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerIsDirectory.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerIsDirectory.setDescription('Returns TRUE if the entry is a directory, FALSE otherwise.')
atFilev2FileViewerIsReadable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerIsReadable.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerIsReadable.setDescription('Returns TRUE if the file is readable, FALSE otherwise.')
atFilev2FileViewerIsWriteable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerIsWriteable.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerIsWriteable.setDescription('Returns TRUE if the file is writeable, FALSE otherwise.')
atFilev2FileViewerIsExecutable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 600, 7, 4, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atFilev2FileViewerIsExecutable.setStatus('current')
if mibBuilder.loadTexts: atFilev2FileViewerIsExecutable.setDescription('Returns TRUE if the file is executable, FALSE otherwise.')
mibBuilder.exportSymbols("AT-FILEv2-MIB", atFilev2Table=atFilev2Table, atFilev2FileViewerCreationTime=atFilev2FileViewerCreationTime, atFilev2TableOptions=atFilev2TableOptions, atFilev2FileCreationTime=atFilev2FileCreationTime, atFilev2SourceStackID=atFilev2SourceStackID, atFilev2DeleteBegin=atFilev2DeleteBegin, atFilev2MoveBegin=atFilev2MoveBegin, atFilev2Flash1=atFilev2Flash1, atFilev2TftpIPAddr=atFilev2TftpIPAddr, atFilev2DestDirName=atFilev2DestDirName, atFilev2SDcardTable=atFilev2SDcardTable, atFilev2InfoFileIsDirectory=atFilev2InfoFileIsDirectory, atFilev2Recursive=atFilev2Recursive, atFilev2DirOperation=atFilev2DirOperation, atFilev2FileAttribs=atFilev2FileAttribs, atFilev2SDcardStackMemberId=atFilev2SDcardStackMemberId, atFilev2DestinationFilename=atFilev2DestinationFilename, atFilev2Tftp4=atFilev2Tftp4, atFilev2InfoFileIsWriteable=atFilev2InfoFileIsWriteable, atFilev2=atFilev2, atFilev2Usb5=atFilev2Usb5, atFilev2FileViewerStackId=atFilev2FileViewerStackId, atFilev2InfoTable=atFilev2InfoTable, atFilev2FileViewerDevice=atFilev2FileViewerDevice, atFilev2FileViewerIsExecutable=atFilev2FileViewerIsExecutable, atFilev2InfoEntry=atFilev2InfoEntry, atFilev2USBMediaStackMemberId=atFilev2USBMediaStackMemberId, atFilev2SourceFilename=atFilev2SourceFilename, atFilev2CopyBegin=atFilev2CopyBegin, atFilev2DirStackID=atFilev2DirStackID, atFilev2DirFileSystem=atFilev2DirFileSystem, atFilev2USBMediaTable=atFilev2USBMediaTable, atFilev2DestinationStackID=atFilev2DestinationStackID, atFilev2Entry=atFilev2Entry, atFilev2BeginDirOperation=atFilev2BeginDirOperation, atFilev2FileViewerIsWriteable=atFilev2FileViewerIsWriteable, atFilev2FileViewerCurrentPath=atFilev2FileViewerCurrentPath, atFilev2SourceDirName=atFilev2SourceDirName, atFilev2InfoFilepath=atFilev2InfoFilepath, atFilev2USBMediaEntry=atFilev2USBMediaEntry, atFilev2FileViewer=atFilev2FileViewer, atFilev2SDcardEntry=atFilev2SDcardEntry, atFilev2FileViewerTable=atFilev2FileViewerTable, atFilev2Filename=atFilev2Filename, atFilev2Card2=atFilev2Card2, atFilev2Device=atFilev2Device, atFilev2FileOperation=atFilev2FileOperation, atFilev2InfoFileIsReadable=atFilev2InfoFileIsReadable, atFilev2FileViewerEntry=atFilev2FileViewerEntry, PYSNMP_MODULE_ID=atFilev2, atFilev2SourceDevice=atFilev2SourceDevice, atFilev2DirPath=atFilev2DirPath, atFilev2FileViewerSize=atFilev2FileViewerSize, atFilev2FileViewerIsDirectory=atFilev2FileViewerIsDirectory, atFilev2DestinationDevice=atFilev2DestinationDevice, atFilev2AllFiles=atFilev2AllFiles, atFilev2InfoFileSize=atFilev2InfoFileSize, atFilev2SDcardPresence=atFilev2SDcardPresence, atFilev2Nvs3=atFilev2Nvs3, atFilev2InfoFileIsExecutable=atFilev2InfoFileIsExecutable, atFilev2FileViewerName=atFilev2FileViewerName, atFilev2InfoFileCreationTime=atFilev2InfoFileCreationTime, atFilev2FileViewerIsReadable=atFilev2FileViewerIsReadable, atFilev2USBMediaPresence=atFilev2USBMediaPresence, atFilev2LastDirOpResult=atFilev2LastDirOpResult, atFilev2StackID=atFilev2StackID, atFilev2FileSize=atFilev2FileSize)
