#
# PySNMP MIB module RC-VLAN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nortel/RC-VLAN-MIB
# Produced by pysmi-1.1.12 at Fri Nov 22 16:01:33 2024
# On host fv-az1205-935 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
rcSvlan, IdList, RcVlanIdOrNone, PortSet, EnableValue, rcVlan, LPortSet = mibBuilder.importSymbols("RAPID-CITY", "rcSvlan", "IdList", "RcVlanIdOrNone", "PortSet", "EnableValue", "rcVlan", "LPortSet")
VrfIdentifier, = mibBuilder.importSymbols("RC-VRF-MIB", "VrfIdentifier")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Unsigned32, ObjectIdentity, MibIdentifier, Counter32, IpAddress, ModuleIdentity, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Bits, Counter64, iso, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Unsigned32", "ObjectIdentity", "MibIdentifier", "Counter32", "IpAddress", "ModuleIdentity", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Bits", "Counter64", "iso", "TimeTicks")
TextualConvention, DisplayString, MacAddress, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "MacAddress", "TruthValue", "RowStatus")
rcVlanMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2272, 1, 3, 0))
rcVlanMib.setRevisions(('2013-10-11 00:00', '2013-03-18 00:00', '2012-12-19 00:00', '2012-08-02 00:00', '2012-07-23 00:00', '2012-06-21 00:00', '2012-02-21 00:00', '2012-02-13 00:00', '2011-12-01 00:00', '2011-09-12 00:00', '2011-05-26 00:00', '2011-04-22 00:00', '2011-03-02 00:00', '2011-01-13 00:00', '2010-09-22 00:00', '2010-09-13 00:00', '2009-09-16 00:00', '2009-06-03 00:00', '2009-03-31 00:00', '2009-03-30 00:00', '2009-03-10 00:00', '2008-08-15 00:00', '2008-08-04 00:00', '2008-07-23 00:00', '2008-06-03 00:00', '2008-05-09 00:00', '2008-03-14 00:00', '2008-03-05 00:00', '2008-02-25 00:00', '2007-11-21 00:00', '2007-10-18 00:00', '2007-10-10 00:00', '2007-04-06 00:00', '2007-03-08 00:00', '2007-01-31 00:00', '2006-12-06 00:00', '2006-05-31 00:00', '2006-02-09 00:00', '2005-11-22 00:00', '2005-08-15 00:00', '2005-08-10 00:00', '2005-04-27 00:00', '2005-03-14 00:00', '2005-02-04 00:00', '2005-01-04 00:00', '2004-12-03 00:00', '2004-11-29 00:00', '2004-11-24 00:00', '2004-11-20 00:00', '2004-10-04 00:00', '2004-09-28 00:00', '2004-09-23 00:00', '2004-09-21 00:00', '2004-09-08 00:00', '2004-08-25 00:00', '2004-07-13 00:00', '2004-06-22 00:00', '2004-06-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rcVlanMib.setRevisionsDescriptions(('Version 62: Corrected syntax definitions. Added types to IMPORTS.', 'Version 61: Added enum value - none, changed normal\n\t\t\t\tto trunk and changed DEFVAL to none under\n\t\t\t\trcVlanPortPrivateVlanPortType', 'Version 60: Added rcVlanSecondaryVlanId and \n\t                        rcVlanSecondaryIsid under rcVlanTable.\n\t\t\t\tAdded enumeration private(13) under \n\t\t\t\trcVlanType. Added rcVlanPortPrivateVlanPortType\n\t\t\t\tunder rcVlanPortTable', 'Version 59: Added rcVlanSpbMcast.', 'Version 58: Added rcVlanRspanEnabled.', 'Version 57: Added enum value spbm-switchedUni for rcVlanType.\n                                Changed description of spbm-bvlan from PLSB to SPBM.', 'Version 56: Added the flushWlanFdb to rcVlanAction', 'Version 55: Moved TEXTUAL CONVENTION LPortSet to rapidcity.mib', 'Version 54: Added the flushIpRsmltEdgePeer to rcVlanAction', 'Version 53: Added the LPortSet textual convention.\n\t                        Also added the following mib objects - \n\t                        rcVlanLPortMembers, \n\t\t\t\trcVlanLPortActiveMembers,\n\t\t\t\trcVlanLPortStaticMembers, \n\t\t\t\trcVlanLPortNotAllowToJoin.', 'Version 52: Added rcVlanRmonEnable and rcVlanIpsecEnable.', 'Version 51: Changed rcVlanVrfId and rcVlanVrfName to\n                                read-create.', 'Version 50: Added rcVlanVoiceEnabled.', 'Version 49: Added enum value spbm-bvlan for rcVlanType.\n                                and changed the size of rcVlanVrfName and \n\t\t\t\tadded rcVlanPlsbIsid under rcVlanTable.', 'Version 48: Added rcVlanPortClassificationSubnet,\n                                      rcVlanPortClassificationProtocol,\n                                      rcVlanPortClassificationPrec,\n                                      rcVlanPortVlanIdList, and\n                                      rcVlanPortClassificationSourceMac\n                                         to SEQUENCE of RcVlanPortEntry.', 'Version 47: Added rcVlanPortClassificationSubnet,\n                                      rcVlanPortClassificationProtocol,\n                                      rcVlanPortClassificationPrec,\n                                      rcVlanPortVlanIdList, and\n                                      rcVlanPortClassificationSourceMac.', 'Version 46: Added rcVlanClearMacRecordTable.', 'Version 45: Added rcVlanIpMultinettingEnable and \n\t\t\t\t      rcVlanAssociatedIpMultinettingVlan', 'Version 44: Added rcVlanDhcpOption82Enabled.', 'Version 43: Added rcVlanPortRemarking.', 'Version 42: added rcVlanNodalMepList, rcVlanNumOfNodalMep, \n                                      rcVlanNodalMipLevelList, rcVlanNumOfNodalMipLevel under RcVlanEntry', 'Version 41: Added rcVlanSource.\n                                Fixed some SMIv2 compliance issues.', 'Version 40: Add rcVlanPortSpoofDetectTable.', 'Version 39: Modified rcVlanId', 'Version 38: Add byPortDefault to rcVlanType.', 'Version 37: Fixed smilint errors.', 'Version 36:\tAdded rcVlanMmrp to rcVlanEntry,\n\t                              rcVlan 15,\n\t                        Modified rcVlanId, rcVlanColor,\n\t\t\t \t         rcVlanStgId, rcVlanAgingTime,\n\t\t\t\t         rcVlanIgmpSnoopRobustness,\n\t\t\t\t         rcVlanIgmpSnoopQueryInterval,\n\t\t\t      \t         rcVlanTosValue, rcVlanFdbAging,\n\t\t\t\t         rcVlanFirewallClusterId', "Version 35: Changed module name to 'RC-VRF-MIB'\nfrom 'RC-VIRTUAL-ROUTING-MIB'", "Version 34: Change 'rcVrfIdentifier' to 'VrfIdentifier'", 'Version 33: Added byPortIp and byPortEvpn to rcVlanType.', 'Version 32: Added rcMgmtVlan,\n                                    rcVlanApplyBtagEthertype.', 'Version 31: Add arp(18) to rcVlanProtocolId attribute.', 'Version 30: Add rcVrfIdentifier to the IMPORTS section.', 'Version 29: Add rcVlanVrfId and rcVlanVrfName.', 'Version 28: Change rcVlanNlbMode and add rcVlanOperNlbMode.', 'Version 27: Added rcVlanPortCfmMepTable and rcVlanPortCfmMipTable.', 'Version 26: Added rcVlanNlbMode to rcVlanEntry.', 'Version 25: Added rcVlanUnkDstMacDiscard.', 'Version 24: Updated rcVlanPortPerformTagging to match\n                                existing implementations.  Restored lost\n                                revision history.', 'Version 23: Added rcVlanOspfPassivePortMember to rcVlanEntry.', 'Version 22: Added rcVlanUnkDstMacDiscard to rcVlanTable.', 'Version 21: Allow rcVlanIgmpSnoopQuerierPort to have value 0.', 'Version 20: Added rcVlanPortSpoofDetect', 'Version 19: changed ranges of rcVlanAgingTime, rcVlanPortVlanIds', 'Version 18: added new mib rcVlanPortArpDetect', 'Version 17: increased the range of rcVlanName to (0..64) characters', 'Version 16: Cleaned up REVISION info.', 'Version 15: removed rcVlanNewName & changed the range\n                                for rcVlanName.', 'Version 14: added new mib rcVlanNewName & made\n                                rcVlanName obsolete.', 'Version 13: add the range for\n                                rcVlanNewLoopDetectedVlanId.', 'Version 12: Increase the range for\n                                rvVlanFirwallClusterId.', 'Version 11: Add range for mib rcVlanPortIndex,\n                                rcVlanMacVlanId, rcVlanLoopDetectedPortIndex,\n                                rcVlanLoopDetectedVlanId.', 'Version 10: Remove range for mib rcVlanPortIndex,\n                               rcVlanMacVlanId, rcVlanLoopDetectedPortIndex,\n                               rcVlanLoopDetectedVlanId.', 'Version 9: Added rcVlanNewLoopDetectedTable. Changed\n                               rcVlanPortLoopDetectAction.', 'Version 8:  Added rcVlanFirewallClusterId in rcVlanTable', 'Version 7:  Added rcVlanTlsIpmc', 'Version 6:  Added rcVlanPortLoopDetectAction', 'Version 5:  Added rcVlanIgmpVer1SnoopMRouterPorts and\n                                rcVlanIgmpVer2SnoopMRouterPorts',))
if mibBuilder.loadTexts: rcVlanMib.setLastUpdated('201310110000Z')
if mibBuilder.loadTexts: rcVlanMib.setOrganization('Bay Networks, Rapid-City Group')
if mibBuilder.loadTexts: rcVlanMib.setContactInfo('\n                                        Edwin Tsang\n                         Postal:        Bay Networks, Inc.\n                                        4401 Great America Parkway\n                                        Santa Clara, CA 95052-8185\n\n                         Tel:           408-495-6159\n                         Fax:           408-495-5215\n                         E-mail:        edwin_tsang@baynetworks.com\n                        ')
if mibBuilder.loadTexts: rcVlanMib.setDescription('Enterprise MIB for the Accelar product family.')
rcVlanNumVlans = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanNumVlans.setStatus('current')
if mibBuilder.loadTexts: rcVlanNumVlans.setDescription('The number of VLANs currently defined in the switch.')
rcVlanTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2), )
if mibBuilder.loadTexts: rcVlanTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanTable.setDescription('A list of Virtual LAN entries. The number of entries\n                      is given by rcVlanNumVlans.')
rcVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanId"))
if mibBuilder.loadTexts: rcVlanEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanEntry.setDescription('Entry containing configuration information for a \n                      particular Virtual LAN.\n\n                      The relationship between the various port sets in a \n                      VLAN Entry are :\n\n                      o The set of ports defined by PortMembers must be a \n                        subset of the set of ports in the underlying STG of \n                        the VLAN.\n\n                      o The bitwise AND of PortMembers and NotAllowToJoin must \n                        be the empty set.\n\n                      o The bitwise OR of PortMembers and NotAllowToJoin must \n                        be the set of ports in the underlying STG of the VLAN.\n\n                      o The set of ports defined by StaticMembers must be a \n                        subset of the set of ports defined by PortMembers.\n\n                      o The bitwise XOR of PortMembers and StaticMembers defines \n                        the set of dynamic (potential) members of the VLAN.\n\n                      o The set of ports defined by ActiveMembers must be a subset \n                        of the set of ports defined by PortMembers.\n                      ')
rcVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanId.setDescription('A value that uniquely identifies the Virtual LAN \n                      associated with this entry. This value corresponds\n                      to the lower 12 bits in the IEEE 802.1Q VLAN Tag.')
rcVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanName.setStatus('current')
if mibBuilder.loadTexts: rcVlanName.setDescription('An administratively-assigned name for this VLAN.')
rcVlanColor = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanColor.setStatus('current')
if mibBuilder.loadTexts: rcVlanColor.setDescription('An administratively-assigned color code for this\n                      VLAN. The value of this object is used by the VLAN\n                      Manager GUI tool to select a color when it draws\n                      this VLAN on the screen.')
rcVlanHighPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanHighPriority.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanHighPriority.setDescription('A flag to note whether frames in this VLAN should \n                      be assigned a high switching priority.')
rcVlanRoutingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanRoutingEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanRoutingEnable.setDescription('A flag to note whether IP routing is enabled in\n                      this VLAN.')
rcVlanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 6), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIfIndex.setStatus('current')
if mibBuilder.loadTexts: rcVlanIfIndex.setDescription("When rcVlanRoutingEnable is set to true(1), this \n                      value indicates the 'logical' ifIndex assigned to\n                      this VLAN.  Otherwise, this value is meaningless\n                      and should be set to zero.")
rcVlanAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("none", 1), ("flushMacFdb", 2), ("flushArp", 3), ("flushIp", 4), ("flushDynMemb", 5), ("all", 6), ("flushSnoopMemb", 7), ("triggerRipUpdate", 8), ("flushSnoopMRtr", 9), ("flushIpRsmltEdgePeer", 10), ("flushWlanFdb", 11))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanAction.setStatus('current')
if mibBuilder.loadTexts: rcVlanAction.setDescription('VLAN related actions.')
rcVlanResult = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("inProgress", 2), ("success", 3), ("fail", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanResult.setStatus('current')
if mibBuilder.loadTexts: rcVlanResult.setDescription('The result from the last VLAN action.')
rcVlanStgId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanStgId.setStatus('current')
if mibBuilder.loadTexts: rcVlanStgId.setDescription('Indicates the Spanning Tree Group (STG) used by\n                      this VLAN to determine the state of its ports.\n                      If this VLAN is not associated with any STG, this\n                      value should be set to zero.')
rcVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("byPort", 1), ("byIpSubnet", 2), ("byProtocolId", 3), ("bySrcMac", 4), ("byDstMcast", 5), ("bySvlan", 6), ("byIds", 7), ("byPortIp", 8), ("byPortEvpn", 9), ("byPortDefault", 10), ("spbm-bvlan", 11), ("spbm-switchedUni", 12), ("private", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanType.setStatus('current')
if mibBuilder.loadTexts: rcVlanType.setDescription('The type of VLAN, distinguished according to the\n                      policy used to define its port membership.')
rcVlanPortMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 11), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanPortMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortMembers.setDescription('The set of ports that are members (static or \n                      dynamic) of this VLAN.')
rcVlanActiveMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 12), PortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanActiveMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanActiveMembers.setDescription('The set of ports that are currently active in \n                      this VLAN. Active ports include all static ports\n                      and any dynamic ports where the VLAN policy was\n                      met.')
rcVlanStaticMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 13), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanStaticMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanStaticMembers.setDescription('The set of ports that are static members of this\n                      VLAN. A static member of a VLAN is always active \n                      and is never aged out.')
rcVlanNotAllowToJoin = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 14), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanNotAllowToJoin.setStatus('current')
if mibBuilder.loadTexts: rcVlanNotAllowToJoin.setDescription('The set of ports that are not allowed to become\n                      members of this VLAN.')
rcVlanProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("none", 0), ("ip", 1), ("ipx802dot3", 2), ("ipx802dot2", 3), ("ipxSnap", 4), ("ipxEthernet2", 5), ("appleTalk", 6), ("decLat", 7), ("decOther", 8), ("sna802dot2", 9), ("snaEthernet2", 10), ("netBios", 11), ("xns", 12), ("vines", 13), ("ipV6", 14), ("usrDefined", 15), ("rarp", 16), ("pPPoE", 17), ("arp", 18)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanProtocolId.setStatus('current')
if mibBuilder.loadTexts: rcVlanProtocolId.setDescription('The protocol identifier of this VLAN. This value \n                      is meaningful only if rcVlanType is equal to \n                      byProtocolId(3). For other VLAN types it should\n                      have the value none(0).')
rcVlanSubnetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 16), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanSubnetAddr.setStatus('current')
if mibBuilder.loadTexts: rcVlanSubnetAddr.setDescription('The IP subnet address of this VLAN. This value \n                      is meaningful only if rcVlanType is equal to \n                      byIpSubnet(2). For other VLAN types it should\n                      have the value 0.0.0.0.')
rcVlanSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 17), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanSubnetMask.setStatus('current')
if mibBuilder.loadTexts: rcVlanSubnetMask.setDescription('The IP subnet mask of this VLAN. This value\n                      is meaningful only if rcVlanType is equal to \n                      byIpSubnet(2). For other VLAN types it should\n                      have the value 0.0.0.0.')
rcVlanAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 1000000), )).clone(600)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanAgingTime.setStatus('current')
if mibBuilder.loadTexts: rcVlanAgingTime.setDescription('The timeout period (in seconds) used for aging\n                      out dynamic members of this VLAN. This field is\n                      only relevant for policy-based VLANs.')
rcVlanMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 19), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanMacAddress.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacAddress.setDescription('The MAC address assigned to the virtual router\n                      interface of this VLAN. This field is meaningful \n                      only if rcVlanRoutingEnable is equal to true(1).')
rcVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcVlanRowStatus.setDescription('Used to create/delete entries in the rcVlanTable.')
rcVlanIgmpSnoopEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 21), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopEnable.setDescription('A flag to note whether IGMP Snooping is enabled\n                      on this VLAN.')
rcVlanIgmpSnoopReportProxyEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 22), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopReportProxyEnable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopReportProxyEnable.setDescription('A flag to note whether IGMP Report Proxy is\n                      enabled on this VLAN.')
rcVlanIgmpSnoopRobustness = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopRobustness.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopRobustness.setDescription('This variable allows tuning for the expected\n                      packet loss on a subnet. If a subnet is expected\n                      to be lossy, the Robustness variable may be\n                      increased. IGMP is robust to (Robustness - 1)\n                      packet losses.')
rcVlanIgmpSnoopQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(125)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopQueryInterval.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopQueryInterval.setDescription('The interval (in seconds) between IGMP Host-Query\n                      packets transmitted on this interface.')
rcVlanIgmpSnoopMRouterPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 25), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopMRouterPorts.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopMRouterPorts.setDescription('The set of ports in this VLAN that provide\n                      connectivity to an IP Multicast router.')
rcVlanUserDefinedPid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 26), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanUserDefinedPid.setStatus('current')
if mibBuilder.loadTexts: rcVlanUserDefinedPid.setDescription('When rcVlanProtocolId is set to usrDefined(15)\n                       in a protocol-based VLAN, this field represents\n                       the 16-bit user defined protocol identifier.')
rcVlanIgmpSnoopActiveMRouterPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 27), PortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopActiveMRouterPorts.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopActiveMRouterPorts.setDescription('Active ports.')
rcVlanProtocolIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 28), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanProtocolIds.setStatus('current')
if mibBuilder.loadTexts: rcVlanProtocolIds.setDescription('Bitfield of protocol ids.')
rcVlanIgmpSnoopActiveQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 29), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopActiveQuerier.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopActiveQuerier.setDescription('IP address of multicast querier router.')
rcVlanIgmpSnoopMRouterExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopMRouterExpiration.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopMRouterExpiration.setDescription('Multicast querier router aging time out.')
rcVlanIgmpSnoopQuerierPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 31), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopQuerierPort.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopQuerierPort.setDescription('The port on which the multicast querier router\n\t\t       was heard.')
rcVlanUserPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("level0", 0), ("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanUserPriority.setStatus('current')
if mibBuilder.loadTexts: rcVlanUserPriority.setDescription('User priority level.')
rcVlanQosLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("level0", 0), ("level1", 1), ("level2", 2), ("level3", 3), ("level4", 4), ("level5", 5), ("level6", 6), ("level7", 7))).clone('level1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanQosLevel.setStatus('current')
if mibBuilder.loadTexts: rcVlanQosLevel.setDescription('Used to specify the Qos level packets, carried in this\n\t\t\tVLAN, should be processed with.')
rcVlanTosValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanTosValue.setStatus('current')
if mibBuilder.loadTexts: rcVlanTosValue.setDescription('Tos value.')
rcVlanEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ethernet2", 1), ("llc", 2), ("snap", 3), ("all", 4), ("notapplicable", 5))).clone('notapplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanEncap.setStatus('current')
if mibBuilder.loadTexts: rcVlanEncap.setDescription('This is the encapsulation type for userdefined protocol\n                        based vlans. This is not meaningful for other types of\n                        vlan. The default value is null.')
rcVlanFirewallVlanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("naap", 2), ("enforceable", 3), ("peering", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanFirewallVlanType.setStatus('current')
if mibBuilder.loadTexts: rcVlanFirewallVlanType.setDescription('This is the firewall vlan type for port based\n                         vlans.')
rcVlanFdbAging = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanFdbAging.setStatus('current')
if mibBuilder.loadTexts: rcVlanFdbAging.setDescription('The timeout required to.')
rcVlanUpdateDynamicMacQosLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 38), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanUpdateDynamicMacQosLevel.setStatus('current')
if mibBuilder.loadTexts: rcVlanUpdateDynamicMacQosLevel.setDescription('It is used to indicate whether to update qos\n                     level for dynamic learned mac add resses\n                     associated with a subnet-based or protocol-based\n                     vlan when vlan qos level changes.  If it is set\n                     to TRUE, qos level for all dynamic learned mac\n                     addresses will be changed upon changing vlan qos\n                     level.  If it is set to DISABLE, once a mac address\n                     is learned, qos level will not updated when vlan\n                     qos level changes.')
rcVlanUserDefinedPidList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 39), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanUserDefinedPidList.setStatus('current')
if mibBuilder.loadTexts: rcVlanUserDefinedPidList.setDescription('A list of Protocol Id to usrDefined in a protocol-based\n                       VLAN, this field represents the list user defined protocol identifier.')
rcVlanIgmpVer1SnoopMRouterPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 40), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpVer1SnoopMRouterPorts.setStatus('current')
if mibBuilder.loadTexts: rcVlanIgmpVer1SnoopMRouterPorts.setDescription('The set of ports in this VLAN that provide connectivity\n                      to an IP Multicast router using IGMP Version 1.')
rcVlanIgmpVer2SnoopMRouterPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 41), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpVer2SnoopMRouterPorts.setStatus('current')
if mibBuilder.loadTexts: rcVlanIgmpVer2SnoopMRouterPorts.setDescription('The set of ports in this VLAN that provide connectivity\n                      to an IP Multicast router using IGMP version 2.')
rcVlanTlsIpmc = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 42), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanTlsIpmc.setStatus('current')
if mibBuilder.loadTexts: rcVlanTlsIpmc.setDescription('Enable/disable the IP Mcast for this SP IP service Vlan for \n                       TLS OE feature')
rcVlanFirewallClusterId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanFirewallClusterId.setStatus('current')
if mibBuilder.loadTexts: rcVlanFirewallClusterId.setDescription('Firewall cluster Id')
rcVlanOspfPassivePortMember = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 44), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanOspfPassivePortMember.setStatus('current')
if mibBuilder.loadTexts: rcVlanOspfPassivePortMember.setDescription('The set of ports in the vlan that are designated as ospf passive.')
rcVlanUnkDstMacDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 45), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanUnkDstMacDiscard.setStatus('current')
if mibBuilder.loadTexts: rcVlanUnkDstMacDiscard.setDescription('Enable/disable Unknown Destination Mac Discard on Vlan')
rcVlanNlbMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("nlbAdminDisable", 0), ("nlbAdminIgmpMcast", 1), ("nlbAdminMulticast", 2), ("nlbAdminUnicast", 4))).clone('nlbAdminDisable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanNlbMode.setStatus('current')
if mibBuilder.loadTexts: rcVlanNlbMode.setDescription('Admin NLB mode set on a VLAN.')
rcVlanOperNlbMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("nlbOperDisable", 0), ("nlbOperIgmpMcast", 1), ("nlbOperMulticast", 2), ("nlbOperUnicast", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanOperNlbMode.setStatus('current')
if mibBuilder.loadTexts: rcVlanOperNlbMode.setDescription('Oper NLB mode of a VLAN.')
rcVlanVrfId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 48), VrfIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanVrfId.setStatus('current')
if mibBuilder.loadTexts: rcVlanVrfId.setDescription('Indicates the Virtual Router to which the VLAN belongs')
rcVlanVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 49), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanVrfName.setStatus('current')
if mibBuilder.loadTexts: rcVlanVrfName.setDescription('The Name of the Virtual Router to which the VLAN belongs')
rcVlanMgmtVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 50), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanMgmtVlan.setStatus('current')
if mibBuilder.loadTexts: rcVlanMgmtVlan.setDescription('This displays the management vlan configuration')
rcVlanApplyBtagEthertype = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 51), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanApplyBtagEthertype.setStatus('current')
if mibBuilder.loadTexts: rcVlanApplyBtagEthertype.setDescription('Used to apply user configured btag ethertype to\n                       the Vlan')
rcVlanMmrp = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 52), EnableValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanMmrp.setStatus('current')
if mibBuilder.loadTexts: rcVlanMmrp.setDescription('This displays the MMRP enable state for the vlan')
rcVlanSource = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dynamicMvmp", 2), ("dynamicGvrp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanSource.setStatus('current')
if mibBuilder.loadTexts: rcVlanSource.setDescription('This object indicates how this VLAN was created:\n\n                 static(1) - Indicates the VLAN was manually configured by an\n                             operator.\n\n                 dynamicMvmp(2) - Indicates the VLAN was dynamically created by\n                                  MVMP (Mobility VLAN Management Protocol).\n\n                 dynamicGvrp(3) - Indicates the VLAN was dynamically created\n                                  by GVRP.')
rcVlanNodalMepList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 54), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 408))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanNodalMepList.setStatus('current')
if mibBuilder.loadTexts: rcVlanNodalMepList.setDescription("List of nodal Meps assigned to this vlan. A mep\n                       consists of Domain Name, Association name and Mep\n                       Id separated by '.'. Each meps is separated by ',':\n                       <md1>.<ma1>.<mepid1>,<md2>.<ma2>.<mepid2>,...\n                       The maximum number of nodal Mep for each vlan is 8.")
rcVlanNumOfNodalMep = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanNumOfNodalMep.setStatus('current')
if mibBuilder.loadTexts: rcVlanNumOfNodalMep.setDescription('Number of nodal meps assigned to this vlan')
rcVlanNodalMipLevelList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 56), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanNodalMipLevelList.setStatus('current')
if mibBuilder.loadTexts: rcVlanNodalMipLevelList.setDescription("List of nodal Mip levels assigned to this vlan that\n                       allows Mip functionality to be enabled on a per level\n                       per vlan basis. A mip level is represented by an\n                       integer ranging from 0 to 7. The mip levels are\n                       separated by ',': <0...7>,<0...7>,... The maximum\n                       number of nodal Mip levels for each vlan is 8.")
rcVlanNumOfNodalMipLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanNumOfNodalMipLevel.setStatus('current')
if mibBuilder.loadTexts: rcVlanNumOfNodalMipLevel.setDescription('Number of nodal mip levels assigned to this vlan that\n                       allows MIP functionality to be enabled on a per level\n                       per vlan basis.')
rcVlanDhcpOption82Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 58), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanDhcpOption82Enabled.setStatus('current')
if mibBuilder.loadTexts: rcVlanDhcpOption82Enabled.setDescription('This object is used to control whether DHCP option 82\n                       is enabled for this VLAN.')
rcVlanIpMultinettingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 59), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanIpMultinettingEnable.setStatus('current')
if mibBuilder.loadTexts: rcVlanIpMultinettingEnable.setDescription('Indicate if the vlan is an Ip Multinetting vlan. If enabled, \n\t\t     rcVlanAssociatedIpMultinettingVlan should be set to 0')
rcVlanAssociatedIpMultinettingVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanAssociatedIpMultinettingVlan.setStatus('current')
if mibBuilder.loadTexts: rcVlanAssociatedIpMultinettingVlan.setDescription('Associated Ip Multinetting vlan Id whose rcVlanIpMultinettingEnable\n\t\t    attribute is set ')
rcVlanPlsbIsid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPlsbIsid.setStatus('current')
if mibBuilder.loadTexts: rcVlanPlsbIsid.setDescription('Plsb i-sid number assigned to a C-vlan. Default 0 value\n\t\t       indicates that no i-sid has been assinged.')
rcVlanVoiceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 62), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanVoiceEnabled.setStatus('current')
if mibBuilder.loadTexts: rcVlanVoiceEnabled.setDescription('This object is used to control whether voice option\n                       is enabled for this VLAN.')
rcVlanRmonEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 63), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanRmonEnable.setStatus('current')
if mibBuilder.loadTexts: rcVlanRmonEnable.setDescription('Indicate if the vlan is enabled for Remote Monitoring')
rcVlanIpsecEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 64), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanIpsecEnable.setStatus('current')
if mibBuilder.loadTexts: rcVlanIpsecEnable.setDescription('Indicate if the vlan is enabled for IPSEC')
rcVlanLPortMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 65), LPortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLPortMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanLPortMembers.setDescription('The set of logical ports that are members (dynamic) \n                       of this VLAN.')
rcVlanLPortActiveMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 66), LPortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLPortActiveMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanLPortActiveMembers.setDescription('The set of logical ports that are currently active in \n                      this VLAN. Active ports include all dynamic ports \n                      where the VLAN policy was met.')
rcVlanLPortStaticMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 67), LPortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLPortStaticMembers.setStatus('current')
if mibBuilder.loadTexts: rcVlanLPortStaticMembers.setDescription('The set of logical ports that are static members of this\n                      VLAN. A static member of a VLAN is always active \n                      and is never aged out.')
rcVlanLPortNotAllowToJoin = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 68), LPortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLPortNotAllowToJoin.setStatus('current')
if mibBuilder.loadTexts: rcVlanLPortNotAllowToJoin.setDescription('The set of logical ports that are not allowed to become\n                      members of this VLAN.')
rcVlanRspanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 69), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanRspanEnabled.setStatus('current')
if mibBuilder.loadTexts: rcVlanRspanEnabled.setDescription('This object is used to control whether rspan option\n                       is enabled for this VLAN.')
rcVlanSpbMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 70), EnableValue().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanSpbMcast.setStatus('current')
if mibBuilder.loadTexts: rcVlanSpbMcast.setDescription('Enable/disable SPB multicast on Vlan')
rcVlanSecondaryVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 71), RcVlanIdOrNone()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanSecondaryVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanSecondaryVlanId.setDescription('A value that uniquely identifies the secondary\n                      Virtual LAN associated with the primary private VLAN. \n                      This value corresponds to the lower 12 bits in \n                      the IEEE 802.1Q VLAN Tag.')
rcVlanSecondaryIsid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 2, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanSecondaryIsid.setStatus('current')
if mibBuilder.loadTexts: rcVlanSecondaryIsid.setDescription('The i-sid number assigned to a secondary VLAN if it \n                       exists. Default 0 value.')
rcVlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3), )
if mibBuilder.loadTexts: rcVlanPortTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortTable.setDescription('A table used to maintain VLAN port related \n                      information.')
rcVlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanPortIndex"))
if mibBuilder.loadTexts: rcVlanPortEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortEntry.setDescription('Entry containing VLAN information regarding a \n                      particular port.')
rcVlanPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortIndex.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortIndex.setDescription('An unique index used to identify a particular \n                      port in the system. This index is equal to the\n                      ifIndex of the port.')
rcVlanPortNumVlanIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortNumVlanIds.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortNumVlanIds.setDescription('Used to indicate the number of VLAN IDs that\n                      are stored in the rcVlanPortVlanIds variable.')
rcVlanPortVlanIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 3), IdList().subtype(subtypeSpec=ValueSizeConstraint(0, 4096))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortVlanIds.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortVlanIds.setDescription('An array used to identify which VLANs this port \n                      is assigned to.  Each VLAN ID is stored as a two\n                      octet value. The first octet in the pair holds\n                      bits 15-8 of the VLAN ID, while the second octet\n                      holds bits 7-0 of the VLAN ID.')
rcVlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("trunk", 2))).clone('access')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortType.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortType.setDescription('The type of port: access(1) or trunk(2).')
rcVlanPortDiscardTaggedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortDiscardTaggedFrames.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortDiscardTaggedFrames.setDescription('A flag used to determine how to process tagged\n                      frames received on this access port. When the \n                      flag is set, these frames are discarded by the\n                      forwarding process. When the flag is reset, these\n                      frames are processed normally.\n\n\t\t      This field is meaningless when the port is not\n\t\t      an access port and should be set to false(2).')
rcVlanPortDiscardUntaggedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortDiscardUntaggedFrames.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortDiscardUntaggedFrames.setDescription('A flag used to determine how to process untagged\n                      frames received on this trunk port. When the flag \n                      is set, these frames are discarded by the \n                      forwarding process. When the flag is reset, these\n                      frames are assigned to the VLAN specified by \n                      rcVlanPortDefaultVlanId.\n\n\t\t      This field is meaningless when the port is not\n\t\t      a trunk port and should be set to false(2).')
rcVlanPortDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortDefaultVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortDefaultVlanId.setDescription('The VLAN ID assigned to untagged frames received\n                      on this trunk port.\n\n\t\t      This field is meaningless when the port is not\n\t\t      a trunk port.')
rcVlanPortPerformTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("tagPvidOnly", 3), ("untagPvidOnly", 4))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortPerformTagging.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortPerformTagging.setDescription('Enable/disable the port on the current vlan to \n                       perform tagging on the incoming and outgoing traffic.')
rcVlanPortSVlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("uni", 2), ("nni", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortSVlanPortType.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSVlanPortType.setDescription('The type of port.')
rcVlanPortLoopDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortLoopDetect.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortLoopDetect.setDescription('Enable/disable loop detection on this port')
rcVlanPortFirstPortInOpid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 11), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortFirstPortInOpid.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortFirstPortInOpid.setDescription('This value gives the IfIndex of the first port in the\n\t               octapid. This value is used to generate an error message\n\t\t       when changing port type from normal to uni/nni and\n\t\t       viceversa')
rcVlanPortLastPortInOpid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 12), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortLastPortInOpid.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortLastPortInOpid.setDescription('This value gives the IfIndex of the first port in the\n\t               octapid. This value is used to generate an error message\n\t\t       when changing port type from normal to uni/nni and\n\t\t       viceversa')
rcVlanPortUntagDefaultVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 13), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortUntagDefaultVlan.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortUntagDefaultVlan.setDescription('enable/disable Egress Tagging on the Default Vlan \n                       of the port.')
rcVlanPortLoopDetectAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("portDown", 1), ("vlanBlock", 2), ("macDiscard", 3))).clone('portDown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortLoopDetectAction.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortLoopDetectAction.setDescription('This value is used to specify the action which needs to be\n                                            taken once a loop is detected on a specific port.')
rcVlanPortArpDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortArpDetect.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortArpDetect.setDescription('Enable/disable Arp detection on this port')
rcVlanPortSpoofDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortSpoofDetect.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetect.setDescription('Enable/disable spoof detection on this port')
rcVlanPortRemarking = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 17), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortRemarking.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortRemarking.setDescription('Enable/disable remarking on this port')
rcVlanPortClassificationSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 18), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortClassificationSubnet.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortClassificationSubnet.setDescription('Enable/disable Subnet based Vlan packets on this port.')
rcVlanPortClassificationProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 19), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortClassificationProtocol.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortClassificationProtocol.setDescription('Enable/disable Protocol based Vlan packets on this port.')
rcVlanPortClassificationPrec = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sourceMac", 1), ("subnet", 2))).clone('sourceMac')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortClassificationPrec.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortClassificationPrec.setDescription('Sets the precedence for vlan classification.  A value\n                      of 1 puts classification of packets to source mac vlans\n                      ahead of subnet based vlans.  A value of 2 puts subnet\n                      based vlans ahead of source mac vlans.  Classification\n                      to other types of vlans is unaffected as it occurs\n                      following source mac and subnet based vlans.')
rcVlanPortVlanIdList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortVlanIdList.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortVlanIdList.setDescription('This bitfield is used to identify which VLANs this port                        is assigned to. Each VLAN ID is stored as a bit.\n                        The most-significant (left-most) bit represents Vlan Id                         1.')
rcVlanPortClassificationSourceMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 22), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortClassificationSourceMac.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortClassificationSourceMac.setDescription('Enable/disable SourceMac based Vlan packets on this port.                      ')
rcVlanPortPrivateVlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("trunk", 1), ("isolated", 2), ("promiscuous", 3), ("none", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanPortPrivateVlanPortType.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortPrivateVlanPortType.setDescription('The type of port associated wiht private VLAN.\n                      If the VLAN is not private then this is ignored.\n                      If the VLAN is private then the value must be\n                      either trunk, isolated, or promiscuous.  Setting\n                      the value to trunk will enable tagging.  Setting\n                      the value to isolated or promiscuous will remove\n                      non-private VLANs from the port.')
rcVlanMacTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 4), )
if mibBuilder.loadTexts: rcVlanMacTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacTable.setDescription('A table used to maintain MAC addresses assigned \n                      to a particular VLAN by MAC address.')
rcVlanMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanMacVlanId"), (0, "RC-VLAN-MIB", "rcVlanMacAddr"))
if mibBuilder.loadTexts: rcVlanMacEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacEntry.setDescription('Entry containing VLAN information regarding a\n                      particular port.')
rcVlanMacVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanMacVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacVlanId.setDescription('An unique index used to identify a VLAN (by MAC \n                      address) in the system.')
rcVlanMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanMacAddr.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacAddr.setDescription('An unique index used to identify a MAC address\n                      assigned to a particular VLAN.')
rcVlanMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanMacRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcVlanMacRowStatus.setDescription('Row status for this entry.')
rcVlanIgmpSnoopNumGroups = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopNumGroups.setStatus('current')
if mibBuilder.loadTexts: rcVlanIgmpSnoopNumGroups.setDescription('The number of entries (rows) in the\n                      rcVlanIgmpSnoopTable.')
rcVlanIgmpSnoopTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6), )
if mibBuilder.loadTexts: rcVlanIgmpSnoopTable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopTable.setDescription('The (conceptual) table listing the IP multicast\n                      groups for which there are members on a particular\n                      interface on a particular VLAN (i.e., a list \n\t\t      known multicast receivers).\n\n\t\t      A row is created by the system when it receives\n\t\t      an IGMP Join messages on a port.')
rcVlanIgmpSnoopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanIgmpSnoopVlanId"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopIpAddress"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopIfIndex"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopMember"))
if mibBuilder.loadTexts: rcVlanIgmpSnoopEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopEntry.setDescription('An entry (row) in the rcVlanIgmpSnoopTable.')
rcVlanIgmpSnoopVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopVlanId.setDescription('The VLAN for which this entry contains\n                      information.')
rcVlanIgmpSnoopIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopIpAddress.setDescription('The IP multicast group address for which this \n                      entry contains information.')
rcVlanIgmpSnoopIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopIfIndex.setDescription('The interface for which this entry contains \n                      information for this IP multicast group address\n                      (i.e., the port the Join message was received).')
rcVlanIgmpSnoopMember = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopMember.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopMember.setDescription('The IP Address of the source of the membership\n                      report received for this IP Multicast group address\n                      on this interface (i.e., the address of the host\n                      sending the Join message).')
rcVlanIgmpSnoopExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopExpiration.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopExpiration.setDescription('The minimum amount of time remaining before this \n                      entry will be aged out.')
rcVlanIgmpSnoopType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2), ("blocked", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopType.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopType.setDescription('The type of entry: dynamic(1) entries are\n                      created by snooping IGMP messages, static(2)\n                      entries are created via management.')
rcVlanIgmpSnoopStaticTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7), )
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticTable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticTable.setDescription('The (conceptual) table listing the statically-\n                      defined IP multicast groups for which there are\n                      members on a particular interface on a particular\n                      VLAN.')
rcVlanIgmpSnoopStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanIgmpSnoopStaticVlanId"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopStaticIpAddress"))
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticEntry.setDescription('An entry (row) in the rcVlanIgmpSnoopStaticTable.')
rcVlanIgmpSnoopStaticVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticVlanId.setDescription('The VLAN for which this entry contains information.')
rcVlanIgmpSnoopStaticIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticIpAddress.setDescription('The IP multicast group address for which this \n                      entry contains information.  The address must\n\t\t      fall within 224.0.1.0 to 239.255.255.255.')
rcVlanIgmpSnoopStaticMemberPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 3), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticMemberPorts.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticMemberPorts.setDescription('The set of ports in this VLAN multicast traffic\n\t\t      for the rcVlanIgmpSnoopStaticIpAddress is to be\n\t\t      forwarded to.')
rcVlanIgmpSnoopStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticRowStatus.setDescription('Used to create/delete entries in the \n                      rcVlanIgmpSnoopStaticTable.')
rcVlanIgmpSnoopStaticNotAllowedToJoin = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 7, 1, 5), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticNotAllowedToJoin.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopStaticNotAllowedToJoin.setDescription('Not allowed to join')
rcVlanIgmpSnoopAccessTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8), )
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessTable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessTable.setDescription('Table used to specify which host(s) can send\n\t\t      and/or receive IP Multicast traffic.')
rcVlanIgmpSnoopAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanIgmpSnoopAccessVlanId"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopAccessGrpAddr"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopAccessHostAddr"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopAccessHostMask"))
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessEntry.setDescription('An entry (row) in the rcVlanIgmpSnoopAccessTable.')
rcVlanIgmpSnoopAccessVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessVlanId.setDescription('The VLAN for which this entry contains information.')
rcVlanIgmpSnoopAccessGrpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessGrpAddr.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessGrpAddr.setDescription('The IP multicast group address for which this\n                      entry contains information.')
rcVlanIgmpSnoopAccessHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessHostAddr.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessHostAddr.setDescription('The IP address of a host for which this\n                      entry contains information.')
rcVlanIgmpSnoopAccessHostMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessHostMask.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessHostMask.setDescription('The IP netmask of a host for which this\n                      entry contains information.')
rcVlanIgmpSnoopAccessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("denyTx", 1), ("denyRx", 2), ("denyBoth", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessMode.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessMode.setDescription('Used to specify whether the host identified by\n\t\t      rcVlanIgmpSnoopAccessHostAddr should be denied\n\t\t      IP multicast transmit, receive, or both.')
rcVlanIgmpSnoopAccessRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopAccessRowStatus.setDescription('Row status')
rcVlanIgmpSnoopSenderTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9), )
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderTable.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderTable.setDescription('The (conceptual) table listing the IP multicast \n                      groups for which there are members on a particular\n                      interface on a particular VLAN (i.e., a list  \n                      known multicast senders).  \n  \n                      A row is created by the system when it receives \n                      an IGMP Join messages on a port.')
rcVlanIgmpSnoopSenderEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanIgmpSnoopSenderVlanId"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopSenderIpAddress"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopSenderIfIndex"), (0, "RC-VLAN-MIB", "rcVlanIgmpSnoopSenderMember"))
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderEntry.setDescription('An entry (row) in the rcVlanIgmpSnoopSenderTable.')
rcVlanIgmpSnoopSenderVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderVlanId.setDescription('The VLAN for which this entry contains information.')
rcVlanIgmpSnoopSenderIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderIpAddress.setDescription('The IP multicast group address for which this\n                      entry contains information.')
rcVlanIgmpSnoopSenderIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderIfIndex.setDescription('The interface for which this entry contains\n                      information for this IP multicast group address\n                      (i.e., the port the multicast traffic was received).')
rcVlanIgmpSnoopSenderMember = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderMember.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderMember.setDescription('The IP Address of the host sending the multicast\n\t\t      traffic.')
rcVlanIgmpSnoopSenderAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("flushEntry", 1), ("flushGrp", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderAction.setStatus('deprecated')
if mibBuilder.loadTexts: rcVlanIgmpSnoopSenderAction.setDescription('Used to specify an action to perform on this group.')
rcVlanLoopDetectedTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 10), )
if mibBuilder.loadTexts: rcVlanLoopDetectedTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanLoopDetectedTable.setDescription('A list of Vlans the port belongs to\nand the \n                      corresponding loop detected status.')
rcVlanLoopDetectedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 10, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanLoopDetectedPortIndex"), (0, "RC-VLAN-MIB", "rcVlanLoopDetectedVlanId"))
if mibBuilder.loadTexts: rcVlanLoopDetectedEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanLoopDetectedEntry.setDescription('Loop-Detected Entry.')
rcVlanLoopDetectedPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLoopDetectedPortIndex.setStatus('current')
if mibBuilder.loadTexts: rcVlanLoopDetectedPortIndex.setDescription('Port Number.')
rcVlanLoopDetectedVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLoopDetectedVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanLoopDetectedVlanId.setDescription('Gives the VlanId to which the port belongs.')
rcVlanLoopDetectedValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanLoopDetectedValue.setStatus('current')
if mibBuilder.loadTexts: rcVlanLoopDetectedValue.setDescription('Gives the Loop Detected status of the port\n                       in a vlan.')
rcVlanDsapSsapTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 11), )
if mibBuilder.loadTexts: rcVlanDsapSsapTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanDsapSsapTable.setDescription('A table used to maintain DSAP/SSAP values\n                       assigned to a sna802dot2 or userdefined vlan.')
rcVlanDsapSsapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 11, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanDsapSsapVlanId"), (0, "RC-VLAN-MIB", "rcVlanDsapSsapPid"))
if mibBuilder.loadTexts: rcVlanDsapSsapEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanDsapSsapEntry.setDescription('An entry in the rcVlanDsapSsap table.')
rcVlanDsapSsapVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rcVlanDsapSsapVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanDsapSsapVlanId.setDescription('A unique index to identify a vlan.')
rcVlanDsapSsapPid = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: rcVlanDsapSsapPid.setStatus('current')
if mibBuilder.loadTexts: rcVlanDsapSsapPid.setDescription('Values of DSAP/SSAP assigned to a particular\n                       vlan.')
rcVlanDsapSsapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 11, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanDsapSsapRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcVlanDsapSsapRowStatus.setDescription('Row Status.')
rcVlanNewLoopDetectedTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12), )
if mibBuilder.loadTexts: rcVlanNewLoopDetectedTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedTable.setDescription('A list of Vlans the port belongs to and the \n                       corresponding loop detected status.')
rcVlanNewLoopDetectedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanNewLoopDetectedPortIndex"), (0, "RC-VLAN-MIB", "rcVlanNewLoopDetectedVlanId"), (0, "RC-VLAN-MIB", "rcVlanNewLoopDetectedMac"))
if mibBuilder.loadTexts: rcVlanNewLoopDetectedEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedEntry.setDescription('Loop-Detected Entry.')
rcVlanNewLoopDetectedPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rcVlanNewLoopDetectedPortIndex.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedPortIndex.setDescription('Port Number.')
rcVlanNewLoopDetectedVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: rcVlanNewLoopDetectedVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedVlanId.setDescription('Gives the VlanId to which the port belongs.')
rcVlanNewLoopDetectedMac = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1, 3), MacAddress())
if mibBuilder.loadTexts: rcVlanNewLoopDetectedMac.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedMac.setDescription('Mac address')
rcVlanNewLoopDetectedAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("portDown", 1), ("vlanBlock", 2), ("macDiscard", 3))).clone('portDown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanNewLoopDetectedAction.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedAction.setDescription('This value is used to specify the action which\n                       needs to be taken once a loop is detected on a \n                       specific port.')
rcVlanNewLoopDetectedSmltRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 12, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanNewLoopDetectedSmltRemote.setStatus('current')
if mibBuilder.loadTexts: rcVlanNewLoopDetectedSmltRemote.setDescription('A MAC address indicate for remote learnt,\n                      either local or remote.')
rcVlanClearMacRecordTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17), )
if mibBuilder.loadTexts: rcVlanClearMacRecordTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordTable.setDescription('Table used to clear a Vlan MAC Record.')
rcVlanClearMacRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanClearMacRecordAddr"))
if mibBuilder.loadTexts: rcVlanClearMacRecordEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordEntry.setDescription('Vlan Clear Mac Record Table Entry')
rcVlanClearMacRecordAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1, 1), MacAddress())
if mibBuilder.loadTexts: rcVlanClearMacRecordAddr.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordAddr.setDescription('Mac Address that needs to be cleared.')
rcVlanClearMacRecordVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanClearMacRecordVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordVlanId.setDescription('Vlan Id where the Mac record has to be cleared.')
rcVlanClearMacRecordAllVlanIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanClearMacRecordAllVlanIds.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordAllVlanIds.setDescription('When set to true, this will clear the MAC\n\t\t\trecord on all the Vlan Ids it exists.')
rcVlanClearMacRecordForceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanClearMacRecordForceDelete.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordForceDelete.setDescription('By default, when ForceDelete is set to false, \n\t\t\tMAC record will not be cleared if an ARP record \n\t\t\tis associated with this Mac Address. If ForceDelete \n\t\t\tis set to True, MAC record will be removed even \n\t\t\twhen an ARP is associated with this record.')
rcVlanClearMacRecordLCForceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 17, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanClearMacRecordLCForceDelete.setStatus('current')
if mibBuilder.loadTexts: rcVlanClearMacRecordLCForceDelete.setDescription('By default, when LCForceDelete (Line Card Force \n\t\t\tDelete) is set to false, if the MAC record is not \n\t\t\tfound on the CP, then no message will be sent to \n\t\t\tthe line-card. When LCForceDelete is set to true, \n\t\t\ta message will be sent to the line-card even when \n\t\t\tthe MAC record is not found on the CP.')
rcVlanPortCfmMepTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13), )
if mibBuilder.loadTexts: rcVlanPortCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepTable.setDescription('A table used to maintain CFM MEP \n                       assigned to the port in a vlan')
rcVlanPortCfmMepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanPortCfmMepVlanId"), (0, "RC-VLAN-MIB", "rcVlanPortCfmMepPort"))
if mibBuilder.loadTexts: rcVlanPortCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepEntry.setDescription('An entry in the rcVlanPortCfmMep table.')
rcVlanPortCfmMepVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: rcVlanPortCfmMepVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepVlanId.setDescription('A unique index to identify a vlan.')
rcVlanPortCfmMepPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rcVlanPortCfmMepPort.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepPort.setDescription('A unique index to identify a port interface \n\t               in a Vlan.')
rcVlanPortCfmMepMepList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 440))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanPortCfmMepMepList.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepMepList.setDescription("List of Meps assigned to this entry. \n\t\t       A mep is consist of <md>.<ma>.<mep_id>. Domain\n\t\t       Name, Association and Mep Id is separated by '.' \n\t\t       A list of mep is consist of \n\t\t       <md1>.<ma1>.<mepid1>,<md2>.<ma2>.<mepid2>,... \n\t\t       Each mep is separated by ','. Maximum up 8 meps")
rcVlanPortCfmMepNumOfMep = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortCfmMepNumOfMep.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepNumOfMep.setDescription('Used to indicate the number of Meps\n                      \tis assigned to this entry')
rcVlanPortCfmMepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 13, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanPortCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMepRowStatus.setDescription('Row Create attibute. For perfomace and efficience, \n                         rcVlanPortCfmMepMepList is required for creation.\n\t\t\t If any Mep is added, entry would be created.\n\t\t\t If all Mep are removed, entry would be deleted')
rcVlanPortCfmMipTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14), )
if mibBuilder.loadTexts: rcVlanPortCfmMipTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipTable.setDescription('A table used to maintain CFM MIP \n                       assigned to the port in a vlan')
rcVlanPortCfmMipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanPortCfmMipVlanId"), (0, "RC-VLAN-MIB", "rcVlanPortCfmMipPort"))
if mibBuilder.loadTexts: rcVlanPortCfmMipEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipEntry.setDescription('An entry in the rcVlanPortCfmMip table.')
rcVlanPortCfmMipVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: rcVlanPortCfmMipVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipVlanId.setDescription('A unique index to identify a vlan.')
rcVlanPortCfmMipPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rcVlanPortCfmMipPort.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipPort.setDescription('A unique index to identify a port interface \n\t               in a Vlan.')
rcVlanPortCfmMipMipList = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 440))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanPortCfmMipMipList.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipMipList.setDescription("List of Mips assigned to this entry. \n\t\t       A mip is consist of <md>.<mip_id>. Domain\n\t\t       Name and Mip Id is separated by '.' \n\t\t       A list of mip is consist of \n\t\t       <md1>.<mipid1>,<md2>.<mipid2>,... \n\t\t       Each mip is separated by ','. Maximum up 8 mips")
rcVlanPortCfmMipNumOfMip = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortCfmMipNumOfMip.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipNumOfMip.setDescription('Used to indicate the number of Mips\n                      \tis assigned to this entry')
rcVlanPortCfmMipRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcVlanPortCfmMipRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortCfmMipRowStatus.setDescription('Row Create attibute. For perfomace and efficience, \n                         rcVlanPortCfmMipMipList is required for creation.\n\t\t\t If any Mip is added, entry would be created.\n\t\t\t If all Mip are removed, entry would be deleted')
rcVlanExtFilterSvcTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15), )
if mibBuilder.loadTexts: rcVlanExtFilterSvcTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcTable.setDescription('Extended filtering services per port per Vlans are\n                         defined in this table')
rcVlanExtFilterSvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanExtFilterSvcVlanId"))
if mibBuilder.loadTexts: rcVlanExtFilterSvcEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcEntry.setDescription('Used to indicate the extended filtering services.\n                      Extended filtering services are per port per Vlan.')
rcVlanExtFilterSvcVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: rcVlanExtFilterSvcVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcVlanId.setDescription('A value that uniquely identifies the Virtual LAN\n                      associated with this entry. This value corresponds\n                      to the lower 12 bits in the IEEE 802.1Q VLAN Tag.')
rcVlanExtFilterSvcFwdAllPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15, 1, 2), PortSet()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanExtFilterSvcFwdAllPorts.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcFwdAllPorts.setDescription('Contains port list that are in ForwardAll mode.')
rcVlanExtFilterSvcFwdUnregPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15, 1, 3), PortSet()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanExtFilterSvcFwdUnregPorts.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcFwdUnregPorts.setDescription('Contains port list that are in Forward Unregistered mode.')
rcVlanExtFilterSvcFilterUnregPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 15, 1, 4), PortSet()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcVlanExtFilterSvcFilterUnregPorts.setStatus('current')
if mibBuilder.loadTexts: rcVlanExtFilterSvcFilterUnregPorts.setDescription('Contains port list that are in Filter Unregistered mode.')
rcSvlanGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 35, 1))
rcSvlanActiveLevel = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 35, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcSvlanActiveLevel.setStatus('current')
if mibBuilder.loadTexts: rcSvlanActiveLevel.setDescription('Stacked Vlan active level.')
rcSvlanTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 35, 2), )
if mibBuilder.loadTexts: rcSvlanTable.setStatus('current')
if mibBuilder.loadTexts: rcSvlanTable.setDescription('A list of possible levels and their corresponding ether type.\n                   The number of entries is eight.')
rcSvlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 35, 2, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcSvlanId"))
if mibBuilder.loadTexts: rcSvlanEntry.setStatus('current')
if mibBuilder.loadTexts: rcSvlanEntry.setDescription('A Stacked Vlan table entry.')
rcSvlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 35, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcSvlanId.setStatus('current')
if mibBuilder.loadTexts: rcSvlanId.setDescription('Row Index.')
rcSvlanLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 35, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcSvlanLevel.setStatus('current')
if mibBuilder.loadTexts: rcSvlanLevel.setDescription('A value that identifies the switch level associated\n                     with this entry.')
rcSvlanEtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 35, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcSvlanEtherType.setStatus('current')
if mibBuilder.loadTexts: rcSvlanEtherType.setDescription('The ether type value is used for svlan tagging.')
rcVlanPortSpoofDetectTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16), )
if mibBuilder.loadTexts: rcVlanPortSpoofDetectTable.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectTable.setDescription('Table containing spoof-detect block entries.')
rcVlanPortSpoofDetectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1), ).setIndexNames((0, "RC-VLAN-MIB", "rcVlanPortSpoofDetectIndex"))
if mibBuilder.loadTexts: rcVlanPortSpoofDetectEntry.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectEntry.setDescription('This entry, which contains port index, VLAN ID, IP address and \n\t\t\tMAC address, is used to indicate which MAC address is starting IP-Spoof \n\t\t\tattack and which gateway IP address is under attack.')
rcVlanPortSpoofDetectIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 1), Unsigned32())
if mibBuilder.loadTexts: rcVlanPortSpoofDetectIndex.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectIndex.setDescription('The auxiliary variable for identifying instances of\n               the columnar objects in the spoof detect table.')
rcVlanPortSpoofDetectSpoofedIpAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedIpAddressType.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedIpAddressType.setDescription('IP address type of address under spoof attack.')
rcVlanPortSpoofDetectSpoofedIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedIpAddress.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedIpAddress.setDescription('IP address that has been detected under spoof attack.')
rcVlanPortSpoofDetectSpoofedMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedMacAddress.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectSpoofedMacAddress.setDescription('MAC address that has sent out spoofing ARP.')
rcVlanPortSpoofDetectPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortSpoofDetectPort.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectPort.setDescription('Port index that has enabled spoof-detect.')
rcVlanPortSpoofDetectVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 3, 16, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcVlanPortSpoofDetectVlanId.setStatus('current')
if mibBuilder.loadTexts: rcVlanPortSpoofDetectVlanId.setDescription('VLAN ID that has been detected under spoof attack.')
mibBuilder.exportSymbols("RC-VLAN-MIB", rcVlanNewLoopDetectedVlanId=rcVlanNewLoopDetectedVlanId, rcVlanIgmpSnoopAccessHostAddr=rcVlanIgmpSnoopAccessHostAddr, rcVlanPortVlanIds=rcVlanPortVlanIds, rcVlanLoopDetectedVlanId=rcVlanLoopDetectedVlanId, rcVlanPortPerformTagging=rcVlanPortPerformTagging, rcVlanIgmpSnoopQuerierPort=rcVlanIgmpSnoopQuerierPort, rcVlanSubnetMask=rcVlanSubnetMask, rcVlanPortSpoofDetectIndex=rcVlanPortSpoofDetectIndex, rcVlanPortSpoofDetectPort=rcVlanPortSpoofDetectPort, rcVlanPortCfmMipVlanId=rcVlanPortCfmMipVlanId, rcSvlanEtherType=rcSvlanEtherType, rcVlanPortCfmMepEntry=rcVlanPortCfmMepEntry, rcVlanOspfPassivePortMember=rcVlanOspfPassivePortMember, rcVlanUserDefinedPidList=rcVlanUserDefinedPidList, rcVlanIpsecEnable=rcVlanIpsecEnable, rcVlanPortType=rcVlanPortType, rcVlanPortFirstPortInOpid=rcVlanPortFirstPortInOpid, rcVlanPortLoopDetectAction=rcVlanPortLoopDetectAction, rcVlanIgmpSnoopActiveQuerier=rcVlanIgmpSnoopActiveQuerier, rcVlanLoopDetectedPortIndex=rcVlanLoopDetectedPortIndex, rcVlanHighPriority=rcVlanHighPriority, rcVlanIgmpSnoopAccessRowStatus=rcVlanIgmpSnoopAccessRowStatus, rcVlanClearMacRecordEntry=rcVlanClearMacRecordEntry, rcVlanPortCfmMipEntry=rcVlanPortCfmMipEntry, rcVlanPortCfmMepMepList=rcVlanPortCfmMepMepList, rcVlanRowStatus=rcVlanRowStatus, rcVlanUserPriority=rcVlanUserPriority, rcVlanIfIndex=rcVlanIfIndex, rcVlanUserDefinedPid=rcVlanUserDefinedPid, rcVlanClearMacRecordVlanId=rcVlanClearMacRecordVlanId, rcVlanPortPrivateVlanPortType=rcVlanPortPrivateVlanPortType, rcVlanIgmpSnoopAccessTable=rcVlanIgmpSnoopAccessTable, rcVlanRspanEnabled=rcVlanRspanEnabled, rcVlanAssociatedIpMultinettingVlan=rcVlanAssociatedIpMultinettingVlan, rcVlanOperNlbMode=rcVlanOperNlbMode, rcVlanIgmpSnoopStaticVlanId=rcVlanIgmpSnoopStaticVlanId, rcVlanIgmpSnoopStaticIpAddress=rcVlanIgmpSnoopStaticIpAddress, rcVlanStaticMembers=rcVlanStaticMembers, rcVlanIgmpSnoopAccessEntry=rcVlanIgmpSnoopAccessEntry, rcVlanPortCfmMipMipList=rcVlanPortCfmMipMipList, rcVlanPortCfmMipTable=rcVlanPortCfmMipTable, rcVlanTable=rcVlanTable, rcVlanRmonEnable=rcVlanRmonEnable, rcVlanPortUntagDefaultVlan=rcVlanPortUntagDefaultVlan, rcVlanExtFilterSvcTable=rcVlanExtFilterSvcTable, rcVlanSpbMcast=rcVlanSpbMcast, rcVlanIgmpSnoopIfIndex=rcVlanIgmpSnoopIfIndex, rcVlanIgmpSnoopSenderAction=rcVlanIgmpSnoopSenderAction, rcVlanIgmpSnoopType=rcVlanIgmpSnoopType, rcVlanLoopDetectedValue=rcVlanLoopDetectedValue, rcVlanIgmpSnoopAccessHostMask=rcVlanIgmpSnoopAccessHostMask, rcVlanLoopDetectedEntry=rcVlanLoopDetectedEntry, rcVlanIgmpSnoopStaticEntry=rcVlanIgmpSnoopStaticEntry, rcVlanIpMultinettingEnable=rcVlanIpMultinettingEnable, rcVlanPortCfmMepPort=rcVlanPortCfmMepPort, rcVlanPortSVlanPortType=rcVlanPortSVlanPortType, rcVlanIgmpSnoopEntry=rcVlanIgmpSnoopEntry, rcVlanDsapSsapVlanId=rcVlanDsapSsapVlanId, rcVlanIgmpSnoopAccessVlanId=rcVlanIgmpSnoopAccessVlanId, rcVlanNewLoopDetectedSmltRemote=rcVlanNewLoopDetectedSmltRemote, rcVlanSecondaryVlanId=rcVlanSecondaryVlanId, rcVlanLPortNotAllowToJoin=rcVlanLPortNotAllowToJoin, rcVlanExtFilterSvcEntry=rcVlanExtFilterSvcEntry, rcVlanLPortMembers=rcVlanLPortMembers, rcVlanIgmpSnoopEnable=rcVlanIgmpSnoopEnable, rcSvlanGlobal=rcSvlanGlobal, rcVlanLoopDetectedTable=rcVlanLoopDetectedTable, rcVlanApplyBtagEthertype=rcVlanApplyBtagEthertype, rcVlanType=rcVlanType, rcVlanRoutingEnable=rcVlanRoutingEnable, rcVlanQosLevel=rcVlanQosLevel, rcVlanProtocolId=rcVlanProtocolId, PYSNMP_MODULE_ID=rcVlanMib, rcVlanIgmpSnoopMRouterPorts=rcVlanIgmpSnoopMRouterPorts, rcVlanIgmpSnoopSenderIfIndex=rcVlanIgmpSnoopSenderIfIndex, rcVlanTlsIpmc=rcVlanTlsIpmc, rcVlanNewLoopDetectedTable=rcVlanNewLoopDetectedTable, rcVlanMmrp=rcVlanMmrp, rcVlanAction=rcVlanAction, rcVlanVrfName=rcVlanVrfName, rcVlanIgmpSnoopStaticNotAllowedToJoin=rcVlanIgmpSnoopStaticNotAllowedToJoin, rcVlanUpdateDynamicMacQosLevel=rcVlanUpdateDynamicMacQosLevel, rcVlanIgmpSnoopRobustness=rcVlanIgmpSnoopRobustness, rcVlanNodalMepList=rcVlanNodalMepList, rcVlanIgmpSnoopStaticRowStatus=rcVlanIgmpSnoopStaticRowStatus, rcVlanPortVlanIdList=rcVlanPortVlanIdList, rcVlanIgmpSnoopStaticTable=rcVlanIgmpSnoopStaticTable, rcVlanVrfId=rcVlanVrfId, rcVlanSecondaryIsid=rcVlanSecondaryIsid, rcSvlanEntry=rcSvlanEntry, rcVlanPortSpoofDetectVlanId=rcVlanPortSpoofDetectVlanId, rcVlanColor=rcVlanColor, rcVlanIgmpSnoopTable=rcVlanIgmpSnoopTable, rcVlanPortClassificationSubnet=rcVlanPortClassificationSubnet, rcVlanPortSpoofDetectSpoofedIpAddressType=rcVlanPortSpoofDetectSpoofedIpAddressType, rcVlanIgmpSnoopSenderIpAddress=rcVlanIgmpSnoopSenderIpAddress, rcVlanAgingTime=rcVlanAgingTime, rcVlanResult=rcVlanResult, rcVlanIgmpSnoopQueryInterval=rcVlanIgmpSnoopQueryInterval, rcVlanNewLoopDetectedEntry=rcVlanNewLoopDetectedEntry, rcVlanMib=rcVlanMib, rcVlanVoiceEnabled=rcVlanVoiceEnabled, rcVlanPortSpoofDetectEntry=rcVlanPortSpoofDetectEntry, rcVlanPortDiscardTaggedFrames=rcVlanPortDiscardTaggedFrames, rcVlanNewLoopDetectedAction=rcVlanNewLoopDetectedAction, rcVlanPortCfmMepVlanId=rcVlanPortCfmMepVlanId, rcVlanMgmtVlan=rcVlanMgmtVlan, rcVlanPortCfmMipRowStatus=rcVlanPortCfmMipRowStatus, rcVlanMacAddress=rcVlanMacAddress, rcVlanNodalMipLevelList=rcVlanNodalMipLevelList, rcVlanIgmpSnoopVlanId=rcVlanIgmpSnoopVlanId, rcVlanEncap=rcVlanEncap, rcVlanNewLoopDetectedPortIndex=rcVlanNewLoopDetectedPortIndex, rcVlanIgmpSnoopMRouterExpiration=rcVlanIgmpSnoopMRouterExpiration, rcVlanIgmpVer2SnoopMRouterPorts=rcVlanIgmpVer2SnoopMRouterPorts, rcSvlanLevel=rcSvlanLevel, rcVlanUnkDstMacDiscard=rcVlanUnkDstMacDiscard, rcVlanMacVlanId=rcVlanMacVlanId, rcVlanFirewallVlanType=rcVlanFirewallVlanType, rcVlanIgmpSnoopAccessGrpAddr=rcVlanIgmpSnoopAccessGrpAddr, rcVlanNumOfNodalMep=rcVlanNumOfNodalMep, rcVlanIgmpSnoopMember=rcVlanIgmpSnoopMember, rcVlanPortSpoofDetectTable=rcVlanPortSpoofDetectTable, rcVlanMacEntry=rcVlanMacEntry, rcVlanIgmpSnoopSenderTable=rcVlanIgmpSnoopSenderTable, rcVlanIgmpSnoopIpAddress=rcVlanIgmpSnoopIpAddress, rcSvlanId=rcSvlanId, rcVlanIgmpSnoopAccessMode=rcVlanIgmpSnoopAccessMode, rcSvlanTable=rcSvlanTable, rcVlanActiveMembers=rcVlanActiveMembers, rcVlanExtFilterSvcFwdUnregPorts=rcVlanExtFilterSvcFwdUnregPorts, rcVlanMacTable=rcVlanMacTable, rcVlanPortSpoofDetectSpoofedIpAddress=rcVlanPortSpoofDetectSpoofedIpAddress, rcVlanPortSpoofDetectSpoofedMacAddress=rcVlanPortSpoofDetectSpoofedMacAddress, rcVlanPortCfmMepNumOfMep=rcVlanPortCfmMepNumOfMep, rcVlanSubnetAddr=rcVlanSubnetAddr, rcVlanPortDiscardUntaggedFrames=rcVlanPortDiscardUntaggedFrames, rcVlanIgmpSnoopSenderMember=rcVlanIgmpSnoopSenderMember, rcVlanPortSpoofDetect=rcVlanPortSpoofDetect, rcVlanExtFilterSvcVlanId=rcVlanExtFilterSvcVlanId, rcVlanPortCfmMepTable=rcVlanPortCfmMepTable, rcVlanPortClassificationSourceMac=rcVlanPortClassificationSourceMac, rcVlanExtFilterSvcFwdAllPorts=rcVlanExtFilterSvcFwdAllPorts, rcVlanIgmpSnoopStaticMemberPorts=rcVlanIgmpSnoopStaticMemberPorts, rcVlanNumVlans=rcVlanNumVlans, rcVlanPortEntry=rcVlanPortEntry, rcVlanPortClassificationPrec=rcVlanPortClassificationPrec, rcVlanEntry=rcVlanEntry, rcVlanSource=rcVlanSource, rcVlanMacRowStatus=rcVlanMacRowStatus, rcVlanPortCfmMipPort=rcVlanPortCfmMipPort, rcVlanIgmpSnoopReportProxyEnable=rcVlanIgmpSnoopReportProxyEnable, rcVlanPortRemarking=rcVlanPortRemarking, rcVlanId=rcVlanId, rcVlanLPortStaticMembers=rcVlanLPortStaticMembers, rcVlanDsapSsapEntry=rcVlanDsapSsapEntry, rcVlanMacAddr=rcVlanMacAddr, rcVlanIgmpSnoopActiveMRouterPorts=rcVlanIgmpSnoopActiveMRouterPorts, rcVlanPortDefaultVlanId=rcVlanPortDefaultVlanId, rcVlanNlbMode=rcVlanNlbMode, rcVlanExtFilterSvcFilterUnregPorts=rcVlanExtFilterSvcFilterUnregPorts, rcVlanStgId=rcVlanStgId, rcVlanNumOfNodalMipLevel=rcVlanNumOfNodalMipLevel, rcVlanFirewallClusterId=rcVlanFirewallClusterId, rcVlanFdbAging=rcVlanFdbAging, rcSvlanActiveLevel=rcSvlanActiveLevel, rcVlanDhcpOption82Enabled=rcVlanDhcpOption82Enabled, rcVlanPlsbIsid=rcVlanPlsbIsid, rcVlanPortTable=rcVlanPortTable, rcVlanDsapSsapRowStatus=rcVlanDsapSsapRowStatus, rcVlanIgmpSnoopSenderVlanId=rcVlanIgmpSnoopSenderVlanId, rcVlanClearMacRecordAddr=rcVlanClearMacRecordAddr, rcVlanPortCfmMepRowStatus=rcVlanPortCfmMepRowStatus, rcVlanPortCfmMipNumOfMip=rcVlanPortCfmMipNumOfMip, rcVlanIgmpSnoopNumGroups=rcVlanIgmpSnoopNumGroups, rcVlanPortClassificationProtocol=rcVlanPortClassificationProtocol, rcVlanNewLoopDetectedMac=rcVlanNewLoopDetectedMac, rcVlanIgmpSnoopExpiration=rcVlanIgmpSnoopExpiration, rcVlanClearMacRecordLCForceDelete=rcVlanClearMacRecordLCForceDelete, rcVlanIgmpSnoopSenderEntry=rcVlanIgmpSnoopSenderEntry, rcVlanLPortActiveMembers=rcVlanLPortActiveMembers, rcVlanDsapSsapPid=rcVlanDsapSsapPid, rcVlanPortLoopDetect=rcVlanPortLoopDetect, rcVlanDsapSsapTable=rcVlanDsapSsapTable, rcVlanIgmpVer1SnoopMRouterPorts=rcVlanIgmpVer1SnoopMRouterPorts, rcVlanPortIndex=rcVlanPortIndex, rcVlanPortMembers=rcVlanPortMembers, rcVlanPortArpDetect=rcVlanPortArpDetect, rcVlanNotAllowToJoin=rcVlanNotAllowToJoin, rcVlanClearMacRecordTable=rcVlanClearMacRecordTable, rcVlanTosValue=rcVlanTosValue, rcVlanPortLastPortInOpid=rcVlanPortLastPortInOpid, rcVlanPortNumVlanIds=rcVlanPortNumVlanIds, rcVlanProtocolIds=rcVlanProtocolIds, rcVlanClearMacRecordForceDelete=rcVlanClearMacRecordForceDelete, rcVlanName=rcVlanName, rcVlanClearMacRecordAllVlanIds=rcVlanClearMacRecordAllVlanIds)
