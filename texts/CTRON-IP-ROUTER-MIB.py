#
# PySNMP MIB module CTRON-IP-ROUTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-IP-ROUTER-MIB
# Produced by pysmi-1.1.12 at Wed Nov  6 08:30:12 2024
# On host fv-az984-999 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
nwRtrProtoSuites, = mibBuilder.importSymbols("ROUTER-OIDS", "nwRtrProtoSuites")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter64, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, iso, Bits, Counter32, NotificationType, TimeTicks, IpAddress, ObjectIdentity, Unsigned32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter64", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "iso", "Bits", "Counter32", "NotificationType", "TimeTicks", "IpAddress", "ObjectIdentity", "Unsigned32", "Integer32")
DisplayString, TextualConvention, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "PhysAddress")
nwIpRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1))
nwIpMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 1))
nwIpComponents = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2))
nwIpSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1))
nwIpForwarding = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2))
nwIpTopology = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4))
nwIpFib = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5))
nwIpEndSystems = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6))
nwIpAccessControl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7))
nwIpFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 8))
nwIpRedirector = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9))
nwIpEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10))
nwIpWorkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11))
nwIpClientServices = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 12))
nwIpSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 1))
nwIpSysAdministration = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2))
nwIpFwdSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1))
nwIpFwdInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2))
nwIpFwdCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1))
nwIpFwdIfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1))
nwIpFwdIfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2))
nwIpDistanceVector = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1))
nwIpLinkState = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2))
nwIpRip = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1))
nwIpRipSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1))
nwIpRipInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2))
nwIpRipDatabase = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3))
nwIpRipFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 4))
nwIpRipConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1))
nwIpRipCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2))
nwIpRipIfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1))
nwIpRipIfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2))
nwIpOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1))
nwIpOspfSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1))
nwIpOspfInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2))
nwIpOspfDatabase = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 3))
nwIpOspfFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 4))
nwIpOspfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1))
nwIpOspfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2))
nwIpOspfIfConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1))
nwIpOspfIfCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2))
nwIpFibSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 1))
nwIpOspfFib = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2))
nwIpOspfFibControl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 1))
nwIpOspfFibEntries = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2))
nwIpHostsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 1))
nwIpHostsInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2))
nwIpHostsToMedia = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3))
nwIpRedirectorSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1))
nwIpRedirectorInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 2))
nwIpEventLogConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 1))
nwIpEventLogFilterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2))
nwIpEventLogTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3))
nwIpMibRevText = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpMibRevText.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpMibRevText.setDescription('Indicates the current revision level of the IP MIB in\n            textual format.')
nwIpSysRouterId = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpSysRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysRouterId.setDescription('The IP Address used to uniquely identify the host\n            (device) running IP Routing Services. The value of\n            nwIpSysRouterId is equal to the highest IP Address in \n            the IP Address Table.')
nwIpSysAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpSysAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysAdminStatus.setDescription('Sets the administrative state of IP Routing Services\n        system-wide. Enabled(3) causes IP Routing Services to\n        become active on all router ports configured and enabled\n        for IP Routing Services. Disabled(2) causes IP Routing\n        Services to become inactive system-wide.')
nwIpSysOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpSysOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysOperStatus.setDescription('Indicates the operating condition of IP Routing Services, system-wide.\n        The value of nwIpSysOperStatus indicates any problem with\n        your IP Routing Services configuration. A value of 6 \n        indicates that regardless of the value of \n        nwIpSysAdminStatus,IP Routing Services is not operating\n        because of an invalid configuration.')
nwIpSysAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpSysAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysAdminReset.setDescription('Resets IP Routing Services, system-wide. Reset (2)\n        forces a restart of IP Routing Services without a\n        graceful shutdown on any active router ports, without\n        affecting any other routing services.')
nwIpSysOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpSysOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwIpSysOperStatus has been in its current administrative\n        state.')
nwIpSysVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 1, 2, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpSysVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpSysVersion.setDescription('Indicates the current revision level of the IP Routing\n        Services firmware, in textual format.')
nwIpFwdCtrAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrAdminStatus.setDescription('Sets the administrative state of the aggregate\n        (system-wide) IP packet and byte counters. Enabled (3)\n        causes these counters to become active. Disabled (2)\n        causes these counters to become inactive.')
nwIpFwdCtrReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrReset.setDescription('Resets the aggregate (system-wide) IP packet and byte\n        counters. Reset (2) resets the IP aggregate counters to 0. \n        nwIpFwdCtrOperationalTime is also reset to 0.')
nwIpFwdCtrOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwIpFwdCtrAdminStatus has been in the current state.')
nwIpFwdCtrInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrInPkts.setDescription('Indicates the total number of IP packets that have been\n        received, system-wide, during nwIpFwdCtrOperationalTime.')
nwIpFwdCtrOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrOutPkts.setDescription('Indicates the total number of IP packets that have been\n        transmitted, system-wide, during nwIpFwdCtrOperationalTime.')
nwIpFwdCtrFwdPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrFwdPkts.setDescription('Indicates the total number of IP packets that have been\n        forwarded, system-wide, during nwIpFwdCtrOperationalTime.')
nwIpFwdCtrFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrFilteredPkts.setDescription('Indicates the total number of IP packets that have been\n        administratively filtered, system-wide, during\n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrDiscardPkts.setDescription('Indicates the total number of IP packets that have been\n        discarded, system-wide, during nwIpFwdCtrOperationalTime.')
nwIpFwdCtrAddrErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrAddrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrAddrErrPkts.setDescription('Indicates the total number of IP packets that have been\n        discarded, system-wide, during nwIpFwdCtrOperationalTime,\n        because of addressing errors in the IP header.')
nwIpFwdCtrLenErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrLenErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrLenErrPkts.setDescription('Indicates the total number of IP packets that have been\n        discarded, system-wide, during nwIpFwdCtrOperationalTime,\n        because an invalid packet length is contained in the IP header.')
nwIpFwdCtrHdrErrPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHdrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHdrErrPkts.setDescription('Indicates the total number of IP packets that have been\n        discarded, system-wide, during nwIpFwdCtrOperationalTime,\n        because of an invalid IP header.')
nwIpFwdCtrInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrInBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been received, system-wide, during \n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrOutBytes.setDescription('Indicates the total number of bytes in the IP packets that have\n        been transmitted, system-wide, during nwIpFwdOperationalTime.')
nwIpFwdCtrFwdBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrFwdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrFwdBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been forwarded, system-wide, during\n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrFilteredBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrFilteredBytes.setDescription('Indicates the total number of bytes in the IP packets\n        that have been administratively filtered, system-wide,\n        during nwIpFwdCtrOperationalTime.')
nwIpFwdCtrDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrDiscardBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been discarded, system-wide, during\n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostInPkts.setDescription('Indicates the total number of IP packets that have\n        been successfully delivered to the local host, during\n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostOutPkts.setDescription('Indicates the total number of IP packets that have been\n         forwarded by the local host, during \n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostDiscardPkts.setDescription('Indicates the total number of IP packets that have been\n         discarded by the local host, during\n         nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostInBytes.setDescription('Indicates the total number of IP packets that have been\n         received by the local host, during\n         nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostOutBytes.setDescription('Indicates the total number of IP packets that have been\n        transmitted by the local host, during\n        nwIpFwdCtrOperationalTime.')
nwIpFwdCtrHostDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdCtrHostDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdCtrHostDiscardBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been discarded by the local host, during\n        nwIpFwdCtrOperationalTime, due to a lack of host resources.')
nwIpFwdIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1), )
if mibBuilder.loadTexts: nwIpFwdIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfTable.setDescription('This table contains an entry for each router port.\n         This table is indexed by nwIpFwdIfIndex, which indicates\n         the value of MIB 2 ifindex which identifies the router \n         port for which each entry exists. ')
nwIpFwdIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpFwdIfIndex"))
if mibBuilder.loadTexts: nwIpFwdIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfEntry.setDescription('Each entry specifies the IP Routing Services configuration\n        for the router port for which the entry exists.')
nwIpFwdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies the router\n        port.')
nwIpFwdIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfAdminStatus.setDescription('Sets the administrative state of IP Routing Services\n         on the router port for which the entry exists. Enabled (3)\n         causes IP Routing Services to become active. Disabled (2)\n         causes it to become inactive.')
nwIpFwdIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfOperStatus.setDescription('Indicates the current operating condition of\n        IP Routing Services on the router port for which the\n        entry exists. The value of nwIpFwdIfOperStatus indicates\n        any problem with the configuration of IP routing Services on\n        the router port. A value of 6 indicates that regardless of \n        the value of nwIpFwdIfAdminStatus, IP Routing Services is\n        not operating because of an invalid port-level configuration.')
nwIpFwdIfOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwIpFwdIfOperStatus has been in its current state.')
nwIpFwdIfControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("add", 2), ("delete", 3))).clone('add')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfControl.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol-specific MIBs. Setting this object\n        has no effect.')
nwIpFwdIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 6), Integer32().clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfMtu.setDescription('Specifies the Maximum Transmission Unit (MTU) for IP packets\n        on the router port for which the entry exists. This includes\n        the IP header and data, but does not include framing.')
nwIpFwdIfForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfForwarding.setDescription('Controls forwarding of IP packets on the router port for\n        which the entry exists. Enabled (3) causes IP packets to be\n        forwarded. Disabled (2) prevents IP packets from being\n        forwarded.')
nwIpFwdIfFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 7, 8, 9, 11, 14, 16, 17))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("snap", 3), ("slip", 5), ("localtalk", 7), ("nativewan", 8), ("encapenet", 9), ("encapenetsnap", 11), ("encaptrsnap", 14), ("encapfddisnap", 16), ("canonical", 17))).clone('ethernet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfFrameType.setDescription('Specifies the framing type for IP packets forwarded on\n        the router port for which the entry exists.')
nwIpFwdIfAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfAclIdentifier.setDescription('Specifies the Access Control ID of the access control\n         list in effect for the IP packets being routed on the router port\n         for which the entry exists. A value of 0 indicates that no\n         access control list is in effect.')
nwIpFwdIfAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfAclStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfAclStatus.setDescription('Controls the operation of any access control list configured\n        for IP traffic for the IP packets being routed on the router port\n        for which the entry exists. Enabled (3) applies the access control\n        list, indicated by nwIpFwdIfAclIdentifier to all IP traffic being\n        routed on the port. Disabled (2) prevents the access control list\n        from being applied.')
nwIpFwdIfCacheControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfCacheControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCacheControl.setDescription('Controls IP Address caching on the router port for which\n        the entry exists. IP Address caching speeds-up the switching\n        process. When IP Addresses caching is enabled, IP Addresses\n        used for address validation, filtering, and forwarding are\n        stored in the cache. This cache is checked first before\n        doing a full route table lookup, which speeds up the switching\n        process. Enabled (3) turns on IP Address caching. Disabled (2\n        turns it off.')
nwIpFwdIfCacheEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCacheEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCacheEntries.setDescription('Indicates the number of entries in the IP Address\n            cache on the router port for which the entry exists.')
nwIpFwdIfCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCacheHits.setDescription('Indicates the number of times entries in the IP\n            Address Cache have been used to provide the IP Address\n            required to validate, filter, or forward an IP packet\n            on the router port.')
nwIpFwdIfCacheMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCacheMisses.setDescription('Indicates the number of times the IP Address required to\n            validate, filter, or forward an IP packet on the router\n            port was not found in the IP Address cache.')
nwIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2), )
if mibBuilder.loadTexts: nwIpAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddressTable.setDescription('This table contains an entry for each IP Address \n        assigned to each router port.')
nwIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpAddrIfIndex"), (0, "CTRON-IP-ROUTER-MIB", "nwIpAddrIfAddress"))
if mibBuilder.loadTexts: nwIpAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrEntry.setDescription('Each entry specifies the IP addressing information for\n        the logical IP network for which the entry exists.')
nwIpAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies the router\n        port for which the entry exists.')
nwIpAddrIfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfAddress.setDescription('This is the IP Address assigned to the logical IP \n        network for which the entry exist. As multiple IP Addresses\n        may be assigned to a single router port, all addresses \n        assigned to the port must be of the same subnet.')
nwIpAddrIfControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("add", 2), ("delete", 3))).clone('add')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfControl.setDescription('Set this object to add or delete this entry from the table.')
nwIpAddrIfAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("primary", 2), ("secondary", 3), ("workgroup", 4))).clone('primary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfAddrType.setDescription('Specifies whether the IP address, nwIpAddrIfAddress, is\n         the primary, workgroup or secondary IP address for the IP router\n         port for which the entry exists. A primary or workgroup address\n         must be specified before a router port can be enabled.')
nwIpAddrIfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfMask.setDescription('Specifies the Subnet Mask for the logical IP network for\n        which the entry exists.')
nwIpAddrIfBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("zeros", 2), ("ones", 3))).clone('ones')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAddrIfBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAddrIfBcastAddr.setDescription('Specifies the IP broadcast address type for the logical\n        IP network for which the entry exists. A router port may\n        be configured to send IP broadcasts using the all-ones-based\n        format or the all-zeros-based format. nwIpAddrIfBcastAddr\n        determines the value of the broadcast portion of the IP\n        broadcast address being used to address broadcast packets.')
nwIpFwdIfCtrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1), )
if mibBuilder.loadTexts: nwIpFwdIfCtrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrTable.setDescription('This table contains an entry for each router port configured\n        and enabled for IP Routing Services.')
nwIpFwdIfCtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpFwdIfCtrIfIndex"))
if mibBuilder.loadTexts: nwIpFwdIfCtrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrEntry.setDescription('Each entry indicates the packet and byte count of IP\n        packets on the router port for which the entry exists.')
nwIpFwdIfCtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies the\n        router port for which the entry exists.')
nwIpFwdIfCtrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrAdminStatus.setDescription('Sets the administrative state of the per-port IP packet\n        and byte counters on the router port for which the entry\n        exists. Enabled (3) causes these counters to become active.\n        Disabled (2) causes these counters to become inactive.')
nwIpFwdIfCtrReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpFwdIfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrReset.setDescription('Resets the per-port IP packet and byte counters on the\n        router port for which the entry exists. Reset (2) resets the\n        counters to 0. nwIpFwdIfCtrOperationalTime is also reset to 0.')
nwIpFwdIfCtrOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second, that\n        the per-port IP packet and byte counters have been active on\n        the router port for which the entry exists.')
nwIpFwdIfCtrInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrInPkts.setDescription('Indicates the total number of IP packets that have been\n        received, during nwIpFwdIfCtrOperationaltime, on the router\n        port for which the entry exists.')
nwIpFwdIfCtrOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrOutPkts.setDescription('Indicates the total number of IP packets that have\n        been transmitted, during nwIpFwdIfCtrOperationalTime,\n        on the router port for which the entry exists.')
nwIpFwdIfCtrFwdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrFwdPkts.setDescription('Indicates the total number of IP packets that have been\n        forwarded during nwIpFwdIfCtrOperationalTime, on the router\n        port for which the entry exists.')
nwIpFwdIfCtrFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrFilteredPkts.setDescription('Indicates the total number of IP packets that have been\n         administratively filtered, during\n        nwIpFwdIfCtrOperationalTime, on the IP router port for\n        which this entry exists.')
nwIpFwdIfCtrDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrDiscardPkts.setDescription('Indicates the total number of IP packets that have\n        been discarded (dropped), during nwIpFwdIfCtrOperationalTime,\n        on the router port for which the entry exists.')
nwIpFwdIfCtrAddrErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrAddrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrAddrErrPkts.setDescription('Indicates the total number of IP packets that have been\n        discarded, because of addressing errors in the IP header,\n        during nwIpFwdIfCtrOperationalTime, on the router port for\n        which the entry exists.')
nwIpFwdIfCtrLenErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrLenErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrLenErrPkts.setDescription('Indicates the total number of IP packets that have been discarded,\n         because an invalid packet length was contained in the IP header, during\n         nwIpFwdIfCtrOperationalTime, on the router port for which the entry exists.')
nwIpFwdIfCtrHdrErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHdrErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHdrErrPkts.setDescription('Indicates the total number of IP packets that have been discarded,\n         because of an invalid IP header, during nwIpFwdIfCtrOperationalTime,\n         on the router port for which the entry exists.')
nwIpFwdIfCtrInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrInBytes.setDescription('Indicates the total number of bytes in the IP packets that have been\n         received, during nwIpFwdIfCtrOperationalTime, on the router port for\n         which the entry exists.')
nwIpFwdIfCtrOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrOutBytes.setDescription('Indicates the total number of bytes in the IP packets that have\n         been transmitted, during nwIpFwdIfCtrOperationalTime, on the router\n         port for which the entry exists.')
nwIpFwdIfCtrFwdBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrFwdBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrFwdBytes.setDescription('Indicates the total number of bytes in the IP packets\n        that have been forwarded, on the router port for which the\n        entry exists, during nwIpFwdIfCtrOperationalTime.')
nwIpFwdIfCtrFilteredBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the IP packets\n         that have been administratively filtered, during\n         nwIpFwdIfCtrOperationalTime, on the IP router port for\n        which the entry exists.')
nwIpFwdIfCtrDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been discarded, during nwIpFwdIfCtrOperationalTime, on\n        the router port for which the entry exists.')
nwIpFwdIfCtrHostInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostInPkts.setDescription('Indicates the total number of IP packets that have been\n        successfully delivered to the local host, that were received\n        on the router port for which the entry exists, during\n        nwIpFwdIfCtrOperationalTime.')
nwIpFwdIfCtrHostOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostOutPkts.setDescription('Indicates the total number of IP packets that have been\n        transmitted by the local host, during\n        nwIpFwdIfCtrOperationalTime, on the router port for which the\n        entry exists.')
nwIpFwdIfCtrHostDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostDiscardPkts.setDescription('Indicates the total number of IP packets discarded by the\n        local host due to a lack of host resources, that were \n        received on the router port for which the entry exists, \n        during nwIpFwdIfCtrOperationalTime.')
nwIpFwdIfCtrHostInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostInBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been successfully delivered to the local host, that \n        were received on the router port for which the entry exists,\n        during nwIpFwdIfCtrOperationalTime. ')
nwIpFwdIfCtrHostOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostOutBytes.setDescription('Indicates the total number of bytes in the IP packets that\n        have been transmitted by the local host, during\n        nwIpFwdIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwIpFwdIfCtrHostDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 2, 2, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpFwdIfCtrHostDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpFwdIfCtrHostDiscardBytes.setDescription('Indicates the total number of bytes in the IP packets\n        that have been discarded by the local host due to a lack\n        of host resources, that were received on the router port\n        for which the entry exists, during\n        nwIpFwdIfCtrOperationalTime.')
nwIpRipAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipAdminStatus.setDescription('Sets the administrative state of the RIP routing\n        protocol system-wide. Enabled (3) causes RIP to become\n        active on all router ports configured and enabled for\n        IP Routing Services. Disabled (2) causes RIP to become\n        inactive.')
nwIpRipOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5), ("invalid-config", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipOperStatus.setDescription('Indicates the current operating condition of the RIP\n        routing protocol system-wide. The value of \n        nwIpRipOperStatus indicates any problem with your RIP\n        configuration. A value of 6 indicates that regardless \n        of the value of nwIpRipAdminStatus, RIP is not operating\n        because of an invalid configuration.')
nwIpRipAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipAdminReset.setDescription('Resets the RIP routing protocol. Reset (2) forces a\n         system-wide restart of the protocol system-wide without\n         a graceful shutdown on any active router ports.')
nwIpRipOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second, that\n        nwIpRipOperStatus, has been in its current state.')
nwIpRipVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipVersion.setDescription('Indicates the current revision level of the RIP routing\n        protocol firmware, in textual format.')
nwIpRipStackSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 6), Integer32().clone(4096)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipStackSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipStackSize.setDescription('Specifies the stack size of the RIP routing protocol thread.\n        In order for a change of this value to take effect, the\n        protocol (nwIpRipAdminReset), IP Routing Services\n        (nwIpSysAdminReset), or the device running Routing Services\n        must be reset.')
nwIpRipThreadPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 7), Integer32().clone(127)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipThreadPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipThreadPriority.setDescription('Specifies the run-time execution priority of the RIP\n        routing protocol thread. In order for a change of this\n        value to take effect, RIP (nwIpRipAdminReset), IP Routing\n        Services (nwIpAdminReset), or the device running Routing\n        Services must be reset.')
nwIpRipDatabaseThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 8), Integer32().clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipDatabaseThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipDatabaseThreshold.setDescription('Specifies the run-time maximum number of RIP entries that\n        can be held in the RIP route table.')
nwIpRipAgeOut = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 9), Integer32().clone(210)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipAgeOut.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipAgeOut.setDescription('Specifies the amount of time, in seconds, that an inactive\n        route table entry will be allowed to remain in the RIP route\n        table before it is aged-out.')
nwIpRipHoldDown = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 1, 10), Integer32().clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipHoldDown.setDescription('Specifies the amount of time (in seconds) to wait before\n        removing an entry from the route table, after receiving an\n        update indicating that the destination has become unreachable.\n        All routers exchanging RIP routing protocol information must\n        have the same hold down time. The time must be long enough\n        to allow all participating routers to receive the same update.')
nwIpRipCtrAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrAdminStatus.setDescription('Sets the administrative state of the aggregate (system-wide)\n        RIP routing protocol packet and byte counters. Enabled (3)\n        causes these counters to become active. Disabled (2) causes\n        these counters to become inactive.')
nwIpRipCtrReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrReset.setDescription('Resets the aggregate (system-wide) RIP routing protocol\n        packet and byte counters. Reset (2) resets the RIP aggregate\n        counters to 0. nwIpRipCtrOperationalTime is also reset to 0.')
nwIpRipCtrOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second, that\n        nwIpRipCtrAdminStatus has been in the current state.')
nwIpRipCtrInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrInPkts.setDescription('Indicates the total number of RIP packets that have been\n        received, system-wide, during nwIpRipCtrOperationalTime.')
nwIpRipCtrOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrOutPkts.setDescription('Indicates the total number of RIP packets that have been\n        transmitted, system-wide, during nwIpRipCtrOperationalTime.')
nwIpRipCtrFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrFilteredPkts.setDescription('Indicates the total number of RIP packets that have been\n         administratively filtered, system-wide, during\n         nwIpRipCtrOperationalTime.')
nwIpRipCtrDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrDiscardPkts.setDescription('Indicates the total number of RIP packets that have been\n        discarded, system-wide, during nwIpRipCtrOperationalTime.')
nwIpRipCtrInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrInBytes.setDescription('Indicates the total number of bytes in the RIP packets that\n        have been received, system-wide, during\n        nwIpRipCtrOperationalTime.')
nwIpRipCtrOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrOutBytes.setDescription('Indicates the total number of bytes in the RIP packets\n         that have been transmitted, system-wide, during     \n        nwIpRipCtrOperationalTime.')
nwIpRipCtrFilteredBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrFilteredBytes.setDescription('Indicates the total number of bytes in the RIP packets\n        that have been administratively filtered, system-wide,\n        during nwIpRipCtrOperationalTime.')
nwIpRipCtrDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipCtrDiscardBytes.setDescription('Indicates the total number of bytes in the RIP packets\n        that have been discarded, system-wide, during\n        nwIpRipCtrOperationalTime.')
nwIpRipIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1), )
if mibBuilder.loadTexts: nwIpRipIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfTable.setDescription('This table contains an entry for each router port. Each\n        entry can contain different values, allowing the routing\n        protocol configuration to vary from router port to router\n        port. This table is indexed by nwIpRipIfIndex, which \n        indicates the value of MIB 2 ifindex, which identifies the\n        router port for which the entry exists.')
nwIpRipIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpRipIfIndex"))
if mibBuilder.loadTexts: nwIpRipIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfEntry.setDescription('Each entry contains the RIP routing protocol configuration\n        for the router port for which the entry exists.')
nwIpRipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwIpRipIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfAdminStatus.setDescription('Sets the administrative state of the RIP routing protocol\n        on the router port for which the entry exists. Enabled (3)\n        causes RIP to become active on the router port. Disabled (2)\n        causes RIP to become inactive on the router port.')
nwIpRipIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfOperStatus.setDescription('Indicates the current operating condition of the RIP\n        routing protocol on the router port for which the entry\n        exists. The value of nwIpRipIfOperStatus indicates any problem\n        with your RIP configuration on the router port. A value of 6\n        indicates that regardless of the value of nwIpRipIfAdminStatus,\n        RIP is not operating on the port because of an invalid\n        configuration.')
nwIpRipIfOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        nwIpRipIfOperStatus, has been in its current state.')
nwIpRipIfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 5), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfVersion.setDescription('Indicates the revision level of the RIP routing protocol\n        firmware on the router port for which the entry exists, in\n        textual format.')
nwIpRipIfAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 6), Integer32().clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfAdvertisement.setDescription('Sets the interval, in seconds, at which RIP advertises \n        the RIP route table on the router port for which the entry\n        exists.')
nwIpRipIfFloodDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 7), Integer32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfFloodDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfFloodDelay.setDescription('Sets the length of time, in seconds, that the RIP routing\n        protocol should wait after discovering that a directly\n        connected route has gone down, before flooding updates\n        (triggered updates) on the router port for which the entry\n        exists. A value of 0 specifies that if a directly connected\n        route goes down, updates should be sent immediately.')
nwIpRipIfRequestDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfRequestDelay.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfRequestDelay.setDescription('Sets the length of time, in hundredths of a second, that\n        the RIP routing protocol should wait after receiving a \n        route request packet, before sending a response on the \n        router port for which the entry exists. A value of 0 \n        specifies that if a route request packet is received on the\n        port, a response should be sent immediately.')
nwIpRipIfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 9), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfPriority.setDescription('This object does not apply to this protocol. It is a common\n        object, inherited from the MIB framework used to provide a\n        common management interface to all the Cabletron Routing\n        Services protocol-specific MIBs. Setting this object has no\n        effect.')
nwIpRipIfHelloTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 10), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfHelloTimer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfHelloTimer.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to \n        provide a common management interfaced to all the Cabletron      \n        Routing Services protocol-specific MIBs. Setting this object\n        has no effect.')
nwIpRipIfSplitHorizon = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfSplitHorizon.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfSplitHorizon.setDescription('Sets the operating condition of Split Horizon on the\n        router port for which the entry exists. When Split Horizon\n        is enabled, the RIP routing protocol keeps track of which\n        router port route information is received on, and prevents\n        information about a route form being sent back out the same\n        router port it was received on.')
nwIpRipIfPoisonReverse = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfPoisonReverse.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfPoisonReverse.setDescription('Sets the operating condition of Poison Reverse on the \n        router port for which the entry exists. When Poison Reverse\n        is enabled, the RIP routing protocol advertises any downed\n        route as unreachable during the period of time that it must\n        wait before removing the route from the route table.')
nwIpRipIfSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfSnooping.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfSnooping.setDescription('Controls the operation of RIP Snooping on the router\n        port. When RIP Snooping is enabled the RIP routing protocol\n        operates in passive mode so that it receives route information,\n        builds and maintains a route table, but does not advertise the\n        route table or send updates on the router port for which the\n        entry exists.')
nwIpRipIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("bma", 2), ("nbma", 3))).clone('bma')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfType.setDescription('Indicates whether the directly connected network segment\n        does or does not support broadcast media access. If broadcast\n        media access is supported, RIP advertisements are sent out one\n        broadcast packet per router port. If broadcast media is not\n        supported, RIP advertisements are sent directly to each \n        neighbor router access.')
nwIpRipIfXmitCost = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfXmitCost.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfXmitCost.setDescription('This object does not apply to this protocol. It is a \n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol-specific MIBs. Setting this object\n        has no effect.')
nwIpRipIfAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfAclIdentifier.setDescription('Specifies the Access Control ID of the access control\n        list in effect for RIP routing protocol packets on the\n        router port for which the entry exists. A value of 0 \n        indicates that there is no access control list in effect\n        for RIP routing protocol packets on the router port.')
nwIpRipIfAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfAclStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfAclStatus.setDescription('Controls the operation of the access control list \n        identified by nwIpRipIfAclIdentifier. Enabled (3) applies\n        the access control list to all RIP routing protocol packet\n        traffic on the router port for which the entry exists.\n        Disabled (2) prevents the access control list from being\n        applied.')
nwIpRipIfCtrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1), )
if mibBuilder.loadTexts: nwIpRipIfCtrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrTable.setDescription('This table contains an entry for each router port.This table\n        is indexed by nwIpRipIfCtrIfIndex which indicates the value\n        of MIB 2 ifindex, which identifies the router port for which\n        the entry exists.')
nwIpRipIfCtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpRipIfCtrIfIndex"))
if mibBuilder.loadTexts: nwIpRipIfCtrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrEntry.setDescription('Each entry indicates the current packet and byte count of\n        RIP routing protocol packets on the router port for which\n        the entry exists.')
nwIpRipIfCtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwIpRipIfCtrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrAdminStatus.setDescription('Sets the administrative state of the RIP packet and byte\n        counters on the router port for which this entry exists. \n        Enabled (3) causes these counters to become active.\n        Disabled (2) causes these counters to become inactive.')
nwIpRipIfCtrReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipIfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrReset.setDescription('Resets the per-port RIP packet and byte counters on the\n        router port for which this entry exists. Reset (2) resets\n        the counters to 0. nwIpRipIfCtrOperationalTime is also reset\n        to 0.')
nwIpRipIfCtrOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n            that nwIpRipIfCtrAdminStatus has been in the current\n            state.')
nwIpRipIfCtrInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrInPkts.setDescription('Indicates the total number of RIP routing protocol packets\n        that have been received, during nwIpRipIfCtrOperationalTime,\n        on the router port for which the entry exists.')
nwIpRipIfCtrOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrOutPkts.setDescription('Indicates the total number of RIP packets that have been\n        transmitted, during nwIpRipIfCtrOperationalTime, on the router\n        port for which the entry exists.')
nwIpRipIfCtrFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrFilteredPkts.setDescription('Indicates the total number of RIP packets that have been\n        administratively filtered during nwIpRipIfCtrOperationalTime,\n        on the router port for which the entry exists.')
nwIpRipIfCtrDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrDiscardPkts.setDescription('Indicates the total number of RIP routing protocol packets\n        that have been discarded, during nwIpRipIfCtrOperationalTime.\n        that were received through the router port for which the entry\n        exists.')
nwIpRipIfCtrInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrInBytes.setDescription('Indicates the total number of bytes in the RIP routing\n        protocol packets that have been received, during\n        nwIpRipIfCtrOperationalTime, on the router port for which this\n        entry exists.')
nwIpRipIfCtrOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrOutBytes.setDescription('Indicates the total number of bytes in the RIP routing\n        protocol packets that have been transmitted, during\n        nwIpRipIfCtrOperationalTime, on the router port for which\n        the entry exists.')
nwIpRipIfCtrFilteredBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the RIP routing\n        protocol packets that have been administratively filtered,\n        during nwIpRipIfCtrOperationalTime, on the router port for\n        which the entry exists.')
nwIpRipIfCtrDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipIfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipIfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the RIP routing\n        protocol packets that have been discarded during\n        nwIpRipIfCtrOperationalTime, that were received on the\n        router port for which the entry exists.')
nwIpRipRouteTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1), )
if mibBuilder.loadTexts: nwIpRipRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRouteTable.setDescription('This table contains the RIP route table. This table contains\n        an entry for each route learned through the RIP routing\n        protocol. Only the best routes from this table are added to\n        the IP forwarding table to be used for packet switching.')
nwIpRipRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpRipRtNetId"), (0, "CTRON-IP-ROUTER-MIB", "nwIpRipRtIfIndex"), (0, "CTRON-IP-ROUTER-MIB", "nwIpRipRtSrcNode"))
if mibBuilder.loadTexts: nwIpRipRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRouteEntry.setDescription('Each entry describes the RIP route to the destination\n        network for which the entry exists.')
nwIpRipRtNetId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtNetId.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtNetId.setDescription('This is the primary index into the RIP route table. This\n        number indicates the IP Address of the destination for which\n        the entry exists.')
nwIpRipRtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtIfIndex.setDescription('This is a secondary index into IP-RIP route table. This\n        number corresponds to the value of MIB 2 ifindex, which\n        identifies the router port for which the entry exists.')
nwIpRipRtSrcNode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtSrcNode.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtSrcNode.setDescription('This is a secondary index into the RIP route table. This\n        number indicates the IP Address of the source router from\n        which this route was learned. A value of 0.0.0.0 indicates\n        that the source is on the network segment directly connected\n        to the router port, nwIpRipRtIfIndex.')
nwIpRipRtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtMask.setDescription('Indicates the Subnet Mask of the IP Address for \n            which the entry exists.')
nwIpRipRtHops = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtHops.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtHops.setDescription('Indicates the number of hops required to reach the\n        destination for which the entry exists.')
nwIpRipRtAge = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtAge.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtAge.setDescription('Indicates the amount of time, in seconds, since an update\n        has been received for the route for which the entry exists.')
nwIpRipRtType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("remote", 4), ("static", 5), ("ospf", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtType.setDescription('Indicates whether the destination network is directly\n        connected through the router port specified by \n        nwIpRipRtIfIndex, or is indirectly connected through\n        another router, specified by nwIpRipRtSrcNode.')
nwIpRipRtFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 1, 1, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRipRtFlags.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRtFlags.setDescription('Specifies properties of the RIP route. The bit mask is\n        as follows: source-changed (1), best-source (2), local net (4),\n        net-down (8), update-fib-only (16).')
nwIpOspfAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfAdminStatus.setDescription('Sets the administrative state of the OSPF routing\n            protocol. enabled(3) causes OSPF to become active\n            on any IP configured router ports. disabled(2) causes \n            OSPF to perform a graceful shutdown on any active IP\n            configured router ports.')
nwIpOspfOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfOperStatus.setDescription('Indicates the current operating condition of OSPF.')
nwIpOspfAdminReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfAdminReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfAdminReset.setDescription('Resets OSPF. reset(2) will force a restart of OSPF\n            on any active IP router ports, configured for OSPF,\n            without a graceful shutdown, without affecting any\n            other routing services.')
nwIpOspfOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfOperationalTime.setDescription('Indicates the amount of time (#of time ticks) that OSPF\n         has been in its current operational state.')
nwIpOspfVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfVersion.setDescription('Indicates the current Cabletron revision level of OSPF\n             in textual format, not the OSPF version supported.')
nwIpOspfStackSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 6), Integer32().clone(50000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfStackSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStackSize.setDescription('Specifies the stack size for the OSPF thread. In order\n         for a change of this value to take effect, OSPF\n         (nwIpOspfAdminStatus), IP (nwIpSysAdminStatus), or the\n         device itself must be reset.')
nwIpOspfThreadPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 1, 7), Integer32().clone(127)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfThreadPriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfThreadPriority.setDescription('Specifies the run-time execution priority of the OSPF\n         protocol thread. In order for a change of this value to\n         take effect, OSPF or the IP routing services, or the\n         device must be reset.')
nwIpOspfCtrAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrAdminStatus.setDescription('Sets the operating condition of the aggregate\n        (device-wide) OSPF packet and byte counters. enable (3)\n         causes these counters to become active on any router ports\n         running OSPF. disabled (2) cause these counters to become\n         inactive on any router port running OSPF.')
nwIpOspfCtrReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrReset.setDescription('Resets the aggregate (device-wide) OSPF packet and byte\n         counters. reset(2) resets the aggregate OSPF counters to 0\n         and nwIpOspfCtrOperationalTime to 0.')
nwIpOspfCtrOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrOperationalTime.setDescription('Indicates the amount of time (# of time ticks) that the\n         aggregate OSPF packet and byte counters have been active.')
nwIpOspfCtrInPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrInPkts.setDescription('Indicates the total number of OSPF packets that have been\n         received, device-wide, during nwIpOspfCtrOperationalTime.')
nwIpOspfCtrOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrOutPkts.setDescription('Indicates the total number of OSPF packets that have been\n         transmitted, device-wide, during nwIpOspfCtr-\n        Operational-Time.')
nwIpOspfCtrFilteredPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrFilteredPkts.setDescription('Indicates the total number of OSPF packets that have been\n         administratively filtered, device-wide, during\n         nwIpOspfCtrOperationalTime.')
nwIpOspfCtrDiscardPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrDiscardPkts.setDescription('Indicates the total number of OSPF packets that have been\n         discarded, device-wide, during nwIpOspfCtrOperationalTime.')
nwIpOspfCtrInBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrInBytes.setDescription('Indicates the total number of bytes in the OSFP packets\n         that have been received, device-wide, during     \n        nwIpOspfCtrOperationalTime.')
nwIpOspfCtrOutBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrOutBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been transmitted, device-wide, during\n         nwIpOspfCtrOperationalTime.')
nwIpOspfCtrFilteredBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been administratively filtered, device-wide,\n         during nwIpOspfCtrOperationalTime.')
nwIpOspfCtrDiscardBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been discarded, during\n         nwIpOspfCtrOperationalTime.')
nwIpOspfIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1), )
if mibBuilder.loadTexts: nwIpOspfIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfTable.setDescription('This table contains the OSPF configuration information for\n         each IP router port')
nwIpOspfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpOspfIfIndex"))
if mibBuilder.loadTexts: nwIpOspfIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfEntry.setDescription('Each entry specifies the OSPF configuration information\n        for the IP router port for which the entry exists.')
nwIpOspfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfIndex.setDescription('This is the primary index into the OSPF interface table.\n         This number corresponds to the index into the MIB-2\n         Interface Table which describes the router port for\n         which the entry exists.')
nwIpOspfIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfAdminStatus.setDescription('Sets the administrative state of OSPF on the IP router\n         port for which the entry exists. enabled(3)\n         causes OSPF to become active on the router port.\n         disabled(2) causes OSPF to become inactive on the\n         router port.')
nwIpOspfIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfOperStatus.setDescription('Sets the administrative state of OSPF on the IP\n         router port for which the entry exists. enabled(3)\n         causes OSPF to become active on the router port.\n         disabled(2) causes OSPF to become inactive on the\n         router port.')
nwIpOspfIfOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n         that nwIpOspfIfAdminStatus has been in its current state.')
nwIpOspfIfVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 5), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfVersion.setDescription('Indicates the OSPF protocol revision level supported on\n          the router port.')
nwIpOspfIfSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfSnooping.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfSnooping.setDescription('Controls the operation of OSPF Snooping on the IP\n         router port for which the entry exists.OSPF\n         Snooping is operating OSPF in passive mode, so it receives\n         route information, builds and maintains a route\n         information table, but does not advertise. enable (3)\n         turns on OSPF Snooping. disable (2) turns it off.')
nwIpOspfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("bma", 2), ("nbma", 3))).clone('bma')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfType.setDescription('Specifies whether the attached network segment does or\n         does not support broadcast media access. bma (2) indicates\n         that route advertisements can be sent as broadcasts. nbma\n         (3) indicates that route advertisements must be addresses\n         directly to each neighbor.')
nwIpOspfIfAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfAclIdentifier.setDescription('Specifies the Access Control List ID of the access\n         control list applied to OSPF traffic on the IP router\n         port for which the entry exists. A value of\n         0 indicates that no Access List applies.')
nwIpOspfIfAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfAclStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfAclStatus.setDescription('Controls the operation of the access list configured for\n         OSPF traffic on the IP router port for which the entry exists.\n         enabled(3) causes the access list to be applied. disabled(2)\n         causes the access list not to be applied.')
nwIpOspfIfCtrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1), )
if mibBuilder.loadTexts: nwIpOspfIfCtrTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrTable.setDescription('This table contains the OSPF packet and byte counter for\n        each configured OSPF router port.')
nwIpOspfIfCtrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpOspfIfCtrIfIndex"))
if mibBuilder.loadTexts: nwIpOspfIfCtrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrEntry.setDescription('Each entry specifies the OSPF packet and byte counter for\n         for the router for which the entry exists.')
nwIpOspfIfCtrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrIfIndex.setDescription('This is the primary index into the OSPF interface counter\n         table. This number corresponds to the index into the MIB-2\n         Interface Table which describes the router port for\n         which the entry exists.')
nwIpOspfIfCtrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfCtrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrAdminStatus.setDescription('Sets the administrative state of the OSPF packet and byte\n         counters on the IP router port for which\n         the entry exists. enabled(3) causes these counters to\n         become active on the router port. disabled(2) turns these\n         counters off.')
nwIpOspfIfCtrReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("reset", 2))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfIfCtrReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrReset.setDescription('Resets the OSPF packet and byte counters on the router port\n         for which the entry exists. reset (2) resets the\n         interface-specific counters to 0 and\n         nwIpOspfIfCtrOperationalTime  to 0.')
nwIpOspfIfCtrOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrOperationalTime.setDescription('Indicates the amount of time (# of time ticks) that the\n         interface-specific OSPF packet and byte counters have\n         been active on the router port for which the entry\n         exists.')
nwIpOspfIfCtrInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrInPkts.setDescription('Indicates the total number of OSPF packets that have been\n         received, on the router port for which the entry exists,\n         during nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrOutPkts.setDescription('Indicates the total number of OSPF packets that have been\n         transmitted, on the router port for which the entry exists,\n         during nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrFilteredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrFilteredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrFilteredPkts.setDescription('Indicates the total number of OSPF packets that have been\n         administratively filtered, on the router port for which\n         the entry exists, during nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrDiscardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrDiscardPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrDiscardPkts.setDescription('Indicates the total number of OSPF packets that have been\n         discarded, on the router port for which the entry exists,\n        during nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrInBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrInBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been received, on the router port for\n         which the entry exists, during\n         nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrOutBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrOutBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been transmitted, on the router port for which the\n         entry exists, during nwIpOspfIfCtrOperationalTime.')
nwIpOspfIfCtrFilteredBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrFilteredBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrFilteredBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been administratively filtered, on the\n         router port for which the entry exists, during\n         nwIpOspfIfCtrOperationalTime')
nwIpOspfIfCtrDiscardBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 4, 2, 1, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfIfCtrDiscardBytes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfIfCtrDiscardBytes.setDescription('Indicates the total number of bytes in the OSPF packets\n         that have been discarded, on the router port for which the\n         entry exists, during nwIpOspfIfCtrOperationalTime.')
nwIpRipRoutePriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 1, 1), Integer32().clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRipRoutePriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRipRoutePriority.setDescription('Specifies the route priority assigned to routes learned by the\n         RIP routing protocol.')
nwIpOSPFRoutePriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 1, 2), Integer32().clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOSPFRoutePriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOSPFRoutePriority.setDescription('Specifies the route priority assigned to routes learned by the\n        OSPF routing protocol.')
nwIpStaticRoutePriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 1, 3), Integer32().clone(48)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpStaticRoutePriority.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpStaticRoutePriority.setDescription('Specifies the route priority assigned to routes learned by\n        statically configured routes..')
nwIpOspfForward = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfForward.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfForward.setDescription('The total number of valid Cabletron IP OSPF FIB entries to\n         include static, dynamic, RIP and BGP4 type routes.')
nwIpOspfLeakAllStaticRoutes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disabled", 2), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfLeakAllStaticRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfLeakAllStaticRoutes.setDescription('Add all static routes in the IP FIB to the Cabletron IP OSPF FIB for\n         advertisement in OSPF routing protocol announcements.')
nwIpOspfLeakAllRipRoutes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfLeakAllRipRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfLeakAllRipRoutes.setDescription('Add all RIP routes in the IP FIB to the Cabletron IP OSPF FIB for \n         advertisement in OSPF routing protocol announcements.')
nwIpOspfLeakAllBgp4Routes = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfLeakAllBgp4Routes.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfLeakAllBgp4Routes.setDescription('Add all BGP4 routes in the IP FIB to the Cabletron IP OSPF FIB for \n         advertisement in OSPF routing protocol announcements.')
nwIpOspfStaticTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1), )
if mibBuilder.loadTexts: nwIpOspfStaticTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticTable.setDescription('A table of statically configured entries in the Cabletron IP OSPF \n         FIB.')
nwIpOspfStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpOspfStaticDest"), (0, "CTRON-IP-ROUTER-MIB", "nwIpOspfStaticForwardMask"), (0, "CTRON-IP-ROUTER-MIB", "nwIpOspfStaticNextHop"))
if mibBuilder.loadTexts: nwIpOspfStaticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticEntry.setDescription('A list of information for each static entry in the Cabletron \n       IP OSPF FIB.')
nwIpOspfStaticDest = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfStaticDest.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticDest.setDescription('The network Address of a static route leaked from the IP FIB into the\n         Cabletron IP OSPF FIB.')
nwIpOspfStaticForwardMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfStaticForwardMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticForwardMask.setDescription('The network mask of a static route leaked from the IP FIB into the \n         Cabletron IP OSPF FIB.')
nwIpOspfStaticNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpOspfStaticNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticNextHop.setDescription('The next hop address of a static route leaked from the IP FIB into the \n         Cabletron IP OSPF FIB. A value of 0.0.0.0 indicates that packets for \n         the external destination should be forwarded to the\n         advertising router.')
nwIpOspfStaticMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfStaticMetric.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticMetric.setDescription('The Cabletron IP OSPF advertised cost of reaching the leaked static \n         route.')
nwIpOspfStaticMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfStaticMetricType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticMetricType.setDescription('The Cabletron IP OSPF metric type to be advertised using\n        OSPF: Autonomous System External type 1 (1) or Autonomous System\n        External type 2 (2).')
nwIpOspfStaticStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpOspfStaticStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpOspfStaticStatus.setDescription('By setting this OID to inactive for a particular static route, the static \n        route will be added to the IP OSPF FIB but not advertised. Setting this \n        OID to active for a particular static route, the static route will be \n        advertised by the OSPF router. By setting this OID to delete for a \n        particular static route, the entry will no longer be advertised using \n        OSPF and will be deleted from the IP OSPF FIB.')
nwIpOspfDynamicTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 2))
nwIpOspfRipTable = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 3))
nwIpOspfBgp4Table = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 5, 2, 2, 4))
nwIpHostsTimeToLive = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostsTimeToLive.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostsTimeToLive.setDescription('Indicates the amount of time (number of minutes) that an entry\n        can remain in the ARP cache.')
nwIpHostsRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostsRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostsRetryCount.setDescription('Indicates the maximum number of times IP Routing Services\n        will retry each attempt to resolve a host address.')
nwIpHostCtlTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1), )
if mibBuilder.loadTexts: nwIpHostCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlTable.setDescription('This table contains the control information for maintaining\n        a cache of IP host addresses on each router port. Note that\n        the of actual entries are maintained by the IP Address\n        Translation Table (Net-to-Media) of MIB 2.')
nwIpHostCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpHostCtlIfIndex"))
if mibBuilder.loadTexts: nwIpHostCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlEntry.setDescription('Each entry contains the control information for\n        maintaining the cache on each router port.')
nwIpHostCtlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlIfIndex.setDescription('Indicates the value of MIB 2 ifindex, which identifies\n        the router port for which the entry exists.')
nwIpHostCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlAdminStatus.setDescription('This object does not apply to this protocol. It is a\n        common object, inherited from the MIB framework used to\n        provide a common management interface to all the Cabletron\n        Routing Services protocol specific MIBS. Setting this object\n        has no effect.')
nwIpHostCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3), ("pending-disable", 4), ("pending-enable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlOperStatus.setDescription('Indicates the current operating condition of the \n        IP Host Address cache on the router port for which the\n        entry exists.')
nwIpHostCtlOperationalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlOperationalTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlOperationalTime.setDescription('Indicates the elapsed time, in hundredths of a second,\n        that nwIpHostCtlOperStatus has been in the current state.')
nwIpHostCtlProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostCtlProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlProtocol.setDescription('Controls the operation of the ARP protocol on the router\n        port for which the entry exists.')
nwIpHostCtlSnooping = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostCtlSnooping.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlSnooping.setDescription('Controls ARP Snooping on the router port for which\n        the entry exists. Given the ARP protocol is enabled,\n        nwIpHostCtlProtocol=3, setting nwIpHostCtlIfSnooping to\n        enabled (3) turns on ARP Snooping. When ARP Snooping is \n        enabled the source IP and physical addresses of all ARP \n        packets received on the router port are added to the MIB 2\n        Net-to-Media Table.')
nwIpHostCtlProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disable", 2), ("enable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostCtlProxy.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlProxy.setDescription("Controls the operations of Proxy ARP on the router port\n        for which the entry exists. Given the ARP protocol is \n        enabled, nwIpHostCtlProtocol=3, setting nwIpHostCtlProxy to\n        enabled (3) turns on Proxy ARP. When Proxy ARP is enabled on\n        a router port, and an ARP request is received, requesting the\n        address for an IP host whose network address is listed on the\n        IP route table, then IP Routing Services sends a Proxy ARP\n        response, with the physical address of the receiving router \n        port in place of the requested host's physical address. Based\n        on this proxy response, the requesting host will then forward\n        packets to the router port, and IP Routing Services will then\n        forward them to the correct destination.")
nwIpHostCtlCacheMax = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 8), Integer32().clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostCtlCacheMax.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlCacheMax.setDescription('Indicates the maximum number of entry slots the cache\n        can consist of. nwIpHostCtlCacheMax cannot be set to less\n        than 16. Setting this value does not allocate any memory for\n        the cache.')
nwIpHostCtlCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlCacheSize.setDescription('Indicates the current number of entry slots in the cache.\n        The cache automatically resizes to accommodate all entries\n        up to the maximum number of entries set by \n        nwIpHostCtlCacheMax.')
nwIpHostCtlNumStatics = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlNumStatics.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlNumStatics.setDescription('Indicates the total number of static entries in the cache\n        on the router port for which the entry exists. Static entries\n        remain in the cache until they are administratively removed.')
nwIpHostCtlNumDynamics = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlNumDynamics.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlNumDynamics.setDescription('Indicates the number of dynamic entries in the cache on\n        the router port for which the entry exists. Dynamic entries\n        area added and aged out by the ARP protocol.')
nwIpHostCtlCacheHits = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlCacheHits.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlCacheHits.setDescription('Indicates the number of times an entry in the cache has\n        been used to successfully provide the physical address \n        required to forward an IP packet on the router port for\n        which the entry exists.')
nwIpHostCtlCacheMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostCtlCacheMisses.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostCtlCacheMisses.setDescription('Indicates the number of times the physical address\n        required to forward an IP packet has not been found in\n        the cache on the router port for which the entry exists.')
nwIpHostMapTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1), )
if mibBuilder.loadTexts: nwIpHostMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapTable.setDescription('The Ip Address translation table used for mapping an IP\n         address to physical address, framing, port and circuit\n         identifier, if applicable.')
nwIpHostMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpHostMapIfIndex"), (0, "CTRON-IP-ROUTER-MIB", "nwIpHostMapIpAddr"))
if mibBuilder.loadTexts: nwIpHostMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapEntry.setDescription("Each entry contains one IpAddress to 'physical'\n         address equivalence, including a circuit identifier\n          if applicable. Also provided is the framing and\n         port number required to converse with this host.")
nwIpHostMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostMapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapIfIndex.setDescription('This is the primary (major) index into the HostMap \n              table. This number corresponds to the index into the\n              MIB-2 Interfaces Group which describes the IP router \n              port for which the entry exists.')
nwIpHostMapIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostMapIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapIpAddr.setDescription("The IpAddress corresponding to the media-dependent\n              'physical' address and circuit identifier (if applic).")
nwIpHostMapPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostMapPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapPhysAddr.setDescription("The media-dependent 'physical' address. The value of\n              this object is 0 for entries indicating native-wan(8)\n              framing.")
nwIpHostMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4), ("inactive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostMapType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapType.setDescription('Setting this object to the value invalid(2) has\n             the effect of invalidating the corresponding entry\n             in the nwIpHostMapTable.  That is, it effectively\n             dissasociates the circuit identified with said\n             entry from the mapping identified with said entry.\n             It is an implementation-specific matter as to\n             whether the agent removes an invalidated entry\n             from the table.  Accordingly, management stations\n             must be prepared to receive tabular information\n             from agents that corresponds to entries not\n             currently in use.  Proper interpretation of such\n             entries requires examination of the relevant\n             nwIpHostMapType object.')
nwIpHostMapCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostMapCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapCircuitID.setDescription('The identifier for the virtual circuit present on the \n             interface. On an interface configured for Frame Relay,\n             this number is the DLCI for the IP Address at the end of\n             the circuit. For non-WAN interfaces, the value of this\n             object is zero.')
nwIpHostMapFraming = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5, 7, 8, 9, 11, 14, 16, 17))).clone(namedValues=NamedValues(("other", 1), ("ethernet", 2), ("snap", 3), ("slip", 5), ("localtalk", 7), ("nativewan", 8), ("encapenet", 9), ("encapenetsnap", 11), ("encaptrsnap", 14), ("encapfddisnap", 16), ("canonical", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpHostMapFraming.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapFraming.setDescription('Specifies the framing type required to converse with the\n              host for which this entry exists.')
nwIpHostMapPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 6, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpHostMapPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpHostMapPortNumber.setDescription("The unique value for the logical port number. It's value\n             ranges between 1 and a maximum value which is dependent on\n             both the number of interfaces in the system and the number\n             of circuits present on interfaces which are of WAN type.")
nwIpAclValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpAclValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclValidEntries.setDescription('Indicates the number of valid entries that exist in the\n        access control list table.')
nwIpAclTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2), )
if mibBuilder.loadTexts: nwIpAclTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclTable.setDescription('This table contains the access control list information\n        for IP traffic. This table contains entries, each of which\n        allows packet forwarding between source/destination pairs to\n        be permitted or denied. The list is identified by the Access\n        Control List ID. Each list may contain multiple entries \n        ordered by sequence number. When an access control list is\n        searched, it is searched in sequence number order and the \n        first match found ends the search. If no match is found, \n        access defaults to permitted.')
nwIpAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpAclIdentifier"), (0, "CTRON-IP-ROUTER-MIB", "nwIpAclSequence"))
if mibBuilder.loadTexts: nwIpAclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclEntry.setDescription('Each entry contains IP source/destination access information.')
nwIpAclIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpAclIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclIdentifier.setDescription('This is the primary (major) index into the IP access\n        control list table. This value identifies the access control\n        list by a unique identifier arbitrarily assigned by the user.\n        All entries that have the same value for nwIpAclIdentifier\n        belong to the same access control list.')
nwIpAclSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpAclSequence.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclSequence.setDescription('This is the secondary (minor) index into the IP access\n        control list table. This number corresponds to a sequence\n        number used to order multiple entries within the same access\n        control list.')
nwIpAclPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("permit", 3), ("deny", 4), ("permit-bidirectional", 5), ("deny-bidirectional", 6))).clone('permit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclPermission.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclPermission.setDescription('Specifies whether access is allowed or denied between\n        the source and destination address pair. Note that source\n        and destination are interchangeable when bi-directional\n        control is selected. To remove an existing entry set\n        nwIpAclPermission to invalid (2). Invalid entries disappear\n        after reboot.')
nwIpAclMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpAclMatches.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclMatches.setDescription('Indicates the number of matches on this entry that have\n        resulted in the permit/deny access restriction being \n        applied as part of the forwarding process.')
nwIpAclDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclDestAddress.setDescription('Specifies the destination IP address used to compare\n        for matches on the access control list.')
nwIpAclDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclDestMask.setDescription('Specifies the mask to be applied to the destination address\n        to determine the portion of the address used to compare for\n        matches on the access control list. Only bits that are \n        matching are used in the comparison. This allows for \n        wild-carding and partial matching.')
nwIpAclSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclSrcAddress.setDescription('Specifies the source address used to compare for\n         matches on the access control list.')
nwIpAclSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclSrcMask.setDescription('Specifies the mask to be applied to the source address\n        to determine the portion of the address to be used to compare\n        for matches on the access control list. Only bits that are\n        matching are used in the comparison. This allows for \n        wild-carding and partial matching.')
nwIpAclProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("all", 2), ("icmp", 3), ("udp", 4), ("tcp", 5))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclProtocol.setDescription('Specifies the IP protocols checked to compare for matches\n        on the access control list.')
nwIpAclPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 7, 2, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpAclPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpAclPortNumber.setDescription('Specifies the port number used to compare for matches on\n        the access control list. nwIpAclPortNumber only applies \n        if nwIpAclProtocol is equal to 4 or 5, UDP or TCP\n        nwIpAclPortNumber ranges from 0 to 65536. The value 0 is \n        a wildcard which matches any port.')
nwIpRedirectTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1), )
if mibBuilder.loadTexts: nwIpRedirectTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectTable.setDescription('This table contains an entry for each UDP port configured\n        for UDP broadcast redirection.')
nwIpRedirectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpRedirectPort"))
if mibBuilder.loadTexts: nwIpRedirectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectEntry.setDescription('Each entry contains the UDP port number of and IP Address\n        to which UDP packets received as LAN broadcasts, should be\n        redirected.')
nwIpRedirectPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRedirectPort.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectPort.setDescription('This is the primary index into the UDP redirector table,\n        identifying the UDP port number of the packets that will \n        be redirected.')
nwIpRedirectAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRedirectAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectAddress.setDescription('Sets the IP address to which the UDP broadcast packets\n        matching the UDP redirect port value (nwIpRedirectPort)\n        will be forwarded.')
nwIpRedirectType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("delete", 2))).clone('forward')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpRedirectType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectType.setDescription('Set this object to enable or disable the redirector\n        feature for the UDP port specified by nwIpRedirectAddress.')
nwIpRedirectCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 9, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpRedirectCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpRedirectCount.setDescription('Indicates how many UDP broadcast packets have been\n        redirected, as specified by this entry.')
nwIpEventAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventAdminStatus.setDescription('Sets the administrative state of IP event logging.\n            enabled(3) causes the event log to become active.\n            disabled(2) causes the event log to become inactive.')
nwIpEventMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 1, 2), Integer32().clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventMaxEntries.setDescription('Sets the administrative state of IP event logging.\n            Enabled (3) causes the event log to become active. \n            Disabled (2) causes the event log to become inactive.')
nwIpEventTraceAll = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventTraceAll.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventTraceAll.setDescription('Enabled (3) allows logging of all event types on all\n            router ports for all protocols and components. \n            Disabled (2) causes the filter table to specify which events\n            to log.')
nwIpEventFilterTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1), )
if mibBuilder.loadTexts: nwIpEventFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFilterTable.setDescription('This table contains an entry for each event filter\n            configured for IP Routing Services events.')
nwIpEventFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpEventFltrProtocol"), (0, "CTRON-IP-ROUTER-MIB", "nwIpEventFltrIfNum"))
if mibBuilder.loadTexts: nwIpEventFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFilterEntry.setDescription('Each entry describes an event filter which defines\n            a particular type of event to be logged to the event log.\n            The value of nwIpEventProtocol indicates the value used \n            in either the nwRtgProtocolTable or the nwComponentTable\n            in the Cabletron Routing Services MIB, which identifies\n            the protocol to which the entry exists.')
nwIpEventFltrProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventFltrProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrProtocol.setDescription('Indicates the value of the Cabletron Routing Services\n            MIB nwRtgProtocolInstance or nwComponentRtgInstance\n            which identifies the protocol involved in the event for\n            which the event filter exists.')
nwIpEventFltrIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventFltrIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrIfNum.setDescription('Specifies the router port involved in the event for\n            which the event filter exists.')
nwIpEventFltrControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("delete", 2), ("add", 3))).clone('add')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventFltrControl.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrControl.setDescription('Set this value to 3 to add the entry to the event\n            filter table. Set this value to 2 to remove the entry\n            from the event filter table.')
nwIpEventFltrType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("misc", 1), ("timer", 2), ("rcv", 4), ("xmit", 8), ("event", 16), ("diags", 32), ("error", 64))).clone('error')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventFltrType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrType.setDescription('This 6 bit mask specifies the types of events to\n            be logged. By default all 6 bits are set to 1, \n            indicating that all types of events are to be logged.\n            Setting any bit to 0 removes an event type from this field\n            and prevents that type of event from being logged.Setting\n            any bit to 1 adds an event type to this field and enables\n            that type of event to be logged. ')
nwIpEventFltrSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highest", 1), ("highmed", 2), ("highlow", 3))).clone('highest')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventFltrSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrSeverity.setDescription("Specifies the level of severity an event must meet\n            in order to be logged. Controls the amount of event\n            logging by ignoring events of a lower priority than\n            specified by this filter value. `Highmed' ignores only\n            events of the lowest severity. `Highlow' logs all events\n            highest priority through lowest. `Highest' severity causes\n            all events except those of the highest severity to be\n            ignored. `Highmed' severity is the default setting which\n            causes only events of the lowest severity to be ignored.\n            `Highlow' severity logs all events, regardless of severity.")
nwIpEventFltrAction = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("log", 1), ("trap", 2), ("log-trap", 3))).clone('log')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpEventFltrAction.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventFltrAction.setDescription("Specifies how the events are to be logged. Logging to the\n        `log' stores the events in the event log table\n        (nwIpEventFltrAction). Logging to `trap' sends events out\n        through the trap mechanism.")
nwIpEventTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1), )
if mibBuilder.loadTexts: nwIpEventTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventTable.setDescription('This table contains an entry for each event that has\n            been logged.')
nwIpEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpEventNumber"))
if mibBuilder.loadTexts: nwIpEventEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventEntry.setDescription('Each entry contains the information about an event\n            that has been logged to the event table.')
nwIpEventNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventNumber.setDescription('An ordinal value assigned to the event for which the\n            log entry exists. nwIpEventNumber is assigned so that\n            each event in the event log can be uniquely identified\n            by the value of nwIpEventNumber.')
nwIpEventTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventTime.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventTime.setDescription('Indicates the time at which the event was logged to\n            the event log.')
nwIpEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("misc", 1), ("timer", 2), ("rcv", 4), ("xmit", 8), ("event", 16), ("diags", 32), ("error", 64)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventType.setDescription('Indicates the type of event that was logged.')
nwIpEventSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("highest", 1), ("highmed", 2), ("highlow", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventSeverity.setDescription('Indicates the severity that was assigned to the event.')
nwIpEventProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventProtocol.setDescription('Indicates the value of the Cabletron Routing Services\n            MIB nwRtgProtocolInstance or nwComponentInstance which\n            indentifies the protocol or component that was involved\n            in the event.')
nwIpEventIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventIfNum.setDescription('Indicates the router port that was involved in the event.')
nwIpEventTextString = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 10, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpEventTextString.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpEventTextString.setDescription('Contains the actual text string that was logged.')
nwIpWgDefTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1), )
if mibBuilder.loadTexts: nwIpWgDefTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefTable.setDescription('This table has an entry for each workgroup subnet definition.\n                It is indexed by and arbitrary integer indentifier.')
nwIpWgDefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpWgDefIdentifier"))
if mibBuilder.loadTexts: nwIpWgDefEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefEntry.setDescription('Each entry specifies the configuration and status of an\n                individual work group.')
nwIpWgDefIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgDefIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefIdentifier.setDescription('An index into the definition table, unique to each entry,\n                arbitrarily assigned by the user.')
nwIpWgDefHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgDefHostAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefHostAddress.setDescription('The IP address of the IP router host which applies to every  \n                interface included in the workgroup.')
nwIpWgDefSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgDefSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefSubnetMask.setDescription('The subnet mask for the IP address above, thereby defining\n                the subnet which applies to every interface included in the\n                workgroup.')
nwIpWgDefSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("low", 2), ("medium", 3), ("high", 4))).clone('low')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgDefSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefSecurity.setDescription('A security level which applies to this workgroup as a whole.\n                Security applies in conjunction with the range table below,\n                which locks hosts to interfaces and/or physical address.\n                Packets are filtered out if security is violated.\n\n                For a high (4) security workgroup, a host must reside on the \n                interface and with the physical address configured in a range\n                table entry. For medium (3) security a host must reside on a \n                configured interface, but unless a physical address is also\n                specified in that range entry, the physical address is not\n                constrained.  For low (2) security a host is free to reside \n                on any interface with any physical address if not configured \n                in the range table, but if configured must match a configured\n                entry.  If security is none (1) the range table does not apply.')
nwIpWgDefFastPath = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgDefFastPath.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefFastPath.setDescription('Enabled (3) provides a fast path for packets through the\n                router when both source and destination are within this\n                workgroup - done mostly by skipping IP header validation.')
nwIpWgDefRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))).clone('notReady')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgDefRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefRowStatus.setDescription("This status instance does not support `createAndGo.'\n                A row entry should be created by a set of `createAndWait'\n                which brings the status to `notReady.' The missing row info\n                may then be supplied by setting nwIpWgDefHostAddr and\n                nwIpWgDefSubnetMask. If defaults are OK for nwIpWgDefFastPath\n                and nwIpWgDefSecurity this status instance may then be set to\n                `active' to activate the row.")
nwIpWgDefOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("disabled", 2), ("subnetConflict", 3), ("internalError", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgDefOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefOperStatus.setDescription("The operational status of this workgroup definition entry.\n                It will be `disabled' if this entry's row status is not active.\n                It will be `subnetConflict' if there is a conflict with an\n                existing active entry in this workgroup definition table.")
nwIpWgDefNumActiveIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgDefNumActiveIntf.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefNumActiveIntf.setDescription("The number of interfaces (ports) in this workgroup which\n                have an operational status nwIpWgIfOperStatus of `OK' in the\n                IP Work Group Interface table below.")
nwIpWgDefNumTotalIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgDefNumTotalIntf.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgDefNumTotalIntf.setDescription("The number of interfaces (ports) in this workgroup which\n                have an administrative status nwIpWgIfRowStatus of `active'\n                in the IP Work Group Interface table below.")
nwIpWgIfTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2), )
if mibBuilder.loadTexts: nwIpWgIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfTable.setDescription('This table contains an entry for each port in a workgroup.\n                It is indexed by the workgroup identifier and the MIB-II \n                interface indentifier.')
nwIpWgIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpWgIfDefIdent"), (0, "CTRON-IP-ROUTER-MIB", "nwIpWgIfIfIndex"))
if mibBuilder.loadTexts: nwIpWgIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfEntry.setDescription('Each entry specifies the association of a router port to\n                 a defined workgroup.')
nwIpWgIfDefIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgIfDefIdent.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfDefIdent.setDescription('The workgroup identifier.  This is the primary index into\n                the IP Work Group Interface Table, matching the index into\n                the Definition Table above.')
nwIpWgIfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgIfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfIfIndex.setDescription('The interface number.  This is the secondary index into the\n                IP Work Group Interface Table, matching the primary index\n                into the MIB-2 IfTable which describes the router port.')
nwIpWgIfNumActiveHosts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgIfNumActiveHosts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfNumActiveHosts.setDescription('The number of hosts known to be active on this interface in\n                 this workgroup. These hosts are visible in the IP Work Group\n                 Host Table below. Hosts age out and become inactive in\n                 approximately 10 minutes if not rediscovered thrugh ARP.')
nwIpWgIfNumKnownHosts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgIfNumKnownHosts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfNumKnownHosts.setDescription('The number of hosts seen on this interface in this workgroup\n                since this interface entry was last activated.')
nwIpWgIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))).clone('notInService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfRowStatus.setDescription("This status instance supports `createAndGo' semantics\n                to create an active entry.")
nwIpWgIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ok", 1), ("disabled", 2), ("workgroupInvalid", 3), ("addressConflict", 4), ("resetRequired", 5), ("linkDown", 6), ("routingDown", 7), ("internalError", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgIfOperStatus.setDescription("The operational status of this interface (port) entry. \n                It will be `disabled' if this entry's row status is not active.\n                It will be `workgroupInvalid' if either there is no workgroup\n                defined for this entry's nwIpWgIfDefIdent or if the operational\n                status for the workgroup in the definition table is not ok.\n                It will be `addressConflict' if an entry in nwIpAddressTable\n                is a conflict with the workgroup address of the definition.\n                If there is no conflict and this entry's row status has just\n                been activated, this operational status will be `resetRequired'.\n                It will be `linkDown' if there are no physical connections on\n                this interface and `routingDown' if routing or forwarding has\n                been adminstratively disabled. If unspecified internal problems\n                occur the status will be `internalError'.")
nwIpWgRngTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3), )
if mibBuilder.loadTexts: nwIpWgRngTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngTable.setDescription('This table locks ranges of IP hosts (addresses) to ports.\n                Entries in this table represent explicit permissions. The\n                host(s) represented by a range entry may exchange packets\n                with this router if it (they) match the port specified in the\n                entry. Optionally physical address may be locked as well.\n\n                This table functions in concert with the workgroup security\n                level as defined in the IP Work Group Definition Table entry.\n                For hosts not entered in this table the default for a low\n                security workgroup is to permit packet exchange, whereas the\n                default for medium and high security is to deny packet\n                exchange.')
nwIpWgRngEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpWgRngBegHostAddr"), (0, "CTRON-IP-ROUTER-MIB", "nwIpWgRngEndHostAddr"), (0, "CTRON-IP-ROUTER-MIB", "nwIpWgRngIfIndex"))
if mibBuilder.loadTexts: nwIpWgRngEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngEntry.setDescription('Each entry configures a range of host IP addresses to be\n                associated with a given interface ( port ). If the range\n                consists of a single host address the entry may optionally\n                specify a physical address. The entry is indexed by the range\n                and the port. Ranges may not overlap. However a range may be\n                duplicated on different ports.\n\n                The address range must lie within the subnet defined for a\n                given workgroup and thus the entry acquires the security\n                level of that workgroup. If security is violated, packets\n                to and from a given host IP address will be filtered out\n                passing through the router. The source and destination IP\n                packet addresses are checked against ranges in the range table\n                during packet forwarding and must match as follows:\n\n                For a high (4) security workgroup, a host must match a single\n                host range entry - it must reside on the port with the\n                physical address as configured in that entry.\n\n                For a medium (3) security workgroup, a host must match a range\n                entry in that it resides on that port, but unless a physical\n                address is also specified in that entry, the physical address\n                is not constrained.\n\n                For a low (2) security workgroup, a host is free to reside on\n                any port with any physical address as long as its IP address\n                does not lie within the range of any entry in the range table,\n                but if it does fall in a range then it must completely match\n                that entry, or another entry with the duplicate range. Match\n                completely means match the port and, if a physical address\n                is specified, match that as well.')
nwIpWgRngBegHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgRngBegHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngBegHostAddr.setDescription('The beginning (lower) IP address of the address range.\n                This is the primary index into the IP Work Group Range Table.')
nwIpWgRngEndHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgRngEndHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngEndHostAddr.setDescription('The ending (higher) IP address of the address range.\n                This is the secondary index of the IP Work Group Range Table.')
nwIpWgRngIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgRngIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngIfIndex.setDescription('The interface number.  This is the tertiary index into the\n                IP Work Group Interface Table, matching the primary index\n                into the MIB-2 IfTable which describes the router port.')
nwIpWgRngPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 4), OctetString().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgRngPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngPhysAddr.setDescription('The physical address of the host with the IP address given\n                in the nwIpWgRngBegHostAddr for this conceptual row entry.\n                Only single host range entry in which nwIpWgRngEndHostAddr is\n                the same as nwIpWgRngBegHostAddr may set a physical address.')
nwIpWgRngRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6))).clone('notInService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwIpWgRngRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngRowStatus.setDescription("This status instance supports `createAndGo' semantics\n                to create an active entry.")
nwIpWgRngOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("disabled", 2), ("workgroupInvalid", 3), ("interfaceInvalid", 4), ("physAddrRequired", 5), ("internalError", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgRngOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgRngOperStatus.setDescription("The operational status of this range table entry. \n                It will be `disabled' if this entry's row status is not active.\n                It will be `workgroupInvalid' if either there is no workgroup\n                or if the operational status for the workgroup in the definition\n                table associated with this address range is not ok.\n                It will be `interfaceInvalid' if this interface is not in\n                the workgroup interface table or if operational status of the\n                interface entry is not ok.  It will be `physAddrRequired' if\n                the security level of the associated workgroup is high and\n                no physical address has been specified for this entry.")
nwIpWgHostTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4), )
if mibBuilder.loadTexts: nwIpWgHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostTable.setDescription('A read only status table for hosts in workgroups.\n                It has the information similar to a net-to-media table.')
nwIpWgHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1), ).setIndexNames((0, "CTRON-IP-ROUTER-MIB", "nwIpWgHostHostAddr"), (0, "CTRON-IP-ROUTER-MIB", "nwIpWgHostIfIndex"))
if mibBuilder.loadTexts: nwIpWgHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostEntry.setDescription('Each entry shows a workgroup host. Entry is indexed by\n                IP address and interface (port).  It gives the workgroup \n                and the physical address found for the host.')
nwIpWgHostHostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgHostHostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostHostAddr.setDescription('The host IP address. This is the primary index to the\n                IP Work Group Host Table.')
nwIpWgHostIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgHostIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostIfIndex.setDescription('The interface (port) number. This is the secondary index\n                to the IP Work Group Host Table, matching the primary index\n                to the MIB-2 IfTable which describes the router port.')
nwIpWgHostDefIdent = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgHostDefIdent.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostDefIdent.setDescription('The workgroup identifier.  This corresponds to the primary\n                index into the IP Work Group Interface Table.')
nwIpWgHostPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgHostPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostPhysAddr.setDescription('The physical address of the host with the IP address given\n                in the nwIpWgHostHostAddr for this conceptual row entry.')
nwIpWgHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 2, 2, 2, 3, 1, 2, 11, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("valid", 3), ("invalid-multiple", 4), ("invalid-physaddr", 5), ("invalid-range", 6), ("invalid-interface", 7), ("invalid-workgroup", 8), ("invalid-expired", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIpWgHostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwIpWgHostStatus.setDescription("This status of the host with respect to the workgroup.\n\n                The host may be `unknown' if ARP has not discovered on which\n                port it resides.\n\n                The status of `invalid-multiple' means the same host\n                IP address was later found duplicated on another port.\n\n                The status of `invalid-physaddr' means the host matched an\n                entry in the IP Work Group Range Table with respect to range\n                and port, but did not match that entry for physical address.\n                If the workgroup was high security this status would result\n                even if no physical address was given in the range entry.\n\n                The status of `invalid-range' could either mean that, in a high\n                or medium security workgroup, the host was not in the range of\n                any entry in the IP WORK GROUP Range Table, or that it was not\n                in the range of an entry with a matching port.\n\n                The status of `invalid-interface' could mean the port was\n                physically down or just not in service in the IP Work Group\n                Interface Table.\n\n                The status of `invalid-workgroup' could mean the workgroup\n                does not exist or is not in service in the IP Work Group\n                Definition Table.\n\n                The status of `invalid-expired' means the host became inactive\n                and aged out on the port on which it was learned.")
mibBuilder.exportSymbols("CTRON-IP-ROUTER-MIB", nwIpOspfRipTable=nwIpOspfRipTable, nwIpFwdIfIndex=nwIpFwdIfIndex, nwIpOspfCtrFilteredPkts=nwIpOspfCtrFilteredPkts, nwIpOspfOperStatus=nwIpOspfOperStatus, nwIpOspfStackSize=nwIpOspfStackSize, nwIpAddrIfAddrType=nwIpAddrIfAddrType, nwIpFwdSystem=nwIpFwdSystem, nwIpSysAdminStatus=nwIpSysAdminStatus, nwIpRipIfCtrDiscardBytes=nwIpRipIfCtrDiscardBytes, nwIpAddressTable=nwIpAddressTable, nwIpAclPortNumber=nwIpAclPortNumber, nwIpOspfIfTable=nwIpOspfIfTable, nwIpHostCtlNumStatics=nwIpHostCtlNumStatics, nwIpAclPermission=nwIpAclPermission, nwIpEventFltrControl=nwIpEventFltrControl, nwIpOspfIfCtrOutBytes=nwIpOspfIfCtrOutBytes, nwIpFwdIfForwarding=nwIpFwdIfForwarding, nwIpFwdIfCacheMisses=nwIpFwdIfCacheMisses, nwIpWgIfIfIndex=nwIpWgIfIfIndex, nwIpFwdIfAclIdentifier=nwIpFwdIfAclIdentifier, nwIpWgRngRowStatus=nwIpWgRngRowStatus, nwIpRipRtAge=nwIpRipRtAge, nwIpFwdInterfaces=nwIpFwdInterfaces, nwIpOspfIfCtrInPkts=nwIpOspfIfCtrInPkts, nwIpHostMapIfIndex=nwIpHostMapIfIndex, nwIpFwdCtrHostOutBytes=nwIpFwdCtrHostOutBytes, nwIpWgDefIdentifier=nwIpWgDefIdentifier, nwIpOspfIfOperationalTime=nwIpOspfIfOperationalTime, nwIpOspfCtrOutPkts=nwIpOspfCtrOutPkts, nwIpOspfLeakAllBgp4Routes=nwIpOspfLeakAllBgp4Routes, nwIpRipIfCtrFilteredBytes=nwIpRipIfCtrFilteredBytes, nwIpRipRtMask=nwIpRipRtMask, nwIpWgHostDefIdent=nwIpWgHostDefIdent, nwIpRipIfCounters=nwIpRipIfCounters, nwIpWgHostHostAddr=nwIpWgHostHostAddr, nwIpWgRngTable=nwIpWgRngTable, nwIpWgRngOperStatus=nwIpWgRngOperStatus, nwIpFwdCtrOutPkts=nwIpFwdCtrOutPkts, nwIpRipCounters=nwIpRipCounters, nwIpRipConfig=nwIpRipConfig, nwIpFwdCtrInBytes=nwIpFwdCtrInBytes, nwIpRipOperStatus=nwIpRipOperStatus, nwIpRipCtrInBytes=nwIpRipCtrInBytes, nwIpAddrIfMask=nwIpAddrIfMask, nwIpRipIfXmitCost=nwIpRipIfXmitCost, nwIpEventAdminStatus=nwIpEventAdminStatus, nwIpFwdIfFrameType=nwIpFwdIfFrameType, nwIpHostCtlNumDynamics=nwIpHostCtlNumDynamics, nwIpWgDefOperStatus=nwIpWgDefOperStatus, nwIpAddrIfBcastAddr=nwIpAddrIfBcastAddr, nwIpRipIfCtrDiscardPkts=nwIpRipIfCtrDiscardPkts, nwIpWgHostPhysAddr=nwIpWgHostPhysAddr, nwIpWgHostIfIndex=nwIpWgHostIfIndex, nwIpFwdIfOperStatus=nwIpFwdIfOperStatus, nwIpRipIfCtrOutPkts=nwIpRipIfCtrOutPkts, nwIpFwdIfCtrHostDiscardBytes=nwIpFwdIfCtrHostDiscardBytes, nwIpOspfIfCtrFilteredPkts=nwIpOspfIfCtrFilteredPkts, nwIpRedirectTable=nwIpRedirectTable, nwIpRedirectType=nwIpRedirectType, nwIpOspfLeakAllRipRoutes=nwIpOspfLeakAllRipRoutes, nwIpOspfStaticMetricType=nwIpOspfStaticMetricType, nwIpEventFltrAction=nwIpEventFltrAction, nwIpEventLogFilterTable=nwIpEventLogFilterTable, nwIpOspfIfCtrEntry=nwIpOspfIfCtrEntry, nwIpWgDefHostAddress=nwIpWgDefHostAddress, nwIpFwdIfCtrFilteredBytes=nwIpFwdIfCtrFilteredBytes, nwIpRipCtrOutBytes=nwIpRipCtrOutBytes, nwIpRipIfCtrAdminStatus=nwIpRipIfCtrAdminStatus, nwIpOspfInterfaces=nwIpOspfInterfaces, nwIpOspfCtrInBytes=nwIpOspfCtrInBytes, nwIpRedirector=nwIpRedirector, nwIpFwdIfCtrEntry=nwIpFwdIfCtrEntry, nwIpEventTable=nwIpEventTable, nwIpOspfStaticEntry=nwIpOspfStaticEntry, nwIpOspfIfEntry=nwIpOspfIfEntry, nwIpFwdCtrInPkts=nwIpFwdCtrInPkts, nwIpRouter=nwIpRouter, nwIpFwdCtrDiscardBytes=nwIpFwdCtrDiscardBytes, nwIpEventFltrProtocol=nwIpEventFltrProtocol, nwIpOspfFilters=nwIpOspfFilters, nwIpFwdCtrDiscardPkts=nwIpFwdCtrDiscardPkts, nwIpFwdIfCtrFwdBytes=nwIpFwdIfCtrFwdBytes, nwIpFwdCtrHostInBytes=nwIpFwdCtrHostInBytes, nwIpFwdCtrFilteredBytes=nwIpFwdCtrFilteredBytes, nwIpOspfIfType=nwIpOspfIfType, nwIpEventNumber=nwIpEventNumber, nwIpFwdIfCtrOutBytes=nwIpFwdIfCtrOutBytes, nwIpFwdCtrFwdBytes=nwIpFwdCtrFwdBytes, nwIpRipCtrFilteredBytes=nwIpRipCtrFilteredBytes, nwIpRipIfAclStatus=nwIpRipIfAclStatus, nwIpWgDefEntry=nwIpWgDefEntry, nwIpRipIfAdminStatus=nwIpRipIfAdminStatus, nwIpFwdIfCtrDiscardBytes=nwIpFwdIfCtrDiscardBytes, nwIpSysConfig=nwIpSysConfig, nwIpOspfIfSnooping=nwIpOspfIfSnooping, nwIpFwdIfMtu=nwIpFwdIfMtu, nwIpFwdCtrFwdPkts=nwIpFwdCtrFwdPkts, nwIpOspfIfCtrOperationalTime=nwIpOspfIfCtrOperationalTime, nwIpOspfBgp4Table=nwIpOspfBgp4Table, nwIpOspfDynamicTable=nwIpOspfDynamicTable, nwIpEventFilterTable=nwIpEventFilterTable, nwIpOspfForward=nwIpOspfForward, nwIpRipIfCtrInPkts=nwIpRipIfCtrInPkts, nwIpRipRouteTable=nwIpRipRouteTable, nwIpRipIfTable=nwIpRipIfTable, nwIpOSPFRoutePriority=nwIpOSPFRoutePriority, nwIpAddrIfIndex=nwIpAddrIfIndex, nwIpEventTraceAll=nwIpEventTraceAll, nwIpOspfStaticDest=nwIpOspfStaticDest, nwIpOspfIfIndex=nwIpOspfIfIndex, nwIpRipStackSize=nwIpRipStackSize, nwIpFwdIfCtrHostOutBytes=nwIpFwdIfCtrHostOutBytes, nwIpOspfOperationalTime=nwIpOspfOperationalTime, nwIpOspfThreadPriority=nwIpOspfThreadPriority, nwIpWgIfRowStatus=nwIpWgIfRowStatus, nwIpOspfIfCtrFilteredBytes=nwIpOspfIfCtrFilteredBytes, nwIpFwdCtrHdrErrPkts=nwIpFwdCtrHdrErrPkts, nwIpDistanceVector=nwIpDistanceVector, nwIpSysAdminReset=nwIpSysAdminReset, nwIpRipRtType=nwIpRipRtType, nwIpHostMapTable=nwIpHostMapTable, nwIpRipCtrOperationalTime=nwIpRipCtrOperationalTime, nwIpEventType=nwIpEventType, nwIpFwdIfControl=nwIpFwdIfControl, nwIpFwdIfAclStatus=nwIpFwdIfAclStatus, nwIpHostsInterfaces=nwIpHostsInterfaces, nwIpRipHoldDown=nwIpRipHoldDown, nwIpFwdCtrHostDiscardBytes=nwIpFwdCtrHostDiscardBytes, nwIpRipIfCtrTable=nwIpRipIfCtrTable, nwIpWgHostStatus=nwIpWgHostStatus, nwIpOspfCtrDiscardBytes=nwIpOspfCtrDiscardBytes, nwIpHostCtlCacheMisses=nwIpHostCtlCacheMisses, nwIpRedirectEntry=nwIpRedirectEntry, nwIpHostCtlTable=nwIpHostCtlTable, nwIpEventProtocol=nwIpEventProtocol, nwIpSysVersion=nwIpSysVersion, nwIpAclDestAddress=nwIpAclDestAddress, nwIpOspfIfCtrOutPkts=nwIpOspfIfCtrOutPkts, nwIpWgDefSecurity=nwIpWgDefSecurity, nwIpRipIfSplitHorizon=nwIpRipIfSplitHorizon, nwIpHostsTimeToLive=nwIpHostsTimeToLive, nwIpRipAdminStatus=nwIpRipAdminStatus, nwIpFwdCtrHostDiscardPkts=nwIpFwdCtrHostDiscardPkts, nwIpRipIfSnooping=nwIpRipIfSnooping, nwIpWgRngIfIndex=nwIpWgRngIfIndex, nwIpOspfStaticMetric=nwIpOspfStaticMetric, nwIpWgRngBegHostAddr=nwIpWgRngBegHostAddr, nwIpOspfStaticNextHop=nwIpOspfStaticNextHop, nwIpOspfConfig=nwIpOspfConfig, nwIpRipIfCtrIfIndex=nwIpRipIfCtrIfIndex, nwIpRipIfPriority=nwIpRipIfPriority, nwIpOspfIfCounters=nwIpOspfIfCounters, nwIpOspfStaticTable=nwIpOspfStaticTable, nwIpFwdCtrAdminStatus=nwIpFwdCtrAdminStatus, nwIpTopology=nwIpTopology, nwIpAclValidEntries=nwIpAclValidEntries, nwIpForwarding=nwIpForwarding, nwIpRipCtrAdminStatus=nwIpRipCtrAdminStatus, nwIpOspfCtrInPkts=nwIpOspfCtrInPkts, nwIpOspfDatabase=nwIpOspfDatabase, nwIpRipIfFloodDelay=nwIpRipIfFloodDelay, nwIpAclDestMask=nwIpAclDestMask, nwIpEvent=nwIpEvent, nwIpHostCtlOperStatus=nwIpHostCtlOperStatus, nwIpAclProtocol=nwIpAclProtocol, nwIpOspfLeakAllStaticRoutes=nwIpOspfLeakAllStaticRoutes, nwIpFwdIfCtrAdminStatus=nwIpFwdIfCtrAdminStatus, nwIpHostCtlCacheHits=nwIpHostCtlCacheHits, nwIpHostCtlProtocol=nwIpHostCtlProtocol, nwIpEventFilterEntry=nwIpEventFilterEntry, nwIpFwdIfCounters=nwIpFwdIfCounters, nwIpAddrIfAddress=nwIpAddrIfAddress, nwIpEventEntry=nwIpEventEntry, nwIpOspfCtrAdminStatus=nwIpOspfCtrAdminStatus, nwIpRedirectCount=nwIpRedirectCount, nwIpFwdIfOperationalTime=nwIpFwdIfOperationalTime, nwIpEventTime=nwIpEventTime, nwIpRedirectPort=nwIpRedirectPort, nwIpWgDefSubnetMask=nwIpWgDefSubnetMask, nwIpEventFltrType=nwIpEventFltrType, nwIpWgDefTable=nwIpWgDefTable, nwIpRipIfEntry=nwIpRipIfEntry, nwIpEventTextString=nwIpEventTextString, nwIpRipIfPoisonReverse=nwIpRipIfPoisonReverse, nwIpFwdIfCtrInBytes=nwIpFwdIfCtrInBytes, nwIpOspfIfCtrReset=nwIpOspfIfCtrReset, nwIpWorkGroup=nwIpWorkGroup, nwIpWgIfDefIdent=nwIpWgIfDefIdent, nwIpRipDatabase=nwIpRipDatabase, nwIpWgRngPhysAddr=nwIpWgRngPhysAddr, nwIpRipDatabaseThreshold=nwIpRipDatabaseThreshold, nwIpRipIfCtrOperationalTime=nwIpRipIfCtrOperationalTime, nwIpAccessControl=nwIpAccessControl, nwIpFwdCtrHostInPkts=nwIpFwdCtrHostInPkts, nwIpFwdIfEntry=nwIpFwdIfEntry, nwIpHostMapPhysAddr=nwIpHostMapPhysAddr, nwIpEventLogConfig=nwIpEventLogConfig, nwIpRipIfHelloTimer=nwIpRipIfHelloTimer, nwIpRipIfCtrReset=nwIpRipIfCtrReset, nwIpHostCtlProxy=nwIpHostCtlProxy, nwIpRedirectAddress=nwIpRedirectAddress, nwIpFwdIfCtrDiscardPkts=nwIpFwdIfCtrDiscardPkts, nwIpRipIfCtrEntry=nwIpRipIfCtrEntry, nwIpOspfIfVersion=nwIpOspfIfVersion, nwIpHostsRetryCount=nwIpHostsRetryCount, nwIpFwdIfTable=nwIpFwdIfTable, nwIpFwdCtrOperationalTime=nwIpFwdCtrOperationalTime, nwIpOspfIfCtrInBytes=nwIpOspfIfCtrInBytes, nwIpHostMapFraming=nwIpHostMapFraming, nwIpOspfCounters=nwIpOspfCounters, nwIpOspfCtrReset=nwIpOspfCtrReset, nwIpAclMatches=nwIpAclMatches, nwIpRipCtrDiscardPkts=nwIpRipCtrDiscardPkts, nwIpRipIfVersion=nwIpRipIfVersion, nwIpWgDefFastPath=nwIpWgDefFastPath, nwIpOspfVersion=nwIpOspfVersion, nwIpOspfAdminReset=nwIpOspfAdminReset, nwIpRipCtrFilteredPkts=nwIpRipCtrFilteredPkts, nwIpOspfFibControl=nwIpOspfFibControl, nwIpEventFltrIfNum=nwIpEventFltrIfNum, nwIpClientServices=nwIpClientServices, nwIpRipAdminReset=nwIpRipAdminReset, nwIpHostMapPortNumber=nwIpHostMapPortNumber, nwIpFwdIfCtrHostInBytes=nwIpFwdIfCtrHostInBytes, nwIpRipRtFlags=nwIpRipRtFlags, nwIpOspfIfConfig=nwIpOspfIfConfig, nwIpOspfStaticStatus=nwIpOspfStaticStatus, nwIpRip=nwIpRip, nwIpHostCtlAdminStatus=nwIpHostCtlAdminStatus, nwIpAclEntry=nwIpAclEntry, nwIpWgDefRowStatus=nwIpWgDefRowStatus, nwIpFwdIfCtrOutPkts=nwIpFwdIfCtrOutPkts, nwIpHostCtlIfIndex=nwIpHostCtlIfIndex, nwIpHostMapEntry=nwIpHostMapEntry, nwIpFwdIfCtrFilteredPkts=nwIpFwdIfCtrFilteredPkts, nwIpFwdIfCacheEntries=nwIpFwdIfCacheEntries, nwIpOspfIfCtrDiscardPkts=nwIpOspfIfCtrDiscardPkts, nwIpOspfCtrFilteredBytes=nwIpOspfCtrFilteredBytes, nwIpOspfFibEntries=nwIpOspfFibEntries, nwIpFibSystem=nwIpFibSystem, nwIpRipIfAclIdentifier=nwIpRipIfAclIdentifier, nwIpFwdIfCtrHdrErrPkts=nwIpFwdIfCtrHdrErrPkts, nwIpOspfIfCtrTable=nwIpOspfIfCtrTable, nwIpMibs=nwIpMibs, nwIpFwdCtrReset=nwIpFwdCtrReset, nwIpSysRouterId=nwIpSysRouterId, nwIpHostMapType=nwIpHostMapType, nwIpRipRtIfIndex=nwIpRipRtIfIndex, nwIpRipRoutePriority=nwIpRipRoutePriority, nwIpFwdIfCtrHostOutPkts=nwIpFwdIfCtrHostOutPkts, nwIpFwdCtrOutBytes=nwIpFwdCtrOutBytes, nwIpOspfIfCtrAdminStatus=nwIpOspfIfCtrAdminStatus, nwIpRipRtNetId=nwIpRipRtNetId, nwIpRipOperationalTime=nwIpRipOperationalTime)
mibBuilder.exportSymbols("CTRON-IP-ROUTER-MIB", nwIpFwdCtrAddrErrPkts=nwIpFwdCtrAddrErrPkts, nwIpFwdIfCacheControl=nwIpFwdIfCacheControl, nwIpWgIfNumKnownHosts=nwIpWgIfNumKnownHosts, nwIpFwdIfCtrAddrErrPkts=nwIpFwdIfCtrAddrErrPkts, nwIpRipIfCtrInBytes=nwIpRipIfCtrInBytes, nwIpOspfCtrDiscardPkts=nwIpOspfCtrDiscardPkts, nwIpEventLogTable=nwIpEventLogTable, nwIpFwdIfCtrReset=nwIpFwdIfCtrReset, nwIpHostMapCircuitID=nwIpHostMapCircuitID, nwIpFilters=nwIpFilters, nwIpFib=nwIpFib, nwIpOspfIfCtrDiscardBytes=nwIpOspfIfCtrDiscardBytes, nwIpFwdCtrHostOutPkts=nwIpFwdCtrHostOutPkts, nwIpRipIfRequestDelay=nwIpRipIfRequestDelay, nwIpMibRevText=nwIpMibRevText, nwIpRipIfOperationalTime=nwIpRipIfOperationalTime, nwIpHostCtlOperationalTime=nwIpHostCtlOperationalTime, nwIpComponents=nwIpComponents, nwIpRipIfConfig=nwIpRipIfConfig, nwIpEventMaxEntries=nwIpEventMaxEntries, nwIpAclSequence=nwIpAclSequence, nwIpRipIfIndex=nwIpRipIfIndex, nwIpRipInterfaces=nwIpRipInterfaces, nwIpWgIfOperStatus=nwIpWgIfOperStatus, nwIpOspfFib=nwIpOspfFib, nwIpFwdIfAdminStatus=nwIpFwdIfAdminStatus, nwIpOspfAdminStatus=nwIpOspfAdminStatus, nwIpOspfIfAclStatus=nwIpOspfIfAclStatus, nwIpOspfSystem=nwIpOspfSystem, nwIpRipRtSrcNode=nwIpRipRtSrcNode, nwIpFwdCtrFilteredPkts=nwIpFwdCtrFilteredPkts, nwIpFwdIfCtrHostInPkts=nwIpFwdIfCtrHostInPkts, nwIpFwdIfCtrLenErrPkts=nwIpFwdIfCtrLenErrPkts, nwIpAclSrcAddress=nwIpAclSrcAddress, nwIpAclTable=nwIpAclTable, nwIpEventIfNum=nwIpEventIfNum, nwIpFwdCtrLenErrPkts=nwIpFwdCtrLenErrPkts, nwIpFwdIfCtrFwdPkts=nwIpFwdIfCtrFwdPkts, nwIpRipSystem=nwIpRipSystem, nwIpEndSystems=nwIpEndSystems, nwIpWgRngEntry=nwIpWgRngEntry, nwIpRipRouteEntry=nwIpRipRouteEntry, nwIpWgRngEndHostAddr=nwIpWgRngEndHostAddr, nwIpRipIfCtrFilteredPkts=nwIpRipIfCtrFilteredPkts, nwIpRedirectorInterface=nwIpRedirectorInterface, nwIpRipCtrReset=nwIpRipCtrReset, nwIpStaticRoutePriority=nwIpStaticRoutePriority, nwIpRedirectorSystem=nwIpRedirectorSystem, nwIpHostCtlEntry=nwIpHostCtlEntry, nwIpEventSeverity=nwIpEventSeverity, nwIpRipAgeOut=nwIpRipAgeOut, nwIpOspfStaticForwardMask=nwIpOspfStaticForwardMask, nwIpRipIfOperStatus=nwIpRipIfOperStatus, nwIpOspfCtrOperationalTime=nwIpOspfCtrOperationalTime, nwIpAclIdentifier=nwIpAclIdentifier, nwIpHostCtlCacheMax=nwIpHostCtlCacheMax, nwIpWgHostEntry=nwIpWgHostEntry, nwIpFwdIfCacheHits=nwIpFwdIfCacheHits, nwIpWgIfNumActiveHosts=nwIpWgIfNumActiveHosts, nwIpSysOperationalTime=nwIpSysOperationalTime, nwIpAclSrcMask=nwIpAclSrcMask, nwIpHostCtlSnooping=nwIpHostCtlSnooping, nwIpRipCtrDiscardBytes=nwIpRipCtrDiscardBytes, nwIpFwdIfCtrHostDiscardPkts=nwIpFwdIfCtrHostDiscardPkts, nwIpFwdIfCtrIfIndex=nwIpFwdIfCtrIfIndex, nwIpOspf=nwIpOspf, nwIpRipCtrOutPkts=nwIpRipCtrOutPkts, nwIpSystem=nwIpSystem, nwIpEventFltrSeverity=nwIpEventFltrSeverity, nwIpRipVersion=nwIpRipVersion, nwIpRipRtHops=nwIpRipRtHops, nwIpWgHostTable=nwIpWgHostTable, nwIpAddrEntry=nwIpAddrEntry, nwIpHostsToMedia=nwIpHostsToMedia, nwIpAddrIfControl=nwIpAddrIfControl, nwIpOspfIfOperStatus=nwIpOspfIfOperStatus, nwIpRipCtrInPkts=nwIpRipCtrInPkts, nwIpFwdIfCtrOperationalTime=nwIpFwdIfCtrOperationalTime, nwIpOspfCtrOutBytes=nwIpOspfCtrOutBytes, nwIpSysOperStatus=nwIpSysOperStatus, nwIpOspfIfCtrIfIndex=nwIpOspfIfCtrIfIndex, nwIpWgDefNumTotalIntf=nwIpWgDefNumTotalIntf, nwIpFwdCounters=nwIpFwdCounters, nwIpHostsSystem=nwIpHostsSystem, nwIpSysAdministration=nwIpSysAdministration, nwIpRipIfType=nwIpRipIfType, nwIpHostCtlCacheSize=nwIpHostCtlCacheSize, nwIpFwdIfCtrInPkts=nwIpFwdIfCtrInPkts, nwIpFwdIfCtrTable=nwIpFwdIfCtrTable, nwIpRipThreadPriority=nwIpRipThreadPriority, nwIpWgDefNumActiveIntf=nwIpWgDefNumActiveIntf, nwIpLinkState=nwIpLinkState, nwIpWgIfTable=nwIpWgIfTable, nwIpWgIfEntry=nwIpWgIfEntry, nwIpHostMapIpAddr=nwIpHostMapIpAddr, nwIpOspfIfAclIdentifier=nwIpOspfIfAclIdentifier, nwIpOspfIfAdminStatus=nwIpOspfIfAdminStatus, nwIpRipFilters=nwIpRipFilters, nwIpRipIfAdvertisement=nwIpRipIfAdvertisement, nwIpRipIfCtrOutBytes=nwIpRipIfCtrOutBytes, nwIpFwdIfConfig=nwIpFwdIfConfig)
