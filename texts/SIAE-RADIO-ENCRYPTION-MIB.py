#
# PySNMP MIB module SIAE-RADIO-ENCRYPTION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/siae/SIAE-RADIO-ENCRYPTION-MIB
# Produced by pysmi-1.1.12 at Tue Sep 17 13:36:42 2024
# On host fv-az975-559 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
AlarmStatus, AlarmSeverityCode = mibBuilder.importSymbols("SIAE-ALARM-MIB", "AlarmStatus", "AlarmSeverityCode")
siaeMib, = mibBuilder.importSymbols("SIAE-TREE-MIB", "siaeMib")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, IpAddress, iso, ModuleIdentity, ObjectIdentity, NotificationType, MibIdentifier, Unsigned32, Counter32, Bits, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "IpAddress", "iso", "ModuleIdentity", "ObjectIdentity", "NotificationType", "MibIdentifier", "Unsigned32", "Counter32", "Bits", "Counter64")
RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
radioEncrypt = ModuleIdentity((1, 3, 6, 1, 4, 1, 3373, 1103, 96))
radioEncrypt.setRevisions(('2015-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: radioEncrypt.setRevisionsDescriptions(('Initial version 01.00.00\n            ',))
if mibBuilder.loadTexts: radioEncrypt.setLastUpdated('201507200000Z')
if mibBuilder.loadTexts: radioEncrypt.setOrganization('SIAE MICROELETTRONICA spa')
if mibBuilder.loadTexts: radioEncrypt.setContactInfo('SIAE MICROELETTONICA s.p.a.\n             Via Michelangelo Buonarroti, 21\n             20093 - Cologno Monzese\n             Milano - ITALY\n             Phone :  +39-02-27325-1\n             E-mail: tbd@siaemic.com\n            ')
if mibBuilder.loadTexts: radioEncrypt.setDescription("SIAE's radio encryption MIB.\n            ")
rdEncryptMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 1), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdEncryptMibVersion.setStatus('current')
if mibBuilder.loadTexts: rdEncryptMibVersion.setDescription('Numerical version of this module.\n             The string version of this MIB have the following format:\n                XX.YY.ZZ\n             so, for example, the value 1 should be interpreted as 00.00.01\n             and the value 10001 should be interpreted as 01.00.01.')
rdEncryptTable = MibTable((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2), )
if mibBuilder.loadTexts: rdEncryptTable.setStatus('current')
if mibBuilder.loadTexts: rdEncryptTable.setDescription("Table with SIAE's ENCRYPT entries.")
rdEncryptTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1), ).setIndexNames((0, "SIAE-RADIO-ENCRYPTION-MIB", "rdEncryptIfIndex"))
if mibBuilder.loadTexts: rdEncryptTableEntry.setStatus('current')
if mibBuilder.loadTexts: rdEncryptTableEntry.setDescription("SIAE's ENCRYPT entry. An ENCRYPT instance have the same index of\n             the relative radio link index. A row in this table is created by\n             the SNMP agent for each instance of radio link.")
rdEncryptIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rdEncryptIfIndex.setStatus('current')
if mibBuilder.loadTexts: rdEncryptIfIndex.setDescription('A unique value, greater than zero, for each ENCRYPT interface.\n             This object is identical to the ifIndex of the standard MIB-2\n             ifTable.\n             SNMP agent accepts the value of this objects only if the\n             capability ifextCapabilityEncrypt is shown in ifextCapabilities\n             for the same ifIndex.\n           ')
rdEncryptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptRowStatus.setStatus('current')
if mibBuilder.loadTexts: rdEncryptRowStatus.setDescription('Status of this row of rdEncryptTable. A manager must set\n             this object in order to create an instance of ENCRYPT.\n            ')
rdEncryptAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2))).clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rdEncryptAdminStatus.setDescription("The desired state of the ENCRYPT. This object can be set only\n             when the rdEncryptRowStatus of the ENCRYPT is active.\n            \n             When a managed system initializes, all ENCRYPT instance start with\n             rdEncryptAdminStatus in the disable(2) state, it's a default\n             state also. As a result of either explicit management\n             action or per configuration information retained by the\n             managed system, rdEncryptAdminStatus is then changed to the \n             enable (1) state (or remains in the disable(2) state).\n\n             In order to use ENCRYPT, also rdEncryptSystemControl must be set to\n             start.\n            ")
rdEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aes128", 1), ("aes256", 2))).clone('aes256')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptAlgo.setStatus('current')
if mibBuilder.loadTexts: rdEncryptAlgo.setDescription('The encryption algorithm. The key length depends on the choosen \n             algorithm.\n            ')
rdEncryptAlgoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("aesModeElectronicCodebook", 1), ("aesModeCipherBlockChaining", 2), ("aesModeCipherFeedback", 3), ("aesModeOutputFeedback", 4), ("aesModeCounter", 5))).clone('aesModeCounter')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptAlgoMode.setStatus('current')
if mibBuilder.loadTexts: rdEncryptAlgoMode.setDescription('AES encryption/decryption algorithm can be implemented in\n             five modes. The modes may be used in conjunction with any\n             symmetric key block cipher algorithm that is approved by a\n             Federal Information Processing Standard (FIPS). \n             The five modes are:\n               - Electronic Codebook (ECB)\n               - Cipher Block Chaining (CBC)\n               - Cipher Feedback (CFB),\n               - Output Feedback (OFB),\n               - and Counter (CTR)\n             Agents can accept only a subset of AES modes.\n            ')
rdEncryptKeyMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manualEnteredKey", 1), ("automaticKeyGeneration", 2))).clone('manualEnteredKey')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptKeyMode.setStatus('current')
if mibBuilder.loadTexts: rdEncryptKeyMode.setDescription("This object select between the Manually-entered key mode and\n             auto-generated key mode. Agent could not accept the value\n             automaticKeyGeneration if it don't support the automatic key\n             generation.\n            ")
rdEncryptKey = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 7), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(16, 16), ValueSizeConstraint(32, 32), )).clone(hexValue="00")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptKey.setStatus('current')
if mibBuilder.loadTexts: rdEncryptKey.setDescription('The key used for encryption. The length of the key depends on  \n             rdEncryptAlgo.\n            ')
rdEncryptKeyLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1096)).clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rdEncryptKeyLifeTime.setStatus('current')
if mibBuilder.loadTexts: rdEncryptKeyLifeTime.setDescription('The life time in day of the automatically generated key.\n             The range goes from one day to three years (considering one\n             leap year).\n            ')
rdEncryptMismatchAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 2, 1, 9), AlarmStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rdEncryptMismatchAlarm.setStatus('current')
if mibBuilder.loadTexts: rdEncryptMismatchAlarm.setDescription('This alarm is raised when local and remote configuration does not\n             match.')
rdEncryptSystemControl = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("shutdown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdEncryptSystemControl.setStatus('current')
if mibBuilder.loadTexts: rdEncryptSystemControl.setDescription("The administrative system control status requested by management\n             for the ENCRYPT feature. The value 'start'(1) indicates that all\n             resources required by ENCRYPT should be allocated and ENCRYPT \n             should be supported in the device on ports which shown the \n             specific capability. The value shutdown(2) indicates that ENCRYPT\n             should be shutdown in the device on all ports and all allocated\n             memory must be released.")
rdEncryptMismatchAlarmSeverityCode = MibScalar((1, 3, 6, 1, 4, 1, 3373, 1103, 96, 4), AlarmSeverityCode().clone('majorTrapEnable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rdEncryptMismatchAlarmSeverityCode.setStatus('current')
if mibBuilder.loadTexts: rdEncryptMismatchAlarmSeverityCode.setDescription('Defines the severity associated to the rdEncryptMismatchAlarm\n             and enables/disables the trap generation on status change event.')
mibBuilder.exportSymbols("SIAE-RADIO-ENCRYPTION-MIB", rdEncryptTableEntry=rdEncryptTableEntry, rdEncryptRowStatus=rdEncryptRowStatus, rdEncryptAlgoMode=rdEncryptAlgoMode, rdEncryptSystemControl=rdEncryptSystemControl, rdEncryptKey=rdEncryptKey, rdEncryptMibVersion=rdEncryptMibVersion, PYSNMP_MODULE_ID=radioEncrypt, radioEncrypt=radioEncrypt, rdEncryptKeyMode=rdEncryptKeyMode, rdEncryptMismatchAlarm=rdEncryptMismatchAlarm, rdEncryptMismatchAlarmSeverityCode=rdEncryptMismatchAlarmSeverityCode, rdEncryptTable=rdEncryptTable, rdEncryptAdminStatus=rdEncryptAdminStatus, rdEncryptIfIndex=rdEncryptIfIndex, rdEncryptKeyLifeTime=rdEncryptKeyLifeTime, rdEncryptAlgo=rdEncryptAlgo)
