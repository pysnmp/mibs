#
# PySNMP MIB module RFC1389-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/output/asn1/RFC1389-MIB
# Produced by pysmi-1.1.12 at Thu Apr  4 13:43:03 2024
# On host fv-az654-234 platform Linux version 6.5.0-1016-azure by user runner
# Using Python version 3.10.14 (main, Mar 20 2024, 15:15:25) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, IpAddress, Counter64, NotificationType, TimeTicks, Integer32, Counter32, ObjectIdentity, Unsigned32, MibIdentifier, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, mib_2, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "IpAddress", "Counter64", "NotificationType", "TimeTicks", "Integer32", "Counter32", "ObjectIdentity", "Unsigned32", "MibIdentifier", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "mib-2", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
rip2 = MibIdentifier((1, 3, 6, 1, 2, 1, 23))
class RouteTag(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class Validation(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("valid", 1), ("invalid", 2))

rip2GlobalGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 23, 1))
rip2GlobalRouteChanges = MibScalar((1, 3, 6, 1, 2, 1, 23, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2GlobalRouteChanges.setStatus('mandatory')
if mibBuilder.loadTexts: rip2GlobalRouteChanges.setDescription('The number of changes made to the IP Route Da-\n              tabase by RIP.')
rip2GlobalQueries = MibScalar((1, 3, 6, 1, 2, 1, 23, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2GlobalQueries.setStatus('mandatory')
if mibBuilder.loadTexts: rip2GlobalQueries.setDescription('The number of responses sent  to  RIP  queries\n              from other systems.')
rip2IfStatTable = MibTable((1, 3, 6, 1, 2, 1, 23, 2), )
if mibBuilder.loadTexts: rip2IfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatTable.setDescription('A  list  of  subnets  which  require  separate\n              status monitoring in RIP.')
rip2IfStatEntry = MibTableRow((1, 3, 6, 1, 2, 1, 23, 2, 1), ).setIndexNames((0, "RFC1389-MIB", "rip2IfStatAddress"))
if mibBuilder.loadTexts: rip2IfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatEntry.setDescription('A Single Routing Domain in a single Subnet.')
rip2IfStatAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2IfStatAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatAddress.setDescription('The IP Address of this system on the indicated\n              subnet.')
rip2IfStatRcvBadPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2IfStatRcvBadPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatRcvBadPackets.setDescription('The number of RIP response packets received by\n              the  RIP  process  which were subsequently dis-\n              carded for any reason (e.g. a version 0 packet,\n              or an unknown command type).')
rip2IfStatRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2IfStatRcvBadRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatRcvBadRoutes.setDescription('The number of routes, in  valid  RIP  packets,\n              which were ignored for any reason (e.g. unknown\n              address family, or invalid metric).')
rip2IfStatSentUpdates = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2IfStatSentUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatSentUpdates.setDescription('The number of triggered RIP  updates  actually\n              sent  on  this interface.  This explicitly does\n              NOT include full updates  sent  containing  new\n              information.')
rip2IfStatStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 2, 1, 5), Validation().clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfStatStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfStatStatus.setDescription('Writing invalid has  the  effect  of  deleting\n              this interface.')
rip2IfConfTable = MibTable((1, 3, 6, 1, 2, 1, 23, 3), )
if mibBuilder.loadTexts: rip2IfConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfTable.setDescription('A list of subnets which require separate  con-\n              figuration in RIP.')
rip2IfConfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 23, 3, 1), ).setIndexNames((0, "RFC1389-MIB", "rip2IfConfAddress"))
if mibBuilder.loadTexts: rip2IfConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfEntry.setDescription('A Single Routing Domain in a single Subnet.')
rip2IfConfAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2IfConfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfAddress.setDescription('The IP Address of this system on the indicated\n              subnet.')
rip2IfConfDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 2), RouteTag().clone(hexValue="0000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfDomain.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfDomain.setDescription('Value inserted into the Routing  Domain  field\n              of all RIP packets sent on this interface.')
rip2IfConfAuthType = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAuthentication", 1), ("simplePassword", 2))).clone('noAuthentication')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfAuthType.setDescription('The type of Authentication used on this inter-\n              face.')
rip2IfConfAuthKey = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfAuthKey.setDescription('The value to be used as the Authentication Key\n              whenever    the   corresponding   instance   of\n              rip2IfConfAuthType has  the  value  simplePass-\n              word.   A modification of the corresponding in-\n              stance of rip2IfConfAuthType  does  not  modify\n              the rip2IfConfAuthKey value.\n\n              If a string shorter than 16 octets is supplied,\n              it  will be left-justified and padded to 16 oc-\n              tets, on the right, with nulls (0x00).\n\n              Reading this object always results in an  OCTET\n              STRING  of  length zero; authentication may not\n              be bypassed by reading the MIB object.')
rip2IfConfSend = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4))).clone('rip1Compatible')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfSend.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfSend.setDescription('What  the  router  sends  on  this  interface.\n              ripVersion1 implies sending RIP updates compli-\n              ant  with  RFC  1058.   rip1Compatible  implies\n              broadcasting RIP-2 updates using RFC 1058 route\n              subsumption rules.  ripVersion2 implies  multi-\n              casting RIP-2 updates.')
rip2IfConfReceive = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3))).clone('rip1OrRip2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfReceive.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfReceive.setDescription('This indicates which version  of  RIP  updates\n              are   to  be  accepted.   Note  that  rip2  and\n              rip1OrRip2 implies reception of multicast pack-\n              ets.')
rip2IfConfDefaultMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfDefaultMetric.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfDefaultMetric.setDescription('This variable indicates what metric is  to  be\n              used  as  a  default  route in RIP updates ori-\n              ginated on this interface.  A value of zero in-\n              dicates  that  no  default route should be ori-\n              ginated; in this  case,  a  default  route  via\n              another router may be propagated.')
rip2IfConfStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 3, 1, 8), Validation().clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rip2IfConfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rip2IfConfStatus.setDescription('Writing invalid has  the  effect  of  deleting\n              this interface.')
rip2PeerTable = MibTable((1, 3, 6, 1, 2, 1, 23, 4), )
if mibBuilder.loadTexts: rip2PeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerTable.setDescription('A list of RIP Peers.')
rip2PeerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 23, 4, 1), ).setIndexNames((0, "RFC1389-MIB", "rip2PeerAddress"), (0, "RFC1389-MIB", "rip2PeerDomain"))
if mibBuilder.loadTexts: rip2PeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerEntry.setDescription('Information regarding a single routing peer.')
rip2PeerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerAddress.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerAddress.setDescription('The IP Address of the Peer System.')
rip2PeerDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 2), RouteTag()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerDomain.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerDomain.setDescription('The value in the Routing Domain field  in  RIP\n              packets received from the peer.')
rip2PeerLastUpdate = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerLastUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerLastUpdate.setDescription('The value of sysUpTime when  the  most  recent\n              RIP update was received from this system.')
rip2PeerVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerVersion.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerVersion.setDescription('The RIP version number in the  header  of  the\n              last RIP packet received.')
rip2PeerRcvBadPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerRcvBadPackets.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerRcvBadPackets.setDescription('The number of RIP response packets  from  this\n              peer discarded as invalid.')
rip2PeerRcvBadRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 23, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rip2PeerRcvBadRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: rip2PeerRcvBadRoutes.setDescription('The number of routes from this peer that  were\n              ignored because the entry format was invalid.')
mibBuilder.exportSymbols("RFC1389-MIB", rip2IfConfEntry=rip2IfConfEntry, rip2IfStatRcvBadPackets=rip2IfStatRcvBadPackets, rip2=rip2, rip2IfStatSentUpdates=rip2IfStatSentUpdates, rip2PeerRcvBadPackets=rip2PeerRcvBadPackets, rip2IfStatAddress=rip2IfStatAddress, rip2IfStatTable=rip2IfStatTable, rip2IfConfAuthType=rip2IfConfAuthType, rip2IfConfTable=rip2IfConfTable, rip2PeerRcvBadRoutes=rip2PeerRcvBadRoutes, rip2IfConfDomain=rip2IfConfDomain, rip2IfConfReceive=rip2IfConfReceive, rip2IfStatEntry=rip2IfStatEntry, rip2GlobalQueries=rip2GlobalQueries, rip2IfConfDefaultMetric=rip2IfConfDefaultMetric, rip2GlobalRouteChanges=rip2GlobalRouteChanges, rip2IfConfAddress=rip2IfConfAddress, Validation=Validation, rip2IfStatStatus=rip2IfStatStatus, rip2IfConfAuthKey=rip2IfConfAuthKey, rip2GlobalGroup=rip2GlobalGroup, rip2PeerLastUpdate=rip2PeerLastUpdate, rip2PeerVersion=rip2PeerVersion, rip2IfConfStatus=rip2IfConfStatus, rip2PeerDomain=rip2PeerDomain, RouteTag=RouteTag, rip2PeerEntry=rip2PeerEntry, rip2IfConfSend=rip2IfConfSend, rip2IfStatRcvBadRoutes=rip2IfStatRcvBadRoutes, rip2PeerTable=rip2PeerTable, rip2PeerAddress=rip2PeerAddress)
