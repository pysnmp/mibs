#
# PySNMP MIB module CM-IP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/adva/CM-IP-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 08:15:03 2024
# On host fv-az530-683 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
fsp150cm, = mibBuilder.importSymbols("ADVA-MIB", "fsp150cm")
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
IpVersion, VlanId = mibBuilder.importSymbols("CM-COMMON-MIB", "IpVersion", "VlanId")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Integer32, Counter64, iso, TimeTicks, ObjectIdentity, Gauge32, IpAddress, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ModuleIdentity, Bits, Unsigned32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter64", "iso", "TimeTicks", "ObjectIdentity", "Gauge32", "IpAddress", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ModuleIdentity", "Bits", "Unsigned32", "MibIdentifier")
RowStatus, StorageType, DisplayString, TruthValue, VariablePointer, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "DisplayString", "TruthValue", "VariablePointer", "MacAddress", "TextualConvention")
cmIPMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11))
cmIPMIB.setRevisions(('2019-03-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cmIPMIB.setRevisionsDescriptions(('\n            Notes from release 201903140000Z\n              (1) Added cmIpInterfaceGateway to cmIpInterfaceTable\n              (2) Added cmIpv6InterfaceGateway to cmIpv6InterfaceTable\n\n            Notes from release 201904050000Z\n              (1) chaned cmStaticRouteNextHop to RO\n              (2) chaned cmIpv6StaticRouteNextHop to RO\n\n            Notes from release 201902030000Z\n              (1) added cmIpTraceRouteInterface\n              (2) added cmIpv6TraceRouteInterface\n\n           Notes from release 201901300000Z\n              (1) added cmPingInterface            \n            \n            Notes from release 201901070000Z\n              (1) Modified cmStaticRouteNextHop: MAX-ACCESS read-write instead read-only\n              (2) Modified cmIpv6StaticRouteNextHop: MAX-ACCESS read-write instead not-accessible\n\n            Notes from release 201802130000Z\n             (1) added ipLoopbackInterfaceTable\n            Notes from release 201802020000Z,\n             (1) Added cmIpInterfaceDhcpVendorInfoHideControl to cmIpInterfaceTable\n             (2) Added ipManagementTunnelDhcpVendorInfoHideControl to ipManagementTunnelTable\n            \n            Notes from release 201407180000Z,\n             (1) Added new IpManagementTunnelType literals:\n                 - gcc0based,\n                 - gcc1based,\n                 - gcc2based.\n\n            Notes from release 201012080000Z,\n             (1)Added cmIpManagementTrafficBridgingSecurityEnabled scalar\n             for the Bridged Management LAN feature on GE20x devices\n             for Release 5.1CC. \n\n            Notes from release 201010230000Z,\n             (1)Added cmIpManagementTrafficBridgingEnabled scalar\n             for the Bridged Management LAN feature on GE20x devices\n             for Release 5.1CC. \n\n            Notes from release 200904200000Z,\n             (1)MIB version ready for release FSP150CC 4.1.\n              (a)Added new table IpManagementTunnel\n              (b)Added attribute cmIpInterfaceRIPv2Enabled\n              (c)Added attribute cmARPEntryType \n              (d)Added attribute cmStaticRouteInterface, cmStaticRouteAdvertise \n\n            Notes from release 200803030000Z,\n             (1)MIB version ready for release FSP150CM 3.1.',))
if mibBuilder.loadTexts: cmIPMIB.setLastUpdated('201903140000Z')
if mibBuilder.loadTexts: cmIPMIB.setOrganization('ADVA Optical Networking SE')
if mibBuilder.loadTexts: cmIPMIB.setContactInfo('Web URL: http://adva.com/\n        E-mail:  support@adva.com\n        Postal:  ADVA Optical Networking SE\n             Campus Martinsried\n             Fraunhoferstrasse 9a\n             82152 Martinsried/Munich\n             Germany\n        Phone: +49 089 89 06 65 0\n        Fax:  +49 089 89 06 65 199 ')
if mibBuilder.loadTexts: cmIPMIB.setDescription('This module defines the IP MIB definitions used by \n             the F3 (FSP150CM/CC) product lines.\n             Copyright (C) ADVA.')
cmIpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1))
cmIpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2))
cmIpScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3))
class CmDhcpRole(TextualConvention, Integer32):
    description = 'DHCP role when DHCP is enabled on an interface.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("dhcp-client", 1), ("dhcp-server", 2))

class IpManagementTunnelType(TextualConvention, Integer32):
    description = 'IP Management Tunnel type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("macbased", 1), ("vlanbased", 2), ("itagbased", 3), ("gcc0based", 4), ("gcc1based", 5), ("gcc2based", 6))

class IpManagementTunnelEncapsulationType(TextualConvention, Integer32):
    description = 'IP Management Tunnel Encapsulation type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ethernet", 1), ("ppp", 2))

class IpEntryType(TextualConvention, Integer32):
    description = 'IP Entry type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("static", 1), ("dynamic", 2))

class IpSourceAddrType(TextualConvention, Integer32):
    description = 'IP Source Address type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("systemipaddr", 1), ("outipinterfaceaddr", 2))

class IpActionType(TextualConvention, Integer32):
    description = '.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("not-applicable", 0), ("initiate", 1))

class Ipv6OverIpv4TunnelType(TextualConvention, Integer32):
    description = 'include four types.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("sixToFour", 1), ("ipv4-compatible", 2), ("isatap", 3), ("static-config", 4), ("gre", 5), ("ipv6-6rd", 6))

class IpMode(TextualConvention, Integer32):
    description = 'include 3 types.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("ipv4-only", 0), ("ipv6-only", 1), ("ipv4-and-ipv6", 2))

class DHCPCIDType(TextualConvention, Integer32):
    description = 'DHCP Client ID Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("notApplicable", 1), ("sysName", 2), ("macAddr", 3), ("userDefined", 4), ("serialNumber", 5))

class DHCPHostNameType(TextualConvention, Integer32):
    description = 'DHCP Hostname Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("notApplicable", 1), ("sysName", 2), ("userDefined", 3))

class PtpArpActionType(TextualConvention, Integer32):
    description = '.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("not-applicable", 0), ("retrieve", 1))

class DHCPVendorInfoType(TextualConvention, Integer32):
    description = 'DHCP Vendor Info Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("notApplicable", 1), ("sysName", 2), ("userDefined", 3))

cmIpSystemScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1))
cmIpSourceAddrScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 2))
cmIpFlushARPCacheAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 1), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpFlushARPCacheAction.setStatus('current')
if mibBuilder.loadTexts: cmIpFlushARPCacheAction.setDescription('This object allows user to initiate Flush ARP action.')
cmIpProxyARPEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpProxyARPEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpProxyARPEnabled.setDescription('This object allows user to enable/disable Proxy ARP.')
cmIpPingDestination = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpPingDestination.setStatus('current')
if mibBuilder.loadTexts: cmIpPingDestination.setDescription('This object allows user to specify the IP Address to which\n        ICMP Ping will be initiated.')
cmIpInitiatePingAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 4), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInitiatePingAction.setStatus('current')
if mibBuilder.loadTexts: cmIpInitiatePingAction.setDescription('This object allows user to initiate ICMP Ping on cmIpPingDestination.')
cmIpPingResult = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpPingResult.setStatus('current')
if mibBuilder.loadTexts: cmIpPingResult.setDescription('This object provides the results of a previous ICMP Ping Action.')
cmIpTraceRouteDestination = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpTraceRouteDestination.setStatus('current')
if mibBuilder.loadTexts: cmIpTraceRouteDestination.setDescription('This object allows user to specify the IP Address to which\n        Trace Route will be initiated.')
cmIpInitiateTraceRouteAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 7), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInitiateTraceRouteAction.setStatus('current')
if mibBuilder.loadTexts: cmIpInitiateTraceRouteAction.setDescription('This object allows user to initiate TraceRoute \n        on cmIpTraceRouteDestination.')
cmIpTraceRouteResult = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpTraceRouteResult.setStatus('current')
if mibBuilder.loadTexts: cmIpTraceRouteResult.setDescription('This object provides the results of a previous TraceRoute Action.')
cmIpManagementTrafficBridgingEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingEnabled.setDescription('This object allows the user to control the IP Management Traffic\n        Bridging feature.  When enabled, the system is managed using the\n        IP address specified at the Management LAN port.  All IP packets\n        that are not terminated at the node will be bridged over the \n        Management LAN.')
cmIpManagementTrafficBridgingSecurityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingSecurityEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingSecurityEnabled.setDescription("This object allows the user to control the IP Management Traffic\n        Bridging feature's security.  When enables, the system supports \n        a secure Management Traffic Bridge.")
cmIpv6PingInterface = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6PingInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpv6PingInterface.setDescription('This object allows user to specify the IPV6 Address related interface.')
cmIpv6PingDestination = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 12), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6PingDestination.setStatus('current')
if mibBuilder.loadTexts: cmIpv6PingDestination.setDescription('This object allows user to specify the IPV6 Address to which\n        ICMP Ping will be initiated.')
cmIpv6InitiatePingAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 13), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6InitiatePingAction.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InitiatePingAction.setDescription('This object allows user to initiate ICMP Ping on cmIpv6PingDestination.')
cmIpv6TraceRouteDestination = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 14), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6TraceRouteDestination.setStatus('current')
if mibBuilder.loadTexts: cmIpv6TraceRouteDestination.setDescription('This object allows user to specify the IPV6 Address to which\n        Trace Route will be initiated.')
cmIpv6InitiateTraceRouteAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 15), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6InitiateTraceRouteAction.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InitiateTraceRouteAction.setDescription('This object allows user to initiate TraceRoute \n        on cmIpv6TraceRouteDestination.')
cmIpv6ProxyNDPEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6ProxyNDPEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6ProxyNDPEnabled.setDescription('This object whether enabled proxy NDP.')
cmIpv6FwdEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 17), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6FwdEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6FwdEnabled.setDescription('This object whether NE works in router mode or host mode.\n       Forwarding enable:router mode, forwarding disable: host mode.')
cmIpFlushNDPCacheAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 18), IpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpFlushNDPCacheAction.setStatus('current')
if mibBuilder.loadTexts: cmIpFlushNDPCacheAction.setDescription('This object allows user to initiate Flush NDP action.')
cmIpPtpArpRtrvAction = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 19), PtpArpActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpPtpArpRtrvAction.setStatus('current')
if mibBuilder.loadTexts: cmIpPtpArpRtrvAction.setDescription('If user want to get PTP arp from cmARPEntry, user need to configure this object first.')
cmIpManagementTrafficDscpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 20), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficDscpEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficDscpEnabled.setDescription('This object controls whether the DSCP value is modified for the transmitted\n        management traffic whether it is locally generated or routed.')
cmIpManagementTrafficDscp = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficDscp.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficDscp.setDescription('This object specifies the DSCP value and it is applicable when\n        cmIpManagementTrafficDscpEnabled is enabled.')
cmIpManagementTrafficBridgingInterface = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingInterface.setDescription('This object allows the user to specify the name of\n        the IP interface the IP address of which shall be used as the\n        IP address of the Management Bridge.')
cmIpManagementTrafficBridgingIpv4Gateway = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingIpv4Gateway.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingIpv4Gateway.setDescription('This object allows the user to specify the IPv4 default gateway \n        for the Management Bridge.')
cmIpManagementTrafficBridgingIpv6Gateway = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 24), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingIpv6Gateway.setStatus('current')
if mibBuilder.loadTexts: cmIpManagementTrafficBridgingIpv6Gateway.setDescription('This object allows the user to specify the IPv6 default gateway \n        for the Management Bridge.')
cmPingInterface = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 25), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmPingInterface.setStatus('current')
if mibBuilder.loadTexts: cmPingInterface.setDescription('This object allows user to specify the IPV4 Address related interface.')
cmIpTraceRouteInterface = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 26), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpTraceRouteInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpTraceRouteInterface.setDescription('This object allows user to specify the IPV4 Address related interface.')
cmIpv6TraceRouteInterface = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 1, 27), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6TraceRouteInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpv6TraceRouteInterface.setDescription('This object allows user to specify the IPV6 Address related interface.')
cmIpSNMPv1InterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpSNMPv1InterfaceName.setStatus('current')
if mibBuilder.loadTexts: cmIpSNMPv1InterfaceName.setDescription("This object allows the user to specify the IP interface name,\n        which will be used in the SNMPv1 TRAP PDUs as the Agent's IP Address.")
cmIpSourceAddressType = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 2, 2), IpSourceAddrType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpSourceAddressType.setStatus('current')
if mibBuilder.loadTexts: cmIpSourceAddressType.setDescription("This object allows the user to specify whether the System IP\n        Address or the Outgoing IP Interface's Address should be used \n        in outgoing IP PDUs.")
cmIpSourceAddressInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 3, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpSourceAddressInterfaceName.setStatus('current')
if mibBuilder.loadTexts: cmIpSourceAddressInterfaceName.setDescription("This object allows the user to specify the IP interface name when\n        cmIpSourceAddressType is 'systemipaddr'.  The IP Address associated\n        with the IP interface name is set as the source IP Address in\n        outgoing PDUs.")
cmIpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1), )
if mibBuilder.loadTexts: cmIpInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceTable.setDescription('User managed IP Address Table.')
cmIpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1), ).setIndexNames((0, "CM-IP-MIB", "cmIpInterfaceName"))
if mibBuilder.loadTexts: cmIpInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceEntry.setDescription('Allows management of IP Interfaces.')
cmIpInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpInterfaceName.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceName.setDescription('Name of the IP interface.')
cmIpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpInterface.setDescription('IP Address of the interface.')
cmIpInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceMask.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceMask.setDescription('IP Mask of the interface.')
cmIpInterfaceDhcpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpEnabled.setDescription('Whether or not DHCP is enabled on this interface.')
cmIpInterfaceMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceMTU.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceMTU.setDescription('IP Interface MTU.')
cmIpInterfaceDhcpRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 6), CmDhcpRole()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpRole.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpRole.setDescription('Specify the DHCP role on this interface.')
cmIpInterfacePhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpInterfacePhysicalAddress.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfacePhysicalAddress.setDescription('Physical Address associated with the IP Address.')
cmIpInterfaceRIPv2Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceRIPv2Enabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceRIPv2Enabled.setDescription('This object allows to enable/disable RIPv2 on the IP Interface.')
cmIpInterfaceDHCPClientIdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDHCPClientIdEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDHCPClientIdEnabled.setDescription('This object enables DHCP Option 61 on the IP interface.  This object\n        is only applicable when DHCP client is enabled.')
cmIpInterfaceDHCPClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDHCPClientId.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDHCPClientId.setDescription('This object is applicable when cmIpInterfaceDHCPClientIdEnabled is\n        set to TRUE.  It allows users to specify the DHCP Client Id as\n        a DisplayString - instead of the MAC address.')
cmIpInterfaceIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 11), IpMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceIpMode.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceIpMode.setDescription('This object is the ipmode for the interface.')
cmIpInterfaceDhcpClassIdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpClassIdEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpClassIdEnabled.setDescription('This object describe whether class id editable enabled.')
cmIpInterfaceDhcpHostNameEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostNameEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostNameEnabled.setDescription('This object describe whether host name editable enabled.')
cmIpInterfaceDhcpHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostName.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostName.setDescription('This object describe the host name.')
cmIpInterfaceDhcpLogServerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 15), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpLogServerEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpLogServerEnabled.setDescription('This object describe whether the dhcp log server enabled.')
cmIpInterfaceDhcpNTPServerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 16), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpNTPServerEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpNTPServerEnabled.setDescription('This object describe whether the dhcp ntp server enabled.')
cmIpInterfaceDhcpClientIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 17), DHCPCIDType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpClientIdType.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpClientIdType.setDescription('This object describe whether the dhcp cid type.')
cmIpInterfaceDhcpHostNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 18), DHCPHostNameType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostNameType.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpHostNameType.setDescription('This object describe whether the dhcp host name type.')
cmIpInterfaceDhcpVendorInfoEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoEnabled.setDescription('This object means the vendor information whether enabled.')
cmIpInterfaceDhcpVendorInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 20), DHCPVendorInfoType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoType.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoType.setDescription('This object describe whether the dhcp vendor information type.')
cmIpInterfaceDhcpVendorInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 21), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfo.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfo.setDescription('This object describe the vendor information.')
cmIpInterfaceDhcpVendorInfoHideControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoHideControl.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceDhcpVendorInfoHideControl.setDescription('This object describe whether the dhcp vendor info is hidden or not')
cmIpInterfaceGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 1, 1, 23), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpInterfaceGateway.setStatus('current')
if mibBuilder.loadTexts: cmIpInterfaceGateway.setDescription('This object desribes the IPv4 Gateway Address of the management interface on OSA540X.')
cmStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2), )
if mibBuilder.loadTexts: cmStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteTable.setDescription("This entity's user configured Static IP Routing table.")
cmStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1), ).setIndexNames((0, "CM-IP-MIB", "cmStaticRouteDest"), (0, "CM-IP-MIB", "cmStaticRouteMask"), (0, "CM-IP-MIB", "cmStaticRouteNextHop"), (0, "CM-IP-MIB", "cmStaticRouteInterface"))
if mibBuilder.loadTexts: cmStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteEntry.setDescription('A particular route to  a  particular  destina-\n       tion, under a particular policy.')
cmStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteDest.setDescription('The destination IP address of this route.\n       This object may not take a Multicast (Class  D)\n       address value.\n       Any assignment (implicit or  otherwise)  of  an\n       instance  of  this  object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       cmStaticRouteMask object is not equal to x.')
cmStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteMask.setDescription('Indicate the mask to be logical-ANDed with the\n       destination  address  before  being compared to\n       the value  in  the  cmStaticRouteDest  field.   For\n       those  systems  that  do  not support arbitrary\n       subnet masks, an agent constructs the value  of\n       the  cmStaticRouteMask  by  reference to the IP Ad-\n       dress Class.\n       Any assignment (implicit or  otherwise)  of  an\n       instance  of  this  object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       cmStaticRouteDest object is not equal to\n       cmStaticRouteDest.')
cmStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteNextHop.setDescription('On remote routes, the address of the next sys-\n       tem en route; Otherwise, 0.0.0.0.')
cmStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteMetric.setDescription("The primary routing  metric  for  this  route.\n       The  semantics of this metric are determined by\n       the routing-protocol specified in  the  route's\n       cmStaticRouteProto  value.   If  this metric is not\n       used, its value should be set to 1.")
cmStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteRowStatus.setDescription('The row status variable, used according to\n       row installation and removal conventions.')
cmStaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmStaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteInterface.setDescription('Name of the IP interface for the interface static route.')
cmStaticRouteAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 2, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmStaticRouteAdvertise.setStatus('current')
if mibBuilder.loadTexts: cmStaticRouteAdvertise.setDescription('Whether this static route will be advertised via routing protocol.')
cmARPTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3), )
if mibBuilder.loadTexts: cmARPTable.setStatus('current')
if mibBuilder.loadTexts: cmARPTable.setDescription('A list of ARP entries on the NIDs.')
cmARPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1), ).setIndexNames((0, "CM-IP-MIB", "cmARPInterface"), (0, "CM-IP-MIB", "cmARPIPAddress"))
if mibBuilder.loadTexts: cmARPEntry.setStatus('current')
if mibBuilder.loadTexts: cmARPEntry.setDescription('A conceptual row in the cmARPTable. Entries can\n            be created/deleted in this table by management application action.')
cmARPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmARPIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cmARPIndex.setDescription('An integer index value used to uniquely identify\n             this ARP Entry in the cmARPTable.')
cmARPIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmARPIPAddress.setStatus('current')
if mibBuilder.loadTexts: cmARPIPAddress.setDescription('This object allows configuration of the ARP Entry IP Address.')
cmARPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 3), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmARPMacAddress.setStatus('current')
if mibBuilder.loadTexts: cmARPMacAddress.setDescription('This object allows management of the ARP Entry MAC Address.')
cmARPInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmARPInterface.setStatus('current')
if mibBuilder.loadTexts: cmARPInterface.setDescription('This object allows management of the ARP Entry Interface.')
cmARPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmARPStorageType.setStatus('current')
if mibBuilder.loadTexts: cmARPStorageType.setDescription('The type of storage configured for this entry.')
cmARPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmARPRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmARPRowStatus.setDescription('The status of this row.\n             The cmARPRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
cmARPEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 3, 1, 7), IpEntryType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmARPEntryType.setStatus('current')
if mibBuilder.loadTexts: cmARPEntryType.setDescription('The type of ARP Entry. Note that static entries can be created.')
cmProxyARPTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4), )
if mibBuilder.loadTexts: cmProxyARPTable.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPTable.setDescription('A list of Proxy ARP entries on the NIDs.  This table is not \n             supported in GE206 Release 4.1CC.')
cmProxyARPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1), ).setIndexNames((0, "CM-IP-MIB", "cmProxyARPInterface"), (0, "CM-IP-MIB", "cmProxyARPIPAddress"), (0, "CM-IP-MIB", "cmProxyARPSubnetMask"))
if mibBuilder.loadTexts: cmProxyARPEntry.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPEntry.setDescription('A conceptual row in the cmProxyARPTable. Entries can\n            be created/deleted in this table by management application action.')
cmProxyARPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyARPIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cmProxyARPIndex.setDescription('An integer index value used to uniquely identify\n             this Proxy ARP Entry in the cmProxyARPTable.')
cmProxyARPIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 2), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyARPIPAddress.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPIPAddress.setDescription('This object allows configuration of the ProxyARP Entry IP Address.')
cmProxyARPSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyARPSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPSubnetMask.setDescription('This object allows management of the Proxy ARP Entry Subnet Mask.')
cmProxyARPInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyARPInterface.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPInterface.setDescription('This object allows management of the Proxy ARP Entry Interface.')
cmProxyARPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyARPStorageType.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPStorageType.setDescription('The type of storage configured for this entry.')
cmProxyARPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 4, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmProxyARPRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmProxyARPRowStatus.setDescription('The status of this row.\n             The cmProxyARPRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
ipManagementTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5), )
if mibBuilder.loadTexts: ipManagementTunnelTable.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelTable.setDescription('A list of IP Management Tunnel entries on the fsp150 family of products.')
ipManagementTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1), ).setIndexNames((0, "CM-IP-MIB", "ipManagementTunnelIndex"))
if mibBuilder.loadTexts: ipManagementTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelEntry.setDescription('A conceptual row in the ipManagementTunnelTable. Entries can\n            be created/deleted in this table by management application action.')
ipManagementTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIndex.setDescription('A unique integer index value used to uniquely identify\n             a Management Tunnel Entry in the ipManagementTunnelTable.')
ipManagementTunnelAssociatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 2), VariablePointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelAssociatedPort.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelAssociatedPort.setDescription('This allows specification of the associated physical port on the device,\n             to which the Management Tunnel is attached.')
ipManagementTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelName.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelName.setDescription('This allows specification of a unique name which is also used as the name of the IP interface,\n             to which the Management Tunnel is attached.')
ipManagementTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 4), IpManagementTunnelType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelType.setDescription('This allows specification of the type of management tunnel, \n             whether it is a VLAN based tunnel or a MAC based tunnel.')
ipManagementTunnelMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelMTU.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelMTU.setDescription('This provides the MTU of the Management Tunnel.')
ipManagementTunnelEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 6), IpManagementTunnelEncapsulationType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelEncapsulationType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelEncapsulationType.setDescription('This allows specification of the encapsulation type of management tunnel.\n             Only Ethernet encapsulation is currently supported.')
ipManagementTunnelIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 7), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpAddress.setDescription('This object allows configuration of the Management Tunnel IP Address.')
ipManagementTunnelSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 8), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelSubnetMask.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelSubnetMask.setDescription('This object allows management of the Management Tunnel Subnet Mask.')
ipManagementTunnelVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 9), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelVlanId.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelVlanId.setDescription('This object allows specification of the VLAN Id in the case of \n          a VLAN management tunnel.  This object is not relevant for a \n          MAC based management tunnel.')
ipManagementTunnelSVlanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 10), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelSVlanEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelSVlanEnabled.setDescription('This object allows specification of whether or not the S-TAG is enabled\n          on the IP Management Tunnel. \n          This object is not relevant for a MAC based management tunnel.')
ipManagementTunnelSVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 11), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelSVlanId.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelSVlanId.setDescription('This object allows specification of the S-TAG VLAN Id in the case of \n          a VLAN management tunnel, when S-TAG is also enabled.  \n          This object is not relevant for a MAC based management tunnel,\n          as well as when the ipManagementTunnelSVlanEnabled is set to false.')
ipManagementTunnelDhcpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 12), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelDhcpEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpEnabled.setDescription('This object allows specification of whether or not DHCP is enabled\n          on the IP Management Tunnel.')
ipManagementTunnelRip2PktsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 13), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelRip2PktsEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelRip2PktsEnabled.setDescription('This object allows specification of whether or not RIP2 is enabled\n          on the IP Management Tunnel.')
ipManagementTunnelPhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipManagementTunnelPhysicalAddress.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelPhysicalAddress.setDescription('This object provides the physical address (MAC Address) associated with the\n          IP Management Tunnel.')
ipManagementTunnelCOS = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelCOS.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelCOS.setDescription('This object allows specification of the Class of Service associated with the\n          IP Management Tunnel. This value is also used in the p-bits of the VLAN\n          based management tunnels (for both VLANs in case S-TAG is enabled).')
ipManagementTunnelCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 16), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelCIR.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelCIR.setDescription('This object allows specification of the Management Tunnel CIR.')
ipManagementTunnelEIR = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelEIR.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelEIR.setDescription('This object allows specification of the Management Tunnel EIR.')
ipManagementTunnelBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 18), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelBufferSize.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelBufferSize.setDescription('This object allows specification of the Management Tunnel Buffer Size.')
ipManagementTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 19), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipManagementTunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelStorageType.setDescription('The type of storage configured for this entry.')
ipManagementTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 20), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelRowStatus.setDescription('The status of this row.\n             The ipManagementTunnelRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
ipManagementTunnelDHCPClientIdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 21), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDHCPClientIdEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDHCPClientIdEnabled.setDescription('This object enables DHCP Option 61 on the Management Tunnel.  \n        This object is only applicable when DHCP client is enabled.')
ipManagementTunnelDHCPClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDHCPClientId.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDHCPClientId.setDescription('This object is applicable when ipManagementTunnelDHCPClientIdEnabled is\n        set to TRUE.  It allows users to specify the DHCP Client Id as\n        a DisplayString - instead of the MAC address.')
ipManagementTunnelQosQueueProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 23), VariablePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelQosQueueProfile.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelQosQueueProfile.setDescription('This object identifies the OID of cmQosQueueProfileIndex in the cmQosQueueProfileTable.')
ipManagementTunnelCVlanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 24), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelCVlanEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelCVlanEnabled.setDescription('This object CTAG whether enabled, By default it is enabled.')
ipManagementTunnelDHCPv6Enabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 25), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDHCPv6Enabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDHCPv6Enabled.setDescription('This object DHCPv6 whether enabled, By default it is enabled.')
ipManagementTunnelIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 26), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6Address.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6Address.setDescription('This object means the unicast ipv6 address.')
ipManagementTunnelIpv6AddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6AddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6AddrPrefixLen.setDescription('This object means the unicast ipv6 address prefix length.')
ipManagementTunnelIpv6StateAddrAutoConfigEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 28), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6StateAddrAutoConfigEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6StateAddrAutoConfigEnabled.setDescription('This object Ipv6StateAddrAutoConfig whether enabled, By default it is enabled.')
ipManagementTunnellinkLocIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 29), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipManagementTunnellinkLocIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnellinkLocIpv6Addr.setDescription('This object means the link local ipv6 address.')
ipManagementTunnellinkLocIpv6AddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipManagementTunnellinkLocIpv6AddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnellinkLocIpv6AddrPrefixLen.setDescription('This object means the link local ipv6 address prefix length.')
ipManagementTunnelIpv6PrefixAdvertiseEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 31), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6PrefixAdvertiseEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6PrefixAdvertiseEnabled.setDescription('This object means the prefix advertise whether enabled.')
ipManagementTunnelIpv6Prefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 32), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6Prefix.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6Prefix.setDescription('This object means the prefix ipv6 address.')
ipManagementTunnelIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6PrefixLen.setDescription('This object means the link local ipv6 address prefix length.')
ipManagementTunnelIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 34), IpMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpMode.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpMode.setDescription('This object means the ip mode for the management tunnel.')
ipManagementTunnelIpv6RipngEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 35), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelIpv6RipngEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelIpv6RipngEnabled.setDescription("This object means the ipv6's Ripng whether enabled.")
ipManagementTunnelDhcpClassIdEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 36), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpClassIdEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpClassIdEnabled.setDescription('This object means the class id whether enabled.')
ipManagementTunnelDhcpHostNameEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 37), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostNameEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostNameEnabled.setDescription('This object means the host name whether enabled.')
ipManagementTunnelDhcpHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 38), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostName.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostName.setDescription('This object describe the host name.')
ipManagementTunnelDhcpLogServerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 39), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpLogServerEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpLogServerEnabled.setDescription('This object describe whether the dhcp log server enabled.')
ipManagementTunnelDhcpNTPServerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 40), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpNTPServerEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpNTPServerEnabled.setDescription('This object describe whether the dhcp ntp server enabled.')
ipManagementTunnelDhcpClientIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 41), DHCPCIDType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpClientIdType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpClientIdType.setDescription('This object describe whether the dhcp cid type.')
ipManagementTunnelDhcpHostNameType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 42), DHCPHostNameType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostNameType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpHostNameType.setDescription('This object describe whether the dhcp host name type.')
ipManagementTunnelDhcpVendorInfoEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 43), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoEnabled.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoEnabled.setDescription('This object means the vendor information whether enabled.')
ipManagementTunnelDhcpVendorInfoType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 44), DHCPVendorInfoType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoType.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoType.setDescription('This object describe whether the dhcp vendor information type.')
ipManagementTunnelDhcpVendorInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 45), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfo.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfo.setDescription('This object describe the vendor information.')
ipManagementTunnelDhcpVendorInfoHideControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 46), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoHideControl.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelDhcpVendorInfoHideControl.setDescription('This object describe whether the dhcp vendor info is hidden or not.')
ipManagementTunnelSharedVim = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 5, 1, 47), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipManagementTunnelSharedVim.setStatus('current')
if mibBuilder.loadTexts: ipManagementTunnelSharedVim.setDescription('This object describes if tunnel share vlan with vim tunnel.')
cmIpv6InterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6), )
if mibBuilder.loadTexts: cmIpv6InterfaceTable.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InterfaceTable.setDescription('User managed IPv6 Address Table.')
cmIpv6InterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1), )
cmIpInterfaceEntry.registerAugmentions(("CM-IP-MIB", "cmIpv6InterfaceEntry"))
cmIpv6InterfaceEntry.setIndexNames(*cmIpInterfaceEntry.getIndexNames())
if mibBuilder.loadTexts: cmIpv6InterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InterfaceEntry.setDescription('Allows management of IPv6 Interfaces.')
cmIpv6InterfaceMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6InterfaceMTU.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InterfaceMTU.setDescription('This object describe the MTU for ipv6 address interface.')
cmIpv6UnicastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 2), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6UnicastAddr.setStatus('current')
if mibBuilder.loadTexts: cmIpv6UnicastAddr.setDescription('This object describe IPv6 Unicast Address together with Prefix.')
cmIpv6UnicastAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6UnicastAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmIpv6UnicastAddrPrefixLen.setDescription('This object describe prefix length of unicast address.')
cmIpv6PrefixAdvertiseEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6PrefixAdvertiseEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6PrefixAdvertiseEnabled.setDescription('This object describe whether to advertise prefix to link in router mode.')
cmIpv6RAPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 5), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6RAPrefix.setStatus('current')
if mibBuilder.loadTexts: cmIpv6RAPrefix.setDescription('This object describe the IPv6 Prefix to be dispatched to link in Router mode.')
cmIpv6RAPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6RAPrefixLength.setStatus('current')
if mibBuilder.loadTexts: cmIpv6RAPrefixLength.setDescription('This object describe Length of RA prefix.')
cmIpv6StateAddrAutoConfigEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6StateAddrAutoConfigEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StateAddrAutoConfigEnabled.setDescription('This object describe whether enable or disable stateless \n       address auto configuration.')
cmIpv6DhcpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6DhcpEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6DhcpEnabled.setDescription('This object describe whether dhcp is enabled on the ipv6 interface.')
cmIpv6DhcpRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 9), CmDhcpRole()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6DhcpRole.setStatus('current')
if mibBuilder.loadTexts: cmIpv6DhcpRole.setDescription('This object describe the dhcp role.')
cmIpv6RIPngEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6RIPngEnabled.setStatus('current')
if mibBuilder.loadTexts: cmIpv6RIPngEnabled.setDescription('This object describe RIPng whether enabled.')
cmIpv6LinkLocAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 11), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpv6LinkLocAddr.setStatus('current')
if mibBuilder.loadTexts: cmIpv6LinkLocAddr.setDescription('This object describe Automatically generated Link-local Address.')
cmIpv6LinkLocAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpv6LinkLocAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmIpv6LinkLocAddrPrefixLen.setDescription('This object describe Length of link local IPv6 address prefix.')
cmIpv6InterfaceGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 6, 1, 13), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6InterfaceGateway.setStatus('current')
if mibBuilder.loadTexts: cmIpv6InterfaceGateway.setDescription('This object describes the IPv6 Gateway address for the management interface on OSA540X.')
cmIpv6StaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7), )
if mibBuilder.loadTexts: cmIpv6StaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteTable.setDescription("This entity's user configured Static Ipv6 Routing table.")
cmIpv6StaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1), ).setIndexNames((0, "CM-IP-MIB", "cmIpv6StaticRouteDest"), (0, "CM-IP-MIB", "cmIpv6StaticRoutePrefixLen"), (0, "CM-IP-MIB", "cmIpv6StaticRouteNextHop"), (0, "CM-IP-MIB", "cmIpv6StaticRouteInterface"))
if mibBuilder.loadTexts: cmIpv6StaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteEntry.setDescription('A particular route to  a  particular  destina-\n       tion, under a particular policy.')
cmIpv6StaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 1), Ipv6Address())
if mibBuilder.loadTexts: cmIpv6StaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteDest.setDescription('The destination Ipv6 address of this route.\n       This object may not take a Multicast (Class  D)\n       address value.\n       Any assignment (implicit or  otherwise)  of  an\n       instance  of  this  object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       cmIpv6StaticRouteMask object is not equal to x.')
cmIpv6StaticRoutePrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: cmIpv6StaticRoutePrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRoutePrefixLen.setDescription('Indicate the mask to be logical-ANDed with the\n       destination  address  before  being compared to\n       the value  in  the  cmIpv6StaticRouteDest  field.   For\n       those  systems  that  do  not support arbitrary\n       subnet masks, an agent constructs the value  of\n       the  cmIpv6StaticRoutePrefixLen  by  reference to the IP Ad-\n       dress Class.\n       Any assignment (implicit or  otherwise)  of  an\n       instance  of  this  object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       cmIpv6StaticRouteDest object is not equal to\n       cmIpv6StaticRouteDest.')
cmIpv6StaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 3), Ipv6Address())
if mibBuilder.loadTexts: cmIpv6StaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteNextHop.setDescription('On remote routes, the address of the next sys-\n       tem en route; Otherwise, 0.0.0.0.')
cmIpv6StaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmIpv6StaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteMetric.setDescription("The primary routing  metric  for  this  route.\n       The  semantics of this metric are determined by\n       the routing-protocol specified in  the  route's\n       cmIpv6StaticRouteProto  value.   If  this metric is not\n       used, its value should be set to 1.")
cmIpv6StaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmIpv6StaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteRowStatus.setDescription('The row status variable, used according to\n       row installation and removal conventions.')
cmIpv6StaticRouteInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)))
if mibBuilder.loadTexts: cmIpv6StaticRouteInterface.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteInterface.setDescription('Name of the Ipv6 interface for the interface static route.')
cmIpv6StaticRouteAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 7, 1, 7), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmIpv6StaticRouteAdvertise.setStatus('current')
if mibBuilder.loadTexts: cmIpv6StaticRouteAdvertise.setDescription('Whether this static route will be advertised via routing protocol.')
cmNDPTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8), )
if mibBuilder.loadTexts: cmNDPTable.setStatus('current')
if mibBuilder.loadTexts: cmNDPTable.setDescription('A list of NDP entries on the NIDs.')
cmNDPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1), ).setIndexNames((0, "CM-IP-MIB", "cmNDPInterface"), (0, "CM-IP-MIB", "cmNDPIpv6Address"))
if mibBuilder.loadTexts: cmNDPEntry.setStatus('current')
if mibBuilder.loadTexts: cmNDPEntry.setDescription('A conceptual row in the cmNDPTable. Entries can\n            be created/deleted in this table by management application action.')
cmNDPIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 1), Ipv6Address())
if mibBuilder.loadTexts: cmNDPIpv6Address.setStatus('current')
if mibBuilder.loadTexts: cmNDPIpv6Address.setDescription('This object allows configuration of the NDP Entry IP Address.')
cmNDPMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 2), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmNDPMacAddress.setStatus('current')
if mibBuilder.loadTexts: cmNDPMacAddress.setDescription('This object allows management of the NDP Entry MAC Address.')
cmNDPInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)))
if mibBuilder.loadTexts: cmNDPInterface.setStatus('current')
if mibBuilder.loadTexts: cmNDPInterface.setDescription('This object allows management of the NDP Entry Interface.')
cmNDPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmNDPStorageType.setStatus('current')
if mibBuilder.loadTexts: cmNDPStorageType.setDescription('The type of storage configured for this entry.')
cmNDPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmNDPRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmNDPRowStatus.setDescription('The status of this row.\n             The cmNDPRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
cmNDPEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 8, 1, 6), IpEntryType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmNDPEntryType.setStatus('current')
if mibBuilder.loadTexts: cmNDPEntryType.setDescription('The type of NDP Entry. Note that static entries can be created.')
cmProxyNDPTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9), )
if mibBuilder.loadTexts: cmProxyNDPTable.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPTable.setDescription('A list of Proxy NDP entries on the NIDs.  This table is not \n             supported in GE206 Release 4.1CC.')
cmProxyNDPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1), ).setIndexNames((0, "CM-IP-MIB", "cmProxyNDPInterface"), (0, "CM-IP-MIB", "cmProxyNDPIpv6Address"), (0, "CM-IP-MIB", "cmProxyNDPIpv6PrefixLen"))
if mibBuilder.loadTexts: cmProxyNDPEntry.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPEntry.setDescription('A conceptual row in the cmProxyNDPTable. Entries can\n            be created/deleted in this table by management application action.')
cmProxyNDPIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1, 1), Ipv6Address())
if mibBuilder.loadTexts: cmProxyNDPIpv6Address.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPIpv6Address.setDescription('This object allows configuration of the ProxyNDP Entry IP Address.')
cmProxyNDPIpv6PrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: cmProxyNDPIpv6PrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPIpv6PrefixLen.setDescription('This object allows management of the Proxy NDP Entry Subnet Mask.')
cmProxyNDPInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyNDPInterface.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPInterface.setDescription('This object allows management of the Proxy NDP Entry Interface.')
cmProxyNDPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1, 4), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmProxyNDPStorageType.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPStorageType.setDescription('The type of storage configured for this entry.')
cmProxyNDPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 9, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmProxyNDPRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmProxyNDPRowStatus.setDescription('The status of this row.\n             The cmProxyNDPRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
cmIpv6OverIpv4TunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10), )
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelTable.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelTable.setDescription('A list of Ipv6OverIpv4Tunnel entries on the NIDs.')
cmIpv6OverIpv4TunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1), ).setIndexNames((0, "CM-IP-MIB", "cmIpv6OverIpv4TunnelIndex"))
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelEntry.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelEntry.setDescription('A conceptual row in the cmIpv6OverIpv4TunnelTable. Entries can\n            be created/deleted in this table by management application action.')
cmIpv6OverIpv4TunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIndex.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIndex.setDescription('An integer index value used to uniquely identify\n             this Ipv6OverIpv4TunnelEntry in the cmIpv6OverIpv4TunnelTable.')
cmIpv6OverIpv4TunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelName.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelName.setDescription('This object describe the tunnel name.')
cmIpv6OverIpv4TunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 3), Ipv6OverIpv4TunnelType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelType.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelType.setDescription('This object describe the tunnel type.')
cmIpv6OverIpv4TunnelDestIpv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelDestIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelDestIpv4Addr.setDescription('This object describe Destination IPv4 address.\n             Only applicable for configured tunnel.')
cmIpv6OverIpv4TunnelIpv6UnicastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 5), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIpv6UnicastAddress.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIpv6UnicastAddress.setDescription('This object describe Source IPv6 address used to transmit \n            IPv6 packets on tunnel. Only writable for Configured Tunnel, \n            read-only for other types of Tunnels.')
cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen.setDescription('This object describe the prefix length for the unicast ipv6 address.')
cmIpv6OverIpv4TunnelLinkLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 7), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelLinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelLinkLocalAddress.setDescription('This object describe the link local adderss.')
cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen.setDescription('This object describe the prefix length for link local address.')
cmIpv6OverIpv4TunnelAssociatedIpv4Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 9), VariablePointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelAssociatedIpv4Interface.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelAssociatedIpv4Interface.setDescription('the IPv4 Interface that Tunnel is created on, \n            which could be DCN or Management tunnel.')
cmIpv6OverIpv4TunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelStorageType.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelStorageType.setDescription('The type of storage configured for this entry.')
cmIpv6OverIpv4TunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4TunnelRowStatus.setDescription('The status of this row.\n             The cmIpv6OverIpv4TunnelRowStatus object may be modified if\n             the associated instance of this object is equal to active(1),\n             notInService(2), or notReady(3).')
cmIpv6OverIpv4PotentialRouterList = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 10, 1, 12), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cmIpv6OverIpv4PotentialRouterList.setStatus('current')
if mibBuilder.loadTexts: cmIpv6OverIpv4PotentialRouterList.setDescription("This object describe the potential router list. \n            And its format should be like 'a.b.c.d,e.f.g.h', split by ',' and no breakspace there.")
ipLoopbackInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11), )
if mibBuilder.loadTexts: ipLoopbackInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceTable.setDescription('A list of loopback interace entries in the management plane.')
ipLoopbackInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1), ).setIndexNames((0, "CM-IP-MIB", "ipLoopbackInterfaceIndex"))
if mibBuilder.loadTexts: ipLoopbackInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceEntry.setDescription('A conceptual row in the ipLoopbackInterfaceTable. Entries can\n            be created/deleted in this table by management application action.')
ipLoopbackInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: ipLoopbackInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceIndex.setDescription('A unique integer index value used to uniquely identify\n             a Loopback Interface Entry in the ipLoopbackInterfaceTable.')
ipLoopbackInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipLoopbackInterfaceName.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceName.setDescription('This allows specification of a unique name which is also used as the name of the IP interface.')
ipLoopbackInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceIpAddress.setDescription('This object allows user to specify the IP Address of the interface.')
ipLoopbackInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceMask.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceMask.setDescription('This object allows user to specify the IP mask of the interface.')
ipLoopbackInterfaceStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipLoopbackInterfaceStorageType.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceStorageType.setDescription('The type of storage configured for this entry.')
ipLoopbackInterfaceRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceRowStatus.setDescription('The status of this row.\n            An entry MUST NOT exist in the active state unless all\n            objects in the entry have an appropriate value, as described\n            in the description clause for each writable object.\n\n            The values of ipLoopbackInterfaceRowStatus supported are\n            createAndGo(4) and destroy(6).  All mandatory attributes\n            must be specified in a single SNMP SET request with\n            ipLoopbackInterfaceRowStatus value as createAndGo(4).\n            Upon successful row creation, this object has a\n            value of active(1).\n\n            The ipLoopbackInterfaceRowStatus object may be modified if\n            the associated instance of this object is equal to active(1).')
ipLoopbackInterfaceIpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 7), IpMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceIpMode.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceIpMode.setDescription('This object means the ip mode for the interface.')
ipLoopbackInterfaceIpv6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 8), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceIpv6Address.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceIpv6Address.setDescription('This object means the ipv6 address for the interface.')
ipLoopbackInterfaceIpv6AddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 1, 11, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipLoopbackInterfaceIpv6AddrPrefixLen.setStatus('current')
if mibBuilder.loadTexts: ipLoopbackInterfaceIpv6AddrPrefixLen.setDescription('This object means the ipv6 address prefix length for the interface.')
ipCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2, 1))
ipGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2, 2))
ipCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2, 1, 1)).setObjects(("CM-IP-MIB", "ipGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipCompliance = ipCompliance.setStatus('current')
if mibBuilder.loadTexts: ipCompliance.setDescription('Describes the requirements for compliance to the IP Module.')
ipGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2, 2, 1)).setObjects(("CM-IP-MIB", "cmIpFlushARPCacheAction"), ("CM-IP-MIB", "cmIpProxyARPEnabled"), ("CM-IP-MIB", "cmIpPingDestination"), ("CM-IP-MIB", "cmIpInitiatePingAction"), ("CM-IP-MIB", "cmIpPingResult"), ("CM-IP-MIB", "cmPingInterface"), ("CM-IP-MIB", "cmIpTraceRouteDestination"), ("CM-IP-MIB", "cmIpInitiateTraceRouteAction"), ("CM-IP-MIB", "cmIpTraceRouteResult"), ("CM-IP-MIB", "cmIpTraceRouteInterface"), ("CM-IP-MIB", "cmIpSNMPv1InterfaceName"), ("CM-IP-MIB", "cmIpSourceAddressType"), ("CM-IP-MIB", "cmIpSourceAddressInterfaceName"), ("CM-IP-MIB", "cmIpManagementTrafficBridgingEnabled"), ("CM-IP-MIB", "cmIpManagementTrafficBridgingSecurityEnabled"), ("CM-IP-MIB", "cmIpInterfaceName"), ("CM-IP-MIB", "cmIpInterface"), ("CM-IP-MIB", "cmIpInterfaceMask"), ("CM-IP-MIB", "cmIpInterfaceDhcpEnabled"), ("CM-IP-MIB", "cmIpInterfaceMTU"), ("CM-IP-MIB", "cmIpInterfaceDhcpRole"), ("CM-IP-MIB", "cmIpInterfacePhysicalAddress"), ("CM-IP-MIB", "cmIpInterfaceRIPv2Enabled"), ("CM-IP-MIB", "cmIpInterfaceDHCPClientIdEnabled"), ("CM-IP-MIB", "cmIpInterfaceDHCPClientId"), ("CM-IP-MIB", "cmIpInterfaceIpMode"), ("CM-IP-MIB", "cmIpInterfaceDhcpClassIdEnabled"), ("CM-IP-MIB", "cmIpInterfaceDhcpHostNameEnabled"), ("CM-IP-MIB", "cmIpInterfaceDhcpHostName"), ("CM-IP-MIB", "cmIpInterfaceDhcpLogServerEnabled"), ("CM-IP-MIB", "cmIpInterfaceDhcpNTPServerEnabled"), ("CM-IP-MIB", "cmIpInterfaceDhcpClientIdType"), ("CM-IP-MIB", "cmIpInterfaceDhcpHostNameType"), ("CM-IP-MIB", "cmIpInterfaceDhcpVendorInfoEnabled"), ("CM-IP-MIB", "cmIpInterfaceDhcpVendorInfoType"), ("CM-IP-MIB", "cmIpInterfaceDhcpVendorInfo"), ("CM-IP-MIB", "cmIpInterfaceDhcpVendorInfoHideControl"), ("CM-IP-MIB", "cmIpInterfaceGateway"), ("CM-IP-MIB", "cmStaticRouteDest"), ("CM-IP-MIB", "cmStaticRouteMask"), ("CM-IP-MIB", "cmStaticRouteNextHop"), ("CM-IP-MIB", "cmStaticRouteMetric"), ("CM-IP-MIB", "cmStaticRouteRowStatus"), ("CM-IP-MIB", "cmStaticRouteInterface"), ("CM-IP-MIB", "cmStaticRouteAdvertise"), ("CM-IP-MIB", "cmARPIndex"), ("CM-IP-MIB", "cmARPIPAddress"), ("CM-IP-MIB", "cmARPMacAddress"), ("CM-IP-MIB", "cmARPInterface"), ("CM-IP-MIB", "cmARPStorageType"), ("CM-IP-MIB", "cmARPRowStatus"), ("CM-IP-MIB", "cmARPEntryType"), ("CM-IP-MIB", "cmProxyARPIndex"), ("CM-IP-MIB", "cmProxyARPIPAddress"), ("CM-IP-MIB", "cmProxyARPSubnetMask"), ("CM-IP-MIB", "cmProxyARPInterface"), ("CM-IP-MIB", "cmProxyARPStorageType"), ("CM-IP-MIB", "cmProxyARPRowStatus"), ("CM-IP-MIB", "ipManagementTunnelIndex"), ("CM-IP-MIB", "ipManagementTunnelAssociatedPort"), ("CM-IP-MIB", "ipManagementTunnelName"), ("CM-IP-MIB", "ipManagementTunnelType"), ("CM-IP-MIB", "ipManagementTunnelMTU"), ("CM-IP-MIB", "ipManagementTunnelEncapsulationType"), ("CM-IP-MIB", "ipManagementTunnelIpAddress"), ("CM-IP-MIB", "ipManagementTunnelSubnetMask"), ("CM-IP-MIB", "ipManagementTunnelVlanId"), ("CM-IP-MIB", "ipManagementTunnelSVlanEnabled"), ("CM-IP-MIB", "ipManagementTunnelSVlanId"), ("CM-IP-MIB", "ipManagementTunnelDhcpEnabled"), ("CM-IP-MIB", "ipManagementTunnelRip2PktsEnabled"), ("CM-IP-MIB", "ipManagementTunnelPhysicalAddress"), ("CM-IP-MIB", "ipManagementTunnelCOS"), ("CM-IP-MIB", "ipManagementTunnelCIR"), ("CM-IP-MIB", "ipManagementTunnelEIR"), ("CM-IP-MIB", "ipManagementTunnelBufferSize"), ("CM-IP-MIB", "ipManagementTunnelStorageType"), ("CM-IP-MIB", "ipManagementTunnelRowStatus"), ("CM-IP-MIB", "ipManagementTunnelQosQueueProfile"), ("CM-IP-MIB", "ipManagementTunnelDHCPClientIdEnabled"), ("CM-IP-MIB", "ipManagementTunnelDHCPClientId"), ("CM-IP-MIB", "ipManagementTunnelCVlanEnabled"), ("CM-IP-MIB", "ipManagementTunnelIpMode"), ("CM-IP-MIB", "ipManagementTunnelDhcpClassIdEnabled"), ("CM-IP-MIB", "ipManagementTunnelDhcpHostNameEnabled"), ("CM-IP-MIB", "ipManagementTunnelDhcpHostName"), ("CM-IP-MIB", "ipManagementTunnelDhcpLogServerEnabled"), ("CM-IP-MIB", "ipManagementTunnelDhcpNTPServerEnabled"), ("CM-IP-MIB", "ipManagementTunnelDhcpClientIdType"), ("CM-IP-MIB", "ipManagementTunnelDhcpHostNameType"), ("CM-IP-MIB", "cmIpManagementTrafficDscpEnabled"), ("CM-IP-MIB", "cmIpManagementTrafficDscp"), ("CM-IP-MIB", "cmIpManagementTrafficBridgingInterface"), ("CM-IP-MIB", "cmIpManagementTrafficBridgingIpv4Gateway"), ("CM-IP-MIB", "cmIpManagementTrafficBridgingIpv6Gateway"), ("CM-IP-MIB", "ipManagementTunnelDhcpVendorInfoEnabled"), ("CM-IP-MIB", "ipManagementTunnelDhcpVendorInfoType"), ("CM-IP-MIB", "ipManagementTunnelDhcpVendorInfo"), ("CM-IP-MIB", "ipManagementTunnelDhcpVendorInfoHideControl"), ("CM-IP-MIB", "ipManagementTunnelSharedVim"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipGroup = ipGroup.setStatus('current')
if mibBuilder.loadTexts: ipGroup.setDescription('A collection of objects used to manage the FSP150CM IP Services.')
ipv6Group = ObjectGroup((1, 3, 6, 1, 4, 1, 2544, 1, 12, 11, 2, 2, 2)).setObjects(("CM-IP-MIB", "ipManagementTunnelDHCPv6Enabled"), ("CM-IP-MIB", "ipManagementTunnelIpv6Address"), ("CM-IP-MIB", "ipManagementTunnelIpv6AddrPrefixLen"), ("CM-IP-MIB", "ipManagementTunnelIpv6StateAddrAutoConfigEnabled"), ("CM-IP-MIB", "ipManagementTunnellinkLocIpv6Addr"), ("CM-IP-MIB", "ipManagementTunnellinkLocIpv6AddrPrefixLen"), ("CM-IP-MIB", "ipManagementTunnelIpv6PrefixAdvertiseEnabled"), ("CM-IP-MIB", "ipManagementTunnelIpv6Prefix"), ("CM-IP-MIB", "ipManagementTunnelIpv6PrefixLen"), ("CM-IP-MIB", "ipManagementTunnelIpv6RipngEnabled"), ("CM-IP-MIB", "cmIpv6InterfaceMTU"), ("CM-IP-MIB", "cmIpv6UnicastAddr"), ("CM-IP-MIB", "cmIpv6UnicastAddrPrefixLen"), ("CM-IP-MIB", "cmIpv6PrefixAdvertiseEnabled"), ("CM-IP-MIB", "cmIpv6RAPrefix"), ("CM-IP-MIB", "cmIpv6RAPrefixLength"), ("CM-IP-MIB", "cmIpv6StateAddrAutoConfigEnabled"), ("CM-IP-MIB", "cmIpv6DhcpEnabled"), ("CM-IP-MIB", "cmIpv6DhcpRole"), ("CM-IP-MIB", "cmIpv6RIPngEnabled"), ("CM-IP-MIB", "cmIpv6LinkLocAddr"), ("CM-IP-MIB", "cmIpv6LinkLocAddrPrefixLen"), ("CM-IP-MIB", "cmIpv6InterfaceGateway"), ("CM-IP-MIB", "cmIpv6StaticRouteDest"), ("CM-IP-MIB", "cmIpv6StaticRoutePrefixLen"), ("CM-IP-MIB", "cmIpv6StaticRouteNextHop"), ("CM-IP-MIB", "cmIpv6StaticRouteMetric"), ("CM-IP-MIB", "cmIpv6StaticRouteRowStatus"), ("CM-IP-MIB", "cmIpv6StaticRouteInterface"), ("CM-IP-MIB", "cmIpv6StaticRouteAdvertise"), ("CM-IP-MIB", "cmNDPIpv6Address"), ("CM-IP-MIB", "cmNDPMacAddress"), ("CM-IP-MIB", "cmNDPInterface"), ("CM-IP-MIB", "cmNDPStorageType"), ("CM-IP-MIB", "cmNDPRowStatus"), ("CM-IP-MIB", "cmNDPEntryType"), ("CM-IP-MIB", "cmProxyNDPIpv6Address"), ("CM-IP-MIB", "cmProxyNDPIpv6PrefixLen"), ("CM-IP-MIB", "cmProxyNDPInterface"), ("CM-IP-MIB", "cmProxyNDPStorageType"), ("CM-IP-MIB", "cmProxyNDPRowStatus"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelIndex"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelName"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelType"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelDestIpv4Addr"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelIpv6UnicastAddress"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelAssociatedIpv4Interface"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelStorageType"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelRowStatus"), ("CM-IP-MIB", "cmIpv6InitiatePingAction"), ("CM-IP-MIB", "cmIpv6InitiatePingAction"), ("CM-IP-MIB", "cmIpv6TraceRouteDestination"), ("CM-IP-MIB", "cmIpv6InitiateTraceRouteAction"), ("CM-IP-MIB", "cmIpv6PingInterface"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen"), ("CM-IP-MIB", "cmIpv6OverIpv4TunnelLinkLocalAddress"), ("CM-IP-MIB", "cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen"), ("CM-IP-MIB", "cmIpv6OverIpv4PotentialRouterList"), ("CM-IP-MIB", "cmIpv6FwdEnabled"), ("CM-IP-MIB", "cmIpv6ProxyNDPEnabled"), ("CM-IP-MIB", "cmIpFlushNDPCacheAction"), ("CM-IP-MIB", "cmIpPtpArpRtrvAction"), ("CM-IP-MIB", "ipLoopbackInterfaceIndex"), ("CM-IP-MIB", "ipLoopbackInterfaceName"), ("CM-IP-MIB", "ipLoopbackInterfaceIpAddress"), ("CM-IP-MIB", "ipLoopbackInterfaceMask"), ("CM-IP-MIB", "ipLoopbackInterfaceStorageType"), ("CM-IP-MIB", "ipLoopbackInterfaceRowStatus"), ("CM-IP-MIB", "ipLoopbackInterfaceIpMode"), ("CM-IP-MIB", "ipLoopbackInterfaceIpv6Address"), ("CM-IP-MIB", "ipLoopbackInterfaceIpv6AddrPrefixLen"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ipv6Group = ipv6Group.setStatus('current')
if mibBuilder.loadTexts: ipv6Group.setDescription('A collection of objects used to manage the FSP150CM IPv6 Services.')
mibBuilder.exportSymbols("CM-IP-MIB", IpManagementTunnelType=IpManagementTunnelType, cmIpInterfaceTable=cmIpInterfaceTable, ipManagementTunnelMTU=ipManagementTunnelMTU, cmIpInterfaceDhcpHostNameEnabled=cmIpInterfaceDhcpHostNameEnabled, ipManagementTunnelEIR=ipManagementTunnelEIR, cmARPMacAddress=cmARPMacAddress, cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen=cmIpv6OverIpv4TunnelIpv6UnicastAddrPrefixLen, ipLoopbackInterfaceIpv6Address=ipLoopbackInterfaceIpv6Address, cmProxyARPSubnetMask=cmProxyARPSubnetMask, cmIpPingDestination=cmIpPingDestination, cmProxyNDPEntry=cmProxyNDPEntry, ipManagementTunnelSubnetMask=ipManagementTunnelSubnetMask, cmIpv6OverIpv4TunnelLinkLocalAddress=cmIpv6OverIpv4TunnelLinkLocalAddress, ipLoopbackInterfaceMask=ipLoopbackInterfaceMask, cmIpv6OverIpv4TunnelAssociatedIpv4Interface=cmIpv6OverIpv4TunnelAssociatedIpv4Interface, cmIpInitiateTraceRouteAction=cmIpInitiateTraceRouteAction, cmIpv6OverIpv4TunnelStorageType=cmIpv6OverIpv4TunnelStorageType, ipManagementTunnelDhcpVendorInfo=ipManagementTunnelDhcpVendorInfo, cmStaticRouteMetric=cmStaticRouteMetric, cmIpProxyARPEnabled=cmIpProxyARPEnabled, ipManagementTunnelIpv6StateAddrAutoConfigEnabled=ipManagementTunnelIpv6StateAddrAutoConfigEnabled, cmIpInterfaceDhcpRole=cmIpInterfaceDhcpRole, cmNDPMacAddress=cmNDPMacAddress, ipManagementTunnelDhcpClientIdType=ipManagementTunnelDhcpClientIdType, cmIpConformance=cmIpConformance, ipManagementTunnelPhysicalAddress=ipManagementTunnelPhysicalAddress, ipManagementTunnelSVlanId=ipManagementTunnelSVlanId, cmIpObjects=cmIpObjects, cmIpPingResult=cmIpPingResult, ipCompliance=ipCompliance, cmIpv6InitiateTraceRouteAction=cmIpv6InitiateTraceRouteAction, cmIpInterfaceDhcpVendorInfo=cmIpInterfaceDhcpVendorInfo, ipCompliances=ipCompliances, cmIpManagementTrafficBridgingIpv6Gateway=cmIpManagementTrafficBridgingIpv6Gateway, cmIpInitiatePingAction=cmIpInitiatePingAction, cmIpPtpArpRtrvAction=cmIpPtpArpRtrvAction, cmIpSourceAddressType=cmIpSourceAddressType, cmIpSourceAddressInterfaceName=cmIpSourceAddressInterfaceName, cmIpInterfaceEntry=cmIpInterfaceEntry, cmIpv6UnicastAddrPrefixLen=cmIpv6UnicastAddrPrefixLen, cmIpInterfaceDHCPClientId=cmIpInterfaceDHCPClientId, cmProxyNDPTable=cmProxyNDPTable, cmIpv6StaticRoutePrefixLen=cmIpv6StaticRoutePrefixLen, cmIpv6PrefixAdvertiseEnabled=cmIpv6PrefixAdvertiseEnabled, IpEntryType=IpEntryType, cmIpManagementTrafficBridgingSecurityEnabled=cmIpManagementTrafficBridgingSecurityEnabled, cmIpv6FwdEnabled=cmIpv6FwdEnabled, ipManagementTunnelStorageType=ipManagementTunnelStorageType, cmIpScalars=cmIpScalars, cmARPIndex=cmARPIndex, ipManagementTunnelIpv6Prefix=ipManagementTunnelIpv6Prefix, cmIpFlushNDPCacheAction=cmIpFlushNDPCacheAction, ipManagementTunnelCVlanEnabled=ipManagementTunnelCVlanEnabled, ipLoopbackInterfaceName=ipLoopbackInterfaceName, cmProxyARPIPAddress=cmProxyARPIPAddress, cmStaticRouteTable=cmStaticRouteTable, ipManagementTunnelDHCPClientId=ipManagementTunnelDHCPClientId, cmIpv6StaticRouteAdvertise=cmIpv6StaticRouteAdvertise, cmNDPTable=cmNDPTable, cmStaticRouteEntry=cmStaticRouteEntry, cmIpv6OverIpv4TunnelIpv6UnicastAddress=cmIpv6OverIpv4TunnelIpv6UnicastAddress, cmIpInterfaceDhcpVendorInfoType=cmIpInterfaceDhcpVendorInfoType, cmIpTraceRouteInterface=cmIpTraceRouteInterface, cmIpv6UnicastAddr=cmIpv6UnicastAddr, ipManagementTunnelDhcpEnabled=ipManagementTunnelDhcpEnabled, cmIpv6RAPrefix=cmIpv6RAPrefix, Ipv6OverIpv4TunnelType=Ipv6OverIpv4TunnelType, cmIpInterfaceDHCPClientIdEnabled=cmIpInterfaceDHCPClientIdEnabled, cmIpInterfaceDhcpHostNameType=cmIpInterfaceDhcpHostNameType, IpSourceAddrType=IpSourceAddrType, ipManagementTunnelName=ipManagementTunnelName, cmIpv6StaticRouteRowStatus=cmIpv6StaticRouteRowStatus, ipManagementTunnellinkLocIpv6Addr=ipManagementTunnellinkLocIpv6Addr, cmNDPInterface=cmNDPInterface, DHCPHostNameType=DHCPHostNameType, cmIpInterfaceMask=cmIpInterfaceMask, ipManagementTunnelDhcpHostNameEnabled=ipManagementTunnelDhcpHostNameEnabled, ipManagementTunnelDhcpVendorInfoHideControl=ipManagementTunnelDhcpVendorInfoHideControl, PtpArpActionType=PtpArpActionType, cmIpManagementTrafficBridgingIpv4Gateway=cmIpManagementTrafficBridgingIpv4Gateway, cmIpInterfaceDhcpHostName=cmIpInterfaceDhcpHostName, cmIpv6OverIpv4TunnelTable=cmIpv6OverIpv4TunnelTable, cmIpv6OverIpv4TunnelType=cmIpv6OverIpv4TunnelType, cmIpv6ProxyNDPEnabled=cmIpv6ProxyNDPEnabled, ipManagementTunnelEntry=ipManagementTunnelEntry, cmIpInterfaceDhcpVendorInfoEnabled=cmIpInterfaceDhcpVendorInfoEnabled, cmStaticRouteDest=cmStaticRouteDest, cmNDPStorageType=cmNDPStorageType, cmIpManagementTrafficBridgingInterface=cmIpManagementTrafficBridgingInterface, cmIpTraceRouteResult=cmIpTraceRouteResult, cmIPMIB=cmIPMIB, ipManagementTunnelType=ipManagementTunnelType, ipManagementTunnelSVlanEnabled=ipManagementTunnelSVlanEnabled, cmIpManagementTrafficBridgingEnabled=cmIpManagementTrafficBridgingEnabled, ipManagementTunnelIpv6RipngEnabled=ipManagementTunnelIpv6RipngEnabled, ipGroups=ipGroups, cmIpManagementTrafficDscpEnabled=cmIpManagementTrafficDscpEnabled, ipManagementTunnelIpv6Address=ipManagementTunnelIpv6Address, ipManagementTunnelIpv6PrefixAdvertiseEnabled=ipManagementTunnelIpv6PrefixAdvertiseEnabled, cmIpInterfaceDhcpVendorInfoHideControl=cmIpInterfaceDhcpVendorInfoHideControl, cmProxyNDPIpv6Address=cmProxyNDPIpv6Address, cmStaticRouteAdvertise=cmStaticRouteAdvertise, cmProxyNDPRowStatus=cmProxyNDPRowStatus, cmIpv6OverIpv4TunnelName=cmIpv6OverIpv4TunnelName, ipManagementTunnelCIR=ipManagementTunnelCIR, cmIpInterfaceGateway=cmIpInterfaceGateway, cmStaticRouteNextHop=cmStaticRouteNextHop, cmARPStorageType=cmARPStorageType, ipManagementTunnelDHCPClientIdEnabled=ipManagementTunnelDHCPClientIdEnabled, cmIpv6InterfaceMTU=cmIpv6InterfaceMTU, ipManagementTunnelIpv6PrefixLen=ipManagementTunnelIpv6PrefixLen, ipv6Group=ipv6Group, cmARPInterface=cmARPInterface, ipManagementTunnelIndex=ipManagementTunnelIndex, cmIpv6PingDestination=cmIpv6PingDestination, cmIpInterfaceDhcpLogServerEnabled=cmIpInterfaceDhcpLogServerEnabled, ipManagementTunnelIpAddress=ipManagementTunnelIpAddress, ipManagementTunnelEncapsulationType=ipManagementTunnelEncapsulationType, cmIpv6OverIpv4PotentialRouterList=cmIpv6OverIpv4PotentialRouterList, cmIpv6RIPngEnabled=cmIpv6RIPngEnabled, cmARPRowStatus=cmARPRowStatus, ipManagementTunnelDhcpVendorInfoEnabled=ipManagementTunnelDhcpVendorInfoEnabled, cmIpv6LinkLocAddrPrefixLen=cmIpv6LinkLocAddrPrefixLen, cmStaticRouteMask=cmStaticRouteMask, IpMode=IpMode, ipLoopbackInterfaceRowStatus=ipLoopbackInterfaceRowStatus, cmIpv6InterfaceEntry=cmIpv6InterfaceEntry, IpActionType=IpActionType, cmNDPEntryType=cmNDPEntryType, cmIpTraceRouteDestination=cmIpTraceRouteDestination, ipManagementTunnelDhcpLogServerEnabled=ipManagementTunnelDhcpLogServerEnabled, ipManagementTunnelDhcpHostName=ipManagementTunnelDhcpHostName, ipManagementTunnelDhcpHostNameType=ipManagementTunnelDhcpHostNameType, cmIpv6StaticRouteNextHop=cmIpv6StaticRouteNextHop, ipManagementTunnelIpMode=ipManagementTunnelIpMode, cmIpInterfaceDhcpNTPServerEnabled=cmIpInterfaceDhcpNTPServerEnabled, ipManagementTunnelQosQueueProfile=ipManagementTunnelQosQueueProfile, cmIpv6OverIpv4TunnelEntry=cmIpv6OverIpv4TunnelEntry, cmNDPIpv6Address=cmNDPIpv6Address, ipLoopbackInterfaceIpMode=ipLoopbackInterfaceIpMode, cmARPIPAddress=cmARPIPAddress, cmIpv6RAPrefixLength=cmIpv6RAPrefixLength, cmIpv6TraceRouteInterface=cmIpv6TraceRouteInterface, cmARPEntry=cmARPEntry, ipManagementTunnelDHCPv6Enabled=ipManagementTunnelDHCPv6Enabled, cmProxyNDPStorageType=cmProxyNDPStorageType, ipManagementTunnelAssociatedPort=ipManagementTunnelAssociatedPort, ipGroup=ipGroup, cmProxyARPStorageType=cmProxyARPStorageType, cmIpv6DhcpEnabled=cmIpv6DhcpEnabled, ipManagementTunnelCOS=ipManagementTunnelCOS, ipLoopbackInterfaceIpv6AddrPrefixLen=ipLoopbackInterfaceIpv6AddrPrefixLen, ipManagementTunnelIpv6AddrPrefixLen=ipManagementTunnelIpv6AddrPrefixLen, cmIpv6PingInterface=cmIpv6PingInterface, cmIpInterfaceDhcpClassIdEnabled=cmIpInterfaceDhcpClassIdEnabled, cmStaticRouteInterface=cmStaticRouteInterface, cmIpv6StaticRouteMetric=cmIpv6StaticRouteMetric, cmPingInterface=cmPingInterface, cmIpv6StaticRouteTable=cmIpv6StaticRouteTable, cmIpInterfaceRIPv2Enabled=cmIpInterfaceRIPv2Enabled, cmIpSystemScalars=cmIpSystemScalars, cmIpv6StateAddrAutoConfigEnabled=cmIpv6StateAddrAutoConfigEnabled, cmIpv6TraceRouteDestination=cmIpv6TraceRouteDestination, cmIpv6StaticRouteEntry=cmIpv6StaticRouteEntry, cmProxyARPEntry=cmProxyARPEntry, cmIpInterfaceDhcpClientIdType=cmIpInterfaceDhcpClientIdType, cmProxyARPRowStatus=cmProxyARPRowStatus, cmIpInterfacePhysicalAddress=cmIpInterfacePhysicalAddress, ipManagementTunnellinkLocIpv6AddrPrefixLen=ipManagementTunnellinkLocIpv6AddrPrefixLen, cmNDPEntry=cmNDPEntry, ipLoopbackInterfaceTable=ipLoopbackInterfaceTable, ipManagementTunnelVlanId=ipManagementTunnelVlanId, cmARPTable=cmARPTable, ipManagementTunnelDhcpNTPServerEnabled=ipManagementTunnelDhcpNTPServerEnabled, cmProxyARPIndex=cmProxyARPIndex, cmIpInterfaceIpMode=cmIpInterfaceIpMode, cmProxyNDPIpv6PrefixLen=cmProxyNDPIpv6PrefixLen, ipManagementTunnelDhcpClassIdEnabled=ipManagementTunnelDhcpClassIdEnabled, IpManagementTunnelEncapsulationType=IpManagementTunnelEncapsulationType, cmIpInterface=cmIpInterface, ipManagementTunnelTable=ipManagementTunnelTable, ipManagementTunnelDhcpVendorInfoType=ipManagementTunnelDhcpVendorInfoType, cmIpManagementTrafficDscp=cmIpManagementTrafficDscp, CmDhcpRole=CmDhcpRole, cmIpv6LinkLocAddr=cmIpv6LinkLocAddr, cmIpv6OverIpv4TunnelDestIpv4Addr=cmIpv6OverIpv4TunnelDestIpv4Addr, cmIpv6InitiatePingAction=cmIpv6InitiatePingAction, ipLoopbackInterfaceIndex=ipLoopbackInterfaceIndex, cmProxyNDPInterface=cmProxyNDPInterface, cmIpv6OverIpv4TunnelRowStatus=cmIpv6OverIpv4TunnelRowStatus, ipManagementTunnelRip2PktsEnabled=ipManagementTunnelRip2PktsEnabled, cmStaticRouteRowStatus=cmStaticRouteRowStatus, cmIpv6DhcpRole=cmIpv6DhcpRole, cmNDPRowStatus=cmNDPRowStatus, cmIpv6InterfaceTable=cmIpv6InterfaceTable, DHCPCIDType=DHCPCIDType, cmIpv6StaticRouteInterface=cmIpv6StaticRouteInterface, cmIpSourceAddrScalars=cmIpSourceAddrScalars, cmIpv6OverIpv4TunnelIndex=cmIpv6OverIpv4TunnelIndex, ipManagementTunnelBufferSize=ipManagementTunnelBufferSize, cmARPEntryType=cmARPEntryType, ipManagementTunnelRowStatus=ipManagementTunnelRowStatus, ipLoopbackInterfaceStorageType=ipLoopbackInterfaceStorageType, DHCPVendorInfoType=DHCPVendorInfoType, cmIpFlushARPCacheAction=cmIpFlushARPCacheAction, cmProxyARPInterface=cmProxyARPInterface, cmIpInterfaceDhcpEnabled=cmIpInterfaceDhcpEnabled, ipManagementTunnelSharedVim=ipManagementTunnelSharedVim, cmProxyARPTable=cmProxyARPTable, cmIpInterfaceName=cmIpInterfaceName, PYSNMP_MODULE_ID=cmIPMIB, ipLoopbackInterfaceEntry=ipLoopbackInterfaceEntry, ipLoopbackInterfaceIpAddress=ipLoopbackInterfaceIpAddress, cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen=cmIpv60verIpv4TunnelLinkLocalAddrPrefixLen, cmIpInterfaceMTU=cmIpInterfaceMTU, cmIpSNMPv1InterfaceName=cmIpSNMPv1InterfaceName, cmIpv6StaticRouteDest=cmIpv6StaticRouteDest, cmIpv6InterfaceGateway=cmIpv6InterfaceGateway)
