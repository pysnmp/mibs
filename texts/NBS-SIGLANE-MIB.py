#
# PySNMP MIB module NBS-SIGLANE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/mrv/NBS-SIGLANE-MIB
# Produced by pysmi-1.1.3 at Wed Dec  8 18:54:18 2021
# On host fv-az121-73 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
NbsCmmcChannelBand, = mibBuilder.importSymbols("NBS-CMMCENUM-MIB", "NbsCmmcChannelBand")
NbsTcMicroAmp, NbsTcMHz, NbsTcTemperature, nbs, NbsTcMilliDb = mibBuilder.importSymbols("NBS-MIB", "NbsTcMicroAmp", "NbsTcMHz", "NbsTcTemperature", "nbs", "NbsTcMilliDb")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, MibIdentifier, Gauge32, ObjectIdentity, Counter32, iso, Counter64, IpAddress, Integer32, Unsigned32, Bits, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "Gauge32", "ObjectIdentity", "Counter32", "iso", "Counter64", "IpAddress", "Integer32", "Unsigned32", "Bits", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
nbsSigLaneMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 629, 236))
if mibBuilder.loadTexts: nbsSigLaneMib.setLastUpdated('201710180000Z')
if mibBuilder.loadTexts: nbsSigLaneMib.setOrganization('NBS')
if mibBuilder.loadTexts: nbsSigLaneMib.setContactInfo('For technical support, please contact your service channel')
if mibBuilder.loadTexts: nbsSigLaneMib.setDescription('Signaling Lane mib - objects for the management of multi-lane\n        ports such as QSFP, CXP, and CFP.')
nbsSigLanePortGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 10))
if mibBuilder.loadTexts: nbsSigLanePortGrp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortGrp.setDescription('Ports which aggregate multiple signaling lanes')
nbsSigLaneLaneGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 20))
if mibBuilder.loadTexts: nbsSigLaneLaneGrp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneGrp.setDescription('Individual signaling lanes within a port')
nbsSigLaneTraps = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 100))
if mibBuilder.loadTexts: nbsSigLaneTraps.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneTraps.setDescription('OBJECT-TYPE macros to be used in SNMP NOTIFICATION macros')
nbsSigLaneTraps0 = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 236, 100, 0))
if mibBuilder.loadTexts: nbsSigLaneTraps0.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneTraps0.setDescription('NOTIFICATION-TYPE macros')
nbsSigLanePortTable = MibTable((1, 3, 6, 1, 4, 1, 629, 236, 10, 1), )
if mibBuilder.loadTexts: nbsSigLanePortTable.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortTable.setDescription('A table that describes signaling lanes for a QSFP[+] or CFP port.')
nbsSigLanePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1), ).setIndexNames((0, "NBS-SIGLANE-MIB", "nbsSigLanePortIfIndex"))
if mibBuilder.loadTexts: nbsSigLanePortEntry.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortEntry.setDescription('Contains a description of a particular port signaling lane.')
nbsSigLanePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortIfIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortIfIndex.setDescription('The index to the MIB-II Interface table entry which represents this\n        port.  This value should be 0 if there is no corresponding MIB-II\n        interface entry.')
nbsSigLanePortFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("fiber", 2), ("lambda", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortFacility.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortFacility.setDescription('fiber(2) indicates that lane signaling is conducted on separate\n        fibers.\n\n        lambda(3) indicates that lane signaling is conducted on different\n        wavelengths on a single SMF fiber.')
nbsSigLanePortLanes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 10, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLanePortLanes.setStatus('current')
if mibBuilder.loadTexts: nbsSigLanePortLanes.setDescription('The number of signaling lanes in this port')
nbsSigLaneLaneTable = MibTable((1, 3, 6, 1, 4, 1, 629, 236, 20, 1), )
if mibBuilder.loadTexts: nbsSigLaneLaneTable.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTable.setDescription('A table that describes (fiber/lambda) network signaling lanes for a\n        multi-lane port.')
nbsSigLaneLaneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1), ).setIndexNames((0, "NBS-SIGLANE-MIB", "nbsSigLaneLaneIfIndex"), (0, "NBS-SIGLANE-MIB", "nbsSigLaneLaneIndex"))
if mibBuilder.loadTexts: nbsSigLaneLaneEntry.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEntry.setDescription('Contains a description of a particular (fiber/lambda) signaling lane.')
nbsSigLaneLaneIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneIfIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneIfIndex.setDescription('The index to the MIB-II Interface table entry which contains this\n        (fiber/lambda) lane.')
nbsSigLaneLaneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneIndex.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneIndex.setDescription('Ordinal index for the signaling lane in a port:\n            1..4  for QSFP[+] 4 x 10G\n            1..4  for CFP 4 x 25G\n            1..4  for CFP 4 x 28G\n            1..10 for CFP 10 x 10G')
nbsSigLaneLaneFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 10), NbsTcMHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneFrequency.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneFrequency.setDescription('The nominal frequency, in MHz.')
nbsSigLaneLaneWavelengthX = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneWavelengthX.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneWavelengthX.setDescription("The nominal wavelength (nanometers) is an ASCII string\n        to be human-readable. CWDM wavelengths use 4 digits.\n        DWDM wavelengths use seven digits and a decimal point.\n\n        Not supported value: 'N/A'")
nbsSigLaneLaneChannelBand = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 12), NbsCmmcChannelBand()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneChannelBand.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneChannelBand.setDescription("The ITU grid labels DWDM channels with a letter 'band' and a\n           numeric channel.  Within this mib, the band is indicated by\n           this object, and the channel number is shown in the object\n           nbsOsaChannelNumber.\n\n           Frequencies of at least 180100 GHz but less than 190100 GHz\n           are considered the L spectrum, and frequencies of at least\n           190100 but less than 200100 GHz are considered the C spectrum.\n\n           Frequencies evenly divisible by 100 GHz are designated with\n           a 'C' or 'L' prepended to the channel number.  Frequencies\n           that are offset by 50 GHz are designated 'H' within the C\n           spectrum, and 'Q' within the L spectrum.")
nbsSigLaneLaneChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneChannelNumber.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneChannelNumber.setDescription('The channel number can be derived by extracting the two middle\n           digits from the six digit frequency in GHz.')
nbsSigLaneLaneTxDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("no", 2), ("yes", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsSigLaneLaneTxDisable.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxDisable.setDescription("This object controls the lane's transmitter:\n\n        notSupported(1), returned if transmitter not configurable, i.e. always\n          enabled;\n\n        no(2), to enable the transmitter;\n\n        yes(3), to disable the transmitter")
nbsSigLaneLaneFaultsCaps = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneFaultsCaps.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneFaultsCaps.setDescription('This object specifies the supported nbsSigLaneLaneFaultsOper bit(s).\n\n        A zero length OCTET STRING indicates this information is not provided.')
nbsSigLaneLaneFaultsOper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneFaultsOper.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneFaultsOper.setDescription('This object provides operational lane fault conditions:\n\n        The first octet provides Tx information:\n\n            Bit 0: Tx LOS if set\n\n            Bit 1: Tx Fault if set\n\n            Bit 2: Tx LOL if set\n\n            Bit 3: Tx Adaptive EQ Fault if set\n\n        The second octet provides Rx information:\n\n            Bit 0: Rx LOS if set\n\n            Bit 2: Rx LOL if set\n\n        OCTET STRING bitmasks count the leftmost bit (MSB) as 0.\n\n        A zero length OCTET STRING indicates this information is not provided.')
nbsSigLaneLaneTxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerLevel.setDescription("This object indicates the status of this lane's\n        measured received power, reported in nbsSigLaneLaneTxPower:\n\n        notSupported(1), if (nbsSigLaneLaneTxPower = 0x80000000);\n\n        lowAlarm(2),\n          if nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerVendorMin;\n\n        lowWarning(3),\n          if nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerVendorMin\n          and nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerUserMin;\n\n        ok(4), if nbsSigLaneLaneTxPower is within thresholds;\n\n        highWarning(5),\n          if nbsSigLaneLaneTxPower < nbsSigLanePortTxPowerVendorMax\n          and nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerUserMax;\n\n        highAlarm(6),\n          if nbsSigLaneLaneTxPower > nbsSigLanePortTxPowerVendorMax")
nbsSigLaneLaneTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 21), NbsTcMilliDb().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneTxPower.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxPower.setDescription('The output power (in milli dBm) of this lane.\n\n        Not supported value: 0x80000000')
nbsSigLaneLaneTxPowerAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 22), NbsTcMilliDb().clone(-2147483648)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneTxPowerAdmin.setDescription('The desired output power (in milli dBm) for this lane; the value\n        should be within the supported bounds of the given pluggable.\n        For a CFP/CFP2 supporting configurable Tx power, this is applied\n        in the corresponding MSA B41x register.\n\n        Not supported value: 0x80000000')
nbsSigLaneLaneRxPowerLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneRxPowerLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneRxPowerLevel.setDescription("This object indicates the status of this lane's\n        measured received power, reported in nbsSigLaneLaneRxPower:\n\n        notSupported(1), if (nbsSigLaneLaneRxPower = 0x80000000);\n\n        lowAlarm(2),\n          if nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerVendorMin;\n\n        lowWarning(3),\n          if nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerVendorMin\n          and nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerUserMin;\n\n        ok(4), if nbsSigLaneLaneRxPower is within thresholds;\n\n        highWarning(5),\n          if nbsSigLaneLaneRxPower < nbsSigLanePortRxPowerVendorMax\n          and nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerUserMax;\n\n        highAlarm(6),\n          if nbsSigLaneLaneRxPower > nbsSigLanePortRxPowerVendorMax")
nbsSigLaneLaneRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 31), NbsTcMilliDb().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneRxPower.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneRxPower.setDescription('The received optical power (in milli dBm) of this lane.\n\n        Not supported value: 0x80000000')
nbsSigLaneLaneBiasAmpsLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmpsLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmpsLevel.setDescription('This object indicates the status of laser bias current,\n        as reported in nbsSigLaneLaneBiasAmps:\n\n        notSupported(1), if (nbsSigLaneLaneBiasAmps = -1);\n\n        lowAlarm(2), if below nbsSigLanePortBiasAmpsVendorMin;\n\n        ok(4), if within the recommended operating range;\n\n        highAlarm(6), if above nbsSigLanePortBiasAmpsVendorMax.')
nbsSigLaneLaneBiasAmps = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 41), NbsTcMicroAmp().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmps.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneBiasAmps.setDescription('The bias current (in microAmps) of this lane.\n\n        Not supported value: -1')
nbsSigLaneLaneLaserTempLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("notSupported", 1), ("lowAlarm", 2), ("lowWarning", 3), ("ok", 4), ("highWarning", 5), ("highAlarm", 6))).clone('ok')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTempLevel.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTempLevel.setDescription('This object indicates the status of laser temperature,\n        as reported in nbsSigLaneLaneLaserTemp:\n\n        notSupported(1), if (nbsSigLaneLaneLaserTemp = 0x80000000);\n\n        lowAlarm(2), if below nbsSigLanePortLaserTempVendorMin;\n\n        ok(4), if within the recommended operating range;\n\n        highAlarm(6), if above nbsSigLanePortLaserTempVendorMax.')
nbsSigLaneLaneLaserTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 51), NbsTcTemperature().clone(-2147483648)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTemp.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneLaserTemp.setDescription('The temperature (in degrees Celsius) of this lane.\n\n        Not supported value: 0x80000000')
nbsSigLaneLaneEthTxAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 60), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneEthTxAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEthTxAllOctets.setDescription('The count of bytes in all Ethernet frames transmitted.\n\n        Not supported value: 0xFFFFFFFFFFFFFFFF')
nbsSigLaneLaneEthTxAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 61), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneEthTxAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEthTxAllFrames.setDescription('The count of all Ethernet frames transmitted.\n\n        Not supported value: 0xFFFFFFFFFFFFFFFF')
nbsSigLaneLaneEthRxAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 70), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneEthRxAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEthRxAllOctets.setDescription('The count of bytes in all Ethernet frames received.\n\n        Not supported value: 0xFFFFFFFFFFFFFFFF')
nbsSigLaneLaneEthRxAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 236, 20, 1, 1, 71), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsSigLaneLaneEthRxAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsSigLaneLaneEthRxAllFrames.setDescription('The count of all Ethernet frames received.\n\n        Not supported value: 0xFFFFFFFFFFFFFFFF')
mibBuilder.exportSymbols("NBS-SIGLANE-MIB", nbsSigLaneMib=nbsSigLaneMib, nbsSigLaneLaneTxPowerLevel=nbsSigLaneLaneTxPowerLevel, nbsSigLaneTraps=nbsSigLaneTraps, nbsSigLanePortLanes=nbsSigLanePortLanes, nbsSigLaneLaneEntry=nbsSigLaneLaneEntry, nbsSigLaneLaneLaserTempLevel=nbsSigLaneLaneLaserTempLevel, nbsSigLanePortEntry=nbsSigLanePortEntry, nbsSigLaneLaneTxPowerAdmin=nbsSigLaneLaneTxPowerAdmin, nbsSigLaneLaneGrp=nbsSigLaneLaneGrp, nbsSigLaneLaneEthTxAllOctets=nbsSigLaneLaneEthTxAllOctets, nbsSigLanePortTable=nbsSigLanePortTable, PYSNMP_MODULE_ID=nbsSigLaneMib, nbsSigLaneLaneRxPower=nbsSigLaneLaneRxPower, nbsSigLanePortGrp=nbsSigLanePortGrp, nbsSigLaneTraps0=nbsSigLaneTraps0, nbsSigLaneLaneIfIndex=nbsSigLaneLaneIfIndex, nbsSigLaneLaneFaultsOper=nbsSigLaneLaneFaultsOper, nbsSigLaneLaneTxPower=nbsSigLaneLaneTxPower, nbsSigLaneLaneChannelNumber=nbsSigLaneLaneChannelNumber, nbsSigLaneLaneTxDisable=nbsSigLaneLaneTxDisable, nbsSigLaneLaneChannelBand=nbsSigLaneLaneChannelBand, nbsSigLaneLaneBiasAmps=nbsSigLaneLaneBiasAmps, nbsSigLanePortIfIndex=nbsSigLanePortIfIndex, nbsSigLaneLaneIndex=nbsSigLaneLaneIndex, nbsSigLaneLaneFaultsCaps=nbsSigLaneLaneFaultsCaps, nbsSigLaneLaneBiasAmpsLevel=nbsSigLaneLaneBiasAmpsLevel, nbsSigLaneLaneEthRxAllFrames=nbsSigLaneLaneEthRxAllFrames, nbsSigLaneLaneFrequency=nbsSigLaneLaneFrequency, nbsSigLaneLaneEthTxAllFrames=nbsSigLaneLaneEthTxAllFrames, nbsSigLaneLaneRxPowerLevel=nbsSigLaneLaneRxPowerLevel, nbsSigLaneLaneTable=nbsSigLaneLaneTable, nbsSigLaneLaneLaserTemp=nbsSigLaneLaneLaserTemp, nbsSigLanePortFacility=nbsSigLanePortFacility, nbsSigLaneLaneWavelengthX=nbsSigLaneLaneWavelengthX, nbsSigLaneLaneEthRxAllOctets=nbsSigLaneLaneEthRxAllOctets)
