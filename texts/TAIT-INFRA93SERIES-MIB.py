#
# PySNMP MIB module TAIT-INFRA93SERIES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/tait/TAIT-INFRA93SERIES-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 10:14:55 2024
# On host fv-az801-864 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Integer32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Unsigned32, NotificationType, Counter64, Counter32, MibIdentifier, ModuleIdentity, TimeTicks, iso, ObjectIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Unsigned32", "NotificationType", "Counter64", "Counter32", "MibIdentifier", "ModuleIdentity", "TimeTicks", "iso", "ObjectIdentity", "Bits")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
taitGeneric, = mibBuilder.importSymbols("TAIT-COMMON-MIB", "taitGeneric")
infra93_94MibModule, = mibBuilder.importSymbols("TAIT-INFRA93-94SERIES-COMMON-MIB", "infra93-94MibModule")
TransmitterStatus, OptionState, TimingControlType, Condition, FrequencyHz, CurrentmA, PowerW, ChannelGroupStatus, GateState, VoltageV, BaseStationMode, AlarmState, Milliseconds = mibBuilder.importSymbols("TAIT-INFRA93-94SERIES-TC-MIB", "TransmitterStatus", "OptionState", "TimingControlType", "Condition", "FrequencyHz", "CurrentmA", "PowerW", "ChannelGroupStatus", "GateState", "VoltageV", "BaseStationMode", "AlarmState", "Milliseconds")
SubAudibleType, MPTControlProtocolStatus, FrequencydHz, TxFrequencyResponse, SINADLevel, RxFrequencyResponse, DcsCode, StandaloneNodeStatus, FallbackNodeStatus, ReceiverSyncStatus, ControlProtocolStatus, OperationalMode, LeveldBm, TransmitterSyncStatus, ColourCode, LogicalChannelState, Ratio, Temperature = mibBuilder.importSymbols("TAIT-INFRA93SERIES-TC-MIB", "SubAudibleType", "MPTControlProtocolStatus", "FrequencydHz", "TxFrequencyResponse", "SINADLevel", "RxFrequencyResponse", "DcsCode", "StandaloneNodeStatus", "FallbackNodeStatus", "ReceiverSyncStatus", "ControlProtocolStatus", "OperationalMode", "LeveldBm", "TransmitterSyncStatus", "ColourCode", "LogicalChannelState", "Ratio", "Temperature")
infra93MibMonitored = ModuleIdentity((1, 3, 6, 1, 4, 1, 3570, 1, 1, 10, 2))
infra93MibMonitored.setRevisions(('2019-08-30 15:38', '2019-05-29 00:00', '2019-03-30 00:00', '2018-08-30 00:00', '2018-07-30 00:00', '2018-05-22 00:26', '2017-09-14 01:30', '2017-08-24 14:00', '2017-05-05 15:00', '2017-03-07 00:00', '2017-02-03 00:00', '2016-12-05 00:00', '2016-07-01 00:00', '2016-02-18 00:00', '2015-11-03 04:00', '2015-03-23 04:00', '2014-10-30 15:00', '2014-07-29 00:00', '2014-07-10 00:00', '2014-04-14 00:00', '2014-04-13 00:00', '2014-03-14 00:00', '2014-01-26 00:00', '2014-01-14 11:00', '2014-01-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: infra93MibMonitored.setRevisionsDescriptions(('Version 1.24.00 - Added linearTransmissionCapability object group.\n                                     - This group is optional and will be present only for systems\n                                       equipped with a linear power amplifier.\n                                     - This group contains the following alarms:\n                                       rctAlarmTxRSynthOutOfLock\n                                       systemAlarmCartesianLoopUnstable\n                                       systemAlarmTxRCableAbsent\n                                   - Added optional pmuInfoGroup object group.\n\t\t\t\t   - pmuAlarmsGroup and pmuStateGroup are now optional.', 'Version 1.23.00 - Minor text revisions', 'Version 1.22.00 - healthNetworkConnLogChan1State, healthNetworkConnLogChan2State references updated', 'Version 1.21.00 - Added audio line configured levels, tx-key, rx-gate and rf repeat\n                                   - Added receiver disabled state monitored value.', 'Version 1.20.00 - Clarified the meaning of the configuration invalid alarm', 'Version 1.19.00 - Added new logical channel states TEST and POLL\n                                   - modified textual convention value for INVALID from 4 to 255', 'Version 1.18.00 - Add channel group name to current channel properties\n                                   - nwSvpPort Monitored value in the TB93XX series Base Stations', 'Version 1.17.00 - Two backup NTP servers added\n                                   - Added channelgroup properties - status, localBufferLevel, furthestBufferLevel, marshalingType, marshallingDuration, Receiver and Transmitter synchronization status/reason\n                                   - Added DMR Central Voter and DMR IP Networking Satellite licences\n                                   - Added single-base-station as an option for channelgroup status\n                                   - Added monitoring parameters for channelgroup network characteristics - \n                                     nwChannelGroupLateStreamsCount, nwChannelGroupOverflowCount, nwChannelGroupUnderflowCount\n                                     nwChannelGroupLostPacketsCount, nwChannelGroupJitter\n                                   - TX Buffer alarm added', 'Version 1.16.00 - Simulcast related alarms added', 'Version 1.15.00 - Fixed missing MAX-ACCESS entires on OIDs: linkInfoDMRNodeIPAddress, linkInfoDMRNodePriority, linkInfoMPTNodeIPAddress, linkInfoMPTNodePriority', 'Version 1.14.01 - Fixed missing MAX-ACCESS entires on OIDs: linkInfoDMRNodeIPAddress, linkInfoDMRNodePriority, linkInfoMPTNodeIPAddress, linkInfoMPTNodePriority', "Version 1.14.00 - Added support for MPT conventional fallback\n                                   - Added status of the MPT fallback node\n                                   - Added status of the DMR fallback node\n                                   - Added state of the receiver's analog gate\n                                   - Added the node controller IP addresses and priorities for DMR and MPT\n                                   - Added the colour code of the channel", 'Version 1.13.00 - Added configured Ntp server visibility\n                                   - Copied PMU State items from TB9400 MIB\n                                   - Updated DCS formatting description', 'Version 1.12.00 - Updated ControlProtocolStatus description tfor name change from dmr-rx-only to dmr-hibernate.\n                                   - Updated ControlProtocolStatus description to include dmr-tier2-aligned mode.\n                                   - Updated where logical receiver gating information comes from.', 'Version 1.11.00 - Fixed missing alarm getters for pa reverse power high, pa final 2 temperature high and pmu output current high\n                                   - Added licenceAnalogConventional\n                                   - Updated description for infoStandaloneNodeStatus\n                                   - updated alarm range descriptions\n                                   - added temperature for reciter board (rctTemperatureBoard)', 'Version 1.10.00 - Added DMR Conventional license state', 'Version 1.09.00 - Description text reviewed', 'Version 1.08.00 - Report the number of interference events', '1.07.00 - Able to monitor the running state of the secure shell interface', '1.06.00 - Add system alarms for TDMA', '1.05.00 - Added values for use during coverage testing', '1.04.01 - Modified description of the inactive logical channel state', '1.04.00 - Moved textual convention module identity OID to start at 1', '1.03.03 - Addition of interference counter and interference over threshold', 'These versions were recorded prior to utilization of the MODULE-IDENTITY change log:\n                   1.03.02 - Modified textual convention for states of logical channels, OFF(0)=>INACTIVE(0)\n                   1.03.01 - Updated description for dmr-two-slot-data now that it is supported\n                   1.03.00 - Addition of packet lost counters\n                   1.02.00 - Addition of licenses and module detail information\n                   1.00.04 - New standalone node alarms\n                             Two alarms have been added for the standalone node. This resulted in two new traps:\n                             systemFallbackControlled and systemDuplicateNodePriority. Also two new OIDs in the MIB:\n                             systemAlarmFallbackControlled and systemAlarmDuplicateNodePriority\n                   1.00.03 - Modifications to names of states\n                              ControlProtocolStatus:\n                                 offline(0) enum has been renamed to unconnected(0)\n                                 unconnected(1) enum has been DEPRECATED and will no longer be used by new base station\n                                                software.\n                                 idle(2) enum has been renamed to standby(2)\n\n                                 The consequences for mismatched old base stations with new MIBs and new base\n                                 stations with old MIBs are as follows:\n\n                                    Old base station queried with new MIBs in NMS:\n                                    offline(0)     => unconnected(0)\n                                    unconnected(1) => deprecated_unconnected(1)\n                                    idle(2)        => standby(2)\n\n                                    New base station queried with old MIBs in NMS:\n                                    unconnected(0) => offline(0)\n                                    standby(2) => idle(2)\n\n                              LogicalChannelState:\n                                 offline(0) enum has been renamed to off(0)\n\n                   1.00.02 - Initial version prior to change log entries',))
if mibBuilder.loadTexts: infra93MibMonitored.setLastUpdated('201908301538Z')
if mibBuilder.loadTexts: infra93MibMonitored.setOrganization('www.taitradio.com')
if mibBuilder.loadTexts: infra93MibMonitored.setContactInfo('Tait Communications\n                   245 Wooldridge Road\n                   PO Box 1645\n                   Christchurch\n                   New Zealand\n\n           phone:  +64 3358 3399\n           email:  support@taitradio.com')
if mibBuilder.loadTexts: infra93MibMonitored.setDescription('rctRfTransmitter, rctRfReceiver, rctSelectedChannel related Monitored values \n                   in the TB93XX series Base Stations')
infra93MIB = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2))
monitored = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2))
mibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1))
productInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1))
productSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1))
info = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 1))
health = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 2))
productEnabledFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2))
modules = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2))
reciter = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2))
rctSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1))
rctInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 1))
rctHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 2))
rctSelectedChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2))
rctRfReceiveQuality = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 3))
rctRfReceiver = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4))
rctRfTransmitter = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5))
rctTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 6))
rctSystemInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 7))
powerAmplifier = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3))
paSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1))
paInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 1))
paHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 2))
paTxOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 2))
paTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 4))
paGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 5))
powerManagementUnit = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4))
pmuSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1))
pmuInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1))
pmuHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 2))
pmuSubmodules = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 3))
pmuState = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2))
frontPanel = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5))
fpSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1))
fpInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 1))
fpHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 2))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3))
alarmSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1))
reciterAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3))
paAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4))
pmuAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5))
customAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6))
fpAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7))
systemAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8))
networkLinks = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4))
networkLinksSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1))
linkInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1))
linkHealth = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 2))
networkInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5))
nwNtpInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 1))
nwChannelGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2))
nwPorts = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 3))
mibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5))
mibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1))
mibCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 2))
licenceDmrFull = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 300), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrFull.setStatus('current')
if mibBuilder.loadTexts: licenceDmrFull.setDescription('DMR Full license. The base station is licensed for operation on a DMR Full system. \n                                           Range: true(1), false(2)')
licenceDmrExpress = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 302), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrExpress.setStatus('current')
if mibBuilder.loadTexts: licenceDmrExpress.setDescription('DMR Express 6 license. The base station is licensed for operation on a DMR Express system. \n                                           Range: true(1), false(2)')
licenceDmrAccess = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 303), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrAccess.setStatus('current')
if mibBuilder.loadTexts: licenceDmrAccess.setDescription('DMR Access license. The base station is licensed for operation on a DMR Access system. \n                                           Range: true(1), false(2)')
licenceDmrConventional = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 304), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrConventional.setStatus('current')
if mibBuilder.loadTexts: licenceDmrConventional.setDescription('DMR Conventional license. The base station is licensed for operation on a DMR concentional system. \n                                           Range: true(1), false(2)')
licenceAnalogConventional = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 301), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceAnalogConventional.setStatus('current')
if mibBuilder.loadTexts: licenceAnalogConventional.setDescription('Analog Conventional licence. The base station is licenced for Analog conventional operation\n                                           Range: true(1), false(2)')
licenceDmrExpress20 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 305), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrExpress20.setStatus('current')
if mibBuilder.loadTexts: licenceDmrExpress20.setDescription('DMR Express 20 license. The base station is licensed for operation on a DMR Express 20 system. \n                                           Range: true(1), false(2)')
licenceDmrCentralVoter = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 306), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrCentralVoter.setStatus('current')
if mibBuilder.loadTexts: licenceDmrCentralVoter.setDescription('DMR Central Voter license. The base station is licensed for operation as a DMR Central Voter. \n                                           Range: true(1), false(2)')
licenceDmrNetworkSatellite = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 2, 307), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceDmrNetworkSatellite.setStatus('current')
if mibBuilder.loadTexts: licenceDmrNetworkSatellite.setDescription('DMR IP Networking Satellite license. The base station is licensed for operation as a DMR IP\n                                           Networking satellite. \n                                           Range: true(1), false(2)')
infoTransmitterStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 1, 1), TransmitterStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoTransmitterStatus.setStatus('current')
if mibBuilder.loadTexts: infoTransmitterStatus.setDescription('The current status of the transmitter.\n\n                                           unknown(0): The transmitter is in an unknown, probably faulty state.\n                                           unconfigured(1): The transmitter requires configuration before it can transmit.\n                                           untuned(2): Something is wrong with the configuration, so the exciter is unable to set the selected frequency.\n                                           idle(3): The transmitter is not transmitting on either channel.\n                                           transmitting(4): The transmitter is actively transmitting.\n                                           calibrating(5): The transmitter is being calibrated.\n                                           fault(6): There is a detected fault with the transmitter.')
infoStandaloneNodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 1, 2), StandaloneNodeStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoStandaloneNodeStatus.setStatus('deprecated')
if mibBuilder.loadTexts: infoStandaloneNodeStatus.setDescription('The current status of standalone mode.\n                                           offline(0): A maintainer has taken the base station offline.  The base station is not under node control.\n                                           standby(1): The standalone node is enabled and ready to become active if the base station loses contact with the node.\n                                                       The standby state can also occur if the base station has lost contact with the node, but an activated major alarm at the base station prevents the standalone node from becoming active.\n                                           active(2): The base station has lost connection with the node and is in standalone node mode.\n                                           disabled(4): The standalone node feature is disabled in configuration.\n                                           running(5): The standalone node is contending with other embedded nodes on the site to take over as the master node.\n                                           master(6): The standalone node is acting as a master node and has set up a control channel on this base station.')
infoMPTFallbackNodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 1, 3), FallbackNodeStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoMPTFallbackNodeStatus.setStatus('current')
if mibBuilder.loadTexts: infoMPTFallbackNodeStatus.setDescription('The current status of the MPT fallback node.')
infoDMRFallbackNodeStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 1, 4), FallbackNodeStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: infoDMRFallbackNodeStatus.setStatus('current')
if mibBuilder.loadTexts: infoDMRFallbackNodeStatus.setDescription('The current status of the DMR fallback node.')
healthRunMode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 2, 2), BaseStationMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: healthRunMode.setStatus('current')
if mibBuilder.loadTexts: healthRunMode.setDescription('Indicates the current base station mode.\n                                           Offline means that a maintainer has taken the base station out of service.\n\n                                           offline(0): The base station is currently offline. It is out of service. It does not transmit or receive user traffic. It communicates with a web browser but not with nodes.\n                                           online(1): The base station is currently online. This is its normal operating mode.\n                                           unknown(2): The base station mode is unknown. This indicates a faulty condition.')
healthNetworkConnLogChan1State = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 2, 3), LogicalChannelState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: healthNetworkConnLogChan1State.setStatus('current')
if mibBuilder.loadTexts: healthNetworkConnLogChan1State.setDescription('Indicates the state of logical channel 1.\n\n                                           inactive(0): The logical channel is not transmitting.\n                                           idle(1): The logical channel is currently idle. It is not currently a traffic channel or a control channel.\n                                           traffic(2): The logical channel is currently operating as a traffic channel (voice/data).\n                                           control(3): The logical channel is currently operating as a control channel.\n                                           test(4): The logical channel is currently operating as a test channel.\n                                           poll(5): The logical channel is currently operating as a poll channel.\n                                           invalid(255): The logical channel configuration is invalid.')
healthNetworkConnLogChan2State = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 2, 4), LogicalChannelState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: healthNetworkConnLogChan2State.setStatus('current')
if mibBuilder.loadTexts: healthNetworkConnLogChan2State.setDescription('Indicates the state of logical channel 2.\n\n                                           inactive(0): The logical channel is not transmitting.\n                                           idle(1): The logical channel is currently idle. It is not currently a traffic channel or a control channel.\n                                           traffic(2): The logical channel is currently operating as a traffic channel (voice/data).\n                                           control(3): The logical channel is currently operating as a control channel.\n                                           test(4): The logical channel is currently operating as a test channel.\n                                           poll(5): The logical channel is currently operating as a poll channel.\n                                           invalid(255): The logical channel configuration is invalid.')
healthSecureShellRunning = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 1, 1, 2, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: healthSecureShellRunning.setStatus('current')
if mibBuilder.loadTexts: healthSecureShellRunning.setDescription('Indicates whether the remote secure shell interface is running.\n                                           Range: true(1), false(2)')
rctInfoProductCode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 1, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctInfoProductCode.setStatus('current')
if mibBuilder.loadTexts: rctInfoProductCode.setDescription('The reciter product code. Product codes are explained in the Specifications Manual.')
rctInfoSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: rctInfoSerialNumber.setDescription('The reciter serial number. A unique identifier assigned to the module in the factory.')
rctInfoHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctInfoHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: rctInfoHardwareVersion.setDescription('The reciter hardware version number.')
rctInfoFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctInfoFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: rctInfoFirmwareVersion.setDescription('The version number of the firmware currently installed on the Reciter.')
rctRfReceiverRSSI = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 1), LeveldBm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverRSSI.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverRSSI.setDescription('The current strength of the received signal in dBm.\n                                           Range: -12000..-6000')
rctRfReceiverLC1RSSI = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 2), LeveldBm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverLC1RSSI.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverLC1RSSI.setDescription('The current strength of the received signal on logical channel 1 in dBm.\n                                           Range: -12000..-6000')
rctRfReceiverLC2RSSI = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 3), LeveldBm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverLC2RSSI.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverLC2RSSI.setDescription('The current strength of the received signal on logical channel 2 in dBm.\n                                           Range: -12000..-6000')
rctRfReceiverLC1RxGateState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverLC1RxGateState.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverLC1RxGateState.setDescription('Receiver gate state of logical channel 1. Only valid if the logical channel has received anything since powering up.\n                                           Range: true(1), false(2)')
rctRfReceiverLC2RxGateState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverLC2RxGateState.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverLC2RxGateState.setDescription('Receiver gate state of logical channel 2. Only valid if the logical channel has received anything since powering up.\n                                           Range: true(1), false(2)')
rctRfReceiverSelectedDecodeCTCSS = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 8), FrequencydHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeCTCSS.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeCTCSS.setDescription('The CTCSS value that the base station unmutes to.')
rctRfReceiverSelectedDecodeSubAudibleType = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 9), SubAudibleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeSubAudibleType.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeSubAudibleType.setDescription('The configured receive sub-audible signaling type.')
rctRfReceiverSelectedSINADGatingLevel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 10), SINADLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverSelectedSINADGatingLevel.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverSelectedSINADGatingLevel.setDescription('The configured signal-to-noise gating threshold in dB.')
rctRfReceiverSelectedDecodeDCS = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 11), DcsCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeDCS.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverSelectedDecodeDCS.setDescription('The DCS value that the base station unmutes to.')
rctRfReceiverSelectedFrequencyResponse = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 12), RxFrequencyResponse()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverSelectedFrequencyResponse.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverSelectedFrequencyResponse.setDescription("Specifies the receive baseband frequency response that applies to the channel.\n                                           MPT Control channels have a flat speech charactieristic.\n                                           MPT Traffic channels have a de-emphasis characteristic.\n                                           Conventional analog channels take their setting from channel profile configuration.\n                                           'Flat speech' applies a constant gain to frequencies in the speech band (high pass above 300 Hz).\n                                           'De-emph speech' is a de-emphasis characteristic over the speech band (high pass above 300 Hz).")
rctRfReceiverAnalogGateState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverAnalogGateState.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverAnalogGateState.setDescription('Analog receiver gate state of the channel.\n                                           Range: true(1), false(2)')
rctRfReceiverIsDisabled = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 4, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfReceiverIsDisabled.setStatus('current')
if mibBuilder.loadTexts: rctRfReceiverIsDisabled.setDescription("Status of the receiver; if it is unavailable then the receiver can't be disabled in the current mode of operation.\n                                           Range: true(1), false(2)")
rctRfTxSelectedEncodeCTCSS = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 10), FrequencydHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxSelectedEncodeCTCSS.setStatus('current')
if mibBuilder.loadTexts: rctRfTxSelectedEncodeCTCSS.setDescription('The configured transmit CTCSS tone frequency in dHz.')
rctRfTxSelectedEncodeSubAudibleType = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 11), SubAudibleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxSelectedEncodeSubAudibleType.setStatus('current')
if mibBuilder.loadTexts: rctRfTxSelectedEncodeSubAudibleType.setDescription('The configured transmit sub-audible signaling type')
rctRfTxSelectFrequencyResponse = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 12), TxFrequencyResponse()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxSelectFrequencyResponse.setStatus('current')
if mibBuilder.loadTexts: rctRfTxSelectFrequencyResponse.setDescription("Specifies the transmit baseband frequency response that applies to the channel.\n                                           MPT Control channels have a flat speech charactieristic.\n                                           MPT Traffic channels have a pre-emphasis characteristic.\n                                           Conventional analog channels take their setting from channel profile configuration.\n                                           'Flat speech' applies a constant gain to frequencies in the speech band (high pass above 300 Hz).\n                                           'Pre-emph speech' is a pre-emphasis characteristic over the speech band (high pass above 300 Hz).")
rctRfTxSelectedEncodeDCS = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 13), DcsCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxSelectedEncodeDCS.setStatus('current')
if mibBuilder.loadTexts: rctRfTxSelectedEncodeDCS.setDescription('The DCS sub-audible signalling value that the base station applies while transmitting.')
rctRfTxSelectedEncodeSubAudibleDeviation = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxSelectedEncodeSubAudibleDeviation.setStatus('current')
if mibBuilder.loadTexts: rctRfTxSelectedEncodeSubAudibleDeviation.setDescription('The deviation that CTCSS or DCS signaling will cause to the carrier frequency. It is in Hz.')
rctRfTxRfRepeatState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 5, 16), OptionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfTxRfRepeatState.setStatus('current')
if mibBuilder.loadTexts: rctRfTxRfRepeatState.setDescription('The current RF repeat state.\n\n                                           disabled(0): RF is not repeated. The reciter acts as a base station.\n                                           enabled(1): RF is repeated. The reciter acts as a repeater.')
rctTemperatureBoard = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 6, 1), Temperature()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctTemperatureBoard.setStatus('current')
if mibBuilder.loadTexts: rctTemperatureBoard.setDescription('The reciter temperature in degrees Celsius, measured on the reciter circuit board.\n                                           Range: -30..125')
rctSiConfiguredBalancedLineInLevel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 7, 1), LeveldBm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSiConfiguredBalancedLineInLevel.setStatus('current')
if mibBuilder.loadTexts: rctSiConfiguredBalancedLineInLevel.setDescription('The configured level of the balanced line input in dBm.\n                                           Range: -30..0')
rctSiConfiguredBalancedLineOutLevel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 7, 2), LeveldBm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSiConfiguredBalancedLineOutLevel.setStatus('current')
if mibBuilder.loadTexts: rctSiConfiguredBalancedLineOutLevel.setDescription('The configured level of the balanced line output in dBm.\n                                           Range: -30..0')
rctSiTxKey = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 7, 3), GateState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSiTxKey.setStatus('current')
if mibBuilder.loadTexts: rctSiTxKey.setDescription('The state of the Tx key input.\n                                           Range: Active(1), Inactive(2)')
rctSiRxGate = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 7, 4), GateState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSiRxGate.setStatus('current')
if mibBuilder.loadTexts: rctSiRxGate.setDescription('The state of the Rx Gate output.\n                                           Range: Active(1), Inactive(2)')
paInfoProductCode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 1, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paInfoProductCode.setStatus('current')
if mibBuilder.loadTexts: paInfoProductCode.setDescription('The power amplifier product code. Product codes are explained in the Specifications Manual.')
paInfoSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: paInfoSerialNumber.setDescription('Power amplifier serial number. A unique identifier assigned to the module in the factory.')
paInfoHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paInfoHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: paInfoHardwareVersion.setDescription('The power amplifier hardware version number.')
paInfoFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paInfoFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: paInfoFirmwareVersion.setDescription('The version number of the firmware currently installed on the power amplifier.')
fpInfoProductCode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 1, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpInfoProductCode.setStatus('current')
if mibBuilder.loadTexts: fpInfoProductCode.setDescription('The product code for the front panel.')
fpInfoSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: fpInfoSerialNumber.setDescription('Front panel serial number. A unique identifier assigned to the front panel in the factory.')
fpInfoHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpInfoHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: fpInfoHardwareVersion.setDescription('Front panel hardware version number.')
fpInfoFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 5, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpInfoFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: fpInfoFirmwareVersion.setDescription('The version number of the firmware currently installed on the front panel.')
pmuInfoProductCode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuInfoProductCode.setStatus('current')
if mibBuilder.loadTexts: pmuInfoProductCode.setDescription('The product code for the PMU.')
pmuInfoSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuInfoSerialNumber.setStatus('current')
if mibBuilder.loadTexts: pmuInfoSerialNumber.setDescription('PMU serial number. A unique identifier assigned to the PMU in the factory.')
pmuInfoHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuInfoHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: pmuInfoHardwareVersion.setDescription('The PMU hardware version number.')
pmuInfoFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuInfoFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: pmuInfoFirmwareVersion.setDescription('The version number of the firmware currently installed on the PMU.')
pmuInfoCalibrationUpdateDate = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 1, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuInfoCalibrationUpdateDate.setStatus('current')
if mibBuilder.loadTexts: pmuInfoCalibrationUpdateDate.setDescription('Indicates when the PMU was last calibrated.')
pmuStateMainsInState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 1), Condition()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateMainsInState.setStatus('current')
if mibBuilder.loadTexts: pmuStateMainsInState.setDescription("The condition of the PMU's AC power input.\n                                           Range:\n                                           bad(0): The AC power input is off, or too low, or too high.\n                                           good(1): The AC power input is usable.\n                                           not fitted(2): The AC power input module is not fitted.")
pmuStateBatteryInState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 2), Condition()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateBatteryInState.setStatus('current')
if mibBuilder.loadTexts: pmuStateBatteryInState.setDescription("The condition of the PMU's DC power input.\n                                           Range:\n                                           bad(0): The DC power input is off, or too low, or too high.\n                                           good(1): The DC power input is usable.\n                                           not fitted(2): The DC power input module is not fitted.")
pmuStateBatteryInVoltage = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 3), VoltageV()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateBatteryInVoltage.setStatus('current')
if mibBuilder.loadTexts: pmuStateBatteryInVoltage.setDescription('The measured voltage of the DC (battery) power supply to the PMU.\n                                           Range: 10.5..15.5.')
pmuStateOutCurrent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 4), CurrentmA()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateOutCurrent.setStatus('current')
if mibBuilder.loadTexts: pmuStateOutCurrent.setDescription('The output current in mA that the PMU is supplying to the subrack (PA(s), reciter(s) and control panel).\n                                           Range: 0..20000.')
pmuStateOutVoltage = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 5), VoltageV()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateOutVoltage.setStatus('current')
if mibBuilder.loadTexts: pmuStateOutVoltage.setDescription('The actual voltage of the PMU output(s) to the PA(s) and reciter(s) in the subrack (nominally 28 V).\n                                           Range: 0..32.')
pmuStateOutStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 6), Condition()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateOutStatus.setStatus('current')
if mibBuilder.loadTexts: pmuStateOutStatus.setDescription('The condition of the PMU power supply to the PA.\n                                           Range:\n                                           bad(0): The power supply is absent or its voltage is too low or too high.\n                                           good(1): The power supply is OK.')
pmuStateAuxOutState = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 7), Condition()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateAuxOutState.setStatus('current')
if mibBuilder.loadTexts: pmuStateAuxOutState.setDescription('The condition of the auxiliary power output.\n                                           Range:\n                                           bad(0): The auxiliary power is off, or its voltage is too high or too low.\n                                           good(1): The auxiliary power output is on.\n                                           not fitted(2): The auxiliary power module is not fitted.')
pmuStateBusConnect = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 4, 2, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuStateBusConnect.setStatus('current')
if mibBuilder.loadTexts: pmuStateBusConnect.setDescription("The state of the DC supply to the PMU's standby converter.\n                                           Range: connected(1), not connected(2)")
rctSelectedChannelNumber = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelNumber.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelNumber.setDescription('Number of the currently selected channel.\n                                           Range: 1..1000')
rctSelectedChannelName = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelName.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelName.setDescription('Name of the current channel.')
rctSelectedChannelProfileName = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelProfileName.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelProfileName.setDescription('Name of the channel profile assigned to the currently selected channel.')
rctSelectedChannelSigProfileName = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelSigProfileName.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelSigProfileName.setDescription('Name of the signalling profile assigned to the currently selected channel.')
rctSelectedChannelTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 5), PowerW()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelTransmitPower.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelTransmitPower.setDescription('Configured PA RF transmit power in watts for the current channel when it is powered by mains.\n                                           Range: 0..100')
rctSelectedChannelTxFreq = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 6), FrequencyHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelTxFreq.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelTxFreq.setDescription('The transmit frequency of the current channel in Hz.\n                                           Range: 100000000..1000000000')
rctSelectedChannelRxFreq = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 7), FrequencyHz()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelRxFreq.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelRxFreq.setDescription('The receive frequency of the current channel in Hz.\n                                           Range: 100000000..1000000000')
rctSelectedChannelSystemType = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 10), OperationalMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelSystemType.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelSystemType.setDescription('The type of network configured in the channel profile of the currently selected channel,\n                                           analogConventional(1), dmrConventional(2), dmrTrunking(3), mptTrunking(4)')
rctSelectedChannelColourCode = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 11), ColourCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelColourCode.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelColourCode.setDescription('The configured colour code for the currently selected channel')
rctSelectedChannelGroupName = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 2, 12), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctSelectedChannelGroupName.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelGroupName.setDescription('Name of the channel group assigned to the currently selected channel.')
rctRfRcvInterference = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 3, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfRcvInterference.setStatus('current')
if mibBuilder.loadTexts: rctRfRcvInterference.setDescription('Interference level is above configured RSSI threshold.\n                                           Range: true(1), false(2)')
rctRfInterferenceCounter = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfInterferenceCounter.setStatus('current')
if mibBuilder.loadTexts: rctRfInterferenceCounter.setDescription('Counter indicating cumulative number of seconds that interference has been present.\n                                           Range: 0..4294967295')
rctRfInterferenceEvents = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 2, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctRfInterferenceEvents.setStatus('current')
if mibBuilder.loadTexts: rctRfInterferenceEvents.setDescription('The number of times the receiver detects interference.')
paTxOutputForwardPower = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 2, 1), PowerW()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paTxOutputForwardPower.setStatus('current')
if mibBuilder.loadTexts: paTxOutputForwardPower.setDescription('The measured forward power of the PA output in Watts.\n                                           Range: 0..100')
paTxOutputVSWR = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 2, 3, 2, 2), Ratio()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paTxOutputVSWR.setStatus('current')
if mibBuilder.loadTexts: paTxOutputVSWR.setDescription("The transmitter's voltage standing wave ratio (VSWR).")
linkInfoCtrlProtocolStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 1), ControlProtocolStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoCtrlProtocolStatus.setStatus('current')
if mibBuilder.loadTexts: linkInfoCtrlProtocolStatus.setDescription('The status of the base station as reported to the node using the control protocol.\n                                           Range:\n                                           unconnected(0): The base station is not under node control.\n                                           deprecatedUnconnected(1): DEPRECATED - The base station is not in contact with a node.\n                                           standby(2): The base station is in contact with a node. Its air interface is not transmitting or receiving.\n                                           dmr-aligned(3): The base station is transmitting a framesync structure together with an idle pattern or a payload.\n                                           dmr-offset(4): Not currently used.\n                                           dmr-two-slot-data(5): The base station is carrying a data call that uses both logical channels.\n                                           dmr-hibernate(6): the base station is hibernating\n                                           analogue(7): Not currently used.\n                                           test-mode(8): Reserved.\n                                           dmr-tier2-aligned(9): The base station is transmitting a framesync struture for Tier 2 operation')
linkInfoNetworkPacketCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoNetworkPacketCount.setStatus('current')
if mibBuilder.loadTexts: linkInfoNetworkPacketCount.setDescription('Total packets received from the network on control and data protocols. This is an accumulating number. The counter is large enough that the number rolls over infrequently, such as once every few months, depending on call volumes.')
linkInfoMPTCtrlProtocolStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 3), MPTControlProtocolStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoMPTCtrlProtocolStatus.setStatus('current')
if mibBuilder.loadTexts: linkInfoMPTCtrlProtocolStatus.setDescription('The status of the base station as reported to the node using the control protocol.\n                                           unconnected(0): The base-station is not connected to any MPT-IP node, neither external nor fallback.\n                                           idle(1): The base-station is connected to a MPT-IP node (either external or fallback). It is not transmitting anything on its air interface (transmitter is off).\n                                           control(2): The base-station is connected to a MPT-IP node (either external or fallback). Air interface transmitting and receiving MPT control channel signalling only.\n                                           traffic(3):      The base-station is connected to a MPT-IP node (either external or fallback). Voice/Data packets are sent to and received from node, Air interface is transmitting as well as receiving.\n                                           conventional(4): The base-station is connected to a fallback node. Voice/Data packets are repeated locally from uplink to downlink. Air interface is transmitting as well as receiving.')
linkInfoDMRNodeIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoDMRNodeIPAddress.setStatus('current')
if mibBuilder.loadTexts: linkInfoDMRNodeIPAddress.setDescription('The IP address of the DMR Node Controlling the base station.')
linkInfoDMRNodePriority = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoDMRNodePriority.setStatus('current')
if mibBuilder.loadTexts: linkInfoDMRNodePriority.setDescription('The priority of the DMR Node Controlling the base station.')
linkInfoMPTNodeIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoMPTNodeIPAddress.setStatus('current')
if mibBuilder.loadTexts: linkInfoMPTNodeIPAddress.setDescription('The IP address of the MPT Node Controlling the base station.')
linkInfoMPTNodePriority = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkInfoMPTNodePriority.setStatus('current')
if mibBuilder.loadTexts: linkInfoMPTNodePriority.setDescription('The priority of the MPT Node Controlling the base station.')
linkHealthNetworkPacketLostCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkHealthNetworkPacketLostCount.setStatus('current')
if mibBuilder.loadTexts: linkHealthNetworkPacketLostCount.setDescription('Total accumulated number of lost voice and control packets sent from the control and switching nodes. An increasing number indicates that the linking infrastructure has a problem or is congested.')
linkHealthNetworkJitterLastOver = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkHealthNetworkJitterLastOver.setStatus('current')
if mibBuilder.loadTexts: linkHealthNetworkJitterLastOver.setDescription('The maximum jitter measured in the last over.')
linkHealthNetworkJitterCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkHealthNetworkJitterCount.setStatus('current')
if mibBuilder.loadTexts: linkHealthNetworkJitterCount.setDescription('The total number of times the configured jitter threshold has been exceeded.')
linkHealthSequenceErrorsCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 4, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkHealthSequenceErrorsCount.setStatus('current')
if mibBuilder.loadTexts: linkHealthSequenceErrorsCount.setDescription('The result of lost packets - i.e. the number of times packets have been received out of sequence. This is an accumulating number.')
nwConfiguredNtpServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwConfiguredNtpServerAddress.setStatus('current')
if mibBuilder.loadTexts: nwConfiguredNtpServerAddress.setDescription('The IP address configured for the preferred NTP server used by the base-station.\n                                   The current status of NTP for the base-station including the selected server is\n                                   available via the NTPv4-MIB (RFC 5907)')
nwConfiguredNtpBackupServerAddress1 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwConfiguredNtpBackupServerAddress1.setStatus('current')
if mibBuilder.loadTexts: nwConfiguredNtpBackupServerAddress1.setDescription('The IP address configured for a backup NTP server used by the base-station.\n                                   The current status of NTP for the base-station including the backup servers is\n                                   available via the NTPv4-MIB (RFC 5907)')
nwConfiguredNtpBackupServerAddress2 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwConfiguredNtpBackupServerAddress2.setStatus('current')
if mibBuilder.loadTexts: nwConfiguredNtpBackupServerAddress2.setDescription('The IP address configured for a backup NTP server used by the base-station.\n                                   The current status of NTP for the base-station including the backup servers is\n                                   available via the NTPv4-MIB (RFC 5907)')
alarmSummaryBaseStation = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryBaseStation.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryBaseStation.setDescription('Base station summary alarm. The base station currently has one or more active alarms.\n                                           Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryReciter = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryReciter.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryReciter.setDescription('Reciter summary alarm. The reciter currently has one or more active alarms. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryPowerAmplifier = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryPowerAmplifier.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryPowerAmplifier.setDescription('PA summary alarm. The PA currently has one or more active alarms. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryPowerManagementUnit = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 4), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryPowerManagementUnit.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryPowerManagementUnit.setDescription('PMU summary alarm. The PMU currently has one or more active alarms. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryCustomAlarms = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryCustomAlarms.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryCustomAlarms.setDescription('Custom summary alarm. There are currently one or more active custom alarms. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryFrontPanel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 6), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryFrontPanel.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryFrontPanel.setDescription('Front panel summary alarm. The front panel currently has one or more active alarms. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummarySystem = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 7), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummarySystem.setStatus('current')
if mibBuilder.loadTexts: alarmSummarySystem.setDescription('System summary alarm. One or more system conditions have triggered alarms. This does not indicate a base station fault. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryMinor = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 8), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryMinor.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryMinor.setDescription('Minor summary alarm. The base station currently has one or more minor alarms. The node will select other channels in preference. Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
alarmSummaryMajor = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 1, 9), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmSummaryMajor.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryMajor.setDescription('Major summary alarm. The base station currently has one or more major alarms. The node will take it out of service.\n                                           Connect to the base station to see what these alarms are.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmRxSynthOutOfLock = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmRxSynthOutOfLock.setStatus('current')
if mibBuilder.loadTexts: rctAlarmRxSynthOutOfLock.setDescription("Receiver synthesizer alarm. The receiver synthesizer is unable to lock on to the frequency it is configured to operate at.\n                                           In response, the base station disabled the receiver.\n                                           Check that this frequency is within the receiver's RF frequency range. If it is, send the reciter for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
rctAlarmInvalidChannelSelected = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmInvalidChannelSelected.setStatus('current')
if mibBuilder.loadTexts: rctAlarmInvalidChannelSelected.setDescription('Channel invalid alarm. An invalid channel number was selected. The base station has stopped operating.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmOverTemperature = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 10), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmOverTemperature.setStatus('current')
if mibBuilder.loadTexts: rctAlarmOverTemperature.setDescription('Temperature high alarm. The reciter is approaching its maximum operating temperature.\n                                           Check if the ambient temperature high alarm is active (Monitor > Alarms > System) and that the reciter, PMU and PA fan                                         Diagnose > Sub-Systems > Fan Tests).\n                                           This alarm could be caused by a high ambient temperature or a fan failure.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmTxCalibrationInvalid = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 13), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmTxCalibrationInvalid.setStatus('current')
if mibBuilder.loadTexts: rctAlarmTxCalibrationInvalid.setDescription('Transmitter calibration invalid alarm. This alarm activates if the exciter has become uncalibrated. Send the reciter for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmRxCalibrationInvalid = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 14), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmRxCalibrationInvalid.setStatus('current')
if mibBuilder.loadTexts: rctAlarmRxCalibrationInvalid.setDescription('Reciter receiver calibration invalid alarm. The RSSI needs to be calibrated for the operational frequency of the channel.\n                                           Connect to the base station and re-calibrate the RSSI.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmInvalidConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 15), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmInvalidConfiguration.setStatus('current')
if mibBuilder.loadTexts: rctAlarmInvalidConfiguration.setDescription('Reciter hardware configuration invalid alarm, the base station modules are not compatible\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarm25MHzSynthOutOfLock = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 16), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarm25MHzSynthOutOfLock.setStatus('current')
if mibBuilder.loadTexts: rctAlarm25MHzSynthOutOfLock.setDescription("Synthesizer out of lock alarm. The reciter's 25 MHz synthesizer cannot remain locked to the external reference.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
rctAlarm6144MHzSynthOutOfLock = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 17), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarm6144MHzSynthOutOfLock.setStatus('current')
if mibBuilder.loadTexts: rctAlarm6144MHzSynthOutOfLock.setDescription("Synthesizer out of lock alarm. The reciter's 61.44 MHz synthesizer cannot remain locked to the external reference.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
rctAlarmTxFSynthOutOfLock = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 18), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmTxFSynthOutOfLock.setStatus('current')
if mibBuilder.loadTexts: rctAlarmTxFSynthOutOfLock.setDescription('The TxF synthesizer is unable to lock on to the frequency it is configured to operate at. In response, the base station disabled the transmitter.\n                              \t\t\t\t\t\t Send the reciter for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmSimulcastSynch = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 19), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmSimulcastSynch.setStatus('current')
if mibBuilder.loadTexts: rctAlarmSimulcastSynch.setDescription('The base station cannot achieve synchronization to common time reference required for simulcast operation.\n                                          If simulcast not needed, uncheck simulcast box in channel profile. Otherwise, check 1PPS and External reference units and NTP server and connectors.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmReceiverSynch = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 20), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmReceiverSynch.setStatus('current')
if mibBuilder.loadTexts: rctAlarmReceiverSynch.setDescription('Reports whether the receiver is aligned with the transmit TDMA frame synchronization of the transmitters of the channel group.\n                                           Possible causes for the receiver unsynchronized alarm are:\n                                           1.  The reciter does not have a valid 1PPS input and is not able to free run 1PPS [ref].\n                                           2.  The reciter is not synchronized to a valid NTP server and is not able to free run NTP time.\n                                           This alarm should be disabled for other system types.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
rctAlarmTxRSynthOutOfLock = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 3, 21), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rctAlarmTxRSynthOutOfLock.setStatus('current')
if mibBuilder.loadTexts: rctAlarmTxRSynthOutOfLock.setDescription('The TxR synthesizer is unable to lock on to the frequency it is configured to operate at. In response, the base station disabled the transmitter.\n                                                Send the reciter for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmNoPADetected = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmNoPADetected.setStatus('current')
if mibBuilder.loadTexts: paAlarmNoPADetected.setDescription('PA not detected alarm. The reciter has not received a response from a PA over the control bus.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmInvalidFirmware = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmInvalidFirmware.setStatus('current')
if mibBuilder.loadTexts: paAlarmInvalidFirmware.setDescription('PA firmware invalid alarm. The firmware in the PA is invalid.\n                                           1. Connect to the base station and activate the latest PA firmware.\n                                           2. Replace the PA and send it for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmInvalidCalibration = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmInvalidCalibration.setStatus('current')
if mibBuilder.loadTexts: paAlarmInvalidCalibration.setDescription('Invalid PA calibration alarm. This alarm can only be triggered on start-up, when the PA carries out self-tests.\n                                           It indicates that settings stored in firmware have values outside acceptable limits. In response, the base station disables the transmitter.\n                                           Contact your regional Tait office for assistance.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmForwardPowerLow = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmForwardPowerLow.setStatus('current')
if mibBuilder.loadTexts: paAlarmForwardPowerLow.setDescription('Forward power low alarm. The PA forward power output is below the configured minimum limit.\n                                           If the VSWR is also raised, check for a load mismatch. Otherwise, there may be a fault in the output driver(s).\n                                           Replace the PA and send for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmPowerFoldback = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 7), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmPowerFoldback.setStatus('current')
if mibBuilder.loadTexts: paAlarmPowerFoldback.setDescription('Power foldback alarm. The PA has detected a fault condition and, to prevent damage, reduced its power output to 35 Watts. (But only if the configured power output is higher than 35 Watts. If the configured output is less than or equal to 35, it stays the same.)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t Check the other alarms to see what fault condition(s) have caused this. If the fault clears, the PA automatically returns to its previous power output level and the alarm returns to green.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t This alarm causes the node to take the base station out of service. Once the problem is fixed, you need to send a test transmission to clear the alarm. Only then will the node bring the channel back into service.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmReversePowerHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 8), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmReversePowerHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmReversePowerHigh.setDescription("Reverse power high alarm. The PA's reverse power is above the configured maximum.\n                              \t\t\t\t\t\t Check for a load mismatch. This alarm has a resolution of only 1W so it isn't sufficiently sensitive for power outputs below 20W.\n                                           Note: This alarm will not show if the transmit combiner uses an isolator.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmShutdownImminent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 9), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmShutdownImminent.setStatus('current')
if mibBuilder.loadTexts: paAlarmShutdownImminent.setDescription('PA shut-down alarm. The PA is not operational. It detected a fault condition and  disabled the transmitter to prevent damage.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmVSWRFault = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 10), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmVSWRFault.setStatus('current')
if mibBuilder.loadTexts: paAlarmVSWRFault.setDescription("VSWR alarm. The PA's Voltage Standing Wave Ratio (VSWR) is above the configured threshold. A normal VSWR is <= 2:1.\n                                           A high VSWR automatically means reduced output power. If the VSWR increases to 10:1 or more,\n                                           the PA folds back its power output to a low level. If the VSWR returns to 5:1 or less, the PA recovers.\n                                           Check for a load mismatch on the RF output.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   This alarm causes the node to take the base station out of service.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   Once the problem is fixed, you need to send a test transmission to clear the alarm. Only then will the node bring the channel back into service.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmDriverCurrentHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 11), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmDriverCurrentHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmDriverCurrentHigh.setDescription('Driver current high alarm. The driver is drawing excessive current. A fixed limit has been exceeded. Replace the PA and send it for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmFinal1CurrentHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 12), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmFinal1CurrentHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmFinal1CurrentHigh.setDescription("Final 1 current high alarm. The current in the PA's final 1 output stage has exceeded a fixed limit.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmFinal2CurrentHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 13), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmFinal2CurrentHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmFinal2CurrentHigh.setDescription("Final 2 current high alarm. The current in the PA's final 2 output stage has exceeded a fixed limit.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmCurrentImbalance = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 14), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmCurrentImbalance.setStatus('current')
if mibBuilder.loadTexts: paAlarmCurrentImbalance.setDescription("Current imbalance alarm. One of the PA's final stages is drawing significantly more current than the other.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmSupplyVoltageLow = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 15), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmSupplyVoltageLow.setStatus('current')
if mibBuilder.loadTexts: paAlarmSupplyVoltageLow.setDescription('Supply voltage low alarm. The PA supply voltage is 26 V or less, probably because the battery supply to the PMU is running low.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmSupplyVoltageHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 16), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmSupplyVoltageHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmSupplyVoltageHigh.setDescription('Supply voltage high alarm. The power supplied to the PA is 29 V or more. The PMU is faulty and needs replacing,\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
paAlarmDriverTemperatureHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 17), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmDriverTemperatureHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmDriverTemperatureHigh.setDescription("Driver temperature high alarm. The temperature in the PA's driver output stage has exceeded the configured threshold.\n                                           If it continues to rise and exceeds a built-in limit, the PA will fold back its power output.\n                                           To see the actual temperature, connect to the base station and select Diagnose > Sub-Systems > Fan Tests.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmFinal1TemperatureHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 18), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmFinal1TemperatureHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmFinal1TemperatureHigh.setDescription("Final 1 temperature high alarm. The temperature in the PA's final 1 output stage has exceeded the configured threshold.\n                                           If it continues to rise and exceeds a built-in limit, the PA will fold back its power output.\n                                           To see the actual temperature, connect to the base station and select Diagnose > Sub-Systems > Fan Tests.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
paAlarmFinal2TemperatureHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 4, 19), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: paAlarmFinal2TemperatureHigh.setStatus('current')
if mibBuilder.loadTexts: paAlarmFinal2TemperatureHigh.setDescription("Final 2 temperature high alarm. The temperature in the PA's final 2 output stage has exceeded the configured threshold.\n                                           If it continues to rise and exceeds a built-in limit, the PA will fold back its power output.\n                                           To see the actual temperature, connect to the base station and select Diagnose > Sub-Systems > Fan Tests.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
pmuAlarmNoPMUDetected = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmNoPMUDetected.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmNoPMUDetected.setDescription('PMU not detected alarm. The reciter has not received a response from the PMU over the control bus.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmInvalidFirmware = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmInvalidFirmware.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmInvalidFirmware.setDescription('PMU firmware invalid alarm. The firmware in the PMU is invalid.\n                                           1. Connect to the base station and activate the PMU firmware.\n                                           2. Replace the PMU and send it for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmMainsFailure = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 4), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmMainsFailure.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmMainsFailure.setDescription('Mains supply alarm. The mains power supply to the PMU is absent or its voltage is outside acceptable limits.\n                                           The PMU is using DC power instead.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmSelfTestFailure = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmSelfTestFailure.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmSelfTestFailure.setDescription('PMU power-up fault. During start-up, the PMU detected an internal error and will reset itself.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmShutdownImminent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 6), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmShutdownImminent.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmShutdownImminent.setDescription('Shut-down imminent alarm. A battery is currently powering the base station and its voltage has fallen below the configured power shut-down voltage.\n                                           The PMU will shut down 30 seconds after activating this alarm.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmTemperatureHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 7), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmTemperatureHigh.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmTemperatureHigh.setDescription('PMU temperature alarm. One of the PMU temperature sensors has detected a temperature that is above the fixed limit.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmBatteryProtect = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 8), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmBatteryProtect.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmBatteryProtect.setDescription('Battery protection mode alarm. Battery protection mode is on. If mains power fails, the PMU will shut down to protect the battery.\n                                           Battery protection mode is entered when the battery voltage falls below the configured power shutdown voltage. Check the battery backup system.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmBatteryVoltageLow = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 9), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmBatteryVoltageLow.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmBatteryVoltageLow.setDescription('Low battery voltage alarm. The DC voltage supply to the PMU is below the configured alarm threshold.\n                                           If mains power is lost, the PMU is likely to reduce its output voltage or shut down. Check the charging system.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmBatteryVoltageHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 10), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmBatteryVoltageHigh.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmBatteryVoltageHigh.setDescription('Battery voltage high alarm. The voltage of the DC power supply to the PMU is higher than the configured maximum.\n                                           The base station takes no action until the voltage reaches the fixed maximum, when it shuts down.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmCurrentOutHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 11), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmCurrentOutHigh.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmCurrentOutHigh.setDescription('PMU high current alarm. The PMU is providing > 15 A of current and is automatically lowering its output voltage.\n                                           There is a short circuit or the PMU is faulty.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
pmuAlarmVoltageOutLow = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 12), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmVoltageOutLow.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmVoltageOutLow.setDescription("Output voltage low alarm. The PMU's DC output (nominally 28 V) is lower than the fixed minimum of 24 V.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
pmuAlarmVoltageOutHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 5, 13), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pmuAlarmVoltageOutHigh.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmVoltageOutHigh.setDescription("High voltage alarm. The PMU's DC output (nominally 28 V) is higher than the fixed maximum of 32 V.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
systemAlarmAmbientTempLow = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmAmbientTempLow.setStatus('current')
if mibBuilder.loadTexts: systemAlarmAmbientTempLow.setDescription('Ambient temperature low alarm. The ambient temperature at the front panel air intake is below the configured minimum.\n                                           Fan operation and PA power output are unaffected by this alarm.\n                                           This alarm could indicate an air conditioning failure.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
systemAlarmAmbientTempHigh = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmAmbientTempHigh.setStatus('current')
if mibBuilder.loadTexts: systemAlarmAmbientTempHigh.setDescription('Ambient temperature high alarm. The ambient temperature at the front panel air intake has exceeded the configured maximum.\n                                           Fan operation and PA power output are unaffected by this alarm.\n                                           This alarm could indicate an air conditioning failure.')
systemAlarmExternalRefAbsent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmExternalRefAbsent.setStatus('current')
if mibBuilder.loadTexts: systemAlarmExternalRefAbsent.setDescription('External frequency reference absent alarm. The base station did not detect an external reference frequency source. It is now using its own source. An external reference is critical for simulcast applications and for K-band operation.\n                                           1.  The source has become unplugged.\n                                           2.  The source is not working.\n                                           3.  There is no external reference source and the alarm was not disabled at installation time. You can disable the alarm (Configure > Alarms > Control).\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
systemAlarmQoSJitter = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 4), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmQoSJitter.setStatus('current')
if mibBuilder.loadTexts: systemAlarmQoSJitter.setDescription('QoS jitter alarm. The incoming voice stream has a jitter equal to or greater than the configured threshold.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
systemAlarmQoSLostPackets = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmQoSLostPackets.setStatus('current')
if mibBuilder.loadTexts: systemAlarmQoSLostPackets.setDescription('QoS lost packets alarm. The number of lost packets in the incoming voice stream has equalled or exceeded the configured threshold.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
systemAlarmFallbackControlled = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 6), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmFallbackControlled.setStatus('current')
if mibBuilder.loadTexts: systemAlarmFallbackControlled.setDescription('This base station is controlled by an Embedded Node in fallback mode.')
systemAlarmDuplicateNodePriority = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 7), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmDuplicateNodePriority.setStatus('current')
if mibBuilder.loadTexts: systemAlarmDuplicateNodePriority.setDescription("The base station's BSP priority is being used by another base station on the same site. This alarm is raised only if the base station has been configured as 'CCH Capable'.")
systemAlarmNTPSynchronisation = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 8), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmNTPSynchronisation.setStatus('current')
if mibBuilder.loadTexts: systemAlarmNTPSynchronisation.setDescription("The base station hasn't had received an NTP signal from a server and the clock might be out of synchronization.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
systemAlarm1PPSAbsent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 9), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarm1PPSAbsent.setStatus('current')
if mibBuilder.loadTexts: systemAlarm1PPSAbsent.setDescription("In a simulcast system base stations must have a 1PPS pulse. This alarm should be disabled for other systems.\n                                           It is not applicable to receive only base stations. The alarm warns that the base station isn't receiving\n                                           a 1PPS pulse. If the base station loses the pulse but is still receiving its external reference, it phase-locks its transmit clock to\n                                           the external frequency reference in order to maintain synchronization. This is called Holdover mode and is a temporary measure. When the\n                                           holdover duration expires the base station becomes unsynchronized.\n                                           The 'Simulcast unsynchronized' alarm under 'Reciter' below indicates whether the base station is synchronized for simulcast operation.\n                                           The 'Receiver unsynchronised' alarm in this section indicates whether the base station receiver is synchronized.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
systemAlarmQoSTransmitBuffer = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 10), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmQoSTransmitBuffer.setStatus('current')
if mibBuilder.loadTexts: systemAlarmQoSTransmitBuffer.setDescription("Simulcast satellite base station is receiving packets that cannot fit into the transmit buffer.\n                                           The alarm can be raised due to one of the two reasons: packets arriving too late or too early.\n                                           See nwQosUnderflowCount and nwQosOverflowCount for the events that cause the alarm condition.\n                                           Most likely causes for packets being late are jitter, delay and configuration errors.\n                                           Most likely cause for packets being too early is preemption.\n                                           Use SNMP monitoring tools and base station's WUI (Monitoring->Interfaces->Channel Group) to identify the cause.\n                                           Refer to logs, if the event has happened too far in the past.\n                                           The alarm is asserted when rate of non-transmitted packets exceeds 1 percent. \n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
systemAlarmCartesianLoopUnstable = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 11), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmCartesianLoopUnstable.setStatus('current')
if mibBuilder.loadTexts: systemAlarmCartesianLoopUnstable.setDescription("PA feedback loop to linearise transmitter can't achieve specified tolerances.\n                                           Check TxR cable connected properly, otherwise return for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
systemAlarmTxRCableAbsent = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 8, 12), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmTxRCableAbsent.setStatus('current')
if mibBuilder.loadTexts: systemAlarmTxRCableAbsent.setDescription('PA feedback cable to reciter TxR is not working correctly/not present.\n                                            Ensure that the TxR cable between PA and Reciter TxR is unbroken and connected securely, or return for repair.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
fpAlarmFan1 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpAlarmFan1.setStatus('current')
if mibBuilder.loadTexts: fpAlarmFan1.setDescription('Fan alarm. The reciter has failed to detect Fan 1 when attempting to activate it upon start-up or when a module temperature threshold is exceeded. The fan may need replacing.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
fpAlarmFan2 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpAlarmFan2.setStatus('current')
if mibBuilder.loadTexts: fpAlarmFan2.setDescription('Fan alarm. The reciter has failed to detect Fan 2 when attempting to activate it upon start-up or when a module temperature threshold is exceeded. The fan may need replacing.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
fpAlarmFan3 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpAlarmFan3.setStatus('current')
if mibBuilder.loadTexts: fpAlarmFan3.setDescription('Fan alarm. The reciter has failed to detect Fan 3 when attempting to activate it upon start-up or when a module temperature threshold is exceeded. The fan may need replacing.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
fpAlarmNoFPDetected = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7, 4), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpAlarmNoFPDetected.setStatus('current')
if mibBuilder.loadTexts: fpAlarmNoFPDetected.setDescription('The base station is unable to detect the front panel on the control bus. Check the connections of the D-range connector and system control bus cable.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
fpAlarmInvalidFirmware = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 7, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fpAlarmInvalidFirmware.setStatus('current')
if mibBuilder.loadTexts: fpAlarmInvalidFirmware.setDescription('Invalid front panel firmware alarm. Connect to the base station and select Tools > Firmware Download to acquire valid firmware. If the firmware is valid contact your regional Tait office for assistance.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)')
customAlarm1 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 1), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm1.setStatus('current')
if mibBuilder.loadTexts: customAlarm1.setDescription("Custom alarm 1. The state of digital input 1 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm2 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 2), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm2.setStatus('current')
if mibBuilder.loadTexts: customAlarm2.setDescription("Custom alarm 2. The state of digital input 2 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm3 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 3), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm3.setStatus('current')
if mibBuilder.loadTexts: customAlarm3.setDescription("Custom alarm 3. The state of digital input 3 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm4 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 4), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm4.setStatus('current')
if mibBuilder.loadTexts: customAlarm4.setDescription("Custom alarm 4. The state of digital input 4 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm5 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 5), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm5.setStatus('current')
if mibBuilder.loadTexts: customAlarm5.setDescription("Custom alarm 5. The state of digital input 5 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm6 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 6), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm6.setStatus('current')
if mibBuilder.loadTexts: customAlarm6.setDescription("Custom alarm 6. The state of digital input 6 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm7 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 7), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm7.setStatus('current')
if mibBuilder.loadTexts: customAlarm7.setDescription("Custom alarm 7. The state of digital input 7 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm8 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 8), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm8.setStatus('current')
if mibBuilder.loadTexts: customAlarm8.setDescription("Custom alarm 8. The state of digital input 8 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm9 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 9), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm9.setStatus('current')
if mibBuilder.loadTexts: customAlarm9.setDescription("Custom alarm 9. The state of digital input 9 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm10 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 10), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm10.setStatus('current')
if mibBuilder.loadTexts: customAlarm10.setDescription("Custom alarm 10. The state of digital input 10 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm11 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 11), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm11.setStatus('current')
if mibBuilder.loadTexts: customAlarm11.setDescription("Custom alarm 11. The state of digital input 11 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
customAlarm12 = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 3, 6, 12), AlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: customAlarm12.setStatus('current')
if mibBuilder.loadTexts: customAlarm12.setDescription("Custom alarm 12. The state of digital input 12 has changed, triggering this alarm.\n                                           This occurs when external equipment has been connected to the input.\n                                           When configured as 'active high', a custom alarm is triggered when its input goes to 'high' (4.75V) and it is cleared when its input goes to 'low'.\n                                           When configured as 'active low', a custom alarm is triggered when its input goes to 'low' (0V) and it is cleared when its input goes to 'high'.\n                                           Range: unavailable(0), cleared(1), raised(2), disabled(3)")
nwSvpPort = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 3, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwSvpPort.setStatus('current')
if mibBuilder.loadTexts: nwSvpPort.setDescription('The configured Simulcast Voted protocol UDP port.')
nwChannelGroupStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 1), ChannelGroupStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupStatus.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupStatus.setDescription('The voting role that the base station is currently playing within the channel group.')
nwChannelGroupLocalBufferLevel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 2), Milliseconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupLocalBufferLevel.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupLocalBufferLevel.setDescription('The lowest level of the transmit buffer, measured in milliseconds over a 5-second period.')
nwChannelGroupEmptiestBufferLevel = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 3), Milliseconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupEmptiestBufferLevel.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupEmptiestBufferLevel.setDescription('The level of the transmit buffer (in ms) at the member that has got emptiest buffer-level.\n                              It is the smallest transmit buffer of any channel group member.\n                              If marshalling is self-regulating, the central voter is responsible for ensuring that there are no buffer underruns.\n                              If marshalling is fixed, the marshalling duration must be long enough to prevent buffer underruns.')
nwChannelGroupMarshallingType = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 4), TimingControlType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupMarshallingType.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupMarshallingType.setDescription('[Simulcast] The Marshalling Type configuration setting indicates how the marshalling time is determined.\n                                           Range:\n                                           fixed(0): Configuration defines the marshalling time.\n                                           self-regulating(1): The network element dynamically adjusts the marshalling time based on the size of the smallest transmit buffer in the channel group.')
nwChannelGroupMarshallingDuration = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 5), Milliseconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupMarshallingDuration.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupMarshallingDuration.setDescription('In simulcast, the current marshalling duration (in ms). This is fixed in configuration or automatically regulated. This parameter is only used by the central voter (channel group master).\n                                           Range: 0..300')
nwChannelGroupReceiverSynchStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 6), ReceiverSyncStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupReceiverSynchStatus.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupReceiverSynchStatus.setDescription("The receiver synchronization status indicates whether the base station's receiver is synchronized and if not then gives reasons why.\n                                           Range:\n                                           no-license(0): The base station does not have a license to operate in Simulcast mode.\n                                           non-channelgroup-operation(1):The current channel group profile does not enable channel group operation.\n                                           synchronized(2): The transmitter is able to synchronize its transmissions with the other members of the channel group. Simulcast is functioning properly.\n                                           never-had-1pps(3): The base station has never had a 1PPS signal. It is either faulty or absent and is therefore unsynchronized.\n                                           never-had-ntp(4): The base station has never had NTP so it is therefore unsynchronized.\n                                           missing-1pps-or-ntp(5): 1PPS or NTP is faulty or absent after initial synchronisation.")
nwChannelGroupTransmitterSynchStatus = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 7), TransmitterSyncStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupTransmitterSynchStatus.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupTransmitterSynchStatus.setDescription("The Synchronization status indicates whether the base station's transmission is synchronized and if not then gives reasons why. A base station transmitter in a simulcast channel group must be synchronized for simulcast operation. An unsynchronized base station does not transmit, unless it is specifically configured to transmit even though unsynchronized.\n                                           Range:\n                                           no-license(0): The base station does not have a license to operate in Simulcast mode.\n                                           non-simulcast-operation(1): The current channel profile does not enable simulcast.\n                                           bad-frequency-reference(2): The base station has frequency reference either faulty or absent and is therefore unsynchronized.\n                                           never-had-1pps(3): The base station has never had a 1PPS. It is either faulty or absent and is therefore unsynchronized.\n                                           never-had-ntp(4): The base station has never had NTP so it is therefore unsynchronized.\n                                           missing-1pps-or-ntp(5): 1PPS or NTP is faulty or absent after initial synchronisation.\n                                           synchronized(6): The transmitter is able to synchronize its transmissions with the other members of the channel group. Simulcast is functioning properly.\n                                           non-channelgroup-operation(7):The current channel profile does not enable channel group operation.")
nwChannelGroupLateStreamsCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupLateStreamsCount.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupLateStreamsCount.setDescription('The number of times any transmission stream arrives later than the required transmit time.\n                              The count is aggregated one since system-startup.')
nwChannelGroupOverflowCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupOverflowCount.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupOverflowCount.setDescription('The number of channelgroup messages that did not fit in the transmit buffer or were too far into the future.\n                              The count is total such messages since system-startup.')
nwChannelGroupUnderflowCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupUnderflowCount.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupUnderflowCount.setDescription('The number of times transmit-buffer ran empty, since system-startup.')
nwChannelGroupLostPacketsCount = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupLostPacketsCount.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupLostPacketsCount.setDescription('The number of packets that were lost during a transmission stream, based on the packet sequence numbering.\n                              The count is aggregated one since system-startup.')
nwChannelGroupJitter = MibScalar((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 1, 5, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwChannelGroupJitter.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupJitter.setDescription('The jitter-value calculated in compliance with RFC-1889. It is the mean deviation (absolute value) \n                              of the difference in packet spacing at the receiver compared to the sender for a pair of packets. The value is in milliseconds.')
healthGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 1)).setObjects(("TAIT-INFRA93SERIES-MIB", "healthRunMode"), ("TAIT-INFRA93SERIES-MIB", "healthNetworkConnLogChan1State"), ("TAIT-INFRA93SERIES-MIB", "healthNetworkConnLogChan2State"), ("TAIT-INFRA93SERIES-MIB", "healthSecureShellRunning"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    healthGroup = healthGroup.setStatus('current')
if mibBuilder.loadTexts: healthGroup.setDescription('The health Group.')
alarmSummaryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 2)).setObjects(("TAIT-INFRA93SERIES-MIB", "alarmSummaryPowerAmplifier"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryFrontPanel"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryReciter"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryBaseStation"), ("TAIT-INFRA93SERIES-MIB", "alarmSummarySystem"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryPowerManagementUnit"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryCustomAlarms"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryMinor"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryMajor"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alarmSummaryGroup = alarmSummaryGroup.setStatus('current')
if mibBuilder.loadTexts: alarmSummaryGroup.setDescription('The alarmSummary Group.')
rctSelectedChannelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 3)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelNumber"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelName"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelProfileName"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelSigProfileName"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelTransmitPower"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelTxFreq"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelRxFreq"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelSystemType"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelColourCode"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelGroupName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctSelectedChannelGroup = rctSelectedChannelGroup.setStatus('current')
if mibBuilder.loadTexts: rctSelectedChannelGroup.setDescription('The rctSelectedChannel Group.')
paTxOutputGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 5)).setObjects(("TAIT-INFRA93SERIES-MIB", "paTxOutputForwardPower"), ("TAIT-INFRA93SERIES-MIB", "paTxOutputVSWR"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    paTxOutputGroup = paTxOutputGroup.setStatus('current')
if mibBuilder.loadTexts: paTxOutputGroup.setDescription('The paTxOutput Group.')
linkInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 6)).setObjects(("TAIT-INFRA93SERIES-MIB", "linkInfoCtrlProtocolStatus"), ("TAIT-INFRA93SERIES-MIB", "linkInfoNetworkPacketCount"), ("TAIT-INFRA93SERIES-MIB", "linkInfoMPTCtrlProtocolStatus"), ("TAIT-INFRA93SERIES-MIB", "linkInfoDMRNodeIPAddress"), ("TAIT-INFRA93SERIES-MIB", "linkInfoDMRNodePriority"), ("TAIT-INFRA93SERIES-MIB", "linkInfoMPTNodeIPAddress"), ("TAIT-INFRA93SERIES-MIB", "linkInfoMPTNodePriority"), ("TAIT-INFRA93SERIES-MIB", "linkHealthSequenceErrorsCount"), ("TAIT-INFRA93SERIES-MIB", "linkHealthNetworkPacketLostCount"), ("TAIT-INFRA93SERIES-MIB", "linkHealthNetworkJitterLastOver"), ("TAIT-INFRA93SERIES-MIB", "linkHealthNetworkJitterCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    linkInfoGroup = linkInfoGroup.setStatus('current')
if mibBuilder.loadTexts: linkInfoGroup.setDescription('The linkInfo Group.')
customAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 7)).setObjects(("TAIT-INFRA93SERIES-MIB", "customAlarm1"), ("TAIT-INFRA93SERIES-MIB", "customAlarm2"), ("TAIT-INFRA93SERIES-MIB", "customAlarm3"), ("TAIT-INFRA93SERIES-MIB", "customAlarm4"), ("TAIT-INFRA93SERIES-MIB", "customAlarm5"), ("TAIT-INFRA93SERIES-MIB", "customAlarm6"), ("TAIT-INFRA93SERIES-MIB", "customAlarm7"), ("TAIT-INFRA93SERIES-MIB", "customAlarm8"), ("TAIT-INFRA93SERIES-MIB", "customAlarm9"), ("TAIT-INFRA93SERIES-MIB", "customAlarm10"), ("TAIT-INFRA93SERIES-MIB", "customAlarm11"), ("TAIT-INFRA93SERIES-MIB", "customAlarm12"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    customAlarmsGroup = customAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: customAlarmsGroup.setDescription('The customAlarms group.')
systemAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 8)).setObjects(("TAIT-INFRA93SERIES-MIB", "systemAlarmExternalRefAbsent"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmAmbientTempHigh"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmAmbientTempLow"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmQoSJitter"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmQoSLostPackets"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmFallbackControlled"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmDuplicateNodePriority"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmNTPSynchronisation"), ("TAIT-INFRA93SERIES-MIB", "systemAlarm1PPSAbsent"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmQoSTransmitBuffer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    systemAlarmsGroup = systemAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: systemAlarmsGroup.setDescription('The systemAlarms Group.')
fpAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 9)).setObjects(("TAIT-INFRA93SERIES-MIB", "fpAlarmInvalidFirmware"), ("TAIT-INFRA93SERIES-MIB", "fpAlarmFan2"), ("TAIT-INFRA93SERIES-MIB", "fpAlarmNoFPDetected"), ("TAIT-INFRA93SERIES-MIB", "fpAlarmFan3"), ("TAIT-INFRA93SERIES-MIB", "fpAlarmFan1"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    fpAlarmsGroup = fpAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: fpAlarmsGroup.setDescription('The fpAlarms Group.')
paAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 10)).setObjects(("TAIT-INFRA93SERIES-MIB", "paAlarmFinal1CurrentHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmDriverCurrentHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmSupplyVoltageLow"), ("TAIT-INFRA93SERIES-MIB", "paAlarmFinal2TemperatureHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmFinal2CurrentHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmVSWRFault"), ("TAIT-INFRA93SERIES-MIB", "paAlarmDriverTemperatureHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmForwardPowerLow"), ("TAIT-INFRA93SERIES-MIB", "paAlarmNoPADetected"), ("TAIT-INFRA93SERIES-MIB", "paAlarmFinal1TemperatureHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmSupplyVoltageHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmPowerFoldback"), ("TAIT-INFRA93SERIES-MIB", "paAlarmInvalidCalibration"), ("TAIT-INFRA93SERIES-MIB", "paAlarmInvalidFirmware"), ("TAIT-INFRA93SERIES-MIB", "paAlarmShutdownImminent"), ("TAIT-INFRA93SERIES-MIB", "paAlarmReversePowerHigh"), ("TAIT-INFRA93SERIES-MIB", "paAlarmCurrentImbalance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    paAlarmsGroup = paAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: paAlarmsGroup.setDescription('The paAlarms Group.')
pmuAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 11)).setObjects(("TAIT-INFRA93SERIES-MIB", "pmuAlarmMainsFailure"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmBatteryVoltageLow"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmBatteryVoltageHigh"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmBatteryProtect"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmInvalidFirmware"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmVoltageOutHigh"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmNoPMUDetected"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmVoltageOutLow"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmShutdownImminent"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmCurrentOutHigh"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmSelfTestFailure"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmTemperatureHigh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pmuAlarmsGroup = pmuAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: pmuAlarmsGroup.setDescription('The pmuAlarms Group.')
reciterAlarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 12)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctAlarmRxSynthOutOfLock"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmInvalidChannelSelected"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmRxCalibrationInvalid"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmOverTemperature"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmInvalidConfiguration"), ("TAIT-INFRA93SERIES-MIB", "rctAlarm25MHzSynthOutOfLock"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmTxCalibrationInvalid"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmTxFSynthOutOfLock"), ("TAIT-INFRA93SERIES-MIB", "rctAlarm6144MHzSynthOutOfLock"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmSimulcastSynch"), ("TAIT-INFRA93SERIES-MIB", "rctAlarmReceiverSynch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    reciterAlarmsGroup = reciterAlarmsGroup.setStatus('current')
if mibBuilder.loadTexts: reciterAlarmsGroup.setDescription('The reciterAlarms Group.')
infoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 13)).setObjects(("TAIT-INFRA93SERIES-MIB", "infoTransmitterStatus"), ("TAIT-INFRA93SERIES-MIB", "infoMPTFallbackNodeStatus"), ("TAIT-INFRA93SERIES-MIB", "infoDMRFallbackNodeStatus"), ("TAIT-INFRA93SERIES-MIB", "rctInfoProductCode"), ("TAIT-INFRA93SERIES-MIB", "rctInfoSerialNumber"), ("TAIT-INFRA93SERIES-MIB", "rctInfoHardwareVersion"), ("TAIT-INFRA93SERIES-MIB", "rctInfoFirmwareVersion"), ("TAIT-INFRA93SERIES-MIB", "paInfoProductCode"), ("TAIT-INFRA93SERIES-MIB", "paInfoSerialNumber"), ("TAIT-INFRA93SERIES-MIB", "paInfoHardwareVersion"), ("TAIT-INFRA93SERIES-MIB", "paInfoFirmwareVersion"), ("TAIT-INFRA93SERIES-MIB", "fpInfoProductCode"), ("TAIT-INFRA93SERIES-MIB", "fpInfoSerialNumber"), ("TAIT-INFRA93SERIES-MIB", "fpInfoHardwareVersion"), ("TAIT-INFRA93SERIES-MIB", "fpInfoFirmwareVersion"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrFull"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrExpress"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrAccess"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrConventional"), ("TAIT-INFRA93SERIES-MIB", "licenceAnalogConventional"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrExpress20"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrCentralVoter"), ("TAIT-INFRA93SERIES-MIB", "licenceDmrNetworkSatellite"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    infoGroup = infoGroup.setStatus('current')
if mibBuilder.loadTexts: infoGroup.setDescription('The info Group.')
rctReceiveQualityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 14)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctRfRcvInterference"), ("TAIT-INFRA93SERIES-MIB", "rctRfInterferenceCounter"), ("TAIT-INFRA93SERIES-MIB", "rctRfInterferenceEvents"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctReceiveQualityGroup = rctReceiveQualityGroup.setStatus('current')
if mibBuilder.loadTexts: rctReceiveQualityGroup.setDescription('The receive quality Group.')
rctReceiverGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 15)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctRfReceiverRSSI"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverLC1RSSI"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverLC2RSSI"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverLC1RxGateState"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverLC2RxGateState"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverSelectedDecodeCTCSS"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverSelectedDecodeSubAudibleType"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverSelectedSINADGatingLevel"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverSelectedDecodeDCS"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverSelectedFrequencyResponse"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverAnalogGateState"), ("TAIT-INFRA93SERIES-MIB", "rctRfReceiverIsDisabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctReceiverGroup = rctReceiverGroup.setStatus('current')
if mibBuilder.loadTexts: rctReceiverGroup.setDescription('The receiver Group.')
rctTemperatureGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 16)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctTemperatureBoard"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctTemperatureGroup = rctTemperatureGroup.setStatus('current')
if mibBuilder.loadTexts: rctTemperatureGroup.setDescription('The reciter temperature group.')
pmuStateGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 17)).setObjects(("TAIT-INFRA93SERIES-MIB", "pmuStateMainsInState"), ("TAIT-INFRA93SERIES-MIB", "pmuStateBatteryInState"), ("TAIT-INFRA93SERIES-MIB", "pmuStateBatteryInVoltage"), ("TAIT-INFRA93SERIES-MIB", "pmuStateOutCurrent"), ("TAIT-INFRA93SERIES-MIB", "pmuStateOutVoltage"), ("TAIT-INFRA93SERIES-MIB", "pmuStateOutStatus"), ("TAIT-INFRA93SERIES-MIB", "pmuStateAuxOutState"), ("TAIT-INFRA93SERIES-MIB", "pmuStateBusConnect"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pmuStateGroup = pmuStateGroup.setStatus('current')
if mibBuilder.loadTexts: pmuStateGroup.setDescription('The pmu status indications group.')
nwNtpInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 18)).setObjects(("TAIT-INFRA93SERIES-MIB", "nwConfiguredNtpServerAddress"), ("TAIT-INFRA93SERIES-MIB", "nwConfiguredNtpBackupServerAddress1"), ("TAIT-INFRA93SERIES-MIB", "nwConfiguredNtpBackupServerAddress2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nwNtpInterfaceGroup = nwNtpInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: nwNtpInterfaceGroup.setDescription('The network ntp interface group.')
rctTransmitterGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 19)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctRfTxSelectedEncodeCTCSS"), ("TAIT-INFRA93SERIES-MIB", "rctRfTxSelectedEncodeSubAudibleType"), ("TAIT-INFRA93SERIES-MIB", "rctRfTxSelectFrequencyResponse"), ("TAIT-INFRA93SERIES-MIB", "rctRfTxSelectedEncodeDCS"), ("TAIT-INFRA93SERIES-MIB", "rctRfTxSelectedEncodeSubAudibleDeviation"), ("TAIT-INFRA93SERIES-MIB", "rctRfTxRfRepeatState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctTransmitterGroup = rctTransmitterGroup.setStatus('current')
if mibBuilder.loadTexts: rctTransmitterGroup.setDescription('The transmitter group.')
nwChannelGroupGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 20)).setObjects(("TAIT-INFRA93SERIES-MIB", "nwChannelGroupStatus"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupLocalBufferLevel"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupEmptiestBufferLevel"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupMarshallingType"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupMarshallingDuration"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupReceiverSynchStatus"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupTransmitterSynchStatus"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupLateStreamsCount"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupOverflowCount"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupUnderflowCount"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupLostPacketsCount"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupJitter"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nwChannelGroupGroup = nwChannelGroupGroup.setStatus('current')
if mibBuilder.loadTexts: nwChannelGroupGroup.setDescription('The group for channelgroup.')
nwPortsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 21)).setObjects(("TAIT-INFRA93SERIES-MIB", "nwSvpPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    nwPortsGroup = nwPortsGroup.setStatus('current')
if mibBuilder.loadTexts: nwPortsGroup.setDescription('Network ports')
mibComplianceList = ModuleCompliance((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 2, 1)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctTransmitterGroup"), ("TAIT-INFRA93SERIES-MIB", "rctReceiverGroup"), ("TAIT-INFRA93SERIES-MIB", "rctReceiveQualityGroup"), ("TAIT-INFRA93SERIES-MIB", "infoGroup"), ("TAIT-INFRA93SERIES-MIB", "healthGroup"), ("TAIT-INFRA93SERIES-MIB", "alarmSummaryGroup"), ("TAIT-INFRA93SERIES-MIB", "rctSelectedChannelGroup"), ("TAIT-INFRA93SERIES-MIB", "paTxOutputGroup"), ("TAIT-INFRA93SERIES-MIB", "linkInfoGroup"), ("TAIT-INFRA93SERIES-MIB", "customAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "fpAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "paAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "reciterAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "rctTemperatureGroup"), ("TAIT-INFRA93SERIES-MIB", "nwNtpInterfaceGroup"), ("TAIT-INFRA93SERIES-MIB", "nwChannelGroupGroup"), ("TAIT-INFRA93SERIES-MIB", "nwPortsGroup"), ("TAIT-INFRA93SERIES-MIB", "linearTransmissionCapability"), ("TAIT-INFRA93SERIES-MIB", "pmuAlarmsGroup"), ("TAIT-INFRA93SERIES-MIB", "pmuInfoGroup"), ("TAIT-INFRA93SERIES-MIB", "pmuStateGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mibComplianceList = mibComplianceList.setStatus('current')
if mibBuilder.loadTexts: mibComplianceList.setDescription('The requirements for conformance to the TAIT-INFRA93SERIES-MIB.')
rctSystemInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 22)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctSiConfiguredBalancedLineInLevel"), ("TAIT-INFRA93SERIES-MIB", "rctSiConfiguredBalancedLineOutLevel"), ("TAIT-INFRA93SERIES-MIB", "rctSiTxKey"), ("TAIT-INFRA93SERIES-MIB", "rctSiRxGate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rctSystemInterfaceGroup = rctSystemInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: rctSystemInterfaceGroup.setDescription('Reciter system interface')
linearTransmissionCapability = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 23)).setObjects(("TAIT-INFRA93SERIES-MIB", "rctAlarmTxRSynthOutOfLock"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmCartesianLoopUnstable"), ("TAIT-INFRA93SERIES-MIB", "systemAlarmTxRCableAbsent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    linearTransmissionCapability = linearTransmissionCapability.setStatus('current')
if mibBuilder.loadTexts: linearTransmissionCapability.setDescription('Information depending on existence of a linear power amplifier')
pmuInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 24)).setObjects(("TAIT-INFRA93SERIES-MIB", "pmuInfoProductCode"), ("TAIT-INFRA93SERIES-MIB", "pmuInfoSerialNumber"), ("TAIT-INFRA93SERIES-MIB", "pmuInfoHardwareVersion"), ("TAIT-INFRA93SERIES-MIB", "pmuInfoFirmwareVersion"), ("TAIT-INFRA93SERIES-MIB", "pmuInfoCalibrationUpdateDate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pmuInfoGroup = pmuInfoGroup.setStatus('current')
if mibBuilder.loadTexts: pmuInfoGroup.setDescription('The PMU info group.')
deprecatedOidGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 3570, 2, 2, 2, 5, 1, 27)).setObjects(("TAIT-INFRA93SERIES-MIB", "infoStandaloneNodeStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    deprecatedOidGroup = deprecatedOidGroup.setStatus('deprecated')
if mibBuilder.loadTexts: deprecatedOidGroup.setDescription('Deprecated OIDs')
mibBuilder.exportSymbols("TAIT-INFRA93SERIES-MIB", rctAlarm6144MHzSynthOutOfLock=rctAlarm6144MHzSynthOutOfLock, paAlarmFinal2CurrentHigh=paAlarmFinal2CurrentHigh, pmuAlarmVoltageOutHigh=pmuAlarmVoltageOutHigh, customAlarm11=customAlarm11, paAlarmSupplyVoltageLow=paAlarmSupplyVoltageLow, reciterAlarms=reciterAlarms, reciter=reciter, rctRfReceiverAnalogGateState=rctRfReceiverAnalogGateState, alarmSummaryBaseStation=alarmSummaryBaseStation, rctAlarmTxRSynthOutOfLock=rctAlarmTxRSynthOutOfLock, rctRfReceiverLC2RSSI=rctRfReceiverLC2RSSI, paAlarmNoPADetected=paAlarmNoPADetected, paAlarmInvalidCalibration=paAlarmInvalidCalibration, paTxOutputGroup=paTxOutputGroup, fpAlarmsGroup=fpAlarmsGroup, linkHealthSequenceErrorsCount=linkHealthSequenceErrorsCount, paAlarmCurrentImbalance=paAlarmCurrentImbalance, paAlarmVSWRFault=paAlarmVSWRFault, systemAlarmFallbackControlled=systemAlarmFallbackControlled, fpAlarms=fpAlarms, rctRfReceiverLC1RxGateState=rctRfReceiverLC1RxGateState, rctTemperatureBoard=rctTemperatureBoard, fpInfoHardwareVersion=fpInfoHardwareVersion, pmuInfoCalibrationUpdateDate=pmuInfoCalibrationUpdateDate, linkHealthNetworkPacketLostCount=linkHealthNetworkPacketLostCount, rctAlarmTxFSynthOutOfLock=rctAlarmTxFSynthOutOfLock, infoTransmitterStatus=infoTransmitterStatus, rctAlarmSimulcastSynch=rctAlarmSimulcastSynch, paInfoHardwareVersion=paInfoHardwareVersion, networkLinks=networkLinks, fpInfoProductCode=fpInfoProductCode, rctHealth=rctHealth, mibConformance=mibConformance, pmuInfoSerialNumber=pmuInfoSerialNumber, mibComplianceList=mibComplianceList, infoMPTFallbackNodeStatus=infoMPTFallbackNodeStatus, nwChannelGroupOverflowCount=nwChannelGroupOverflowCount, rctTemperature=rctTemperature, rctRfReceiverSelectedDecodeSubAudibleType=rctRfReceiverSelectedDecodeSubAudibleType, rctSummary=rctSummary, fpInfoFirmwareVersion=fpInfoFirmwareVersion, pmuAlarmTemperatureHigh=pmuAlarmTemperatureHigh, rctAlarmReceiverSynch=rctAlarmReceiverSynch, systemAlarmAmbientTempHigh=systemAlarmAmbientTempHigh, linkInfoMPTNodeIPAddress=linkInfoMPTNodeIPAddress, healthGroup=healthGroup, fpAlarmNoFPDetected=fpAlarmNoFPDetected, rctSelectedChannelSigProfileName=rctSelectedChannelSigProfileName, monitored=monitored, alarmSummaryMajor=alarmSummaryMajor, alarmSummaryGroup=alarmSummaryGroup, networkLinksSummary=networkLinksSummary, paInfo=paInfo, customAlarm5=customAlarm5, networkInterfaces=networkInterfaces, paAlarmReversePowerHigh=paAlarmReversePowerHigh, rctSiRxGate=rctSiRxGate, licenceAnalogConventional=licenceAnalogConventional, pmuStateOutStatus=pmuStateOutStatus, alarmSummaryReciter=alarmSummaryReciter, pmuAlarmMainsFailure=pmuAlarmMainsFailure, pmuAlarmVoltageOutLow=pmuAlarmVoltageOutLow, linkInfoNetworkPacketCount=linkInfoNetworkPacketCount, rctRfInterferenceCounter=rctRfInterferenceCounter, powerManagementUnit=powerManagementUnit, alarmSummaryPowerAmplifier=alarmSummaryPowerAmplifier, infoGroup=infoGroup, linkInfoGroup=linkInfoGroup, rctSiConfiguredBalancedLineOutLevel=rctSiConfiguredBalancedLineOutLevel, pmuStateBusConnect=pmuStateBusConnect, rctRfReceiveQuality=rctRfReceiveQuality, linkInfoCtrlProtocolStatus=linkInfoCtrlProtocolStatus, pmuAlarms=pmuAlarms, paAlarmForwardPowerLow=paAlarmForwardPowerLow, licenceDmrFull=licenceDmrFull, rctInfoSerialNumber=rctInfoSerialNumber, linkHealthNetworkJitterCount=linkHealthNetworkJitterCount, pmuAlarmBatteryProtect=pmuAlarmBatteryProtect, rctReceiverGroup=rctReceiverGroup, licenceDmrConventional=licenceDmrConventional, alarmSummaryMinor=alarmSummaryMinor, mibGroups=mibGroups, rctRfReceiverSelectedDecodeCTCSS=rctRfReceiverSelectedDecodeCTCSS, linkHealth=linkHealth, rctRfTxSelectedEncodeSubAudibleType=rctRfTxSelectedEncodeSubAudibleType, info=info, rctAlarmRxCalibrationInvalid=rctAlarmRxCalibrationInvalid, paAlarmFinal1CurrentHigh=paAlarmFinal1CurrentHigh, rctInfoProductCode=rctInfoProductCode, rctSelectedChannelRxFreq=rctSelectedChannelRxFreq, nwConfiguredNtpServerAddress=nwConfiguredNtpServerAddress, customAlarms=customAlarms, customAlarm9=customAlarm9, licenceDmrAccess=licenceDmrAccess, nwChannelGroupLateStreamsCount=nwChannelGroupLateStreamsCount, fpAlarmFan2=fpAlarmFan2, reciterAlarmsGroup=reciterAlarmsGroup, pmuInfoProductCode=pmuInfoProductCode, licenceDmrExpress=licenceDmrExpress, rctSelectedChannelGroup=rctSelectedChannelGroup, pmuInfo=pmuInfo, linkInfo=linkInfo, paInfoSerialNumber=paInfoSerialNumber, alarmSummaryFrontPanel=alarmSummaryFrontPanel, customAlarm7=customAlarm7, systemAlarmAmbientTempLow=systemAlarmAmbientTempLow, pmuAlarmCurrentOutHigh=pmuAlarmCurrentOutHigh, rctRfReceiverSelectedDecodeDCS=rctRfReceiverSelectedDecodeDCS, nwChannelGroupEmptiestBufferLevel=nwChannelGroupEmptiestBufferLevel, rctAlarmInvalidChannelSelected=rctAlarmInvalidChannelSelected, pmuStateBatteryInVoltage=pmuStateBatteryInVoltage, nwChannelGroupStatus=nwChannelGroupStatus, pmuAlarmBatteryVoltageHigh=pmuAlarmBatteryVoltageHigh, nwChannelGroupLostPacketsCount=nwChannelGroupLostPacketsCount, linearTransmissionCapability=linearTransmissionCapability, healthNetworkConnLogChan1State=healthNetworkConnLogChan1State, infra93MIB=infra93MIB, rctInfoHardwareVersion=rctInfoHardwareVersion, rctAlarmOverTemperature=rctAlarmOverTemperature, alarmSummaryCustomAlarms=alarmSummaryCustomAlarms, rctAlarmTxCalibrationInvalid=rctAlarmTxCalibrationInvalid, linkHealthNetworkJitterLastOver=linkHealthNetworkJitterLastOver, mibObjects=mibObjects, licenceDmrNetworkSatellite=licenceDmrNetworkSatellite, infoStandaloneNodeStatus=infoStandaloneNodeStatus, systemAlarmQoSTransmitBuffer=systemAlarmQoSTransmitBuffer, paHealth=paHealth, pmuInfoHardwareVersion=pmuInfoHardwareVersion, nwChannelGroupMarshallingType=nwChannelGroupMarshallingType, rctRfReceiverSelectedSINADGatingLevel=rctRfReceiverSelectedSINADGatingLevel, pmuAlarmBatteryVoltageLow=pmuAlarmBatteryVoltageLow, rctSelectedChannelGroupName=rctSelectedChannelGroupName, licenceDmrExpress20=licenceDmrExpress20, rctSelectedChannelProfileName=rctSelectedChannelProfileName, customAlarm6=customAlarm6, nwConfiguredNtpBackupServerAddress1=nwConfiguredNtpBackupServerAddress1, deprecatedOidGroup=deprecatedOidGroup, paSummary=paSummary, pmuSummary=pmuSummary, rctRfReceiverRSSI=rctRfReceiverRSSI, licenceDmrCentralVoter=licenceDmrCentralVoter, rctRfReceiverLC2RxGateState=rctRfReceiverLC2RxGateState, rctRfTxSelectedEncodeDCS=rctRfTxSelectedEncodeDCS, rctSiTxKey=rctSiTxKey, rctRfReceiverSelectedFrequencyResponse=rctRfReceiverSelectedFrequencyResponse, alarms=alarms, customAlarmsGroup=customAlarmsGroup, healthSecureShellRunning=healthSecureShellRunning, nwChannelGroupUnderflowCount=nwChannelGroupUnderflowCount, paAlarmSupplyVoltageHigh=paAlarmSupplyVoltageHigh, pmuInfoGroup=pmuInfoGroup, systemAlarmsGroup=systemAlarmsGroup, paAlarmDriverCurrentHigh=paAlarmDriverCurrentHigh, systemAlarmTxRCableAbsent=systemAlarmTxRCableAbsent, rctRfTxSelectedEncodeSubAudibleDeviation=rctRfTxSelectedEncodeSubAudibleDeviation, nwChannelGroup=nwChannelGroup, paTxOutput=paTxOutput, fpInfoSerialNumber=fpInfoSerialNumber, paAlarms=paAlarms, nwChannelGroupGroup=nwChannelGroupGroup, nwConfiguredNtpBackupServerAddress2=nwConfiguredNtpBackupServerAddress2, rctSelectedChannelTxFreq=rctSelectedChannelTxFreq, pmuAlarmNoPMUDetected=pmuAlarmNoPMUDetected, PYSNMP_MODULE_ID=infra93MibMonitored, linkInfoMPTCtrlProtocolStatus=linkInfoMPTCtrlProtocolStatus, fpAlarmFan1=fpAlarmFan1, powerAmplifier=powerAmplifier, rctTransmitterGroup=rctTransmitterGroup, rctRfTxSelectedEncodeCTCSS=rctRfTxSelectedEncodeCTCSS, productInfo=productInfo, alarmSummaryPowerManagementUnit=alarmSummaryPowerManagementUnit, nwPorts=nwPorts, alarmSummarySystem=alarmSummarySystem, systemAlarmCartesianLoopUnstable=systemAlarmCartesianLoopUnstable, fpAlarmInvalidFirmware=fpAlarmInvalidFirmware, paTemperature=paTemperature, nwChannelGroupJitter=nwChannelGroupJitter, pmuInfoFirmwareVersion=pmuInfoFirmwareVersion, rctAlarmInvalidConfiguration=rctAlarmInvalidConfiguration, healthRunMode=healthRunMode, healthNetworkConnLogChan2State=healthNetworkConnLogChan2State, linkInfoMPTNodePriority=linkInfoMPTNodePriority, rctRfTxRfRepeatState=rctRfTxRfRepeatState, rctRfReceiverIsDisabled=rctRfReceiverIsDisabled, pmuAlarmsGroup=pmuAlarmsGroup, rctReceiveQualityGroup=rctReceiveQualityGroup, paGeneral=paGeneral, infra93MibMonitored=infra93MibMonitored, paAlarmShutdownImminent=paAlarmShutdownImminent, pmuStateMainsInState=pmuStateMainsInState, nwChannelGroupLocalBufferLevel=nwChannelGroupLocalBufferLevel, rctSelectedChannelColourCode=rctSelectedChannelColourCode, paTxOutputVSWR=paTxOutputVSWR, rctRfReceiver=rctRfReceiver, customAlarm12=customAlarm12, rctSelectedChannelNumber=rctSelectedChannelNumber, nwNtpInterfaceGroup=nwNtpInterfaceGroup, nwPortsGroup=nwPortsGroup, customAlarm2=customAlarm2, customAlarm10=customAlarm10, rctSelectedChannelTransmitPower=rctSelectedChannelTransmitPower, frontPanel=frontPanel, paAlarmFinal2TemperatureHigh=paAlarmFinal2TemperatureHigh, pmuStateOutCurrent=pmuStateOutCurrent, nwChannelGroupTransmitterSynchStatus=nwChannelGroupTransmitterSynchStatus, paAlarmPowerFoldback=paAlarmPowerFoldback, paAlarmDriverTemperatureHigh=paAlarmDriverTemperatureHigh, pmuAlarmInvalidFirmware=pmuAlarmInvalidFirmware, rctSystemInterface=rctSystemInterface, paInfoFirmwareVersion=paInfoFirmwareVersion, rctInfoFirmwareVersion=rctInfoFirmwareVersion, pmuStateOutVoltage=pmuStateOutVoltage, rctAlarmRxSynthOutOfLock=rctAlarmRxSynthOutOfLock, paAlarmFinal1TemperatureHigh=paAlarmFinal1TemperatureHigh, rctAlarm25MHzSynthOutOfLock=rctAlarm25MHzSynthOutOfLock, pmuAlarmSelfTestFailure=pmuAlarmSelfTestFailure, customAlarm1=customAlarm1, systemAlarmQoSLostPackets=systemAlarmQoSLostPackets, nwChannelGroupReceiverSynchStatus=nwChannelGroupReceiverSynchStatus, nwNtpInterface=nwNtpInterface, linkInfoDMRNodeIPAddress=linkInfoDMRNodeIPAddress, modules=modules, nwChannelGroupMarshallingDuration=nwChannelGroupMarshallingDuration, systemAlarmExternalRefAbsent=systemAlarmExternalRefAbsent, pmuStateGroup=pmuStateGroup, pmuSubmodules=pmuSubmodules, rctRfRcvInterference=rctRfRcvInterference, systemAlarmDuplicateNodePriority=systemAlarmDuplicateNodePriority, rctSiConfiguredBalancedLineInLevel=rctSiConfiguredBalancedLineInLevel, linkInfoDMRNodePriority=linkInfoDMRNodePriority, productEnabledFeatures=productEnabledFeatures, rctSystemInterfaceGroup=rctSystemInterfaceGroup, infoDMRFallbackNodeStatus=infoDMRFallbackNodeStatus, systemAlarms=systemAlarms, paInfoProductCode=paInfoProductCode, paAlarmsGroup=paAlarmsGroup, rctSelectedChannelSystemType=rctSelectedChannelSystemType, nwSvpPort=nwSvpPort, systemAlarmNTPSynchronisation=systemAlarmNTPSynchronisation, pmuAlarmShutdownImminent=pmuAlarmShutdownImminent, alarmSummary=alarmSummary, fpAlarmFan3=fpAlarmFan3, systemAlarm1PPSAbsent=systemAlarm1PPSAbsent, pmuStateAuxOutState=pmuStateAuxOutState, pmuState=pmuState, fpSummary=fpSummary, rctRfReceiverLC1RSSI=rctRfReceiverLC1RSSI, pmuStateBatteryInState=pmuStateBatteryInState, paTxOutputForwardPower=paTxOutputForwardPower, rctTemperatureGroup=rctTemperatureGroup, mibCompliance=mibCompliance, health=health, rctInfo=rctInfo, pmuHealth=pmuHealth)
mibBuilder.exportSymbols("TAIT-INFRA93SERIES-MIB", customAlarm4=customAlarm4, fpHealth=fpHealth, rctSelectedChannel=rctSelectedChannel, systemAlarmQoSJitter=systemAlarmQoSJitter, rctSelectedChannelName=rctSelectedChannelName, customAlarm8=customAlarm8, rctRfTxSelectFrequencyResponse=rctRfTxSelectFrequencyResponse, productSummary=productSummary, rctRfInterferenceEvents=rctRfInterferenceEvents, rctRfTransmitter=rctRfTransmitter, customAlarm3=customAlarm3, fpInfo=fpInfo, paAlarmInvalidFirmware=paAlarmInvalidFirmware)
