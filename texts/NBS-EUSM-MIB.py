#
# PySNMP MIB module NBS-EUSM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/mrv/NBS-EUSM-MIB
# Produced by pysmi-1.1.12 at Tue Sep 17 13:34:36 2024
# On host fv-az975-559 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
nbsCmmcPortEntry, nbsCmmcSlotEntry = mibBuilder.importSymbols("NBS-CMMC-MIB", "nbsCmmcPortEntry", "nbsCmmcSlotEntry")
nbs, = mibBuilder.importSymbols("NBS-MIB", "nbs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Integer32, iso, IpAddress, Counter32, MibIdentifier, NotificationType, ModuleIdentity, TimeTicks, Gauge32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Integer32", "iso", "IpAddress", "Counter32", "MibIdentifier", "NotificationType", "ModuleIdentity", "TimeTicks", "Gauge32", "ObjectIdentity")
StorageType, DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "DisplayString", "TextualConvention", "RowStatus")
nbsEusmMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 629, 202))
if mibBuilder.loadTexts: nbsEusmMib.setLastUpdated('201103221412Z')
if mibBuilder.loadTexts: nbsEusmMib.setOrganization('NBS')
if mibBuilder.loadTexts: nbsEusmMib.setContactInfo('For technical support, please contact your service channel')
if mibBuilder.loadTexts: nbsEusmMib.setDescription('MIB for representing NBS Eusm information')
nbsEusmSlotGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 1))
if mibBuilder.loadTexts: nbsEusmSlotGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotGrp.setDescription('Stage-II Slot context features for EUSM boards')
nbsEusmPortGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 2))
if mibBuilder.loadTexts: nbsEusmPortGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortGrp.setDescription('Stage-II Port context featurea for EUSM boards')
nbsEusmTestGrp = ObjectIdentity((1, 3, 6, 1, 4, 1, 629, 202, 3))
if mibBuilder.loadTexts: nbsEusmTestGrp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTestGrp.setDescription('Testing category of features for EUSM boards. The example items\n       that may go here are the smart loopback traffic generation,\n       loss/gain analysis, performance monitoring, etc.')
nbsEusmSlotTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 1), )
if mibBuilder.loadTexts: nbsEusmSlotTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotTable.setDescription('Contains a description of slot context features applicable\n           for the whole module. There is going to be one row for each\n           slot. All the scalar type objects applicable at the slot\n           context are dumped here.')
nbsEusmSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmSlotEntry"))
nbsEusmSlotEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmSlotEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotEntry.setDescription('Contains a description of slot context features applicable\n           for the whole module. There is going to be one row for each\n           slot. All the scalar type objects applicable at the slot\n           context are dumped here.')
nbsEusmSlotSupportsEusm = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSupported", 1), ("supported", 2))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotSupportsEusm.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotSupportsEusm.setDescription('Is EUSM config and status supported for this slot?')
nbsEusmSlotAccControlActionUntag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("permit", 2), ("deny", 3))).clone('permit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionUntag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionUntag.setDescription('permit(2) or deny(3) works on all untagged frames')
nbsEusmSlotAccControlActionTag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("denyAll", 2), ("denyVlan", 3), ("permitVlan", 4), ("permitAll", 5))).clone('permitAll')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionTag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlActionTag.setDescription('denyAll(2) filters all tagged frames\n\n           denyVlan(3) and permitVlan(4) work on the specified list\n\n           permitAll(5) negates access control of tagged frames')
nbsEusmSlotAccControlVidList = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotAccControlVidList.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotAccControlVidList.setDescription('List of VLAN in a free format, for example 10-12 15 23-43\n           1000-1050 specifies 3 different ranges of vlan ids and one\n           isolated vlan id')
nbsEusmSlotLinkAggrAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("onRandom", 3), ("onXorAll", 4), ("deprecatedonSmac", 5), ("onDmac", 6), ("onXorSd", 7), ("onIp", 8))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrAdmin.setDescription('Depending on the link status of the trunk ports the Link\n           Aggregation operational status may be different, this is why\n           it calls for both Admin and Oper objects')
nbsEusmSlotLinkAggrOper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("onRandom", 3), ("onXorAll", 4), ("onSmac", 5), ("onDmac", 6), ("onXorSd", 7), ("onIp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrOper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLinkAggrOper.setDescription(' ')
nbsEusmSlotStormControlBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlBroadcast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlBroadcast.setDescription('User-specified maximum allowed Broadcast frames, in\n           units of 1000 frames/second.  The value zero (0)\n           indicates this feature is disabled, so no cap will\n           be enforced.')
nbsEusmSlotStormControlMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlMulticast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlMulticast.setDescription('User-specified maximum allowed Multicast frames, in\n           units of 1000 frames/second.  The value zero (0)\n           indicates this feature is disabled, so no cap will\n           be enforced.')
nbsEusmSlotStormControlUnicast = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormControlUnicast.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotStormControlUnicast.setDescription('User-specified maximum allowed Unicast frames, in\n           units of 1000 frames/second.  The value zero (0)\n           indicates this feature is disabled, so no cap will\n           be enforced.')
nbsEusmSlotStormBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotStormBurstSize.setStatus('deprecated')
if mibBuilder.loadTexts: nbsEusmSlotStormBurstSize.setDescription('**** DEPRECATED ****')
nbsEusmSlotCoSMode = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("dscpOnly", 2), ("tagOnly", 3), ("bothTagDscp", 4), ("none", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotCoSMode.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotCoSMode.setDescription('If  the user selects bothTagDscp(4), and a packet arrives\n           with both DSCP and a Vlan tag, the DSCP priority system will\n           take precedence.\n\n           tagOnly(3) will use Layer 2 Vlan Priority bits to assign a\n           Service\n\n           Level Class (SLC) to a packet and tagMappingTable\n           information will be used.\n\n           dscpOnly(2) will use Layer 3 DSCP bits to assign an SL class\n           to a packet.\n\n           dscpMappingTable information will be used')
nbsEusmSlotDscpRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpRemark.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpRemark.setDescription('The EUSM can be set to mark egress packets with a new DSCP.\n           The user can set to remark egress DSCP in one of the\n           following modes: AF or CS Remarking only applies to IPv4 or\n           IPv6 packets. The user can define which type of incoming\n           (ingress )DSCP frames will be remarked.Selection includes\n           the combination of EF,AF,CS,Zero DSCP and all others.')
nbsEusmSlotDscpEgressMode = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("afMode", 2), ("csMode", 3))).clone('afMode')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpEgressMode.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpEgressMode.setDescription('The user can set to egress remark DSCP in one of the\n           following modes:\n\n           a) Map CoS class to AF CPs (call it AF-mode)\n              0: AF12\n              1: AF22\n              2: AF32\n              3: AF42\n\n           b) Map CoS class to Class selectors CPs (call it CS-mode)\n              0: 000000\n              1: 001000\n              2: 010000\n              3: 110000')
nbsEusmSlotDscpIngressEf = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressEf.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressEf.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressAf = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAf.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAf.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressCs = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressCs.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressCs.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressZeroDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressZeroDscp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressZeroDscp.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotDscpIngressAllOther = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("enable", 2), ("disable", 3))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAllOther.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotDscpIngressAllOther.setDescription('One of the five ingress options EF,AF,CS,ZERO and OTHER')
nbsEusmSlotIometrix = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("on", 3))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotIometrix.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotIometrix.setDescription('Controls whether or not the EUSM should enable Iometrix\n           Level 1 cNode agent behavior')
nbsEusmSlotManagementVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(4094)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotManagementVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotManagementVid.setDescription('VLAN Id reserved for EUSM management activities.')
nbsEusmSlotUserPortIRAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotUserPortIRAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotUserPortIRAdmin.setDescription('Unit is kilobits per second.\n\n           Max possible value is 4,294,967,295 which is large enough\n           even to represent 1 Terabit communication. This applies to\n           user ingress traffic that does not match any defined\n           flow. 0 is acceptable value, which means discard all non-flow traffic.\n           Any value above 1000000 for EUSM is considered as no limit.')
nbsEusmSlotUserPortIROper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotUserPortIROper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotUserPortIROper.setDescription('Unit is kilobits per second.\n\n           Max possible value is 4,294,967,295 which is large enough\n           even to represent 1 Terabit communication. This is the actual\n           value applied to user ingress traffic that does not match any\n           defined flow. It is based on the configured IRAdmin object\n           modified to match the constraints of the device.')
nbsEusmSlotMaxFlowCfgSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 23), Integer32().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxFlowCfgSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxFlowCfgSize.setDescription('Maximum number of entries in the FlowCfg table.  This may\n           vary from slot to slot if different versions of EUSM software\n           support different table sizes.')
nbsEusmSlotMaxVlanTranSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 24), Integer32().clone(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxVlanTranSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxVlanTranSize.setDescription('Maximum number of entries in the VLAN Translation table.\n\n           This may vary from slot to slot if different versions of\n           EUSM software support different table sizes.')
nbsEusmSlotMaxDscpMapSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 25), Integer32().clone(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxDscpMapSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxDscpMapSize.setDescription('Maximum number of entries in the DSCP to SLC Priority Map table.\n\n           This may vary from slot to slot if different versions of\n           EUSM software support different table sizes.')
nbsEusmSlotMaxCosPrioSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 1, 1, 26), Integer32().clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotMaxCosPrioSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotMaxCosPrioSize.setDescription('Maximum number of entries in the VLAN CoS to SLC Priority table.\n\n           This may vary from slot to slot if different versions of\n           EUSM software support different table sizes.')
nbsEusmFlowCfgTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 2), )
if mibBuilder.loadTexts: nbsEusmFlowCfgTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgTable.setDescription('A table that describes the Vlan Flow Rate Limits\n\n           At the moment there is a limit of 32 entries for this table')
nbsEusmFlowCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmFlowCfgChassis"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgSlot"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgVid"), (0, "NBS-EUSM-MIB", "nbsEusmFlowCfgPriority"))
if mibBuilder.loadTexts: nbsEusmFlowCfgEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgEntry.setDescription('Contains a description of a particular Vlan Flow Rate Limit\n           information')
nbsEusmFlowCfgChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmFlowCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmFlowCfgVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgVid.setDescription('The Vid part of the index.')
nbsEusmFlowCfgPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgPriority.setDescription("Priority part of the VLAN as index.\n\n           0(Zero) is don't care and the real priority starts 1 based.")
nbsEusmFlowCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgRowStatus.setDescription('This table RowStatus object to create, modify and delete the rows')
nbsEusmFlowCfgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgStorageType.setDescription('This table StorageType')
nbsEusmFlowCfgIRAdmin = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgIRAdmin.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgIRAdmin.setDescription('Information Rate (IR) specified for the Vid and priority\n           combo.\n\n           Unit is kilobits per second. Max possible value is\n           4,294,967,295 which is large enough even to represent 1\n           Terabit communication.')
nbsEusmFlowCfgIROper = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowCfgIROper.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgIROper.setDescription('Information Rate (IR) that is actually applied to the flow.\n\n           Unit is kilobits per second. Max possible value is\n           4,294,967,295 which is large enough even to represent 1\n           Terabit communication.')
nbsEusmFlowCfgClearCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("idle", 2), ("inProgress", 3), ("clear", 4))).clone('idle')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmFlowCfgClearCounter.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowCfgClearCounter.setDescription('To clear the counters for selected row')
nbsEusmFlowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 3), )
if mibBuilder.loadTexts: nbsEusmFlowStatusTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusTable.setDescription('A table that describes the Vlan Flow Rate Limits\n           At the moment there is a limit of 32 entries for this table.')
nbsEusmFlowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1), )
nbsEusmFlowCfgEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmFlowStatusEntry"))
nbsEusmFlowStatusEntry.setIndexNames(*nbsEusmFlowCfgEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmFlowStatusEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusEntry.setDescription('Contains status part of the FlowCfgTable')
nbsEusmFlowStatusRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowStatusRxFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusRxFrames.setDescription('Received Frames counted')
nbsEusmFlowStatusRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmFlowStatusRxOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmFlowStatusRxOctets.setDescription('Received Octets counted')
nbsEusmVidMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 4), )
if mibBuilder.loadTexts: nbsEusmVidMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapTable.setDescription('A table that describes the Vlan Translation table\n\n           At the moment there is a limit of 3 or 7 entries for this\n           table')
nbsEusmVidMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmVidMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmVidMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmVidMapFromVid"))
if mibBuilder.loadTexts: nbsEusmVidMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapEntry.setDescription('Contains a description of a particular Vlan Translation\n           table feature')
nbsEusmVidMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmVidMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmVidMapFromVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmVidMapFromVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapFromVid.setDescription('The vlanTranslation index.')
nbsEusmVidMapToVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(100)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapToVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapToVid.setDescription('The vlanTranslation index.')
nbsEusmVidMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapRowStatus.setDescription('This table RowStatus object to create, modify and delete the\n           rows')
nbsEusmVidMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 4, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmVidMapStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmVidMapStorageType.setDescription('This table StorageType')
nbsEusmCoSDscpMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 5), )
if mibBuilder.loadTexts: nbsEusmCoSDscpMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapTable.setDescription('Only 7 possible rows in this table.It is possible to make\n           this table without the RowStatus object as there are not\n           going to be variable number of rows in this table. But we\n           could define less than 7 rows. So RowStatus is added on')
nbsEusmCoSDscpMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmCoSDscpMapDscp"))
if mibBuilder.loadTexts: nbsEusmCoSDscpMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapEntry.setDescription('Ingress Tag prio is mapped to egress SL class queue or\n           priority')
nbsEusmCoSDscpMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmCoSDscpMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmCoSDscpMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapDscp.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapDscp.setDescription('DSCP range is 0..63 and since it is an index we make it\n           1..64 as the 1 based range')
nbsEusmCoSDscpMapSlcPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("normal", 2), ("medium", 3), ("high", 4))).clone('low')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlcPrio.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapSlcPrio.setDescription('Service Level Class Priority has 4 queues. Each ingress\n           packet is assigned a Diffserv Service Level Class as part of\n           the ingress traffic process. A packet can be forwarded to\n           any one of 4 hardware egress packet queues of a port\n           according to the packet SL class.')
nbsEusmCoSDscpMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapRowStatus.setDescription('This table RowStatus object to create, modify and delete the rows')
nbsEusmCoSDscpMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 5, 1, 6), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSDscpMapStorageType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSDscpMapStorageType.setDescription('This table StorageType')
nbsEusmCoSTagPrioMapTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 1, 6), )
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapTable.setDescription('Only 8 rows in this table.  It is a fixed size table because\n           rows for all values of the table index Priority object must\n           be defined in the configured device.')
nbsEusmCoSTagPrioMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1), ).setIndexNames((0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapChassis"), (0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapSlot"), (0, "NBS-EUSM-MIB", "nbsEusmCoSTagPrioMapPriority"))
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapEntry.setDescription('Ingress Tag priority is mapped to egress Service Level class\n           queue or priority.')
nbsEusmCoSTagPrioMapChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapChassis.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapChassis.setDescription('The index of the table to refer to Chassis')
nbsEusmCoSTagPrioMapSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlot.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlot.setDescription('The index of the table to refer to Slot of this EUSM')
nbsEusmCoSTagPrioMapPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapPriority.setDescription('Tag priority range is 0..7.')
nbsEusmCoSTagPrioMapSlcPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("normal", 2), ("medium", 3), ("high", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlcPrio.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCoSTagPrioMapSlcPrio.setDescription('Service Level Class Priority has 4 queues. Each ingress\n           packet is assigned a Diffserv Service Level Class as part of\n           the ingress traffic process. A packet can be forwarded to\n           any one of 4 hardware egress packet queues of a port\n           according to the packet SL class.')
nbsEusmPortTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 2, 1), )
if mibBuilder.loadTexts: nbsEusmPortTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortTable.setDescription('Contains a description of Port context features applicable\n           There is going to be one row for each port. All the scalar\n           type objects applicable at the port context are dumped\n           here.')
nbsEusmPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmPortEntry"))
nbsEusmPortEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmPortEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortEntry.setDescription('Contains a description of slot context features applicable\n           for the whole module. There is going to be one row for each\n           slot. All the scalar type objects applicable at the slot\n           context are dumped here.')
nbsEusmPortSupportsEusm = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSupported", 1), ("supported", 2))).clone('notSupported')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPortSupportsEusm.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSupportsEusm.setDescription('Is EUSM config and status supported for this slot?')
nbsEusmPortSmartLoopbackAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("all", 3), ("onDA", 4), ("onVid", 5), ("onBoth", 6), ("mac", 7))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackAction.setDescription(' ')
nbsEusmPortSmartLoopbackSwap = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("off", 2), ("on", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackSwap.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackSwap.setDescription(' ')
nbsEusmPortSmartLoopbackMac = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackMac.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackMac.setDescription(' ')
nbsEusmPortSmartLoopbackVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortSmartLoopbackVid.setDescription(' ')
nbsEusmPortVlanTagAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("add", 2), ("strip", 3), ("ignore", 4))).clone('ignore')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagAction.setDescription('add(2) need two more arguments s-vlanId and s-vlan-priority\n           strip(3)and ignore(4) does not need any argument')
nbsEusmPortVlanTagVid = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagVid.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagVid.setDescription('need to be specified when VlanTagAction is add(2)')
nbsEusmPortVlanTagPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmPortVlanTagPriority.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPortVlanTagPriority.setDescription('need to be specified when VlanTagAction is add(2)')
nbsEusmTgaTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 1), )
if mibBuilder.loadTexts: nbsEusmTgaTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTable.setDescription('Contains a description of Test context features applicable.\n\n           There is going to be one row for each port.')
nbsEusmTgaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmTgaEntry"))
nbsEusmTgaEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmTgaEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaEntry.setDescription('Contains a description of slot context features applicable\n           for the whole module.\n\n           There is going to be one row for each port.')
nbsEusmTgaDa = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaDa.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaDa.setDescription('Destination Address - MAC address')
nbsEusmTgaDaType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaDaType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaDaType.setDescription('Different options to specify the Destination Address')
nbsEusmTgaSa = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaSa.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaSa.setDescription('Source Address - MAC address')
nbsEusmTgaSaType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaSaType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaSaType.setDescription('Different options to specify the Source Address')
nbsEusmTgaTag = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaTag.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTag.setDescription("VLAN tag or e-type plus initial data If VLAN tagging is not\n           specified (i.e. Tag does not begin as '8100h', then the first\n           two bytes of Tag define the frame type, and the last two Tag\n           bytes are the first two data bytes")
nbsEusmTgaTagType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3), ("increment", 4))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaTagType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaTagType.setDescription('Different options to specify the Tag')
nbsEusmTgaPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="0000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaPattern.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaPattern.setDescription('The two Pattern bytes are replicated as needed to fill-out\n           the frame to the specified size')
nbsEusmTgaPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3))).clone('random')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaPatternType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaPatternType.setDescription('Different options to specify the Source Address')
nbsEusmTgaFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 9600)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameSize.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameSize.setDescription('Frame Size range from 64 to 9600')
nbsEusmTgaFrameSizeType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("random", 2), ("fixed", 3))).clone('fixed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameSizeType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameSizeType.setDescription('Different options to specify the Frame Size')
nbsEusmTgaFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967294)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameCount.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameCount.setDescription(' ')
nbsEusmTgaFrameCountType = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("continuous", 2), ("fixed", 3))).clone('continuous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaFrameCountType.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaFrameCountType.setDescription('Different options to specify the Frame Size')
nbsEusmTgaInterPacketGap = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(12, 134217727)).clone(1249928)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaInterPacketGap.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaInterPacketGap.setDescription('Rate Control - only option is fixed. Default is 1249928.\n           This sets an approx rate of 100/10/1 fps at 1000/100/10\n           Mbps. Number of bytes between frames. Controls traffic rate')
nbsEusmTgaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("start", 2), ("stop", 3))).clone('stop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmTgaAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmTgaAction.setDescription('Different actions to activate the traffic generation. There\n           are three frame generation activities: specify, start, and\n           stop. Specifying and actually starting traffic may be done\n           together or separately. In fact, it is reasonable to specify\n           once, then start (and stop) many times.')
nbsEusmCableTestTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 2), )
if mibBuilder.loadTexts: nbsEusmCableTestTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestTable.setDescription('Cable testing feature')
nbsEusmCableTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1), )
nbsCmmcPortEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmCableTestEntry"))
nbsEusmCableTestEntry.setIndexNames(*nbsCmmcPortEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmCableTestEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestEntry.setDescription('Cable testing feature')
nbsEusmCableTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("testStart", 2), ("testInProgress", 3), ("testCompleted", 4), ("testIdle", 5))).clone('testIdle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmCableTestStatus.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestStatus.setDescription('To initiate and get the status of the cable test feature. It\n           is applicable only to copper ports. In the future we may\n           have multiple copper ports. A GET on this object will show\n           testIdle if a test has never been run, or testCompleted(4)\n           if it has.\n\n           When testStart(2) is SET, for a short time of\n           about 3 seconds you would expect to see testInProgress(3).\n           Time-stamp of the test start will be sent by the SNMP agent\n           to the line-card to keep track of the time instance of the\n           test.')
nbsEusmCableTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmCableTestResult.setStatus('current')
if mibBuilder.loadTexts: nbsEusmCableTestResult.setDescription('This string will give out the result of the cable test done\n           with a time stamp that gives the indication as to when the\n           CableTest was initiated. This also gives the result for all\n           the 4 pairs of wire. Possible results status includes\n           invalid, good, mismatch short and open.\n\n           When the status is mismatch, short or open, there will be\n           length indicating more information about the location of the\n           fault. From the LNXNM point of view it is easy to deal with\n           scalars than tables - so this is made into DisplayString.\n           Since the MVs use it read-only and display anyway, it is\n           probably simpler to deal with scalar display string rather\n           than table. An example TestResult may look like the\n           following\n\n             <time-stamp>pair-1 good,pair-2 invalid,pair-3 open at 25\n             meters,pair-4 good.')
nbsEusmLgaTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 3), )
if mibBuilder.loadTexts: nbsEusmLgaTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaTable.setDescription('Contains a description of Traffic discrepancy counters.')
nbsEusmLgaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmLgaEntry"))
nbsEusmLgaEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmLgaEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaEntry.setDescription('Discrepancy entry')
nbsEusmLgaRdAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdAllFrames.setDescription('The count of all frames (good+bad) lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRducFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRducFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRducFrames.setDescription('The count of good unicast frames lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdmcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdmcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdmcFrames.setDescription('The count of good multicast frames lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdbcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdbcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdbcFrames.setDescription('The count of good broadcast frames lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSize64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSize64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSize64.setDescription('The count of all 64 byte frames lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax127.setDescription('The count of all 65-127 byte frames lost/gained (-/+) in the\n           most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax255.setDescription('The count of all 128-255 byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax511.setDescription('The count of all 256-511 byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1023.setDescription('The count of all 512-1023 byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax1518.setDescription('The count of all 1024-1518 byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeMax2047.setDescription('The count of all 1519-2047 byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdSizeOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdSizeOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdSizeOvr2047.setDescription('The count of all 2048-plus byte frames lost/gained (-/+) in\n           the most recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdFrameDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdFrameDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdFrameDivisor.setDescription('The divisor to calculate frame loss/gain ratios for the most\n           recent interval.')
nbsEusmLgaRdAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdAllOctets.setDescription('The count of all frame octets lost/gained (-/+) in the most\n           recent interval.\n\n           Not supported value: 0x80000000')
nbsEusmLgaRdOctetDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdOctetDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdOctetDivisor.setDescription('The divisor to calculate octet loss/gain ratios for the most\n           recent interval.')
nbsEusmLgaRdTimeSpan = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaRdTimeSpan.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaRdTimeSpan.setDescription('The time span (tenths of a sec) for the most recent\n           interval.')
nbsEusmLgaAdAllFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdAllFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdAllFrames.setDescription('The accumulated count of all frames (good+bad) lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAducFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAducFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAducFrames.setDescription('The accumulated count of good unicast frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdmcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdmcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdmcFrames.setDescription('The accumulated count of good multicast frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdbcFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdbcFrames.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdbcFrames.setDescription('The accumulated count of good broadcast frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSize64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSize64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSize64.setDescription('The accumulated count of all 64 byte frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax127.setDescription('The accumulated count of all 65-127 byte frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax255.setDescription('The accumulated count of all 128-255 byte frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax511.setDescription('The accumulated count of all 256-511 byte frames lost/gained\n           (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1023.setDescription('The accumulated count of all 512-1023 byte frames\n           lost/gained (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax1518.setDescription('The accumulated count of all 1024-1518 byte frames\n           lost/gained (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeMax2047.setDescription('The accumulated count of all 1519-2047 byte frames\n                 lost/gained (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdSizeOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdSizeOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdSizeOvr2047.setDescription('The accumulated count of all 2048-plus byte frames\n           lost/gained (-/+) over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdFrameDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdFrameDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdFrameDivisor.setDescription('The divisor to calculate frame loss/gain ratios over all intervals.')
nbsEusmLgaAdAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdAllOctets.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdAllOctets.setDescription('The accumulated count of all frame octets lost/gained (-/+)\n           over all intervals.\n\n           Not supported value: 0x80000000')
nbsEusmLgaAdOctetDivisor = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdOctetDivisor.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdOctetDivisor.setDescription('The divisor to calculate octet loss/gain ratios over all intervals.')
nbsEusmLgaAdTimeSpan = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 32), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmLgaAdTimeSpan.setStatus('current')
if mibBuilder.loadTexts: nbsEusmLgaAdTimeSpan.setDescription('The accumulated time span (tenths of a sec) for all intervals.')
nbsEusmSlotLgaInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 86400)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLgaInterval.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLgaInterval.setDescription('Traffic Analysis (loss/gain) sampling time interval (sec).\n           Practical range allowed is 10 seconds to 1 day.')
nbsEusmSlotLgaAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 3, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("inactive", 2), ("start", 3), ("stop", 4), ("inProgress", 5))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotLgaAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotLgaAction.setDescription('Traffic Analysis (loss/gain) activity status.')
nbsEusmPmTable = MibTable((1, 3, 6, 1, 4, 1, 629, 202, 3, 4), )
if mibBuilder.loadTexts: nbsEusmPmTable.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmTable.setDescription('Contains a description of Traffic discrepancy counters.')
nbsEusmPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1), )
nbsCmmcSlotEntry.registerAugmentions(("NBS-EUSM-MIB", "nbsEusmPmEntry"))
nbsEusmPmEntry.setIndexNames(*nbsCmmcSlotEntry.getIndexNames())
if mibBuilder.loadTexts: nbsEusmPmEntry.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmEntry.setDescription('Performance Monitoring entry')
nbsEusmPmAvgAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvgAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvgAllSizes.setDescription('The average transit time (nanosec) for monitored frames.')
nbsEusmPmAvg64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg64.setDescription('The average transit time (nanosec) for monitored 64 byte\n           frames.')
nbsEusmPmAvg127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg127.setDescription('The average transit time (nanosec) for monitored 65-127 byte\n           frames.')
nbsEusmPmAvg255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg255.setDescription('The average transit time (nanosec) for monitored 128-255\n           byte frames.')
nbsEusmPmAvg511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg511.setDescription('The average transit time (nanosec) for monitored 256-511\n           byte frames.')
nbsEusmPmAvg1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg1023.setDescription('The average transit time (nanosec) for monitored 512-1023\n           byte frames.')
nbsEusmPmAvg1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg1518.setDescription('The average transit time (nanosec) for monitored 1024-1518\n           byte frames.')
nbsEusmPmAvg2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvg2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvg2047.setDescription('The average transit time (nanosec) for monitored 1519-2047\n           byte frames.')
nbsEusmPmAvgOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmAvgOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmAvgOvr2047.setDescription('The average transit time (nanosec) for monitored 2048-plus\n           byte frames.')
nbsEusmPmMinAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMinAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMinAllSizes.setDescription('The minimum transit time (nanosec) for monitored frames.')
nbsEusmPmMin64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin64.setDescription('The minimum transit time (nanosec) for monitored 64\n           byte frames.')
nbsEusmPmMin127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin127.setDescription('The minimum transit time (nanosec) for monitored 65-127\n           byte frames.')
nbsEusmPmMin255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin255.setDescription('The minimum transit time (nanosec) for monitored 128-255\n           byte frames.')
nbsEusmPmMin511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin511.setDescription('The minimum transit time (nanosec) for monitored 256-511\n           byte frames.')
nbsEusmPmMin1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin1023.setDescription('The minimum transit time (nanosec) for monitored 512-1023\n           byte frames.')
nbsEusmPmMin1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin1518.setDescription('The minimum transit time (nanosec) for monitored 1024-1518\n           byte frames.')
nbsEusmPmMin2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMin2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMin2047.setDescription('The minimum transit time (nanosec) for monitored 1519-2047\n           byte frames.')
nbsEusmPmMinOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMinOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMinOvr2047.setDescription('The minimum transit time (nanosec) for monitored 2048-plus\n           byte frames.')
nbsEusmPmMaxAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMaxAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMaxAllSizes.setDescription('The maximum transit time (nanosec) for monitored frames.')
nbsEusmPmMax64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax64.setDescription('The maximum transit time (nanosec) for monitored 64\n           byte frames.')
nbsEusmPmMax127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax127.setDescription('The maximum transit time (nanosec) for monitored 65-127\n           byte frames.')
nbsEusmPmMax255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax255.setDescription('The maximum transit time (nanosec) for monitored 128-255\n           byte frames.')
nbsEusmPmMax511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax511.setDescription('The maximum transit time (nanosec) for monitored 256-511\n           byte frames.')
nbsEusmPmMax1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax1023.setDescription('The maximum transit time (nanosec) for monitored 512-1023\n           byte frames.')
nbsEusmPmMax1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax1518.setDescription('The maximum transit time (nanosec) for monitored 1024-1518\n           byte frames.')
nbsEusmPmMax2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMax2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMax2047.setDescription('The maximum transit time (nanosec) for monitored 1519-2047\n           byte frames.')
nbsEusmPmMaxOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmMaxOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmMaxOvr2047.setDescription('The maximum transit time (nanosec) for monitored 2048-plus\n           byte frames.')
nbsEusmPmFramesAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFramesAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFramesAllSizes.setDescription('The count of all monitored frames.')
nbsEusmPmFrames64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames64.setDescription('The count of all monitored 64 byte frames.')
nbsEusmPmFrames127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames127.setDescription('The count of all monitored 65-127 byte frames.')
nbsEusmPmFrames255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames255.setDescription('The count of all monitored 128-255 byte frames.')
nbsEusmPmFrames511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 32), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames511.setDescription('The count of all monitored 256-511 byte frames.')
nbsEusmPmFrames1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames1023.setDescription('The count of all monitored 512-1023 byte frames.')
nbsEusmPmFrames1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames1518.setDescription('The count of all monitored 1024-1518 byte frames.')
nbsEusmPmFrames2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 35), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFrames2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFrames2047.setDescription('The count of all monitored 1519-2047 byte frames.')
nbsEusmPmFramesOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 36), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmFramesOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmFramesOvr2047.setDescription('The count of all monitored 2048-plus byte frames.')
nbsEusmPmOctetsAllSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 37), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctetsAllSizes.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctetsAllSizes.setDescription('The count of octets in all monitored frames.')
nbsEusmPmOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 38), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets64.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets64.setDescription('The count of octets in all monitored 64 byte frames.')
nbsEusmPmOctets127 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets127.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets127.setDescription('The count of octets in all monitored 65-127 byte frames.')
nbsEusmPmOctets255 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets255.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets255.setDescription('The count of octets in all monitored 128-255 byte frames.')
nbsEusmPmOctets511 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 41), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets511.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets511.setDescription('The count of octets in all monitored 256-511 byte frames.')
nbsEusmPmOctets1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets1023.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets1023.setDescription('The count of octets in all monitored 512-1023 byte frames.')
nbsEusmPmOctets1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 43), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets1518.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets1518.setDescription('The count of octets in all monitored 1024-1518 byte frames.')
nbsEusmPmOctets2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 44), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctets2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctets2047.setDescription('The count of octets in all monitored 1519-2047 byte frames.')
nbsEusmPmOctetsOvr2047 = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 45), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmPmOctetsOvr2047.setStatus('current')
if mibBuilder.loadTexts: nbsEusmPmOctetsOvr2047.setDescription('The count of octets in all monitored 2048-plus byte frames.')
nbsEusmSlotPmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 604800)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmInterval.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmInterval.setDescription('Performance Monitoring time duration (sec). Practical range\n           allowed is 1 minute to 1 week.')
nbsEusmSlotPmSelector = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notSupported", 1), ("coToCpe", 2), ("cpeToCo", 3), ("cpeTx", 4), ("cpeRx", 5))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmSelector.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmSelector.setDescription("Performance Monitoring traffic direction selector.\n\n           coToCpe(2) measures from CO's active trunk port to\n           CPE's active trunk port.\n\n           cpeToCo(3) measures from CPE's active trunk port to\n           CO's active trunk port.\n\n           To measure from one CPE to another, the user should\n           designate the source CPE as cpeTx(4) and the\n           destination CPE as cpeRx(5).\n\n           The reflector CPE must be activated before the\n           source CPE.")
nbsEusmSlotPmAction = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("notSupported", 1), ("inactive", 2), ("start", 3), ("stop", 4), ("inProgress", 5), ("complete", 6), ("stopping", 7))).clone('notSupported')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nbsEusmSlotPmAction.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmAction.setDescription('Traffic Analysis (performance monitoring) activity status.')
nbsEusmSlotPmCapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 629, 202, 3, 4, 1, 49), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nbsEusmSlotPmCapabilities.setStatus('current')
if mibBuilder.loadTexts: nbsEusmSlotPmCapabilities.setDescription('This bitmask indicates which performance monitoring  selectors\n           this slot can support.  This object is mandatory for all slots\n           in systems where the nbsEusmSlotPmSelector object is supported.\n           Each capability is represented by one bit.  Set bit to 1 to\n           advertise capability, 0 to deny it.\n\n             Capability    Bit\n           --------------  ---\n                 reserved   0\n             notSupported   1\n                  coToCpe   2\n                  cpeToCo   3\n                    cpeTx   4\n                    cpeRx   5\n\n           OCTET STRING bitmasks count the leftmost bit (MSB) as 0.\n\n           A zero length OCTET STRING indicates that this object is not\n           supported.')
mibBuilder.exportSymbols("NBS-EUSM-MIB", nbsEusmPmOctets1023=nbsEusmPmOctets1023, nbsEusmFlowStatusRxOctets=nbsEusmFlowStatusRxOctets, nbsEusmCoSDscpMapEntry=nbsEusmCoSDscpMapEntry, nbsEusmVidMapToVid=nbsEusmVidMapToVid, nbsEusmSlotAccControlActionUntag=nbsEusmSlotAccControlActionUntag, nbsEusmLgaRdFrameDivisor=nbsEusmLgaRdFrameDivisor, nbsEusmCoSTagPrioMapSlot=nbsEusmCoSTagPrioMapSlot, nbsEusmVidMapFromVid=nbsEusmVidMapFromVid, nbsEusmPmOctets1518=nbsEusmPmOctets1518, nbsEusmSlotMaxCosPrioSize=nbsEusmSlotMaxCosPrioSize, nbsEusmVidMapStorageType=nbsEusmVidMapStorageType, nbsEusmCoSDscpMapSlot=nbsEusmCoSDscpMapSlot, nbsEusmPmMin64=nbsEusmPmMin64, nbsEusmPmMin1023=nbsEusmPmMin1023, nbsEusmSlotCoSMode=nbsEusmSlotCoSMode, nbsEusmPmFramesAllSizes=nbsEusmPmFramesAllSizes, nbsEusmPmAvgOvr2047=nbsEusmPmAvgOvr2047, nbsEusmSlotDscpEgressMode=nbsEusmSlotDscpEgressMode, nbsEusmLgaRdSizeMax255=nbsEusmLgaRdSizeMax255, nbsEusmPmMin255=nbsEusmPmMin255, nbsEusmPmMin1518=nbsEusmPmMin1518, nbsEusmCoSTagPrioMapEntry=nbsEusmCoSTagPrioMapEntry, nbsEusmVidMapSlot=nbsEusmVidMapSlot, nbsEusmLgaRdSizeOvr2047=nbsEusmLgaRdSizeOvr2047, nbsEusmFlowCfgRowStatus=nbsEusmFlowCfgRowStatus, nbsEusmSlotEntry=nbsEusmSlotEntry, nbsEusmFlowCfgSlot=nbsEusmFlowCfgSlot, nbsEusmMib=nbsEusmMib, nbsEusmTgaFrameSizeType=nbsEusmTgaFrameSizeType, nbsEusmPmFrames511=nbsEusmPmFrames511, nbsEusmSlotAccControlActionTag=nbsEusmSlotAccControlActionTag, nbsEusmPmMax511=nbsEusmPmMax511, nbsEusmPmAvg64=nbsEusmPmAvg64, nbsEusmPmOctetsAllSizes=nbsEusmPmOctetsAllSizes, nbsEusmPmOctets2047=nbsEusmPmOctets2047, nbsEusmCoSTagPrioMapTable=nbsEusmCoSTagPrioMapTable, nbsEusmLgaRdbcFrames=nbsEusmLgaRdbcFrames, nbsEusmTgaTable=nbsEusmTgaTable, nbsEusmFlowCfgTable=nbsEusmFlowCfgTable, nbsEusmLgaAdSize64=nbsEusmLgaAdSize64, nbsEusmPortSmartLoopbackSwap=nbsEusmPortSmartLoopbackSwap, nbsEusmCableTestTable=nbsEusmCableTestTable, nbsEusmPmMax127=nbsEusmPmMax127, nbsEusmLgaAducFrames=nbsEusmLgaAducFrames, nbsEusmVidMapTable=nbsEusmVidMapTable, nbsEusmPmOctetsOvr2047=nbsEusmPmOctetsOvr2047, nbsEusmCoSTagPrioMapPriority=nbsEusmCoSTagPrioMapPriority, nbsEusmSlotLinkAggrOper=nbsEusmSlotLinkAggrOper, nbsEusmPortGrp=nbsEusmPortGrp, nbsEusmSlotIometrix=nbsEusmSlotIometrix, nbsEusmTgaSa=nbsEusmTgaSa, nbsEusmPortSmartLoopbackVid=nbsEusmPortSmartLoopbackVid, nbsEusmLgaAdAllOctets=nbsEusmLgaAdAllOctets, nbsEusmCoSDscpMapRowStatus=nbsEusmCoSDscpMapRowStatus, nbsEusmPmAvg511=nbsEusmPmAvg511, nbsEusmTgaSaType=nbsEusmTgaSaType, nbsEusmFlowCfgPriority=nbsEusmFlowCfgPriority, nbsEusmPmMaxAllSizes=nbsEusmPmMaxAllSizes, nbsEusmSlotAccControlVidList=nbsEusmSlotAccControlVidList, nbsEusmCoSDscpMapTable=nbsEusmCoSDscpMapTable, nbsEusmLgaRducFrames=nbsEusmLgaRducFrames, nbsEusmLgaRdAllFrames=nbsEusmLgaRdAllFrames, nbsEusmSlotPmCapabilities=nbsEusmSlotPmCapabilities, nbsEusmPmOctets64=nbsEusmPmOctets64, nbsEusmPmFramesOvr2047=nbsEusmPmFramesOvr2047, nbsEusmLgaAdSizeMax1023=nbsEusmLgaAdSizeMax1023, nbsEusmLgaAdmcFrames=nbsEusmLgaAdmcFrames, nbsEusmPmMaxOvr2047=nbsEusmPmMaxOvr2047, nbsEusmLgaRdSize64=nbsEusmLgaRdSize64, nbsEusmPmMax1518=nbsEusmPmMax1518, nbsEusmTestGrp=nbsEusmTestGrp, nbsEusmCoSDscpMapStorageType=nbsEusmCoSDscpMapStorageType, nbsEusmPmMin511=nbsEusmPmMin511, nbsEusmSlotStormControlBroadcast=nbsEusmSlotStormControlBroadcast, nbsEusmVidMapRowStatus=nbsEusmVidMapRowStatus, nbsEusmTgaInterPacketGap=nbsEusmTgaInterPacketGap, nbsEusmSlotLgaInterval=nbsEusmSlotLgaInterval, nbsEusmSlotUserPortIROper=nbsEusmSlotUserPortIROper, nbsEusmPmTable=nbsEusmPmTable, nbsEusmLgaRdmcFrames=nbsEusmLgaRdmcFrames, nbsEusmLgaAdSizeMax255=nbsEusmLgaAdSizeMax255, nbsEusmLgaAdOctetDivisor=nbsEusmLgaAdOctetDivisor, nbsEusmPmFrames2047=nbsEusmPmFrames2047, nbsEusmCableTestResult=nbsEusmCableTestResult, nbsEusmSlotLgaAction=nbsEusmSlotLgaAction, nbsEusmTgaPatternType=nbsEusmTgaPatternType, nbsEusmLgaAdSizeMax2047=nbsEusmLgaAdSizeMax2047, nbsEusmPmOctets511=nbsEusmPmOctets511, nbsEusmCableTestEntry=nbsEusmCableTestEntry, nbsEusmPmMinAllSizes=nbsEusmPmMinAllSizes, nbsEusmSlotStormControlUnicast=nbsEusmSlotStormControlUnicast, nbsEusmSlotDscpIngressCs=nbsEusmSlotDscpIngressCs, nbsEusmPmMax255=nbsEusmPmMax255, nbsEusmPmMin2047=nbsEusmPmMin2047, nbsEusmSlotDscpIngressAf=nbsEusmSlotDscpIngressAf, nbsEusmPortVlanTagAction=nbsEusmPortVlanTagAction, nbsEusmFlowStatusEntry=nbsEusmFlowStatusEntry, nbsEusmPmFrames1023=nbsEusmPmFrames1023, nbsEusmCableTestStatus=nbsEusmCableTestStatus, nbsEusmLgaAdAllFrames=nbsEusmLgaAdAllFrames, nbsEusmSlotLinkAggrAdmin=nbsEusmSlotLinkAggrAdmin, nbsEusmCoSDscpMapChassis=nbsEusmCoSDscpMapChassis, nbsEusmVidMapChassis=nbsEusmVidMapChassis, nbsEusmSlotMaxDscpMapSize=nbsEusmSlotMaxDscpMapSize, nbsEusmSlotPmSelector=nbsEusmSlotPmSelector, nbsEusmPmAvg127=nbsEusmPmAvg127, nbsEusmPmAvg2047=nbsEusmPmAvg2047, nbsEusmLgaAdSizeMax127=nbsEusmLgaAdSizeMax127, nbsEusmLgaAdFrameDivisor=nbsEusmLgaAdFrameDivisor, nbsEusmPmAvg1518=nbsEusmPmAvg1518, nbsEusmTgaAction=nbsEusmTgaAction, nbsEusmLgaTable=nbsEusmLgaTable, nbsEusmSlotDscpRemark=nbsEusmSlotDscpRemark, nbsEusmSlotMaxFlowCfgSize=nbsEusmSlotMaxFlowCfgSize, nbsEusmFlowCfgIROper=nbsEusmFlowCfgIROper, nbsEusmFlowCfgClearCounter=nbsEusmFlowCfgClearCounter, nbsEusmTgaPattern=nbsEusmTgaPattern, nbsEusmFlowCfgIRAdmin=nbsEusmFlowCfgIRAdmin, nbsEusmLgaRdTimeSpan=nbsEusmLgaRdTimeSpan, nbsEusmLgaRdOctetDivisor=nbsEusmLgaRdOctetDivisor, nbsEusmCoSTagPrioMapSlcPrio=nbsEusmCoSTagPrioMapSlcPrio, nbsEusmPmFrames255=nbsEusmPmFrames255, nbsEusmLgaAdSizeOvr2047=nbsEusmLgaAdSizeOvr2047, nbsEusmPmMax64=nbsEusmPmMax64, nbsEusmLgaRdSizeMax2047=nbsEusmLgaRdSizeMax2047, nbsEusmPmMax2047=nbsEusmPmMax2047, nbsEusmTgaTag=nbsEusmTgaTag, nbsEusmTgaFrameCountType=nbsEusmTgaFrameCountType, nbsEusmSlotDscpIngressZeroDscp=nbsEusmSlotDscpIngressZeroDscp, nbsEusmLgaRdSizeMax511=nbsEusmLgaRdSizeMax511, nbsEusmSlotPmAction=nbsEusmSlotPmAction, nbsEusmSlotStormControlMulticast=nbsEusmSlotStormControlMulticast, nbsEusmTgaDa=nbsEusmTgaDa, nbsEusmPmMin127=nbsEusmPmMin127, nbsEusmFlowCfgVid=nbsEusmFlowCfgVid, nbsEusmLgaRdSizeMax1518=nbsEusmLgaRdSizeMax1518, nbsEusmLgaAdTimeSpan=nbsEusmLgaAdTimeSpan, nbsEusmTgaTagType=nbsEusmTgaTagType, nbsEusmPmEntry=nbsEusmPmEntry, PYSNMP_MODULE_ID=nbsEusmMib, nbsEusmVidMapEntry=nbsEusmVidMapEntry, nbsEusmSlotDscpIngressEf=nbsEusmSlotDscpIngressEf, nbsEusmTgaFrameCount=nbsEusmTgaFrameCount, nbsEusmLgaRdAllOctets=nbsEusmLgaRdAllOctets, nbsEusmLgaAdbcFrames=nbsEusmLgaAdbcFrames, nbsEusmLgaRdSizeMax127=nbsEusmLgaRdSizeMax127, nbsEusmPortSmartLoopbackMac=nbsEusmPortSmartLoopbackMac, nbsEusmFlowStatusRxFrames=nbsEusmFlowStatusRxFrames, nbsEusmLgaEntry=nbsEusmLgaEntry, nbsEusmPortSmartLoopbackAction=nbsEusmPortSmartLoopbackAction, nbsEusmTgaEntry=nbsEusmTgaEntry, nbsEusmPmAvg1023=nbsEusmPmAvg1023, nbsEusmSlotDscpIngressAllOther=nbsEusmSlotDscpIngressAllOther, nbsEusmPmFrames1518=nbsEusmPmFrames1518, nbsEusmPmAvgAllSizes=nbsEusmPmAvgAllSizes, nbsEusmSlotPmInterval=nbsEusmSlotPmInterval, nbsEusmPortTable=nbsEusmPortTable, nbsEusmPortSupportsEusm=nbsEusmPortSupportsEusm, nbsEusmTgaFrameSize=nbsEusmTgaFrameSize, nbsEusmPmAvg255=nbsEusmPmAvg255, nbsEusmPortEntry=nbsEusmPortEntry, nbsEusmSlotUserPortIRAdmin=nbsEusmSlotUserPortIRAdmin, nbsEusmSlotMaxVlanTranSize=nbsEusmSlotMaxVlanTranSize, nbsEusmPmMinOvr2047=nbsEusmPmMinOvr2047, nbsEusmSlotManagementVid=nbsEusmSlotManagementVid, nbsEusmCoSTagPrioMapChassis=nbsEusmCoSTagPrioMapChassis, nbsEusmFlowCfgChassis=nbsEusmFlowCfgChassis, nbsEusmPortVlanTagVid=nbsEusmPortVlanTagVid, nbsEusmLgaAdSizeMax511=nbsEusmLgaAdSizeMax511, nbsEusmPmFrames127=nbsEusmPmFrames127, nbsEusmPmFrames64=nbsEusmPmFrames64, nbsEusmSlotSupportsEusm=nbsEusmSlotSupportsEusm, nbsEusmLgaAdSizeMax1518=nbsEusmLgaAdSizeMax1518, nbsEusmLgaRdSizeMax1023=nbsEusmLgaRdSizeMax1023, nbsEusmFlowCfgStorageType=nbsEusmFlowCfgStorageType, nbsEusmSlotGrp=nbsEusmSlotGrp, nbsEusmSlotStormBurstSize=nbsEusmSlotStormBurstSize, nbsEusmPortVlanTagPriority=nbsEusmPortVlanTagPriority, nbsEusmFlowStatusTable=nbsEusmFlowStatusTable, nbsEusmPmOctets255=nbsEusmPmOctets255, nbsEusmCoSDscpMapSlcPrio=nbsEusmCoSDscpMapSlcPrio, nbsEusmTgaDaType=nbsEusmTgaDaType, nbsEusmSlotTable=nbsEusmSlotTable, nbsEusmFlowCfgEntry=nbsEusmFlowCfgEntry, nbsEusmPmMax1023=nbsEusmPmMax1023, nbsEusmCoSDscpMapDscp=nbsEusmCoSDscpMapDscp, nbsEusmPmOctets127=nbsEusmPmOctets127)
