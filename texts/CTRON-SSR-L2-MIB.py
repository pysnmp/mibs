#
# PySNMP MIB module CTRON-SSR-L2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-SSR-L2-MIB
# Produced by pysmi-1.1.3 at Wed Dec  1 15:48:58 2021
# On host fv-az74-277 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ssrMibs, = mibBuilder.importSymbols("CTRON-SSR-SMI-MIB", "ssrMibs")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, TimeTicks, iso, ModuleIdentity, ObjectIdentity, Bits, Gauge32, Integer32, NotificationType, Counter32, Unsigned32, Counter64, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "TimeTicks", "iso", "ModuleIdentity", "ObjectIdentity", "Bits", "Gauge32", "Integer32", "NotificationType", "Counter32", "Unsigned32", "Counter64", "IpAddress")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
l2MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500))
l2MIB.setRevisions(('1999-09-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: l2MIB.setRevisionsDescriptions(('Firmware release 3.0 introduces full rmon I and II. this\n                enterprise mib is now obsolete.',))
if mibBuilder.loadTexts: l2MIB.setLastUpdated('9802090000Z')
if mibBuilder.loadTexts: l2MIB.setOrganization('Cabletron Systems, Inc.')
if mibBuilder.loadTexts: l2MIB.setContactInfo('Cabletron Systems, Inc.\n     35 Industrial Way, P.O. Box 5005\n     Rochester, NH 03867-0505\n     (603) 332-9400\n     support@ctron.com\n     http://www.ctron.com')
if mibBuilder.loadTexts: l2MIB.setDescription('This module defines a schema to access SSR Layer 2 processing subsystem.\n      This mib is no longer supported on ssr platforms. features of this \n      mib now exist in standard mibs. RMON I RFC 1757 provides \n      Layer 2 information and ctron-ssr-policy mib to program filter tables.')
l2Group = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2))
l2LearnedEntryDiscards = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2LearnedEntryDiscards.setReference('RFC 1493 dot1dTp group dot1dTpLearnedEntryDiscards')
if mibBuilder.loadTexts: l2LearnedEntryDiscards.setStatus('obsolete')
if mibBuilder.loadTexts: l2LearnedEntryDiscards.setDescription('The total number of Forwarding Database entries,\n        which have been or would have been learned, but\n        have been discarded due to a lack of space to\n        store them in the Forwarding Database.  If this\n        counter is increasing, it indicates that the\n        Forwarding Database is regularly becoming full (a\n        condition which has unpleasant performance effects\n        on the subnetwork).  If this counter has a\n        significant value but is not presently increasing,\n        it indicates that the problem has been occurring\n        but is not persistent.')
l2LearnedMacEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2LearnedMacEntries.setStatus('obsolete')
if mibBuilder.loadTexts: l2LearnedMacEntries.setDescription('The total number of MAC entries. The total number\n        is equal to the number of unique VLAN id and MAC\n        address pairs on the switch.')
l2LearnedFlowEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2LearnedFlowEntries.setStatus('obsolete')
if mibBuilder.loadTexts: l2LearnedFlowEntries.setDescription('The total number of Flow entries. The total number\n        is equal to the number of unique VLAN id, source MAC\n        address and destination MAC address 3-tuple on the switch.')
l2ForwardTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4), )
if mibBuilder.loadTexts: l2ForwardTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardTable.setDescription('A list of L2 flow entries.')
l2ForwardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2ForwardFilterId"), (0, "CTRON-SSR-L2-MIB", "l2ForwardDstMacAddr"), (0, "CTRON-SSR-L2-MIB", "l2ForwardSrcMacAddr"), (0, "CTRON-SSR-L2-MIB", "l2ForwardVlanId"))
if mibBuilder.loadTexts: l2ForwardEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardEntry.setDescription('An entry containing the L2 flow')
l2ForwardFilterId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardFilterId.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardFilterId.setDescription("A filter number which is used to get the next row from the \n        L2 Forwarding table. A zero implies no filter. When a number\n        is used, the index(s) specified in the first GET_NEXT \n        is used as a filter for future GET_NEXT's using the same\n        FilterId.")
l2ForwardDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 2), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardDstMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardDstMacAddr.setDescription('The destination MAC address which has been learned.')
l2ForwardSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardSrcMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardSrcMacAddr.setDescription('The source MAC address, which is present in case\n        of a Flow, that has been learned by the switch.')
l2ForwardVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardVlanId.setDescription('The VLAN the destination MAC address belongs to.')
l2ForwardDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardDstPort.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardDstPort.setDescription('The physical port number in the shelf/Chassis to which the \n        frame will be forwarded.\n        A zero implies that the frame destined to this destination\n        MAC address will be forwarded to multiple ports. This\n        implies a Multicast or unknown Unicast frame.')
l2ForwardInPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2ForwardInPorts.setStatus('obsolete')
if mibBuilder.loadTexts: l2ForwardInPorts.setDescription("The set of physical ports to which this entry is contained in\n              the L2 tables.  Each octet within the value of this \n              object specifies a set of eight ports. \n              The first octet specifying ports 1 through 8, \n              the second octet specifying ports 9 through 16, etc.  \n\n              Within each octet, the least\n              significant bit represents the lowest numbered\n              port and the most significant bit represents the\n              highest numbered port.  Thus, each port of the\n              bridge is represented by a single bit within the\n              value of this object.  If that bit has a value of\n              '1' then that port is included in the set of\n              ports; the port is not included if its bit has a\n              value of '0'.  (Note that the setting of the bit\n              corresponding to the port from which a frame is\n              received is irrelevant.)  The default value of\n              this object is a string of zeroes of appropriate\n              length. The maximum number of ports/card-module \n              is sysHwModuleNumPorts.")
l2PriorityTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5), )
if mibBuilder.loadTexts: l2PriorityTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityTable.setDescription('A list of L2 flow entries.')
l2PriorityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2PriorityIndex"))
if mibBuilder.loadTexts: l2PriorityEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityEntry.setDescription('An entry containing the L2 flow.')
l2PriorityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PriorityIndex.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityIndex.setDescription('A unique index into the L2 priority table.')
l2PriorityDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PriorityDesc.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityDesc.setDescription('A string used to identify the flow by name.')
l2PriorityDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 3), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PriorityDstMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityDstMacAddr.setDescription('The destination MAC address which has been learned.')
l2PrioritySrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 4), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PrioritySrcMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2PrioritySrcMacAddr.setDescription('The source MAC address, which is present in case\n        of a Flow, that has been learned by the switch.')
l2PriorityVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PriorityVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityVlanId.setDescription('The VLAN the destination MAC address belongs to.')
l2PriorityInPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PriorityInPorts.setStatus('obsolete')
if mibBuilder.loadTexts: l2PriorityInPorts.setDescription("The set of physical ports which allow this source MAC address.\n        Each octet within the value of this object specifies \n        a set of eight ports, with the first octet specifying \n        ports 1 through 8, the second octet specifying ports 9\n        through 16, etc.  Within each octet, the least\n        significant bit represents the lowest numbered\n        port, and the most significant bit represents the\n        highest numbered port.  Thus, each port of the\n        bridge is represented by a single bit within the\n        value of this object.  If that bit has a value of\n        '1' then that port is included in the set of\n        ports; the port is not included if its bit has a\n        value of '0'.  (Note that the setting of the bit\n        corresponding to the port from which a frame is\n        received is irrelevant.)  The default value of\n        this object is a string of zeroes of appropriate\n        length. The maximum number of ports per Module/Card\n        is sysHwModuleNumPorts.")
l2Priority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("low", 1), ("medium", 2), ("high", 3), ("control", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2Priority.setStatus('obsolete')
if mibBuilder.loadTexts: l2Priority.setDescription('The priority for this L2 flow. There are four \n        priority levels: low, medium, high and control. \n        The highest priority class is reserved for router control traffic, \n        which leaves three classes, high, medium, and low for normal\n        data flows. Buffered traffic in higher priority classes is sent ahead \n        of pending traffic in lower priority classes, which allows latency \n        and throughput demands to be maintained for the higher priority traffic. \n        To prevent low priority traffic from waiting indefinitely as higher \n        priority traffic fills the wire, a weighted fair queuing mechanism provides \n        adjustable minimum bandwidth guarantees at each output port, thereby ensuring \n        that some traffic from each priority class always gets through.')
l2FilterTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6), )
if mibBuilder.loadTexts: l2FilterTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterTable.setDescription('A list of L2 filters.')
l2FilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2FilterIndex"))
if mibBuilder.loadTexts: l2FilterEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterEntry.setDescription('An entry containing the L2 filter.')
l2FilterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterIndex.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterIndex.setDescription('A unique index into the table.')
l2FilterDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterDesc.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterDesc.setDescription('A string used to identify the filter by an name.')
l2FilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("staticEntry", 1), ("addressFilter", 2), ("addressLock", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterType.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterType.setDescription('The types of filters, as explained below.\n\n           static-entry\n \n               Based on the restrictions and the presence of\n               source, destination MAC address they can be of \n               three types :\n\n               source-static-entry - All frames with a source\n               address equal to srcMAC, coming through any of \n               the inPorts will be allowed/disallowed to go \n               to any port that is a member of the outPorts\n               list.\n\n               destination-static-entry - All frames with a \n               destination address equal to dstMAC, coming \n               through any of the inPorts  will be allowed/\n               disallowed/forced to go to any port that is a \n               member of the outPorts list.\n\n               flow-static-entry - All frames with a source\n               address equal to srcMAC and a destination address\n               equal to dstMAC, coming through any of the inPorts \n               list will be allowed/disallowed to go to any port \n               that is a member of the outPorts list.\n\n           address-filter\n \n               Based on the restrictions and the presence of\n               source, destination MAC address they can be of \n               three types :\n\n               source-address-filter - All frames with a source\n               address equal to srcMAC, coming through any of \n               the inPorts will be filtered out.\n\n               destination-address-filter - All frames with a \n               destination address equal to dstMAC, coming through \n               any of the inPorts will be filtered out.\n\n               flow-filter - All frames with a source address equal \n               to srcMAC and a destination address equal to dstMAC, \n               coming through any of the inPorts list will be \n               filtered out.\n\n           address-lock\n\n               This locks a source address to a port. It allows \n               learning of srcMAC addresses only on any of the ports\n               in inPorts.')
l2FilterRestrictions = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allow", 1), ("disallow", 2), ("force", 3), ("none", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterRestrictions.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterRestrictions.setDescription('The restrictions which are applied when the filterType \n          is static-entry.')
l2FilterSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 5), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterSrcMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterSrcMacAddr.setDescription('The source MAC address, which is present in case\n                of a Flow, that has been learned by the switch.')
l2FilterDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 6), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterDstMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterDstMacAddr.setDescription('The destination MAC address which has been learned.')
l2FilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterVlanId.setDescription('The VLAN the destination MAC address belongs to.')
l2FilterInPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterInPorts.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterInPorts.setDescription("The set of physical ports which allow this source MAC address.\n        Each octet within the value of this object specifies \n        a set of eight ports, with the first octet specifying \n        ports 1 through 8, the second octet specifying ports 9\n        through 16, etc.  Within each octet, the least\n        significant bit represents the lowest numbered\n        port, and the most significant bit represents the\n        highest numbered port.  Thus, each port of the\n        bridge is represented by a single bit within the\n        value of this object.  If that bit has a value of\n        '1' then that port is included in the set of\n        ports; the port is not included if its bit has a\n        value of '0'.  (Note that the setting of the bit\n        corresponding to the port from which a frame is\n        received is irrelevant.)  The default value of\n        this object is a string of zeroes of appropriate\n        length.  The maximum number of ports/card-module\n        is sysHwModuleNumPorts.")
l2FilterOutPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 6, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2FilterOutPorts.setStatus('obsolete')
if mibBuilder.loadTexts: l2FilterOutPorts.setDescription("The set of ports which allow this destination MAC address.\n        Each octet within the value of this object specifies \n        a set of eight ports, with the first octet specifying \n        ports 1 through 8, the second octet specifying ports 9\n        through 16, etc.  Within each octet, the most\n        significant bit represents the lowest numbered\n        port, and the least significant bit represents the\n        highest numbered port.  Thus, each port of the\n        bridge is represented by a single bit within the\n        value of this object.  If that bit has a value of\n        '1' then that port is included in the set of\n        ports; the port is not included if its bit has a\n        value of '0'.  (Note that the setting of the bit\n        corresponding to the port from which a frame is\n        received is irrelevant.)  The default value of\n        this object is a string of zeroes of appropriate\n        length.")
l2PortSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7), )
if mibBuilder.loadTexts: l2PortSecurityTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityTable.setDescription('A list of L2 port security filters.')
l2PortSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2PortSecurityIndex"))
if mibBuilder.loadTexts: l2PortSecurityEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityEntry.setDescription('An entry containing the L2 filter.')
l2PortSecurityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortSecurityIndex.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityIndex.setDescription('A unique index into the table.')
l2PortSecurityDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 25))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortSecurityDesc.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityDesc.setDescription('A string used to identify the filter by a name.')
l2PortSecurityType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sourceSecure", 1), ("destinationSecure", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortSecurityType.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityType.setDescription('The security filters are of two types :\n                \n                source-secure \n                   For all the ports in inPorts forward only those\n                   frames that match source-static-entry filter from\n                   the l2FilterTable.\n                \n                destination-secure \n                   For all the ports in inPorts forward only those\n                   frames that match destination-static-entry filter from\n                   the l2FilterTable.')
l2PortSecurityVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortSecurityVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityVlanId.setDescription('The VLAN the destination MAC address belongs to.')
l2PortSecurityInPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 7, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortSecurityInPorts.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSecurityInPorts.setDescription("The set of physical ports which allow this source MAC address.\n        Each octet within the value of this object specifies \n        a set of eight ports, with the first octet specifying \n        ports 1 through 8, the second octet specifying ports 9\n        through 16, etc.  Within each octet, the least\n        significant bit represents the lowest numbered\n        port, and the most significant bit represents the\n        highest numbered port.  Thus, each port of the\n        bridge is represented by a single bit within the\n        value of this object.  If that bit has a value of\n        '1' then that port is included in the set of\n        ports; the port is not included if its bit has a\n        value of '0'.  (Note that the setting of the bit\n        corresponding to the port from which a frame is\n        received is irrelevant.)  The default value of\n        this object is a string of zeroes of appropriate\n        length.")
l2PortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8), )
if mibBuilder.loadTexts: l2PortTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortTable.setDescription('A table that contains information about every\n        physical port that is associated with this transparent\n        bridge.')
l2PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2Port"))
if mibBuilder.loadTexts: l2PortEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortEntry.setDescription('A list of information for each physical port.')
l2Port = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2Port.setStatus('obsolete')
if mibBuilder.loadTexts: l2Port.setDescription('The port number of the port for which this entry\n        contains Transparent bridging management information.')
l2PortAgingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortAgingStatus.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortAgingStatus.setDescription('Whether aging is enabled or not on this port.')
l2PortAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2PortAgingTime.setReference('IEEE 802.1D-1990: Section 6.7.1.1.3')
if mibBuilder.loadTexts: l2PortAgingTime.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortAgingTime.setDescription('The time-out period in seconds for aging out\n        dynamically learned forwarding information.\n        802.1D-1990 recommends a default of 300 seconds.')
l2PortDemandAgeHiBound = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortDemandAgeHiBound.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortDemandAgeHiBound.setDescription("When the number of MAC entries on a physical port's L2 table reaches\n        the l2PortDemandAgeHiBound (95% full), a number of MAC entries\n        based on l2PortDemandAgeLowBound percentage will be removed \n        (aged-out) from the table.")
l2PortDemandAgeLowBound = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortDemandAgeLowBound.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortDemandAgeLowBound.setDescription('The l2PortDemandAgeLowBound value determines how many MAC\n        entries need to be aged-out. See l2PortDemandAgeHiBound. Default\n        value is 85%.\n        Example: if - L2 table capacity        = 10,000 entries \n                    - l2PortDemandAgeHiBound   = 95%\n                    - l2PortDemandAgeLowBound  = 85%\n\n    When the L2 table reaches 95% capacity (9500 MAC entries), \n    10% of the entries will be aged-out.')
l2PortDemandAgeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortDemandAgeCount.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortDemandAgeCount.setDescription('The number of times demand aging has taken\n        place on this physical port.')
l2PortLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortLearnedEntryDiscards.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortLearnedEntryDiscards.setDescription('The total number of L2 Port table entries,\n        which have been or would have been learned, but\n        have been discarded due to a lack of space to\n        store them in the Forwarding Database.  If this\n        counter is increasing, it indicates that the\n        L2 port table  is regularly becoming full (a\n        condition which has unpleasant performance effects\n        on the subnetwork).  If this counter has a\n        significant value but is not presently increasing,\n        it indicates that the problem has been occurring\n        but is not persistent.')
l2PortSrcEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortSrcEntries.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortSrcEntries.setDescription("The number of MAC addresses/Flow entries that\n        reside on this ports L2 table as a source (i.e. for\n        a flow entry the source and destination MAC address's\n        lie on the same LAN segment).")
l2PortDstEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortDstEntries.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortDstEntries.setDescription('The number of MAC addresses/Flow entries that\n        reside on this ports L2 table as a destination (i.e. for\n        a flow entry the destination MAC address was not learned\n        as a source).')
l2PortMgmtEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortMgmtEntries.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortMgmtEntries.setDescription('The number of user configured entries, including\n               filters, bridge management addresses etc.')
l2PortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortMaxInfo.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortMaxInfo.setDescription('The maximum size of the info/data (non-MAC) field that\n        this port will receive or transmit. See RFC 1493\n        for similar OID called dot1dTpPortMaxInfo.')
l2PortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortInFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: l2PortInFrames.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortInFrames.setDescription('The number of frames that have been received by\n        this port from its segment. Note that a frame\n        received on the interface corresponding to this\n        port is only counted by this object if and only if\n        it is for a protocol being processed by the local\n        bridging function, including bridge management\n        frames.')
l2PortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 8, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortOutFrames.setReference('IEEE 802.1D-1990: Section 6.6.1.1.3')
if mibBuilder.loadTexts: l2PortOutFrames.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortOutFrames.setDescription('The number of frames that have been transmitted\n        by this port to its segment.  Note that a frame\n        transmitted on the interface corresponding to this\n        port is only counted by this object if and only if\n        it is for a protocol being processed by the local\n        bridging function, including bridge management\n        frames.')
l2PortForwardTable = MibTable((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9), )
if mibBuilder.loadTexts: l2PortForwardTable.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardTable.setDescription('A table that contains information about the\n        Forward/Flow Table that is associated with this \n        port.')
l2PortForwardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1), ).setIndexNames((0, "CTRON-SSR-L2-MIB", "l2PortForwardPort"), (0, "CTRON-SSR-L2-MIB", "l2PortForwardIndex"))
if mibBuilder.loadTexts: l2PortForwardEntry.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardEntry.setDescription('A list of Flow/Forward information for this port.')
l2PortForwardPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardPort.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardPort.setDescription('The port number of the port for which this entry\n        contains Transparent bridging management\n        information.')
l2PortForwardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardIndex.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardIndex.setDescription('A unique index into the Flow/Forward database table.')
l2PortForwardDstMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 3), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardDstMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardDstMacAddr.setDescription('The destination MAC address which has been learned.')
l2PortForwardSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 4), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardSrcMacAddr.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardSrcMacAddr.setDescription('The source MAC address, which is present in case\n        of a Flow, that has been learned by the switch.')
l2PortForwardVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardVlanId.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardVlanId.setDescription('The VLAN the destination MAC address belongs to.')
l2PortForwardDstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardDstPort.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardDstPort.setDescription('The physical port number to which the frame will be forwarded.\n        A zero implies that the frame destined to this destination\n        MAC address will be forwarded to multiple ports. This\n        implies a Multicast or unknown Unicast frame.')
l2PortForwardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardStatus.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardStatus.setDescription("The status of this entry.  The meanings of the\n                      values are:\n\n                        other(1)   : none of the following.  This would\n                                     include the case where some other\n                                     MIB object (not the corresponding\n                                     instance of dot1dTpFdbPort, nor an\n                                     entry in the dot1dStaticTable) is\n                                     being used to determine if and how\n                                     frames addressed to the value of\n                                     the corresponding instance of\n                                     dot1dTpFdbAddress are being\n                                     forwarded.\n\n                        invalid(2) : this entry is not longer valid\n                                     (e.g., it was learned but has since\n                                     aged-out), but has not yet been\n                                     flushed from the table.\n\n                        learned(3) : the value of the corresponding\n                                     instance of dot1dTpFdbPort was\n                                     learned, and is being used.\n\n                        self(4)    : the value of the corresponding\n                                     instance of dot1dTpFdbAddress\n                                     represents one of the bridge's\n                                     addresses.  The corresponding\n                                     instance of dot1dTpFdbPort\n                                     indicates which of the bridge's\n                                     ports has this address.\n\n                        mgmt(5)    : the value of the corresponding\n                                     instance of dot1dTpFdbAddress is\n                                     also the value of an existing\n                                     instance of dot1dStaticAddress.")
l2PortForwardLastDetectedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 2501, 1, 2, 9, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2PortForwardLastDetectedTime.setStatus('obsolete')
if mibBuilder.loadTexts: l2PortForwardLastDetectedTime.setDescription('The time (in hundredths of a second) since the\n        last time this MAC address was detected by this\n        port.')
l2Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500, 2))
l2Compliances = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500, 2, 1))
l2Groups = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500, 2, 2))
l2ComplianceV10 = ModuleCompliance((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500, 2, 2, 1, 1)).setObjects(("CTRON-SSR-L2-MIB", "l2ConfGroupV10"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    l2ComplianceV10 = l2ComplianceV10.setStatus('obsolete')
if mibBuilder.loadTexts: l2ComplianceV10.setDescription('The compliance statement for the SSR-L2-MIB.')
l2ConfGroupV10 = ObjectGroup((1, 3, 6, 1, 4, 1, 52, 2501, 1, 500, 2, 2, 1)).setObjects(("CTRON-SSR-L2-MIB", "l2LearnedEntryDiscards"), ("CTRON-SSR-L2-MIB", "l2LearnedMacEntries"), ("CTRON-SSR-L2-MIB", "l2LearnedFlowEntries"), ("CTRON-SSR-L2-MIB", "l2ForwardFilterId"), ("CTRON-SSR-L2-MIB", "l2ForwardDstMacAddr"), ("CTRON-SSR-L2-MIB", "l2ForwardSrcMacAddr"), ("CTRON-SSR-L2-MIB", "l2ForwardVlanId"), ("CTRON-SSR-L2-MIB", "l2ForwardDstPort"), ("CTRON-SSR-L2-MIB", "l2ForwardInPorts"), ("CTRON-SSR-L2-MIB", "l2PriorityIndex"), ("CTRON-SSR-L2-MIB", "l2PriorityDesc"), ("CTRON-SSR-L2-MIB", "l2PriorityDstMacAddr"), ("CTRON-SSR-L2-MIB", "l2PrioritySrcMacAddr"), ("CTRON-SSR-L2-MIB", "l2PriorityVlanId"), ("CTRON-SSR-L2-MIB", "l2PriorityInPorts"), ("CTRON-SSR-L2-MIB", "l2Priority"), ("CTRON-SSR-L2-MIB", "l2FilterIndex"), ("CTRON-SSR-L2-MIB", "l2FilterDesc"), ("CTRON-SSR-L2-MIB", "l2FilterType"), ("CTRON-SSR-L2-MIB", "l2FilterRestrictions"), ("CTRON-SSR-L2-MIB", "l2FilterSrcMacAddr"), ("CTRON-SSR-L2-MIB", "l2FilterDstMacAddr"), ("CTRON-SSR-L2-MIB", "l2FilterVlanId"), ("CTRON-SSR-L2-MIB", "l2FilterInPorts"), ("CTRON-SSR-L2-MIB", "l2FilterOutPorts"), ("CTRON-SSR-L2-MIB", "l2PortSecurityIndex"), ("CTRON-SSR-L2-MIB", "l2PortSecurityDesc"), ("CTRON-SSR-L2-MIB", "l2PortSecurityType"), ("CTRON-SSR-L2-MIB", "l2PortSecurityVlanId"), ("CTRON-SSR-L2-MIB", "l2PortSecurityInPorts"), ("CTRON-SSR-L2-MIB", "l2Port"), ("CTRON-SSR-L2-MIB", "l2PortAgingStatus"), ("CTRON-SSR-L2-MIB", "l2PortAgingTime"), ("CTRON-SSR-L2-MIB", "l2PortDemandAgeHiBound"), ("CTRON-SSR-L2-MIB", "l2PortDemandAgeLowBound"), ("CTRON-SSR-L2-MIB", "l2PortDemandAgeCount"), ("CTRON-SSR-L2-MIB", "l2PortLearnedEntryDiscards"), ("CTRON-SSR-L2-MIB", "l2PortSrcEntries"), ("CTRON-SSR-L2-MIB", "l2PortDstEntries"), ("CTRON-SSR-L2-MIB", "l2PortMgmtEntries"), ("CTRON-SSR-L2-MIB", "l2PortMaxInfo"), ("CTRON-SSR-L2-MIB", "l2PortInFrames"), ("CTRON-SSR-L2-MIB", "l2PortOutFrames"), ("CTRON-SSR-L2-MIB", "l2PortForwardPort"), ("CTRON-SSR-L2-MIB", "l2PortForwardIndex"), ("CTRON-SSR-L2-MIB", "l2PortForwardDstMacAddr"), ("CTRON-SSR-L2-MIB", "l2PortForwardSrcMacAddr"), ("CTRON-SSR-L2-MIB", "l2PortForwardVlanId"), ("CTRON-SSR-L2-MIB", "l2PortForwardDstPort"), ("CTRON-SSR-L2-MIB", "l2PortForwardStatus"), ("CTRON-SSR-L2-MIB", "l2PortForwardLastDetectedTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    l2ConfGroupV10 = l2ConfGroupV10.setStatus('obsolete')
if mibBuilder.loadTexts: l2ConfGroupV10.setDescription('A set of managed objects that make up version 1.0 of the SSR Layer 2 mib.')
mibBuilder.exportSymbols("CTRON-SSR-L2-MIB", l2PortSecurityTable=l2PortSecurityTable, l2PortAgingTime=l2PortAgingTime, l2ForwardTable=l2ForwardTable, l2PortDemandAgeHiBound=l2PortDemandAgeHiBound, l2PortForwardDstPort=l2PortForwardDstPort, l2PriorityInPorts=l2PriorityInPorts, l2PortSecurityIndex=l2PortSecurityIndex, l2PortSrcEntries=l2PortSrcEntries, l2PortForwardVlanId=l2PortForwardVlanId, l2PriorityTable=l2PriorityTable, l2PortEntry=l2PortEntry, l2LearnedEntryDiscards=l2LearnedEntryDiscards, l2FilterTable=l2FilterTable, l2PortForwardTable=l2PortForwardTable, l2FilterVlanId=l2FilterVlanId, l2PortMgmtEntries=l2PortMgmtEntries, l2PortOutFrames=l2PortOutFrames, l2PortForwardPort=l2PortForwardPort, l2PortForwardStatus=l2PortForwardStatus, l2FilterIndex=l2FilterIndex, PYSNMP_MODULE_ID=l2MIB, l2ForwardVlanId=l2ForwardVlanId, l2PortAgingStatus=l2PortAgingStatus, l2FilterDstMacAddr=l2FilterDstMacAddr, l2PortSecurityInPorts=l2PortSecurityInPorts, l2ForwardFilterId=l2ForwardFilterId, l2PortSecurityVlanId=l2PortSecurityVlanId, l2PortForwardEntry=l2PortForwardEntry, l2FilterOutPorts=l2FilterOutPorts, l2PortForwardIndex=l2PortForwardIndex, l2PortForwardLastDetectedTime=l2PortForwardLastDetectedTime, l2PortLearnedEntryDiscards=l2PortLearnedEntryDiscards, l2PriorityDesc=l2PriorityDesc, l2ForwardDstPort=l2ForwardDstPort, l2PortDemandAgeCount=l2PortDemandAgeCount, l2Groups=l2Groups, l2PortTable=l2PortTable, l2PriorityIndex=l2PriorityIndex, l2FilterRestrictions=l2FilterRestrictions, l2LearnedMacEntries=l2LearnedMacEntries, l2PortDemandAgeLowBound=l2PortDemandAgeLowBound, l2Group=l2Group, l2PortInFrames=l2PortInFrames, l2Conformance=l2Conformance, l2PortMaxInfo=l2PortMaxInfo, l2PriorityEntry=l2PriorityEntry, l2PortSecurityDesc=l2PortSecurityDesc, l2FilterEntry=l2FilterEntry, l2FilterInPorts=l2FilterInPorts, l2ForwardInPorts=l2ForwardInPorts, l2ForwardEntry=l2ForwardEntry, l2FilterDesc=l2FilterDesc, l2FilterType=l2FilterType, l2Port=l2Port, l2PriorityVlanId=l2PriorityVlanId, l2ConfGroupV10=l2ConfGroupV10, l2PortDstEntries=l2PortDstEntries, l2ForwardDstMacAddr=l2ForwardDstMacAddr, l2Priority=l2Priority, l2PortForwardDstMacAddr=l2PortForwardDstMacAddr, l2FilterSrcMacAddr=l2FilterSrcMacAddr, l2PrioritySrcMacAddr=l2PrioritySrcMacAddr, l2LearnedFlowEntries=l2LearnedFlowEntries, l2PortSecurityType=l2PortSecurityType, l2MIB=l2MIB, l2PriorityDstMacAddr=l2PriorityDstMacAddr, l2PortForwardSrcMacAddr=l2PortForwardSrcMacAddr, l2Compliances=l2Compliances, l2ComplianceV10=l2ComplianceV10, l2PortSecurityEntry=l2PortSecurityEntry, l2ForwardSrcMacAddr=l2ForwardSrcMacAddr)
