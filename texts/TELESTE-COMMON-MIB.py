#
# PySNMP MIB module TELESTE-COMMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/teleste/TELESTE-COMMON-MIB
# Produced by pysmi-1.1.3 at Wed Dec  1 17:08:38 2021
# On host fv-az83-424 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, IpAddress, ObjectIdentity, Unsigned32, ModuleIdentity, MibIdentifier, NotificationType, Gauge32, iso, Integer32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "IpAddress", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "MibIdentifier", "NotificationType", "Gauge32", "iso", "Integer32", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
DateAndTime, Uint16, TPhysAddress, common = mibBuilder.importSymbols("TELESTE-ROOT-MIB", "DateAndTime", "Uint16", "TPhysAddress", "common")
element = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 1))
elementInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1))
elementName = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elementName.setStatus('mandatory')
if mibBuilder.loadTexts: elementName.setDescription("This is the logical name of the controlling module of\n\t\t\t\tthe network element. The name may or may not be the same\n\t\t\t\tas the module's name in the moduleTable.")
elementStructure = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("compact", 2), ("modular", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: elementStructure.setStatus('mandatory')
if mibBuilder.loadTexts: elementStructure.setDescription('This object tells whether the device is a single compact\n\t\t\t\tdevice or a modular device.')
elementConfigChangeCode = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elementConfigChangeCode.setStatus('optional')
if mibBuilder.loadTexts: elementConfigChangeCode.setDescription('This object is an indicator about changes in the network\n\t\t\t\telement configuration. How the value is formed is device\n\t\t\t\tdependent. It can be a counter, a checksum of the device\n\t\t\t\tconfiguration parameters, a DateAndTime type variable or\n\t\t\t\teven SysUptime, if no other information is available. \n\t\t\t\tDateAndTime is the recommended value.\n\t\t\t\t\n\t\t\t\tThis object is intended to permit a management application\n\t\t\t\tto maintain configuration (including moduleTable) \n\t\t\t\tsyncronization with the agent.')
elementResetCount = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elementResetCount.setStatus('optional')
if mibBuilder.loadTexts: elementResetCount.setDescription("Total number of software resets during the device's life time.")
elementTotalUpTime = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: elementTotalUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: elementTotalUpTime.setDescription('The total uptime the device (software) has been running. Unit 1 day.')
elementLatitude = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elementLatitude.setStatus('optional')
if mibBuilder.loadTexts: elementLatitude.setDescription('Device latitude coordinate. Unit 0.00001 degrees.')
elementLongitude = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elementLongitude.setStatus('optional')
if mibBuilder.loadTexts: elementLongitude.setDescription('Device longitude coordinate. Unit 0.00001 degrees.')
elementAltitude = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: elementAltitude.setStatus('optional')
if mibBuilder.loadTexts: elementAltitude.setDescription('Device altitude coordinate. Unit 1 metre.')
elementStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2))
statusGeneral = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("normal", 1), ("notification", 2), ("warning", 3), ("alarm", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusGeneral.setStatus('mandatory')
if mibBuilder.loadTexts: statusGeneral.setDescription('A number stating the general status of the element.\n\t\t\t\t\n\t\t\t\tValues:\n\t\t\t\t1 = Normal\n\t\t\t\t2 = At least one Notification is active\n\t\t\t\t3 = At least one Warning is active\n\t\t\t\t4 = At least one Alarm is active\n\t\t\t\t\n\t\t\t\tIf the element has more than one state active, then \n\t\t\t\tthe state with the highest value is returned.')
statusBusMaster = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("slaveOnly", 1), ("configuredSlave", 2), ("currentlySlave", 3), ("currentlyMaster", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusBusMaster.setStatus('optional')
if mibBuilder.loadTexts: statusBusMaster.setDescription('A number stating the Bus Master status of the NE.\n\t\t\t\t\n\t\t\t\tValues:\n\t\t\t\t1 = The NE is a slave-only device\n\t\t\t\t2 = The NE is configured as slave\n\t\t\t\t3 = The NE is configured as master but is currently\n\t\t\t\t    slave because a stronger master is on the bus\n\t\t\t\t4 = The NE is currently the bus master')
statusLmt = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noLmtInterface", 1), ("stateUnknown", 2), ("notConnected", 3), ("connected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusLmt.setStatus('optional')
if mibBuilder.loadTexts: statusLmt.setDescription("A number telling if the Local Management Terminal (LMT)\n\t\t\t\tis connected to the element.\n\t\t\t\t\n\t\t\t\tValues:\n\t\t\t\t1 = The element does not have an LMT interface\n\t\t\t\t2 = The element can not detect if an LMT is connected\n\t\t\t\t3 = The element has not detected a connected LMT\n\t\t\t\t4 = The element has detected a connected LMT\n\t\t\t\t\n\t\t\t\tNote! Applies only to fysically point-to-point \n\t\t\t\tconnected LMT's to device, not via bus ot other \n\t\t\t\tshared medias.")
statusLid = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLid", 1), ("closed", 2), ("open", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusLid.setStatus('optional')
if mibBuilder.loadTexts: statusLid.setDescription('Element lid status:\n\t\t\t\t1 = no lid (no lid sensor is available)\n\t\t\t\t2 = lid is closed\n\t\t\t\t3 = lid is open')
statusTemperature = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("tempNormal", 1), ("tempHIHI", 2), ("tempHi", 3), ("tempLo", 4), ("tempLOLO", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusTemperature.setStatus('optional')
if mibBuilder.loadTexts: statusTemperature.setDescription('Element temperature status:\n\t\t\t\t1 = normal\n\t\t\t\t2 = HIHI\n\t\t\t\t3 = Hi\n\t\t\t\t4 = Lo\n\t\t\t\t5 = LOLO\n\t\t\t\t')
statusFan = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fanNormal", 1), ("fanFailure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusFan.setStatus('mandatory')
if mibBuilder.loadTexts: statusFan.setDescription('A common status object for all fans in the device.\n\t\t\t\tfanNormal(1) = all fans operate normally\n\t\t\t\tfanFailure(2) = at least one fan has a failure')
statusHardware = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hwNormal", 1), ("hwFailure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusHardware.setStatus('mandatory')
if mibBuilder.loadTexts: statusHardware.setDescription('Device hardware status:\n\t\t\t\thwNormal(1) = the hardware operates normally\n\t\t\t\thwFailure(2) = a hardware failure is detected')
statusSoftware = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("swNormal", 1), ("swFailure", 2), ("swMissing", 3), ("swInitialising", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusSoftware.setStatus('mandatory')
if mibBuilder.loadTexts: statusSoftware.setDescription('Device software status:\n\t\t\t\tswNormal(1) = the software operates normally\n\t\t\t\tswFailure(2) = a software failure is detected\n\t\t\t\tswMissing(3) = the software or firmware is missing\n\t\t\t\tsw(Initialising(4) = the software is initialising')
statusSettings = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("settingsStable", 1), ("settingsChanged", 2), ("settingsNotAvailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusSettings.setStatus('mandatory')
if mibBuilder.loadTexts: statusSettings.setDescription('Status of device settings:\n\t\t\t\tsettingsStable(1) = settings are stable\n\t\t\t\tsettingsChanged(2) = settings have been (recently) changed\n\t\t\t\tsettingsNotAvailable(3) = settings status is not available\n\t\t\t\tThe value should stay in value 2 only a predefined time, e.g. 60 seconds or\n\t\t\t\tthe time it takes until the settings are written into non-volatile memory.\n\t\t\t\t')
elementControl = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3))
controlResetElement = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("hardReset", 2), ("softReset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlResetElement.setStatus('mandatory')
if mibBuilder.loadTexts: controlResetElement.setDescription('On write requests this object commands the module to \n\t\t\t\treset itself.\n\t\t\t\t\n\t\t\t\tIf softReset(3) or hardReset(2) can not be performed,\n\t\t\t\tthen BAD VALUE error is returned.\n\t\t\t\t\n\t\t\t\tOn read requests value noReset(1) is returned.')
controlBusMasterAdminState = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlBusMasterAdminState.setStatus('optional')
if mibBuilder.loadTexts: controlBusMasterAdminState.setDescription('This object tells whether the element is configured as\n\t\t\t\ta bus master or not. Only relevant for bus master type\n\t\t\t\tof elements. Others return no(2).')
controlAlarmDetection = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("restart", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlAlarmDetection.setStatus('mandatory')
if mibBuilder.loadTexts: controlAlarmDetection.setDescription('This variable is used to disable or enable the element\n\t\t\t\talarm checking. When disabled(1), the element \n\t\t\t\twill not check any alarms (or send traps). \n\t\t\t\tDefault value is enabled(2).\n\t\t\t\t\n\t\t\t\tNote: This variable must be consistent with \n\t\t\t\tcommonAlarmDetectionControl in SCTE-HMS-COMMON-MIB, if\n\t\t\t\tthat is implemented.')
controlMaxNumberTrapReceivers = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: controlMaxNumberTrapReceivers.setStatus('mandatory')
if mibBuilder.loadTexts: controlMaxNumberTrapReceivers.setDescription('Number of entries in the elementTrapReceiverTable. \n\t\t\t\tAt least one trap entry must be supported.')
controlTrapReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5), )
if mibBuilder.loadTexts: controlTrapReceiverTable.setStatus('optional')
if mibBuilder.loadTexts: controlTrapReceiverTable.setDescription("A table of manager trap receiver addresses, ports and\n\t\t\t\tcommunities. Total number of entries can not exceed \n\t\t\t\telementNumberTrapReceivers. An entry is deleted from this\n\t\t\t\ttable by setting its IP address to '0.0.0.0'.\n\t\t\t\t\n\t\t\t\tNote: one of the community strings must match to \n\t\t\t\tcommonTrapCommunityString in SCTE-HMS-COMMON-MIB, if \n\t\t\t\tthat is implemented.")
controlTrapReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "receiverEntryId"))
if mibBuilder.loadTexts: controlTrapReceiverEntry.setStatus('optional')
receiverEntryId = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiverEntryId.setStatus('mandatory')
if mibBuilder.loadTexts: receiverEntryId.setDescription('Unique table index. Makes possible to have several \n\t\t\t\tip-address of 0.0.0.0 entries so that no mechanism\n\t\t\t\tfor row manipulation of table is needed.')
receiverAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: receiverAddress.setStatus('mandatory')
if mibBuilder.loadTexts: receiverAddress.setDescription('Ip address of the manager receiving Traps.')
receiverPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: receiverPort.setStatus('mandatory')
if mibBuilder.loadTexts: receiverPort.setDescription('Trap UDP port number. Default port is the standard trap\n\t\t\t\tport 162.')
receiverCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 5, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: receiverCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: receiverCommunity.setDescription('Community string for the trap receiver.\n\t\t\t\t\n\t\t\t\tThe agent is allowed to limit the length of the string. \n\t\t\t\tMinimum length of eight characters must be supported.\n\t\t\t\t\n\t\t\t\tNote: one of the community strings must match to \n\t\t\t\tcommonTrapCommunityString in SCTE-HMS-COMMON-MIB, if\n\t\t\t\tthat is implemented.')
controlTrapSending = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTrapSending.setStatus('optional')
if mibBuilder.loadTexts: controlTrapSending.setDescription('Enables/disables trap sending.\n\t\t\t\t\n\t\t\t\t1 = traps enabled\n\t\t\t\t2 = traps disabled')
controlTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTrapInterval.setStatus('optional')
if mibBuilder.loadTexts: controlTrapInterval.setDescription('The minimum interval between traps.\n\t\t\t\t- Unit 10 milliseconds\n\t\t\t\t- Minimum value 0 (send as fast as possible)\n\t\t\t\t- Maximum value 1000 (10 seconds)\n\t\t\t\t- Default value is 100 (1 second)')
controlTrapLifeTime = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTrapLifeTime.setStatus('optional')
if mibBuilder.loadTexts: controlTrapLifeTime.setDescription('The maximum time a trap stays in the trap queue waiting\n\t\t\t\tfor sending.\n\t\t\t\t- Unit 1 second.\n\t\t\t\t- Minimum value 10\n\t\t\t\t- Maximum value 300\n\t\t\t\t- Default value 60')
controlAlarmOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlAlarmOnDelay.setStatus('optional')
if mibBuilder.loadTexts: controlAlarmOnDelay.setDescription("The minimum time an object's alarm/warning condition must\n\t\t\t\texist before it is recorded as an alarm/warning. Common\n\t\t\t\tto all alarms/warnings\n\t\t\t\t- Unit 10 ms\n\t\t\t\t- Minimum value 10 (100 ms)\n\t\t\t\t- Maximum value 6000 (60 seconds)\n\t\t\t\t- Default value 100 (1 second)")
controlAlarmOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlAlarmOffDelay.setStatus('optional')
if mibBuilder.loadTexts: controlAlarmOffDelay.setDescription("The minimum time an alarm/warning entry stays active after\n\t\t\t\tthe object has reached it's normal condition. Common to all\n\t\t\t\talarms/warnings.\n\t\t\t\t- Unit 10 ms\n\t\t\t\t- Minimum value 10 (100 ms)\n\t\t\t\t- Maximum value 6000 (60 seconds)\n\t\t\t\t- default value 100 (1 second)")
controlTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 3, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: controlTrapDelay.setDescription('The time before a trap is sent after an alarm\n\t\t\t\tis detected.\n\t\t\t\t\n\t\t\t\t- Unit 10 ms\n\t\t\t\t- Minimum value 10 (100 ms)\n\t\t\t\t- Maximum value 6000 (60 seconds)\n\t\t\t\t- Default value 500 (5 seconds)\n\t\t\t\t\n\t\t\t\tThis parameter can be used to control alarm storms e.g.\n\t\t\t\tin an amplifier cascade by using a different value in\n\t\t\t\teach amplifier.')
elementProductKey = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4))
productKeyNumberOfKeys = MibScalar((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyNumberOfKeys.setStatus('optional')
if mibBuilder.loadTexts: productKeyNumberOfKeys.setDescription('Number of product keys supported by the device.')
productKeyTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5), )
if mibBuilder.loadTexts: productKeyTable.setStatus('mandatory')
productKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "productKeyIndex"))
if mibBuilder.loadTexts: productKeyEntry.setStatus('mandatory')
productKeyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyIndex.setDescription('Product key index.')
productKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: productKeyValue.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyValue.setDescription('Product key value.')
productKeyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyMask.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyMask.setDescription('Product key mask.')
productKeyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("keyInvalid", 1), ("keyValid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyStatus.setDescription('Product key status:\n\t\t\t\t1(keyInvalid) = the key is invalid or missing\n\t\t\t\t2(keyValid) = the key is valid')
productKeyCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cipherOther", 1), ("cipherBlowFish", 2), ("cipherXXTEA", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyCipher.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyCipher.setDescription('Cipher method supported by this key:\n\t\t\t\t1(cipherOther) = other ciphering is used\n\t\t\t\t2(cipherBlowFish) = BlowFish ciphering is used\n\t\t\t\t3(cipherXXTEA) = XXTEA ciphering is used')
productKeyNumberOfFeatures = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyNumberOfFeatures.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyNumberOfFeatures.setDescription('Number of features available with this key.')
productKeyFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6), )
if mibBuilder.loadTexts: productKeyFeatureTable.setStatus('mandatory')
productKeyFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "productKeyIndex"), (0, "TELESTE-COMMON-MIB", "productKeyFeatureIndex"))
if mibBuilder.loadTexts: productKeyFeatureEntry.setStatus('mandatory')
productKeyFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyFeatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyFeatureIndex.setDescription('Feature index (second index).')
productKeyFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyFeatureName.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyFeatureName.setDescription('A human-readable description of the feature.')
productKeyFeatureEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("featureDisable", 1), ("featureEnable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyFeatureEnable.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyFeatureEnable.setDescription('Status of the feature:\n\t\t\t\t1(featureDisable) = the feature si disabled in this device\n\t\t\t\t2(featureEnable) = the feature is enabled in this devices')
productKeyFeatureExpirationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 1, 4, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: productKeyFeatureExpirationTime.setStatus('mandatory')
if mibBuilder.loadTexts: productKeyFeatureExpirationTime.setDescription('Number of days left before the feature expires. A zero value means\n\t\t\t\tinfinite validity time. This object has a meaning only if the\n\t\t\t\tfeature is enabled (productKeyFeatureEnable = 2(featureEnable)).')
module = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 2))
moduleInformation = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1))
moduleTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1), )
if mibBuilder.loadTexts: moduleTable.setStatus('mandatory')
if mibBuilder.loadTexts: moduleTable.setDescription('This table lists basic module identification and \n\t\t\t\tconfiguration data of modules installed inside \n\t\t\t\tthe managed element.\n\t\t\t\t\n\t\t\t\tThe first row in the table list information about the\n\t\t\t\telement itself. If the element is not modular, only the \n\t\t\t\tfirst row exists in the table.\n\t\t\t\t\n\t\t\t\tObject moduleId is used for indexing the modules\n\t\t\t\tin all module section tables.')
moduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleEntry.setStatus('mandatory')
moduleId = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleId.setStatus('mandatory')
if mibBuilder.loadTexts: moduleId.setDescription('An unique module index identifying the (physical) modules\n\t\t\t\tinside the network element. The exact conjunction between\n\t\t\t\tthe index and the physical modules depends on the element\n\t\t\t\tstructural principle.\n\t\t\t\t\n\t\t\t\tFor network elements containing plug-in modules the index\n\t\t\t\tshould follow module slot numbering.\n\t\t\t\t\n\t\t\t\tThis index should be used in all subsequent module tables.')
moduleName = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleName.setStatus('optional')
if mibBuilder.loadTexts: moduleName.setDescription("The identification name ('aliasname') of the module.")
moduleHwType = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwType.setStatus('mandatory')
if mibBuilder.loadTexts: moduleHwType.setDescription('The hardware type name of the module.')
moduleRackNo = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleRackNo.setStatus('optional')
if mibBuilder.loadTexts: moduleRackNo.setDescription('Rack number of the module.\n\t\t\t\t\n\t\t\t\tThis can be used to identify the physical position of\n\t\t\t\tthe module in the case where the agent manages modules \n\t\t\t\tthat are in several racks.')
moduleSlotNo = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: moduleSlotNo.setStatus('optional')
if mibBuilder.loadTexts: moduleSlotNo.setDescription('Slot number of the module (within rack).')
moduleDetailTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2), )
if mibBuilder.loadTexts: moduleDetailTable.setStatus('mandatory')
if mibBuilder.loadTexts: moduleDetailTable.setDescription('This table lists detailed module data of modules installed\n\t\t\t\tinside the element.\n\t\t\t\t\n\t\t\t\tThe first row in the table list information about the \n\t\t\t\telement itself. If the element is not modular, only the \n\t\t\t\tfirst row exists in the table.')
moduleDetailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleDetailEntry.setStatus('mandatory')
moduleMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 1), TPhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleMacAddress.setStatus('optional')
if mibBuilder.loadTexts: moduleMacAddress.setDescription("Module MAC address. If the MAC address is unknown\n\t\t\t\t'00.00.00.00.00.00' is returned.")
moduleBusAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleBusAddress.setStatus('optional')
if mibBuilder.loadTexts: moduleBusAddress.setDescription('Module bus address.')
moduleAppDate = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAppDate.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAppDate.setDescription('Module application software date.')
moduleAppVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleAppVersion.setStatus('mandatory')
if mibBuilder.loadTexts: moduleAppVersion.setDescription('Module application software version. If software version\n\t\t\t\tis undefined, then zero length string is returned.')
moduleBiosDate = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleBiosDate.setStatus('mandatory')
if mibBuilder.loadTexts: moduleBiosDate.setDescription('Module BIOS date.')
moduleBiosVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleBiosVersion.setStatus('mandatory')
if mibBuilder.loadTexts: moduleBiosVersion.setDescription('Module BIOS version. If bios version is undefined,\n\t\t\t\ta zero length string is returned.')
moduleHwSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: moduleHwSerialNumber.setDescription('Module serial number.')
moduleHwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 1, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleHwVersion.setStatus('mandatory')
if mibBuilder.loadTexts: moduleHwVersion.setDescription('Module hardware version.')
moduleStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2))
moduleStatusTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1), )
if mibBuilder.loadTexts: moduleStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: moduleStatusTable.setDescription('This table contains status objects for modules inside\n\t\t\t\tthe network element.The first row in the table lists \n\t\t\t\tinformation about the host module. If the element is \n\t\t\t\tnot modular, only the first row exists in the table.')
moduleStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: moduleStatusEntry.setDescription('Row in moduleStatusTable. The index is moduleId from\n\t\t\t\tthe moduleTable. Row in this table exist only if \n\t\t\t\tthere is a row with the same moduleId in the moduleTable.')
statusResetCause = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("selfReset", 2), ("powerReset", 3), ("commandedReset", 4), ("softdownloadReset", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusResetCause.setStatus('mandatory')
if mibBuilder.loadTexts: statusResetCause.setDescription('Reason for the last reset.\n\t\t\t\t\n\t\t\t\tIf the reason is unknown, the value is reasonUnknown(1).\n\t\t\t\tIf the device makes self reset and it can detect it, then\n\t\t\t\tvalue is reasonSelfReset(2). If the reset was made by the \n\t\t\t\tuser from the power switch and it can be sensed, then the \n\t\t\t\tvalue is reasonPowerReset(3). If the reason is an external \n\t\t\t\tcommand from the user interface or from the network \n\t\t\t\tmessage (e.g. commonReset), then the reason is \n\t\t\t\treasonCommandedReset(4).')
statusRunningSwImage = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusRunningSwImage.setStatus('mandatory')
if mibBuilder.loadTexts: statusRunningSwImage.setDescription('Currently running software image number.\n\t\t\t\tBios is 0, applications are numbered from 1..n, \n\t\t\t\twhere n is the maximum image number.')
statusInternalTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-600, 1300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusInternalTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: statusInternalTemperature.setDescription('Device temperature, unit 0.1 deg C. Value is zero (0),\n\t\t\t\tif temperature is not available.')
statusLidStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLid", 1), ("closed", 2), ("open", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusLidStatus.setStatus('optional')
if mibBuilder.loadTexts: statusLidStatus.setDescription('Current lid status detected by the device. May or may not be\n\t\t\t\tthe same variable as the elementLidStatus.')
statusRestartCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statusRestartCounter.setStatus('optional')
if mibBuilder.loadTexts: statusRestartCounter.setDescription('This objects counts the number of restarts of the module. \n\t\t\t\tA start can be a cold start or a warm start.')
moduleControl = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3))
moduleControlTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1), )
if mibBuilder.loadTexts: moduleControlTable.setStatus('optional')
if mibBuilder.loadTexts: moduleControlTable.setDescription('This table contains common control commands for all the\n\t\t\t\tmodules inside the element.')
moduleControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleControlEntry.setStatus('optional')
controlLedUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("alwaysOn", 2), ("offWhenLidClosed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlLedUsage.setStatus('optional')
if mibBuilder.loadTexts: controlLedUsage.setDescription("A variable to instruct how device LED's behave when \n\t\t\t\tthe lid is closed.")
controlMarkState = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("on", 2), ("off", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlMarkState.setStatus('optional')
if mibBuilder.loadTexts: controlMarkState.setDescription('A variable to instruct the device to start and stop\n\t\t\t\tshowing mark (blinking module LED).\n\t\t\t\t\n\t\t\t\tOn read requests returns the current mark state.')
controlReset = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noReset", 1), ("hardReset", 2), ("softReset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlReset.setStatus('optional')
if mibBuilder.loadTexts: controlReset.setDescription('On write requests this object commands the module to \n\t\t\t\treset itself.\n\t\t\t\t\n\t\t\t\tIf softReset(3) or hardReset(2) can not be performed,\n\t\t\t\tthen BAD VALUE error is returned.\n\t\t\t\t\n\t\t\t\tOn read requests value noReset(1) is returned.')
controlTempLimitHiHi = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTempLimitHiHi.setStatus('optional')
if mibBuilder.loadTexts: controlTempLimitHiHi.setDescription('Module temperature HiHi (high alarm) limit in 0.1 degC.')
controlTempLimitHi = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTempLimitHi.setStatus('optional')
if mibBuilder.loadTexts: controlTempLimitHi.setDescription('Module temperature Hi (high warning) limit in 0.1 degC.')
controlTempLimitLo = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTempLimitLo.setStatus('optional')
if mibBuilder.loadTexts: controlTempLimitLo.setDescription('Module temperature Lo (low warning) limit in 0.1 degC.')
controlTempLimitLoLo = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTempLimitLoLo.setStatus('optional')
if mibBuilder.loadTexts: controlTempLimitLoLo.setDescription('Module temperature LoLo (low alarm) limit in 0.1 degC.')
controlTempDeadBand = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlTempDeadBand.setStatus('optional')
if mibBuilder.loadTexts: controlTempDeadBand.setDescription("Module temperature alarm/warning deadband in 0.1 degC. Common\n\t\t\t\tto all limit values (LoLo, Lo, Hi, HiHi). The deadband defines\n\t\t\t\tthe difference between the 'ON' limit and the 'OFF' limit of\n\t\t\t\tthe corresponding alarm.\n\t\t\t\t\n\t\t\t\tExample: The Hi limit is 65 degC and the deadband is 5 degC.\n\t\t\t\tThe high warning is activated when the temperature exceeds\n\t\t\t\t65 degC and deactivated only after it falls below 60 degC.")
controlInternalAppAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allowIntControl", 1), ("denyIntControl", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlInternalAppAccess.setStatus('optional')
if mibBuilder.loadTexts: controlInternalAppAccess.setDescription("This object defines whether the internal controller application\n\t\t\t\tis able to access the module parameters. This corresponds\n\t\t\t\tto the BXX module setting 'Allow Functions'.\n\t\t\t\t1 = allow internal control\n\t\t\t\t2 = deny internal control (remote control is possible)")
controlLocalAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: controlLocalAccess.setStatus('optional')
if mibBuilder.loadTexts: controlLocalAccess.setDescription("This object defines whether the local user interface\n\t\t\t\t(buttons, knobs etc.) is enabled or disabled. Values:\n\t\t\t\t1 = disabled, local UI is locked\n\t\t\t\t2 = enabled, local UI is active\n\t\t\t\tFor modules/devices with no local UI this objects should\n\t\t\t\treturn value 'disabled (1).")
moduleSWUpdateTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2), )
if mibBuilder.loadTexts: moduleSWUpdateTable.setStatus('optional')
if mibBuilder.loadTexts: moduleSWUpdateTable.setDescription('A table of software update control objects.')
moduleSWUpdateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleSWUpdateEntry.setStatus('optional')
sWUpdateControl = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("updateIdle", 1), ("updateRunning", 2), ("updateFailed", 3), ("updateStart", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWUpdateControl.setStatus('optional')
if mibBuilder.loadTexts: sWUpdateControl.setDescription('Writing value updateStart(4) commands the module to run a software \n\t\t\t\tupdate. The software image location and  file name are specified in \n\t\t\t\tsWUpdateURL and sWUpdateFilename.\n\t\t\t\t\n\t\t\t\tWriting a updateIdle(1) when the update is running will terminate the \n\t\t\t\tupdate process immediately. Writing any value when no update is \n\t\t\t\trunnign has no effect.\n\t\t\t\t\n\t\t\t\tReading this object returns either updateIdle(1), updateRunning(2) or \n\t\t\t\tupdateFailed(3) depending on the status of the (last) software update.\n\t\t\t\t')
swUpdateURL = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swUpdateURL.setStatus('optional')
if mibBuilder.loadTexts: swUpdateURL.setDescription('The URL where the software image can be downloaded.\n\t\t\t\t\n\t\t\t\tFormat e.g. TFTP:\\\\downloads\\swupdate\\.')
sWUpdateFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sWUpdateFileName.setStatus('optional')
if mibBuilder.loadTexts: sWUpdateFileName.setDescription('File name of the software image file to be downloaded.')
sWUpdateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 3, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sWUpdateStatus.setStatus('optional')
if mibBuilder.loadTexts: sWUpdateStatus.setDescription("Description of the software update result.\n\t\t\t\t\n\t\t\t\tAfter successful update this object should return a string \n\t\t\t\t'Software updated successfully on <date and time>'. If the update failed \n\t\t\t\tthe returned value should be 'Software update failed'.\n\t\t\t\t")
moduleRegistry = MibIdentifier((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4))
moduleSizeOfTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 1), )
if mibBuilder.loadTexts: moduleSizeOfTable.setStatus('optional')
if mibBuilder.loadTexts: moduleSizeOfTable.setDescription('This table defines maximum number of entries \n\t\t\t\tin the registry tables. All the registry tables have\n\t\t\t\tfixed size defined in this table.')
moduleSizeOfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 1, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"))
if mibBuilder.loadTexts: moduleSizeOfEntry.setStatus('optional')
sizeOfRegistry = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sizeOfRegistry.setStatus('mandatory')
if mibBuilder.loadTexts: sizeOfRegistry.setDescription('Max number of entries in the registryTable.\n\t\t\t\tThe entries in the registryTable are numbered\n\t\t\t\tfrom 1..sizeofRegistry.')
sizeOfRepairlog = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sizeOfRepairlog.setStatus('optional')
if mibBuilder.loadTexts: sizeOfRepairlog.setDescription('Max number of entries in the repairlogTable.\n\t\t\t\t\n\t\t\t\tFirst entry (oldest entry) is deleted, when a new \n\t\t\t\tentry is added and the table is full.')
sizeOfNotebook = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sizeOfNotebook.setStatus('optional')
if mibBuilder.loadTexts: sizeOfNotebook.setDescription('Max number of entries in the notebookTable.\n\t\t\t\tThe lines in the notebookTable are numbered from\n\t\t\t\t1..sizeofNotebook.')
moduleRegistryTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 2), )
if mibBuilder.loadTexts: moduleRegistryTable.setStatus('optional')
if mibBuilder.loadTexts: moduleRegistryTable.setDescription("This table lists user data for all modules \n\t\t\t\tinstalled inside the element.\n\t\t\t\t\n\t\t\t\tTable is indexed by the moduleId and regIndex.\n\t\t\t\tregIndex can have values 1..sizeofRegistry.\n\t\t\t\t\n\t\t\t\tA registryEntry is 'deleted' by setting its name\n\t\t\t\tto an empty string.")
moduleRegistryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 2, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"), (0, "TELESTE-COMMON-MIB", "regIndex"))
if mibBuilder.loadTexts: moduleRegistryEntry.setStatus('optional')
regIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: regIndex.setStatus('optional')
if mibBuilder.loadTexts: regIndex.setDescription('A second index to registryTable.\n\t\t\t\tCan have values 1..sizeofRegistryTable.')
regName = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 2, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: regName.setStatus('optional')
if mibBuilder.loadTexts: regName.setDescription('Descriptive name for the parameter. \n\t\t\t\t\n\t\t\t\tThe agent is allowed to limit the length of the name. \n\t\t\t\tMinimum length of eight characters must be supported.\n\t\t\t\t\n\t\t\t\tWriting empty string to this object removes it from the\n\t\t\t\tregistryTable.')
regValue = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: regValue.setStatus('optional')
if mibBuilder.loadTexts: regValue.setDescription('Textual information describing the parameter information.\n\t\t\t\t \n\t\t\t\tThe agent is allowed to limit the length of the name. \n\t\t\t\tMinimum length of eight characters must be supported.')
moduleRepairLogTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3), )
if mibBuilder.loadTexts: moduleRepairLogTable.setStatus('optional')
if mibBuilder.loadTexts: moduleRepairLogTable.setDescription('This table contains repair history entries for modules\n\t\t\t\tin the element. The table is indexed with moduleId and \n\t\t\t\trepairLogDate.\n\t\t\t\t\n\t\t\t\tThe table can have sizeofRepairlog number of entries. \n\t\t\t\tIf this number is exceeded when writing a new entry, \n\t\t\t\tthe oldest entry is deleted and and a new entry is added.')
moduleRepairLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"), (0, "TELESTE-COMMON-MIB", "repairIndex"))
if mibBuilder.loadTexts: moduleRepairLogEntry.setStatus('optional')
if mibBuilder.loadTexts: moduleRepairLogEntry.setDescription("Row entry in RepairLogTable.\n\t\t\t\t\n\t\t\t\tNote that it uses double index: moduleId  repairIndex. \n\t\t\t\tthat uniquely identify each log entry. Rows for particular\n\t\t\t\tmodule exist only if there is row, that represents this\n\t\t\t\tmodule in the moduleTable. \n\t\t\t\t\n\t\t\t\tA row is 'deleted' by giving a date 0000-00-00.")
repairIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: repairIndex.setStatus('optional')
if mibBuilder.loadTexts: repairIndex.setDescription('Row number of the Repairlog entry. Can have values \n\t\t\t\tbetween 1..sizeOfRepairlog. This field is a second index\n\t\t\t\tto moduleRepairLogTable.')
repairDate = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: repairDate.setStatus('optional')
if mibBuilder.loadTexts: repairDate.setDescription('Date of this repair entry formatted as CCYY-MM-DD.')
repairReasonCode = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: repairReasonCode.setStatus('optional')
if mibBuilder.loadTexts: repairReasonCode.setDescription('Repair code for this entry.')
repairNameCode = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: repairNameCode.setStatus('optional')
if mibBuilder.loadTexts: repairNameCode.setDescription('Repairer name code (initials) for this entry.')
repairComment = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 3, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: repairComment.setStatus('optional')
if mibBuilder.loadTexts: repairComment.setDescription('Comment of the repair event.\n\t\t\t\tThe agent is allowed to truncate the length of the\n\t\t\t\tcomment, if it is too long to internal storage.')
moduleNotebookTable = MibTable((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 4), )
if mibBuilder.loadTexts: moduleNotebookTable.setStatus('optional')
if mibBuilder.loadTexts: moduleNotebookTable.setDescription('Notebook is a free text area for manager or serviceman \n\t\t\t\tnotes. It is divided into 50 character long character\n\t\t\t\tblocks or lines. Each line is an entry in the \n\t\t\t\tnotebookTable.\n\t\t\t\t\n\t\t\t\tIndices are moduleName and lineNumber.\n\t\t\t\t\n\t\t\t\tA new line with the same lineNumber overwrites \n\t\t\t\tthe old line.')
moduleNotebookEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 4, 1), ).setIndexNames((0, "TELESTE-COMMON-MIB", "moduleId"), (0, "TELESTE-COMMON-MIB", "notebookLineNumber"))
if mibBuilder.loadTexts: moduleNotebookEntry.setStatus('optional')
notebookLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: notebookLineNumber.setStatus('optional')
if mibBuilder.loadTexts: notebookLineNumber.setDescription('The line number of the notebookTextLine.\n\t\t\t\tThe number must be in between 1..sizeofNotebook.\n\t\t\t\tinclusive. Numbers should be used consecutively.')
notebookLineText = MibTableColumn((1, 3, 6, 1, 4, 1, 3715, 99, 2, 4, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: notebookLineText.setStatus('optional')
if mibBuilder.loadTexts: notebookLineText.setDescription('Text field for storing notes about the module.')
mibBuilder.exportSymbols("TELESTE-COMMON-MIB", moduleRackNo=moduleRackNo, productKeyEntry=productKeyEntry, moduleAppVersion=moduleAppVersion, notebookLineText=notebookLineText, controlTrapDelay=controlTrapDelay, controlTempDeadBand=controlTempDeadBand, receiverPort=receiverPort, elementLongitude=elementLongitude, controlTrapReceiverTable=controlTrapReceiverTable, productKeyNumberOfFeatures=productKeyNumberOfFeatures, repairReasonCode=repairReasonCode, productKeyValue=productKeyValue, statusInternalTemperature=statusInternalTemperature, productKeyTable=productKeyTable, moduleBusAddress=moduleBusAddress, moduleSizeOfEntry=moduleSizeOfEntry, regName=regName, moduleId=moduleId, statusBusMaster=statusBusMaster, statusTemperature=statusTemperature, moduleSWUpdateTable=moduleSWUpdateTable, sizeOfNotebook=sizeOfNotebook, controlLedUsage=controlLedUsage, statusLmt=statusLmt, controlLocalAccess=controlLocalAccess, controlTrapReceiverEntry=controlTrapReceiverEntry, moduleRegistry=moduleRegistry, moduleRepairLogTable=moduleRepairLogTable, statusRestartCounter=statusRestartCounter, moduleNotebookTable=moduleNotebookTable, controlAlarmOffDelay=controlAlarmOffDelay, productKeyIndex=productKeyIndex, elementTotalUpTime=elementTotalUpTime, productKeyFeatureEntry=productKeyFeatureEntry, moduleBiosVersion=moduleBiosVersion, moduleHwSerialNumber=moduleHwSerialNumber, moduleHwVersion=moduleHwVersion, controlTempLimitHiHi=controlTempLimitHiHi, sWUpdateStatus=sWUpdateStatus, statusFan=statusFan, statusGeneral=statusGeneral, sWUpdateControl=sWUpdateControl, productKeyCipher=productKeyCipher, productKeyFeatureName=productKeyFeatureName, elementConfigChangeCode=elementConfigChangeCode, statusSoftware=statusSoftware, repairDate=repairDate, moduleStatus=moduleStatus, statusHardware=statusHardware, controlTrapLifeTime=controlTrapLifeTime, controlResetElement=controlResetElement, moduleSlotNo=moduleSlotNo, moduleRegistryTable=moduleRegistryTable, moduleControlEntry=moduleControlEntry, moduleDetailTable=moduleDetailTable, statusSettings=statusSettings, controlReset=controlReset, moduleMacAddress=moduleMacAddress, controlBusMasterAdminState=controlBusMasterAdminState, moduleName=moduleName, controlMarkState=controlMarkState, productKeyFeatureIndex=productKeyFeatureIndex, repairIndex=repairIndex, notebookLineNumber=notebookLineNumber, moduleStatusEntry=moduleStatusEntry, elementControl=elementControl, controlAlarmOnDelay=controlAlarmOnDelay, receiverEntryId=receiverEntryId, productKeyFeatureExpirationTime=productKeyFeatureExpirationTime, moduleStatusTable=moduleStatusTable, elementResetCount=elementResetCount, moduleEntry=moduleEntry, productKeyNumberOfKeys=productKeyNumberOfKeys, moduleTable=moduleTable, controlTempLimitLo=controlTempLimitLo, sizeOfRegistry=sizeOfRegistry, controlTempLimitHi=controlTempLimitHi, moduleNotebookEntry=moduleNotebookEntry, moduleHwType=moduleHwType, elementName=elementName, moduleSWUpdateEntry=moduleSWUpdateEntry, elementAltitude=elementAltitude, sizeOfRepairlog=sizeOfRepairlog, sWUpdateFileName=sWUpdateFileName, productKeyStatus=productKeyStatus, moduleDetailEntry=moduleDetailEntry, controlInternalAppAccess=controlInternalAppAccess, elementStructure=elementStructure, statusResetCause=statusResetCause, elementStatus=elementStatus, moduleSizeOfTable=moduleSizeOfTable, controlTrapSending=controlTrapSending, regIndex=regIndex, statusLidStatus=statusLidStatus, elementProductKey=elementProductKey, moduleBiosDate=moduleBiosDate, moduleRepairLogEntry=moduleRepairLogEntry, controlTempLimitLoLo=controlTempLimitLoLo, moduleControlTable=moduleControlTable, productKeyFeatureEnable=productKeyFeatureEnable, controlTrapInterval=controlTrapInterval, statusRunningSwImage=statusRunningSwImage, moduleRegistryEntry=moduleRegistryEntry, repairNameCode=repairNameCode, elementInformation=elementInformation, moduleControl=moduleControl, swUpdateURL=swUpdateURL, element=element, productKeyFeatureTable=productKeyFeatureTable, controlMaxNumberTrapReceivers=controlMaxNumberTrapReceivers, productKeyMask=productKeyMask, receiverCommunity=receiverCommunity, elementLatitude=elementLatitude, moduleAppDate=moduleAppDate, moduleInformation=moduleInformation, regValue=regValue, controlAlarmDetection=controlAlarmDetection, module=module, statusLid=statusLid, receiverAddress=receiverAddress, repairComment=repairComment)
