#
# PySNMP MIB module ARRIS-C3-MAC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/arris/ARRIS-C3-MAC-MIB
# Produced by pysmi-1.1.12 at Fri Nov 22 15:07:26 2024
# On host fv-az692-788 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
cmtsC3, = mibBuilder.importSymbols("ARRIS-MIB", "cmtsC3")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
TenthdBmV, TenthdB = mibBuilder.importSymbols("DOCS-IF-MIB", "TenthdBmV", "TenthdB")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Gauge32, IpAddress, Counter32, Counter64, Integer32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, MibIdentifier, Bits, iso, ObjectIdentity, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Gauge32", "IpAddress", "Counter32", "Counter64", "Integer32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "MibIdentifier", "Bits", "iso", "ObjectIdentity", "Unsigned32")
TimeInterval, TextualConvention, TruthValue, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "TextualConvention", "TruthValue", "RowStatus", "DisplayString")
cmtsC3MACMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6))
cmtsC3MACMIB.setRevisions(('2004-11-21 00:00', '2004-11-26 00:00', '2004-12-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cmtsC3MACMIB.setRevisionsDescriptions(('Changes to support fully programmable IF frequency.\n             Added support for downstream wireless mode.\n             Updated some mib descriptions for clarity and typos.\n             Added mixed mode to DocsisMacType definition which defines a\n             docsis downstream and euro-docsis upstream configuration that is\n             used by some customers in lieu of annex C mode which the CMTS does\n             not support in hardware.\n             Added support for downstream wireless mode.', 'Added dcxMACUpChannelinitialRangingDelay.', 'Added dcxMACUccMaxFailedAttempts.',))
if mibBuilder.loadTexts: cmtsC3MACMIB.setLastUpdated('200412030000Z')
if mibBuilder.loadTexts: cmtsC3MACMIB.setOrganization('Arris International')
if mibBuilder.loadTexts: cmtsC3MACMIB.setContactInfo('   Network Management\n                Postal: Arris International.\n                        4400 Cork Airport Business Park\n                        Cork Airport, Kinsale Road\n                        Cork, Ireland.\n                Tel:    +353 21 7305 800\n                Fax:    +353 21 4321 972')
if mibBuilder.loadTexts: cmtsC3MACMIB.setDescription('This MIB manages the MAC software on the Cadant C3 CMTS.')
class DocsisMacType(TextualConvention, Integer32):
    description = 'Indicates the DOCSIS Channel Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("docsis", 1), ("euroDocsis", 2), ("mixed", 3), ("custom", 4))

dcxMACObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1))
dcxMACCmtsMacTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1), )
if mibBuilder.loadTexts: dcxMACCmtsMacTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACCmtsMacTable.setDescription('Additional columns for docsIfCmtsMacTable.\n                An entry in this table exists for each ifEntry with an \n                ifType of docsCableMaclayer(127).')
dcxMACCmtsMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dcxMACCmtsMacEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACCmtsMacEntry.setDescription('dcxMACCmtsMacEntry')
dcxMACCmtsMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 1), DocsisMacType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACCmtsMacMode.setStatus('current')
if mibBuilder.loadTexts: dcxMACCmtsMacMode.setDescription('Indicates the mode in which the MAC is operating. A read to this\n            value may return any of the modes defined by DocsisMacType. Only\n            the modes docsis, euroDocsis and mixed may be written.\n            When set to docsis or euroDocsis, all downstream and upstream\n            channels in this MAC domain will be configured in DOCSIS or\n            EuroDOCSIS mode respectively. When set to mixed, the downstream\n            channels will be configured in DOCSIS and the upstream channels\n            will be running in EuroDOCSIS mode.\n            The value custom will be returned in a read operation if any of\n            the underlying channels has been reconfigured in such a way that\n            the MAC can not be described a docsis, euroDocsis or mixed.')
dcxMACCableAdvanceType = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dynamic", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACCableAdvanceType.setStatus('current')
if mibBuilder.loadTexts: dcxMACCableAdvanceType.setDescription('Cable Map Advance Type - 0 for Static, 1 for Dynamic.')
dcxMACPlantLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 161))).setUnits('kilometers').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACPlantLength.setStatus('current')
if mibBuilder.loadTexts: dcxMACPlantLength.setDescription('Cable Plant Length (1-way) in kilometers.')
dcxMACFlapAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 864000))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACFlapAgingTime.setStatus('current')
if mibBuilder.loadTexts: dcxMACFlapAgingTime.setDescription('Cable Flap List Aging Time in seconds.')
dcxMACFlapInsertTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACFlapInsertTime.setStatus('current')
if mibBuilder.loadTexts: dcxMACFlapInsertTime.setDescription('Cable Flap List Insertion Time threshold in seconds.')
dcxMACFlapMissThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setUnits('misses').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACFlapMissThresh.setStatus('current')
if mibBuilder.loadTexts: dcxMACFlapMissThresh.setDescription('Cable Flap List Miss Threshold in misses.')
dcxMACFlapListSize = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 6000))).setUnits('entries').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACFlapListSize.setStatus('current')
if mibBuilder.loadTexts: dcxMACFlapListSize.setDescription('Cable Flap List Maximum Number of Entries.')
dcxMACCmOfflineAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3600, 864000)).clone(86400)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACCmOfflineAgingTime.setStatus('current')
if mibBuilder.loadTexts: dcxMACCmOfflineAgingTime.setDescription('Cable modem offline aging time in seconds. Minimum value\n            is 1 hour. Maximum time before aging a modem is 10 days.\n            Default value is 24 hours.')
dcxMACUccMaxFailedAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 1, 1, 10), Unsigned32().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUccMaxFailedAttempts.setStatus('current')
if mibBuilder.loadTexts: dcxMACUccMaxFailedAttempts.setDescription('Maximum number of consecutive failed channel change attempts that\n            a modem is allowed before the CMTS decides to no longer use the\n            modem for load balancing purposes.\n            If a modem successfully completes a channel change before the\n            maximum number of attempts is reached, the number of consecutive\n            failed attempts for the modem is reset.\n            A value of 0 indicates no limit.')
dcxMACDownstreamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2), )
if mibBuilder.loadTexts: dcxMACDownstreamChannelTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownstreamChannelTable.setDescription('Additional columns for docsIfDownstreamChannelTable.\n                An entry in this table exists for each ifEntry with an \n                ifType of docsCableDownstream(128).')
dcxMACDownstreamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dcxMACDownstreamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownstreamChannelEntry.setDescription('dcxMACDownstreamChannelEntry')
dcxMACDownChannelMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 1), DocsisMacType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACDownChannelMacMode.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelMacMode.setDescription('Configures the downstream to DOCSIS or EuroDOCSIS.\n            When dcxMACDownChannelWirelessMode is disabled, changes to this\n            will impact the downstream annex type, modulation, symbol rate\n            and interleaver. When wireless mode is enabled, only the annex\n            type and interleaver will be changed.')
dcxMACDownChannelUpconverter = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACDownChannelUpconverter.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelUpconverter.setDescription('Controls whether or not the internal upconverter is used.\n             If set to internal, the downstream IF frequency will operate\n             in read-only mode and will be configured internally by the\n             CMTS based on the downstream channel configuration.\n             If set to external, the IF frequency may be programmed to set the\n             frequency supplied to an external upconverter via the IF output.\n             In this mode, the downstream RF frequency and power will both\n             return 0 when read.')
dcxMACDownChannelIfFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10000000, 60000000))).setUnits('hertz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACDownChannelIfFrequency.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelIfFrequency.setDescription('The IF frequency output by the modulator for this channel.')
dcxMACDownChannelWirelessMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACDownChannelWirelessMode.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelWirelessMode.setDescription('Enabling this mode allows non-standard downstream modulations and\n            symbol rates to be configured which are suitable when using the\n            CMTS in a wireless application. Changes to dcxMACDownChannelMacMode\n            when wireless mode is active will only impact the downstream annex\n            type and interleaver settings. Modulation and symbol rates will\n            only be affected when wireless mode is disabled.\n            Disabling wireless mode will reset any non-standard modulation and\n            symbol rates settings in order to restore a standard DOCSIS or\n            EuroDOCSIS downstream.\n            If a set to active fails, a license may be required to activate the\n            feature.')
dcxMACDownChannelSymbolRate = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1250000, 6952000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACDownChannelSymbolRate.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelSymbolRate.setDescription('Sets the downstream symbol rate.')
dcxMACDownChannelAlpha = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 2, 1, 6), Integer32()).setUnits('percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: dcxMACDownChannelAlpha.setStatus('current')
if mibBuilder.loadTexts: dcxMACDownChannelAlpha.setDescription('The percentage of excess bandwidth for the channel.')
dcxMACUpstreamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3), )
if mibBuilder.loadTexts: dcxMACUpstreamChannelTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamChannelTable.setDescription('Additional columns for docsIfUpstreamChannelTable.\n                An entry in this table exists for each ifEntry with an \n                ifType of docsCableUpstream(129).')
dcxMACUpstreamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: dcxMACUpstreamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamChannelEntry.setDescription('dcxMACUpstreamChannelEntry')
dcxMACUpChannelMacMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 1), DocsisMacType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelMacMode.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelMacMode.setDescription('Indicates the mode in which this upstream is operating. A read or\n            write to this may consist only of the values docsis or euroDocsis.')
dcxMACUpChannelAmpAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 2), TenthdBmV()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelAmpAttenuation.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelAmpAttenuation.setDescription('The amplifier attenuation level for this logical \n            channel.')
dcxMACUpChannelIngressCancellation = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("tdmaOnly", 2), ("scdmaSec", 3), ("scdmaInc1", 4), ("scdmaInc2", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelIngressCancellation.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelIngressCancellation.setDescription('Sets the ingress noise cancellation mode for this\n            logical channel. Not all modes may be valid for a\n            given logical channel configuration or hardware.')
dcxMACUpChannelGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelGroupId.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelGroupId.setDescription('The group ID for this logical channel used to associate it \n            with other upsteams on the same physical network. The group ID \n            is an index into the dcxMACUpstreamGroupTable which defines common \n            parameters for grouped upsteams. Upstreams do not have to be \n            grouped and there may be more than one group on the same physical \n            network. Spatially diverse upstreams should not have the same group ID.')
dcxMACUpChannelShortPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 5), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelShortPollInterval.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelShortPollInterval.setDescription('The short interval for initial unicast maintanance on this logical \n            channel.')
dcxMACUpChannelPeriodicPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 6), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(100, 10000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelPeriodicPollInterval.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelPeriodicPollInterval.setDescription('The periodic station maintanance interval on this logical channel.')
dcxMACUpChannelInputPowerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("fixed", 1), ("automatic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelInputPowerMode.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelInputPowerMode.setDescription('The receiver input power mode for this logical channel. In fixed\n            mode the input power to the demodulator will remain fixed across \n            symbol rate changes. In automatic mode the demodulator may vary the \n            input power for optimal performance.')
dcxMACUpChannelPower = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 8), TenthdBmV()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelPower.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelPower.setDescription('The nominal receiver input  power for this logical channel.')
dcxMACUpChannelPlantLength = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 320))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelPlantLength.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelPlantLength.setDescription('The cable length in km to the most distant CM on this logical \n                upstream.')
dcxMACUpChannelMaxCmMapProcTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelMaxCmMapProcTime.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelMaxCmMapProcTime.setDescription('The maximum time in microseconds allowed for modems on this logical \n            channel to process the Upstream Bandwidth Allocation MAP.')
dcxMACUpChannelConcatenation = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelConcatenation.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelConcatenation.setDescription('Enables or disables the use of packet concatenation by Cable Modems on \n            this logical channel.')
dcxMACUpChannelSpMgtTriggerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelSpMgtTriggerIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelSpMgtTriggerIndex.setDescription('An index into spectral management trigger table, identical \n            to dcxMACSpMgtTriggerIndex in that table. All entries with \n            the same value of dcxMACSpMgtTriggerIndex form a trigger group \n            all assigned to the same logical upstream channel or group. \n            Returns 0 if there are no triggers assigned to this logical \n            channel.')
dcxMACUpChannelLowPowerOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 13), TenthdBmV().subtype(subtypeSpec=ValueRangeConstraint(-100, -10)).clone(-60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelLowPowerOffset.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelLowPowerOffset.setDescription('The maximum power offset of a burst below the nominal\n            input power to the CMTS that will not cause a RNG-RSP\n            with status continue. Valid range is from -10 dBmV to\n            -1 dBmV in 1 dB increments.')
dcxMACUpChannelHighPowerOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 14), TenthdBmV().subtype(subtypeSpec=ValueRangeConstraint(10, 100)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelHighPowerOffset.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelHighPowerOffset.setDescription('The maximum power offset of a burst above the nominal\n            input power to the CMTS that will not cause a RNG-RSP\n            with status continue. Valid range is from +1 dBmV to\n            +10 dBmV in 1 dB increments.')
dcxMACUpChannelLogSnrAveTimeconstant = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelLogSnrAveTimeconstant.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelLogSnrAveTimeconstant.setDescription('The averaging timeconstant used to calculate the per-logical channel \n            MIB variable docsIfSigQSignalNoise. The averaging uses a logarithmic\n            scale, so that the actual timeconstant used is 2^X, where X is the\n            value configured for this object. Increasing the value of X increases\n            the degree to which the SNR results are averaged over time, and reduces\n            the sensitivity of the reported channel SNR to local oscillations in\n            signal quality. Averaging can effectively be disabled by setting this\n            object to 0')
dcxMACUpChannelImpulseMitigation = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelImpulseMitigation.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelImpulseMitigation.setDescription('Enables or disables impulse noise mitigation for this \n            logical channel.')
dcxMACUpChannelRngPreambleGuardSymbols = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 17), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelRngPreambleGuardSymbols.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelRngPreambleGuardSymbols.setDescription('Number of guard symbols before the preamble pilot pattern for \n            ranging bursts. Guard symbols may help the receiver to mitigate \n            the effects of ISI and\\or help with the detection of bursts with \n            an early arrival time')
dcxMACUpChannelNrngPreambleGuardSymbols = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 18), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelNrngPreambleGuardSymbols.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelNrngPreambleGuardSymbols.setDescription('Number of guard symbols before the preamble pilot pattern for \n            non-ranging bursts. Guard symbols may help the receiver to mitigate \n            the effects of ISI and\\or help with the detection of bursts with \n            an early arrival time')
dcxMACUpChannelExtendedFrequencyErrorDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("initialRanging", 1), ("periodicRanging", 2), ("allRanging", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelExtendedFrequencyErrorDetect.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelExtendedFrequencyErrorDetect.setDescription('Offsets in carrier frequency in the modem are corrected by the CMTS\n            during ranging. Typically most if not all off the frequency error is\n            removed in the initial ranging response with incremental changes removed\n            during periodic ranging. If large frequency offsets are expected during\n            initial or periodic ranging, this value may be configured to provide\n            extended frequency offset detection and correction.')
dcxMACUpChannelLogC3SnrTimeconstant = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 20), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelLogC3SnrTimeconstant.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelLogC3SnrTimeconstant.setDescription('The averaging timeconstant used to calculate the per-logical channel \n            MIB variable dcxMACUpChannelSignalNoise. The averaging uses a logarithmic\n            scale, so that the actual timeconstant used is 2^X, where X is the\n            value configured for this object. Increasing the value of X increases\n            the degree to which the SNR results are averaged over time, and reduces\n            the sensitivity of the reported channel SNR to local oscillations in\n            signal quality. Averaging can effectively be disabled by setting this\n            object to 0')
dcxMACUpChannelSignalNoise = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 21), TenthdB()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: dcxMACUpChannelSignalNoise.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelSignalNoise.setDescription('A measurement of the average signal/noise ratio for the logical upstream.\n            The averaging may be controlled using the dcxMACUpChannelLogC3SnrTimeconstant\n            variable')
dcxMACUpChannelSafeConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelSafeConfig.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelSafeConfig.setDescription('If true, MIB SETs which would cause this logical channel to go offline will return\n            a failure')
dcxMACUpChannelInitialRangingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 3, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 3000))).setUnits('microseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dcxMACUpChannelInitialRangingDelay.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpChannelInitialRangingDelay.setDescription('The number of extra microseconds to allow in a broadcast IUC3\n             grant to compensate for modems that perform initial ranging later\n             than expected.')
dcxMACUpstreamGroupTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4), )
if mibBuilder.loadTexts: dcxMACUpstreamGroupTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupTable.setDescription('Entries containing definitions for group IDs\n                that can be associated with an upstream channel.')
dcxMACUpstreamGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1), ).setIndexNames((0, "ARRIS-C3-MAC-MIB", "dcxMACUpstreamGroupId"))
if mibBuilder.loadTexts: dcxMACUpstreamGroupEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupEntry.setDescription('dcxMACUpstreamGroupEntry')
dcxMACUpstreamGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dcxMACUpstreamGroupId.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupId.setDescription('The ID for this group.')
dcxMACUpstreamGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamGroupName.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupName.setDescription('The name associated with this group')
dcxMACUpstreamGroupLoadBalancing = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("initialNumeric", 2), ("periodic", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamGroupLoadBalancing.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupLoadBalancing.setDescription('Configures upstream load balancing for the group.\n            Options are: none, initialNumeric, periodic.\n            If set to none, no load balancing will be performed.\n            If set to initialNumeric, the CMTS may redirect modems to other active upstream\n            channels in the same group by setting the upstream channel ID override in the\n            RNG-RSP at any time up to the point where the modem successfully completes\n            periodic ranging. Once a modem has completed ranging it must be reset before it\n            may be moved to another upstream. The modems in a group will be distributed\n            evenly and numerically across the active channels in the group. When a modems\n            performs initial ranging, it will be sent to the upsteam with the least number\n            of active modems if the number of active modems on the current upsteam is greater\n            than the average number of modems per upsteam in the group. All channels are\n            treated equally when calculating loads.\n            If a modem fails to range on the desired channel following a ranging overide,\n            it will be allowed to remain on the channel on which it next performs initial\n            ranging.\n            If set to periodic, modems will be numerically distributed during initial ranging\n            and then selectively moved after registration using UCC. Periodic load balancing\n            will attempt to distribute the modems to maintain even bandwidth utilization across\n            the channels in a group.')
dcxMACUpstreamGroupFrequencyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamGroupFrequencyIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupFrequencyIndex.setDescription('An index into upstream frequency table, identical to \n            dcxMACUpstreamFrequencyIndex in that table. All entries \n            with the same value of dcxMACUpstreamFrequencyIndex form \n            a spectral frequency group all assigned to the same \n            upstream group. Returns 0 if there are no triggers assigned \n            to this group.')
dcxMACUpstreamGroupSpMgtTriggerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamGroupSpMgtTriggerIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupSpMgtTriggerIndex.setDescription('An index into spectral management trigger table, identical \n            to dcxMACSpMgtTriggerIndex in that table. All entries with \n            the same value of dcxMACSpMgtTriggerIndex form a trigger group \n            all assigned to the same upstream group or channel. Returns 0 if \n            there are no triggers assigned to this group.')
dcxMACUpstreamGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamGroupStatus.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamGroupStatus.setDescription('Used to create rows in this table')
dcxMACUpstreamFrequencyTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5), )
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyTable.setDescription('Describes the upstream spectrum available for use by one or more\n                upstream groups. Entries are grouped by dcxMACUpstreamFrequencyIndex,\n                with each group assigned to one or more upstream groups.')
dcxMACUpstreamFrequencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1), ).setIndexNames((0, "ARRIS-C3-MAC-MIB", "dcxMACUpstreamFrequencyIndex"), (0, "ARRIS-C3-MAC-MIB", "dcxMACUpstreamFrequencyRegion"))
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyEntry.setDescription('Describes a single contiguous region of upstream spectrum, available for\n            use by one or more upstream spectral groups.')
dcxMACUpstreamFrequencyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyIndex.setDescription('An index into the upstream frequency table representing \n             a group of spectral regions, all associated with the \n             same upstream spectral group.')
dcxMACUpstreamFrequencyRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyRegion.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyRegion.setDescription('An index into the upstream frequency table which, when \n             grouped with other frequency regions with the same frequency\n             index fully describe the upstream frequency spectrum available\n             for use by a given spectral group.')
dcxMACUpstreamFrequencyStart = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1, 3), Integer32()).setUnits('hertz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStart.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStart.setDescription('The start frequency for this upstream spectral region.')
dcxMACUpstreamFrequencyStop = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1, 4), Integer32()).setUnits('hertz').setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStop.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStop.setDescription('The stop frequency for this upstream spectral region.')
dcxMACUpstreamFrequencyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStatus.setStatus('current')
if mibBuilder.loadTexts: dcxMACUpstreamFrequencyStatus.setDescription('Used to create entries in this table.')
dcxMACSpectralMgtObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6))
dcxMACSpectralMgtTriggerTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1), )
if mibBuilder.loadTexts: dcxMACSpectralMgtTriggerTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpectralMgtTriggerTable.setDescription('Describes the spectral management triggers assigned to one \n                or more upstream groups or channels. Entries are grouped by \n                dcxMACSpMgtTriggerIndex, with each group assigned to one or more \n                upstream channels or groups.')
dcxMACSpectralMgtTriggerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1), ).setIndexNames((0, "ARRIS-C3-MAC-MIB", "dcxMACSpMgtTriggerIndex"), (0, "ARRIS-C3-MAC-MIB", "dcxMACSpMgtTriggerNumber"))
if mibBuilder.loadTexts: dcxMACSpectralMgtTriggerEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpectralMgtTriggerEntry.setDescription('Describes a single spectral management trigger, available for\n            use by one or more upstream channels or spectral groups.')
dcxMACSpMgtTriggerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: dcxMACSpMgtTriggerIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerIndex.setDescription('An index into the spectral managment trigger table \n            representing a group of triggers, all assigned to\n             the same upstream channel or spectral group.')
dcxMACSpMgtTriggerNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dcxMACSpMgtTriggerNumber.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerNumber.setDescription('An index into the spectral managment trigger table which, \n            when grouped with other triggers with the same trigger\n            index fully describe the spectral mangement triggers\n            assigned to the same upstream channel or spectral group.')
dcxMACSpMgtTriggerType = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerType.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerType.setDescription('Identifies the trigger type represented by this entry.')
dcxMACSpMgtTriggerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerAction.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerAction.setDescription('An index into the spectral management action table,\n            identical to dcxMACSpMgtActionIndex in that table,\n            identifying the action to take if this trigger is\n            invoked. Returns 0 if there is no action associated\n            with this trigger.')
dcxMACSpMgtTriggerParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam1.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam1.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam2.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam2.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam3.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam3.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam4.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam4.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam5.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam5.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam6 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam6.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam6.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam7 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam7.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam7.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerParam8 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam8.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerParam8.setDescription('Parameter dependent on trigger type.')
dcxMACSpMgtTriggerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 1, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtTriggerStatus.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtTriggerStatus.setDescription('Used to create and control the status of entries in this table.')
dcxMACSpectralMgtActionTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2), )
if mibBuilder.loadTexts: dcxMACSpectralMgtActionTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpectralMgtActionTable.setDescription('Describes the spectral management actions assigned to one \n                or more spectral managment triggers.')
dcxMACSpectralMgtActionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1), ).setIndexNames((0, "ARRIS-C3-MAC-MIB", "dcxMACSpMgtActionIndex"))
if mibBuilder.loadTexts: dcxMACSpectralMgtActionEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpectralMgtActionEntry.setDescription('Describes a single spectral management action, assigned to\n            one or more spectral management triggers.')
dcxMACSpMgtActionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: dcxMACSpMgtActionIndex.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionIndex.setDescription('An index into the spectral managment actions table \n            used to assign actions to spectral management triggers.')
dcxMACSpMgtActionType = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionType.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionType.setDescription('Identifies the action type represented by this entry.')
dcxMACSpMgtActionParam1 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam1.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam1.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam2 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam2.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam2.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam3 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam3.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam3.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam4 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam4.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam4.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam5 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam5.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam5.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam6 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam6.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam6.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam7 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam7.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam7.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionParam8 = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionParam8.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionParam8.setDescription('Parameter dependent on action type.')
dcxMACSpMgtActionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 6, 2, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSpMgtActionStatus.setStatus('current')
if mibBuilder.loadTexts: dcxMACSpMgtActionStatus.setDescription('Used to create and control the status of entries in this table.')
dcxMACSharedSecretTable = MibTable((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 7), )
if mibBuilder.loadTexts: dcxMACSharedSecretTable.setStatus('current')
if mibBuilder.loadTexts: dcxMACSharedSecretTable.setDescription('Set up shared secrets for this DOCSIS MAC Interface')
dcxMACSharedSecretEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ARRIS-C3-MAC-MIB", "dcxMACSharedSecretId"))
if mibBuilder.loadTexts: dcxMACSharedSecretEntry.setStatus('current')
if mibBuilder.loadTexts: dcxMACSharedSecretEntry.setDescription('dcxMACSharedSecretEntry')
dcxMACSharedSecretId = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: dcxMACSharedSecretId.setStatus('current')
if mibBuilder.loadTexts: dcxMACSharedSecretId.setDescription('ID for the associated shared secret.')
dcxMACSharedSecretStr = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 7, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSharedSecretStr.setStatus('current')
if mibBuilder.loadTexts: dcxMACSharedSecretStr.setDescription('This is the shared secret itself, which is considered write-only. It can be SET \n             but when a GET operation is performed the value is not returned.')
dcxMACSharedSecretStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4115, 1, 4, 3, 6, 1, 7, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dcxMACSharedSecretStatus.setStatus('current')
if mibBuilder.loadTexts: dcxMACSharedSecretStatus.setDescription('Row status.')
mibBuilder.exportSymbols("ARRIS-C3-MAC-MIB", dcxMACUpChannelPower=dcxMACUpChannelPower, dcxMACSpMgtActionStatus=dcxMACSpMgtActionStatus, dcxMACUpChannelLogSnrAveTimeconstant=dcxMACUpChannelLogSnrAveTimeconstant, dcxMACDownstreamChannelEntry=dcxMACDownstreamChannelEntry, dcxMACUpChannelGroupId=dcxMACUpChannelGroupId, dcxMACUpstreamGroupFrequencyIndex=dcxMACUpstreamGroupFrequencyIndex, dcxMACObjects=dcxMACObjects, dcxMACDownChannelMacMode=dcxMACDownChannelMacMode, dcxMACSpMgtActionParam4=dcxMACSpMgtActionParam4, dcxMACDownChannelIfFrequency=dcxMACDownChannelIfFrequency, dcxMACUpstreamGroupSpMgtTriggerIndex=dcxMACUpstreamGroupSpMgtTriggerIndex, dcxMACSpMgtTriggerType=dcxMACSpMgtTriggerType, dcxMACDownChannelUpconverter=dcxMACDownChannelUpconverter, dcxMACUpChannelPlantLength=dcxMACUpChannelPlantLength, dcxMACUccMaxFailedAttempts=dcxMACUccMaxFailedAttempts, dcxMACFlapMissThresh=dcxMACFlapMissThresh, dcxMACCmtsMacMode=dcxMACCmtsMacMode, dcxMACUpstreamFrequencyEntry=dcxMACUpstreamFrequencyEntry, dcxMACSpectralMgtObjects=dcxMACSpectralMgtObjects, dcxMACSharedSecretStatus=dcxMACSharedSecretStatus, dcxMACUpChannelImpulseMitigation=dcxMACUpChannelImpulseMitigation, dcxMACUpstreamFrequencyRegion=dcxMACUpstreamFrequencyRegion, dcxMACSpMgtActionType=dcxMACSpMgtActionType, dcxMACUpChannelConcatenation=dcxMACUpChannelConcatenation, dcxMACUpChannelShortPollInterval=dcxMACUpChannelShortPollInterval, dcxMACUpChannelSignalNoise=dcxMACUpChannelSignalNoise, dcxMACDownChannelAlpha=dcxMACDownChannelAlpha, PYSNMP_MODULE_ID=cmtsC3MACMIB, dcxMACUpstreamFrequencyStatus=dcxMACUpstreamFrequencyStatus, dcxMACUpChannelSafeConfig=dcxMACUpChannelSafeConfig, dcxMACDownChannelWirelessMode=dcxMACDownChannelWirelessMode, dcxMACUpstreamFrequencyStop=dcxMACUpstreamFrequencyStop, dcxMACFlapInsertTime=dcxMACFlapInsertTime, dcxMACCableAdvanceType=dcxMACCableAdvanceType, dcxMACUpChannelLogC3SnrTimeconstant=dcxMACUpChannelLogC3SnrTimeconstant, dcxMACUpChannelInitialRangingDelay=dcxMACUpChannelInitialRangingDelay, dcxMACSpMgtTriggerIndex=dcxMACSpMgtTriggerIndex, dcxMACSpectralMgtTriggerEntry=dcxMACSpectralMgtTriggerEntry, dcxMACUpstreamFrequencyStart=dcxMACUpstreamFrequencyStart, dcxMACUpstreamChannelTable=dcxMACUpstreamChannelTable, dcxMACSharedSecretStr=dcxMACSharedSecretStr, dcxMACUpChannelHighPowerOffset=dcxMACUpChannelHighPowerOffset, dcxMACSpMgtActionParam5=dcxMACSpMgtActionParam5, dcxMACDownChannelSymbolRate=dcxMACDownChannelSymbolRate, dcxMACUpChannelAmpAttenuation=dcxMACUpChannelAmpAttenuation, dcxMACCmtsMacTable=dcxMACCmtsMacTable, dcxMACUpChannelLowPowerOffset=dcxMACUpChannelLowPowerOffset, dcxMACUpstreamGroupStatus=dcxMACUpstreamGroupStatus, dcxMACUpstreamChannelEntry=dcxMACUpstreamChannelEntry, dcxMACUpChannelMacMode=dcxMACUpChannelMacMode, dcxMACSpMgtTriggerParam1=dcxMACSpMgtTriggerParam1, dcxMACSpMgtTriggerParam8=dcxMACSpMgtTriggerParam8, dcxMACPlantLength=dcxMACPlantLength, dcxMACFlapAgingTime=dcxMACFlapAgingTime, dcxMACFlapListSize=dcxMACFlapListSize, dcxMACSharedSecretEntry=dcxMACSharedSecretEntry, dcxMACUpstreamGroupName=dcxMACUpstreamGroupName, dcxMACSpMgtTriggerParam2=dcxMACSpMgtTriggerParam2, dcxMACCmtsMacEntry=dcxMACCmtsMacEntry, dcxMACUpChannelSpMgtTriggerIndex=dcxMACUpChannelSpMgtTriggerIndex, dcxMACSpMgtActionParam7=dcxMACSpMgtActionParam7, dcxMACUpstreamFrequencyIndex=dcxMACUpstreamFrequencyIndex, dcxMACSpMgtTriggerNumber=dcxMACSpMgtTriggerNumber, dcxMACUpChannelNrngPreambleGuardSymbols=dcxMACUpChannelNrngPreambleGuardSymbols, dcxMACSpectralMgtActionTable=dcxMACSpectralMgtActionTable, dcxMACSpectralMgtActionEntry=dcxMACSpectralMgtActionEntry, dcxMACUpChannelMaxCmMapProcTime=dcxMACUpChannelMaxCmMapProcTime, dcxMACUpstreamGroupTable=dcxMACUpstreamGroupTable, dcxMACSpMgtActionIndex=dcxMACSpMgtActionIndex, dcxMACUpstreamFrequencyTable=dcxMACUpstreamFrequencyTable, dcxMACUpChannelInputPowerMode=dcxMACUpChannelInputPowerMode, dcxMACUpstreamGroupLoadBalancing=dcxMACUpstreamGroupLoadBalancing, dcxMACSpMgtTriggerParam4=dcxMACSpMgtTriggerParam4, dcxMACUpChannelIngressCancellation=dcxMACUpChannelIngressCancellation, DocsisMacType=DocsisMacType, dcxMACSpMgtActionParam8=dcxMACSpMgtActionParam8, dcxMACSpMgtActionParam1=dcxMACSpMgtActionParam1, dcxMACSpMgtActionParam6=dcxMACSpMgtActionParam6, dcxMACUpChannelRngPreambleGuardSymbols=dcxMACUpChannelRngPreambleGuardSymbols, dcxMACSpMgtTriggerParam7=dcxMACSpMgtTriggerParam7, dcxMACSpectralMgtTriggerTable=dcxMACSpectralMgtTriggerTable, dcxMACUpstreamGroupEntry=dcxMACUpstreamGroupEntry, dcxMACUpChannelPeriodicPollInterval=dcxMACUpChannelPeriodicPollInterval, dcxMACSpMgtTriggerStatus=dcxMACSpMgtTriggerStatus, cmtsC3MACMIB=cmtsC3MACMIB, dcxMACDownstreamChannelTable=dcxMACDownstreamChannelTable, dcxMACSpMgtActionParam3=dcxMACSpMgtActionParam3, dcxMACSpMgtTriggerParam3=dcxMACSpMgtTriggerParam3, dcxMACUpChannelExtendedFrequencyErrorDetect=dcxMACUpChannelExtendedFrequencyErrorDetect, dcxMACSpMgtActionParam2=dcxMACSpMgtActionParam2, dcxMACSharedSecretId=dcxMACSharedSecretId, dcxMACUpstreamGroupId=dcxMACUpstreamGroupId, dcxMACSharedSecretTable=dcxMACSharedSecretTable, dcxMACSpMgtTriggerParam5=dcxMACSpMgtTriggerParam5, dcxMACSpMgtTriggerAction=dcxMACSpMgtTriggerAction, dcxMACCmOfflineAgingTime=dcxMACCmOfflineAgingTime, dcxMACSpMgtTriggerParam6=dcxMACSpMgtTriggerParam6)
