#
# PySNMP MIB module ATM-SOFT-PVC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/atmforum/ATM-SOFT-PVC-MIB
# Produced by pysmi-1.1.12 at Wed May 29 10:17:40 2024
# On host fv-az1984-402 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
atmVplVpi, atmVclVpi, atmVclVci = mibBuilder.importSymbols("ATM-MIB", "atmVplVpi", "atmVclVpi", "atmVclVci")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
enterprises, Bits, ModuleIdentity, ObjectIdentity, Integer32, NotificationType, iso, MibIdentifier, Counter64, TimeTicks, IpAddress, Unsigned32, Gauge32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "Bits", "ModuleIdentity", "ObjectIdentity", "Integer32", "NotificationType", "iso", "MibIdentifier", "Counter64", "TimeTicks", "IpAddress", "Unsigned32", "Gauge32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TruthValue, TextualConvention, TimeStamp, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "TimeStamp", "RowStatus", "DisplayString")
atmSoftPvcMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 353, 5, 5, 1))
atmSoftPvcMIB.setRevisions(('1997-03-01 00:00', '1996-06-21 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: atmSoftPvcMIB.setRevisionsDescriptions(('Updated version of the Soft PVC MIB released with the\n                PNNI V1.0 Errata and PICS (af-pnni-81.00).', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: atmSoftPvcMIB.setLastUpdated('9703010000Z')
if mibBuilder.loadTexts: atmSoftPvcMIB.setOrganization('The ATM Forum.')
if mibBuilder.loadTexts: atmSoftPvcMIB.setContactInfo('The ATM Forum\n\t\t2570 West El Camino Real, Suite 304\n\t\tMountain View, CA 94040-1313 USA\n\t\tPhone:\t+1 415-949-6700\n\t\tFax:\t\t+1 415-949-6705\n\t\tinfo@atmforum.com')
if mibBuilder.loadTexts: atmSoftPvcMIB.setDescription('ATM Soft PVC MIB')
atmForum = MibIdentifier((1, 3, 6, 1, 4, 1, 353))
atmForumNetworkManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5))
atmfSoftPvc = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5))
atmSoftPvcMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1))
atmSoftPvcMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2))
class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity.\n\t\tThe address types are: no address (0 octets),\n\t\tE.164 (8 octets)and NSAP (20 octets).\n\t\tNote: The E.164 address is encoded in BCD format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(20, 20), )
atmSoftPvcBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1))
atmSoftPvcCallFailuresTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrapEnable.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrapEnable.setDescription("Allows the generation of traps in response to call\n\t\tfailures. By default, this object is set to 'false'.")
atmSoftPvcCallFailures = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCallFailures.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcCallFailures.setDescription('The number of times a series of call attempts has failed to\n\t\testablish a Soft PVCC or Soft PVPC. The number of call\n\t\tattempts in a series is determined by\n\t\tatmSoftPVccRetryThreshold or atmSoftPVpcRetryThreshold,\n\t\trespectively.')
atmSoftPvcCurrentlyFailingSoftPVccs = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVccs.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVccs.setDescription("The current number of Soft PVCCs for which there is\n\t\tan active row in the atmSoftPVccTable having an\n\t\tatmSoftPVccOperStatus with a value other than 'connected'.")
atmSoftPvcCurrentlyFailingSoftPVpcs = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVpcs.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcCurrentlyFailingSoftPVpcs.setDescription("The current number of Soft PVPCs for which there is an\n\t\tactive row in the atmSoftPVpcTable having an \n\t\tatmSoftPVpcOperStatus with a value other than 'connected'.")
atmSoftPvcNotificationInterval = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmSoftPvcNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcNotificationInterval.setDescription('The minimum interval between the sending\n\t\tof atmSoftPvcCallFailuresTrap notifications.')
atmSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2), )
if mibBuilder.loadTexts: atmSoftPVccTable.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccTable.setDescription('The (conceptual) table used to manage Soft\n\t\tPermanent Virtual Channel Connections (Soft PVCCs).\n\t\tThe Soft PVCC table is applicable only to switches.')
atmSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVccLeafReference"))
if mibBuilder.loadTexts: atmSoftPVccEntry.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccEntry.setDescription('Each entry in this table represents a  Soft\n\t\tPermanent Virtual Channel Connection (Soft PVCC)\n\t\toriginating at a switch interface.\n\n\t\tA Soft PVCC is a VCC that is:\n\t\t  - provisioned at the originating (source)\n\t\t\tinterface of the connection\n\t\t  - established by signalling procedures\n\t\t\tacross a network to a destination interface.\n\n\t\tA row in the atmVclTable must be created,\n\t\tdefining a VCL on the source interface, prior to\n\t\tcreating an atmSoftPVccEntry row. The row in the\n\t\tatmVclTable must be active prior to activating the\n\t\tatmSoftPVccEntry row.\n\n\t\tThe contents of this table reflect only the\n\t\tcharacteristics unique to a Soft PVCC. The traffic\n\t\tparameters are defined in the VCL row for the source\n\t\tinterface, as specified in the ATOMMIB (RFC1695) and \n\t\tthe forthcoming addition, the Supplemental ATOMMIB.\n\n\t\tNote that the atmSigDescrParamTable contains some objects\n\t\tsuch as the AAL parameters, Broadband high layer\n\t\tinformation and Broadband low layer information\n\t\telements which are used to carry end-to-end information.\n\t\tFor this reason, these objects are not relevant to Soft\n\t\tPVCCs.\n\n\t\tWhen a row is made active, an attempt is made\n\t\tto set up a switched connection to an interface at\n\t\tthe destination switch. No objects (other than\n\t\tatmSoftPVccRowStatus) can be set while the row is \n\t\tactive.\n\n\t\tAt the destination, the VCL may be defined (but \n\t\tnot cross-connected) prior to arrival of the Setup \n\t\trequest.\n\n\t\tThe combination of ifIndex, atmVclVpi, and atmVclVci\n\t\tspecified in the index clause of this entry serves to\n\t\tidentify the VCL on the source interface. The\n\t\tatmSoftPVccLeafReference object aids in distinguishing\n\t\tbetween leaves of a point-to-multipoint Soft PVCC.')
atmSoftPVccLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmSoftPVccLeafReference.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccLeafReference.setDescription("An arbitrary integer which, in the case of the\n\t\tsource VCL having an atmVclCastType of\n\t\t'p2mpRoot', serves to distinguish between the \n\t\tmultiple leaves attached to a root of a \n\t\tpoint-to-multipoint Soft PVCC. If the atmVclCastType \n\t\tis not 'p2mpRoot' the value 1 shall be used.")
atmSoftPVccTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 2), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccTargetAddress.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccTargetAddress.setDescription('The target ATM Address of this Soft PVCC.  If no\n                address is supplied, no attempts to establish the\n                Soft PVCC are initiated.')
atmSoftPVccTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccTargetSelectType.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccTargetSelectType.setDescription("Indicates whether the target VPI/VCI values\n\t\tare to be used at the destination.\n\n\t\tIf the value 'any' is specified, the destination\n\t\tswitch will choose the VPI/VCI values. In such a\n\t\tcase, once the Soft PVCC atmSoftPVccOperStatus\n\t\tvalue is 'connected', the value of this object\n\t\tchanges to 'required', such that the same VPI/VCI\n\t\tvalues will continue to be used even if the connection\n\t\tis subsequently torn down and re-established. The\n\t\tVPI/VCI values chosen will be available for reading in \n\t\tatmSoftPVccTargetVpi and atmSoftPVccTargetVci.\n\n\t\tIf the value 'required' is specified, then values\n\t\tmust be supplied for objects atmSoftPVccTargetVpi\n\t\tand atmSoftPVccTargetVci prior to activation of the\n\t\trow. These values are then to be used at the destination.")
atmSoftPVccTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccTargetVpi.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccTargetVpi.setDescription("The VPI value of the VCL used at the target interface.\n\t\tThis value is not relevant when the value of \n\t\tatmSoftPVccTargetSelectType is 'any'.")
atmSoftPVccTargetVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccTargetVci.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccTargetVci.setDescription("The VCI value of the VCL used at the target interface.\n\t\tThis value must be filled in when the\n\t\tatmSoftPVccTargetSelectType is set to 'required'.This \n\t\tvalue is not relevant when the value of \n\t\tatmSoftPVccTargetSelectType is 'any'.")
atmSoftPVccLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccLastReleaseCause.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccLastReleaseCause.setDescription('Value of the Cause field of the Cause\n\t\tInformation Element in the last RELEASE\n\t\tsignalling message received for this Soft PVCC.\n\t\tIndicates the reason for the Release.')
atmSoftPVccLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccLastReleaseDiagnostic.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information\n\t\tfrom the Cause field of the Cause Information Element\n\t\tin the last RELEASE signalling message received for\n\t\tthis Soft PVCC.')
atmSoftPVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4), ("noAddressSupplied", 5), ("lowerLayerDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccOperStatus.setDescription("Describes the status of the Soft PVCC.  Valid values\n                are:\n                   other              - none of the types specified below\n                   establishmentInProgress - connection or party is not\n                                             operational, but setup or add\n                                             party attempts are ongoing\n                   connected          - connection or party is currently\n                                        operational\n                   retriesExhausted   - retry limit has been reached and\n                                        setup or add party attempts have\n                                        ceased\n                   noAddressSupplied  - no remote address has been\n                                        configured, so no setup or add\n                                        party attempts are initiated\n                   lowerLayerDown     - underlying ATM interface is not\n                                        operational\n                When the row is not 'active', the value of this\n\t\tobject is 'other'.")
atmSoftPVccRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccRestart.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRestart.setDescription("When the value is set to 'restart' the Soft PVCC\n\t\tis released if necessary and a new setup procedure\n\t\tis begun. As a result of this action, the\n\t\tatmSoftPVccOperStatus object transitions to\n\t\t'establishmentInProgress' (if not already in this state)\n\t\tand the atmSoftPVccRetryFailures object is cleared\n\n\t\tWhen the value is set to 'noop' no operation is\n\t\tperformed. When read, the value 'noop' is returned.")
atmSoftPVccRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccRetryInterval.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRetryInterval.setDescription('Defines the period to wait before attempting\n\t\tto establish the Soft PVCC after the first failed call\n\t\tattempt.  The time to wait between subsequent call\n                attempts may differ to implement a backoff scheme.\n                Zero represents an infinite interval indicating no\n\t\tretries.')
atmSoftPVccRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccRetryTimer.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRetryTimer.setDescription('Indicates the current value of the retry timer for\n\t\tthis connection. When the value reaches zero an attempt\n\t\twill be made to establish the Soft PVCC. When the timer\n\t\tis not running, the value zero shall be returned.')
atmSoftPVccRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for\n\t\tthe same Soft PVCC which need to fail before the\n\t\tatmSoftPvcCallFailures object is incremented. A value of\n\t\tzero indicates that an infinite number of call attempts\n\t\tare required to increment the atmSoftPvcCallFailures object\n\t\tand thus disables alarms for the Soft PVCC.')
atmSoftPVccRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVccRetryFailures.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRetryFailures.setDescription('Indicates how many attempts to establish the connection\n\t\thave failed.  This count is reset whenever a connection\n\t\tis successfully established or the Soft PVCC is restarted.')
atmSoftPVccRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccRetryLimit.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful\n\t\tcall setup attempts can be made before stopping the attempt\n\t\tto set up the connection. If this limit is reached then\n\t\tmanagement action will be required (e.g. setting \n\t\tatmSoftPVccRestart to 'restart') to initiate a new attempt\n\t\tto establish the connection. A value of zero indicates\n\t\tno limit - the attempts will continue until successful.")
atmSoftPVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVccRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVccRowStatus.setDescription("Used to create and delete a Soft PVCC. When this\n\t\tobject is set to 'active' an attempt is made to\n\t\tset up the Soft PVCC. When this object has the value\n\t\t'active' and is set to another value, any\n\t\tset-up or connection in-progress is released.")
atmSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3), )
if mibBuilder.loadTexts: atmSoftPVpcTable.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcTable.setDescription('The (conceptual) table used to manage Soft\n\t\tPermanent Virtual Path Connections (Soft PVPCs)\n\t\tThe Soft PVPC table is applicable only to switches.')
atmSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVplVpi"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVpcLeafReference"))
if mibBuilder.loadTexts: atmSoftPVpcEntry.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcEntry.setDescription('Each entry in this table represents a  Soft\n\t\tPermanent Virtual Path Connection (Soft PVPC)\n\t\toriginating at a switch interface.\n\n\t\tA Soft PVPC is a VPC that is:\n\t\t  - provisioned at the originating (source)\n\t\t\tinterface of the connection\n\t\t  - established by signalling procedures\n\t\t\tacross a network to a destination interface.\n\n\t\tA row in the atmVplTable must be created,\n\t\tdefining a VPL on the source interface, prior to\n\t\tcreating an atmSoftPVpcEntry row. The row in the\n\t\tatmVplTable must be active prior to activating the\n\t\tatmSoftPVpcEntry row.\n\n\t\tThe contents of this table reflect only the\n\t\tcharacteristics unique to a Soft PVPC. The traffic\n\t\tparameters are defined in the VPL row for the source\n\t\tinterface, as specified in the ATOMMIB (RFC1695) and\n\t\tthe forthcoming addition, the Supplemental ATOMMIB.\n\n\t\tNote that the atmSigDescrParamTable contains some\n\t\tobjects such as the AAL parameters, Broadband high\n\t\tlayer information, and Broadband low layer information\n\t\telements which are used to carry end-to-end information.\n\t\tFor this reason, these objects are not relevant to Soft\n\t\tPVPCs.\n\n\t\tWhen a row is made active, an attempt is made\n\t\tto set up a switched connection to an interface at\n\t\tthe destination switch. No objects (other than\n\t\tatmSoftPVpcRowStatus) can be set while the row is\n\t\tactive.\n\n\t\tAt the destination, the VPL may be defined (but\n\t\tnot cross-connected) prior to arrival of the Setup\n\t\trequest.\n\n\t\tThe combination of ifIndex, atmVplVpi specified\n\t\tin the index clause of this entry serves to\n\t\tidentify the VPL on the source interface. The\n\t\tatmSoftPVpcLeafReference object aids in distinguishing\n\t\tbetween leaves of a point-to-multipoint Soft PVPC.')
atmSoftPVpcLeafReference = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63535)))
if mibBuilder.loadTexts: atmSoftPVpcLeafReference.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcLeafReference.setDescription("An arbitrary integer which, in the case of the\n\t\tsource VPL having a atmVplCastType of\n\t\t'p2mpRoot', serves to distinguish between the\n\t\tmultiple leaves attached to a root of a\n\t\tpoint-to-multipoint Soft PVPC.\n\n\t\tIf the atmVplCastType is not 'p2mpRoot', the\n\t\tvalue 1 shall be used.")
atmSoftPVpcTargetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 2), AtmAddr()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcTargetAddress.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcTargetAddress.setDescription('The target ATM Address of this Soft PVPC.  If no\n                address is supplied, no attempts to establish the\n                Soft PVPC are initiated.')
atmSoftPVpcTargetSelectType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("required", 1), ("any", 2))).clone('required')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcTargetSelectType.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcTargetSelectType.setDescription("Indicates whether the target VPI value\n\t\tis to be used at the destination.\n\t\tIf the value 'any' is specified, the\n\t\tdestination switch will choose the VPI\n\t\tvalue. In such a case, once the Soft PVPC\n\t\tatmSoftPVpcOperStatus value is 'connected',\n\t\tthe value of this object changes to 'required',\n\t\tsuch that the same VPI value will continue to\n\t\tbe used even if the connection is subsequently\n\t\ttorn down and re-established. The VPI value\n\t\tchosen will be available for reading in\n\t\tatmSoftPVpcTargetVpi.\n\n\t\tIf the value 'required' is specified, then\n\t\ta value must be supplied for object\n\t\tatmSoftPVpcTargetVpi prior to activation\n\t\tof the row. This value is then to be used\n\t\tat the destination.")
atmSoftPVpcTargetVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcTargetVpi.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcTargetVpi.setDescription("The VPI value of the VPL used at the\n\t\ttarget interface.\n\n\t\tThis value must be filled in when the\n\t\tatmSoftPVpcTargetSelectType is set to 'required'.\n\t\tThis value is not relevant when the value of\n\t\tatmSoftPVpcTargetSelectType is 'any'.")
atmSoftPVpcLastReleaseCause = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseCause.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseCause.setDescription('Value of the Cause field of the Cause\n\t\tInformation Element in the last RELEASE\n\t\tsignalling message received for this Soft PVPC.\n\t\tIndicates the reason for the Release.')
atmSoftPVpcLastReleaseDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseDiagnostic.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcLastReleaseDiagnostic.setDescription('Value of the first 8 bytes of diagnostic information\n\t\tfrom the Cause field of the Cause Information Element\n\t\tin the last RELEASE signalling message received for\n\t\tthis Soft PVPC.')
atmSoftPVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("establishmentInProgress", 2), ("connected", 3), ("retriesExhausted", 4), ("noAddressSupplied", 5), ("lowerLayerDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcOperStatus.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcOperStatus.setDescription("Describes the status of the Soft PVPC. \n                   other              - none of the types specified below\n                   establishmentInProgress - connection or party is not\n                                             operational, but setup or add\n                                             party attempts are ongoing\n                   connected          - connection or party is currently\n                                        operational\n                   retriesExhausted   - retry limit has been reached and\n                                        setup or add party attempts have\n                                        ceased\n                   noAddressSupplied  - no remote address has been\n                                        configured, so no setup or add\n                                        party attempts are initiated\n                   lowerLayerDown     - underlying ATM interface is not\n                                        operational\n                When the row is not 'active', the value of this\n\t\tobject is 'other'.")
atmSoftPVpcRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restart", 1), ("noop", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcRestart.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRestart.setDescription("When the value is set to 'restart', the Soft PVPC is\n\t\treleased if necessary and a new setup procedure is begun.\n\t\tAs a result of this action, the atmSoftPVpcOperStatus\n\t\tobject transitions to 'establishmentInProgress' (if not\n\t\talready in this state) and the atmSoftPVpcRetryFailures\n\t\tobject is cleared.\n\n\t\tWhen the value is set to 'noop', no operation is performed.\n\t\tWhen read, the value 'noop' is returned.")
atmSoftPVpcRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcRetryInterval.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRetryInterval.setDescription('Defines the period to wait before attempting\n\t\tto establish the Soft PVPC after the first failed \n                call attempt.  The time to wait between subsequent\n                call attempts may differ to implement a backoff scheme.\n                Zero represents an infinite interval indicating no \n                retries.')
atmSoftPVpcRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcRetryTimer.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRetryTimer.setDescription('Indicates the current value of the retry timer for\n\t\tthis connection. When the value reaches zero an attempt\n\t\twill be made to establish the Soft PVPC. When the\n\t\ttimer is not running, the value zero shall be returned.')
atmSoftPVpcRetryThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcRetryThreshold.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRetryThreshold.setDescription('Indicates the number of consecutive call setup attempts for\n\t\tthe same Soft PVPC which need to fail before the\n\t\tatmSoftPvcCallFailures object is incremented. A value of\n\t\tzero indicates that an infinite number of call attempts\n\t\tare required to increment the atmSoftPvcCallFailures object\n\t\tand thus disables alarms for the Soft PVPC.')
atmSoftPVpcRetryFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmSoftPVpcRetryFailures.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRetryFailures.setDescription('Indicates how many attempts to establish the connection\n\t\thave failed.  This count is reset whenever a connection\n\t\tis successfully established or the Soft PVPC is restarted.')
atmSoftPVpcRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcRetryLimit.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRetryLimit.setDescription("Sets a maximum limit on how many consecutive unsuccessful\n\t\tcall setup attempts can be made before stopping the attempt\n\t\tto set up the connection. If this limit is reached then\n\t\tmanagement action will be required (e.g. setting\n\t\tatmSoftPVpcRestart to 'restart') to initiate a new attempt\n\t\tto establish the connection. A value of zero indicates no\n\t\tlimit - the attempts will continue until successful.")
atmSoftPVpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 3, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmSoftPVpcRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmSoftPVpcRowStatus.setDescription("Used to create and delete a Soft PVPC. When this\n\t\tobject is set to 'active' an attempt is made to\n\t\tset up the Soft PVPC. When this object has the value\n\t\t'active' and is set to another value, any\n\t\tset-up or connection in-progress is released.")
atmInterfaceSoftPvcAddressTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4), )
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressTable.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressTable.setDescription('This table is used to configure ATM addresses at \n\t\tan ATM interface on this node prior to setting up\n\t\tSoft PVPCs or Soft PVPCs at that interface.')
atmInterfaceSoftPvcAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-SOFT-PVC-MIB", "atmInterfaceSoftPvcAddress"))
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressEntry.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressEntry.setDescription('ATM address entry for configuring Soft PVCCs or\n\t\tSoft PVPCs at an ATM interface.')
atmInterfaceSoftPvcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddress.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddress.setDescription('Specifies the address that can be used to establish a Soft\n\t\tPVCC or Soft PVPC to this interface.')
atmInterfaceSoftPvcAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: atmInterfaceSoftPvcAddressRowStatus.setDescription('Used to create and delete an ATM address at this interface\n\t\tfor setting up Soft PVCCs or Soft PVPCs.')
atmCurrentlyFailingSoftPVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5), )
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTable.setDescription("A table indicating all Soft Permanent Virtual Channel\n\t\tConnections (Soft PVCCs) for which the atmSoftPVccRowStatus\n\t\tis 'active' and the atmSoftPVccOperStatus is other than\n\t\t'connected'.")
atmCurrentlyFailingSoftPVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVccLeafReference"))
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccEntry.setDescription("Each entry in this table represents a Soft Permanent\n\t\tVirtual Channel Connection (Soft PVCC) for which the\n\t\tatmSoftPVccRowStatus is 'active' and the \n\t\tatmSoftPVccOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVccTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 5, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccTimeStamp.setDescription('The time at which this Soft PVCC began to fail.')
atmCurrentlyFailingSoftPVpcTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6), )
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTable.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTable.setDescription("A table indicating all Soft Permanent Virtual Path\n\t\tConnections (Soft PVPCs) for which the atmSoftPVpcRowStatus\n\t\tis 'active' and the atmSoftPVpcOperStatus is other than\n\t\t'connected'.")
atmCurrentlyFailingSoftPVpcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-SOFT-PVC-MIB", "atmSoftPVpcLeafReference"))
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcEntry.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcEntry.setDescription("Each entry in this table represents a Soft Permanent\n\t\tVirtual Path Connection (Soft PVPC) for which the\n\t\tatmSoftPVpcRowStatus is 'active' and the \n\t\tatmSoftPVpcOperStatus is other than 'connected'.")
atmCurrentlyFailingSoftPVpcTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 1, 6, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTimeStamp.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcTimeStamp.setDescription('The time at which this Soft PVPC began to fail.')
atmSoftPvcTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1))
atmSoftPvcTrapsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1, 0))
atmSoftPvcCallFailuresTrap = NotificationType((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 2, 1, 0, 1)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPvcCallFailures"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVccs"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVpcs"))
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrap.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcCallFailuresTrap.setDescription('A notification indicating that one or more series of\n\t\tcall attempts in trying to establish a Soft PVPC or\n\t\tSoft PVCC have failed since the last\n\t\tatmSoftPvcCallFailureTrap was sent. If this trap has\n\t\tnot been sent for the last atmSoftPvcNotificationInterval,\n\t\tthen it will be sent on the next increment of\n\t\tatmSoftPvcCallFailures.')
atmSoftPvcMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3))
atmSoftPvcMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 1))
atmSoftPvcMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2))
atmSoftPvcMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 1, 1)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPvcBaseMIBGroup"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcVccMIBGroup"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcAddressMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSoftPvcMIBCompliance = atmSoftPvcMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcMIBCompliance.setDescription('The compliance statement for the ATM Soft PVC group.')
atmSoftPvcBaseMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 1)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPvcCallFailuresTrapEnable"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCallFailures"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVccs"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcCurrentlyFailingSoftPVpcs"), ("ATM-SOFT-PVC-MIB", "atmSoftPvcNotificationInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSoftPvcBaseMIBGroup = atmSoftPvcBaseMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcBaseMIBGroup.setDescription('A collection of objects to related to failing\n\t\tSoft PVCCs and Soft PVPCs.')
atmSoftPvcVccMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 2)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPVccTargetAddress"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccTargetSelectType"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccTargetVpi"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccTargetVci"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccLastReleaseCause"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccLastReleaseDiagnostic"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccOperStatus"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRestart"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRetryInterval"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRetryTimer"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRetryThreshold"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRetryFailures"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRetryLimit"), ("ATM-SOFT-PVC-MIB", "atmSoftPVccRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSoftPvcVccMIBGroup = atmSoftPvcVccMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcVccMIBGroup.setDescription('A collection of objects managing Soft PVCCs.')
atmSoftPvcVpcMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 3)).setObjects(("ATM-SOFT-PVC-MIB", "atmSoftPVpcTargetAddress"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcTargetSelectType"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcTargetVpi"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcLastReleaseCause"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcLastReleaseDiagnostic"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcOperStatus"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRestart"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRetryInterval"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRetryTimer"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRetryThreshold"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRetryFailures"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRetryLimit"), ("ATM-SOFT-PVC-MIB", "atmSoftPVpcRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSoftPvcVpcMIBGroup = atmSoftPvcVpcMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcVpcMIBGroup.setDescription('A collection of objects managing Soft PVPCs.')
atmSoftPvcAddressMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 4)).setObjects(("ATM-SOFT-PVC-MIB", "atmInterfaceSoftPvcAddressRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmSoftPvcAddressMIBGroup = atmSoftPvcAddressMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmSoftPvcAddressMIBGroup.setDescription('A collection of objects managing interfaces addresses for\n\t\tSoft PVCCs and Soft PVPCs.')
atmCurrentlyFailingSoftPVccMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 5)).setObjects(("ATM-SOFT-PVC-MIB", "atmCurrentlyFailingSoftPVccTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCurrentlyFailingSoftPVccMIBGroup = atmCurrentlyFailingSoftPVccMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVccMIBGroup.setDescription('A collection of objects for management of currently\n\t\tfailing Soft PVCCs.')
atmCurrentlyFailingSoftPVpcMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 353, 5, 5, 1, 3, 2, 6)).setObjects(("ATM-SOFT-PVC-MIB", "atmCurrentlyFailingSoftPVpcTimeStamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmCurrentlyFailingSoftPVpcMIBGroup = atmCurrentlyFailingSoftPVpcMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmCurrentlyFailingSoftPVpcMIBGroup.setDescription('A collection of objects for management of currently\n\t\tfailing Soft PVPCs.')
mibBuilder.exportSymbols("ATM-SOFT-PVC-MIB", atmSoftPVpcLastReleaseDiagnostic=atmSoftPVpcLastReleaseDiagnostic, atmSoftPvcBaseMIBGroup=atmSoftPvcBaseMIBGroup, PYSNMP_MODULE_ID=atmSoftPvcMIB, atmSoftPvcAddressMIBGroup=atmSoftPvcAddressMIBGroup, atmSoftPvcMIBCompliance=atmSoftPvcMIBCompliance, atmCurrentlyFailingSoftPVccTable=atmCurrentlyFailingSoftPVccTable, atmSoftPvcMIB=atmSoftPvcMIB, atmSoftPVccLastReleaseDiagnostic=atmSoftPVccLastReleaseDiagnostic, atmSoftPVpcTargetSelectType=atmSoftPVpcTargetSelectType, atmSoftPvcTraps=atmSoftPvcTraps, atmSoftPVccRetryFailures=atmSoftPVccRetryFailures, atmSoftPVpcLastReleaseCause=atmSoftPVpcLastReleaseCause, atmSoftPVccRetryThreshold=atmSoftPVccRetryThreshold, atmSoftPVpcRestart=atmSoftPVpcRestart, atmSoftPvcMIBObjects=atmSoftPvcMIBObjects, atmSoftPVccEntry=atmSoftPVccEntry, atmSoftPVccTargetSelectType=atmSoftPVccTargetSelectType, atmSoftPvcTrapsPrefix=atmSoftPvcTrapsPrefix, atmSoftPVccRetryLimit=atmSoftPVccRetryLimit, atmSoftPVpcOperStatus=atmSoftPVpcOperStatus, atmSoftPVpcRowStatus=atmSoftPVpcRowStatus, atmInterfaceSoftPvcAddressEntry=atmInterfaceSoftPvcAddressEntry, atmSoftPVpcTargetVpi=atmSoftPVpcTargetVpi, atmSoftPvcCurrentlyFailingSoftPVccs=atmSoftPvcCurrentlyFailingSoftPVccs, atmSoftPVccLastReleaseCause=atmSoftPVccLastReleaseCause, atmCurrentlyFailingSoftPVpcTable=atmCurrentlyFailingSoftPVpcTable, atmSoftPVccRestart=atmSoftPVccRestart, atmSoftPvcNotificationInterval=atmSoftPvcNotificationInterval, atmSoftPvcCallFailuresTrap=atmSoftPvcCallFailuresTrap, AtmAddr=AtmAddr, atmCurrentlyFailingSoftPVccMIBGroup=atmCurrentlyFailingSoftPVccMIBGroup, atmSoftPVccRetryInterval=atmSoftPVccRetryInterval, atmSoftPvcCallFailures=atmSoftPvcCallFailures, atmSoftPvcMIBConformance=atmSoftPvcMIBConformance, atmSoftPVccTable=atmSoftPVccTable, atmSoftPvcMIBGroups=atmSoftPvcMIBGroups, atmCurrentlyFailingSoftPVpcMIBGroup=atmCurrentlyFailingSoftPVpcMIBGroup, atmSoftPvcCurrentlyFailingSoftPVpcs=atmSoftPvcCurrentlyFailingSoftPVpcs, atmSoftPvcVpcMIBGroup=atmSoftPvcVpcMIBGroup, atmSoftPVpcLeafReference=atmSoftPVpcLeafReference, atmSoftPvcMIBCompliances=atmSoftPvcMIBCompliances, atmSoftPVccTargetVpi=atmSoftPVccTargetVpi, atmSoftPVccTargetVci=atmSoftPVccTargetVci, atmSoftPVccLeafReference=atmSoftPVccLeafReference, atmSoftPVpcRetryTimer=atmSoftPVpcRetryTimer, atmInterfaceSoftPvcAddressTable=atmInterfaceSoftPvcAddressTable, atmForum=atmForum, atmInterfaceSoftPvcAddress=atmInterfaceSoftPvcAddress, atmfSoftPvc=atmfSoftPvc, atmSoftPVccRetryTimer=atmSoftPVccRetryTimer, atmSoftPVpcTable=atmSoftPVpcTable, atmSoftPVpcEntry=atmSoftPVpcEntry, atmCurrentlyFailingSoftPVpcTimeStamp=atmCurrentlyFailingSoftPVpcTimeStamp, atmSoftPvcCallFailuresTrapEnable=atmSoftPvcCallFailuresTrapEnable, atmSoftPVccOperStatus=atmSoftPVccOperStatus, atmSoftPVpcRetryThreshold=atmSoftPVpcRetryThreshold, atmForumNetworkManagement=atmForumNetworkManagement, atmSoftPVpcTargetAddress=atmSoftPVpcTargetAddress, atmSoftPVpcRetryInterval=atmSoftPVpcRetryInterval, atmCurrentlyFailingSoftPVccTimeStamp=atmCurrentlyFailingSoftPVccTimeStamp, atmSoftPvcVccMIBGroup=atmSoftPvcVccMIBGroup, atmSoftPvcBaseGroup=atmSoftPvcBaseGroup, atmSoftPVccTargetAddress=atmSoftPVccTargetAddress, atmSoftPVccRowStatus=atmSoftPVccRowStatus, atmSoftPVpcRetryFailures=atmSoftPVpcRetryFailures, atmSoftPVpcRetryLimit=atmSoftPVpcRetryLimit, atmInterfaceSoftPvcAddressRowStatus=atmInterfaceSoftPvcAddressRowStatus, atmCurrentlyFailingSoftPVccEntry=atmCurrentlyFailingSoftPVccEntry, atmCurrentlyFailingSoftPVpcEntry=atmCurrentlyFailingSoftPVpcEntry, atmSoftPvcMIBTraps=atmSoftPvcMIBTraps)
