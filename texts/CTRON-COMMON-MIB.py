#
# PySNMP MIB module CTRON-COMMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-COMMON-MIB
# Produced by pysmi-1.1.8 at Fri Sep  8 11:07:14 2023
# On host fv-az590-991 platform Linux version 5.15.0-1041-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
dl, ups, subSysDevice, subSysMMAC, commonRev1 = mibBuilder.importSymbols("IRM-OIDS", "dl", "ups", "subSysDevice", "subSysMMAC", "commonRev1")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, iso, IpAddress, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Gauge32, Bits, Unsigned32, TimeTicks, Integer32, NotificationType, ModuleIdentity, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "iso", "IpAddress", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Gauge32", "Bits", "Unsigned32", "TimeTicks", "Integer32", "NotificationType", "ModuleIdentity", "MibIdentifier")
PhysAddress, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "TextualConvention", "DisplayString")
fnb2 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3))
environment = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4))
fnbTR = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1))
fnbCSMACD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2))
fnbPortConnect = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3))
nB55 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 3))
mRXI = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 6))
iRM3 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7))
tRMM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 8))
eMME = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 9))
fPRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10))
upsVersion = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1))
upsRevision = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1))
deviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 176, 177, 178, 179, 180, 185, 187, 190, 65569, 65570, 65571, 65572))).clone(namedValues=NamedValues(("other", 1), ("iRM2", 176), ("iRBM", 177), ("iRM3", 178), ("tRMBM-R", 179), ("tRMBM-S", 180), ("emm-E", 185), ("tRMM", 187), ("trmMim", 190), ("mrxi24", 65569), ("mrxi22", 65570), ("mrxi34", 65571), ("mrxi38", 65572)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceType.setDescription('The type of management board.')
deviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceName.setStatus('mandatory')
if mibBuilder.loadTexts: deviceName.setDescription('A textual description on the entity managed by the\n                    resident agent.  It is mandatory that this only con-\n                    tain printable ASCII characters.')
deviceIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceIPAddress.setDescription('The Network address, in this case the IP address,\n                    of the device.  This object is required for use by\n                    the Local Management Interface.')
deviceTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceTime.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTime.setDescription('The current time of day, in 24 hour format, as\n                    measured by the device.  The representation shall\n                    use the standard HHMMSS format.')
deviceDate = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceDate.setStatus('mandatory')
if mibBuilder.loadTexts: deviceDate.setDescription('The current date, as measured by the device.  The\n                    representation shall use the standard MMDDYYYY \n                    format.')
fnbTRTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1), )
if mibBuilder.loadTexts: fnbTRTable.setStatus('mandatory')
if mibBuilder.loadTexts: fnbTRTable.setDescription('A list of entries that provide connection status of\n                    Token Ring subsystems, for the FNB.')
fnbTREntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1), ).setIndexNames((0, "CTRON-COMMON-MIB", "fnbTRIndex"))
if mibBuilder.loadTexts: fnbTREntry.setStatus('mandatory')
if mibBuilder.loadTexts: fnbTREntry.setDescription('An entry in the fnbTRTable containing objects that\n                    provide FNB connection status for a Token Ring sub-\n                    system.')
fnbTRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbTRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fnbTRIndex.setDescription("An unique value for each Token Ring subsystem.  Its\n                    value ranges between 1 and chassisSlots.  The value\n                    for each interface must remain constant, at least,\n                    from one re-initialization of the entity's network\n                    management system to the next re-initialization.")
fnbConnectLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("detached", 1), ("attached", 2), ("faulted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectLeft.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectLeft.setDescription('The Connected Left board (board n + 1) has the following\n                     states:\n\n                     Detached == 1  (Management (only management) detached,\n                                     read/write).\n                     Attached == 2  (Management/AutoMode  attached, read/write).\n                     Faulted  == 3  (Management/AutoMode tried to attach but\n                                     failed READ ONLY).')
fnbConnectRight = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("detached", 1), ("attached", 2), ("faulted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectRight.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectRight.setDescription('The Connected Right board (board n - 1) has the following states:\n\n             Detached == 1  (Management (only management) detached, read/write).\n             Attached == 2  (Management/AutoMode attached, read/write ).\n             Faulted  == 3  (Management/AutoMode tried to attach but failed,\n                             READ ONLY).')
fnbBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbBypass.setStatus('mandatory')
if mibBuilder.loadTexts: fnbBypass.setDescription('Denotes the bypass status of the current Token Ring\n                    board.  Bypassed means the board is NOT attached to the\n                    FNB.')
fnbRPBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("disabled", 2), ("enabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbRPBypass.setStatus('mandatory')
if mibBuilder.loadTexts: fnbRPBypass.setDescription("Denotes the Ring Port bypass status of the current Token Ring\n            board.  If this capability is not available on this board, the\n            value 'other' is returned when read, and BADSETINFO when written.")
fnbCSMACDTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2, 1), )
if mibBuilder.loadTexts: fnbCSMACDTable.setStatus('mandatory')
if mibBuilder.loadTexts: fnbCSMACDTable.setDescription('A list of entries that provide connection status of\n                    CSMA/CD subsystems, for the FNB.')
fnbCSMACDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2, 1, 1), ).setIndexNames((0, "CTRON-COMMON-MIB", "fnbCSMACDIndex"))
if mibBuilder.loadTexts: fnbCSMACDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fnbCSMACDEntry.setDescription('An entry in the fnbCSMACDTable containing objects\n                    that provide FNB connection status for a CSMA/CD\n                    subsystem.')
fnbCSMACDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbCSMACDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fnbCSMACDIndex.setDescription("An unique value for each CSMACD subsystem.  Its\n                    value ranges between 1 and chassisSlots.  The value\n                    for each interface must remain constant, at least,\n                    from one re-initialization of the entity's network\n                    management system to the next re-initialization.")
fnbConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("connectB", 1), ("connectC", 2), ("disconnect", 3), ("connectA", 4), ("subnetB", 5), ("subnetC", 6), ("multiChannel", 7), ("frontPanel", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnect.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnect.setDescription('Denotes the connection status of the CSMA/CD board\n                    to the inter-RIC bus.')
fnbPortChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbPortChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortChanges.setDescription("Denotes the number of times any port on the\n                        given MIM has changed it's connection to the\n                        inter-RIC bus.")
fnbPortConnectTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1), )
if mibBuilder.loadTexts: fnbPortConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectTable.setDescription('This table is used to control port\n                        association on ethernet devices.  Only\n                        those boards that support port switching\n                        will be listed in this table.')
fnbPortConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1, 1), ).setIndexNames((0, "CTRON-COMMON-MIB", "fnbPortConnectBoardIndex"), (0, "CTRON-COMMON-MIB", "fnbPortConnectPortIndex"))
if mibBuilder.loadTexts: fnbPortConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectEntry.setDescription('Describes a specific port connection entry.')
fnbPortConnectBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbPortConnectBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectBoardIndex.setDescription('An instance of a board for which this port\n                        assignment relationship exists.')
fnbPortConnectPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbPortConnectPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectPortIndex.setDescription('An instance of a port for which this\n                        assignment relationship exists.')
fnbPortConnectPortAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("connectA", 1), ("connectB", 2), ("connectC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbPortConnectPortAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectPortAssignment.setDescription('The specific channel that the port is\n                        assigned.')
fnbPortConnectCompID = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbPortConnectCompID.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectCompID.setDescription('This is the component ID as defined in the chassis\n                        MIB that this port is associated with.  These\n                        components will be repeater components.')
fnbPortConnectionChanges = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 2, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fnbPortConnectionChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fnbPortConnectionChanges.setDescription("Maintains the number of times any port within\n                        the mangement domain of this MIM changes it's\n                        port assignment.")
chassisHWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: chassisHWRev.setDescription('Define the hardware revision of the device or sys-\n                    tem chassis.')
chassisType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("mMAC8FNB", 2), ("mMAC5FNB", 3), ("mMAC3FNB", 4), ("mINIMMAC", 5), ("mRXI", 6), ("m3FNB", 7), ("m5FNB", 8), ("m8FNB", 9), ("nonFNB", 10), ("mMAC3FNBS", 11), ("mMAC5FNBS", 12), ("mMAC8FNBS", 13), ("m8FNBS", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisType.setStatus('mandatory')
if mibBuilder.loadTexts: chassisType.setDescription('Denotes the type of chassis.')
chassisSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSlots.setDescription('Denotes the number of available chassis slots.')
chassisFNB = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisFNB.setStatus('mandatory')
if mibBuilder.loadTexts: chassisFNB.setDescription('Denotes the presence or absence of the FNB.')
chassisAlarmEna = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisAlarmEna.setStatus('mandatory')
if mibBuilder.loadTexts: chassisAlarmEna.setDescription('Allow an audible alarm to be either enabled or dis-\n                    abled.')
chassisAlarmState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("chassisNoFaultCondition", 1), ("chassisFaultCondition", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: chassisAlarmState.setDescription('Denotes the current condition of the power supply \n                    fault detection circuit.  Setting a value of\n                    chassisNoFaultCondition(1) disables the current \n                    chassis alarm condition, and stops the current \n                    audible alarm from sounding.  Setting a value of \n                    chassisFaultCondition(2) is not allowed.\n\n                    This object will read with the value of \n                    chassisNoFaultCondition(1) when the chassis is \n                    currently operating with no power faults detected.\n\n                    This object will read with the value of \n                    chassisFaultCondition(2) when the chassis is \n                    currently in a power fault condition.')
powerTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1), )
if mibBuilder.loadTexts: powerTable.setStatus('mandatory')
if mibBuilder.loadTexts: powerTable.setDescription('A list of power supply entries.')
powerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1), ).setIndexNames((0, "CTRON-COMMON-MIB", "powerSupplyNum"))
if mibBuilder.loadTexts: powerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: powerEntry.setDescription('An entry in the powerTable providing objects for a\n                    power supply.')
powerSupplyNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyNum.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyNum.setDescription('Denotes the power supply that may have failed.')
powerSupplyState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("infoNotAvailable", 1), ("notInstalled", 2), ("installedAndOperating", 3), ("installedAndNotOperating", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyState.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyState.setDescription("Denotes the power supply's state.")
powerSupplyId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyId.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyId.setDescription('Identifies the type of power supply.  For example, this\n                could be used to identify power supplies which support\n                additional remote management capabilities.')
powerSupplyRedun = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("redundancyAvail", 1), ("redundancyNotAvail", 2), ("infoNotAvailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: powerSupplyRedun.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyRedun.setDescription('Identifies whether power redundancy is available\n                within the chassis.\n\n                Devices that do not support power supply redundancy,\n                will return infoNotAvailable.')
powerSupplyRemoteDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("infoNotAvailable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: powerSupplyRemoteDisable.setStatus('mandatory')
if mibBuilder.loadTexts: powerSupplyRemoteDisable.setDescription('Provides Enable/Disable control of the power supply.\n\n                For devices that do not support this capability, a set \n                attempt will return BADVALUE, and a read will always \n                return infoNotAvailable.')
nB55HWAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 3, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nB55HWAddress.setReference('This value is the same as ifPhysAddress in RFC\n                    1213.')
if mibBuilder.loadTexts: nB55HWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nB55HWAddress.setDescription("The device's MAC address.")
nB55HWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nB55HWRev.setStatus('mandatory')
if mibBuilder.loadTexts: nB55HWRev.setDescription('Denotes the revision of the nB55 board. A value of\n                    one denotes Revision 1, a value of two denotes Revi-\n                    sion 2, and so on.')
nB55FWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 3, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nB55FWRev.setStatus('mandatory')
if mibBuilder.loadTexts: nB55FWRev.setDescription('Denotes the revision of firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
mRXIHWAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 6, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mRXIHWAddress.setReference('This value is the same as ifPhysAddress in RFC\n                    1213.')
if mibBuilder.loadTexts: mRXIHWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mRXIHWAddress.setDescription("The device's MAC address.")
mRXIHWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mRXIHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: mRXIHWRev.setDescription('Denotes the revision of the mRXI board. A value of\n                    one denotes Revision 1, a value of two denotes Revi-\n                    sion 2, and so on.')
mRXIFWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 6, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mRXIFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: mRXIFWRev.setDescription('Denotes the revision of firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
iRM3HWAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iRM3HWAddress.setReference('This value is the same as ifPhysAddress in RFC\n                    1213.')
if mibBuilder.loadTexts: iRM3HWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iRM3HWAddress.setDescription("The device's MAC address.")
iRM3HWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: iRM3HWRev.setStatus('mandatory')
if mibBuilder.loadTexts: iRM3HWRev.setDescription('Denotes the revision of the IRM3 board. A value of\n                    one denotes Revision 1, a value of two denotes Revi-\n                    sion 2, and so on.')
iRM3FWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: iRM3FWRev.setStatus('mandatory')
if mibBuilder.loadTexts: iRM3FWRev.setDescription('Denotes the revision of firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
iRM3PortAssoc = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 6))).clone(namedValues=NamedValues(("aoffFrp", 5), ("arpFoff", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iRM3PortAssoc.setStatus('mandatory')
if mibBuilder.loadTexts: iRM3PortAssoc.setDescription('Controls how front panel ports are associated \n                    with the Irm3.')
iRM3BPSupport = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iRM3BPSupport.setStatus('mandatory')
if mibBuilder.loadTexts: iRM3BPSupport.setDescription('Denotes whether or not Backplane Protocol Support is\n                    present in the current version of the IRM3.')
tRMMHWAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 8, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRMMHWAddress.setReference('This value is the same as ifPhysAddress in RFC\n                    1213.')
if mibBuilder.loadTexts: tRMMHWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tRMMHWAddress.setDescription("The device's MAC address.")
tRMMHWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRMMHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: tRMMHWRev.setDescription('Denotes the revision of the tRMM board. A value of\n                    one denotes Revision 1, a value of two denotes Revi-\n                    sion 2, and so on.')
tRMMFWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 8, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRMMFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: tRMMFWRev.setDescription('Denotes the revision of firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
eMMEHWAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 9, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMMEHWAddress.setReference('This value is the same as ifPhysAddress in RFC\n                    1213.')
if mibBuilder.loadTexts: eMMEHWAddress.setStatus('mandatory')
if mibBuilder.loadTexts: eMMEHWAddress.setDescription("The device's MAC address.")
eMMEHWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 9, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMMEHWRev.setStatus('mandatory')
if mibBuilder.loadTexts: eMMEHWRev.setDescription('Denotes the revision of the eMME board. A value of\n                    one denotes Revision 1, a value of two denotes Revi-\n                    sion 2, and so on.')
eMMEFWRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 9, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMMEFWRev.setStatus('mandatory')
if mibBuilder.loadTexts: eMMEFWRev.setDescription('Denotes the revision of firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
eMMEBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 9, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eMMEBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: eMMEBoardMap.setDescription('Denotes a bit encoded representation of the slots that\n                     contain MIM boards.  If a bit is a one then the board\n                     is present.')
fPRedund = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1))
fPRedundReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundReset.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundReset.setDescription('If this object is set to Reset it will cause a reset\n                     of the front panel redundancy. Setting this object to\n                     NoReset will do nothing. This object will always be \n                     read as NoReset.')
fPRedundPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundPollInterval.setDescription('Get/Set the number of seconds between polls for front\n                     panel redundancy.')
fPRedundRetrys = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundRetrys.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundRetrys.setDescription('Get/Set the the number of unanswered polls allowed for\n                     the front panel redundancy before it switches ports.')
fPRedundNumAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fPRedundNumAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundNumAddr.setDescription('Get the number of IP Addresses associated with front panel\n                     redundancy.')
fPRedundAddAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundAddAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundAddAddr.setDescription('Add an IP Address to the polling list for the front panel\n                     redundancy.')
fPRedundDelAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundDelAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundDelAddr.setDescription('Delete an IP Address from the polling list for the \n                     front panel redundancy.')
fPRedundActivePort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundActivePort.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundActivePort.setDescription('Get/Set the front panel port you want to be active \n                     when front panel redundancy is enabled.')
fPRedundEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fPRedundEnable.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundEnable.setDescription('If this object is set to enable, the front panel\n                     redundancy will be activated. If this object is set \n                     to disable,  the front panel redundancy will be \n                     deactivated.  When read, this object will returns the \n                     state of the object based on the last request \n                     made.')
fPRedundAddrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 2), )
if mibBuilder.loadTexts: fPRedundAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundAddrTable.setDescription('A list of entries that provide IP address\n                    information for front panel redundancy.')
fPRedundAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 2, 1), ).setIndexNames((0, "CTRON-COMMON-MIB", "fPRedundAddrId"))
if mibBuilder.loadTexts: fPRedundAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundAddrEntry.setDescription('An entry in the fPRedundAddrTable providing objects\n                    for front panel redundancy.')
fPRedundAddrId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fPRedundAddrId.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundAddrId.setDescription('A unique value identifying an element in a sequence of\n                     member IP Addresses which belong to the front panel \n                     redundancy.  This value goes from 1 to the maximum \n                     number of IP Addresses which may be included in  \n                     front panel redundancy.')
fPRedundAddrIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 1, 6, 2, 10, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fPRedundAddrIPAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fPRedundAddrIPAddr.setDescription('Returns an IP Address associated with the front panel\n                     redundancy.')
upsID = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 257, 258, 259, 260, 261, 262))).clone(namedValues=NamedValues(("other", 1), ("aPCModel370", 257), ("aPCModel400", 258), ("aPCModel600", 259), ("aPCModel900", 260), ("aPCModel1250", 261), ("aPCModel2000", 262)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upsID.setStatus('mandatory')
if mibBuilder.loadTexts: upsID.setDescription('Denotes a type code which refers to the manufactur-\n                    ers and model of the UPS.')
upsUpTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upsUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: upsUpTime.setDescription('Denotes the operating time, in hours, since the UPS\n                    was last powered on.')
upsDisable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upsDisable.setStatus('deprecated')
if mibBuilder.loadTexts: upsDisable.setDescription('Allows the UPS to be disabled.  A set turns of the\n                    UPS for those systems, so equipped.  A get/get-next\n                    always returns 0.')
upsDisconnect = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upsDisconnect.setStatus('mandatory')
if mibBuilder.loadTexts: upsDisconnect.setDescription('Allows the UPS backup power system to conserve its\n                    battery.  Setting the object to a value of 1 turns off\n                    the power system.  A get/get-next always retuns a 0.')
upsTest = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unitOK", 1), ("unitFailed", 2), ("badBattery", 3), ("noRecentTest", 4), ("underTest", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: upsTest.setStatus('mandatory')
if mibBuilder.loadTexts: upsTest.setDescription('Denotes the status performed on the UPS.  A write\n                    unitOK(1) intiates the test.  A read indicates status of\n                    test.')
upsBatteryCapacity = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upsBatteryCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: upsBatteryCapacity.setDescription('Denotes the percentage of battery capacity left,\n                    100% being a fully-charged battery.')
upsACLineVoltsIn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upsACLineVoltsIn.setStatus('mandatory')
if mibBuilder.loadTexts: upsACLineVoltsIn.setDescription('Denotes the input AC utility line voltage.')
upsBatteryVoltsOut = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: upsBatteryVoltsOut.setStatus('mandatory')
if mibBuilder.loadTexts: upsBatteryVoltsOut.setDescription('Denotes the battery voltage.')
dlForceOnBoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlForceOnBoot.setStatus('mandatory')
if mibBuilder.loadTexts: dlForceOnBoot.setDescription('When set to a 1, the system will request a\n                     download, during the next system restart.\n                     If no server is found and the current image\n                     in flash memory is valid, the system will boot\n                     using the flash-resident image.')
dlCommitRAMToFlash = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlCommitRAMToFlash.setStatus('mandatory')
if mibBuilder.loadTexts: dlCommitRAMToFlash.setDescription('When written with a 1, the boot software will erase\n                    flash memory, compress the downloaded code, and save\n                    the compressed image into flash memory.  Upon com-\n                    pletion of this operation, the flash memory driver\n                    resets this object to 0, indicating completion of\n                    the programming operation.')
dlInitiateColdBoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlInitiateColdBoot.setStatus('mandatory')
if mibBuilder.loadTexts: dlInitiateColdBoot.setDescription('When written with a 1, the boot software intiates a\n                    system reboot.  All MIB variables used to control\n                    the exact nature of the download should be set,\n                    prior to activating a system reset.\n\n                    A read always returns a 0.')
dlTFTPRequestHost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlTFTPRequestHost.setStatus('mandatory')
if mibBuilder.loadTexts: dlTFTPRequestHost.setDescription('The IP address of the server to be used, when\n                    firmware is to be loaded across the network.')
dlTFTPRequest = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlTFTPRequest.setStatus('mandatory')
if mibBuilder.loadTexts: dlTFTPRequest.setDescription('The filename requested of the server, when firmware\n                    is to be loaded across the network.')
dlLastImageFilename = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlLastImageFilename.setStatus('mandatory')
if mibBuilder.loadTexts: dlLastImageFilename.setDescription('Filename of the last image to be successfully\n                    loaded into memory.')
dlLastServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlLastServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlLastServerIPAddress.setDescription('The IP address of the server used to load the\n                    present image in flash memory.')
dlFlashSize = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlFlashSize.setStatus('mandatory')
if mibBuilder.loadTexts: dlFlashSize.setDescription('Denotes the size, in bytes, of flash memory con-\n                    tained on this module.')
dlFlashCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlFlashCount.setStatus('mandatory')
if mibBuilder.loadTexts: dlFlashCount.setDescription('Denotes the number of times that flash memory has\n                    been reprogrammed.  This value is initialzed to 1,\n                    when the module is initially powered up.')
dlFirmwareBase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlFirmwareBase.setStatus('mandatory')
if mibBuilder.loadTexts: dlFirmwareBase.setDescription('Denotes the starting address of the firmware in\n                    RAM.')
dlFirmwareTop = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlFirmwareTop.setStatus('mandatory')
if mibBuilder.loadTexts: dlFirmwareTop.setDescription('Denotes the ending address of firmware in RAM.')
dlFirmwareStart = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlFirmwareStart.setStatus('mandatory')
if mibBuilder.loadTexts: dlFirmwareStart.setDescription('Denotes the start address of the firmware, in RAM,\n                    as established by the boot process.')
dlBootRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlBootRev.setStatus('mandatory')
if mibBuilder.loadTexts: dlBootRev.setDescription('Denotes the revision of boot firmware in the module.\n                    The first octets provides the version, and the\n                    second provides the revision.')
dlForceBootp = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlForceBootp.setStatus('mandatory')
if mibBuilder.loadTexts: dlForceBootp.setDescription('When set, this variable forces the client to send a\n                BOOTP request packet when rebooting.  The client will\n                make several attempts before timing out if a server\n                does not respond.  This variable stays set.  When set to\n                a 1 it should always be read as a one.  When set to zero\n                it should always be read as zero.')
dlServerName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlServerName.setStatus('mandatory')
if mibBuilder.loadTexts: dlServerName.setDescription('This OID is reserved for future use of the Bootp server\n                name.  This field can be used when a client wants to get\n                boot information from a particular bootp server.')
dlOnLineDownLoad = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normalOperation", 1), ("forceDownLoad", 2), ("forceDownLoadReset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlOnLineDownLoad.setStatus('mandatory')
if mibBuilder.loadTexts: dlOnLineDownLoad.setDescription('During normal operation this object has the value of 1.  By\n                setting this object to a value of forceDownLoad(2) an online\n                download will be performed.  By setting this object to a\n                value of forceDownLoadReset(3) an online down load will be\n                performed and a reset will be forced upon successful completion\n                of the download.')
dlOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("normalOperation", 3), ("downLoadActive", 4), ("downLoadCompleteError", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dlOperStatus.setDescription('This object reflects the status of the download code.  A\n                value of normalOperation(3) reflects either a down load was\n                started but has finished normally and no reset was specified\n                or no down load has been started.  A value of downLoadActive\n                only appears while a down load is in progress.  A value of\n                downLoadCompleteError reflects that a down load was started\n                however an error was detected.')
dlNetAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlNetAddress.setDescription('IP Address of the server to be used when an image is to be\n                downloaded using the Runtime TFTP Download.')
dlFileName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlFileName.setStatus('mandatory')
if mibBuilder.loadTexts: dlFileName.setDescription('Filename requested of the server when an image is to be\n                 downloaded using the Runtime TFTP Download.  This should be a\n                 complete path filename.')
dlErrorString = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlErrorString.setStatus('mandatory')
if mibBuilder.loadTexts: dlErrorString.setDescription('If the value of ctDLOperStatus is downloadCompleteError(5)\n                then this object will provide a more complete description of\n                the error.  Otherwise this object will be the zero length\n                string.')
dlTftpServerGatewayIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 4, 21), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dlTftpServerGatewayIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dlTftpServerGatewayIPAddress.setDescription('The IP address of the gateway/router which connects\n                     this SNMP agent to the TFTP server.')
mibBuilder.exportSymbols("CTRON-COMMON-MIB", fPRedundRetrys=fPRedundRetrys, dlLastImageFilename=dlLastImageFilename, dlCommitRAMToFlash=dlCommitRAMToFlash, dlForceBootp=dlForceBootp, eMME=eMME, dlOnLineDownLoad=dlOnLineDownLoad, upsACLineVoltsIn=upsACLineVoltsIn, powerSupplyRedun=powerSupplyRedun, chassisSlots=chassisSlots, deviceTime=deviceTime, fnbTRTable=fnbTRTable, fnbConnect=fnbConnect, tRMMHWAddress=tRMMHWAddress, dlTftpServerGatewayIPAddress=dlTftpServerGatewayIPAddress, upsVersion=upsVersion, dlErrorString=dlErrorString, eMMEHWAddress=eMMEHWAddress, fPRedundAddrTable=fPRedundAddrTable, mRXIHWAddress=mRXIHWAddress, fnbTR=fnbTR, dlFlashSize=dlFlashSize, powerSupplyRemoteDisable=powerSupplyRemoteDisable, iRM3FWRev=iRM3FWRev, chassis=chassis, dlTFTPRequestHost=dlTFTPRequestHost, fnbPortConnectTable=fnbPortConnectTable, dlTFTPRequest=dlTFTPRequest, mRXI=mRXI, tRMM=tRMM, fnbPortConnectBoardIndex=fnbPortConnectBoardIndex, nB55HWRev=nB55HWRev, nB55FWRev=nB55FWRev, fPRedundAddrEntry=fPRedundAddrEntry, deviceType=deviceType, dlFileName=dlFileName, deviceIPAddress=deviceIPAddress, iRM3HWAddress=iRM3HWAddress, iRM3HWRev=iRM3HWRev, fPRedundAddrId=fPRedundAddrId, fnbTREntry=fnbTREntry, fnbCSMACDTable=fnbCSMACDTable, tRMMFWRev=tRMMFWRev, eMMEFWRev=eMMEFWRev, fPRedundDelAddr=fPRedundDelAddr, dlInitiateColdBoot=dlInitiateColdBoot, fnbRPBypass=fnbRPBypass, chassisAlarmState=chassisAlarmState, upsBatteryCapacity=upsBatteryCapacity, fnbPortConnect=fnbPortConnect, dlFirmwareTop=dlFirmwareTop, dlBootRev=dlBootRev, dlForceOnBoot=dlForceOnBoot, fPRedundAddAddr=fPRedundAddAddr, deviceDate=deviceDate, environment=environment, iRM3PortAssoc=iRM3PortAssoc, fnbCSMACDEntry=fnbCSMACDEntry, fPRedundPollInterval=fPRedundPollInterval, chassisAlarmEna=chassisAlarmEna, dlFirmwareStart=dlFirmwareStart, fnbPortConnectPortAssignment=fnbPortConnectPortAssignment, fnbConnectRight=fnbConnectRight, fnbCSMACD=fnbCSMACD, fnb2=fnb2, upsBatteryVoltsOut=upsBatteryVoltsOut, mRXIHWRev=mRXIHWRev, fnbPortConnectEntry=fnbPortConnectEntry, dlOperStatus=dlOperStatus, upsDisconnect=upsDisconnect, powerEntry=powerEntry, upsRevision=upsRevision, fPRedundReset=fPRedundReset, fnbCSMACDIndex=fnbCSMACDIndex, dlServerName=dlServerName, chassisFNB=chassisFNB, eMMEHWRev=eMMEHWRev, nB55HWAddress=nB55HWAddress, powerSupplyId=powerSupplyId, upsTest=upsTest, dlLastServerIPAddress=dlLastServerIPAddress, fnbTRIndex=fnbTRIndex, powerTable=powerTable, upsDisable=upsDisable, fPRedundActivePort=fPRedundActivePort, fnbPortConnectPortIndex=fnbPortConnectPortIndex, dlFlashCount=dlFlashCount, dlFirmwareBase=dlFirmwareBase, powerSupplyNum=powerSupplyNum, chassisHWRev=chassisHWRev, fnbConnectLeft=fnbConnectLeft, nB55=nB55, iRM3=iRM3, deviceName=deviceName, chassisType=chassisType, fnbBypass=fnbBypass, dlNetAddress=dlNetAddress, powerSupplyState=powerSupplyState, iRM3BPSupport=iRM3BPSupport, fPRedundNumAddr=fPRedundNumAddr, eMMEBoardMap=eMMEBoardMap, upsUpTime=upsUpTime, fPRedund=fPRedund, fPRedundEnable=fPRedundEnable, tRMMHWRev=tRMMHWRev, upsID=upsID, fPRedundancy=fPRedundancy, fnbPortConnectCompID=fnbPortConnectCompID, fnbPortChanges=fnbPortChanges, fPRedundAddrIPAddr=fPRedundAddrIPAddr, fnbPortConnectionChanges=fnbPortConnectionChanges, mRXIFWRev=mRXIFWRev)
