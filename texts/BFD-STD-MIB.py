#
# PySNMP MIB module BFD-STD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/output/asn1/BFD-STD-MIB
# Produced by pysmi-1.1.12 at Wed May 29 06:41:29 2024
# On host fv-az1019-850 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
BfdCtrlSourcePortNumberTC, BfdMultiplierTC, BfdCtrlDestPortNumberTC, BfdSessIndexTC, BfdIntervalTC = mibBuilder.importSymbols("BFD-TC-STD-MIB", "BfdCtrlSourcePortNumberTC", "BfdMultiplierTC", "BfdCtrlDestPortNumberTC", "BfdSessIndexTC", "BfdIntervalTC")
IndexIntegerNextFree, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "IndexIntegerNextFree")
IANAbfdSessTypeTC, IANAbfdSessAuthenticationTypeTC, IANAbfdSessStateTC, IANAbfdSessOperModeTC, IANAbfdSessAuthenticationKeyTC, IANAbfdDiagTC = mibBuilder.importSymbols("IANA-BFD-TC-STD-MIB", "IANAbfdSessTypeTC", "IANAbfdSessAuthenticationTypeTC", "IANAbfdSessStateTC", "IANAbfdSessOperModeTC", "IANAbfdSessAuthenticationKeyTC", "IANAbfdDiagTC")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddress, InetPortNumber, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, mib_2, ModuleIdentity, IpAddress, ObjectIdentity, MibIdentifier, NotificationType, iso, Bits, Counter64, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "mib-2", "ModuleIdentity", "IpAddress", "ObjectIdentity", "MibIdentifier", "NotificationType", "iso", "Bits", "Counter64", "Counter32")
StorageType, TextualConvention, DisplayString, TruthValue, TimeStamp, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "DisplayString", "TruthValue", "TimeStamp", "RowStatus")
bfdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 222))
bfdMIB.setRevisions(('2014-08-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: bfdMIB.setRevisionsDescriptions(('Initial version.  Published as RFC 7331.',))
if mibBuilder.loadTexts: bfdMIB.setLastUpdated('201408120000Z')
if mibBuilder.loadTexts: bfdMIB.setOrganization('IETF Bidirectional Forwarding Detection\n                   Working Group')
if mibBuilder.loadTexts: bfdMIB.setContactInfo('Thomas D. Nadeau\n          Brocade\n          Email:  tnadeau@lucidvision.com\n\n          Zafar Ali\n          Cisco Systems, Inc.\n          Email:  zali@cisco.com\n\n          Nobo Akiya\n          Cisco Systems, Inc.\n          Email:  nobo@cisco.com\n\n          Comments about this document should be emailed\n          directly to the BFD Working Group mailing list\n          at rtg-bfd@ietf.org')
if mibBuilder.loadTexts: bfdMIB.setDescription("Bidirectional Forwarding Management Information Base.\n\n          Copyright (c) 2014 IETF Trust and the persons identified\n          as authors of the code.  All rights reserved.\n\n          Redistribution and use in source and binary forms, with\n          or without modification, is permitted pursuant to, and\n          subject to the license terms contained in, the Simplified\n          BSD License set forth in Section 4.c of the IETF Trust's\n          Legal Provisions Relating to IETF Documents\n          (http://trustee.ietf.org/license-info).")
bfdNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 0))
bfdObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 1))
bfdConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2))
bfdScalarObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 1, 1))
bfdAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("adminDown", 3), ("down", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bfdAdminStatus.setStatus('current')
if mibBuilder.loadTexts: bfdAdminStatus.setDescription('The desired global administrative status of the BFD\n             system in this device.')
bfdOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("adminDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdOperStatus.setStatus('current')
if mibBuilder.loadTexts: bfdOperStatus.setDescription('Indicates the actual operational status of the\n             BFD system in this device. When this value is\n             down(2), all entries in the bfdSessTable MUST have\n             their bfdSessOperStatus as down(2) as well. When\n             this value is adminDown(3), all entries in the\n             bfdSessTable MUST have their bfdSessOperStatus\n             as adminDown(3) as well.')
bfdNotificationsEnable = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bfdNotificationsEnable.setReference('See also RFC3413 for explanation that\n             notifications are under the ultimate control of the\n             MIB modules in this document.')
if mibBuilder.loadTexts: bfdNotificationsEnable.setStatus('current')
if mibBuilder.loadTexts: bfdNotificationsEnable.setDescription('If this object is set to true(1), then it enables\n             the emission of bfdSessUp and bfdSessDown\n             notifications; otherwise these notifications are not\n             emitted.')
bfdSessIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 222, 1, 1, 4), IndexIntegerNextFree().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessIndexNext.setStatus('current')
if mibBuilder.loadTexts: bfdSessIndexNext.setDescription('This object contains an unused value for\n             bfdSessIndex that can be used when creating\n             entries in the table. A zero indicates that\n             no entries are available, but MUST NOT be used\n             as a valid index. ')
bfdSessTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 2), )
if mibBuilder.loadTexts: bfdSessTable.setReference('Katz, D. and D. Ward, Bidirectional Forwarding\n              Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessTable.setDescription('The BFD Session Table describes the BFD sessions.')
bfdSessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 2, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessIndex"))
if mibBuilder.loadTexts: bfdSessEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessEntry.setDescription('The BFD Session Entry describes BFD session.')
bfdSessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 1), BfdSessIndexTC())
if mibBuilder.loadTexts: bfdSessIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessIndex.setDescription('This object contains an index used to represent a\n             unique BFD session on this device.  Managers\n             should obtain new values for row creation in this\n             table by reading bfdSessIndexNext.')
bfdSessVersionNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessVersionNumber.setReference('Katz, D. and D. Ward, Bidirectional Forwarding\n              Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessVersionNumber.setStatus('current')
if mibBuilder.loadTexts: bfdSessVersionNumber.setDescription('The version number of the BFD protocol that this session\n             is running in. Write access is available for this object\n             to provide ability to set desired version for this\n             BFD session.')
bfdSessType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 3), IANAbfdSessTypeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessType.setStatus('current')
if mibBuilder.loadTexts: bfdSessType.setDescription('This object specifies the type of this BFD session.')
bfdSessDiscriminator = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDiscriminator.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscriminator.setDescription('This object specifies the local discriminator for this BFD\n             session, used to uniquely identify it.')
bfdSessRemoteDiscr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setReference('Section 6.8.6, from Katz, D. and D. Ward, Bidirectional\n             Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setStatus('current')
if mibBuilder.loadTexts: bfdSessRemoteDiscr.setDescription('This object specifies the session discriminator chosen\n             by the remote system for this BFD session.  The value may\n             be zero(0) if the remote discriminator is not yet known\n             or if the session is in the down or adminDown(1) state.')
bfdSessDestinationUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 6), BfdCtrlDestPortNumberTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDestinationUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessDestinationUdpPort.setDescription("This object specifies the destination UDP port number\n             used for this BFD session's control packets. The value\n             may be zero(0) if the session is in adminDown(1) state.")
bfdSessSourceUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 7), BfdCtrlSourcePortNumberTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSourceUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessSourceUdpPort.setDescription("This object specifies the source UDP port number used\n             for this BFD session's control packets. The value may be\n             zero(0) if the session is in adminDown(1) state. Upon\n             creation of a new BFD session via this MIB, the value of\n             zero(0) specified would permit the implementation to\n             choose its own source port number.")
bfdSessEchoSourceUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 8), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessEchoSourceUdpPort.setStatus('current')
if mibBuilder.loadTexts: bfdSessEchoSourceUdpPort.setDescription("This object specifies the source UDP port number used for\n             this BFD session's echo packets. The value may be zero(0)\n             if the session is not running in the echo mode, or the\n             session is in adminDown(1) state. Upon creation of a new\n             BFD session via this MIB, the value of zero(0) would\n             permit the implementation to choose its own source port\n             number.")
bfdSessAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("adminDown", 3), ("down", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAdminStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessAdminStatus.setDescription('Denotes the desired operational status of the BFD Session.\n\n             A transition to enabled(1) will start the BFD state machine\n             for the session. The state machine will have an initial\n             state of down(2).\n\n             A transition to disabled(2) will stop the BFD state machine\n             for the session. The state machine may first transition to\n             adminDown(1) prior to stopping.\n\n             A transition to adminDown(3) will cause the BFD state\n             machine to transition to adminDown(1), and will cause the\n             session to remain in this state.\n\n             A transition to down(4) will cause the BFD state machine\n             to transition to down(2), and will cause the session to\n             remain in this state.\n\n             Care should be used in providing write access to this\n             object without adequate authentication.')
bfdSessOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("adminDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessOperStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessOperStatus.setDescription('Denotes the actual operational status of the BFD Session.\n             If the value of bfdOperStatus is down(2), this value MUST\n             eventually be down(2) as well. If the value of\n             bfdOperStatus is adminDown(3), this value MUST eventually\n             be adminDown(3) as well.')
bfdSessState = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 11), IANAbfdSessStateTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessState.setStatus('current')
if mibBuilder.loadTexts: bfdSessState.setDescription('Configured BFD session state.')
bfdSessRemoteHeardFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setReference('Katz, D. and D. Ward, Bidirectional\n             Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessRemoteHeardFlag.setDescription('This object specifies status of BFD packet reception from\n             the remote system. Specifically, it is set to true(1) if\n             the local system is actively receiving BFD packets from the\n             remote system, and is set to false(2) if the local system\n             has not received BFD packets recently (within the detection\n             time) or if the local system is attempting to tear down\n             the BFD session.')
bfdSessDiag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 13), IANAbfdDiagTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessDiag.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiag.setDescription("A diagnostic code specifying the local system's reason\n             for the last transition of the session from up(4)\n             to some other state.")
bfdSessOperMode = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 14), IANAbfdSessOperModeTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessOperMode.setStatus('current')
if mibBuilder.loadTexts: bfdSessOperMode.setDescription('This object specifies the operational mode of this\n             BFD session.')
bfdSessDemandModeDesiredFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDemandModeDesiredFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessDemandModeDesiredFlag.setDescription("This object indicates that the local system's\n             desire to use Demand mode. Specifically, it is set\n             to true(1) if the local system wishes to use\n             Demand mode or false(2) if not")
bfdSessControlPlaneIndepFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessControlPlaneIndepFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessControlPlaneIndepFlag.setDescription("This object indicates that the local system's\n             ability to continue to function through a disruption of\n             the control plane. Specifically, it is set\n             to true(1) if the local system BFD implementation is\n             independent of the control plane. Otherwise, the\n             value is set to false(2)")
bfdSessMultipointFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessMultipointFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessMultipointFlag.setDescription('This object indicates the Multipoint (M) bit for this\n             session. It is set to true(1) if Multipoint (M) bit is\n             set to 1. Otherwise, the value is set to false(2)')
bfdSessInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 18), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessInterface.setStatus('current')
if mibBuilder.loadTexts: bfdSessInterface.setDescription('This object contains an interface index used to indicate\n             the interface which this BFD session is running on. This\n             value can be zero if there is no interface associated\n             with this BFD session.')
bfdSessSrcAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 19), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSrcAddrType.setStatus('current')
if mibBuilder.loadTexts: bfdSessSrcAddrType.setDescription('This object specifies IP address type of the source IP\n             address of this BFD session. The value of unknown(0) is\n             allowed only when the session is singleHop(1) and the\n             source IP address of this BFD session is derived from\n             the outgoing interface, or when the BFD session is not\n             associated with a specific interface. If any other\n             unsupported values are attempted in a set operation, the\n             agent MUST return an inconsistentValue error.')
bfdSessSrcAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 20), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessSrcAddr.setStatus('current')
if mibBuilder.loadTexts: bfdSessSrcAddr.setDescription('This object specifies the source IP address of this BFD\n             session. The format of this object is controlled by the\n             bfdSessSrcAddrType object.')
bfdSessDstAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 21), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDstAddrType.setStatus('current')
if mibBuilder.loadTexts: bfdSessDstAddrType.setDescription('This object specifies IP address type of the neighboring IP\n             address which is being monitored with this BFD session.\n             The value of unknown(0) is allowed only when the session is\n             singleHop(1) and the outgoing interface is of type\n             point-to-point, or when the BFD session is not associated\n             with a specific interface. If any other unsupported values\n             are attempted in a set operation, the agent MUST return an\n             inconsistentValue error.')
bfdSessDstAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 22), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDstAddr.setStatus('current')
if mibBuilder.loadTexts: bfdSessDstAddr.setDescription('This object specifies the neighboring IP address which is\n             being monitored with this BFD session. The format of this\n             object is controlled by the bfdSessDstAddrType object.')
bfdSessGTSM = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 23), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessGTSM.setReference('RFC5082, The Generalized TTL Security Mechanism (GTSM).\n            RFC5881, Section 5')
if mibBuilder.loadTexts: bfdSessGTSM.setStatus('current')
if mibBuilder.loadTexts: bfdSessGTSM.setDescription('Setting the value of this object to false(2) will disable\n             GTSM protection of the BFD session.  GTSM MUST be enabled\n             on a singleHop(1) session if no authentication is in use.')
bfdSessGTSMTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessGTSMTTL.setReference('RFC5082, The Generalized TTL Security Mechanism (GTSM).\n            RFC5881, Section 5')
if mibBuilder.loadTexts: bfdSessGTSMTTL.setStatus('current')
if mibBuilder.loadTexts: bfdSessGTSMTTL.setDescription('This object is valid only when bfdSessGTSM protection is\n             enabled on the system. This object indicates the minimum\n             allowed TTL for received BFD control packets. For a\n             singleHop(1) session, if GTSM protection is enabled,\n             this object SHOULD be set to maximum TTL value allowed\n             for single hop.\n\n             By default, GTSM is enabled and TTL value is 255. For a\n             multihop session, updating of maximum TTL value allowed\n             is likely required.')
bfdSessDesiredMinTxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 25), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setReference('Section 4.1 from Katz, D. and D. Ward, Bidirectional\n             Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessDesiredMinTxInterval.setDescription('This object specifies the minimum interval, in\n             microseconds, that the local system would like to use\n             when transmitting BFD Control packets. The value of\n             zero(0) is reserved in this case, and should not be\n             used.')
bfdSessReqMinRxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 26), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setReference('Section 4.1 from Katz, D. and D. Ward, Bidirectional\n             Forwarding Detection (BFD), RFC 5880, June 2012.')
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessReqMinRxInterval.setDescription('This object specifies the minimum interval, in\n             microseconds, between received  BFD Control packets the\n             local system is capable of supporting. The value of\n             zero(0) can be specified when the transmitting system\n             does not want the remote system to send any periodic BFD\n             control packets.')
bfdSessReqMinEchoRxInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 27), BfdIntervalTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessReqMinEchoRxInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessReqMinEchoRxInterval.setDescription('This object specifies the minimum interval, in\n             microseconds, between received BFD Echo packets that this\n             system is capable of supporting. Value must be zero(0) if\n             this is a multihop BFD session.')
bfdSessDetectMult = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 28), BfdMultiplierTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessDetectMult.setStatus('current')
if mibBuilder.loadTexts: bfdSessDetectMult.setDescription('This object specifies the Detect time multiplier.')
bfdSessNegotiatedInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 29), BfdIntervalTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedInterval.setDescription('This object specifies the negotiated interval, in\n             microseconds, that the local system is transmitting\n             BFD Control packets.')
bfdSessNegotiatedEchoInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 30), BfdIntervalTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedEchoInterval.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedEchoInterval.setDescription('This object specifies the negotiated interval, in\n             microseconds, that the local system is transmitting\n             BFD echo packets. Value is expected to be zero if\n             the sessions is not running in echo mode.')
bfdSessNegotiatedDetectMult = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 31), BfdMultiplierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessNegotiatedDetectMult.setStatus('current')
if mibBuilder.loadTexts: bfdSessNegotiatedDetectMult.setDescription('This object specifies the Detect time multiplier.')
bfdSessAuthPresFlag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 32), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward,\n             Bidirectional Forwarding Detection (BFD), RFC 5880,\n             June 2012.')
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthPresFlag.setDescription("This object indicates that the local system's\n             desire to use Authentication. Specifically, it is set\n             to true(1) if the local system wishes the session\n             to be authenticated or false(2) if not.")
bfdSessAuthenticationType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 33), IANAbfdSessAuthenticationTypeTC().clone('noAuthentication')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationType.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward,\n             Bidirectional Forwarding Detection (BFD), RFC 5880,\n             June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationType.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationType.setDescription('The Authentication Type used for this BFD session.\n             This field is valid only when the Authentication\n             Present bit is set. Max-access to this object as well as\n             other authentication related objects are set to\n             read-create in order to support management of a single\n             key ID at a time, key rotation is not handled. Key update\n             in practice must be done by atomic update using a set\n             containing all affected objects in the same varBindList\n             or otherwise risk the session dropping.')
bfdSessAuthenticationKeyID = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward,\n             Bidirectional Forwarding Detection (BFD), RFC 5880,\n             June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationKeyID.setDescription('The authentication key ID in use for this session.  This\n             object permits multiple keys to be active simultaneously.\n             The value -1 indicates that no Authentication Key ID will\n             be present in the optional BFD Authentication Section.')
bfdSessAuthenticationKey = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 35), IANAbfdSessAuthenticationKeyTC()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setReference('Sections 4.2 - 4.4 from Katz, D. and D. Ward,\n             Bidirectional Forwarding Detection (BFD), RFC 5880,\n             June 2012.')
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setStatus('current')
if mibBuilder.loadTexts: bfdSessAuthenticationKey.setDescription('The authentication key.  When the\n             bfdSessAuthenticationType is simplePassword(1), the value\n             of this object is the password present in the BFD packets.\n\n             When the bfdSessAuthenticationType is one of the keyed\n             authentication types, this value is used in the\n             computation of the key present in the BFD authentication\n             packet.')
bfdSessStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 36), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessStorageType.setStatus('current')
if mibBuilder.loadTexts: bfdSessStorageType.setDescription("This variable indicates the storage type for this\n             object. Conceptual rows having the value\n             'permanent' need not allow write-access to any\n             columnar objects in the row.")
bfdSessRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 2, 1, 37), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: bfdSessRowStatus.setStatus('current')
if mibBuilder.loadTexts: bfdSessRowStatus.setDescription('This variable is used to create, modify, and/or\n             delete a row in this table. When a row in this\n             table has a row in the active(1) state, no\n             objects in this row can be modified except the\n             bfdSessRowStatus and bfdSessStorageType.')
bfdSessPerfTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 3), )
if mibBuilder.loadTexts: bfdSessPerfTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfTable.setDescription('This table specifies BFD Session performance counters.')
bfdSessPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 3, 1), )
bfdSessEntry.registerAugmentions(("BFD-STD-MIB", "bfdSessPerfEntry"))
bfdSessPerfEntry.setIndexNames(*bfdSessEntry.getIndexNames())
if mibBuilder.loadTexts: bfdSessPerfEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEntry.setDescription('An entry in this table is created by a BFD-enabled node\n             for every BFD Session. bfdSessPerfDiscTime is used to\n             indicate potential discontinuity for all counter objects\n             in this table.')
bfdSessPerfCtrlPktIn = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktIn.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktIn.setDescription('The total number of BFD control messages received for this\n             BFD session.\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfCtrlPktInHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktOut = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOut.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOut.setDescription('The total number of BFD control messages sent for this BFD\n             session.\n\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfCtrlPktOutHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDrop = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDrop.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDrop.setDescription('The total number of BFD control messages received for this\n             session yet dropped for being invalid.\n\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfCtrlPktDropHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDropLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropLastTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropLastTime.setDescription('The value of sysUpTime on the most recent occasion at\n             which received BFD control message for this session was\n             dropped. If no such up event exists, this object contains\n             a zero value.')
bfdSessPerfEchoPktIn = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktIn.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktIn.setDescription('The total number of BFD echo messages received for this\n             BFD session.\n\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfEchoPktInHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktOut = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktOut.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktOut.setDescription('The total number of BFD echo messages sent for this BFD\n             session.\n\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfEchoPktOutHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDrop = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDrop.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDrop.setDescription('The total number of BFD echo messages received for this\n             session yet dropped for being invalid.\n\n             It MUST be equal to the least significant 32 bits of\n             bfdSessPerfEchoPktDropHC if supported, and MUST do so\n             with the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDropLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropLastTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropLastTime.setDescription('The value of sysUpTime on the most recent occasion at\n             which received BFD echo message for this session was\n             dropped. If no such up event has been issued, this\n             object contains a zero value.')
bfdSessUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessUpTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessUpTime.setDescription('The value of sysUpTime on the most recent occasion at which\n             the session came up. If no such event has been issued,\n             this object contains a zero value.')
bfdSessPerfLastSessDownTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfLastSessDownTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfLastSessDownTime.setDescription('The value of sysUpTime on the most recent occasion at\n             which the last time communication was lost with the\n             neighbor. If no down event has been issued this object\n             contains a zero value.')
bfdSessPerfLastCommLostDiag = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 11), IANAbfdDiagTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfLastCommLostDiag.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfLastCommLostDiag.setDescription('The BFD diag code for the last time communication was lost\n             with the neighbor. If such an event has not been issued\n             this object contains a zero value.')
bfdSessPerfSessUpCount = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfSessUpCount.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfSessUpCount.setDescription('The number of times this session has gone into the Up\n             state since the system last rebooted.')
bfdSessPerfDiscTime = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 13), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfDiscTime.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfDiscTime.setDescription('The value of sysUpTime on the most recent occasion at\n             which any one or more of the session counters suffered\n             a discontinuity.\n\n             The relevant counters are the specific instances associated\n             with this BFD session of any Counter32 object contained in\n             the BfdSessPerfTable. If no such discontinuities have\n             occurred since the last re-initialization of the local\n             management subsystem, then this object contains a zero\n             value.')
bfdSessPerfCtrlPktInHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktInHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktInHC.setDescription('This value represents the total number of BFD control\n             messages received for this BFD session.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfCtrlPktIn, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktOutHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOutHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktOutHC.setDescription('This value represents the total number of BFD control\n             messages transmitted for this BFD session.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfCtrlPktOut, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessPerfCtrlPktDropHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfCtrlPktDropHC.setDescription('This value represents the total number of BFD control\n             messages received for this BFD session yet dropped for\n             being invalid.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfCtrlPktDrop, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktInHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktInHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktInHC.setDescription('This value represents the total number of BFD echo\n             messages received for this BFD session.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfEchoPktIn, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktOutHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktOutHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktOutHC.setDescription('This value represents the total number of BFD echo\n             messages transmitted for this BFD session.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfEchoPktOut, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessPerfEchoPktDropHC = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 3, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropHC.setStatus('current')
if mibBuilder.loadTexts: bfdSessPerfEchoPktDropHC.setDescription('This value represents the total number of BFD echo\n             messages received for this BFD session yet dropped\n             for being invalid.\n\n             The least significant 32 bits MUST equal to\n             bfdSessPerfEchoPktDrop, and MUST do so with\n             the rules spelled out in RFC 2863.')
bfdSessDiscMapTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 4), )
if mibBuilder.loadTexts: bfdSessDiscMapTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapTable.setDescription("The BFD Session Discriminator Mapping Table maps a\n             local discriminator value to associated BFD session's\n             bfdSessIndex found in the bfdSessionTable.")
bfdSessDiscMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 4, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessDiscriminator"))
if mibBuilder.loadTexts: bfdSessDiscMapEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapEntry.setDescription('The BFD Session Discriminator Mapping Entry\n             specifies a mapping between a local discriminator\n             and a BFD session.')
bfdSessDiscMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 4, 1, 1), BfdSessIndexTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessDiscMapIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessDiscMapIndex.setDescription('This object specifies a mapping between a\n             local discriminator and a BFD Session in\n             the BfdSessTable.')
bfdSessIpMapTable = MibTable((1, 3, 6, 1, 2, 1, 222, 1, 5), )
if mibBuilder.loadTexts: bfdSessIpMapTable.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapTable.setDescription('The BFD Session IP Mapping Table maps given\n             bfdSessInterface, bfdSessSrcAddrType, bfdSessSrcAddr,\n             bfdSessDstAddrType and bfdSessDstAddr\n             to an associated BFD session found in the\n             bfdSessionTable.')
bfdSessIpMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 222, 1, 5, 1), ).setIndexNames((0, "BFD-STD-MIB", "bfdSessInterface"), (0, "BFD-STD-MIB", "bfdSessSrcAddrType"), (0, "BFD-STD-MIB", "bfdSessSrcAddr"), (0, "BFD-STD-MIB", "bfdSessDstAddrType"), (0, "BFD-STD-MIB", "bfdSessDstAddr"))
if mibBuilder.loadTexts: bfdSessIpMapEntry.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapEntry.setDescription('The BFD Session IP Map Entry contains a mapping\n             from the IP information for a session, to the session\n             in the bfdSessionTable.')
bfdSessIpMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 222, 1, 5, 1, 1), BfdSessIndexTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bfdSessIpMapIndex.setStatus('current')
if mibBuilder.loadTexts: bfdSessIpMapIndex.setDescription('This object specifies the BfdSessIndexTC referred\n             to by the indexes of this row. In essence, a mapping is\n             provided between these indexes and the BfdSessTable.')
bfdSessUp = NotificationType((1, 3, 6, 1, 2, 1, 222, 0, 1)).setObjects(("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessDiag"))
if mibBuilder.loadTexts: bfdSessUp.setStatus('current')
if mibBuilder.loadTexts: bfdSessUp.setDescription('This notification is generated when the\n             bfdSessState object for one or more contiguous\n             entries in bfdSessTable are about to enter the up(4)\n             state from some other state. The included values of\n             bfdSessDiag MUST both be set equal to this\n             new state (i.e: up(4)).  The two instances of\n             bfdSessDiag in this notification indicate the range\n             of indexes that are affected.  Note that all the indexes\n             of the two ends of the range can be derived from the\n             instance identifiers of these two objects.  For the\n             cases where a contiguous range of sessions\n             have transitioned into the up(4) state at roughly\n             the same time, the device SHOULD issue a single\n             notification for each range of contiguous indexes in\n             an effort to minimize the emission of a large number\n             of notifications.  If a notification has to be\n             issued for just a single bfdSessEntry, then\n             the instance identifier (and values) of the two\n             bfdSessDiag objects MUST be the identical.')
bfdSessDown = NotificationType((1, 3, 6, 1, 2, 1, 222, 0, 2)).setObjects(("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessDiag"))
if mibBuilder.loadTexts: bfdSessDown.setStatus('current')
if mibBuilder.loadTexts: bfdSessDown.setDescription('This notification is generated when the\n             bfdSessState object for one or more contiguous\n             entries in bfdSessTable are about to enter the down(2)\n             or adminDown(1) states from some other state. The included\n             values of bfdSessDiag MUST both be set equal to this new\n             state (i.e: down(2) or adminDown(1)).  The two instances\n             of bfdSessDiag in this notification indicate the range\n             of indexes that are affected.  Note that all the indexes\n             of the two ends of the range can be derived from the\n             instance identifiers of these two objects.  For\n             cases where a contiguous range of sessions\n             have transitioned into the down(2) or adminDown(1) states\n             at roughly the same time, the device SHOULD issue a single\n             notification for each range of contiguous indexes in\n             an effort to minimize the emission of a large number\n             of notifications.  If a notification has to be\n             issued for just a single bfdSessEntry, then\n             the instance identifier (and values) of the two\n             bfdSessDiag objects MUST be the identical.')
bfdGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2, 1))
bfdCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 222, 2, 2))
bfdModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 222, 2, 2, 1)).setObjects(("BFD-STD-MIB", "bfdSessionGroup"), ("BFD-STD-MIB", "bfdSessionReadOnlyGroup"), ("BFD-STD-MIB", "bfdSessionPerfGroup"), ("BFD-STD-MIB", "bfdNotificationGroup"), ("BFD-STD-MIB", "bfdSessionPerfHCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdModuleFullCompliance = bfdModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: bfdModuleFullCompliance.setDescription('Compliance statement for agents that provide full\n             support for the BFD-MIB module. Such devices can\n             then be monitored and also be configured using\n             this MIB module.')
bfdModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 222, 2, 2, 2)).setObjects(("BFD-STD-MIB", "bfdSessionGroup"), ("BFD-STD-MIB", "bfdSessionReadOnlyGroup"), ("BFD-STD-MIB", "bfdSessionPerfGroup"), ("BFD-STD-MIB", "bfdNotificationGroup"), ("BFD-STD-MIB", "bfdSessionPerfHCGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdModuleReadOnlyCompliance = bfdModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: bfdModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only\n             provide read-only support for BFD-MIB. Such devices\n             can then be monitored but cannot be configured using\n             this MIB module.')
bfdSessionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 1)).setObjects(("BFD-STD-MIB", "bfdAdminStatus"), ("BFD-STD-MIB", "bfdOperStatus"), ("BFD-STD-MIB", "bfdNotificationsEnable"), ("BFD-STD-MIB", "bfdSessVersionNumber"), ("BFD-STD-MIB", "bfdSessType"), ("BFD-STD-MIB", "bfdSessIndexNext"), ("BFD-STD-MIB", "bfdSessDiscriminator"), ("BFD-STD-MIB", "bfdSessDestinationUdpPort"), ("BFD-STD-MIB", "bfdSessSourceUdpPort"), ("BFD-STD-MIB", "bfdSessEchoSourceUdpPort"), ("BFD-STD-MIB", "bfdSessAdminStatus"), ("BFD-STD-MIB", "bfdSessOperStatus"), ("BFD-STD-MIB", "bfdSessOperMode"), ("BFD-STD-MIB", "bfdSessDemandModeDesiredFlag"), ("BFD-STD-MIB", "bfdSessControlPlaneIndepFlag"), ("BFD-STD-MIB", "bfdSessMultipointFlag"), ("BFD-STD-MIB", "bfdSessInterface"), ("BFD-STD-MIB", "bfdSessSrcAddrType"), ("BFD-STD-MIB", "bfdSessSrcAddr"), ("BFD-STD-MIB", "bfdSessDstAddrType"), ("BFD-STD-MIB", "bfdSessDstAddr"), ("BFD-STD-MIB", "bfdSessGTSM"), ("BFD-STD-MIB", "bfdSessGTSMTTL"), ("BFD-STD-MIB", "bfdSessDesiredMinTxInterval"), ("BFD-STD-MIB", "bfdSessReqMinRxInterval"), ("BFD-STD-MIB", "bfdSessReqMinEchoRxInterval"), ("BFD-STD-MIB", "bfdSessDetectMult"), ("BFD-STD-MIB", "bfdSessAuthPresFlag"), ("BFD-STD-MIB", "bfdSessAuthenticationType"), ("BFD-STD-MIB", "bfdSessAuthenticationKeyID"), ("BFD-STD-MIB", "bfdSessAuthenticationKey"), ("BFD-STD-MIB", "bfdSessStorageType"), ("BFD-STD-MIB", "bfdSessRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionGroup = bfdSessionGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionGroup.setDescription('Collection of objects needed for BFD sessions.')
bfdSessionReadOnlyGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 2)).setObjects(("BFD-STD-MIB", "bfdSessRemoteDiscr"), ("BFD-STD-MIB", "bfdSessState"), ("BFD-STD-MIB", "bfdSessRemoteHeardFlag"), ("BFD-STD-MIB", "bfdSessDiag"), ("BFD-STD-MIB", "bfdSessNegotiatedInterval"), ("BFD-STD-MIB", "bfdSessNegotiatedEchoInterval"), ("BFD-STD-MIB", "bfdSessNegotiatedDetectMult"), ("BFD-STD-MIB", "bfdSessDiscMapIndex"), ("BFD-STD-MIB", "bfdSessIpMapIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionReadOnlyGroup = bfdSessionReadOnlyGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionReadOnlyGroup.setDescription('Collection of read-only objects needed for BFD sessions.')
bfdSessionPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 3)).setObjects(("BFD-STD-MIB", "bfdSessPerfCtrlPktIn"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktOut"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDrop"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDropLastTime"), ("BFD-STD-MIB", "bfdSessPerfEchoPktIn"), ("BFD-STD-MIB", "bfdSessPerfEchoPktOut"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDrop"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDropLastTime"), ("BFD-STD-MIB", "bfdSessUpTime"), ("BFD-STD-MIB", "bfdSessPerfLastSessDownTime"), ("BFD-STD-MIB", "bfdSessPerfLastCommLostDiag"), ("BFD-STD-MIB", "bfdSessPerfSessUpCount"), ("BFD-STD-MIB", "bfdSessPerfDiscTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionPerfGroup = bfdSessionPerfGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionPerfGroup.setDescription('Collection of objects needed to monitor the\n             performance of BFD sessions.')
bfdSessionPerfHCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 4)).setObjects(("BFD-STD-MIB", "bfdSessPerfCtrlPktInHC"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktOutHC"), ("BFD-STD-MIB", "bfdSessPerfCtrlPktDropHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktInHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktOutHC"), ("BFD-STD-MIB", "bfdSessPerfEchoPktDropHC"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdSessionPerfHCGroup = bfdSessionPerfHCGroup.setStatus('current')
if mibBuilder.loadTexts: bfdSessionPerfHCGroup.setDescription('Collection of objects needed to monitor the\n             performance of BFD sessions for which the\n             values of bfdSessPerfPktIn, bfdSessPerfPktOut\n             wrap around too quickly.')
bfdNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 222, 2, 1, 5)).setObjects(("BFD-STD-MIB", "bfdSessUp"), ("BFD-STD-MIB", "bfdSessDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bfdNotificationGroup = bfdNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: bfdNotificationGroup.setDescription('Set of notifications implemented in this\n             module.')
mibBuilder.exportSymbols("BFD-STD-MIB", bfdSessOperStatus=bfdSessOperStatus, bfdSessDstAddrType=bfdSessDstAddrType, bfdNotificationGroup=bfdNotificationGroup, bfdSessPerfDiscTime=bfdSessPerfDiscTime, bfdOperStatus=bfdOperStatus, bfdSessDown=bfdSessDown, bfdSessDestinationUdpPort=bfdSessDestinationUdpPort, bfdSessDemandModeDesiredFlag=bfdSessDemandModeDesiredFlag, bfdSessPerfSessUpCount=bfdSessPerfSessUpCount, bfdSessIndex=bfdSessIndex, bfdSessDetectMult=bfdSessDetectMult, bfdSessGTSM=bfdSessGTSM, bfdSessTable=bfdSessTable, bfdSessVersionNumber=bfdSessVersionNumber, bfdSessPerfCtrlPktDropHC=bfdSessPerfCtrlPktDropHC, bfdConformance=bfdConformance, bfdSessRemoteHeardFlag=bfdSessRemoteHeardFlag, bfdModuleFullCompliance=bfdModuleFullCompliance, bfdSessDesiredMinTxInterval=bfdSessDesiredMinTxInterval, bfdGroups=bfdGroups, bfdSessPerfEchoPktOut=bfdSessPerfEchoPktOut, bfdSessIndexNext=bfdSessIndexNext, bfdSessControlPlaneIndepFlag=bfdSessControlPlaneIndepFlag, bfdSessionPerfHCGroup=bfdSessionPerfHCGroup, bfdSessPerfCtrlPktOut=bfdSessPerfCtrlPktOut, bfdNotificationsEnable=bfdNotificationsEnable, bfdSessDiscMapTable=bfdSessDiscMapTable, bfdSessAuthPresFlag=bfdSessAuthPresFlag, bfdSessOperMode=bfdSessOperMode, bfdSessAuthenticationType=bfdSessAuthenticationType, bfdSessNegotiatedEchoInterval=bfdSessNegotiatedEchoInterval, bfdSessionReadOnlyGroup=bfdSessionReadOnlyGroup, bfdSessReqMinEchoRxInterval=bfdSessReqMinEchoRxInterval, PYSNMP_MODULE_ID=bfdMIB, bfdSessNegotiatedInterval=bfdSessNegotiatedInterval, bfdSessReqMinRxInterval=bfdSessReqMinRxInterval, bfdSessRowStatus=bfdSessRowStatus, bfdSessNegotiatedDetectMult=bfdSessNegotiatedDetectMult, bfdSessPerfCtrlPktDrop=bfdSessPerfCtrlPktDrop, bfdSessionPerfGroup=bfdSessionPerfGroup, bfdSessInterface=bfdSessInterface, bfdAdminStatus=bfdAdminStatus, bfdSessEchoSourceUdpPort=bfdSessEchoSourceUdpPort, bfdSessStorageType=bfdSessStorageType, bfdSessPerfCtrlPktOutHC=bfdSessPerfCtrlPktOutHC, bfdSessSourceUdpPort=bfdSessSourceUdpPort, bfdSessIpMapIndex=bfdSessIpMapIndex, bfdSessIpMapEntry=bfdSessIpMapEntry, bfdSessPerfTable=bfdSessPerfTable, bfdSessPerfEntry=bfdSessPerfEntry, bfdSessPerfCtrlPktDropLastTime=bfdSessPerfCtrlPktDropLastTime, bfdSessPerfEchoPktOutHC=bfdSessPerfEchoPktOutHC, bfdSessIpMapTable=bfdSessIpMapTable, bfdModuleReadOnlyCompliance=bfdModuleReadOnlyCompliance, bfdMIB=bfdMIB, bfdSessType=bfdSessType, bfdSessMultipointFlag=bfdSessMultipointFlag, bfdSessPerfEchoPktDropHC=bfdSessPerfEchoPktDropHC, bfdSessEntry=bfdSessEntry, bfdSessDiag=bfdSessDiag, bfdSessPerfLastCommLostDiag=bfdSessPerfLastCommLostDiag, bfdSessPerfEchoPktIn=bfdSessPerfEchoPktIn, bfdScalarObjects=bfdScalarObjects, bfdSessPerfCtrlPktInHC=bfdSessPerfCtrlPktInHC, bfdSessDiscMapIndex=bfdSessDiscMapIndex, bfdSessPerfEchoPktInHC=bfdSessPerfEchoPktInHC, bfdSessUpTime=bfdSessUpTime, bfdSessDstAddr=bfdSessDstAddr, bfdObjects=bfdObjects, bfdCompliances=bfdCompliances, bfdSessSrcAddrType=bfdSessSrcAddrType, bfdSessDiscMapEntry=bfdSessDiscMapEntry, bfdNotifications=bfdNotifications, bfdSessDiscriminator=bfdSessDiscriminator, bfdSessGTSMTTL=bfdSessGTSMTTL, bfdSessionGroup=bfdSessionGroup, bfdSessSrcAddr=bfdSessSrcAddr, bfdSessAuthenticationKeyID=bfdSessAuthenticationKeyID, bfdSessPerfLastSessDownTime=bfdSessPerfLastSessDownTime, bfdSessPerfCtrlPktIn=bfdSessPerfCtrlPktIn, bfdSessState=bfdSessState, bfdSessPerfEchoPktDrop=bfdSessPerfEchoPktDrop, bfdSessAdminStatus=bfdSessAdminStatus, bfdSessPerfEchoPktDropLastTime=bfdSessPerfEchoPktDropLastTime, bfdSessRemoteDiscr=bfdSessRemoteDiscr, bfdSessUp=bfdSessUp, bfdSessAuthenticationKey=bfdSessAuthenticationKey)
