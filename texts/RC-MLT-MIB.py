#
# PySNMP MIB module RC-MLT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/nortel/RC-MLT-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 10:09:25 2024
# On host fv-az1773-903 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
rcMlt, IdList, EnableValue, rcStat, rcLinkFlapDetect, PortSet, rcL2Redundancy = mibBuilder.importSymbols("RAPID-CITY", "rcMlt", "IdList", "EnableValue", "rcStat", "rcLinkFlapDetect", "PortSet", "rcL2Redundancy")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, Integer32, Counter64, Bits, Unsigned32, Gauge32, Counter32, IpAddress, TimeTicks, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, ObjectIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "Counter64", "Bits", "Unsigned32", "Gauge32", "Counter32", "IpAddress", "TimeTicks", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "ObjectIdentity", "NotificationType")
TextualConvention, TruthValue, MacAddress, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "MacAddress", "RowStatus", "DisplayString")
rcMltMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2272, 1, 17, 0))
rcMltMib.setRevisions(('2005-12-06 00:00', '2005-09-01 00:00', '2005-08-10 00:00', '2005-07-11 00:00', '2005-05-27 00:00', '2005-02-02 00:00', '2005-01-04 00:00', '2004-12-21 00:00', '2004-09-30 00:00', '2004-09-23 00:00', '2004-07-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rcMltMib.setRevisionsDescriptions(('Version 13:  Changed range of rcMltSmltId to 0..256.', 'Version 12:  Changed rcMltEnable from read-only to read-create.\n                                 Changed all read-write objects in rcMltTable\n                                 to read-create.', 'Version 11:  Increased to rcMltId & rcMltSmltId from 32 to 256', 'Version 10:  Added enumerations to rcMltDistributionAlgorithm.', 'Version 9:  Fixed range of rcMltVlanIds, allow rcMltIfIndex to be 0.', 'Version 8:  Changed the SYNTAX for rcStatMltIfUtilIfHCInUtil &\n                                rcStatMltIfUtilIfHCOutUtil  to Gauge32', 'Version 7:  Made Index rcStatMltIfUtilMltId as not-accessible', 'Version 6:  Added rcStatMltIfUtilTable', 'Version 5:  Import MacAddress type', 'Version 4:  Added  rcMltVlacpTable', 'Version 3:  Added  rcMltVlacpTable',))
if mibBuilder.loadTexts: rcMltMib.setLastUpdated('200512060000Z')
if mibBuilder.loadTexts: rcMltMib.setOrganization('Bay Networks, Rapid-City Group')
if mibBuilder.loadTexts: rcMltMib.setContactInfo('Yu-Ten Lee\n                         Postal:        Nortel Networks\n \t\t    4655 Great America Parkway\n                                               Santa Clara, CA 95052-8185\n\n                         Tel:              408-495-2560\n                         Fax:              408-495-6680\n                         E-mail:        ylee@nortelnetworks.com')
if mibBuilder.loadTexts: rcMltMib.setDescription('Enterprise MIB for the Accelar product family.')
rcStatMlt = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6))
rcStatMltIfExtnTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1), )
if mibBuilder.loadTexts: rcStatMltIfExtnTable.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnTable.setDescription('A table used to store Mlt interface\n                      statistics.')
rcStatMltIfExtnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcStatMltIfExtnMltId"))
if mibBuilder.loadTexts: rcStatMltIfExtnEntry.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnEntry.setDescription('Mlt interface statistics')
rcStatMltIfExtnMltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnMltId.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnMltId.setDescription('Mlt Id')
rcStatMltIfExtnIfInMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfInMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfInMulticastPkts.setDescription('multi-pkts to upper')
rcStatMltIfExtnIfInBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfInBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfInBroadcastPkts.setDescription('broad-pkts to upper')
rcStatMltIfExtnIfOutMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfOutMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfOutMulticastPkts.setDescription('multi-pkts from upper')
rcStatMltIfExtnIfOutBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfOutBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfOutBroadcastPkts.setDescription('broad-pkts from upper')
rcStatMltIfExtnIfHCInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInOctets.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInOctets.setDescription('The total number of octets received \n                       on the MLT interface, including framing \n                       characters.')
rcStatMltIfExtnIfHCInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInUcastPkts.setDescription('The number of packets delivered by this\n                       MLT to a higher MLT that were not addressed\n                       to a nulticast or broadcase address at this\n                       sublayer.')
rcStatMltIfExtnIfHCInMulticastPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInMulticastPkt.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInMulticastPkt.setDescription('The number of packets delivered to this MLT that\n                       were addressed to a nulticast address at this\n                       sublayer.  For a MAC layer protocol, this number\n                       includes both Group and Functional addresses.')
rcStatMltIfExtnIfHCInBroadcastPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInBroadcastPkt.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCInBroadcastPkt.setDescription('The number of packets delivered to this MLT that\n \t\t       were addressed to a broadcast address at this\n \t\t       sublayer.')
rcStatMltIfExtnIfHCOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutOctets.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutOctets.setDescription('The total number of octets transmitted \n                       out of the MLT interface, including \n                       framing characters.')
rcStatMltIfExtnIfHCOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutUcastPkts.setDescription('The number of packets that hight-level protocols\n                       requested be transmitted that were not addressed \n                       to a multicast address at this MLT.  This total\n                       number includes those packets discarded or unsent.')
rcStatMltIfExtnIfHCOutMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutMulticast.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutMulticast.setDescription('The total number of packets that hight-level\n                       protocols requested be transmitted, and that \n                       were addressed to a multicast address at this\n                       MLT, including those that were discarded or \n                       not sent.  For a MAC layer protocol, this\n                       number includes both Group and Functional\n                       addresses.')
rcStatMltIfExtnIfHCOutBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutBroadcast.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfExtnIfHCOutBroadcast.setDescription('The total number of packets that hight-level\n\t\t       protocols requested be transmitted, and that\n\t\t       were addressed to a broadcase address at this\t\n\t\t       MLT, including those that were discarded or \n\t\t       not sent.')
rcStatMltEtherTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2), )
if mibBuilder.loadTexts: rcStatMltEtherTable.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherTable.setDescription('A table used to store Mlt Ethernet\n                      statistics.')
rcStatMltEtherEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcStatMltEtherMltId"))
if mibBuilder.loadTexts: rcStatMltEtherEntry.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherEntry.setDescription('Mlt enternet statistics')
rcStatMltEtherMltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherMltId.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherMltId.setDescription('A value that uniquely identifies the Multi-Link \n                       Trunk associated with this entry.')
rcStatMltEtherAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherAlignmentErrors.setDescription('A count of frames received on a particular MLT\n \t\t       that are not an integral number of octets in\n\t\t       length and do not pass the FCS check.  The count\n\t\t       represented by an instance of this object is\n\t\t       incremented when the alignmentError status is\n\t\t       returned by the MAC service to the LLC (or other\n\t\t       MAC user).  Received frames for which multiple\n\t \t       error conditions occur are, according to the \n\t\t       conventions of IEEE 802.3 Layer Management, \n\t\t       counted exclusively according to the error status\n\t\t       presented to the LLC.')
rcStatMltEtherFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherFCSErrors.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherFCSErrors.setDescription('A count of frames received on an MLT that are an\n\t               integral number of octets in length but do not pass\n                       the FCS check.  The count represented by an instance\n                       of this object is incremented when the frameCheckError\n                       status is returned by the MAC service to the LLC\n                       (or other MAC user).  Received frames for which\n\t\t       multiple error conditions occur are, according to \n                       the conventions of IEEE 802.3 Layer Management, \n\t\t       counted exclusively according to the error status\n\t\t       presented to the LLC.')
rcStatMltEtherSingleCollFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherSingleCollFrames.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherSingleCollFrames.setDescription('A count of successfully transmitted frames on \n                       a particular MLT for which transmission is \n                       inhibited by exactly one collision.  A frame \n                       that is counted by an instance of this objects \n                       is also counted by the corresponding instance \n                       of either the ifOutUcastPkts, ifOutMulticastPkts, \n                       or ifOutBroadcastPkts, and it not counted by the \n                       corresponding instance of the MultipleCollisionFrames \n                       object.')
rcStatMltEtherMultipleCollFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherMultipleCollFrames.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherMultipleCollFrames.setDescription('A count of successfully transmitted frames on \n                       a particular MLT for which transmission is \n                       inhibited by more than one collision.  A frame \n                       that is counted by an instance of this object \n                       is also counted by the corresponding instance \n                       of either the ifOutUcastPkts, ifOutMulticastPkts, \n                       or ifOutBroadcastPkts, and is not counted by the \n                       corresponding instance of the SingleCollisionFrames \n                       objects.')
rcStatMltEtherSQETestError = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherSQETestError.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherSQETestError.setDescription('A count of times that the SQE TEST ERROR message\n\t\t       is generated by the PLS sublayer for a particular\n\t               MLT. SQE stands for Signal Quality Error.')
rcStatMltEtherDeferredTransmiss = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherDeferredTransmiss.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherDeferredTransmiss.setDescription('A count of frames for which the first transmission\n\t               attempt on a particular MLT is delayed because the\n                       medium is busy.  The count represented by an \n\t               instance of this object does not include frames\n\t\t       involved in collisions.')
rcStatMltEtherLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherLateCollisions.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherLateCollisions.setDescription('The number of times that a collision is detected \n                       on a particular MLT later than 512 bit-times \n                       (64 octets) into the transmission of a packet. \n                       Five hundred and twelve bit-times corresponds to \n                       51.2 microseconds on a 10 mb/s system.  A (late) \n                       collision included in a count represented by an \n                       instance of this object is also considered as a\n                       (generic) collision for purposes of other \n                       collision-related statistics.')
rcStatMltEtherExcessiveCollis = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherExcessiveCollis.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherExcessiveCollis.setDescription('A count of frames for which transmission on a \n\t               particular MLT fails due to excessive collisions.')
rcStatMltEtherIMacTransmitError = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherIMacTransmitError.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherIMacTransmitError.setDescription('A count of frames for which transmission on a \n\t               particular MLT fails due to an internal MAC \n                       sublayer transmit error.  A frame is only counted \n                       by an instance of this object if it is not counted\n                       by the corresponding instance of either the \n\t\t       LateCollisions object, the ExcessiveCollisions\n\t\t       object, or the CarrierSenseError object.')
rcStatMltEtherCarrierSenseError = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherCarrierSenseError.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherCarrierSenseError.setDescription('The number of times that the carrier sense \n                       condition was lost or never asserted when \n                       attempting to transmit a frame on a particular\n                       MLT.  The count represented by an instance of\n\t               this object is incremented at most once per\n\t\t       transmission attempt, even if the carrier\n\t\t       sense condition fluctuates during a \n\t\t       transmission attempt.')
rcStatMltEtherFrameTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherFrameTooLong.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherFrameTooLong.setDescription('A count of frames received on a particular MLT\n                       that exceed the maximum permitted size (1518 \n                       octets).  The count represented by an instance\n\t\t       os this object is incremented when the frame\n\t               TooLong status is returned by the MAC service\n\t\t       to the LLC (or other MAC user).  Received frames\n\t\t       for which multiple error conditions occur are, \n\t\t       according to the conventions of IEEE 802.3 \n                       Layer Management, counted exclusively according\n\t\t       to the error status presented to the LLC.')
rcStatMltEtherIMacReceiveError = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltEtherIMacReceiveError.setStatus('current')
if mibBuilder.loadTexts: rcStatMltEtherIMacReceiveError.setDescription('A count of frames for which reception on a \n\t\t       particular MLT fails due to an internal MAC\n\t\t       sublayer receive error.  A frame is only\n\t\t       counted by an instance of this object if it \n\t\t       is not counted by the corresponding instance \n\t\t       of either the FrameTooLongs object, the\n\t               AlignmentErrors object, of the FCSErrors\n\t               objects.\n                       The precise meaning of the count represented\n\t\t       by an instance of this object is implementation\n\t               specific.  In particular, an instance of this\n\t               object may represent a count of receive errors\n                       on a particular interface that are not otherwise\n\t\t       counted.')
rcStatMltIpTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3), )
if mibBuilder.loadTexts: rcStatMltIpTable.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpTable.setDescription('A table used to store Mlt Ip statistics.')
rcStatMltIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcStatMltIpMltId"))
if mibBuilder.loadTexts: rcStatMltIpEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpEntry.setDescription('Mlt enternet statistics')
rcStatMltIpMltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpMltId.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpMltId.setDescription('Mlt Id')
rcStatMltIpInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInReceives.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInReceives.setDescription('all incoming packets')
rcStatMltIpInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInHdrErrors.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInHdrErrors.setDescription('hdr errors detected')
rcStatMltIpInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInAddrErrors.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInAddrErrors.setDescription('bad dest. ip addr')
rcStatMltIpForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpForwDatagrams.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpForwDatagrams.setDescription('packets forwarded')
rcStatMltIpInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInUnknownProtos.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInUnknownProtos.setDescription('unsupported protocol')
rcStatMltIpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInDiscards.setDescription('good, but no buffer')
rcStatMltIpInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpInDelivers.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpInDelivers.setDescription('pkts delivered to upper')
rcStatMltIpOutRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpOutRequest.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpOutRequest.setDescription('pkts received from upper')
rcStatMltIpOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpOutDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpOutDiscards.setDescription('good, but no buffer')
rcStatMltIpOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpOutNoRoutes.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpOutNoRoutes.setDescription('no route to destination')
rcStatMltIpReasmReqds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpReasmReqds.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpReasmReqds.setDescription('fragments to reassem')
rcStatMltIpReasmOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpReasmOKs.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpReasmOKs.setDescription('reassembled successfully')
rcStatMltIpReasmFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpReasmFails.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpReasmFails.setDescription('reassembly failures')
rcStatMltIpFragOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpFragOKs.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpFragOKs.setDescription('fragment successfully')
rcStatMltIpFragFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpFragFails.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpFragFails.setDescription('fragment failure')
rcStatMltIpFragCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpFragCreates.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpFragCreates.setDescription('pkts due to fragmenting')
rcStatMltIpRoutingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIpRoutingDiscards.setStatus('deprecated')
if mibBuilder.loadTexts: rcStatMltIpRoutingDiscards.setDescription('Route entries removed')
rcStatSmltIstDownCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltIstDownCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltIstDownCnt.setDescription('Counters that counts how the session between the\n                       two peering switches has done down since last boot.')
rcStatSmltHelloTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltHelloTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltHelloTxMsgCnt.setDescription('Counters that counts the tx hello msg.')
rcStatSmltHelloRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltHelloRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltHelloRxMsgCnt.setDescription('Counters that counts the rx hello msg.')
rcStatSmltLearnMacAddrTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltLearnMacAddrTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltLearnMacAddrTxMsgCnt.setDescription('Counters that counts the tx learn Mac Address msg.')
rcStatSmltLearnMacAddrRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltLearnMacAddrRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltLearnMacAddrRxMsgCnt.setDescription('Counters that counts the rx learn Mac Address msg.')
rcStatSmltMacAddrAgeOutTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeOutTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeOutTxMsgCnt.setDescription('Counters that counts the tx Mac Address Aging Out msg.')
rcStatSmltMacAddrAgeOutRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeOutRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeOutRxMsgCnt.setDescription('Counters that counts the rx Mac Address Aging Out msg.')
rcStatSmltMacAddrAgeExpTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeExpTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeExpTxMsgCnt.setDescription('Counters that counts the tx Mac Address age expired msg.')
rcStatSmltMacAddrAgeExpRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeExpRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltMacAddrAgeExpRxMsgCnt.setDescription('Counters that counts the rx Mac Address age expired msg.')
rcStatSmltStgInfoTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltStgInfoTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltStgInfoTxMsgCnt.setDescription('Counters that counts the tx Stg information msg.')
rcStatSmltStgInfoRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltStgInfoRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltStgInfoRxMsgCnt.setDescription('Counters that counts the rx Stg information msg.')
rcStatSmltDelMacAddrTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltDelMacAddrTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltDelMacAddrTxMsgCnt.setDescription('Counters that counts the tx deleted MAC address msg.')
rcStatSmltDelMacAddrRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltDelMacAddrRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltDelMacAddrRxMsgCnt.setDescription('Counters that counts the rx deleted MAC address msg.')
rcStatSmltSmltDownTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSmltDownTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSmltDownTxMsgCnt.setDescription('Counters that counts the tx Smlt Down msg.')
rcStatSmltSmltDownRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSmltDownRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSmltDownRxMsgCnt.setDescription('Counters that counts the rx Smlt Down msg.')
rcStatSmltSmltUpTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSmltUpTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSmltUpTxMsgCnt.setDescription('Counters that counts the tx Smlt Up msg.')
rcStatSmltSmltUpRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSmltUpRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSmltUpRxMsgCnt.setDescription('Counters that counts the rx Smlt Up msg.')
rcStatSmltSendMacTblTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSendMacTblTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSendMacTblTxMsgCnt.setDescription('Counters that counts the tx Send Mac Table msg.')
rcStatSmltSendMacTblRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltSendMacTblRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltSendMacTblRxMsgCnt.setDescription('Counters that counts the rx Send Mac Table msg.')
rcStatSmltIgmpTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltIgmpTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltIgmpTxMsgCnt.setDescription('Counters that counts the tx Igmp msg.')
rcStatSmltIgmpRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltIgmpRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltIgmpRxMsgCnt.setDescription('Counters that counts the rx Igmp msg.')
rcStatSmltPortDownTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltPortDownTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltPortDownTxMsgCnt.setDescription('Counters that counts the tx port down msg.')
rcStatSmltPortDownRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltPortDownRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltPortDownRxMsgCnt.setDescription('Counters that counts the rx port down msg.')
rcStatSmltReqMacTblTxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltReqMacTblTxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltReqMacTblTxMsgCnt.setDescription('Counters that counts the tx request Mac table msg.')
rcStatSmltReqMacTblRxMsgCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltReqMacTblRxMsgCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltReqMacTblRxMsgCnt.setDescription('Counters that counts the rx request Mac table msg.')
rcStatSmltRxUnknownMsgTypeCnt = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatSmltRxUnknownMsgTypeCnt.setStatus('current')
if mibBuilder.loadTexts: rcStatSmltRxUnknownMsgTypeCnt.setDescription('Counters that counts the rx unknown msg type.')
rcStatMltIfUtilTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30), )
if mibBuilder.loadTexts: rcStatMltIfUtilTable.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilTable.setDescription('A table used to store Mlt interface utilization.')
rcStatMltIfUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcStatMltIfUtilMltId"))
if mibBuilder.loadTexts: rcStatMltIfUtilEntry.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilEntry.setDescription('Mlt interface utilization')
rcStatMltIfUtilMltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: rcStatMltIfUtilMltId.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilMltId.setDescription('To assign an Id within the range specified to the  \n                        Mlt created ')
rcStatMltIfUtilIfHCInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCInOctets.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCInOctets.setDescription('The total number of octets received\n                         on the MLT interface, including framing characters.')
rcStatMltIfUtilIfHCInUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCInUtil.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCInUtil.setDescription('The best estimate of the mean physical layer network\n                        utilization on this interface during this interval, \n                        in percent.')
rcStatMltIfUtilIfHCOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCOutOctets.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCOutOctets.setDescription('The total number of octets transmitted out of the\n                          MLT interface, including framing characters.')
rcStatMltIfUtilIfHCOutUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 12, 6, 30, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCOutUtil.setStatus('current')
if mibBuilder.loadTexts: rcStatMltIfUtilIfHCOutUtil.setDescription('The best estimate of the mean physical layer network\n                           utilization on this interface during this interval, \n                           in percent.')
rcMltNumMlts = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltNumMlts.setStatus('current')
if mibBuilder.loadTexts: rcMltNumMlts.setDescription('The number of MLTs currently defined in the switch.')
rcMltPotentialMembers = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 2), PortSet()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltPotentialMembers.setStatus('current')
if mibBuilder.loadTexts: rcMltPotentialMembers.setDescription('The set of ports that are not members of any MLT.')
rcMltIstSessionEnable = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 3), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltIstSessionEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltIstSessionEnable.setDescription('Used to enable/disable mlt functionality.')
rcMltIstSessionStatus = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltIstSessionStatus.setStatus('current')
if mibBuilder.loadTexts: rcMltIstSessionStatus.setDescription('Used to enable/disable mlt functionality.')
rcMltIstPeerIp = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltIstPeerIp.setStatus('current')
if mibBuilder.loadTexts: rcMltIstPeerIp.setDescription('IST mlt Peer Ip address.')
rcMltIstVlanId = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltIstVlanId.setStatus('current')
if mibBuilder.loadTexts: rcMltIstVlanId.setDescription('IST mlt Vlan Id.')
rcMltTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10), )
if mibBuilder.loadTexts: rcMltTable.setStatus('current')
if mibBuilder.loadTexts: rcMltTable.setDescription('A list of Multi-Link Trunk entries. The number of \n                      \tentries is given by rcMltNumMlts.')
rcMltEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcMltId"))
if mibBuilder.loadTexts: rcMltEntry.setStatus('current')
if mibBuilder.loadTexts: rcMltEntry.setDescription('Entry containing configuration information for a \n                      \tparticular Multi-Link Trunk.')
rcMltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltId.setStatus('current')
if mibBuilder.loadTexts: rcMltId.setDescription('A value that uniquely identifies the Multi-Link \n                      \tTrunk associated with this entry.')
rcMltName = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltName.setStatus('current')
if mibBuilder.loadTexts: rcMltName.setDescription('An administratively-assigned name for this MLT.')
rcMltPortMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 3), PortSet()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltPortMembers.setStatus('current')
if mibBuilder.loadTexts: rcMltPortMembers.setDescription('The set of ports that are members of this MLT.')
rcMltPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("trunk", 2))).clone('access')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltPortType.setStatus('current')
if mibBuilder.loadTexts: rcMltPortType.setDescription('The type of MLT port: access(1) or trunk(2).')
rcMltNumVlanIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltNumVlanIds.setStatus('current')
if mibBuilder.loadTexts: rcMltNumVlanIds.setDescription('Used to indicate the number of VLAN IDs that\n                      \tare stored in the rcMltVlanIds variable.')
rcMltVlanIds = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 6), IdList().subtype(subtypeSpec=ValueSizeConstraint(0, 8192))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltVlanIds.setStatus('current')
if mibBuilder.loadTexts: rcMltVlanIds.setDescription('An array used to identify which VLANs this MLT \n                      \tis associated with.  Each VLAN ID is stored as a \n\t\t      \ttwo octet value. The first octet in the pair holds\n                      \tbits 15-8 of the VLAN ID, while the second octet\n                      \tholds bits 7-0 of the VLAN ID.')
rcMltRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcMltRowStatus.setDescription('Used to create/delete entries in the rcMltTable.')
rcMltEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltEnable.setDescription('Enable the entry.')
rcMltLoadBalance = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltLoadBalance.setStatus('current')
if mibBuilder.loadTexts: rcMltLoadBalance.setDescription('Perform load balance?')
rcMltDistributionAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("basic", 2), ("advanced", 3))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltDistributionAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rcMltDistributionAlgorithm.setDescription('The load balancing algorithm.')
rcMltIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltIfIndex.setStatus('current')
if mibBuilder.loadTexts: rcMltIfIndex.setDescription("Used to indicate the 'logical' ifIndex assigned to\n                      this MLT.")
rcMltMltType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normalMLT", 1), ("istMLT", 2), ("splitMLT", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltMltType.setStatus('current')
if mibBuilder.loadTexts: rcMltMltType.setDescription('MLT type.')
rcMltSmltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltSmltId.setStatus('current')
if mibBuilder.loadTexts: rcMltSmltId.setDescription('Split MLT id.')
rcMltRunningType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normalMLT", 1), ("istMLT", 2), ("splitMLT", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltRunningType.setStatus('current')
if mibBuilder.loadTexts: rcMltRunningType.setDescription('Split MLT running type.')
rcMltSvlanPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("uni", 2), ("nni", 3))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltSvlanPortType.setStatus('current')
if mibBuilder.loadTexts: rcMltSvlanPortType.setDescription('Set MLT port type.')
rcMltMulticastDistribution = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 16), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltMulticastDistribution.setStatus('current')
if mibBuilder.loadTexts: rcMltMulticastDistribution.setDescription('Enable/Disable multicast distribution per mlt.')
rcMltLacp10gBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 17), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltLacp10gBackup.setStatus('current')
if mibBuilder.loadTexts: rcMltLacp10gBackup.setDescription('Enable/Disable 10G Mlt reliance backup mode.')
rcMltAggregatable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 18), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltAggregatable.setStatus('current')
if mibBuilder.loadTexts: rcMltAggregatable.setDescription('Enable/Disable link aggregation on a MLT.')
rcMltClearLinkAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("none", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltClearLinkAggregate.setStatus('current')
if mibBuilder.loadTexts: rcMltClearLinkAggregate.setDescription('clear link aggregate, equivalent to disable and \n                       re-enable aggregatable on the MLT.')
rcMltNtStgEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 20), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltNtStgEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltNtStgEnable.setDescription('Indicates whether this MLT is operating in\n                         Nortel Mode or in Cisco Mode.\n                         true = Nortel Mode\n                         false = Cisco Mode.')
rcMltDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 21), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltDesignatedPort.setStatus('current')
if mibBuilder.loadTexts: rcMltDesignatedPort.setDescription('Indicates the Designated port for the MLT.')
rcMltAggOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 22), EnableValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltAggOperState.setStatus('current')
if mibBuilder.loadTexts: rcMltAggOperState.setDescription('Link aggregation state on a MLT.')
rcMltAggTimeOfLastOperChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcMltAggTimeOfLastOperChange.setStatus('current')
if mibBuilder.loadTexts: rcMltAggTimeOfLastOperChange.setDescription('The time value since the interface entered its\n                       current operational state.')
rcMltVplsMgmtVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 10, 1, 24), EnableValue().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rcMltVplsMgmtVlan.setStatus('current')
if mibBuilder.loadTexts: rcMltVplsMgmtVlan.setDescription('Management Vlan is configured on this mlt')
rcMltMcastDistribution = MibIdentifier((1, 3, 6, 1, 4, 1, 2272, 1, 17, 11))
rcMltMcastDistributionEnable = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 11, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltMcastDistributionEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltMcastDistributionEnable.setDescription('Used to enable/disable this feature to\n                       distribute multicast traffic on MLT ports. All\n                       the cards in the system must be E-Tickets.\n                       Cannot perform distribution in a mixed mode.')
rcMltMcastDistributionGrpMask = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 11, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltMcastDistributionGrpMask.setStatus('current')
if mibBuilder.loadTexts: rcMltMcastDistributionGrpMask.setDescription('Group Mask. Create a MLT abstraction layer to\n                       distribute traffic basd on (source, group) information\n                       of the multicast packet. The algorithm to pick\n                       the actual port nedds to generate a fairly random\n                       number for different combinations but a lways generate\n                       the same number for a given (source, group) pair. By\n                       default, the number of active ports of the MLT is used\n                       to MOD the pseudo-random number generated by the XOR\n                       of each byte of the masked group address with the\n                       masked source address.')
rcMltMcastDistributionSrcMask = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 11, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltMcastDistributionSrcMask.setStatus('current')
if mibBuilder.loadTexts: rcMltMcastDistributionSrcMask.setDescription('Source Mask.')
rcMltMcastDistributionRedistributionEnable = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 17, 11, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltMcastDistributionRedistributionEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltMcastDistributionRedistributionEnable.setDescription('Enable redistribution.')
rcSltPortTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12), )
if mibBuilder.loadTexts: rcSltPortTable.setStatus('current')
if mibBuilder.loadTexts: rcSltPortTable.setDescription('')
rcSltPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcSltPortIfIndex"))
if mibBuilder.loadTexts: rcSltPortEntry.setStatus('current')
if mibBuilder.loadTexts: rcSltPortEntry.setDescription('Entry containing configuration information for a \n                        particular Multi-Link Trunk.')
rcSltPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcSltPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: rcSltPortIfIndex.setDescription('An interface for this SLT.')
rcSltPortSmltId = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcSltPortSmltId.setStatus('current')
if mibBuilder.loadTexts: rcSltPortSmltId.setDescription('A uniquely identifies the Single-Link\n                        Trunk associated with this entry.')
rcSltPortOperType = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("smlt", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcSltPortOperType.setStatus('current')
if mibBuilder.loadTexts: rcSltPortOperType.setDescription('The current operate type of the port normal\n                       or smlt.')
rcSltPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 12, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcSltPortRowStatus.setStatus('current')
if mibBuilder.loadTexts: rcSltPortRowStatus.setDescription('Used to create/delete entries of the Table.')
rcMltVlacpTable = MibTable((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13), )
if mibBuilder.loadTexts: rcMltVlacpTable.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpTable.setDescription('Mlt Virtual LACP table')
rcMltVlacpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1), ).setIndexNames((0, "RC-MLT-MIB", "rcMltId"))
if mibBuilder.loadTexts: rcMltVlacpEntry.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpEntry.setDescription('Entry containing info. for a particular port')
rcMltVlacpAdminEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltVlacpAdminEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpAdminEnable.setDescription('Administratively enable/disable Virtual LACP on a MLT')
rcMltVlacpFastPeriodicTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1, 2), Integer32().clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltVlacpFastPeriodicTimer.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpFastPeriodicTimer.setDescription('The number of miliseconds between periodic transmissions\n                       using Short Timeouts')
rcMltVlacpTimeoutScale = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1, 3), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltVlacpTimeoutScale.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpTimeoutScale.setDescription('Scalar value used to calculate timeout time from\n                       periodic time. Timeout = PeriodicTime * TimeoutScale')
rcMltVlacpEtherMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltVlacpEtherMacAddress.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpEtherMacAddress.setDescription("Multicast Mac Address exclusively used for VLACPDU's")
rcMltVlacpDualHomingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2272, 1, 17, 13, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcMltVlacpDualHomingEnable.setStatus('current')
if mibBuilder.loadTexts: rcMltVlacpDualHomingEnable.setDescription('Enable/Disable Dual homing on Virtual LACP on a MLT')
rcLinkFlapDetectAutoPortDownEnable = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 27, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcLinkFlapDetectAutoPortDownEnable.setStatus('current')
if mibBuilder.loadTexts: rcLinkFlapDetectAutoPortDownEnable.setDescription('Used to enable/disable the Link Flap Detect\n\t\t\tfeature.  When enabled this feature will monitor\n\t\t\tthe number of times a port goes down during a\n\t\t\tcertain interval.  If the number exceeds a given\n\t\t\tbound the port will be forced out-of-service.')
rcLinkFlapDetectSendTrap = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 27, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcLinkFlapDetectSendTrap.setStatus('current')
if mibBuilder.loadTexts: rcLinkFlapDetectSendTrap.setDescription('Used to configure whether a trap should be\n\t\t\tsent if the port is forced out-of-service.')
rcLinkFlapDetectFrequency = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 27, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcLinkFlapDetectFrequency.setStatus('current')
if mibBuilder.loadTexts: rcLinkFlapDetectFrequency.setDescription('Used to configure the number of times the port\n\t\t\tcan go down.')
rcLinkFlapDetectInterval = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 27, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcLinkFlapDetectInterval.setStatus('current')
if mibBuilder.loadTexts: rcLinkFlapDetectInterval.setDescription('Used to configure the interval (in minutes).')
rcL2RedundancyHaCpuState = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 32, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("initialization", 0), ("oneWayActive", 1), ("twoWayActive", 2), ("synchronized", 3), ("remoteIncompatible", 4), ("error", 5), ("disabled", 6), ("peerNotConnected", 7), ("peerConnected", 8), ("lostPeerConnection", 9), ("notSynchronized", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcL2RedundancyHaCpuState.setStatus('current')
if mibBuilder.loadTexts: rcL2RedundancyHaCpuState.setDescription('Indicate the Ha-CPU state. \n                         initialization - indicate the CPU is in this state. \n                         oneWayActive - Modules that need to be \n                         synchronized have registered with the framework (either \n                         locally or a message was received from remote CPU (1). \n                         twoWayActive - Modules that need to be synchronized have \n                         registered with the framework (either locally or a message \n                         was received from remote CPU (2). \n                         synchronized  - Table based synchroniztion was completed \n                         on the current CPU (3).  \n                         remoteIncompatible - CPUs framework version is incompatible \n                         with the remote CPU (4). \n                         error  - If an invalid event is generated in a given state the \n                         CPU enters Error state (5). \n                         disabled - High Availability is not enabled (6).\n                         peerNotConnected - no peer connection is established (7).\n                         peerConnected - peer connection is established (8).\n                         lostPeerConnection - lost connection to peer/Standby CPU (9).\n                         notSynchronized - Table Sync is not complete (10).')
rcL2RedundancyHaEvent = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 32, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("restart", 0), ("systemRegistrationDone", 1), ("tableSynchronizationDone", 2), ("versionIncompatible", 3), ("noEvent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcL2RedundancyHaEvent.setStatus('current')
if mibBuilder.loadTexts: rcL2RedundancyHaEvent.setDescription('Indicate the Ha event status. \n                         restart (0) - Causes the state machine to restart \n                         systemRegistrationDone (1)- Causes the CPU to transfer to \n                         One Way or Two Way Active state. Locally or message received \n                         from remote CPU.  \n                         tableSynchronizationDone (2) - Causes the CPU to \n                         transfer to Synchronized state. \n                         versionIncompatible (3) - Causes the CPU to go to Remote \n                         Incompatible state \n                         noEvent (4) - Means no event has occured uptill now. ')
rcL2RedundancyEnable = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 32, 3), EnableValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rcL2RedundancyEnable.setStatus('current')
if mibBuilder.loadTexts: rcL2RedundancyEnable.setDescription('Indicate the feature enable/disable.')
rcL2RedundancyStandbyCpu = MibScalar((1, 3, 6, 1, 4, 1, 2272, 1, 32, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hotStandbyCPU", 1), ("warmStandbyCPU", 2), ("standbyCPUNotPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rcL2RedundancyStandbyCpu.setStatus('current')
if mibBuilder.loadTexts: rcL2RedundancyStandbyCpu.setDescription('Indicate if the L2 Redundancy is enabled on the standby CPU.')
mibBuilder.exportSymbols("RC-MLT-MIB", rcMltMcastDistributionEnable=rcMltMcastDistributionEnable, rcStatMltIpReasmOKs=rcStatMltIpReasmOKs, rcStatMltEtherFCSErrors=rcStatMltEtherFCSErrors, rcStatSmltSendMacTblRxMsgCnt=rcStatSmltSendMacTblRxMsgCnt, rcStatSmltStgInfoRxMsgCnt=rcStatSmltStgInfoRxMsgCnt, rcMltMcastDistributionGrpMask=rcMltMcastDistributionGrpMask, rcLinkFlapDetectFrequency=rcLinkFlapDetectFrequency, rcMltVlacpAdminEnable=rcMltVlacpAdminEnable, rcMltIstPeerIp=rcMltIstPeerIp, rcMltVlacpEntry=rcMltVlacpEntry, rcStatMltIfExtnIfInBroadcastPkts=rcStatMltIfExtnIfInBroadcastPkts, rcStatSmltPortDownRxMsgCnt=rcStatSmltPortDownRxMsgCnt, rcMltId=rcMltId, rcMltLoadBalance=rcMltLoadBalance, rcStatSmltHelloRxMsgCnt=rcStatSmltHelloRxMsgCnt, rcStatSmltSmltDownTxMsgCnt=rcStatSmltSmltDownTxMsgCnt, rcStatSmltLearnMacAddrTxMsgCnt=rcStatSmltLearnMacAddrTxMsgCnt, rcMltEnable=rcMltEnable, rcMltNtStgEnable=rcMltNtStgEnable, rcSltPortEntry=rcSltPortEntry, rcStatMltIfExtnEntry=rcStatMltIfExtnEntry, rcStatMltEtherCarrierSenseError=rcStatMltEtherCarrierSenseError, rcMltRowStatus=rcMltRowStatus, rcStatMltEtherDeferredTransmiss=rcStatMltEtherDeferredTransmiss, rcStatMltEtherLateCollisions=rcStatMltEtherLateCollisions, rcStatSmltSmltUpTxMsgCnt=rcStatSmltSmltUpTxMsgCnt, rcStatMltEtherSingleCollFrames=rcStatMltEtherSingleCollFrames, rcStatMltIpForwDatagrams=rcStatMltIpForwDatagrams, rcStatMltIfUtilEntry=rcStatMltIfUtilEntry, rcStatMltIfExtnTable=rcStatMltIfExtnTable, rcStatMltIfExtnIfHCInOctets=rcStatMltIfExtnIfHCInOctets, rcMltMltType=rcMltMltType, rcMltTable=rcMltTable, rcStatMltIpReasmReqds=rcStatMltIpReasmReqds, rcMltAggregatable=rcMltAggregatable, rcMltIfIndex=rcMltIfIndex, rcStatMltIfExtnIfHCOutBroadcast=rcStatMltIfExtnIfHCOutBroadcast, rcSltPortIfIndex=rcSltPortIfIndex, rcLinkFlapDetectInterval=rcLinkFlapDetectInterval, rcStatMltIpInDiscards=rcStatMltIpInDiscards, rcStatSmltDelMacAddrTxMsgCnt=rcStatSmltDelMacAddrTxMsgCnt, rcL2RedundancyStandbyCpu=rcL2RedundancyStandbyCpu, PYSNMP_MODULE_ID=rcMltMib, rcMltVlacpFastPeriodicTimer=rcMltVlacpFastPeriodicTimer, rcMltRunningType=rcMltRunningType, rcMltMcastDistribution=rcMltMcastDistribution, rcStatSmltSmltDownRxMsgCnt=rcStatSmltSmltDownRxMsgCnt, rcStatSmltReqMacTblRxMsgCnt=rcStatSmltReqMacTblRxMsgCnt, rcStatMltIfUtilIfHCOutOctets=rcStatMltIfUtilIfHCOutOctets, rcMltNumMlts=rcMltNumMlts, rcMltNumVlanIds=rcMltNumVlanIds, rcStatMltIpInUnknownProtos=rcStatMltIpInUnknownProtos, rcLinkFlapDetectSendTrap=rcLinkFlapDetectSendTrap, rcStatMltEtherMultipleCollFrames=rcStatMltEtherMultipleCollFrames, rcSltPortOperType=rcSltPortOperType, rcSltPortRowStatus=rcSltPortRowStatus, rcMltVlacpEtherMacAddress=rcMltVlacpEtherMacAddress, rcStatMltEtherMltId=rcStatMltEtherMltId, rcStatMltIfExtnIfHCInMulticastPkt=rcStatMltIfExtnIfHCInMulticastPkt, rcL2RedundancyHaCpuState=rcL2RedundancyHaCpuState, rcMltMulticastDistribution=rcMltMulticastDistribution, rcMltName=rcMltName, rcMltMcastDistributionRedistributionEnable=rcMltMcastDistributionRedistributionEnable, rcStatSmltIgmpTxMsgCnt=rcStatSmltIgmpTxMsgCnt, rcStatMltIfExtnIfOutBroadcastPkts=rcStatMltIfExtnIfOutBroadcastPkts, rcStatMltIpReasmFails=rcStatMltIpReasmFails, rcSltPortTable=rcSltPortTable, rcStatSmltHelloTxMsgCnt=rcStatSmltHelloTxMsgCnt, rcStatMltIpFragOKs=rcStatMltIpFragOKs, rcMltSmltId=rcMltSmltId, rcStatMltIpOutNoRoutes=rcStatMltIpOutNoRoutes, rcMltMcastDistributionSrcMask=rcMltMcastDistributionSrcMask, rcStatMltIfUtilIfHCOutUtil=rcStatMltIfUtilIfHCOutUtil, rcStatSmltPortDownTxMsgCnt=rcStatSmltPortDownTxMsgCnt, rcStatMltIpFragFails=rcStatMltIpFragFails, rcStatMltEtherTable=rcStatMltEtherTable, rcStatMltIpFragCreates=rcStatMltIpFragCreates, rcStatMltIfUtilIfHCInUtil=rcStatMltIfUtilIfHCInUtil, rcStatSmltSmltUpRxMsgCnt=rcStatSmltSmltUpRxMsgCnt, rcMltVlacpDualHomingEnable=rcMltVlacpDualHomingEnable, rcStatSmltReqMacTblTxMsgCnt=rcStatSmltReqMacTblTxMsgCnt, rcStatMltIfExtnMltId=rcStatMltIfExtnMltId, rcStatMltIfExtnIfHCInUcastPkts=rcStatMltIfExtnIfHCInUcastPkts, rcMltPortMembers=rcMltPortMembers, rcStatMltEtherAlignmentErrors=rcStatMltEtherAlignmentErrors, rcStatSmltRxUnknownMsgTypeCnt=rcStatSmltRxUnknownMsgTypeCnt, rcStatMltIfExtnIfHCOutMulticast=rcStatMltIfExtnIfHCOutMulticast, rcStatMltIfUtilTable=rcStatMltIfUtilTable, rcMltVlanIds=rcMltVlanIds, rcMltDistributionAlgorithm=rcMltDistributionAlgorithm, rcStatMltIpInReceives=rcStatMltIpInReceives, rcStatMltIfUtilMltId=rcStatMltIfUtilMltId, rcStatMltIpInAddrErrors=rcStatMltIpInAddrErrors, rcStatMlt=rcStatMlt, rcStatMltIpTable=rcStatMltIpTable, rcMltPortType=rcMltPortType, rcMltVplsMgmtVlan=rcMltVplsMgmtVlan, rcStatMltIfExtnIfHCOutOctets=rcStatMltIfExtnIfHCOutOctets, rcMltAggTimeOfLastOperChange=rcMltAggTimeOfLastOperChange, rcMltMib=rcMltMib, rcMltPotentialMembers=rcMltPotentialMembers, rcMltIstVlanId=rcMltIstVlanId, rcLinkFlapDetectAutoPortDownEnable=rcLinkFlapDetectAutoPortDownEnable, rcMltLacp10gBackup=rcMltLacp10gBackup, rcSltPortSmltId=rcSltPortSmltId, rcStatSmltDelMacAddrRxMsgCnt=rcStatSmltDelMacAddrRxMsgCnt, rcStatMltEtherSQETestError=rcStatMltEtherSQETestError, rcStatSmltIstDownCnt=rcStatSmltIstDownCnt, rcMltIstSessionEnable=rcMltIstSessionEnable, rcStatMltIpEntry=rcStatMltIpEntry, rcL2RedundancyHaEvent=rcL2RedundancyHaEvent, rcStatSmltMacAddrAgeOutTxMsgCnt=rcStatSmltMacAddrAgeOutTxMsgCnt, rcStatMltIpRoutingDiscards=rcStatMltIpRoutingDiscards, rcStatSmltMacAddrAgeOutRxMsgCnt=rcStatSmltMacAddrAgeOutRxMsgCnt, rcStatMltEtherFrameTooLong=rcStatMltEtherFrameTooLong, rcMltEntry=rcMltEntry, rcMltVlacpTable=rcMltVlacpTable, rcStatMltIfExtnIfHCOutUcastPkts=rcStatMltIfExtnIfHCOutUcastPkts, rcStatSmltStgInfoTxMsgCnt=rcStatSmltStgInfoTxMsgCnt, rcStatSmltIgmpRxMsgCnt=rcStatSmltIgmpRxMsgCnt, rcMltDesignatedPort=rcMltDesignatedPort, rcStatMltEtherEntry=rcStatMltEtherEntry, rcL2RedundancyEnable=rcL2RedundancyEnable, rcStatMltIfExtnIfInMulticastPkts=rcStatMltIfExtnIfInMulticastPkts, rcStatMltIfUtilIfHCInOctets=rcStatMltIfUtilIfHCInOctets, rcStatSmltMacAddrAgeExpRxMsgCnt=rcStatSmltMacAddrAgeExpRxMsgCnt, rcStatMltIfExtnIfHCInBroadcastPkt=rcStatMltIfExtnIfHCInBroadcastPkt, rcStatSmltSendMacTblTxMsgCnt=rcStatSmltSendMacTblTxMsgCnt, rcStatMltIpInHdrErrors=rcStatMltIpInHdrErrors, rcStatMltIpOutRequest=rcStatMltIpOutRequest, rcStatSmltLearnMacAddrRxMsgCnt=rcStatSmltLearnMacAddrRxMsgCnt, rcMltVlacpTimeoutScale=rcMltVlacpTimeoutScale, rcStatMltEtherIMacTransmitError=rcStatMltEtherIMacTransmitError, rcMltAggOperState=rcMltAggOperState, rcStatMltIpInDelivers=rcStatMltIpInDelivers, rcMltIstSessionStatus=rcMltIstSessionStatus, rcMltSvlanPortType=rcMltSvlanPortType, rcStatMltIpMltId=rcStatMltIpMltId, rcStatMltIpOutDiscards=rcStatMltIpOutDiscards, rcStatMltEtherIMacReceiveError=rcStatMltEtherIMacReceiveError, rcMltClearLinkAggregate=rcMltClearLinkAggregate, rcStatSmltMacAddrAgeExpTxMsgCnt=rcStatSmltMacAddrAgeExpTxMsgCnt, rcStatMltIfExtnIfOutMulticastPkts=rcStatMltIfExtnIfOutMulticastPkts, rcStatMltEtherExcessiveCollis=rcStatMltEtherExcessiveCollis)
