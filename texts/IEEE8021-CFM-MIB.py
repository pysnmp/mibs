#
# PySNMP MIB module IEEE8021-CFM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/standard/iee/IEEE8021-CFM-MIB
# Produced by pysmi-1.1.12 at Mon Jul 29 02:30:51 2024
# On host fv-az654-133 platform Linux version 6.5.0-1024-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
IEEE8021VlanIndex, ieee802dot1mibs = mibBuilder.importSymbols("IEEE8021-TC-MIB", "IEEE8021VlanIndex", "ieee802dot1mibs")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
LldpChassisId, LldpChassisIdSubtype, LldpPortIdSubtype, LldpPortId = mibBuilder.importSymbols("LLDP-MIB", "LldpChassisId", "LldpChassisIdSubtype", "LldpPortIdSubtype", "LldpPortId")
VlanId, VlanIdOrNone = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "VlanIdOrNone")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Counter64, Unsigned32, Gauge32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Bits, iso, Counter32, TimeTicks, NotificationType, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter64", "Unsigned32", "Gauge32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Bits", "iso", "Counter32", "TimeTicks", "NotificationType", "ModuleIdentity")
TAddress, TimeStamp, TextualConvention, MacAddress, TDomain, RowStatus, TruthValue, DisplayString, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "TAddress", "TimeStamp", "TextualConvention", "MacAddress", "TDomain", "RowStatus", "TruthValue", "DisplayString", "TimeInterval")
ieee8021CfmMib = ModuleIdentity((1, 3, 111, 2, 802, 1, 1, 8))
ieee8021CfmMib.setRevisions(('2011-02-27 00:00', '2008-11-18 00:00', '2008-10-15 00:00', '2007-06-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ieee8021CfmMib.setRevisionsDescriptions(('Addition of support for ICC format and minor edits\n         as part of 2011 revision of IEEE Std 802.1Q.', 'Added new columns to the dot1agCfmMepTable to support new\n       MEP functionality required for PBB-TE support.  Modified\n       dot1agCfmMepDbTable to support new functionality requried\n       for PBB-TE.  Modified conformance clauses to indicate objects\n       needed for PBB-TE support.', 'The IEEE8021-CFM-MIB Module was originally included in IEEE \n       802.1ag-2007. Some objects in this module are deprecated and \n       replaced by objects in the IEEE8021-CFM-V2-MIB module\n       defined in 802.1ap.\n\n       This revision is included in IEEE 802.1ap', 'Included in IEEE 802.1ag-2007\n\n        Copyright (C) IEEE802.1.',))
if mibBuilder.loadTexts: ieee8021CfmMib.setLastUpdated('201102270000Z')
if mibBuilder.loadTexts: ieee8021CfmMib.setOrganization('IEEE 802.1 Working Group')
if mibBuilder.loadTexts: ieee8021CfmMib.setContactInfo('WG-URL:   http://grouper.ieee.org/groups/802/1/index.html\n        WG-EMail: stds-802-1@ieee.org \n\n        Contact:  David Elie-Dit-Cosaque\n           Postal: C/O IEEE 802.1 Working Group\n                   IEEE Standards Association\n                   445 Hoes Lane\n                   P.O. Box 1331\n                   Piscataway\n                   NJ 08855-1331\n                   USA\n           E-mail: STDS-802-1-L@LISTSERV.IEEE.ORG\n\n        Contact:  Norman Finn\n           Postal: C/O IEEE 802.1 Working Group\n                   IEEE Standards Association\n                   445 Hoes Lane\n                   P.O. Box 1331\n                   Piscataway\n                   NJ 08855-1331\n                   USA\n           E-mail: STDS-802-1-L@LISTSERV.IEEE.ORG\n       ')
if mibBuilder.loadTexts: ieee8021CfmMib.setDescription('Connectivity Fault Management module.\n\n       Unless otherwise indicated, the references in this MIB\n       module are to IEEE 802.1Q-2011.\n\n       Copyright (C) IEEE.\n       This version of this MIB module is part of IEEE802.1Q;\n       see the draft itself for full legal notices.')
dot1agNotifications = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 0))
dot1agMIBObjects = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1))
dot1agCfmConformance = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2))
dot1agCfmStack = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 1))
dot1agCfmDefaultMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 2))
dot1agCfmVlan = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 3))
dot1agCfmConfigErrorList = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 4))
dot1agCfmMd = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 5))
dot1agCfmMa = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 6))
dot1agCfmMep = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 1, 7))
class Dot1agCfmMaintDomainNameType(TextualConvention, Integer32):
    reference = '21.6.5, Table 21-19'
    description = 'A value that represents a type (and thereby the format)\n        of a Dot1agCfmMaintDomainName.  The value can be one of\n        the following:\n\n\n        ieeeReserved(0)   Reserved for definition by IEEE 802.1\n                          recommend to not use zero unless\n                          absolutely needed.\n        none(1)           No format specified, usually because\n                          there is not (yet) a Maintenance\n                          Domain Name. In this case, a zero\n                          length OCTET STRING for the Domain\n                          Name field is acceptable.\n        dnsLikeName(2)    Domain Name like string, globally unique\n                          text string derived from a DNS name.\n        macAddrAndUint(3) MAC address + 2-octet (unsigned) integer.\n        charString(4)     RFC2579 DisplayString, except that the\n                          character codes 0-31 (decimal) are not\n                          used.\n        ieeeReserved(xx)  Reserved for definition by IEEE 802.1\n                          xx values can be [5..31] and [64..255]\n        ituReserved(xx)   Reserved for definition by  ITU-T Y.1731\n                          xx values range from [32..63]\n\n        To support future extensions, the Dot1agCfmMaintDomainNameType\n        textual convention SHOULD NOT be sub-typed in object type\n        definitions.  It MAY be sub-typed in compliance statements in\n        order to require only a subset of these address types for a\n        compliant implementation.\n\n        Implementations MUST ensure that Dot1agCfmMaintDomainNameType\n        objects and any dependent objects (e.g.,\n        Dot1agCfmMaintDomainName objects) are consistent.  An\n        inconsistentValue error MUST be generated if an attempt to\n        change an Dot1agCfmMaintDomainNameType object would, for\n        example, lead to an undefined Dot1agCfmMaintDomainName value.\n        In particular,\n        Dot1agCfmMaintDomainNameType/Dot1agCfmMaintDomainName pairs\n        MUST be changed together if the nameType changes.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("none", 1), ("dnsLikeName", 2), ("macAddressAndUint", 3), ("charString", 4))

class Dot1agCfmMaintDomainName(TextualConvention, OctetString):
    reference = '21.6.5'
    description = "Denotes a generic Maintenance Domain Name.\n\n        A Dot1agCfmMaintDomainName value is always interpreted within\n        the context of a Dot1agCfmMaintDomainNameType value.  Every\n        usage of the Dot1agCfmMaintDomainName textual convention is\n        required to specify the Dot1agCfmMaintDomainNameType object\n        that provides the context.  It is suggested that the\n        Dot1agCfmMaintDomainNameType object be logically registered\n        before the object(s) that use the Dot1agCfmMaintDomainName\n        textual convention, if they appear in the same logical row.\n\n        The value of a Dot1agCfmMaintDomainName object MUST always\n        be consistent with the value of the associated\n        Dot1agCfmMaintDomainNameType object. Attempts to set\n        an Dot1agCfmMaintDomainName object to a value inconsistent\n        with the associated Dot1agCfmMaintDomainNameType MUST fail\n        with an inconsistentValue error.\n\n        When this textual convention is used as the syntax of an\n        index object, there may be issues with the limit of 128\n        sub-identifiers specified in SMIv2, IETF STD 58.  In this\n        case, the object definition MUST include a 'SIZE' clause\n        to limit the number of potential instance sub-identifiers;\n        otherwise the applicable constraints MUST be stated in\n        the appropriate conceptual row DESCRIPTION clauses, or\n        in the surrounding documentation if there is no single\n        DESCRIPTION clause that is appropriate.\n\n        A value of none(1) in the associated\n        Dot1agCfmMaintDomainNameType object means that no Maintenance\n        Domain name is present, and the contents of the\n        Dot1agCfmMaintDomainName object are meaningless.\n\n        See the DESCRIPTION of the Dot1agCfmMaintAssocNameType\n        TEXTUAL-CONVENTION for a discussion of the length limits on\n        the Maintenance Domain name and Maintenance Association name.\n       "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 43)

class Dot1agCfmMaintAssocNameType(TextualConvention, Integer32):
    reference = '21.6.5.4, Table 21-20'
    description = 'A value that represents a type (and thereby the format)\n        of a Dot1agCfmMaintAssocName.  The value can be one of\n        the following:\n\n        ieeeReserved(0)   Reserved for definition by IEEE 802.1\n                          recommend to not use zero unless\n                          absolutely needed.\n        primaryVid(1)     Primary VLAN ID.\n                          12 bits represented in a 2-octet integer:\n                          - 4 least significant bits of the first\n                            byte contains the 4 most significant \n                            bits of the 12 bits primary VID\n                          - second byte contains the 8 least\n                            significant bits of the primary VID\n\n                                 0 1 2 3 4 5 6 7 8\n                                 +-+-+-+-+-+-+-+-+\n                                 |0 0 0 0| (MSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VID   LSB    |\n                                 +-+-+-+-+-+-+-+-+\n\n        charString(2)     RFC2579 DisplayString, except that the\n                          character codes 0-31 (decimal) are not\n                          used. (1..45) octets\n        unsignedInt16 (3) 2-octet integer/big endian\n        rfc2865VpnId(4)   RFC 2685 VPN ID\n                          3 octet VPN authority Organizationally\n                          Unique Identifier followed by 4 octet VPN\n                          index identifying VPN according to the OUI:\n\n                                 0 1 2 3 4 5 6 7 8\n                                 +-+-+-+-+-+-+-+-+\n                                 | VPN OUI (MSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |   VPN OUI     |\n                                 +-+-+-+-+-+-+-+-+\n                                 | VPN OUI (LSB) |\n                                 +-+-+-+-+-+-+-+-+\n                                 |VPN Index (MSB)|\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VPN Index    |\n                                 +-+-+-+-+-+-+-+-+\n                                 |  VPN Index    |\n                                 +-+-+-+-+-+-+-+-+\n                                 |VPN Index (LSB)|\n                                 +-+-+-+-+-+-+-+-+\n\n        ieeeReserved(xx)  Reserved for definition by IEEE 802.1\n                          xx values can be [5..31] and [64..255]\n        ICCformat(32)     ICC-based format as specified in ITU-T Y.1731\n        ituReserved(xx)   Reserved for definition by  ITU-T Y.1731\n                          xx values range from [33..63]\n\n        To support future extensions, the Dot1agCfmMaintAssocNameType\n        textual convention SHOULD NOT be sub-typed in object type\n        definitions.  It MAY be sub-typed in compliance statements in\n        order to require only a subset of these address types for a\n        compliant implementation.\n\n        Implementations MUST ensure that Dot1agCfmMaintAssocNameType\n        objects and any dependent objects (e.g.,\n        Dot1agCfmMaintAssocName objects) are consistent.  An\n        inconsistentValue error MUST be generated if an attempt to\n        change an Dot1agCfmMaintAssocNameType object would, for\n        example, lead to an undefined Dot1agCfmMaintAssocName value.\n        In particular,\n        Dot1agCfmMaintAssocNameType/Dot1agCfmMaintAssocName pairs\n        MUST be changed together if the nameType changes.\n\n        The Maintenance Domain name and Maintenance Association name,\n        when put together into the CCM PDU, MUST total 48 octets or\n        less.  If the Dot1agCfmMaintDomainNameType object contains\n        none(1), then the Dot1agCfmMaintAssocName object MUST be\n        45 octets or less in length.  Otherwise, the length of\n        the Dot1agCfmMaintDomainName object plus the length of the\n        Dot1agCfmMaintAssocName object, added together, MUST total\n        less than or equal to 44 octets.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 32))
    namedValues = NamedValues(("primaryVid", 1), ("charString", 2), ("unsignedInt16", 3), ("rfc2865VpnId", 4), ("iccFormat", 32))

class Dot1agCfmMaintAssocName(TextualConvention, OctetString):
    reference = '802.1ag clauses 21.6.5.4, 21.6.5.5, 21.6.5.6'
    description = "Denotes a generic Maintenance Association Name. It is the\n        part of the Maintenance Association Identifier which is\n        unique within the Maintenance Domain Name and is appended\n        to the Maintenance Domain Name to form the Maintenance\n        Association Identifier (MAID).\n\n        A Dot1agCfmMaintAssocName value is always interpreted within\n        the context of a Dot1agCfmMaintAssocNameType value.  Every\n        usage of the Dot1agCfmMaintAssocName textual convention is\n        required to specify the Dot1agCfmMaintAssocNameType object\n        that provides the context.  It is suggested that the\n        Dot1agCfmMaintAssocNameType object be logically registered\n        before the object(s) that use the Dot1agCfmMaintAssocName\n        textual convention, if they appear in the same logical row.\n\n        The value of a Dot1agCfmMaintAssocName object MUST \n        always be consistent with the value of the associated\n        Dot1agCfmMaintAssocNameType object. Attempts to set\n        an Dot1agCfmMaintAssocName object to a value inconsistent\n        with the associated Dot1agCfmMaintAssocNameType MUST fail\n        with an inconsistentValue error.\n\n        When this textual convention is used as the syntax of an\n        index object, there may be issues with the limit of 128\n        sub-identifiers specified in SMIv2, IETF STD 58.  In this\n        case, the object definition MUST include a 'SIZE' clause\n        to limit the number of potential instance sub-identifiers;\n        otherwise the applicable constraints MUST be stated in\n        the appropriate conceptual row DESCRIPTION clauses, or\n        in the surrounding documentation if there is no single\n        DESCRIPTION clause that is appropriate.\n       "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 45)

class Dot1agCfmMDLevel(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 21.4.1'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\n        Higher numbers correspond to higher Maintenance Domains,\n        those with the greatest physical reach, with the highest\n        values for customers' CFM PDUs.  Lower numbers correspond\n        to lower Maintenance Domains, those with more limited\n        physical reach, with the lowest values for CFM PDUs\n        protecting single bridges or physical links.\n       "
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 7)

class Dot1agCfmMDLevelOrNone(TextualConvention, Integer32):
    reference = '802.1ag clauses 18.3, 12.14.3.1.3:c'
    description = "Integer identifying the Maintenance Domain Level (MD Level).\n        Higher numbers correspond to higher Maintenance Domains,\n        those with the greatest physical reach, with the highest\n        values for customers' CFM packets.  Lower numbers correspond\n        to lower Maintenance Domains, those with more limited\n        physical reach, with the lowest values for CFM PDUs\n        protecting single bridges or physical links.\n\n        The value (-1) is reserved to indicate that no MA Level has\n        been assigned.\n       "
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 7), )
class Dot1agCfmMpDirection(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.3.2:c'
    description = 'Indicates the direction in which the Maintenance\n        association (MEP or MIP) faces on the bridge port:\n\n        down(1)    Sends Continuity Check Messages away from the\n                   MAC Relay Entity.\n        up(2)      Sends Continuity Check Messages towards the\n                   MAC Relay Entity.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("down", 1), ("up", 2))

class Dot1agCfmPortStatus(TextualConvention, Integer32):
    reference = '12.14.7.6.3:f, 20.19.3 and 21.5.4'
    description = 'An enumerated value from he Port Status TLV from the last CCM\n        received from the last MEP. It indicates the ability of the\n        Bridge Port on which the transmitting MEP resides to pass\n        ordinary data, regardless of the status of the MAC\n        (Table 21-10).\n\n        psNoPortStateTLV(0) Indicates either that no CCM has been\n                            received or that no port status TLV was\n                            present in the last CCM received.\n\n        psBlocked(1)        Ordinary data cannot pass freely through\n                            the port on which the remote MEP resides.\n                            Value of enableRmepDefect is equal to\n                            false.\n\n        psUp(2):            Ordinary data can pass freely through\n                            the port on which the remote MEP resides.\n                            Value of enableRmepDefect is equal to\n                            true.\n\n        NOTE: A 0 value is used for psNoPortStateTLV, so that\n              additional code points can be added in a manner\n              consistent with the Dot1agCfmInterfaceStatus textual\n              convention.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("psNoPortStateTLV", 0), ("psBlocked", 1), ("psUp", 2))

class Dot1agCfmInterfaceStatus(TextualConvention, Integer32):
    reference = '12.14.7.6.3:g, 20.19.4 and 21.5.5'
    description = 'An enumerated value from the Interface Status TLV from the \n        last CCM received from the last MEP. It indicates the status\n        of the Interface within which the MEP transmitting the CCM\n        is configured, or the next lower Interface in the Interface\n        Stack, if the MEP is not configured within an Interface.\n\n    isNoInterfaceStatusTLV(0)  Indicates either that no CCM has been\n                          received or that no interface status TLV\n                          was present in the last CCM received.\n\n    isUp(1)               The interface is ready to pass packets.\n\n    isDown(2)             The interface cannot pass packets\n\n    isTesting(3)          The interface is in some test mode.\n   \n    isUnknown(4)          The interface status cannot be determined\n                          for some reason.\n\n    isDormant(5)          The interface is not in a state to pass\n                          packets but is in a pending state, waiting\n                          for some external event.\n    \n    isNotPresent(6)       Some component of the interface is missing\n    \n    isLowerLayerDown(7)   The interface is down due to state of the\n                          lower layer interfaces\n\n        NOTE: A 0 value is used for isNoInterfaceStatusTLV, so that\n              these code points can be kept consistent with new code\n              points added to ifOperStatus in the IF-MIB.\n\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("isNoInterfaceStatusTLV", 0), ("isUp", 1), ("isDown", 2), ("isTesting", 3), ("isUnknown", 4), ("isDormant", 5), ("isNotPresent", 6), ("isLowerLayerDown", 7))

class Dot1agCfmHighestDefectPri(TextualConvention, Integer32):
    reference = '20.1.2, 12.14.7.7.2:c and 20.33.9'
    description = 'An enumerated value, equal to the contents of the variable\n        highestDefect (20.33.9 and Table 20-1), indicating the\n        highest-priority defect that has been present since the MEP\n        Fault Notification Generator State Machine was last in the \n        FNG_RESET state, either:\n\n        none(0)           no defects since FNG_RESET\n        defRDICCM(1)      DefRDICCM\n        defMACstatus(2)   DefMACstatus\n        defRemoteCCM(3)   DefRemoteCCM\n        defErrorCCM(4)    DefErrorCCM\n        defXconCCM(5)     DefXconCCM\n\n        The value 0 is used for no defects so that additional higher\n        priority values can be added, if needed, at a later time, and\n        so that these values correspond with those in\n        Dot1agCfmLowestAlarmPri.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 0), ("defRDICCM", 1), ("defMACstatus", 2), ("defRemoteCCM", 3), ("defErrorCCM", 4), ("defXconCCM", 5))

class Dot1agCfmLowestAlarmPri(TextualConvention, Integer32):
    reference = '12.14.7.1.3:k and 20.9.5'
    description = 'An integer value specifying the lowest priority defect\n        that is allowed to generate a Fault Alarm (20.9.5), either:\n\n        allDef(1)           DefRDICCM, DefMACstatus, DefRemoteCCM,\n                            DefErrorCCM, and DefXconCCM;\n        macRemErrXcon(2)    Only DefMACstatus, DefRemoteCCM,\n                            DefErrorCCM, and DefXconCCM (default);\n        remErrXcon(3)       Only DefRemoteCCM, DefErrorCCM,\n                            and DefXconCCM;\n        errXcon(4)          Only DefErrorCCM and DefXconCCM;\n        xcon(5)             Only DefXconCCM; or\n        noXcon(6)           No defects DefXcon or lower are to be\n                            reported;\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("allDef", 1), ("macRemErrXcon", 2), ("remErrXcon", 3), ("errXcon", 4), ("xcon", 5), ("noXcon", 6))

class Dot1agCfmMepId(TextualConvention, Unsigned32):
    reference = '802.1ag clauses 3.19 and 19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n        integer, unique over a given Maintenance Association,\n        identifying a specific MEP.\n       '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 8191)

class Dot1agCfmMepIdOrZero(TextualConvention, Unsigned32):
    reference = '19.2.1'
    description = 'Maintenance association End Point Identifier (MEPID): A small\n        integer, unique over a given Maintenance Association,\n        identifying a specific MEP.\n \n        The special value 0 is allowed to indicate special cases, for\n        example that no MEPID is configured.\n\n        Whenever an object is defined with this SYNTAX, then the\n        DESCRIPTION clause of such an object MUST specify what the\n        special value of 0 means.\n       '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), )
class Dot1agCfmMhfCreation(TextualConvention, Integer32):
    reference = '12.14.5.1.3:c and 22.2.3'
    description = 'Indicates if the Management Entity can create MHFs.\n        The valid values are:\n\n        defMHFnone(1)      No MHFs can be created for this VID.\n        defMHFdefault(2)   MHFs can be created on this VID on any\n                           Bridge port through which this VID can\n                           pass.\n        defMHFexplicit(3)  MHFs can be created for this VID only on\n                           Bridge ports through which this VID can\n                           pass, and only if a MEP is created at some\n                           lower MD Level.\n        defMHFdefer(4)     The creation of MHFs is determined by the\n                           corresponding Maintenance Domain variable\n                           (dot1agCfmMaCompMhfCreation).\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3), ("defMHFdefer", 4))

class Dot1agCfmIdPermission(TextualConvention, Integer32):
    reference = '12.14.6.1.3:d and 21.5.3'
    description = 'Indicates what, if anything, is to be included in the Sender\n        ID TLV transmitted in CCMs, LBMs, LTMs, and LTRs.  The valid\n        values are:\n\n        sendIdNone(1)      The Sender ID TLV is not to be sent.\n        sendIdChassis(2)   The Chassis ID Length, Chassis ID\n                           Subtype, and Chassis ID fields of  the\n                           Sender ID TLV are to be sent.\n        sendIdManage(3)    The Management Address Length and\n                           Management Address of the Sender ID TLV\n                           are to be sent.\n        sendIdChassisManage(4) The Chassis ID Length, Chassis ID\n                           Subtype, Chassis ID, Management Address\n                           Length and Management Address fields are\n                           all to be sent.\n        sendIdDefer(5)     The contents of the Sender ID TLV are\n                           determined by the corresponding\n                           Maintenance Domain variable\n                           (dot1agCfmMaCompIdPermission).\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4), ("sendIdDefer", 5))

class Dot1agCfmCcmInterval(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.6.1.3:e, 20.8.1 and 21.6.1.3'
    description = "Indicates the interval at which CCMs are sent by a MEP.\n        The possible values are:\n        intervalInvalid(0) No CCMs are sent (disabled).\n        interval300Hz(1)   CCMs are sent every 3 1/3 milliseconds\n                           (300Hz).\n        interval10ms(2)    CCMs are sent every 10 milliseconds.\n        interval100ms(3)   CCMs are sent every 100 milliseconds.\n        interval1s(4)      CCMs are sent every 1 second.\n        interval10s(5)     CCMs are sent every 10 seconds.\n        interval1min(6)    CCMs are sent every minute.\n        interval10min(7)   CCMs are sent every 10 minutes.\n\n        Note: enumerations start at zero to match the 'CCM Interval\n              field' protocol field.\n       "
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("intervalInvalid", 0), ("interval300Hz", 1), ("interval10ms", 2), ("interval100ms", 3), ("interval1s", 4), ("interval10s", 5), ("interval1min", 6), ("interval10min", 7))

class Dot1agCfmFngState(TextualConvention, Integer32):
    reference = '12.14.7.1.3:f and 20.35'
    description = 'Indicates the diferent states of the MEP Fault Notification\n        Generator State Machine.\n\n        fngReset(1)            No defect has been present since the\n                               dot1agCfmMepFngResetTime timer\n                               expired, or since the state machine\n                               was last reset.\n\n        fngDefect(2)           A defect is present, but not for a\n                               long enough time to be reported \n                               (dot1agCfmMepFngAlarmTime).\n\n        fngReportDefect(3)     A momentary state during which the\n                               defect is reported by sending a\n                               dot1agCfmFaultAlarm notification,\n                               if that action is enabled.\n\n        fngDefectReported(4)   A defect is present, and some defect\n                               has been reported.\n\n        fngDefectClearing(5)   No defect is present, but the\n                               dot1agCfmMepFngResetTime timer has\n                               not yet expired.\n       '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("fngReset", 1), ("fngDefect", 2), ("fngReportDefect", 3), ("fngDefectReported", 4), ("fngDefectClearing", 5))

class Dot1agCfmRelayActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.5, 21.9.5, and\n        Table 21-27'
    description = 'Possible values the Relay action field can take.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("rlyHit", 1), ("rlyFdb", 2), ("rlyMpdb", 3))

class Dot1agCfmIngressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:g, 20.36.2.6, 21.9.8.1, and\n        Table 21-30\n       '
    description = 'Possible values returned in the ingress action field.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("ingNoTlv", 0), ("ingOk", 1), ("ingDown", 2), ("ingBlocked", 3), ("ingVid", 4))

class Dot1agCfmEgressActionFieldValue(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.5.3:o, 20.36.2.10, 21.9.9.1, and\n        Table 21-32'
    description = 'Possible values returned in the egress action field'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("egrNoTlv", 0), ("egrOK", 1), ("egrDown", 2), ("egrBlocked", 3), ("egrVid", 4))

class Dot1agCfmRemoteMepState(TextualConvention, Integer32):
    reference = '802.1ag clauses 12.14.7.6.3:b, 20.22'
    description = 'Operational state of the remote MEP state machine.  This\n        state machine monitors the reception of valid CCMs from a\n        remote MEP with a specific MEPID.  It uses a timer that\n        expires in 3.5 times the length of time indicated by the\n        dot1agCfmMaNetCcmInterval object.\n\n        rMepIdle(1)            Momentary state during reset.\n\n        rMepStart(2)           The timer has not expired since the\n                               state machine was reset, and no valid\n                               CCM has yet been received.\n\n        rMepFailed(3)          The timer has expired, both since the\n                               state machine was reset, and since a\n                               valid CCM was received.\n\n        rMepOk(4)              The timer has not expired since a\n                               valid CCM was received.\n'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("rMepIdle", 1), ("rMepStart", 2), ("rMepFailed", 3), ("rMepOk", 4))

class Dot1afCfmIndexIntegerNextFree(TextualConvention, Unsigned32):
    description = 'An integer which may be used as a new Index in a table.\n\n       The special value of 0 indicates that no more new entries can\n       be created in the relevant table.\n\n       When a MIB is used for configuration, an object with this\n       SYNTAX always contains a legal value (if non-zero) for an\n       index that is not currently used in the relevant table. The\n       Command Generator (Network Management Application) reads this\n       variable and uses the (non-zero) value read when creating a\n       new row with an SNMP SET.  When the SET is performed, the\n       Command Responder (agent) MUST determine whether the value is\n       indeed still unused; Two Network Management Applications may\n       attempt to create a row (configuration entry) simultaneously\n       and use the same value. If it is currently unused, the SET\n       succeeds and the Command Responder (agent) changes the value\n       of this object, according to an implementation-specific\n       algorithm.  If the value is in use, however, the SET fails.\n       The Network Management Application MUST then re-read this\n       variable to obtain a new usable value.\n\n       An OBJECT-TYPE definition using this SYNTAX MUST specify the\n       relevant table for which the object is providing this\n       functionality.\n      '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

class Dot1agCfmMepDefects(TextualConvention, Bits):
    reference = '802.1ag clauses 12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q,\n        12.14.7.1.3:r, and 12.14.7.1.3:s.'
    description = 'A MEP can detect and report a number of defects, and multiple\n        defects can be present at the same time. These defects are:\n\n        bDefRDICCM(0) A remote MEP is reported the RDI bit in its\n                     last CCM.\n        bDefMACstatus(1) Either some remote MEP is reporting its\n                     Interface Status TLV as not isUp, or all remote\n                     MEPs are reporting a Port Status TLV that\n                     contains some value other than psUp.\n        bDefRemoteCCM(2) The MEP is not receiving valid CCMs from at\n                     least one of the remote MEPs.\n        bDefErrorCCM(3) The MEP has received at least one invalid CCM\n                     whose CCM Interval has not yet timed out.\n        bDefXconCCM(4) The MEP has received at least one CCM from\n                     either another MAID or a lower MD Level whose\n                     CCM Interval has not yet timed out.\n       '
    status = 'current'
    namedValues = NamedValues(("bDefRDICCM", 0), ("bDefMACstatus", 1), ("bDefRemoteCCM", 2), ("bDefErrorCCM", 3), ("bDefXconCCM", 4))

class Dot1agCfmConfigErrors(TextualConvention, Bits):
    reference = '12.14.4.1.3:b and clauses 22.2.3 and 22.2.4'
    description = "While making the MIP creation evaluation described in 802.1ag\n        clause 22.2.3, the management entity can encounter errors in\n        the configuration. These are possible errors that can be\n        encountered:\n\n        CFMleak(0)   MA x is associated with a specific VID list,\n                     one or more of the VIDs in MA x can pass through\n                     the Bridge Port, no Down MEP is configured on\n                     any Bridge Port for MA x, and some other MA y,\n                     at a higher MD Level than MA x, and associated\n                     with at least one of the VID(s) also in MA x,\n                     does have a MEP configured on the Bridge Port.\n\n        conflictingVids(1)  MA x is associated with a specific VID\n                     list, an Up MEP is configured on MA x on the\n                     Bridge Port, and some other MA y, associated\n                     with at least one of the VID(s) also in MA x,\n                     also has an Up MEP configured on some Bridge\n                     Port.\n\n        ExcessiveLevels(2)  The number of different MD Levels at\n                     which MIPs are to be created on this port\n                     exceeds the Bridge's capabilities (see\n                     subclause 22.3).\n\n        OverlappedLevels(3) A MEP is created for one VID at one MD\n                     Level, but a MEP is configured on another\n                     VID at that MD Level or higher, exceeding\n                     the Bridge's capabilities.\n       "
    status = 'current'
    namedValues = NamedValues(("cfmLeak", 0), ("conflictingVids", 1), ("excessiveLevels", 2), ("overlappedLevels", 3))

class Dot1agCfmPbbComponentIdentifier(TextualConvention, Unsigned32):
    reference = '12.3 l)'
    description = 'A Provider Backbone Bridge (PBB) can comprise a number of\n        components, each of which can be managed in a manner\n        essentially equivalent to an 802.1Q bridge.  In order to access\n        these components easily, an index is used in a number of\n        tables.  If any two tables are indexed by\n        Dot1agCfmPbbComponentIdentifier, then entries in those tables\n        indexed by the same value of Dot1agCfmPbbComponentIdentifier\n        correspond to the same component.\n       '
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

dot1agCfmStackTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1), )
if mibBuilder.loadTexts: dot1agCfmStackTable.setReference('802.1ag clauses 12.14.2')
if mibBuilder.loadTexts: dot1agCfmStackTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackTable.setDescription('There is one CFM Stack table per bridge. It permits\n        the retrieval of information about the Maintenance Points\n        configured on any given interface.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmStackifIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackVlanIdOrNone"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackMdLevel"), (0, "IEEE8021-CFM-MIB", "dot1agCfmStackDirection"))
if mibBuilder.loadTexts: dot1agCfmStackEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackEntry.setDescription('The Stack table entry\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n')
dot1agCfmStackifIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setReference('12.14.2.1.2:a')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackifIndex.setDescription('This object represents the  Bridge Port or aggregated port\n        on which MEPs or MHFs might be configured.\n\n        Upon a restart of the system, the system SHALL, if necessary,\n        change the value of this variable, and  rearrange the\n        dot1agCfmStackTable, so that it indexes the entry in the\n        interface table with the same value of ifAlias that it\n        indexed before the system restart.  If no such entry exists,\n        then the system SHALL delete all entries in the\n        dot1agCfmStackTable with the interface index.\n        **NOTE: this object is deprecated due to re-indexing of\n    the table.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackVlanIdOrNone = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 2), VlanIdOrNone())
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setReference('802.1ag clauses 12.14.2.1.2:d, 22.1.7')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackVlanIdOrNone.setDescription('VLAN ID to which the MP is attached, or 0, if none.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 3), Dot1agCfmMDLevel())
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setReference('12.14.2.1.2:b')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMdLevel.setDescription('MD Level of the Maintenance Point.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 4), Dot1agCfmMpDirection())
if mibBuilder.loadTexts: dot1agCfmStackDirection.setReference('12.14.2.1.2:c')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackDirection.setDescription('Direction in which the MP faces on the Bridge Port\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setReference('12.14.2.1.3:b')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMdIndex.setDescription('The index of the Maintenance Domain in the dot1agCfmMdTable\n        to which the MP is associated, or 0, if none.\n       ')
dot1agCfmStackMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setReference('12.14.2.1.3:c')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMaIndex.setDescription('The index of the MA in the dot1agCfmMaNetTable and\n        dot1agCfmMaCompTable to which the MP is associated, or 0, if\n        none.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmStackMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 7), Dot1agCfmMepIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMepId.setReference('12.14.2.1.3:d\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMepId.setDescription('If an MEP is configured, the MEPID, else 0')
dot1agCfmStackMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 1, 1, 1, 8), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setReference('12.14.2.1.3:e')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackMacAddress.setDescription('MAC address of the MP.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmVlanTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1), )
if mibBuilder.loadTexts: dot1agCfmVlanTable.setReference('802.1ag clauses 12.14.3.1.3:a, 12.14.3.2.2:a, 12.14.5.3.2:c,\n        12.14.6.1.3:b, 22.1.5.')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanTable.setDescription('This table defines the association of VIDs into VLANs.  There\n        is an entry in this table, for each component of the bridge,\n        for each VID that is:\n            a) a VID belonging to a VLAN associated with more than\n               one VID; and\n            b) not the Primary VLAN of that VID.\n        The entry in this table contains the Primary VID of the VLAN.\n\n        By default, this table is empty, meaning that every VID is\n        the Primary VID of a single-VID VLAN.\n\n        VLANs that are associated with only one VID SHOULD NOT have\n        an entry in this table.\n\n        The writable objects in this table need to be persistent\n        upon reboot or restart of a device.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmVlanEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmVlanComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmVlanVid"))
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanEntry.setDescription('The VLAN table entry.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmVlanComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanComponentId.setDescription('The bridge component within the system to which the information\n        in this dot1agCfmVlanEntry applies.  If the system is not a\n        Bridge, or if only one component is present in the Bridge, then\n        this variable (index) MUST be equal to 1.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmVlanVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 2), VlanId())
if mibBuilder.loadTexts: dot1agCfmVlanVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanVid.setDescription('This is a VLAN ID belonging to a VLAN that is associated with\n        more than one VLAN ID, and this is not the Primary VID of the\n        VLAN.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmVlanPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 3), VlanId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanPrimaryVid.setDescription("This is the Primary VLAN ID of the VLAN with which this\n        entry's dot1agCfmVlanVid is associated.  This value MUST not\n        equal the value of dot1agCfmVlanVid.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ")
dot1agCfmVlanRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns MUST have a valid value before a row\n        can be activated.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmDefaultMdDefLevel = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 1), Dot1agCfmMDLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setReference('12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefLevel.setDescription('A value indicating the MD Level at which MHFs are to be\n        created, and Sender ID TLV transmission by those MHFs is to\n        be controlled, for each dot1agCfmDefaultMdEntry whose\n        dot1agCfmDefaultMdLevel object contains the value -1.\n\n        After this initialization, this object needs to be persistent\n        upon reboot or restart of a device.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmDefaultMdDefMhfCreation = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))).clone('defMHFnone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setReference('12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefMhfCreation.setDescription('A value indicating if the Management entity can create MHFs\n        (MIP Half Function) for the VID, for each\n        dot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdMhfCreation\n        object contains the value defMHFdefer.  Since, in this\n        variable, there is no encompassing Maintenance Domain, the\n        value defMHFdefer is not allowed.\n\n        After this initialization, this object needs to be persistent\n        upon reboot or restart of a device.\n       ')
dot1agCfmDefaultMdDefIdPermission = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4))).clone('sendIdNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setReference('12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmDefaultMdDefIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\n        included in the Sender ID TLV (21.5.3) transmitted by MHFs\n        created by the Default Maintenance Domain, for each\n        dot1agCfmDefaultMdEntry whose dot1agCfmDefaultMdIdPermission\n        object contains the value sendIdDefer.  Since, in this\n        variable, there is no encompassing Maintenance Domain, the\n        value sendIdDefer is not allowed.\n\n        After this initialization, this object needs to be persistent\n        upon reboot or restart of a device.\n       ')
dot1agCfmDefaultMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4), )
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setReference(' 12.14.3')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdTable.setDescription("For each bridge component, the Default MD Level Managed Object\n        controls MHF creation for VIDs that are not attached to a\n        specific Maintenance Association Managed Object, and Sender ID\n        TLV transmission by those MHFs.\n\n        For each Bridge Port, and for each VLAN ID whose data can\n        pass through that Bridge Port, an entry in this table is\n        used by the algorithm in subclause 22.2.3 only if there is no\n        entry in the Maintenance Association table defining an MA\n        for the same VLAN ID and MD Level as this table's entry, and\n        on which MA an Up MEP is defined.  If there exists such an\n        MA, that MA's objects are used by the algorithm in\n        subclause 22.2.3 in place of this table entry's objects.  The\n        agent maintains the value of dot1agCfmDefaultMdStatus to\n        indicate whether this entry is overridden by an MA.\n\n        When first initialized, the agent creates this table\n        automatically with entries for all VLAN IDs,\n        with the default values specified for each object.\n\n        After this initialization, the writable objects in this\n        table need to be persistent upon reboot or restart of a\n        device.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ")
dot1agCfmDefaultMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmDefaultMdComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmDefaultMdPrimaryVid"))
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdEntry.setDescription('The Default MD Level table entry.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmDefaultMdComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdComponentId.setDescription('The bridge component within the system to which the information\n        in this dot1agCfmDefaultMdEntry applies.  If the system is not\n        a Bridge, or if only one component is present in the Bridge,\n        then this variable (index) MUST be equal to 1.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmDefaultMdPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 2), VlanId())
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdPrimaryVid.setDescription("The Primary VID of the VLAN to which this entry's objects\n        apply.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ")
dot1agCfmDefaultMdStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setReference('12.14.3.1.3:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdStatus.setDescription("State of this Default MD Level table entry.  True if there is\n        no entry in the Maintenance Association table defining an MA\n        for the same VLAN ID and MD Level as this table's entry, and\n        on which MA an Up MEP is defined, else false.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ")
dot1agCfmDefaultMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 4), Dot1agCfmMDLevelOrNone().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setReference('12.14.3.1.3:c, 12.14.3.2.2:b')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdLevel.setDescription("A value indicating the MD Level at which MHFs are to be\n        created, and Sender ID TLV transmission by those MHFs is to\n        be controlled, for the VLAN to which this entry's objects\n        apply.  If this object has the value -1, the MD Level for MHF\n        creation for this VLAN is controlled by\n        dot1agCfmDefaultMdDefLevel.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ")
dot1agCfmDefaultMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 5), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setReference('12.14.3.1.3:d')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdMhfCreation.setDescription('A value indicating if the Management entity can create MHFs\n        (MIP Half Function) for this VID at this MD Level.  If this\n        object has the value defMHFdefer, MHF creation for this VLAN\n        is controlled by dot1agCfmDefaultMdDefMhfCreation.\n\n        The value of this variable is meaningless if the values of\n        dot1agCfmDefaultMdStatus is false.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmDefaultMdIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 2, 4, 1, 6), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setReference('12.14.3.1.3:e')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\n        included in the Sender ID TLV (21.5.3) transmitted by MHFs\n        created by the Default Maintenance Domain.  If this object\n        has the value sendIdDefer, Sender ID TLV transmission for\n        this VLAN is controlled by dot1agCfmDefaultMdDefIdPermission.\n\n        The value of this variable is meaningless if the values of\n        dot1agCfmDefaultMdStatus is false.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmConfigErrorListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1), )
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setReference('12.14.4')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListTable.setDescription('The CFM Configuration Error List table provides a list of\n        Interfaces and VIDs that are incorrectly configured.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmConfigErrorListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListVid"), (0, "IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListIfIndex"))
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListEntry.setDescription('The Config Error List Table  entry\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmConfigErrorListVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 1), VlanId())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setReference('12.14.4.1.2:a')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListVid.setDescription('The VLAN ID of the VLAN with interfaces in error.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmConfigErrorListIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setReference('12.14.4.1.2:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListIfIndex.setDescription('This object is the IfIndex of the interface.\n\n        Upon a restart of the system, the system SHALL, if necessary,\n        change the value of this variable so that it indexes the\n        entry in the interface table with the same value of ifAlias\n        that it indexed before the system restart.  If no such\n        entry exists, then the system SHALL delete any entries in\n        dot1agCfmConfigErrorListTable indexed by that\n        InterfaceIndex value.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmConfigErrorListErrorType = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 4, 1, 1, 3), Dot1agCfmConfigErrors()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setReference('12.14.4.1.3:b')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListErrorType.setDescription('A vector of Boolean error conditions from 22.2.4, any of\n        which may be true:\n\n        0) CFMleak;\n        1) ConflictingVids;\n        2) ExcessiveLevels;\n        3) OverlappedLevels.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMdTableNextIndex = MibScalar((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 1), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTableNextIndex.setDescription('This object contains an unused value for dot1agCfmMdIndex in\n        the dot1agCfmMdTable, or a zero to indicate that none exist.\n       ')
dot1agCfmMdTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2), )
if mibBuilder.loadTexts: dot1agCfmMdTable.setReference('802.1ag clauses 3.22 and 18.1')
if mibBuilder.loadTexts: dot1agCfmMdTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdTable.setDescription('The Maintenance Domain table. Each row in the table\n        represents a different Maintenance Domain.\n\n        A Maintenance Domain is described in 802.1ag (3.22) as the\n        network or the part of the network for which faults in\n        connectivity are to be managed. The boundary of a Maintenance\n        Domain is defined by a set of DSAPs, each of which can become\n        a point of connectivity to a service instance.\n       ')
dot1agCfmMdEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"))
if mibBuilder.loadTexts: dot1agCfmMdEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdEntry.setDescription('The Maintenance Domain table entry. This entry is not lost\n        upon reboot. It is backed up by stable storage.\n       ')
dot1agCfmMdIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMdIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdIndex.setDescription('The index to the Maintenance Domain table.\n\n        dot1agCfmMdTableNextIndex needs to be inspected to find an\n        available index for row-creation.\n\n        Referential integrity is required, i.e., the index needs to be\n        persistent upon a reboot or restart of a device.  The index\n        can never be reused for other Maintenance Domain.  The index\n        value SHOULD keep increasing up to the time that they wrap\n        around. This is to facilitate access control based on OID.\n       ')
dot1agCfmMdFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 2), Dot1agCfmMaintDomainNameType().clone('charString')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdFormat.setReference('21.6.5.1')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdFormat.setDescription('The type (and thereby format) of the Maintenance Domain Name.')
dot1agCfmMdName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 3), Dot1agCfmMaintDomainName().clone('DEFAULT')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdName.setReference('802.1ag clauses 3.24, 12.14.5, and 21.6.5.3')
if mibBuilder.loadTexts: dot1agCfmMdName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdName.setDescription('The Maintenance Domain name. The type/format of this object\n        is determined by the value of the dot1agCfmMdNameType object.\n          \n        Each Maintenance Domain has unique name amongst all those\n        used or available to a service provider or operator.  It\n        facilitates easy identification of administrative\n        responsibility for each Maintenance Domain.\n\n        Clause 3.24 defines a Maintenance Domain name as the\n        identifier, unique over the domain for which CFM is to\n        protect against accidental concatenation of Service\n        Instances, of a particular Maintenance Domain.\n       ')
dot1agCfmMdMdLevel = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 4), Dot1agCfmMDLevel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setReference('12.14.5.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMdLevel.setDescription('The Maintenance Domain Level.')
dot1agCfmMdMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defMHFnone", 1), ("defMHFdefault", 2), ("defMHFexplicit", 3))).clone('defMHFnone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setReference('12.14.5.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfCreation.setDescription('Enumerated value indicating whether the management entity can\n        create MHFs (MIP Half Function) for this Maintenance Domain.\n        Since, in this variable, there is no encompassing Maintenance\n        Domain, the value defMHFdefer is not allowed.\n       ')
dot1agCfmMdMhfIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sendIdNone", 1), ("sendIdChassis", 2), ("sendIdManage", 3), ("sendIdChassisManage", 4))).clone('sendIdNone')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setReference('12.14.5.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMhfIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\n        included in the Sender ID TLV (21.5.3) transmitted by MPs\n        configured in this Maintenance Domain.  Since, in this\n        variable, there is no encompassing Maintenance Domain, the\n        value sendIdDefer is not allowed.\n       ')
dot1agCfmMdMaNextIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 7), Dot1afCfmIndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMdMaNextIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdMaNextIndex.setDescription('Value to be used as the index of the MA table entries, both\n        the dot1agCfmMaNetTable and the dot1agCfmMaCompTable, for\n        this Maintenance Domain when the management entity wants to\n        create a new row in those tables.\n       ')
dot1agCfmMdRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns MUST have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMaNetTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1), )
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setReference('18.2')
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetTable.setDescription('The Maintenance Association table.  Each row in the table\n        represents an MA.  An MA is a set of MEPs, each configured\n        with a single service instance.\n\n        This is the part of the complete MA table that is constant\n        across all Bridges in a Maintenance Domain, and across all\n        components of a single Bridge.  That part of the MA table that\n        can vary from Bridge component to Bridge component is contained\n        in the dot1agCfmMaCompTable.\n\n        Creation of a Service Instance establishes a connectionless\n        association among the selected DSAPs.  Configuring a\n        Maintenance association End Point (MEP) at each of the\n        DSAPs creates a Maintenance Association (MA) to monitor\n        that connectionless connectivity.  The MA is identified by a\n        Short MA Name that is unique within the Maintenance Domain\n        and chosen to facilitate easy identification of the Service\n        Instance.  Together, the Maintenance Domain Name and the\n        Short MA Name form the Maintenance Association Identifier\n        (MAID) that is carried in CFM Messages to identify\n        incorrect connectivity among Service Instances.  A small\n        integer, the Maintenance association End Point Identifier\n        (MEPID), identifies each MEP among those configured on a\n        single MA (802.1ag clauses 3.19 and 18.2).\n\n        This table uses two indices, first index is the index of the\n        Maintenance Domain table.  The second index is the same as the\n        index of the dot1agCfmMaCompEntry for the same MA.\n\n        The writable objects in this table need to be persistent\n        upon reboot or restart of a device.\n\n       ')
dot1agCfmMaNetEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaNetEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetEntry.setDescription('The MA table entry.')
dot1agCfmMaIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmMaIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaIndex.setDescription('Index of the MA table dot1agCfmMdMaNextIndex needs to\n        be inspected to find an available index for row-creation.\n       ')
dot1agCfmMaNetFormat = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 2), Dot1agCfmMaintAssocNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setReference('802.1ag clauses 21.6.5.4')
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetFormat.setDescription('The type (and thereby format) of the Maintenance Association\n        Name.\n       ')
dot1agCfmMaNetName = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 3), Dot1agCfmMaintAssocName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetName.setReference('802.1ag clauses 21.6.5.6, and Table 21-20')
if mibBuilder.loadTexts: dot1agCfmMaNetName.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetName.setDescription('The Short Maintenance Association name. The type/format of\n        this object is determined by the value of the\n        dot1agCfmMaNetNameType object.  This name MUST be unique within\n        a maintenance domain.\n       ')
dot1agCfmMaNetCcmInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 4), Dot1agCfmCcmInterval().clone('interval1s')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setReference('12.14.6.1.3:e')
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetCcmInterval.setDescription('Interval between CCM transmissions to be used by all MEPs\n        in the MA.\n       ')
dot1agCfmMaNetRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaNetRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaNetRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns MUST have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMaCompTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2), )
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setReference('18.2')
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompTable.setDescription('The Maintenance Association table.  Each row in the table\n        represents an MA.  An MA is a set of MEPs, each configured\n        with a single service instance.\n\n        This is the part of the complete MA table that is variable\n        across the Bridges in a Maintenance Domain, or across the\n        components of a single Bridge.  That part of the MA table that\n        is constant across the Bridges and their components in a\n        Maintenance Domain is contained in the dot1agCfmMaNetTable.\n\n        This table uses three indices, first index is the\n        Dot1agCfmPbbComponentIdentifier that identifies the component\n        within the Bridge for which the information in the\n        dot1agCfmMaCompEntry applies.  The second is the index of the\n        Maintenance Domain table.  The third index is the same as the\n        index of the dot1agCfmMaNetEntry for the same MA.\n\n        The writable objects in this table need to be persistent\n        upon reboot or restart of a device.\n\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMaComponentId"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"))
if mibBuilder.loadTexts: dot1agCfmMaCompEntry.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompEntry.setDescription('The MA table entry.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaComponentId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 1), Dot1agCfmPbbComponentIdentifier())
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setReference('12.3 l)')
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaComponentId.setDescription('The bridge component within the system to which the information\n        in this dot1agCfmMaCompEntry applies.  If the system is not a\n        Bridge, or if only one component is present in the Bridge, then\n        this variable (index) MUST be equal to 1.\n    **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompPrimaryVlanId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 2), VlanIdOrNone()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setReference('12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompPrimaryVlanId.setDescription('The Primary VLAN ID with which the Maintenance Association is\n        associated, or 0 if the MA is not attached to any VID.  If\n        the MA is associated with more than one VID, the\n        dot1agCfmVlanTable lists them.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompMhfCreation = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 3), Dot1agCfmMhfCreation().clone('defMHFdefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setReference('12.14.6.1.3:c')
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompMhfCreation.setDescription('Indicates if the Management entity can create MHFs (MIP Half\n        Function) for this MA.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompIdPermission = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 4), Dot1agCfmIdPermission().clone('sendIdDefer')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setReference('12.14.6.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompIdPermission.setDescription('Enumerated value indicating what, if anything, is to be\n        included in the Sender ID TLV (21.5.3) transmitted by MPs\n        configured in this MA.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompNumberOfVids = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setReference('12.14.6.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompNumberOfVids.setDescription('The number of VIDs associated with the MA.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaCompRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaCompRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaCompRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns MUST have a valid value before a row\n        can be activated.\n        **NOTE: this object is deprecated due to re-indexing of the \n    table.\n       ')
dot1agCfmMaMepListTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3), )
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setReference('12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListTable.setDescription("List of MEPIDs that belong to this MA.\n \n        Clause 12.14.6.1.3 specifies that a list of MEPIDs in all\n        bridges in that MA, but since SNMP SMI does not allow to\n        state in a MIB that an object in a table is an array, the \n        information has to be stored in another table with two\n        indices, being the first index, the index of the table that \n        contains the list or array.\n\n        For all bridges in which the same MAID {dot1agCfmMdFormat,\n        dot1agCfmMdName, dot1agCfmMaNetFormat, and dot1agCfmMaNetName}\n        is configured, the same set of dot1agCfmMaMepListIdentifiers\n        MUST be configured in the bridges' dot1agCfmMaMepListTables.\n        This allows each MEP to determine whether or not it is\n        receiving CCMs from all of the other MEPs in the MA.\n\n        For example, if one were creating a new MA whose MAID were\n        {charString, 'Dom1', charString, 'MA1'}, that had 2 MEPs, whose\n        MEPIDs were 1 and 3, one could, in Bridge A:\n         1. Get a new MD index d from dot1agCfmMdTableNextIndex.\n         2. Create the Maintenance Domain {charString, 'Dom1'}.\n         3. Get a new MA index a from dot1agCfmMdMaNextIndex [d].\n         4. Create the Maintenance Association {charString, 'MA1'}.\n         5. Create a new dot1agCfmMaMepListEntry for each of the MEPs\n            in the MA: [d, a, 1] and [d, a, 3].\n         6. Create one of the new MEPs, say [d, a, 1].\n        Then, in Bridge B:\n         7. Do all of these steps 1-6, except for using the other MEPID\n            for the new MEP in Step 6, in this example, MEPID 3.\n        Note that, when creating the MA, MEP List Table, and MEP\n        entries in the second bridge, the indices 'd' and 'a'\n        identifying the MAID {charString, 'Dom1', charString, 'MA1'}\n        may have different values than those in the first Bridge.\n       ")
dot1agCfmMaMepListEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaMepListIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListEntry.setDescription('The known MEPS table entry.')
dot1agCfmMaMepListIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setReference('12.14.6.1.3:g')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListIdentifier.setDescription('MEPID')
dot1agCfmMaMepListRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMaMepListRowStatus.setDescription('The status of the row. Read SNMPv2-TC (RFC1903) for an\n        explanation of the possible values this object can take.\n       ')
dot1agCfmMepTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1), )
if mibBuilder.loadTexts: dot1agCfmMepTable.setReference('802.1ag clauses 12.14.7 and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTable.setDescription('The Maintenance Association End Point (MEP) table.\n\n        Each row in the table represents a different MEP.  A MEP is\n        an actively managed CFM entity, associated with a specific\n        DSAP of a Service Instance, which can generate and receive\n        CFM PDUs and track any responses.  It is an end point of a\n        single Maintenance Association, and is an endpoint of a\n        separate Maintenance Entity for each of the other MEPs in\n        the same Maintenance Association (802.1ag clause 3.19).\n\n        This table uses three indices. The first two indices are the\n        indices of the Maintenance Domain and MA tables, the reason\n        being that a MEP is always related to an MA and Maintenance\n        Domain.\n\n        The MEP table also stores all the managed objects for sending\n        LBM and LTM.\n\n        *LBM Managed objects\n\n        LBM Managed objects in the MEP table\n        enables the management entity to initiate\n        transmission of Loopback messages.  It will signal the MEP\n        that it SHOULD transmit some number of Loopback messages\n        and detect the detection (or lack thereof) of the\n        corresponding Loopback messages.\n\n        Steps to use entries in this table:\n\n        1) Wait for dot1agCfmMepTransmitLbmStatus value to be\n           false.  To do this do this sequence:\n           a. an SNMP GET for both SnmpSetSerialNo and\n              dot1agCfmMepTransmitLbmStatus objects (in same SNMP\n              PDU).\n           b. Check if value for dot1agCfmMepTransmitLbmStatus is false.\n              - if not, wait x seconds, go to step a above.\n              - if yes, save the value of SnmpSetSerialNo and go\n                to step 2) below\n        2) Change dot1agCfmMepTransmitLbmStatus value from false to\n           true to ensure no other management entity will use\n           the service. In order to not disturb a possible other NMS\n           do this by sending an SNMP SET for both SnmpSetSerialNo\n           and dot1agCfmMepTransmitLbmStatus objects (in same SNMP\n           PDU,  and make sure SNmpSetSerialNo is the first varBind).\n           For the SnmpSetSerialNo varBind, use the value that you\n           obtained in step 1)a.. This ensures that two cooperating\n           NMSes will not step on each others toes.\n           Setting this MIB object does not set the corresponding\n           LBIactive state machine variable.\n        3) Setup the different data to be sent (number of messages,\n           optional TLVs,...), except do not set\n           dot1agCfmMepTransmitLbmMessages.\n        4) Record the current values of dot1agCfmMepLbrIn,\n           dot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu.\n        6) Set dot1agCfmMepTransmitLbmMessages to a non-zero value to\n           initiate transmission of Loopback messages.\n           The dot1agCfmMepTransmitLbmMessages indicates the\n           number of LBMs to be sent and is not decremented as\n           loopbacks are actually sent. dot1agCfmMepTransmitLbmMessages\n           is not equivalent to the LBMsToSend state machine variable.\n        7) Check the value of dot1agCfmMepTransmitLbmResultOK to\n           find out if the operation was successfully initiated or\n           not.\n        8) Monitor the value of dot1agCfmMepTransmitLbmStatus.\n           When it is reset to false, the last LBM has been transmitted.\n           Wait an additional 5 seconds to ensure that all LBRs have\n           been returned.\n        9) Compare dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder,\n           and dot1agCfmMepLbrBadMsdu to their old values from step\n           4, above, to get the results of the test.\n\n        *LTM Managed objects\n        The LTM Managed objects in the MEP table are used in a manner\n        similar to that described for LBM transmission, above.  Upon\n        successfully initiating the transmission, the variables\n        dot1agCfmMepTransmitLtmSeqNumber and\n        dot1agCfmMepTransmitLtmEgressIdentifier return the information\n        required to recover the results of the LTM from the\n        dot1agCfmLtrTable.\n       ')
dot1agCfmMepEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepEntry.setDescription('The MEP table entry')
dot1agCfmMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setReference('802.1ag clauses 3.19, 19.2 and 12.14.7')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIdentifier.setDescription('Integer that is unique among all the MEPs in the same MA.\n        Other definition is: a small integer, unique over a given\n        Maintenance Association, identifying a specific Maintenance\n        association End Point (3.19).\n\n        MEP Identifier is also known as the MEPID.\n       ')
dot1agCfmMepIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setReference('12.14.7.1.3:b')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepIfIndex.setDescription('This object is the interface index of the interface either a\n        bridge port, or an aggregated IEEE 802.1 link within a bridge\n        port, to which the MEP is attached.\n\n        Upon a restart of the system, the system SHALL, if necessary,\n        change the value of this variable so that it indexes the\n        entry in the interface table with the same value of ifAlias\n        that it indexed before the system restart.  If no such\n        entry exists, then the system SHALL set this variable to 0.\n       ')
dot1agCfmMepDirection = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 3), Dot1agCfmMpDirection()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepDirection.setReference('802.1ag clauses 12.14.7.1.3:c and 19.2')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDirection.setDescription('The direction in which the MEP faces on the Bridge port.')
dot1agCfmMepPrimaryVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setReference('802.1ag clauses 12.14.7.1.3:d')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPrimaryVid.setDescription("An integer indicating the Primary VID of the MEP, always\n        one of the VIDs assigned to the MEP's MA.  The value 0\n        indicates that either the Primary VID is that of the\n        MEP's MA, or that the MEP's MA is associated with no VID.")
dot1agCfmMepActive = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepActive.setReference('802.1ag clauses 12.14.7.1.3:e and 20.9.1')
if mibBuilder.loadTexts: dot1agCfmMepActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepActive.setDescription('Administrative state of the MEP\n\n        A Boolean indicating the administrative state of the MEP.\n\n        True indicates that the MEP is to function normally, and\n        false that it is to cease functioning.')
dot1agCfmMepFngState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 6), Dot1agCfmFngState().clone('fngReset')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepFngState.setReference('802.1ag clauses 12.14.7.1.3:f and 20.35')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngState.setDescription('Current state of the MEP Fault Notification Generator\n        State Machine.\n       ')
dot1agCfmMepCciEnabled = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setReference('802.1ag clauses 12.14.7.1.3:g and 20.10.1')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciEnabled.setDescription('If set to true, the MEP will generate CCM messages.')
dot1agCfmMepCcmLtmPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setReference('12.14.7.1.3:h')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmLtmPriority.setDescription('The priority value for CCMs and LTMs transmitted by the MEP.\n        Default Value is the highest priority value allowed to pass\n        through the bridge port for any of this MEPs VIDs.\n        The management entity can obtain the default value for this \n        variable from the priority regeneration table by extracting the \n        highest priority value in this table on this MEPs bridge port.\n        (1 is lowest, then 2, then 0, then 3-7).\n       ')
dot1agCfmMepMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setReference('12.14.7.1.3:i and 19.4')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepMacAddress.setDescription('MAC address of the MEP.')
dot1agCfmMepLowPrDef = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 10), Dot1agCfmLowestAlarmPri().clone('macRemErrXcon')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setReference('12.14.7.1.3:k and 20.9.5 and Table 20-1')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLowPrDef.setDescription('An integer value specifying the lowest priority defect \n        that is allowed to generate fault alarm.\n       ')
dot1agCfmMepFngAlarmTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 11), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(250)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setReference('802.1ag clauses 12.14.7.1.3:l and 20.33.3')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngAlarmTime.setDescription('The time that defects MUST be present before a Fault Alarm is\n        issued (fngAlarmTime. 20.33.3) (default 2.5s).\n       ')
dot1agCfmMepFngResetTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 12), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(250, 1000)).clone(1000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setReference('802.1ag clauses 12.14.7.1.3:m and 20.33.4')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepFngResetTime.setDescription('The time that defects MUST be absent before resetting a\n        Fault Alarm (fngResetTime, 20.33.4) (default 10s).\n       ')
dot1agCfmMepHighestPrDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 13), Dot1agCfmHighestDefectPri()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setReference('12.14.7.1.3:n  20.33.9 and Table 21-1')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepHighestPrDefect.setDescription('The highest priority defect that has been present since the\n        MEPs Fault Notification Generator State Machine was last in\n        the FNG_RESET state.\n       ')
dot1agCfmMepDefects = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 14), Dot1agCfmMepDefects()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDefects.setReference('.1ag clauses 12.14.7.1.3:o, 12.14.7.1.3:p, 12.14.7.1.3:q,\n        12.14.7.1.3:r, 12.14.7.1.3:s, 20.21.3, 20.23.3, 20.33.5,\n        20.33.6, 20.33.7.')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDefects.setDescription('A vector of Boolean error conditions from Table 20-1, any of\n        which may be true:\n\n        DefRDICCM(0)\n        DefMACstatus(1)\n        DefRemoteCCM(2)\n        DefErrorCCM(3)\n        DefXconCCM(4)\n       ')
dot1agCfmMepErrorCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:t and 20.21.2')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepErrorCcmLastFailure.setDescription('The last-received CCM that triggered an DefErrorCCM fault.')
dot1agCfmMepXconCcmLastFailure = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1522))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setReference('802.1ag clauses 12.14.7.1.3:u and 20.23.2')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepXconCcmLastFailure.setDescription('The last-received CCM that triggered a DefXconCCM fault.')
dot1agCfmMepCcmSequenceErrors = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setReference('802.1ag clauses 12.14.7.1.3:v and 20.16.12')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCcmSequenceErrors.setDescription('The total number of out-of-sequence CCMs received from all\n        remote MEPs.\n       ')
dot1agCfmMepCciSentCcms = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setReference('802.1ag clauses 12.14.7.1.3:w and 20.10.2')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepCciSentCcms.setDescription('Total number of Continuity Check messages transmitted.')
dot1agCfmMepNextLbmTransId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setReference('802.1ag clauses 12.14.7.1.3:x and 20.28.2')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepNextLbmTransId.setDescription('Next sequence number/transaction identifier to be sent in a\n        Loopback message. This sequence number can be zero because\n        it wraps around.\n       ')
dot1agCfmMepLbrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setReference('12.14.7.1.3:y and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrIn.setDescription('Total number of valid, in-order Loopback Replies received.')
dot1agCfmMepLbrInOutOfOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setReference('12.14.7.1.3:z and 20.31.1')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrInOutOfOrder.setDescription('The total number of valid, out-of-order Loopback Replies\n        received.\n       ')
dot1agCfmMepLbrBadMsdu = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setReference('12.14.7.1.3:aa  20.2.3')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrBadMsdu.setDescription('The total number of LBRs received whose\n        mac_service_data_unit did not match (except for the OpCode)\n        that of the corresponding LBM (20.2.3).\n       ')
dot1agCfmMepLtmNextSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setReference('12.14.7.1.3:ab and 20.36.1')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLtmNextSeqNumber.setDescription('Next transaction identifier/sequence number to be sent in a\n        Linktrace message. This sequence number can be zero because\n        it wraps around.\n       ')
dot1agCfmMepUnexpLtrIn = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setReference('12.14.7.1.3:ac  20.39.1')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepUnexpLtrIn.setDescription('The total number of unexpected LTRs received (20.39.1).\n       ')
dot1agCfmMepLbrOut = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setReference('12.14.7.1.3:ad and 20.26.2')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepLbrOut.setDescription('Total number of Loopback Replies transmitted.')
dot1agCfmMepTransmitLbmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmStatus.setDescription('A Boolean flag set to true by the MEP Loopback Initiator State\n       Machine or an MIB manager to indicate\n       that another LBM is being transmitted.\n       Reset to false by the MEP Loopback Initiator State Machine.')
dot1agCfmMepTransmitLbmDestMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 27), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n        destination MAC address.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLbmDestIsMepId is 'false'.\n       ")
dot1agCfmMepTransmitLbmDestMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 28), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestMepId.setDescription("The Maintenance association End Point Identifier of another\n        MEP in the same Maintenance Association to which the LBM is\n        to be sent.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLbmDestIsMepId is 'true'.\n       ")
dot1agCfmMepTransmitLbmDestIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 29), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setReference('12.14.7.3.2:b')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDestIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\n        Loopback transmission.\n        False indicates that unicast destination MAC address of the\n        target MEP is used for Loopback transmission.\n       ')
dot1agCfmMepTransmitLbmMessages = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setReference('12.14.7.3.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmMessages.setDescription('The number of Loopback messages to be transmitted.')
dot1agCfmMepTransmitLbmDataTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 31), OctetString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setReference('12.14.7.3.2:d')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmDataTlv.setDescription('An arbitrary amount of data to be included in the Data TLV,\n        if the Data TLV is selected to be sent.  The intent is to be able\n        to fill the frame carrying the CFM PDU to its maximum length.\n        This may lead to fragmentation in some cases.\n       ')
dot1agCfmMepTransmitLbmVlanPriority = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setReference('12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanPriority.setDescription('Priority. 3 bit value to be used in the VLAN tag, if present\n        in the transmitted frame.\n\n        The default value is CCM priority.\n       ')
dot1agCfmMepTransmitLbmVlanDropEnable = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 33), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setReference('12.14.7.3.2:e')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmVlanDropEnable.setDescription('Drop Enable bit value to be used in the VLAN tag, if present\n        in the transmitted frame.\n\n        For more information about VLAN Drop Enable, please check\n        IEEE 802.1ad.\n       ')
dot1agCfmMepTransmitLbmResultOK = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 34), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setReference('12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmResultOK.setDescription('Indicates the result of the operation:\n\n        - true       The Loopback Message(s) will be\n                     (or has been) sent.\n        - false      The Loopback Message(s) will not\n                     be sent.\n       ')
dot1agCfmMepTransmitLbmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 35), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setReference('12.14.7.3.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLbmSeqNumber.setDescription('The Loopback Transaction Identifier\n       (dot1agCfmMepNextLbmTransId) of the first LBM (to be) sent.\n        The value returned is undefined if\n        dot1agCfmMepTransmitLbmResultOK is false.\n       ')
dot1agCfmMepTransmitLtmStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 36), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmStatus.setDescription('A Boolean flag set to true by the bridge port to indicate\n       that another LTM may be transmitted. \n       Reset to false by the MEP Linktrace Initiator State Machine.')
dot1agCfmMepTransmitLtmFlags = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 37), Bits().clone(namedValues=NamedValues(("useFDBonly", 0))).clone(namedValues=NamedValues(("useFDBonly", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setReference('12.14.7.4.2:b and 20.37.1')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmFlags.setDescription('The flags field for LTMs transmitted by the MEP.')
dot1agCfmMepTransmitLtmTargetMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 38), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMacAddress.setDescription("The Target MAC Address Field to be transmitted: A unicast\n        destination MAC address.\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLtmTargetIsMepId is 'false'.\n       ")
dot1agCfmMepTransmitLtmTargetMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 39), Dot1agCfmMepIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetMepId.setDescription("An indication of the Target MAC Address Field to be\n        transmitted:\n        The Maintenance association End Point Identifier of\n        another MEP in the same Maintenance Association\n        This address will be used if the value of the column\n        dot1agCfmMepTransmitLtmTargetIsMepId is 'true'.\n       ")
dot1agCfmMepTransmitLtmTargetIsMepId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 40), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setReference('12.14.7.4.2:c')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTargetIsMepId.setDescription('True indicates that MEPID of the target MEP is used for\n        Linktrace transmission.\n        False indicates that unicast destination MAC address of the\n        target MEP is used for Loopback transmission.\n       ')
dot1agCfmMepTransmitLtmTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 41), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(64)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setReference('12.14.7.4.2:d and 21.8.4')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmTtl.setDescription('The LTM TTL field. Default value, if not specified, is 64.\n        The TTL field indicates the number of hops remaining to the\n        LTM.  Decremented by 1 by each Linktrace Responder that\n        handles the LTM.  The value returned in the LTR is one less\n        than that received in the LTM.  If the LTM TTL is 0 or 1, the\n        LTM is not forwarded to the next hop, and if 0, no LTR is\n        generated.\n       ')
dot1agCfmMepTransmitLtmResult = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 42), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setReference('12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmResult.setDescription('Indicates the result of the operation:\n\n        - true    The Linktrace Message will be (or has been) sent.\n        - false   The Linktrace Message will not be sent')
dot1agCfmMepTransmitLtmSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 43), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setReference('12.14.7.4.3:a')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmSeqNumber.setDescription('The LTM Transaction Identifier\n        (dot1agCfmMepLtmNextSeqNumber) of the LTM sent.\n        The value returned is undefined if\n        dot1agCfmMepTransmitLtmResult is false.\n       ')
dot1agCfmMepTransmitLtmEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setReference('12.14.7.4.3:b and 21.8.8')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepTransmitLtmEgressIdentifier.setDescription('Identifies the MEP Linktrace Initiator that is originating,\n        or the Linktrace Responder that is forwarding, this LTM.\n        The low-order six octets contain a 48-bit IEEE MAC address\n        unique to the system in which the MEP Linktrace Initiator\n        or Linktrace Responder resides.  The high-order two octets\n        contain a value sufficient to uniquely identify the MEP\n        Linktrace Initiator or Linktrace Responder within that system.\n\n        For most Bridges, the address of any MAC attached to the\n        Bridge will suffice for the low-order six octets, and 0 for\n        the high-order octets.  In some situations, e.g., if multiple\n        virtual Bridges utilizing emulated LANs are implemented in a\n        single physical system, the high-order two octets can be used\n        to differentiate among the transmitting entities.\n\n        The value returned is undefined if\n        dot1agCfmMepTransmitLtmResult is false.\n       ')
dot1agCfmMepRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 45), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepRowStatus.setDescription('The status of the row.\n\n        The writable columns in a row can not be changed if the row\n        is active. All columns MUST have a valid value before a row\n        can be activated.\n       ')
dot1agCfmMepPbbTeCanReportPbbTePresence = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 46), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setReference('12.14.7.1.3:af and 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeCanReportPbbTePresence.setDescription('A Boolean valued parameter that is set to true if the system\n       has the capability to report the presence of traffic and that\n       the capability is enabled. Traffic presence reporting is an\n       optional PBB-TE feature.')
dot1agCfmMepPbbTeTrafficMismatchDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 47), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setReference('12.14.7.1.3:ah and 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeTrafficMismatchDefect.setDescription('A Boolean valued parameter that is set to true if the system\n       has detected a traffic field mismatch defect.  Mismatch detection\n        is an optional PBB-TE feature.')
dot1agCfmMepPbbTransmitLbmLtmReverseVid = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 48), IEEE8021VlanIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setReference('12.14.7.4.2')
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTransmitLbmLtmReverseVid.setDescription('This column specifies the value to use in the Reverse VID value\n       field of PBB-TE MIP TLVs contained within TransmitLTM pdus.')
dot1agCfmMepPbbTeMismatchAlarm = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 49), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setReference('12.14.7.1.3:ag and 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchAlarm.setDescription('A Boolean valued parameter that is set to true if the system\n       is to allow a mismatch defect to generate a fault alarm.')
dot1agCfmMepPbbTeLocalMismatchDefect = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 50), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setReference('12.14.7.1.3:ai and 21.6.1.4')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeLocalMismatchDefect.setDescription('A Boolean valued parameter that is set to true if the system\n       has detected a local mismatch defect.  Mismatch detection\n       is an optional PBB-TE feature.')
dot1agCfmMepPbbTeMismatchSinceReset = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1, 51), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setReference('12.14.7.1.3:aj')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepPbbTeMismatchSinceReset.setDescription('A Boolean valued parameter indicating if the mismatch defect\n       has been present since the MEP Mismatch Fault Notification\n       Generator was last in the MFNG_RESET state.')
dot1agCfmLtrTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2), )
if mibBuilder.loadTexts: dot1agCfmLtrTable.setReference('12.14.7.5')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTable.setDescription('This table extends the MEP table and contains a list of\n        Linktrace replies received by a specific MEP in response to\n        a linktrace message.\n\n        SNMP SMI does not allow to state in a MIB that an object in\n        a table is an array.  The solution is to take the index (or\n        indices) of the first table and add one or more indices.\n       ')
dot1agCfmLtrEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFM-MIB", "dot1agCfmLtrSeqNumber"), (0, "IEEE8021-CFM-MIB", "dot1agCfmLtrReceiveOrder"))
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEntry.setDescription('The Linktrace Reply table entry.')
dot1agCfmLtrSeqNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setReference('12.14.7.5.2:b')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrSeqNumber.setDescription("Transaction identifier/Sequence number returned by a previous\n        transmit linktrace message command, indicating which LTM's\n        response is going to be returned.\n       ")
dot1agCfmLtrReceiveOrder = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setReference('12.14.7.5.2:c')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrReceiveOrder.setDescription('An index to distinguish among multiple LTRs with the same LTR\n        Transaction Identifier field value.  dot1agCfmLtrReceiveOrder\n        are assigned sequentially from 1, in the order that the\n        Linktrace Initiator received the LTRs.\n       ')
dot1agCfmLtrTtl = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setReference('12.14.7.5 and 20.36.2.2')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTtl.setDescription('TTL field value for a returned LTR.')
dot1agCfmLtrForwarded = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setReference('802.1ag clauses 12.14.7.5.3:c and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrForwarded.setDescription("Indicates if a LTM was forwarded by the responding MP, as\n        returned in the 'FwdYes' flag of the flags field.\n       ")
dot1agCfmLtrTerminalMep = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setReference('802.1ag clauses 12.14.7.5.3:d and 20.36.2.1')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrTerminalMep.setDescription('A Boolean value stating whether the forwarded LTM reached a\n        MEP enclosing its MA, as returned in the Terminal MEP flag of\n        the Flags field.\n       ')
dot1agCfmLtrLastEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:e and 20.36.2.3')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrLastEgressIdentifier.setDescription('An octet field holding the Last Egress Identifier returned\n        in the LTR Egress Identifier TLV of the LTR.\n        The Last Egress Identifier identifies the MEP Linktrace \n        Initiator that originated, or the Linktrace Responder that \n        forwarded, the LTM to which this LTR is the response.  This\n        is the same value as the Egress Identifier TLV of that LTM.\n       ')
dot1agCfmLtrNextEgressIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setReference('802.1ag clauses 12.14.7.5.3:f and 20.36.2.4')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrNextEgressIdentifier.setDescription('An octet field holding the Next Egress Identifier returned\n        in the LTR Egress Identifier TLV of the LTR.  The Next Egress\n        Identifier Identifies the Linktrace Responder that\n        transmitted this LTR, and can forward the LTM to the next\n        hop.  This is the same value as the Egress Identifier TLV of\n        the forwarded LTM, if any. If the FwdYes bit of the Flags\n        field is false, the contents of this field are undefined,\n        i.e., any value can be transmitted, and the field is ignored\n        by the receiver.\n       ')
dot1agCfmLtrRelay = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 8), Dot1agCfmRelayActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setReference('802.1ag clauses 12.14.7.5.3:g and 20.36.2.5')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrRelay.setDescription('Value returned in the Relay Action field.')
dot1agCfmLtrChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 9), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID returned\n        in the Sender ID TLV of the LTR, if any.  This value is\n        meaningless if the dot1agCfmLtrChassisId has a length of 0.')
dot1agCfmLtrChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 10), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setReference('802.1ag clauses 12.14.7.5.3:i and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrChassisId.setDescription('The Chassis ID returned in the Sender ID TLV of the LTR, if\n        any. The format of this object is determined by the\n        value of the dot1agCfmLtrChassisIdSubtype object.\n       ')
dot1agCfmLtrManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 11), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.5, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddressDomain.setDescription("The TDomain that identifies the type and format of\n        the related dot1agCfmMepDbManAddress object, used to access\n        the SNMP agent of the system transmitting the LTR.  Received\n        in the LTR Sender ID TLV from that system.\n\n        Typical values will be one of (not all inclusive) list:\n\n\n           snmpUDPDomain          (from SNMPv2-TM, RFC3417)\n           snmpIeee802Domain      (from SNMP-IEEE802-TM-MIB, RFC4789)\n\n        The value 'zeroDotZero' (from RFC2578) indicates 'no management\n        address was present in the LTR', in which case the related\n        object dot1agCfmMepDbManAddress MUST have a zero-length OCTET\n        STRING as a value.\n       ")
dot1agCfmLtrManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 12), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setReference('802.1ag clauses 12.14.7.5.3:j, 21.5.3.7, 21.9.6')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrManAddress.setDescription("The TAddress that can be used to access the SNMP\n        agent of the system transmitting the CCM, received in the CCM\n        Sender ID TLV from that system.\n\n        If the related object dot1agCfmLtrManAddressDomain contains\n        the value 'zeroDotZero', this object dot1agCfmLtrManAddress\n        MUST have a zero-length OCTET STRING as a value.\n      ")
dot1agCfmLtrIngress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 13), Dot1agCfmIngressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setReference('802.1ag clauses 12.14.7.5.3:k and 20.36.2.6')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngress.setDescription('The value returned in the Ingress Action Field of the LTM.\n        The value ingNoTlv(0) indicates that no Reply Ingress TLV was\n        returned in the LTM.')
dot1agCfmLtrIngressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setReference('802.1ag clauses 12.14.7.5.3:l and 20.36.2.7')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressMac.setDescription('MAC address returned in the ingress MAC address field.\n        If the dot1agCfmLtrIngress object contains the value\n        ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrIngressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 15), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:m and 20.36.2.8')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortIdSubtype.setDescription('Format of the Ingress Port ID.\n        If the dot1agCfmLtrIngress object contains the value\n        ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrIngressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 16), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setReference('802.1ag clauses 12.14.7.5.3:n and 20.36.2.9')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrIngressPortId.setDescription('Ingress Port ID. The format of this object is determined by\n        the value of the dot1agCfmLtrIngressPortIdSubtype object.\n        If the dot1agCfmLtrIngress object contains the value\n        ingNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 17), Dot1agCfmEgressActionFieldValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setReference('802.1ag clauses 12.14.7.5.3:o and 20.36.2.10')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgress.setDescription('The value returned in the Egress Action Field of the LTM.\n        The value egrNoTlv(0) indicates that no Reply Egress TLV was\n        returned in the LTM.')
dot1agCfmLtrEgressMac = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 18), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setReference('802.1ag clauses 12.14.7.5.3:p and 20.36.2.11')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressMac.setDescription('MAC address returned in the egress MAC address field.\n        If the dot1agCfmLtrEgress object contains the value\n        egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgressPortIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 19), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setReference('802.1ag clauses 12.14.7.5.3:q and 20.36.2.12')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortIdSubtype.setDescription('Format of the egress Port ID.\n        If the dot1agCfmLtrEgress object contains the value\n        egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrEgressPortId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 20), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setReference('802.1ag clauses 12.14.7.5.3:r and 20.36.2.13')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrEgressPortId.setDescription('Egress Port ID. The format of this object is determined by\n        the value of the dot1agCfmLtrEgressPortIdSubtype object.\n        If the dot1agCfmLtrEgress object contains the value\n        egrNoTlv(0), then the contents of this object are meaningless.')
dot1agCfmLtrOrganizationSpecificTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 2, 1, 21), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(4, 1500), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setReference('802.1ag clauses 12.14.7.5.3:s, 21.5.2')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmLtrOrganizationSpecificTlv.setDescription('All Organization specific TLVs returned in the LTR, if\n        any.  Includes all octets including and following the TLV\n        Length field of each TLV, concatenated together.')
dot1agCfmMepDbTable = MibTable((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3), )
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setReference('19.2.15')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbTable.setDescription('The MEP Database. A database, maintained by every MEP, that\n        maintains received information about other MEPs in the\n        Maintenance Domain.\n\n        The SMI does not allow to state in a MIB that an object in\n        a table is an array. The solution is to take the index (or\n        indices) of the first table and add one or more indices.\n       ')
dot1agCfmMepDbEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1), ).setIndexNames((0, "IEEE8021-CFM-MIB", "dot1agCfmMdIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMaIndex"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepIdentifier"), (0, "IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepIdentifier"))
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbEntry.setDescription('The MEP Database table entry.')
dot1agCfmMepDbRMepIdentifier = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 1), Dot1agCfmMepId())
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setReference('12.14.7.6.2:b')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIdentifier.setDescription('Maintenance association End Point Identifier of a remote MEP\n        whose information from the MEP Database is to be returned.\n       ')
dot1agCfmMepDbRMepState = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 2), Dot1agCfmRemoteMepState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setReference('12.14.7.6.3:b and 20.22')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepState.setDescription('The operational state of the remote MEP IFF State machines.')
dot1agCfmMepDbRMepFailedOkTime = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setReference('12.14.7.6.3:c')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepFailedOkTime.setDescription('The time (SysUpTime) at which the IFF Remote MEP state machine\n        last entered either the RMEP_FAILED or RMEP_OK state.\n       ')
dot1agCfmMepDbMacAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setReference('12.14.7.6.3:d and 20.19.7')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbMacAddress.setDescription('The MAC address of the remote MEP.')
dot1agCfmMepDbRdi = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setReference('802.1ag clauses 12.14.7.6.3:e and 20.19.2')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRdi.setDescription('State of the RDI bit in the last received CCM (true for\n        RDI=1), or false if none has been received.\n       ')
dot1agCfmMepDbPortStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 6), Dot1agCfmPortStatus().clone('psNoPortStateTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setReference('12.14.7.6.3:f and 20.19.3')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbPortStatusTlv.setDescription('An enumerated value of the Port status TLV received in the\n        last CCM from the remote MEP or the default value\n        psNoPortStateTLV indicating either no CCM has been received,\n        or that nor port status TLV was received in the last CCM.\n       ')
dot1agCfmMepDbInterfaceStatusTlv = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 7), Dot1agCfmInterfaceStatus().clone('isNoInterfaceStatusTLV')).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setReference('12.14.7.6.3:g and 20.19.4')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbInterfaceStatusTlv.setDescription('An enumerated value of the Interface status TLV received\n        in the last CCM from the remote MEP or the default value\n        isNoInterfaceStatus TLV indicating either no CCM has been\n        received, or that no interface status TLV was received in\n        the last CCM.\n       ')
dot1agCfmMepDbChassisIdSubtype = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 8), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.2')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisIdSubtype.setDescription('This object specifies the format of the Chassis ID received\n        in the last CCM.')
dot1agCfmMepDbChassisId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 9), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setReference('802.1ag clauses 12.14.7.6.3:h and 21.5.3.3')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbChassisId.setDescription('The Chassis ID. The format of this object is determined by the\n        value of the dot1agCfmLtrChassisIdSubtype object.\n       ')
dot1agCfmMepDbManAddressDomain = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 10), TDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.5, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddressDomain.setDescription("The TDomain that identifies the type and format of\n        the related dot1agCfmMepDbManAddress object, used to access\n        the SNMP agent of the system transmitting the CCM.  Received\n        in the CCM Sender ID TLV from that system.\n\n        Typical values will be one of (not all inclusive) list:\n\n\n           snmpUDPDomain          (from SNMPv2-TM, RFC3417)\n           snmpIeee802Domain      (from SNMP-IEEE802-TM-MIB, RFC4789)\n\n        The value 'zeroDotZero' (from RFC2578) indicates 'no management\n        address was present in the LTR', in which case the related\n        object dot1agCfmMepDbManAddress MUST have a zero-length OCTET\n        STRING as a value.\n       ")
dot1agCfmMepDbManAddress = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 11), TAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setReference('802.1ag clauses 12.14.7.6.3:h, 21.5.3.7, 21.6.7')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbManAddress.setDescription("The TAddress that can be used to access the SNMP\n        agent of the system transmitting the CCM, received in the CCM\n        Sender ID TLV from that system.\n\n        If the related object dot1agCfmMepDbManAddressDomain contains\n        the value 'zeroDotZero', this object dot1agCfmMepDbManAddress\n        MUST have a zero-length OCTET STRING as a value.\n       ")
dot1agCfmMepDbRMepIsActive = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 3, 1, 12), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setReference('12.14.7.1.3:af')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbRMepIsActive.setDescription('A Boolean value stating if the remote MEP is active.')
dot1agCfmFaultAlarm = NotificationType((1, 3, 111, 2, 802, 1, 1, 8, 0, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepHighestPrDefect"))
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setDescription("A MEP has a persistent defect condition. A notification\n        (fault alarm) is sent to the management entity with the OID\n        of the MEP that has detected the fault.\n\n        Whenever a MEP has a persistent defect,\n        it may or may not generate a Fault Alarm to warn the system\n        administrator of the problem, as controlled by the MEP\n        Fault Notification Generator State Machine and associated\n        Managed Objects. Only the highest-priority defect, as shown\n        in Table 20-1, is reported in the Fault Alarm.\n\n        If a defect with a higher priority is raised after a Fault\n        Alarm has been issued, another Fault Alarm is issued.\n\n        The management entity receiving the notification can identify\n        the system from the network source address of the\n        notification, and can identify the MEP reporting the defect\n        by the indices in the OID of the dot1agCfmMepHighestPrDefect\n        variable in the notification:\n\n           dot1agCfmMdIndex - Also the index of the MEP's\n                              Maintenance Domain table entry\n                              (dot1agCfmMdTable).\n           dot1agCfmMaIndex - Also an index (with the MD table index)\n                              of the MEP's Maintenance Association\n                              network table entry\n                              (dot1agCfmMaNetTable), and (with the MD\n                              table index and component ID) of the\n                              MEP's MA component table entry\n                              (dot1agCfmMaCompTable).\n           dot1agCfmMepIdentifier - MEP Identifier and final index\n                              into the MEP table (dot1agCfmMepTable).\n       ")
if mibBuilder.loadTexts: dot1agCfmFaultAlarm.setReference('12.14.7.7')
dot1agCfmCompliances = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 1))
dot1agCfmGroups = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 8, 2, 2))
dot1agCfmStackGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmStackMdIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMaIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmStackMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmStackGroup = dot1agCfmStackGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmStackGroup.setDescription('Objects for the Stack group.')
dot1agCfmDefaultMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 2)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdIdPermission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmDefaultMdGroup = dot1agCfmDefaultMdGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmDefaultMdGroup.setDescription('Objects for the Default MD Level group.')
dot1agCfmVlanIdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 3)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmVlanPrimaryVid"), ("IEEE8021-CFM-MIB", "dot1agCfmVlanRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmVlanIdGroup = dot1agCfmVlanIdGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmVlanIdGroup.setDescription('Objects for the VLAN ID group.')
dot1agCfmConfigErrorListGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 4)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListErrorType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmConfigErrorListGroup = dot1agCfmConfigErrorListGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmConfigErrorListGroup.setDescription('Objects for the CFM Configuration Error List Group.')
dot1agCfmMdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 5)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMdTableNextIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMdName"), ("IEEE8021-CFM-MIB", "dot1agCfmMdFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMdLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMhfIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmMdMaNextIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMdRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMdGroup = dot1agCfmMdGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMdGroup.setDescription('Objects for the Maintenance Domain Group.')
dot1agCfmMaGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 6)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMaNetFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetName"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetCcmInterval"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompPrimaryVlanId"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompIdPermission"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaCompNumberOfVids"), ("IEEE8021-CFM-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMaGroup = dot1agCfmMaGroup.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmMaGroup.setDescription('Objects for the MA group.')
dot1agCfmMepGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 7)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepIfIndex"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDirection"), ("IEEE8021-CFM-MIB", "dot1agCfmMepPrimaryVid"), ("IEEE8021-CFM-MIB", "dot1agCfmMepActive"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngState"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCciEnabled"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCcmLtmPriority"), ("IEEE8021-CFM-MIB", "dot1agCfmMepMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLowPrDef"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngAlarmTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepFngResetTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepHighestPrDefect"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDefects"), ("IEEE8021-CFM-MIB", "dot1agCfmMepErrorCcmLastFailure"), ("IEEE8021-CFM-MIB", "dot1agCfmMepXconCcmLastFailure"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCcmSequenceErrors"), ("IEEE8021-CFM-MIB", "dot1agCfmMepCciSentCcms"), ("IEEE8021-CFM-MIB", "dot1agCfmMepNextLbmTransId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrIn"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrInOutOfOrder"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrBadMsdu"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLtmNextSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepUnexpLtrIn"), ("IEEE8021-CFM-MIB", "dot1agCfmMepLbrOut"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDestIsMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmMessages"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmDataTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmVlanPriority"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmVlanDropEnable"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmResultOK"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLbmSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmFlags"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTargetIsMepId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmTtl"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmResult"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmSeqNumber"), ("IEEE8021-CFM-MIB", "dot1agCfmMepTransmitLtmEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmMepRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrForwarded"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrRelay"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrChassisIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrChassisId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrManAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrManAddressDomain"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressMac"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressPortIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrIngressPortId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgress"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressMac"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressPortIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrEgressPortId"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrTerminalMep"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrLastEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrNextEgressIdentifier"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrTtl"), ("IEEE8021-CFM-MIB", "dot1agCfmLtrOrganizationSpecificTlv"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepGroup = dot1agCfmMepGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepGroup.setDescription('Objects for the MEP group.')
dot1agCfmMepDbGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 8)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepState"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbRMepFailedOkTime"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbMacAddress"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbRdi"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbPortStatusTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbInterfaceStatusTlv"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbChassisIdSubtype"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbChassisId"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbManAddressDomain"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbManAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmMepDbGroup = dot1agCfmMepDbGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmMepDbGroup.setDescription('Objects for the MEP group.')
dot1agCfmNotificationsGroup = NotificationGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 9)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmFaultAlarm"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmNotificationsGroup = dot1agCfmNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: dot1agCfmNotificationsGroup.setDescription('Objects for the Notifications group.')
ieee8021CfmMaNetGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 10)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmMaNetFormat"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetName"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetCcmInterval"), ("IEEE8021-CFM-MIB", "dot1agCfmMaNetRowStatus"), ("IEEE8021-CFM-MIB", "dot1agCfmMaMepListRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmMaNetGroup = ieee8021CfmMaNetGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmMaNetGroup.setDescription('Objects for the MA Net group.')
ieee8021CfmDefaultMdDefGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 11)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefLevel"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefMhfCreation"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdDefIdPermission"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021CfmDefaultMdDefGroup = ieee8021CfmDefaultMdDefGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021CfmDefaultMdDefGroup.setDescription('Objects for the Default MD default Level group.')
dot1agCfmCompliance = ModuleCompliance((1, 3, 111, 2, 802, 1, 1, 8, 2, 1, 1)).setObjects(("IEEE8021-CFM-MIB", "dot1agCfmStackGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmDefaultMdGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmConfigErrorListGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMdGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMaGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMepGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmMepDbGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmNotificationsGroup"), ("IEEE8021-CFM-MIB", "dot1agCfmVlanIdGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dot1agCfmCompliance = dot1agCfmCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: dot1agCfmCompliance.setDescription('The compliance statement for support of the CFM MIB module.')
mibBuilder.exportSymbols("IEEE8021-CFM-MIB", dot1agCfmMepDbTable=dot1agCfmMepDbTable, dot1agCfmDefaultMdDefIdPermission=dot1agCfmDefaultMdDefIdPermission, dot1agCfmMepCciSentCcms=dot1agCfmMepCciSentCcms, Dot1agCfmMpDirection=Dot1agCfmMpDirection, Dot1agCfmHighestDefectPri=Dot1agCfmHighestDefectPri, dot1agCfmMepCciEnabled=dot1agCfmMepCciEnabled, dot1agCfmVlanEntry=dot1agCfmVlanEntry, dot1agCfmDefaultMdEntry=dot1agCfmDefaultMdEntry, dot1agCfmDefaultMdStatus=dot1agCfmDefaultMdStatus, dot1agCfmStackMacAddress=dot1agCfmStackMacAddress, dot1agCfmMepXconCcmLastFailure=dot1agCfmMepXconCcmLastFailure, dot1agCfmMepTransmitLtmSeqNumber=dot1agCfmMepTransmitLtmSeqNumber, dot1agCfmMepPrimaryVid=dot1agCfmMepPrimaryVid, dot1agCfmDefaultMdIdPermission=dot1agCfmDefaultMdIdPermission, dot1agCfmMepDbEntry=dot1agCfmMepDbEntry, Dot1agCfmMaintDomainName=Dot1agCfmMaintDomainName, Dot1agCfmMepIdOrZero=Dot1agCfmMepIdOrZero, dot1agCfmLtrIngressPortIdSubtype=dot1agCfmLtrIngressPortIdSubtype, dot1agCfmMepDbPortStatusTlv=dot1agCfmMepDbPortStatusTlv, Dot1agCfmMaintAssocName=Dot1agCfmMaintAssocName, dot1agCfmDefaultMdMhfCreation=dot1agCfmDefaultMdMhfCreation, dot1agCfmMdMhfCreation=dot1agCfmMdMhfCreation, dot1agCfmMepEntry=dot1agCfmMepEntry, dot1agCfmLtrEgress=dot1agCfmLtrEgress, Dot1agCfmRemoteMepState=Dot1agCfmRemoteMepState, dot1agCfmMdFormat=dot1agCfmMdFormat, Dot1afCfmIndexIntegerNextFree=Dot1afCfmIndexIntegerNextFree, dot1agCfmDefaultMdComponentId=dot1agCfmDefaultMdComponentId, dot1agCfmMepTransmitLtmEgressIdentifier=dot1agCfmMepTransmitLtmEgressIdentifier, Dot1agCfmLowestAlarmPri=Dot1agCfmLowestAlarmPri, dot1agCfmVlanComponentId=dot1agCfmVlanComponentId, dot1agCfmLtrNextEgressIdentifier=dot1agCfmLtrNextEgressIdentifier, dot1agMIBObjects=dot1agMIBObjects, dot1agCfmVlanVid=dot1agCfmVlanVid, Dot1agCfmMaintAssocNameType=Dot1agCfmMaintAssocNameType, dot1agCfmMdTableNextIndex=dot1agCfmMdTableNextIndex, dot1agCfmMepDbRdi=dot1agCfmMepDbRdi, ieee8021CfmMib=ieee8021CfmMib, PYSNMP_MODULE_ID=ieee8021CfmMib, dot1agCfmLtrLastEgressIdentifier=dot1agCfmLtrLastEgressIdentifier, Dot1agCfmMDLevelOrNone=Dot1agCfmMDLevelOrNone, dot1agCfmMepTransmitLtmTargetMacAddress=dot1agCfmMepTransmitLtmTargetMacAddress, dot1agCfmLtrReceiveOrder=dot1agCfmLtrReceiveOrder, dot1agCfmStackVlanIdOrNone=dot1agCfmStackVlanIdOrNone, dot1agCfmLtrForwarded=dot1agCfmLtrForwarded, dot1agCfmMepPbbTeMismatchAlarm=dot1agCfmMepPbbTeMismatchAlarm, dot1agCfmLtrIngress=dot1agCfmLtrIngress, dot1agCfmLtrSeqNumber=dot1agCfmLtrSeqNumber, Dot1agCfmMepDefects=Dot1agCfmMepDefects, dot1agCfmMepFngState=dot1agCfmMepFngState, ieee8021CfmMaNetGroup=ieee8021CfmMaNetGroup, dot1agCfmMaNetTable=dot1agCfmMaNetTable, dot1agCfmMaMepListEntry=dot1agCfmMaMepListEntry, dot1agCfmMepIfIndex=dot1agCfmMepIfIndex, dot1agCfmMepFngAlarmTime=dot1agCfmMepFngAlarmTime, dot1agCfmMepTransmitLbmStatus=dot1agCfmMepTransmitLbmStatus, dot1agCfmDefaultMdLevel=dot1agCfmDefaultMdLevel, dot1agCfmMepTransmitLbmResultOK=dot1agCfmMepTransmitLbmResultOK, dot1agCfmMepGroup=dot1agCfmMepGroup, dot1agCfmMepTransmitLbmMessages=dot1agCfmMepTransmitLbmMessages, dot1agCfmLtrEntry=dot1agCfmLtrEntry, dot1agCfmLtrTable=dot1agCfmLtrTable, dot1agCfmMdMdLevel=dot1agCfmMdMdLevel, dot1agCfmStackEntry=dot1agCfmStackEntry, dot1agCfmVlan=dot1agCfmVlan, dot1agCfmMaNetRowStatus=dot1agCfmMaNetRowStatus, dot1agCfmMepActive=dot1agCfmMepActive, dot1agCfmLtrIngressPortId=dot1agCfmLtrIngressPortId, dot1agCfmMepLowPrDef=dot1agCfmMepLowPrDef, dot1agCfmConfigErrorListVid=dot1agCfmConfigErrorListVid, dot1agCfmMepTable=dot1agCfmMepTable, dot1agCfmMepDirection=dot1agCfmMepDirection, dot1agCfmMepTransmitLbmVlanDropEnable=dot1agCfmMepTransmitLbmVlanDropEnable, dot1agCfmMdTable=dot1agCfmMdTable, Dot1agCfmRelayActionFieldValue=Dot1agCfmRelayActionFieldValue, dot1agCfmMaMepListTable=dot1agCfmMaMepListTable, dot1agCfmMepFngResetTime=dot1agCfmMepFngResetTime, dot1agCfmLtrEgressPortId=dot1agCfmLtrEgressPortId, dot1agCfmMepTransmitLbmDestMepId=dot1agCfmMepTransmitLbmDestMepId, dot1agCfmMepLbrBadMsdu=dot1agCfmMepLbrBadMsdu, dot1agCfmLtrChassisId=dot1agCfmLtrChassisId, dot1agCfmMep=dot1agCfmMep, dot1agCfmStackMaIndex=dot1agCfmStackMaIndex, dot1agCfmMepDbMacAddress=dot1agCfmMepDbMacAddress, dot1agCfmMepTransmitLbmDestIsMepId=dot1agCfmMepTransmitLbmDestIsMepId, dot1agCfmConfigErrorListGroup=dot1agCfmConfigErrorListGroup, dot1agCfmMepTransmitLbmDataTlv=dot1agCfmMepTransmitLbmDataTlv, dot1agCfmVlanIdGroup=dot1agCfmVlanIdGroup, dot1agCfmMepTransmitLtmFlags=dot1agCfmMepTransmitLtmFlags, dot1agCfmMepDbRMepIdentifier=dot1agCfmMepDbRMepIdentifier, dot1agCfmMdMhfIdPermission=dot1agCfmMdMhfIdPermission, dot1agCfmStackMdIndex=dot1agCfmStackMdIndex, dot1agCfmMaCompNumberOfVids=dot1agCfmMaCompNumberOfVids, dot1agCfmCompliances=dot1agCfmCompliances, dot1agCfmMepDbRMepIsActive=dot1agCfmMepDbRMepIsActive, dot1agCfmMepHighestPrDefect=dot1agCfmMepHighestPrDefect, dot1agCfmDefaultMdDefMhfCreation=dot1agCfmDefaultMdDefMhfCreation, dot1agCfmMaGroup=dot1agCfmMaGroup, Dot1agCfmPbbComponentIdentifier=Dot1agCfmPbbComponentIdentifier, Dot1agCfmMaintDomainNameType=Dot1agCfmMaintDomainNameType, dot1agCfmStackMdLevel=dot1agCfmStackMdLevel, dot1agCfmStackifIndex=dot1agCfmStackifIndex, dot1agCfmStackDirection=dot1agCfmStackDirection, dot1agCfmMaNetEntry=dot1agCfmMaNetEntry, dot1agCfmMepTransmitLbmDestMacAddress=dot1agCfmMepTransmitLbmDestMacAddress, Dot1agCfmInterfaceStatus=Dot1agCfmInterfaceStatus, dot1agCfmMepMacAddress=dot1agCfmMepMacAddress, dot1agCfmMepPbbTeLocalMismatchDefect=dot1agCfmMepPbbTeLocalMismatchDefect, dot1agCfmNotificationsGroup=dot1agCfmNotificationsGroup, Dot1agCfmMDLevel=Dot1agCfmMDLevel, dot1agCfmMepLbrInOutOfOrder=dot1agCfmMepLbrInOutOfOrder, dot1agCfmConfigErrorListTable=dot1agCfmConfigErrorListTable, dot1agCfmMepTransmitLbmVlanPriority=dot1agCfmMepTransmitLbmVlanPriority, Dot1agCfmConfigErrors=Dot1agCfmConfigErrors, dot1agCfmMepUnexpLtrIn=dot1agCfmMepUnexpLtrIn, dot1agCfmMepLbrOut=dot1agCfmMepLbrOut, dot1agCfmMepCcmLtmPriority=dot1agCfmMepCcmLtmPriority, dot1agCfmMepDbGroup=dot1agCfmMepDbGroup, Dot1agCfmEgressActionFieldValue=Dot1agCfmEgressActionFieldValue, dot1agCfmMaComponentId=dot1agCfmMaComponentId, dot1agCfmStack=dot1agCfmStack, dot1agCfmMepCcmSequenceErrors=dot1agCfmMepCcmSequenceErrors, dot1agCfmStackMepId=dot1agCfmStackMepId, dot1agCfmVlanTable=dot1agCfmVlanTable, dot1agCfmCompliance=dot1agCfmCompliance, dot1agCfmMepPbbTeCanReportPbbTePresence=dot1agCfmMepPbbTeCanReportPbbTePresence, dot1agCfmDefaultMdTable=dot1agCfmDefaultMdTable, dot1agCfmLtrTtl=dot1agCfmLtrTtl, dot1agCfmLtrEgressMac=dot1agCfmLtrEgressMac, Dot1agCfmFngState=Dot1agCfmFngState, dot1agCfmLtrManAddressDomain=dot1agCfmLtrManAddressDomain, dot1agNotifications=dot1agNotifications, dot1agCfmDefaultMdDefLevel=dot1agCfmDefaultMdDefLevel, dot1agCfmMepDbInterfaceStatusTlv=dot1agCfmMepDbInterfaceStatusTlv, dot1agCfmMaNetName=dot1agCfmMaNetName, dot1agCfmVlanRowStatus=dot1agCfmVlanRowStatus, dot1agCfmMa=dot1agCfmMa, dot1agCfmMepTransmitLtmTtl=dot1agCfmMepTransmitLtmTtl, dot1agCfmMepIdentifier=dot1agCfmMepIdentifier, dot1agCfmMdName=dot1agCfmMdName, dot1agCfmMaCompPrimaryVlanId=dot1agCfmMaCompPrimaryVlanId, dot1agCfmMepPbbTeMismatchSinceReset=dot1agCfmMepPbbTeMismatchSinceReset, dot1agCfmMepTransmitLbmSeqNumber=dot1agCfmMepTransmitLbmSeqNumber, dot1agCfmMdRowStatus=dot1agCfmMdRowStatus, dot1agCfmMepDbManAddressDomain=dot1agCfmMepDbManAddressDomain, dot1agCfmMepTransmitLtmResult=dot1agCfmMepTransmitLtmResult, dot1agCfmMepDbChassisIdSubtype=dot1agCfmMepDbChassisIdSubtype, dot1agCfmMaMepListRowStatus=dot1agCfmMaMepListRowStatus, dot1agCfmMaNetCcmInterval=dot1agCfmMaNetCcmInterval, dot1agCfmMdIndex=dot1agCfmMdIndex, dot1agCfmLtrRelay=dot1agCfmLtrRelay, dot1agCfmStackGroup=dot1agCfmStackGroup, Dot1agCfmCcmInterval=Dot1agCfmCcmInterval, dot1agCfmMepErrorCcmLastFailure=dot1agCfmMepErrorCcmLastFailure, dot1agCfmMepDbRMepFailedOkTime=dot1agCfmMepDbRMepFailedOkTime, dot1agCfmMaCompIdPermission=dot1agCfmMaCompIdPermission, dot1agCfmStackTable=dot1agCfmStackTable, dot1agCfmMd=dot1agCfmMd, Dot1agCfmMhfCreation=Dot1agCfmMhfCreation, dot1agCfmMdMaNextIndex=dot1agCfmMdMaNextIndex, dot1agCfmMepRowStatus=dot1agCfmMepRowStatus, dot1agCfmMepTransmitLtmTargetIsMepId=dot1agCfmMepTransmitLtmTargetIsMepId, dot1agCfmMepDbRMepState=dot1agCfmMepDbRMepState, dot1agCfmDefaultMdGroup=dot1agCfmDefaultMdGroup, dot1agCfmMaNetFormat=dot1agCfmMaNetFormat, dot1agCfmMepLtmNextSeqNumber=dot1agCfmMepLtmNextSeqNumber, dot1agCfmGroups=dot1agCfmGroups, dot1agCfmMdGroup=dot1agCfmMdGroup, dot1agCfmMaCompRowStatus=dot1agCfmMaCompRowStatus, dot1agCfmMepDefects=dot1agCfmMepDefects, dot1agCfmMepLbrIn=dot1agCfmMepLbrIn, dot1agCfmMepTransmitLtmStatus=dot1agCfmMepTransmitLtmStatus, dot1agCfmMepPbbTeTrafficMismatchDefect=dot1agCfmMepPbbTeTrafficMismatchDefect, ieee8021CfmDefaultMdDefGroup=ieee8021CfmDefaultMdDefGroup, dot1agCfmMepDbChassisId=dot1agCfmMepDbChassisId, dot1agCfmDefaultMdPrimaryVid=dot1agCfmDefaultMdPrimaryVid, dot1agCfmLtrIngressMac=dot1agCfmLtrIngressMac, dot1agCfmLtrChassisIdSubtype=dot1agCfmLtrChassisIdSubtype, dot1agCfmMaCompMhfCreation=dot1agCfmMaCompMhfCreation, dot1agCfmDefaultMd=dot1agCfmDefaultMd, dot1agCfmMepTransmitLtmTargetMepId=dot1agCfmMepTransmitLtmTargetMepId, Dot1agCfmIdPermission=Dot1agCfmIdPermission, dot1agCfmConfigErrorListErrorType=dot1agCfmConfigErrorListErrorType, dot1agCfmMaCompTable=dot1agCfmMaCompTable, dot1agCfmMepNextLbmTransId=dot1agCfmMepNextLbmTransId, dot1agCfmMdEntry=dot1agCfmMdEntry, dot1agCfmLtrOrganizationSpecificTlv=dot1agCfmLtrOrganizationSpecificTlv, dot1agCfmConfigErrorList=dot1agCfmConfigErrorList, dot1agCfmConfigErrorListEntry=dot1agCfmConfigErrorListEntry, dot1agCfmMepPbbTransmitLbmLtmReverseVid=dot1agCfmMepPbbTransmitLbmLtmReverseVid, dot1agCfmMepDbManAddress=dot1agCfmMepDbManAddress, dot1agCfmMaCompEntry=dot1agCfmMaCompEntry, dot1agCfmLtrEgressPortIdSubtype=dot1agCfmLtrEgressPortIdSubtype, dot1agCfmConformance=dot1agCfmConformance, Dot1agCfmIngressActionFieldValue=Dot1agCfmIngressActionFieldValue, dot1agCfmVlanPrimaryVid=dot1agCfmVlanPrimaryVid, dot1agCfmFaultAlarm=dot1agCfmFaultAlarm, Dot1agCfmMepId=Dot1agCfmMepId, dot1agCfmLtrTerminalMep=dot1agCfmLtrTerminalMep, dot1agCfmConfigErrorListIfIndex=dot1agCfmConfigErrorListIfIndex, dot1agCfmMaMepListIdentifier=dot1agCfmMaMepListIdentifier, dot1agCfmLtrManAddress=dot1agCfmLtrManAddress, dot1agCfmMaIndex=dot1agCfmMaIndex, Dot1agCfmPortStatus=Dot1agCfmPortStatus)
