#
# PySNMP MIB module CAMBIUM-PTP800-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/cambium/CAMBIUM-PTP800-V1-MIB
# Produced by pysmi-1.1.12 at Tue Jun  4 08:03:28 2024
# On host fv-az1110-484 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter32, enterprises, NotificationType, NotificationType, MibIdentifier, Counter64, Gauge32, ObjectIdentity, Bits, iso, TimeTicks, ModuleIdentity, IpAddress, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "enterprises", "NotificationType", "NotificationType", "MibIdentifier", "Counter64", "Gauge32", "ObjectIdentity", "Bits", "iso", "TimeTicks", "ModuleIdentity", "IpAddress", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cambium = MibIdentifier((1, 3, 6, 1, 4, 1, 17713))
ptp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 1))
ptmp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 2))
ptp800 = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 4))
configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 5))
ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 6))
licence = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 8))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 9))
phyControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 10))
phyStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 12))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 13))
smtp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 15))
snmpControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 16))
sntp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 17))
reset = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 18))
versions = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 19))
pubStats = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 20))
encryption = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 22))
rfu = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 23))
radioLicense = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 24))
protectionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 25))
protectionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 26))
protectionStats = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 27))
aAAControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 29))
syslogControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 28))
supplementary = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 96))
ptpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 99))
ptpTrapPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 8, 99, 0))
ethernetPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 6, 15), )
if mibBuilder.loadTexts: ethernetPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by Ethernet priority.')
ethernetPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 6, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "ethernetPriorityTableIndex"))
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setDescription('Table EthernetPriorityTable')
l2CPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 6, 32), )
if mibBuilder.loadTexts: l2CPPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: l2CPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues associated with the different layer 2 control protocol frameworks.')
l2CPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 6, 32, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "l2CPPriorityTableIndex"))
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setDescription('Table L2CPPriorityTable')
iPDSCPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 6, 38), )
if mibBuilder.loadTexts: iPDSCPPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: iPDSCPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by L3 IP DSCP priority.')
iPDSCPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 6, 38, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "iPDSCPPriorityTableIndex"))
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setDescription('Table IPDSCPPriorityTable')
mPLSTCPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 6, 40), )
if mibBuilder.loadTexts: mPLSTCPriorityTable.setStatus('mandatory')
if mibBuilder.loadTexts: mPLSTCPriorityTable.setDescription(' A priority queue mapping table. This is a list of priority queues indexed by MPLS TC priority.')
mPLSTCPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 6, 40, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "mPLSTCPriorityTableIndex"))
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setDescription('Table MPLSTCPriorityTable')
sNMPTrapTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10), )
if mibBuilder.loadTexts: sNMPTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapTable.setDescription(' SNMP trap configuration table.')
sNMPTrapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "sNMPTrapTableIndex"))
if mibBuilder.loadTexts: sNMPTrapTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapTableEntry.setDescription('Table SNMPTrapTable')
sNTPServerTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15), )
if mibBuilder.loadTexts: sNTPServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerTable.setDescription('')
sNTPServerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "sNTPServerTableIndex"))
if mibBuilder.loadTexts: sNTPServerTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerTableEntry.setDescription('Table SNTPServerTable')
userTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2), )
if mibBuilder.loadTexts: userTable.setStatus('mandatory')
if mibBuilder.loadTexts: userTable.setDescription(' The User Table Control group contains objects specifically for user account management.')
userTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP800-MIB", "userTableIndex"))
if mibBuilder.loadTexts: userTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: userTableEntry.setDescription('Table UserTable')
localPacketFiltering = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localPacketFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: localPacketFiltering.setDescription('Controls the filtering of Ethernet frames that have been \n             sourced from the CMU management agent. When Local Packet \n             Filtering is disabled, such frames are transmitted at the \n             Wireless Interface and either the Management Port for \n             Out-of-Band operation or the Data Port for In-Band \n             operation. This is regardless of whether the port has \n             been learned for the destination address. When Local \n             Packet Filtering is enabled, such frames are only \n             transmitted at the port which has been learned for the \n             destination address')
iPv4Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv4Address.setStatus('mandatory')
if mibBuilder.loadTexts: iPv4Address.setDescription('Internet protocol (IPv4) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
subnetMask = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: subnetMask.setDescription('A subnet allows the flow of network traffic between \n             hosts to be segregated based on a network configuration. \n             By organizing hosts into logical groups, subnetting can \n             improve network security and performance')
gatewayIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gatewayIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: gatewayIPAddress.setDescription('The IPv4 address of a device on the current network that \n             acts as an IPv4 network gateway. A gateway acts as an \n             entrance / exit to packets from / to other networks.')
maximumTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1000, 370))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maximumTransmitPower.setStatus('mandatory')
if mibBuilder.loadTexts: maximumTransmitPower.setDescription('Maximum transmit power the wireless unit is permitted to \n             use when establishing and maintaining the wireless link, \n             expressed in tenths of a dBm. Note that when an IRFU is \n             connected rather than an ODU, the transmit power refers \n             to the power at the transceiver output and not the IRFU \n             antenna port. See the User Guide for more details')
antennaGain = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 610))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: antennaGain.setStatus('mandatory')
if mibBuilder.loadTexts: antennaGain.setDescription('Antenna Gain. Expressed in 10ths of dBi.')
rFFeederLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFFeederLoss.setStatus('mandatory')
if mibBuilder.loadTexts: rFFeederLoss.setDescription('Insertion loss of the microwave connection between the \n             RFU and the antenna. The feeder loss should be 0 dB for \n             the standard 1 + 0 direct mount configuration. Expressed \n             in 10ths of dB.')
remoteIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteIPAddress.setDescription('IP Address of the peer wireless unit')
remoteMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteMACAddress.setDescription('MAC Address of the peer wireless unit')
enableTransmission = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("muted", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: enableTransmission.setDescription('Permits the transmitter to radiate. Once the unit is \n             installed and configured, use this to enable the \n             transmitter')
aTPCEnable = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aTPCEnable.setStatus('mandatory')
if mibBuilder.loadTexts: aTPCEnable.setDescription('Enables Automatic Transmitter Power Control (ATPC). \n             NOTE: Use of ATPC is mandatory in some regions. When ATPC \n             is enabled, the transmit power is dynamically adjusted to \n             optimize link performance. The transmit power will always \n             be adjusted within the constraints set by Maximum \n             Transmit Power. When ATPC is disabled, the transmit power \n             will be fixed at the level set by Maximum Transmit Power. \n             When adaptive modulation is enabled, this setting can \n             limit the capacity of the system by capping the \n             modulation to a mode which is consistent with the \n             configured Maximum Transmit Power.')
iFCableLength = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iFCableLength.setStatus('mandatory')
if mibBuilder.loadTexts: iFCableLength.setDescription('IF Cable Length in cm - please refer to the user manual \n             for more information on the recommended cable type.')
linkName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkName.setStatus('mandatory')
if mibBuilder.loadTexts: linkName.setDescription('Name of the PTP link allocated by the System \n             Administrator. Used to establish a connection with the \n             correct PTP wireless unit at the other end of the link. \n             NOTE: The link name MUST be the same at both ends of the \n             PTP link.')
siteName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siteName.setStatus('mandatory')
if mibBuilder.loadTexts: siteName.setDescription('This field is allocated by the system administrator and \n             contains a description of the site name together with any \n             additional notes')
diverseAntennaGain = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 610))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diverseAntennaGain.setStatus('mandatory')
if mibBuilder.loadTexts: diverseAntennaGain.setDescription('Diverse Antenna Receive Gain. Expressed in 10ths of \n             dBi.')
diverseRfFeederLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: diverseRfFeederLoss.setStatus('mandatory')
if mibBuilder.loadTexts: diverseRfFeederLoss.setDescription('Insertion loss of the microwave connection between the \n             RFU and the diverse antenna. Expressed in 10ths of dB.')
iPv6Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6Address.setStatus('mandatory')
if mibBuilder.loadTexts: iPv6Address.setDescription('Internet protocol (IPv6) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
iPVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ipv4", 0), ("ipv6", 1), ("dual-ipv4-and-ipv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPVersion.setStatus('mandatory')
if mibBuilder.loadTexts: iPVersion.setDescription('IP protocol selection. Choice of IPv4, IPv6 or Dual.')
iPv6AutoConfiguredLinkLocalAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setDescription('The auto configured link local IPv6 address')
iPv6PrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6PrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: iPv6PrefixLength.setDescription('IPv6 prefix length')
iPv6GatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6GatewayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: iPv6GatewayAddress.setDescription('The IPv6 address of a device on the current network that \n             is currently acting as an IPv6 network gateway. A gateway \n             acts as an entrance / exit to packets from / to other \n             networks.')
remoteInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: remoteInternetAddressType.setDescription('The type of Internet address specified by the associated \n             remoteInternetAddressType.')
remoteInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 5, 27), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteInternetAddress.setDescription('INET address used to identify the peer wireless unit')
dataPortCopperAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortCopperAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortCopperAutoNegotiation.setDescription('This controls whether the configuration of the copper \n             data Ethernet interface is automatically negotiated or \n             forced. WARNING: ONLY USE FORCED AS A LAST RESORT. To \n             operate an Ethernet link at a fixed speed, leave auto \n             negotiation enabled and limit the Auto Neg Advertisement \n             to the desired speed. Only force Ethernet configuration \n             as a last resort if constrained auto negotiation fails. \n             NB: Auto-MDI/MDIX is disabled when Forced is set, and the \n             unit defaults to MDIX, so the correct straight through or \n             crossover cable will be required to establish a \n             connection. NB: both ends of an Ethernet link must be \n             configured identically, as Forced and auto negotiation \n             are NOT compatible. A mixed configuration will cause a \n             duplex mismatch')
dataPortCopperAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 2), Bits().clone(namedValues=NamedValues(("neg-100-mbps-full-duplex", 6), ("neg-1000-mbps-full-duplex", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortCopperAutoNegAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortCopperAutoNegAdvertisement.setDescription('This sets the different configurations of the copper \n             data Ethernet interface that will be advertised during \n             auto negotiation. WARNING: Duplex mismatch may result if \n             both ends of the Ethernet link do not have the same \n             settings. Do not use auto negotiation together with a \n             fixed setting at the Ethernet link partner (other end of \n             the link). WARNING: Make sure that you select option(s) \n             that you know your connected equipment can cater for!')
dataPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("down", 0), ("copper-link-up", 1), ("fiber-link-up", 2), ("fiber-y-inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortStatus.setDescription('Current status of the data Ethernet link. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
dataPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("speed1000mbpsfullduplex", 0), ("speed100mbpsfullduplex", 1), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortSpeedAndDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortSpeedAndDuplex.setDescription('The current speed and duplex of the data Ethernet link')
dataPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setDescription('When enabled, this causes the data Ethernet link to be \n             dropped briefly when the wireless link drops. This is so \n             that spanning tree algorithms can quickly detect that \n             there is a problem')
useVLANForManagementInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("no-vlan-tagging", 0), ("ieee-8021q-tagged-c-tag-type-8100", 1), ("ieee-8021ad-tagged-s-tag-or-b-tag-type-88a8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setDescription('This controls whether the management interfaces \n             (WWW/SNMP/SMTP/SNTP) use VLAN tags or not')
vLANManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementPriority.setStatus('mandatory')
if mibBuilder.loadTexts: vLANManagementPriority.setDescription('This VLAN Priority (0-7) will be included in packets \n             generated by the management interfaces')
vLANManagementVIDValidation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementVIDValidation.setStatus('mandatory')
if mibBuilder.loadTexts: vLANManagementVIDValidation.setDescription('If enabled, the management interfaces will only respond \n             to Ethernet packets tagged with the configured VLAN \n             Management VID, otherwise packets with any VID will be \n             accepted')
vLANManagementVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementVID.setStatus('mandatory')
if mibBuilder.loadTexts: vLANManagementVID.setDescription('This VLAN VID (0-4094) will be included in packets \n             generated by the management interfaces')
ethernetPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(9, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setDescription('Number of entries in the ethernetPriorityTable.')
managementPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementPortAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortAutoNegotiation.setDescription('This controls whether the configuration of the \n             out-of-band management Ethernet interface is \n             automatically negotiated or forced. WARNING: ONLY USE \n             FORCED AS A LAST RESORT. To operate an Ethernet link at a \n             fixed speed, leave auto negotiation enabled and limit the \n             Auto Neg Advertisement to the desired speed. Only force \n             Ethernet configuration as a last resort if constrained \n             auto negotiation fails. NB: Auto-MDI/MDIX is disabled \n             when Forced is set, and the unit defaults to MDIX, so the \n             correct straight through or crossover cable will be \n             required to establish a connection. NB: both ends of an \n             Ethernet link must be configured identically, as Forced \n             and auto negotiation are NOT compatible. A mixed \n             configuration will cause a duplex mismatch')
managementPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 17), Bits().clone(namedValues=NamedValues(("neg-10-mbps-full-duplex", 6), ("neg-100-mbps-full-duplex", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementPortAutoNegAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortAutoNegAdvertisement.setDescription('This sets the different configurations of the \n             out-of-band management Ethernet interface that will be \n             advertised during auto negotiation. WARNING: Duplex \n             mismatch may result if both ends of the Ethernet link do \n             not have the same settings. Do not use auto negotiation \n             together with a fixed setting at the Ethernet link \n             partner (other end of the link). WARNING: Make sure that \n             you select option(s) that you know your connected \n             equipment can cater for!')
managementPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("copper-link-up", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortStatus.setDescription('Current status of the out-of-band management Ethernet \n             link')
managementPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("speed100mbpsfullduplex", 1), ("speed10mbpsfullduplex", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortSpeedAndDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortSpeedAndDuplex.setDescription('The current speed and duplex of the out-of-band \n             management Ethernet link')
managementPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setDescription('When enabled, this causes the out-of-band management \n             Ethernet link to be dropped briefly when the wireless \n             link drops. This is so that spanning tree algorithms can \n             quickly detect that there is a problem')
managementMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("out-of-band-local", 0), ("out-of-band", 1), ("in-band", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementMode.setStatus('mandatory')
if mibBuilder.loadTexts: managementMode.setDescription('Management mode: Out-of-band management. End-to-end \n             out-of-band mode in which the management agent can be \n             reached from the management port at the local CMU, and \n             (assuming that the wireless link is established) the \n             management port at the remote CMU. Out-of-band local \n             management. (default) Similar to the standard out-of-band \n             mode, except that management frames are not forwarded \n             over the wireless link. In-band management. The \n             management agent can be reached from the data port at the \n             local CMU, and (assuming that the wireless link is \n             established) the data port at the remote CMU. In this \n             mode, the management port is disabled.')
managementCommittedInformationRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("kbps-200", 0), ("kbps-300", 1), ("kbps-400", 2), ("kbps-500", 3), ("kbps-600", 4), ("kbps-700", 5), ("kbps-800", 6), ("kbps-900", 7), ("kbps-1000", 8), ("kbps-1100", 9), ("kbps-1200", 10), ("kbps-1300", 11), ("kbps-1400", 12), ("kbps-1500", 13), ("kbps-1600", 14), ("kbps-1700", 15), ("kbps-1800", 16), ("kbps-1900", 17), ("kbps-2000", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementCommittedInformationRate.setStatus('mandatory')
if mibBuilder.loadTexts: managementCommittedInformationRate.setDescription('The Management Network Committed Information Rate (CIR). \n             The Management Network guarantees this capacity will be \n             available for management traffic')
dataPortPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tunnel", 0), ("discard", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortPauseFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortPauseFrames.setDescription('Controls whether the bridge tunnels or discards Layer 2 \n             PAUSE frames arriving at the data Ethernet port. Such \n             frames are identified by the destination MAC Address \n             being equal to 01-80-C2-00-00-01')
transmitCapacityLimit = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitCapacityLimit.setStatus('mandatory')
if mibBuilder.loadTexts: transmitCapacityLimit.setDescription('Transmit capacity is limited by the lower of: 1) the \n             capacity limit specified by the installed License Key. 2) \n             the Ethernet speed negotiated at the other end of the \n             wireless link. Value expressed in 10ths of Mbps. 0 \n             indicates unlimited')
transmitCapacityLimitDetail = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("limited-due-to-absence-of-license-key", 0), ("running-at-the-capacity-limit", 1), ("running-at-unlimited-capacity", 2), ("restricted-due-to-remote-ethernet-speed", 3), ("limited-due-to-development-override", 4), ("unlimited-due-to-development-override", 5), ("unlimited-capacity-trial-period", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitCapacityLimitDetail.setStatus('mandatory')
if mibBuilder.loadTexts: transmitCapacityLimitDetail.setDescription('A brief description of the reason (if any) for the limit \n             being applied to the transmit capacity')
dataPortEthernetMediaTypeToUse = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto-with-fiber-preference", 0), ("force-copper", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortEthernetMediaTypeToUse.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortEthernetMediaTypeToUse.setDescription('The physical media type to use on the data Ethernet port \n             ')
dataPortCopperForcedConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("force-100-mbps-full-duplex", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortCopperForcedConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortCopperForcedConfiguration.setDescription('This forces the configuration of the copper data \n             Ethernet interface rather than using auto negotiation. \n             THE CONFIGURATION SHOULD ONLY BE FORCED IF YOU ARE HAVING \n             PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST ENSURE THAT \n             YOU CONFIGURE BOTH THIS UNIT AND THE Ethernet PORT TO \n             WHICH IT IS CONNECTED IDENTICALLY! WARNING: Duplex \n             mismatch may result if both ends of the Ethernet link do \n             not have the same settings. Do not use auto negotiation \n             together with a fixed setting at the Ethernet link \n             partner (other end of the link)')
managementPortForcedConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("force-100-mbps-full-duplex", 0), ("force-10-mbps-full-duplex", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortForcedConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortForcedConfiguration.setDescription('This forces the configuration of the out-of-band \n             management Ethernet interface rather than using auto \n             negotiation. THE CONFIGURATION SHOULD ONLY BE FORCED IF \n             YOU ARE HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU \n             MUST ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE \n             Ethernet PORT TO WHICH IT IS CONNECTED IDENTICALLY! \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not use \n             auto negotiation together with a fixed setting at the \n             Ethernet link partner (other end of the link)')
l2CPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setDescription('Number of entries in the l2CPPriorityTable.')
unknownNetworkPriorityQueueMapping = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setStatus('mandatory')
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setDescription('Configures the classification of unknown network \n             protocols to an egress queue at the wireless port. \n             Unknown means something other than IP and MPLS')
dSCPManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dSCPManagementPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dSCPManagementPriority.setDescription('This Differentiated Services Code Point value will be \n             inserted in the IP Header of all IP Datagrams transmitted \n             by the management interfaces')
qOSPriorityScheme = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ethernet", 0), ("ipmpls", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qOSPriorityScheme.setStatus('mandatory')
if mibBuilder.loadTexts: qOSPriorityScheme.setDescription('Selects classification based on fields in the Ethernet \n             header (Layer 2) or in the Network header (Layer 3). The \n             unit recognises two network layer protocols: IP and MPLS')
iPDSCPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setDescription('Number of entries in the iPDSCPPriorityTable.')
mPLSTCPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 6, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setDescription('Number of entries in the mPLSTCPriorityTable.')
ethernetPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setDescription('Configures the classification of this Ethernet priority \n             (also known as IEEE 802.1p value) to an egress queue at \n             the wireless port.')
ethernetPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("p0", 1), ("p1", 2), ("p2", 3), ("p3", 4), ("p4", 5), ("p5", 6), ("p6", 7), ("p7", 8), ("untagged", 9))))
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setDescription('Ethernet priority flag, used to index values in the \n             ethernetPriorityTable.')
l2CPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 32, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setStatus('mandatory')
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setDescription('Configures the classification of this layer two control \n             protocol (L2CP) to an egress queue at the wireless port')
l2CPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 32, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("bridge", 1), ("garpmrp", 2), ("cfm", 3), ("r-aps", 4), ("eaps", 5))))
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setDescription('layer 2 control protocol, used to index values in the \n             l2CPPriorityTable.')
iPDSCPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 38, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setStatus('mandatory')
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setDescription('Configures the classification of this IP differentiated \n             services code point (DSCP) value to an egress queue at \n             the wireless port')
iPDSCPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 38, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setDescription('IP DSCP priority flag, used to index values in the \n             iPDSCPPriorityTable')
mPLSTCPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 40, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setStatus('mandatory')
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setDescription('Configures the classification of this MPLS traffic class \n             (the field formerly known as EXP) to an egress queue at \n             the wireless port')
mPLSTCPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 6, 40, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setDescription('MPLS TC priority flag, used to index values in the \n             mPLSTCPriorityTable')
productVariant = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("ptp-xx400-full", 0), ("ptp-xx400-deprecated-1", 1), ("ptp-xx400-deprecated-2", 2), ("ptp-xx400-lite", 3), ("spare-1", 4), ("ptp-xx300", 5), ("spare-2", 6), ("spare-3", 7), ("ptp-xx500-full-deprecated", 8), ("ptp-xx500-lite-deprecated", 9), ("ptp-xx500", 10), ("ptp-xx600-lite", 11), ("ptp-xx600-full", 12), ("spare-5", 13), ("spare-6", 14), ("ptp-800", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productVariant.setStatus('mandatory')
if mibBuilder.loadTexts: productVariant.setDescription('The product variant')
productName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productName.setStatus('mandatory')
if mibBuilder.loadTexts: productName.setDescription('Name of the product variant')
ethernetFiberSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetFiberSupport.setStatus('mandatory')
if mibBuilder.loadTexts: ethernetFiberSupport.setDescription('Ethernet fiber support availability on this wireless \n             unit')
transmitCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("rate-10-mbps", 0), ("rate-20-mbps", 1), ("rate-30-mbps", 2), ("rate-40-mbps", 3), ("rate-50-mbps", 4), ("rate-100-mbps", 5), ("rate-150-mbps", 6), ("rate-200-mbps", 7), ("rate-300-mbps", 8), ("rate-unlimited", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: transmitCapacity.setDescription('Maximum capacity the wireless link may provide in the \n             transmit direction. This is restricted by the License \n             Key.')
encryptionAlgorithmsAvail = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("aes-rijndael", 1), ("aes-256-bit-rijndael", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: encryptionAlgorithmsAvail.setStatus('mandatory')
if mibBuilder.loadTexts: encryptionAlgorithmsAvail.setDescription('The Encryption Algorithm(s) available to the wireless \n             link. N.B. The same Encryption Algorithm must be \n             configured at BOTH ends of the link for it to function \n             correctly')
securityLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 8, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityLevel.setStatus('mandatory')
if mibBuilder.loadTexts: securityLevel.setDescription('The maximum configurable security level')
linkNameMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("link-name-mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkNameMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: linkNameMismatch.setDescription('Signaling was received with the wrong Link Name. Either \n             the Link Name is configured differently at each end of \n             the wireless link, or this unit is aligned to the wrong \n             link partner. NB: A change of value during operation may \n             generate an SNMP trap and/or SMTP email alert')
alignmentMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("aligning", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alignmentMode.setStatus('mandatory')
if mibBuilder.loadTexts: alignmentMode.setDescription('Indicates if the unit is undergoing alignment. NB: a \n             change of state during operation may generate an SNMP \n             trap and/or SMTP email alert')
tFTPServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPServerIPAddress.setDescription('IP address of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
tFTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPServerPortNumber.setDescription('The port number of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
tFTPSoftwareUpgradeFileName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setDescription('Filename of the Software Upgrade to be loaded from the \n             TFTP Server')
tFTPStartSoftwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setDescription("Write '1' to this attribute to start the TFTP software \n             upgrade process. The attribute will be reset to 0 when \n             the upgrade process has finished")
tFTPSoftwareUpgradeStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 0), ("upload-in-progress", 1), ("upload-successful-programming-flash", 2), ("upgrade-successful-reboot-to-run-the-new-software-image", 3), ("upgrade-failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setDescription('The current status of the TFTP Software upgrade process')
tFTPSoftwareUpgradeStatusText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setDescription('Descriptive text describing the status of the TFTP \n             Software upgrade process, including any error details')
tFTPSoftwareUpgradeStatusAdditionalText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setDescription('Any additional text describing the status of the TFTP \n             Software upgrade process, including any error details')
hTTPAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPAccessEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: hTTPAccessEnabled.setDescription('This controls whether or not HTTP access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the HTTP port. Remote \n             management via HTTPS is not affected by this setting. Any \n             change in this setting will not take effect until the \n             unit has been rebooted. (Factory default = Enabled)')
telnetAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetAccessEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: telnetAccessEnabled.setDescription('This controls whether or not Telnet access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the TELNET port. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = Disabled)')
hTTPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hTTPPortNumber.setDescription('This controls the port number for HTTP access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 80)')
hTTPSPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPSPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: hTTPSPortNumber.setDescription('This controls the port number for HTTPS access. A value \n             of zero will use the default port number. Availability of \n             HTTPS is controlled via the Licence Key. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 443)')
telnetPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: telnetPortNumber.setDescription('This controls the port number for TELNET access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 23)')
hTTPSAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hTTPSAccessEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: hTTPSAccessEnabled.setDescription('This controls whether or not HTTPS access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the configured HTTPS Port \n             Number. Remote management via HTTP is not affected by \n             this setting. Any change in this setting will not take \n             effect until the unit has been rebooted. (Factory default \n             = Enabled)')
tFTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             tFTPServerInternetAddress.')
tFTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 9, 19), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tFTPServerInternetAddress.setDescription('INET address of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
remoteMaximumTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 10, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1000, 370))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setStatus('mandatory')
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setDescription('Maximum transmit power the remote wireless unit is \n             permitted to use when establishing and maintaining the \n             wireless link, expressed in tenths of a dBm. Note that \n             when an IRFU is connected rather than an ODU, the \n             transmit power refers to the power at the transceiver \n             output and not the IRFU antenna port. See the User Guide \n             for more details')
minModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 10, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: minModulation.setStatus('mandatory')
if mibBuilder.loadTexts: minModulation.setDescription('When adaptive modulation is enabled, PTP 800 will adapt \n             the modulation mode between a minimum and maximum \n             modulation mode. Depending on the region, minimum and \n             maximum modulation modes will be either derived from the \n             radio license, e.g. FCC and Industry Canada, or will be \n             user adjustable, e.g. ETSI.In general, a modulation mode \n             is defined by two aspects, a modulation and a code rate. \n             This integer attribute identifies the modulation aspect \n             of the minimum modulation mode. For example, if the \n             minimum modulation mode is 16QAM 0.91, this attribute \n             will be set to a value of 2 which identifies a modulation \n             of 16QAM.')
minCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 10, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: minCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: minCodeRate.setDescription('When adaptive modulation is enabled, PTP 800 will adapt \n             the modulation mode between a minimum and maximum \n             modulation mode. Depending on the region, minimum and \n             maximum modulation modes will be either derived from the \n             radio license, e.g. FCC and Industry Canada, or will be \n             user adjustable, e.g. ETSI. In general, a modulation mode \n             is defined by two aspects, a modulation and a code rate. \n             This attribute is equal to 100 times the code rate aspect \n             of the minimum modulation mode. For example, if the \n             minimum modulation mode is 16QAM 0.91, this attribute \n             will be set to a value of 91.')
maxModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 10, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxModulation.setStatus('mandatory')
if mibBuilder.loadTexts: maxModulation.setDescription('When adaptive modulation is enabled, PTP 800 will adapt \n             the modulation mode between a minimum and maximum \n             modulation mode. Depending on the region, minimum and \n             maximum modulation modes will be either derived from the \n             radio license, e.g. FCC and Industry Canada, or will be \n             user adjustable, e.g. ETSI. In general, a modulation mode \n             is defined by two aspects, a modulation and a code rate. \n             This integer attribute identifies the modulation aspect \n             of the maximum modulation mode. For example, if the \n             maximum modulation mode is 256QAM 0.91, this attribute \n             will be set to a value of 6 which identifies a modulation \n             of 256QAM.')
maxCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 10, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: maxCodeRate.setDescription('When adaptive modulation is enabled, PTP 800 will adapt \n             the modulation mode between a minimum and maximum \n             modulation mode. Depending on the region, minimum and \n             maximum modulation modes will be either derived from the \n             radio license, e.g. FCC and Industry Canada, or will be \n             user adjustable, e.g. ETSI. In general, a modulation mode \n             is defined by two aspects, a modulation and a code rate. \n             This attribute is equal to 100 times the code rate aspect \n             of the maximum modulation mode. For example, if the \n             maximum modulation mode is 256QAM 0.91, this attribute \n             will be set to a value of 91.')
receivePower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivePower.setStatus('mandatory')
if mibBuilder.loadTexts: receivePower.setDescription('This is the receive power measured by the RFU. When an \n             IRFU transceiver is connected rather than an ODU, the \n             Receive Power refers to the power at the input to the \n             transceiver and not the IRFU antenna port. Expressed in \n             tenths of a dBm.')
vectorError = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vectorError.setStatus('mandatory')
if mibBuilder.loadTexts: vectorError.setDescription('Vector Error is a measure of received signal quality. \n             The value is generally in the range from -6 dB to -38 dB, \n             a more negative number indicating a higher quality \n             signal. Expressed in tenths of a dB.')
transmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitPower.setStatus('mandatory')
if mibBuilder.loadTexts: transmitPower.setDescription('This is the transmit power of the RFU. When an IRFU \n             transceiver is connected rather than an ODU, the Transmit \n             Power refers to the power at the transceiver output and \n             not the IRFU antenna port. Expressed in tenths of a dBm.')
linkLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-500, 1800))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkLoss.setStatus('mandatory')
if mibBuilder.loadTexts: linkLoss.setDescription('Link Loss is a measurement of the loss in signal level \n             as the radio wave propagates between the antennas \n             installed at each end of the link. The Link Loss is only \n             accurate if the Antenna Gain and RF Feeder Loss have been \n             configured correctly at both ends of the link. Expressed \n             in tenths of a dB.')
receiveModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulation.setStatus('mandatory')
if mibBuilder.loadTexts: receiveModulation.setDescription('Current active receive modulation')
transmitModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitModulation.setStatus('mandatory')
if mibBuilder.loadTexts: transmitModulation.setDescription('Current active transmit modulation')
receiveCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: receiveCodeRate.setDescription('Indicates the code rate applied to the signal being \n             received at the wireless interface. The reported value is \n             the code rate multiplied by 100.')
transmitCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 12, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: transmitCodeRate.setDescription('Indicates the code rate applied to the signal \n             transmitted at the wireless interface. The reported value \n             is the code rate multiplied by 100.')
unitOutOfCalibration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("calibrated", 0), ("partial-calibration", 1), ("invalid-calibration", 2), ("bandwidth-variant-unsupported-pas-shutdown", 3), ("out-of-calibration-pas-shutdown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitOutOfCalibration.setStatus('mandatory')
if mibBuilder.loadTexts: unitOutOfCalibration.setDescription('The unit is out of calibration')
encryptionEnabledMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("encryption-enabled-mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: encryptionEnabledMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: encryptionEnabledMismatch.setDescription('Encryption has been enabled on one end of the wireless \n             link but not the other')
dataPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabled-by-snmp-ifadminstatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortDisabledWarning.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the data Ethernet interface \n             has disabled Ethernet traffic')
dataPortFiberStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("installed-fiber-not-licensed", 1), ("no-fiber-link-established-but-los-not-detected", 2), ("no-fiber-link-established-and-los-detected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortFiberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortFiberStatus.setDescription('If the fiber interface on the data Ethernet port is not \n             OK, there are three possible causes: 1) the fiber \n             interface has been installed but disabled, 2) the \n             interface could not be established even though no LOS was \n             detected (i.e. an optical carrier was detected, which \n             could be due to a broken TX fiber, or because the \n             interface is disabled at the other end of the fiber \n             link), or 3) the interface could not be established and \n             LOS is detected (i.e. no optical carrier is detected). \n             NB: a change of status may generate an SNMP trap and/or \n             SMTP email alert')
dataPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-error", 0), ("mismatch-detected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortConfigurationMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) on \n             the data Ethernet port when the link is in full duplex is \n             an indication of an auto-negotiation or forced \n             configuration mismatch')
softwareVersionRemoteCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersionRemoteCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: softwareVersionRemoteCompatibility.setDescription('Indicates a mismatch of software versions at the two \n             ends of the wireless link')
managementPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabled-by-snmp-ifadminstatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortDisabledWarning.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the out-of-band management \n             Ethernet interface has disabled Ethernet traffic')
rFUStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("ok", 0), ("fault", 1), ("unknown-3", 2), ("in-reset", 3), ("download-in-progress", 4), ("incompatible-firmware-version", 5), ("incompatible-device", 6), ("ifi-card-attached", 7), ("no-response", 8), ("power-supply-fault", 9), ("power-supply-disabled", 10), ("switching-memory-banks", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rFUStatus.setDescription("Current status of the RFU. A state of 'ok' indicates \n             that the RFU is fully operational, although may not be \n             transmitting.")
managementPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-error", 0), ("mismatch-detected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortConfigurationMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) on \n             the out-of-band management Ethernet port when the link is \n             in full duplex is an indication of an auto-negotiation or \n             forced configuration mismatch')
secureModeAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("secure-mode-is-active", 0), ("secure-mode-is-not-configured", 1), ("secure-mode-is-configured-but-not-active", 2), ("secure-mode-is-not-supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secureModeAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: secureModeAlarm.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
rFUPlatformCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUPlatformCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: rFUPlatformCompatibility.setDescription('This indicates when the RFU currently connected to the \n             CMU does not match the RFU Platform which was installed. \n             Either re-run the Installation Wizard or connect the \n             correct RFU')
rFUProtectionCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 13, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUProtectionCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: rFUProtectionCompatibility.setDescription('This indicates when the IRFU branching unit \n             configuration is not compatible with the protection \n             configuration or if the left hand transceiver has been \n             configured as Secondary or the right hand transceiver has \n             been configured as Primary')
sMTPEmailAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEmailAlert.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPEmailAlert.setDescription('Simple Mail Transfer Protocol is used to send equipment \n             alerts via email to a specified email address. This \n             utility can only be configured by the system \n             administrator')
sMTPServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPServerIPAddress.setDescription('IP address of the SMTP server')
sMTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPServerPortNumber.setDescription('Port number of the SMTP server')
sMTPSourceEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setDescription("The 'from' email address used when constructing the \n             automatically generated e-mail message")
sMTPDestinationEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setDescription("The 'to' email address used when constructing the \n             automatically generated e-mail message")
sMTPEnabledMessages = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 6), Bits().clone(namedValues=NamedValues(("protection-state", 3), ("enabled-diagnostic-alarms", 4), ("management-port-up-down", 5), ("data-port-up-down", 6), ("wireless-link-up-down", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEnabledMessages.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPEnabledMessages.setDescription('This controls which SMTP messages the unit will send')
sMTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sMTPServerInternetAddress.')
sMTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 15, 8), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sMTPServerInternetAddress.setDescription('Internet address of the SMTP server')
sNMPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPPortNumber.setDescription('The IP port number used to access the SNMP MIB (i.e. \n             Gets and Sets). NB: A system reboot is required to \n             activate changes to this attribute')
sNMPCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPCommunityString.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPCommunityString.setDescription('The SNMP community string. NB: A system reboot is \n             required to activate changes to this attribute')
sNMPTrapVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("v1", 0), ("v2c", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapVersion.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapVersion.setDescription('The SNMP protocol version to use for SNMP Traps.')
sNMPEnabledTraps = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 6), Bits().clone(namedValues=NamedValues(("protection-state", 1), ("authentication-failure", 2), ("enabled-diagnostic-alarms", 3), ("management-port-up-down", 4), ("data-port-up-down", 5), ("wireless-link-up-down", 6), ("cold-start", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPEnabledTraps.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPEnabledTraps.setDescription('This controls which SNMP Traps the unit will send')
enabledDiagnosticAlarms = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 7), Bits().clone(namedValues=NamedValues(("data-port-configuration-mismatch", 0), ("unknown-7", 1), ("wireless-link-status", 2), ("sntp-sync", 3), ("encryption-enabled-mismatch", 4), ("unit-out-of-calibration", 5), ("link-name-mismatch", 6), ("alignment-mode", 7), ("syslog-disabled-warning", 8), ("management-port-status", 9), ("data-port-status", 10), ("rfu-status", 11), ("management-port-disabled-warning", 12), ("management-port-configuration-mismatch", 13), ("data-port-fiber-status", 14), ("data-port-disabled-warning", 15), ("software-version-mismatch", 18), ("syslog-client-disabled-warning", 19), ("rfu-power-button-pressed", 20), ("secure-mode", 21), ("syslog-local-wrapped", 22), ("syslog-local-nearly-full", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setDescription('Controls which individual diagnostic alarms are \n             enabled.')
enabledDiagnosticProtectionAlarms = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 8), Bits().clone(namedValues=NamedValues(("end-wireless-receive-signal-status", 0), ("protection-interface-status", 1), ("management-port-ethernet-speed-status", 2), ("data-port-ethernet-speed-status", 3), ("licensed-transmit-capacity-status", 4), ("wireless-receive-signal-status", 5), ("protection-configuration-status", 6), ("protection-availability-status", 7), ("rx-diversity-availability-status", 13), ("rx-diversity-configuration-status", 14), ("rx-diversity-data-port-status", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledDiagnosticProtectionAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: enabledDiagnosticProtectionAlarms.setDescription('Controls which individual diagnostic protection alarms \n             are enabled.')
sNMPTrapTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 16, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapTableNumber.setDescription('Number of entries in the sNMPTrapTable.')
sNMPTrapTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNMPTrapTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapTableIndex.setDescription('SNMP trap value, used to index the SNMPTrapTable.')
sNMPTrapIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapIPAddress.setDescription('The IP address to which all SNMP Traps are sent. NB: A \n             system reboot is required to activate changes to this \n             attribute.')
sNMPTrapPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapPortNumber.setDescription('Destination port for SNMP Traps (default=162). NB: A \n             system reboot is required to activate changes to this \n             attribute.')
sNMPTrapInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNMPTrapInternetAddress.')
sNMPTrapInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setDescription('The Internet address to which all SNMP Traps are sent.')
sNMPTrapReceiverEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 16, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setDescription('A value of 0 disables the sending of SNMP trap to \n             corresponding receiver. A value of 1 enables the sending \n             of SNMP trap to corresponding receiver.')
sNTPState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPState.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPState.setDescription('SNTP control state')
sNTPPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 43200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPPollInterval.setDescription('The SNTP server polling interval')
sNTPSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no-sync", 0), ("in-sync", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPSync.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPSync.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
sNTPLastSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPLastSync.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPLastSync.setDescription('Last SNTP sync time')
systemClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemClock.setStatus('mandatory')
if mibBuilder.loadTexts: systemClock.setDescription('System clock presented as local time')
timeZone = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50))).clone(namedValues=NamedValues(("gmt-minus-1200", 0), ("gmt-minus-1130", 1), ("gmt-minus-1100", 2), ("gmt-minus-1030", 3), ("gmt-minus-1000", 4), ("gmt-minus-0930", 5), ("gmt-minus-0900", 6), ("gmt-minus-0830", 7), ("gmt-minus-0800", 8), ("gmt-minus-0730", 9), ("gmt-minus-0700", 10), ("gmt-minus-0630", 11), ("gmt-minus-0600", 12), ("gmt-minus-0530", 13), ("gmt-minus-0500", 14), ("gmt-minus-0430", 15), ("gmt-minus-0400", 16), ("gmt-minus-0330", 17), ("gmt-minus-0300", 18), ("gmt-minus-0230", 19), ("gmt-minus-0200", 20), ("gmt-minus-0130", 21), ("gmt-minus-0100", 22), ("gmt-minus-0030", 23), ("gmt-zero", 24), ("gmt-plus-0030", 25), ("gmt-plus-0100", 26), ("gmt-plus-0130", 27), ("gmt-plus-0200", 28), ("gmt-plus-0230", 29), ("gmt-plus-0300", 30), ("gmt-plus-0330", 31), ("gmt-plus-0400", 32), ("gmt-plus-0430", 33), ("gmt-plus-0500", 34), ("gmt-plus-0530", 35), ("gmt-plus-0600", 36), ("gmt-plus-0630", 37), ("gmt-plus-0700", 38), ("gmt-plus-0730", 39), ("gmt-plus-0800", 40), ("gmt-plus-0830", 41), ("gmt-plus-0900", 42), ("gmt-plus-0930", 43), ("gmt-plus-1000", 44), ("gmt-plus-1030", 45), ("gmt-plus-1100", 46), ("gmt-plus-1130", 47), ("gmt-plus-1200", 48), ("gmt-plus-1230", 49), ("gmt-plus-1300", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeZone.setStatus('mandatory')
if mibBuilder.loadTexts: timeZone.setDescription('Time zone offsets from Greenwich Mean Time (GMT)')
daylightSaving = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylightSaving.setStatus('mandatory')
if mibBuilder.loadTexts: daylightSaving.setDescription('Daylight Saving Time')
sNTPPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("server-1", 0), ("server-2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServer.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPPrimaryServer.setDescription('Specifies the primary SNTP server, determining the order \n             in which the servers are tried.')
sNTPPrimaryServerDeadTime = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setDescription('Time (in seconds) to wait before retrying communications \n             with an unresponsive primary SNTP server. Setting the \n             value to 0 disables the timer.')
sNTPServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerRetries.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerRetries.setDescription('Number of times the PTP will retry after an SNTP server \n             fails to respond.')
sNTPServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerTimeout.setDescription('Time (in seconds) the PTP will wait for a response from \n             an SNTP server.')
sNTPServerTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 17, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerTableNumber.setDescription('Number of entries in the SNTPServerTable.')
sNTPServerTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNTPServerTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerTableIndex.setDescription('Index range for the SNTPServerTable.')
sNTPServerIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerIPAddress.setDescription('The IP address of a valid SNTP server')
sNTPServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerPortNumber.setDescription('The IP port number of the SNTP server. Defaults to port \n             123.')
sNTPServerResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerResponse.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerResponse.setDescription('The most recent response received from the SNTP server, \n             if used')
sNTPServerInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNTPServerInternetAddress.')
sNTPServerInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 17, 15, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sNTPServerInternetAddress.setDescription('The Internet address of a valid SNTP server')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("running", 0), ("console-reboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('mandatory')
if mibBuilder.loadTexts: systemReset.setDescription("Setting this attribute to '1' will cause a system \n             reboot. NB: a system reboot will apply any pending new \n             settings held in memory")
softwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: softwareVersion.setDescription('Current software version')
hardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 19, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hardwareVersion.setDescription('Hardware platform version')
secondarySoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 19, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondarySoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: secondarySoftwareVersion.setDescription('Secondary software version, used when the primary \n             software image is invalid or erased')
bootVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 19, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bootVersion.setDescription('Boot code software version')
receiveDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: receiveDataRate.setDescription('Data rate received by the wireless interface. Expressed \n             in kbps, rounded down to nearest 100 kbps.')
transmitDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 20, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: transmitDataRate.setDescription('Data rate transmitted from the wireless interface. \n             Expressed in kbps, rounded down to nearest 100 kbps.')
aggregateDataRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 20, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregateDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: aggregateDataRate.setDescription('Total data rate across the wireless interface summed \n             over both link directions. Expressed in kbps, rounded \n             down to nearest 100 kbps.')
wirelessLinkAvailability = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: wirelessLinkAvailability.setDescription('The percentage of time that the unit has been able to \n             successfully demodulate the signal transmitted from the \n             remote end of the link. Calculated since the last reset \n             of the system counters. The reported value is the \n             percentage multiplied by 10000.')
wirelessLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 20, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 0), ("registering", 1), ("searching", 2), ("acquiring", 3), ("radar-cac", 4), ("initialising", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wirelessLinkStatus.setDescription('Current status of the wireless link')
encryptionAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("aes-rijndael", 1), ("aes-256-bit-rijndael", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: encryptionAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: encryptionAlgorithm.setDescription('The Encryption Algorithm used by the wireless link. NB: \n             A system reboot is required to activate changes to this \n             attribute. NB: The same Encryption Algorithm must be \n             configured at BOTH ends of the link for it to function \n             correctly')
rFURfBand = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4000, 70000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURfBand.setStatus('mandatory')
if mibBuilder.loadTexts: rFURfBand.setDescription('RFU RF band in MHz')
rFUTxBandAboveRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxBandAboveRx.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxBandAboveRx.setDescription('Yes means RFU transmitter frequency band is above \n             receiver frequency band')
rFUFreqSpacing = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1560000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUFreqSpacing.setStatus('mandatory')
if mibBuilder.loadTexts: rFUFreqSpacing.setDescription('Tx-Rx frequency spacing in kHz')
rFUTxPowerMin = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxPowerMin.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxPowerMin.setDescription('Minimum transmitter power level, in 10ths of dBm')
rFUTxPowerMax = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(160, 370))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxPowerMax.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxPowerMax.setDescription('Maximum transmitter power level, in 10ths of dBm')
rFURxFreqMin = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5725000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURxFreqMin.setStatus('mandatory')
if mibBuilder.loadTexts: rFURxFreqMin.setDescription('Minimum receiver frequency in kHz')
rFURxFreqMax = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5725000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURxFreqMax.setStatus('mandatory')
if mibBuilder.loadTexts: rFURxFreqMax.setDescription('Maximum receiver frequency in kHz')
rFUTxFreqMin = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5725000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxFreqMin.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxFreqMin.setDescription('Minimum transmitter frequency in kHz')
rFUTxFreqMax = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5725000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxFreqMax.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxFreqMax.setDescription('Maximum transmitter frequency in kHz')
rFUSerial = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUSerial.setStatus('mandatory')
if mibBuilder.loadTexts: rFUSerial.setDescription('RFU serial number')
rFUActiveFirmwareBank = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUActiveFirmwareBank.setStatus('mandatory')
if mibBuilder.loadTexts: rFUActiveFirmwareBank.setDescription('RFU active firmware bank number')
rFUVersionBank1 = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUVersionBank1.setStatus('mandatory')
if mibBuilder.loadTexts: rFUVersionBank1.setDescription('RFU firmware version number (nnn/ddMMYY) in bank 1')
rFUVersionBank2 = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUVersionBank2.setStatus('mandatory')
if mibBuilder.loadTexts: rFUVersionBank2.setDescription('RFU firmware version number (nnn/ddMMYY) in bank 2')
rFUType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUType.setStatus('mandatory')
if mibBuilder.loadTexts: rFUType.setDescription('RFU type as: RFU platform, frequency band, Tx-Rx \n             frequency spacing, Hi/Lo band and transmit frequency \n             range')
rFURxRFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURxRFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFURxRFSynthLockAlarm.setDescription('RFU RF receiver out of lock alarm')
rFUTxRFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxRFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxRFSynthLockAlarm.setDescription('RFU RF transmitter out of lock alarm')
rFUTxPowerAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("tx-output-failed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxPowerAlarm.setDescription('RFU transmitter output failed alarm')
rFUCommonIFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUCommonIFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUCommonIFSynthLockAlarm.setDescription('Alarm indicating when the common IF RFU synthesizer is \n             out of lock')
rFUPowerAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("power-failed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUPowerAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUPowerAlarm.setDescription('RFU general power alarm')
rFULockoutAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("locked-out", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFULockoutAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFULockoutAlarm.setDescription('RFU locked pending unlock code alarm')
rFUCableAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("if-cable-voltage-out-of-range", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUCableAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUCableAlarm.setDescription('RFU cable detector voltage out of range alarm')
rFUCableAttenuationAdjustAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("if-cable-attenuator-adjusting", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUCableAttenuationAdjustAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUCableAttenuationAdjustAlarm.setDescription('RFU cable attenuator not yet adjusted alarm')
rFUTxPowerDegradedAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("degraded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxPowerDegradedAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxPowerDegradedAlarm.setDescription('Indicates when the current transmit power is more than 3 \n             dB below or more than 3 dB above the correct transmit \n             power.')
rFURpsAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("rps-alarm-active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURpsAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFURpsAlarm.setDescription('RFU radio protection switch (RPS) alarm')
rFUTxMuteStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("transmitting", 0), ("muted-by-user", 1), ("muted-due-to-configuration-error", 2), ("muted-due-to-rfu-fault", 3), ("muted-due-to-rfu-configuring", 4), ("muted-due-to-rfu-incompatible-with-cmu", 5), ("muted-due-to-inactive", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxMuteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxMuteStatus.setDescription('Indicates whether the RFU is transmitting or muted. If \n             it is muted, it will also indicate the reason.')
rFUFanAssemblyAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("partial-fan-failure", 1), ("total-fan-failure", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUFanAssemblyAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUFanAssemblyAlarm.setDescription('This indicates when the IRFU transceiver fan assembly \n             has failed. The assembly consists of two fans and if one \n             fan fails, the this will report partial failure. If both \n             fans fail, this will report total failure')
rFUHighTemperatureAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("high-temperature", 1), ("very-high-temperature", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUHighTemperatureAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUHighTemperatureAlarm.setDescription('Indicates when the temperature of the IRFU transceiver \n             has risen above either of two thresholds. If the \n             temperature exceeds the High Temperature threshold, the \n             transmit power may reduce. If the temperature exceeds the \n             Very High Temperature threshold, the transceiver will \n             mute the transmitter')
rFURFSwitchAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("fault", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURFSwitchAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFURFSwitchAlarm.setDescription('This indicates that an RF switch is not present when it \n             should be or that on the most recent attempt to make this \n             unit active, the IRFU RF Switch was not able to switch to \n             the correct position')
rFURxIFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURxIFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFURxIFSynthLockAlarm.setDescription('RFU IF receiver out of lock alarm')
rFUTxIFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTxIFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTxIFSynthLockAlarm.setDescription('RFU IF transmitter out of lock alarm')
rFUPowerButtonPressed = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("irfu-power-button-was-pressed", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUPowerButtonPressed.setStatus('mandatory')
if mibBuilder.loadTexts: rFUPowerButtonPressed.setDescription('IRFU power button have been pressed, IFRU has powered \n             down unexpectedly')
rFUConnectedPlatform = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("odu-a", 1), ("odu-b", 2), ("irfu-hp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUConnectedPlatform.setStatus('mandatory')
if mibBuilder.loadTexts: rFUConnectedPlatform.setDescription('The type of RFU platform currently connected to the CMU')
rFUCommonRFSynthLockAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("out-of-lock", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUCommonRFSynthLockAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFUCommonRFSynthLockAlarm.setDescription('Alarm indicating when the common RFU RF synthesizer is \n             out of lock')
rFUBranchingConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("rfu-1plus0", 0), ("rfu-1plus0-mhsb-ready-equal", 1), ("rfu-1plus0-mhsb-ready-unequal", 2), ("rfu-1plus1-mhsb-equal", 3), ("rfu-1plus1-mhsb-unequal", 4), ("rfu-1plus1-tx-mhsb--rx-sd", 5), ("rfu-2plus0", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rFUBranchingConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: rFUBranchingConfiguration.setDescription('When an IRFU is being installed, the configuration of \n             the IRFU branching unit must be configured. Please see \n             the User Guide for further details')
rFUTransceiverLocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("left-trx-a", 0), ("right-trx-b", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rFUTransceiverLocation.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTransceiverLocation.setDescription('When a 2+0 IRFU is being installed, the user must \n             configure which of the two IRFU transceivers the CMU is \n             controlling in order to ensure correct operation')
rFURfSwitchCableAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("fault", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFURfSwitchCableAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: rFURfSwitchCableAlarm.setDescription('The RF switch in the IRFU is indicating an invalid \n             switch position. The most likely cause is a fault or a \n             disconnection of the cable which connects the transceiver \n             to the RF switch')
rFUReceiveBranchingUnitLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUReceiveBranchingUnitLoss.setStatus('mandatory')
if mibBuilder.loadTexts: rFUReceiveBranchingUnitLoss.setDescription('The receive loss in the IRFU branching unit, expressed \n             in tenths of a dB. The branching unit is a component of \n             the IRFU which is situated between the IRFU transceiver \n             and IRFU antenna port. It provides the necessary \n             filtering, isolation and coupling.')
rFUTransmitBranchingUnitLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 23, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rFUTransmitBranchingUnitLoss.setStatus('mandatory')
if mibBuilder.loadTexts: rFUTransmitBranchingUnitLoss.setDescription('The transmit loss in the IRFU branching unit, expressed \n             in tenths of a dB. The branching unit is a component of \n             the IRFU which is situated between the IRFU transceiver \n             and IRFU antenna port. It provides the necessary \n             filtering, isolation and coupling.')
radioLicenseIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseIdentifier.setDescription('Radio license identifier')
radioLicenseBand = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("band-lower-6-ghz", 0), ("band-7-ghz", 1), ("band-8-ghz", 2), ("band-11-ghz", 3), ("band-13-ghz", 4), ("band-15-ghz", 5), ("band-18-ghz", 6), ("band-23-ghz", 7), ("band-26-ghz", 8), ("band-32-ghz", 9), ("band-38-ghz", 10), ("band-upper-6-ghz", 11), ("band-28-ghz", 12), ("band-42-ghz", 13), ("band-unsupported", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseBand.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseBand.setDescription('Radio license band')
radioLicenseRegion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("etsi", 0), ("fcc", 1), ("canada", 2), ("brazil", 3), ("ntia", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseRegion.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseRegion.setDescription('Radio license region')
radioLicenseTxFreq = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5925000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseTxFreq.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseTxFreq.setDescription('Radio license transmit frequency in kHz')
radioLicenseRxFreq = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5925000, 70000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseRxFreq.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseRxFreq.setDescription('Radio license receive frequency in kHz')
radioLicenseBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("bw-7-mhz", 0), ("bw-10-mhz", 1), ("bw-1375-mhz", 2), ("bw-14-mhz", 3), ("bw-20-mhz", 4), ("bw-275-mhz", 5), ("bw-28-mhz", 6), ("bw-30-mhz", 7), ("bw-40-mhz", 8), ("bw-50-mhz", 9), ("bw-55-mhz", 10), ("bw-56-mhz", 11), ("bw-80-mhz", 12), ("bw-25-mhz", 13), ("bw-60-mhz", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseBandwidth.setDescription('Radio license bandwidth')
radioLicenseMaxEIRP = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-300, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseMaxEIRP.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseMaxEIRP.setDescription('Maximum Effective Isotropic Radiated Power (EIRP) \n             permitted by the license. Expressed in 10ths of dBm')
radioLicenseModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseModulation.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseModulation.setDescription('Radio license modulation')
radioLicenseCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseCodeRate.setDescription('Radio license code rate, multiplied by 100 to give two \n             decimal places of precision')
radioLicenseIncompatibleAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("radio-license-incompatible-with-rfu", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseIncompatibleAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseIncompatibleAlarm.setDescription('Indicates if the radio license is incompatible with the \n             attached RFU. Re-run Installation to correct the issue')
radioLicenseMinModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseMinModulation.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseMinModulation.setDescription('Certain licensing authorities, for example FCC and \n             Industry Canada, require adaptive modulation to be bound \n             by a minimum and maximum modulation mode as defined by \n             the radio license. This attribute is only of significance \n             in such regions and when adaptive modulation is enabled. \n             For other regions, for example ETSI, minimum and maximum \n             modulation mode are directly adjustable by the user and \n             are not defined by the radio license. In general, a \n             modulation mode is defined by two aspects, a modulation \n             and a code rate. This integer attribute identifies the \n             modulation aspect of the RadioLicenseMinModMode attribute \n             required by the radio license. For example, if \n             RadioLicenseMinModMode is configured for 16QAM 0.79, this \n             attribute will be set to a value of 2 which identifies a \n             modulation of 16QAM.')
radioLicenseMinCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseMinCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseMinCodeRate.setDescription('Certain licensing authorities, for example FCC and \n             Industry Canada, require adaptive modulation to be bound \n             by a minimum and maximum modulation mode as defined by \n             the radio license. This attribute is only of significance \n             in such regions and when adaptive modulation is enabled. \n             For other regions, for example ETSI, minimum and maximum \n             modulation mode are directly adjustable by the user and \n             are not defined by the radio license. In general, a \n             modulation mode is defined by two aspects, a modulation \n             and a code rate. This attribute is equal to 100 times the \n             code rate aspect of the RadioLicenseMinModMode attribute \n             required by the radio license. For example, if \n             RadioLicenseMinModMode is configured for QPSK 0.80, this \n             attribute will read 80.')
radioLicenseMaxModulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mod-qpsk", 0), ("mod-8psk", 1), ("mod-16qam", 2), ("mod-32qam", 3), ("mod-64qam", 4), ("mod-128qam", 5), ("mod-256qam", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseMaxModulation.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseMaxModulation.setDescription('Certain licensing authorities, for example FCC and \n             Industry Canada, require adaptive modulation to be bound \n             by a minimum and maximum modulation mode as defined by \n             the radio license. This attribute is only of significance \n             in such regions and when adaptive modulation is enabled. \n             For other regions, for example ETSI, minimum and maximum \n             modulation mode are directly adjustable by the user and \n             are not defined by the radio license. In general, a \n             modulation mode is defined by two aspects, a modulation \n             and a code rate. This integer attribute identifies the \n             modulation aspect of the RadioLicenseMaxModMode attribute \n             required by the radio license. For example, if \n             RadioLicenseMaxModMode is configured for 256QAM 0.91, \n             this attribute will be set to a value of 6 which \n             identifies a modulation of 256QAM.')
radioLicenseMaxCodeRate = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 24, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: radioLicenseMaxCodeRate.setStatus('mandatory')
if mibBuilder.loadTexts: radioLicenseMaxCodeRate.setDescription('Certain licensing authorities, for example FCC and \n             Industry Canada, require adaptive modulation to be bound \n             by a minimum and maximum modulation mode as defined by \n             the radio license. This attribute is only of significance \n             in such regions and when adaptive modulation is enabled. \n             For other regions, for example ETSI, minimum and maximum \n             modulation mode are directly adjustable by the user and \n             are not defined by the radio license. In general, a \n             modulation mode is defined by two aspects, a modulation \n             and a code rate. This attribute is equal to 100 times the \n             code rate aspect of the RadioLicenseMaxModMode attribute \n             required by the radio license. For example, if \n             RadioLicenseMaxModMode is configured for 256QAM 0.91, \n             this attribute will read 91.')
protection = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("hot-standby-1plus1", 1), ("hot-standby-1plus1-with-rx-diversity", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protection.setStatus('mandatory')
if mibBuilder.loadTexts: protection.setDescription('PTP 800 supports a 1+1 Hot Standby configuration where \n             the wireless link is protected against hardware failure. \n             This requires the installation of redundant equipment at \n             each end of the wireless link including a secondary CMU \n             and RFU. At a given end of the wireless link, only one \n             CMU / RFU is Active at any one time, the neighbor CMU / \n             RFU being Inactive. When a fault is detected on the \n             Active CMU / RFU, the Active role will automatically \n             switch to the Inactive CMU / RFU. To enable functionality \n             associated with this feature, this attribute must be \n             configured for a setting of 1+1.')
faultProtectionSwitching = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: faultProtectionSwitching.setStatus('mandatory')
if mibBuilder.loadTexts: faultProtectionSwitching.setDescription('In a 1+1 Hot Standby configuration, protection switching \n             on detection of a fault can be enabled/disabled using \n             this attribute.')
primarySecondaryMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primarySecondaryMode.setStatus('mandatory')
if mibBuilder.loadTexts: primarySecondaryMode.setDescription('At a given end of a 1+1 Hot Standby configuration, one \n             CMU must be configured as Primary, the other CMU as \n             Secondary. When a Protected Link initialises with no \n             faults, the CMUs configured as Primary will become the \n             Active CMUs, that is, the Primary CMUs are the preferred \n             CMUs. When RFUs are connected to the antenna via an \n             Asymmetric Coupler, the RFU which is connected to the \n             Primary CMU should be connected to the Main path of the \n             coupler. This is the path with the lowest loss.')
numberOfAntennas = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("one", 0), ("two", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: numberOfAntennas.setStatus('mandatory')
if mibBuilder.loadTexts: numberOfAntennas.setDescription('This must be configured to match the number of antennas \n             installed at this end of the link.')
primaryRecovery = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryRecovery.setStatus('mandatory')
if mibBuilder.loadTexts: primaryRecovery.setDescription('At a given end of a 1+1 Hot Standby configuration, the \n             CMU configured as Primary is the preferred unit to take \n             the Active role. If the Primary Recovery attribute is set \n             to Enabled at a given end, a protection switch back to \n             the preferred Primary CMU / RFU will occur autonomously \n             if it has stayed free of faults for a configurable period \n             of time determined by the Primary Recovery Period.')
primaryRecoveryPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2880))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: primaryRecoveryPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: primaryRecoveryPeriod.setDescription('At a given end of a 1+1 Hot Standby configuration, the \n             CMU configured as Primary is the preferred unit to take \n             the Active role. If the Primary Recovery attribute is set \n             to Enabled at a given end, a protection switch back to \n             the preferred Primary CMU / RFU will occur autonomously \n             if it has stayed free of faults for a configurable period \n             of time determined by the Primary Recovery Period.')
requestedProtectionState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: requestedProtectionState.setStatus('mandatory')
if mibBuilder.loadTexts: requestedProtectionState.setDescription('In a 1+1 Hot Standby configuration, only one CMU / RFU \n             at a given end of the link is Active at any one time, the \n             neighbor CMU / RFU being Inactive. Use the Requested \n             Protection State attribute to request whether this CMU / \n             RFU should be in the Active or Inactive state.')
antennaReceiveLevelDeltaThreshold = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: antennaReceiveLevelDeltaThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: antennaReceiveLevelDeltaThreshold.setDescription('At a given end of a 1+1 Hot Standby configuration, a CMU \n             will raise an alarm to the management system when the \n             measured receive level adjusted by antenna gain and \n             feeder loss is less than that of its neighbor by more \n             than the Antenna Receive Level Delta Threshold.')
antennaReceiveLevelMeasurementWindow = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2880))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: antennaReceiveLevelMeasurementWindow.setStatus('mandatory')
if mibBuilder.loadTexts: antennaReceiveLevelMeasurementWindow.setDescription('At a given end of a 1+1 Hot Standby configuration, a CMU \n             will raise an alarm to the management system when the \n             measured receive level adjusted by antenna gain and \n             feeder loss is less than that of its neighbor by more \n             than the Antenna Receive Level Delta Threshold. The \n             measurements are averaged over the most recent Antenna \n             Receive Level Measurement Window.')
fiberY = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fiberY.setStatus('mandatory')
if mibBuilder.loadTexts: fiberY.setDescription("One or both ends of a 1+1 Hot Standby system can be \n             connected to the network using an 'Optical-Y Splitter Kit \n             per end'. This end configuration provides a single fiber \n             interface to the network. Any end which is connected to \n             the network using this method must have the Fiber Y \n             attribute set to Enabled. Please note: CMUs must be \n             loaded with boot code version 03-00 or later and recovery \n             version 04-00 or later for Fiber Y to work correctly.")
rxDiversityVlanTpid = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ieee-8021q-tagged-c-tag-type-8100", 0), ("ieee-8021ad-tagged-s-tag-or-b-tag-type-88a8", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rxDiversityVlanTpid.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityVlanTpid.setDescription('When Receive Diversity is enabled, the Inactive CMU \n             sends Rx Diversity Ethernet Frames to the Active CMU. \n             These Ethernet Frames must be VLAN tagged and this \n             attribute controls whether the frames are tagged using \n             the TPID defined by 802.1Q or the TPID defined by \n             802.1ad.')
rxDiversityVid = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 25, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rxDiversityVid.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityVid.setDescription('When Receive Diversity is enabled, the Inactive CMU \n             sends Rx Diversity Ethernet Frames to the Active CMU. \n             These Ethernet Frames must be VLAN tagged and this \n             attribute controls the VLAN Identifier')
protectionAvailabilityStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("not-protected", 1), ("not-protecting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: protectionAvailabilityStatus.setDescription("In a 1+1 Hot Standby configuration, the Protection \n             Availability Status attribute indicates whether the \n             Active unit is currently being protected by the Inactive \n             unit. If it isn't being protected, the Active unit will \n             report Not Protected and the Inactive unit will report \n             Not Protecting.")
protectionConfigurationStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("configuration-not-protecting", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionConfigurationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: protectionConfigurationStatus.setDescription('In a 1+1 Hot Standby configuration, this attribute will \n             indicate whether the configuration will support \n             protection.')
protectionState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionState.setStatus('mandatory')
if mibBuilder.loadTexts: protectionState.setDescription('In a 1+1 Hot Standby configuration, only one CMU / RFU \n             at a given end of the link is Active at any one time, the \n             neighbor CMU / RFU being Inactive. The Protection State \n             attribute indicates whether a CMU / RFU is in the Active \n             or Inactive state.')
activeUnit = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeUnit.setStatus('mandatory')
if mibBuilder.loadTexts: activeUnit.setDescription('At a given end of a 1+1 Hot Standby configuration, one \n             CMU must be configured as Primary, the other CMU as \n             Secondary. When a Protected Link initialises with no \n             faults, the CMU configured as Primary will become the \n             Active CMU, that is, the Primary CMU is the preferred \n             CMUs. The Active Unit attribute indicates whether the \n             active unit is configured as Primary or Secondary.')
protectionSwitchCause = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("no-previous-protection-switch", 0), ("neighbor-cmu-connected-but-not-responding", 1), ("rfu-not-responding", 2), ("rfu-rx-rf-synth-out-of-lock", 3), ("rfu-tx-rf-synth-out-of-lock", 4), ("rfu-common-rf-synth-out-of-lock", 5), ("rfu-cable-failure", 6), ("rfu-cable-attenuator-adjustment-failure", 7), ("rfu-tx-power-degraded", 8), ("data-port-down", 9), ("management-port-down", 10), ("wireless-receive-signal-not-detected", 11), ("byte-error-ratio-over-threshold", 12), ("code-word-error-ratio-over-threshold", 13), ("cmu-rebooting", 14), ("configuration-not-protecting", 15), ("wireless-receive-signal-not-detected-at-remote-end", 16), ("byte-error-ratio-over-threshold-at-remote-end", 17), ("code-word-error-ratio-over-threshold-at-remote-end", 18), ("multiple-receive-failure-at-remote-end", 19), ("primary-recovery", 20), ("managed-protection-switch", 21), ("rfu-rx-if-synth-out-of-lock", 22), ("rfu-tx-if-synth-out-of-lock", 23), ("rfu-common-if-synth-out-of-lock", 24), ("rfu-very-high-temperature", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionSwitchCause.setStatus('mandatory')
if mibBuilder.loadTexts: protectionSwitchCause.setDescription('In a 1+1 Hot Standby configuration, the Protection \n             Switch Cause attribute reports the reason for the last \n             protection switch.')
endId = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 79))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endId.setStatus('mandatory')
if mibBuilder.loadTexts: endId.setDescription('In a 1+1 Hot Standby configuration, the End Id contains \n             the IP address of neighboring CMUs starting with the \n             highest IP address and with a space separating the \n             addresses. It is a single identifier of neighboring \n             CMUs.')
neighborIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: neighborIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: neighborIPAddress.setDescription('In a 1+1 Hot Standby configuration, the Neighbor IP \n             Address identifies the IP Address of the neighbor CMU \n             connected via the Protection Interface.')
neighborMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: neighborMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: neighborMACAddress.setDescription('In a 1+1 Hot Standby configuration, the Neighbor MAC \n             Address identifies the MAC Address of the neighbor CMU \n             connected via the Protection Interface.')
wirelessReceiveSignalStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("not-detected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessReceiveSignalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wirelessReceiveSignalStatus.setDescription('The Wireless Receive Signal Status indicates if the \n             receiver is able to demodulate the transmit signal from \n             the remote end of the link. If it cannot demodulate the \n             signal, a protection switch may occur in a system \n             configured for 1+1 Hot Standby.')
licensedTransmitCapacityStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("less-than-neighbor", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licensedTransmitCapacityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: licensedTransmitCapacityStatus.setDescription('In a 1+1 Hot Standby configuration, the Licensed \n             Transmit Capacity Status attribute indicates when the \n             Licensed Transmit Capacity is below that of its \n             neighbor.')
dataPortEthernetSpeedStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("less-than-neighbor", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortEthernetSpeedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dataPortEthernetSpeedStatus.setDescription('In a 1+1 Hot Standby configuration, the Data Port \n             Ethernet Speed Status attribute indicates if the Ethernet \n             Speed of the Data Port is below that of its neighbor.')
managementPortEthernetSpeedStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("less-than-neighbor", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: managementPortEthernetSpeedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: managementPortEthernetSpeedStatus.setDescription('In a 1+1 Hot Standby configuration, the Management Port \n             Ethernet Speed Status attribute indicates if the Ethernet \n             Speed of the Management Port is below that of its \n             neighbor.')
protectionInterfaceStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("neighbor-not-responding", 1), ("neighbor-not-connected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protectionInterfaceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: protectionInterfaceStatus.setDescription('In a 1+1 Hot Standby configuration, information is \n             shared between neighbor CMUs over the Protection \n             Interface. The Protection Interface Status attribute \n             reports whether the neighbor CMU is successfully \n             responding, physically disconnected or whether it is \n             physically connected but not responding, e.g. powered \n             down.')
remotePrimaryIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePrimaryIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remotePrimaryIPAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Primary \n             IP Address reports the IP address of the CMU which is \n             configured as Primary at the remote end of the wireless \n             link.')
remoteSecondaryIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteSecondaryIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteSecondaryIPAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Secondary \n             IP Address reports the IP address of the CMU which is \n             configured as Secondary at the remote end of the wireless \n             link.')
remotePrimaryMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePrimaryMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remotePrimaryMACAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Primary \n             MAC Address reports the MAC address of the CMU which is \n             configured as Primary at the remote end of the wireless \n             link.')
remoteSecondaryMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteSecondaryMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteSecondaryMACAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Secondary \n             MAC Address reports the MAC address of the CMU which is \n             configured as Secondary at the remote end of the wireless \n             link.')
remotePrimarySecondaryMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("primary", 0), ("secondary", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePrimarySecondaryMode.setStatus('mandatory')
if mibBuilder.loadTexts: remotePrimarySecondaryMode.setDescription('In a 1+1 Hot Standby configuration, this attribute \n             identifies whether the Active Unit at the remote end of \n             the link is configured as Primary or Secondary.')
transmitterStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("muted", 0), ("transmitting", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: transmitterStatus.setDescription('Indicates whether the RFU is transmitting or muted. In a \n             1+1 Hot Standby configuration, it will also indicate if \n             the RFU is Inactive and therefore ready to transmit.')
endWirelessReceiveSignalStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("not-detected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: endWirelessReceiveSignalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: endWirelessReceiveSignalStatus.setDescription('The End Wireless Receive Signal Status indicates if the \n             end of a link is unable to demodulate the signal \n             transmitted from the remote end of the link. When \n             Protection is set to 1+1 Hot Standby, this attribute will \n             indicate Not Detected if the Active CMU is unable to \n             demodulate the wireless signal. When Receive Diversity is \n             enabled, this attribute will indicate Not Detected if \n             both the Active and Inactive CMUs are unable to \n             demodulate the wireless signal.')
rxDiversityDataPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("not-protecting", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityDataPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityDataPortStatus.setDescription('When Receive Diversity is enabled, the Inactive CMU \n             sends Rx Diversity Ethernet Frames to the Active CMU. \n             Before sending these frames, the Data Port MUST be \n             negotiated at 1000 Mbps. This attribute indicates if this \n             is not the case')
rxDiversityAvailabilityStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("not-protected", 1), ("not-protecting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityAvailabilityStatus.setDescription('The Rx Diversity Availability Status attribute will \n             indicate when Receive Diversity is not operating \n             correctly, either due to a fault or due to an incorrect \n             configuration')
rxDiversityConfigurationStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("configuration-not-protecting", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityConfigurationStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityConfigurationStatus.setDescription('For Receive Diversity to operate correctly, certain \n             attributes must be configured correctly on both neighbor \n             CMUs. The Rx Diversity Configuration Status attribute \n             will indicate when this is not the case')
rxDiversityNeighborCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityNeighborCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityNeighborCompatibility.setDescription('For Receive Diversity to operate correctly, both \n             neighbor CMUs must both be configured with the Protection \n             attribute set to �1+1 Hot Standby with Rx Diversity�. \n             The Rx Diversity Neighbor Compatibility attribute \n             indicates when the neighbor CMU is configured to a \n             different setting')
rxDiversityVlanTpidNeighborCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityVlanTpidNeighborCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityVlanTpidNeighborCompatibility.setDescription('For Receive Diversity to operate correctly, both \n             neighbor CMUs must be configured with the same value of \n             Rx Diversity VLAN TPID. The Rx Diversity VLAN TPID \n             Neighbor Compatibility attribute indicates when this is \n             not the case')
rxDiversityVidNeighborCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("mismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDiversityVidNeighborCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: rxDiversityVidNeighborCompatibility.setDescription('For Receive Diversity to operate correctly, both \n             neighbor CMUs must be configured with the same value of \n             Rx Diversity VID. The Rx Diversity VID Neighbor \n             Compatibility attribute indicates when this is not the \n             case')
neighborInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: neighborInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: neighborInternetAddressType.setDescription('The type of Internet address specified by the associated \n             neighborInternetAddress.')
neighborInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 34), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: neighborInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: neighborInternetAddress.setDescription('In a 1+1 Hot Standby configuration, the Neighbor \n             Internet Address identifies the INET Address of the \n             neighbor CMU connected via the Protection Interface.')
remotePrimaryInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePrimaryInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: remotePrimaryInternetAddressType.setDescription('The type of Internet address specified by the associated \n             remoteSecondaryInternetAddress.')
remotePrimaryInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 36), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remotePrimaryInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remotePrimaryInternetAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Primary \n             Internet Address reports the INET address of the CMU \n             which is configured as Primary at the remote end of the \n             wireless link.')
remoteSecondaryInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown-6", 5), ("unknown-7", 6), ("unknown-8", 7), ("unknown-9", 8), ("unknown-10", 9), ("unknown-11", 10), ("unknown-12", 11), ("unknown-13", 12), ("unknown-14", 13), ("unknown-15", 14), ("unknown-16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteSecondaryInternetAddressType.setStatus('mandatory')
if mibBuilder.loadTexts: remoteSecondaryInternetAddressType.setDescription('The type of Internet address specified by the associated \n             remoteSecondaryInternetAddress.')
remoteSecondaryInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 26, 38), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteSecondaryInternetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: remoteSecondaryInternetAddress.setDescription('In a 1+1 Hot Standby configuration, the Remote Secondary \n             Internet Address reports the INET address of the CMU \n             which is configured as Secondary at the remote end of the \n             wireless link.')
activeAvailableTime = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 27, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeAvailableTime.setStatus('mandatory')
if mibBuilder.loadTexts: activeAvailableTime.setDescription('The Active Available Time reports the time which the \n             Wireless Link Status has been Up whilst the CMU/RFU has \n             been in the Active role of a 1+1 Hot Standby \n             configuration. The reported time is since the last \n             statistics reset.')
activeCounterMeasurementPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 27, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeCounterMeasurementPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: activeCounterMeasurementPeriod.setDescription('For a 1+1 Hot Standby link, the elapsed time that the \n             Protection State of the unit has been in the active state \n             since the last reset of the system counters.')
activeWirelessLinkAvailability = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 27, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: activeWirelessLinkAvailability.setStatus('mandatory')
if mibBuilder.loadTexts: activeWirelessLinkAvailability.setDescription('For a 1+1 Hot Standby link, the percentage of time that \n             the unit has been able to successfully demodulate the \n             signal transmitted from the remote end of the link whilst \n             the Protecion State of the unit has been active. This \n             attribute is not updated whilst the Protection State is \n             inactive. Calculated since the last reset of the system \n             counters. The reported value is the percentage multiplied \n             by 10000')
userTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 29, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userTableNumber.setStatus('mandatory')
if mibBuilder.loadTexts: userTableNumber.setDescription('Number of entries in the userTable')
userTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: userTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: userTableIndex.setDescription('used to index values in the userTable.')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('mandatory')
if mibBuilder.loadTexts: userName.setDescription('User name which must be entered, along with the \n             appropriate password, in order to gain access to the \n             system.')
userRole = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("read-only", 0), ("system-administrator", 1), ("security-officer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userRole.setStatus('mandatory')
if mibBuilder.loadTexts: userRole.setDescription('Role of the selected user. A Security Officer has access \n             to and can modify all settings. A System Administrator \n             has access to and can modify all non-security settings. A \n             Read Only user can view settings, but cannot make any \n             changes.')
userEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: userEnabled.setDescription('Enable / Disable the selected user')
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 8, 29, 2, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('mandatory')
if mibBuilder.loadTexts: userPassword.setDescription('User password, which must be entered in order to gain \n             access to the system.')
syslogClient = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 28, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogClient.setStatus('mandatory')
if mibBuilder.loadTexts: syslogClient.setDescription('Enable or disable the syslog client')
syslogState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 28, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogState.setStatus('mandatory')
if mibBuilder.loadTexts: syslogState.setDescription('The syslog service has been enabled or disabled')
longitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 96, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: longitude.setStatus('mandatory')
if mibBuilder.loadTexts: longitude.setDescription('The longitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
latitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 96, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: latitude.setStatus('mandatory')
if mibBuilder.loadTexts: latitude.setDescription('The latitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
altitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 8, 96, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: altitude.setStatus('mandatory')
if mibBuilder.loadTexts: altitude.setDescription('The altitude of the unit, measured in metres. This \n             object is set by the SNMP manager and has no internal \n             function.')
dataPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,3)).setObjects(("CAMBIUM-PTP800-MIB", "dataPortStatus"))
if mibBuilder.loadTexts: dataPortStatusTrap.setDescription('Current status of the data Ethernet link. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
linkNameMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,9)).setObjects(("CAMBIUM-PTP800-MIB", "linkNameMismatch"))
if mibBuilder.loadTexts: linkNameMismatchTrap.setDescription('Signaling was received with the wrong Link Name. Either \n             the Link Name is configured differently at each end of \n             the wireless link, or this unit is aligned to the wrong \n             link partner. NB: A change of value during operation may \n             generate an SNMP trap and/or SMTP email alert')
alignmentModeTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,10)).setObjects(("CAMBIUM-PTP800-MIB", "alignmentMode"))
if mibBuilder.loadTexts: alignmentModeTrap.setDescription('Indicates if the unit is undergoing alignment. NB: a \n             change of state during operation may generate an SNMP \n             trap and/or SMTP email alert')
unitOutOfCalibrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,11)).setObjects(("CAMBIUM-PTP800-MIB", "unitOutOfCalibration"))
if mibBuilder.loadTexts: unitOutOfCalibrationTrap.setDescription('The unit is out of calibration')
encryptionEnabledMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,13)).setObjects(("CAMBIUM-PTP800-MIB", "encryptionEnabledMismatch"))
if mibBuilder.loadTexts: encryptionEnabledMismatchTrap.setDescription('Encryption has been enabled on one end of the wireless \n             link but not the other')
dataPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,17)).setObjects(("CAMBIUM-PTP800-MIB", "dataPortDisabledWarning"))
if mibBuilder.loadTexts: dataPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the data Ethernet interface \n             has disabled Ethernet traffic')
dataPortFiberStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,18)).setObjects(("CAMBIUM-PTP800-MIB", "dataPortFiberStatus"))
if mibBuilder.loadTexts: dataPortFiberStatusTrap.setDescription('If the fiber interface on the data Ethernet port is not \n             OK, there are three possible causes: 1) the fiber \n             interface has been installed but disabled, 2) the \n             interface could not be established even though no LOS was \n             detected (i.e. an optical carrier was detected, which \n             could be due to a broken TX fiber, or because the \n             interface is disabled at the other end of the fiber \n             link), or 3) the interface could not be established and \n             LOS is detected (i.e. no optical carrier is detected). \n             NB: a change of status may generate an SNMP trap and/or \n             SMTP email alert')
dataPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,19)).setObjects(("CAMBIUM-PTP800-MIB", "dataPortConfigurationMismatch"))
if mibBuilder.loadTexts: dataPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) on \n             the data Ethernet port when the link is in full duplex is \n             an indication of an auto-negotiation or forced \n             configuration mismatch')
softwareVersionRemoteCompatibilityTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,20)).setObjects(("CAMBIUM-PTP800-MIB", "softwareVersionRemoteCompatibility"))
if mibBuilder.loadTexts: softwareVersionRemoteCompatibilityTrap.setDescription('Indicates a mismatch of software versions at the two \n             ends of the wireless link')
sNTPSyncTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,21)).setObjects(("CAMBIUM-PTP800-MIB", "sNTPSync"))
if mibBuilder.loadTexts: sNTPSyncTrap.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
managementPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,23)).setObjects(("CAMBIUM-PTP800-MIB", "managementPortStatus"))
if mibBuilder.loadTexts: managementPortStatusTrap.setDescription('Current status of the out-of-band management Ethernet \n             link')
managementPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,24)).setObjects(("CAMBIUM-PTP800-MIB", "managementPortDisabledWarning"))
if mibBuilder.loadTexts: managementPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the out-of-band management \n             Ethernet interface has disabled Ethernet traffic')
rFUStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,27)).setObjects(("CAMBIUM-PTP800-MIB", "rFUStatus"))
if mibBuilder.loadTexts: rFUStatusTrap.setDescription("Current status of the RFU. A state of 'ok' indicates \n             that the RFU is fully operational, although may not be \n             transmitting.")
managementPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,28)).setObjects(("CAMBIUM-PTP800-MIB", "managementPortConfigurationMismatch"))
if mibBuilder.loadTexts: managementPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) on \n             the out-of-band management Ethernet port when the link is \n             in full duplex is an indication of an auto-negotiation or \n             forced configuration mismatch')
wirelessLinkStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,29)).setObjects(("CAMBIUM-PTP800-MIB", "wirelessLinkStatus"))
if mibBuilder.loadTexts: wirelessLinkStatusTrap.setDescription('Current status of the wireless link')
protectionAvailabilityStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,31)).setObjects(("CAMBIUM-PTP800-MIB", "protectionAvailabilityStatus"))
if mibBuilder.loadTexts: protectionAvailabilityStatusTrap.setDescription("In a 1+1 Hot Standby configuration, the Protection \n             Availability Status attribute indicates whether the \n             Active unit is currently being protected by the Inactive \n             unit. If it isn't being protected, the Active unit will \n             report Not Protected and the Inactive unit will report \n             Not Protecting.")
protectionConfigurationStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,32)).setObjects(("CAMBIUM-PTP800-MIB", "protectionConfigurationStatus"))
if mibBuilder.loadTexts: protectionConfigurationStatusTrap.setDescription('In a 1+1 Hot Standby configuration, this attribute will \n             indicate whether the configuration will support \n             protection.')
protectionStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,33)).setObjects(("CAMBIUM-PTP800-MIB", "protectionState"))
if mibBuilder.loadTexts: protectionStateTrap.setDescription('In a 1+1 Hot Standby configuration, only one CMU / RFU \n             at a given end of the link is Active at any one time, the \n             neighbor CMU / RFU being Inactive. The Protection State \n             attribute indicates whether a CMU / RFU is in the Active \n             or Inactive state.')
wirelessReceiveSignalStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,34)).setObjects(("CAMBIUM-PTP800-MIB", "wirelessReceiveSignalStatus"))
if mibBuilder.loadTexts: wirelessReceiveSignalStatusTrap.setDescription('The Wireless Receive Signal Status indicates if the \n             receiver is able to demodulate the transmit signal from \n             the remote end of the link. If it cannot demodulate the \n             signal, a protection switch may occur in a system \n             configured for 1+1 Hot Standby.')
licensedTransmitCapacityStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,36)).setObjects(("CAMBIUM-PTP800-MIB", "licensedTransmitCapacityStatus"))
if mibBuilder.loadTexts: licensedTransmitCapacityStatusTrap.setDescription('In a 1+1 Hot Standby configuration, the Licensed \n             Transmit Capacity Status attribute indicates when the \n             Licensed Transmit Capacity is below that of its \n             neighbor.')
dataPortEthernetSpeedStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,37)).setObjects(("CAMBIUM-PTP800-MIB", "dataPortEthernetSpeedStatus"))
if mibBuilder.loadTexts: dataPortEthernetSpeedStatusTrap.setDescription('In a 1+1 Hot Standby configuration, the Data Port \n             Ethernet Speed Status attribute indicates if the Ethernet \n             Speed of the Data Port is below that of its neighbor.')
managementPortEthernetSpeedStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,38)).setObjects(("CAMBIUM-PTP800-MIB", "managementPortEthernetSpeedStatus"))
if mibBuilder.loadTexts: managementPortEthernetSpeedStatusTrap.setDescription('In a 1+1 Hot Standby configuration, the Management Port \n             Ethernet Speed Status attribute indicates if the Ethernet \n             Speed of the Management Port is below that of its \n             neighbor.')
protectionInterfaceStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,39)).setObjects(("CAMBIUM-PTP800-MIB", "protectionInterfaceStatus"))
if mibBuilder.loadTexts: protectionInterfaceStatusTrap.setDescription('In a 1+1 Hot Standby configuration, information is \n             shared between neighbor CMUs over the Protection \n             Interface. The Protection Interface Status attribute \n             reports whether the neighbor CMU is successfully \n             responding, physically disconnected or whether it is \n             physically connected but not responding, e.g. powered \n             down.')
syslogStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,40)).setObjects(("CAMBIUM-PTP800-MIB", "syslogState"))
if mibBuilder.loadTexts: syslogStateTrap.setDescription('The syslog service has been enabled or disabled')
syslogLocalNearlyFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,41))
if mibBuilder.loadTexts: syslogLocalNearlyFullTrap.setDescription('The syslog local log is nearly full (90%)')
syslogLocalWrappedTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,42))
if mibBuilder.loadTexts: syslogLocalWrappedTrap.setDescription('The syslog local log has wrapped')
secureModeAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,43)).setObjects(("CAMBIUM-PTP800-MIB", "secureModeAlarm"))
if mibBuilder.loadTexts: secureModeAlarmTrap.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
endWirelessReceiveSignalStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,44)).setObjects(("CAMBIUM-PTP800-MIB", "endWirelessReceiveSignalStatus"))
if mibBuilder.loadTexts: endWirelessReceiveSignalStatusTrap.setDescription('The End Wireless Receive Signal Status indicates if the \n             end of a link is unable to demodulate the signal \n             transmitted from the remote end of the link. When \n             Protection is set to 1+1 Hot Standby, this attribute will \n             indicate Not Detected if the Active CMU is unable to \n             demodulate the wireless signal. When Receive Diversity is \n             enabled, this attribute will indicate Not Detected if \n             both the Active and Inactive CMUs are unable to \n             demodulate the wireless signal.')
rxDiversityDataPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,45)).setObjects(("CAMBIUM-PTP800-MIB", "rxDiversityDataPortStatus"))
if mibBuilder.loadTexts: rxDiversityDataPortStatusTrap.setDescription('When Receive Diversity is enabled, the Inactive CMU \n             sends Rx Diversity Ethernet Frames to the Active CMU. \n             Before sending these frames, the Data Port MUST be \n             negotiated at 1000 Mbps. This attribute indicates if this \n             is not the case')
rxDiversityAvailabilityStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,46)).setObjects(("CAMBIUM-PTP800-MIB", "rxDiversityAvailabilityStatus"))
if mibBuilder.loadTexts: rxDiversityAvailabilityStatusTrap.setDescription('The Rx Diversity Availability Status attribute will \n             indicate when Receive Diversity is not operating \n             correctly, either due to a fault or due to an incorrect \n             configuration')
rxDiversityConfigurationStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,47)).setObjects(("CAMBIUM-PTP800-MIB", "rxDiversityConfigurationStatus"))
if mibBuilder.loadTexts: rxDiversityConfigurationStatusTrap.setDescription('For Receive Diversity to operate correctly, certain \n             attributes must be configured correctly on both neighbor \n             CMUs. The Rx Diversity Configuration Status attribute \n             will indicate when this is not the case')
rFUPowerButtonPressedTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,48)).setObjects(("CAMBIUM-PTP800-MIB", "rFUPowerButtonPressed"))
if mibBuilder.loadTexts: rFUPowerButtonPressedTrap.setDescription('IRFU power button have been pressed, IFRU has powered \n             down unexpectedly')
syslogClientTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 8, 99) + (0,49)).setObjects(("CAMBIUM-PTP800-MIB", "syslogClient"))
if mibBuilder.loadTexts: syslogClientTrap.setDescription('Enable or disable the syslog client')
mibBuilder.exportSymbols("CAMBIUM-PTP800-MIB", iPv4Address=iPv4Address, bridge=bridge, ethernetPriorityQueueMapping=ethernetPriorityQueueMapping, systemReset=systemReset, qOSPriorityScheme=qOSPriorityScheme, vectorError=vectorError, ptmp=ptmp, ethernetPriorityTableEntry=ethernetPriorityTableEntry, rFUBranchingConfiguration=rFUBranchingConfiguration, rxDiversityAvailabilityStatus=rxDiversityAvailabilityStatus, rFUCommonIFSynthLockAlarm=rFUCommonIFSynthLockAlarm, managementPortConfigurationMismatchTrap=managementPortConfigurationMismatchTrap, managementPortConfigurationMismatch=managementPortConfigurationMismatch, rFUTransmitBranchingUnitLoss=rFUTransmitBranchingUnitLoss, dataPortPauseFrames=dataPortPauseFrames, remotePrimaryIPAddress=remotePrimaryIPAddress, sMTPDestinationEmailAddress=sMTPDestinationEmailAddress, sNMPTrapTableNumber=sNMPTrapTableNumber, rFUCableAlarm=rFUCableAlarm, antennaReceiveLevelDeltaThreshold=antennaReceiveLevelDeltaThreshold, mPLSTCPriorityTableEntry=mPLSTCPriorityTableEntry, wirelessReceiveSignalStatusTrap=wirelessReceiveSignalStatusTrap, linkLoss=linkLoss, syslogState=syslogState, aTPCEnable=aTPCEnable, rFUTxPowerAlarm=rFUTxPowerAlarm, configuration=configuration, remotePrimarySecondaryMode=remotePrimarySecondaryMode, receiveCodeRate=receiveCodeRate, softwareVersion=softwareVersion, radioLicenseTxFreq=radioLicenseTxFreq, ethernetPriorityTable=ethernetPriorityTable, receiveDataRate=receiveDataRate, rFUTxMuteStatus=rFUTxMuteStatus, sNMPTrapReceiverEnabled=sNMPTrapReceiverEnabled, iPVersion=iPVersion, phyControl=phyControl, requestedProtectionState=requestedProtectionState, rFUVersionBank1=rFUVersionBank1, rFURFSwitchAlarm=rFURFSwitchAlarm, sNTPState=sNTPState, userTableIndex=userTableIndex, radioLicenseMinCodeRate=radioLicenseMinCodeRate, sNMPTrapInternetAddress=sNMPTrapInternetAddress, radioLicenseMinModulation=radioLicenseMinModulation, managementPortEthernetSpeedStatusTrap=managementPortEthernetSpeedStatusTrap, altitude=altitude, syslogClientTrap=syslogClientTrap, receivePower=receivePower, tFTPSoftwareUpgradeStatus=tFTPSoftwareUpgradeStatus, timeZone=timeZone, endId=endId, remoteSecondaryIPAddress=remoteSecondaryIPAddress, secondarySoftwareVersion=secondarySoftwareVersion, unknownNetworkPriorityQueueMapping=unknownNetworkPriorityQueueMapping, longitude=longitude, protectionConfigurationStatus=protectionConfigurationStatus, gatewayIPAddress=gatewayIPAddress, iPDSCPPriorityQueueMapping=iPDSCPPriorityQueueMapping, rFURfSwitchCableAlarm=rFURfSwitchCableAlarm, l2CPPriorityTableNumber=l2CPPriorityTableNumber, vLANManagementPriority=vLANManagementPriority, rFUTxBandAboveRx=rFUTxBandAboveRx, sNTPServerResponse=sNTPServerResponse, radioLicenseMaxModulation=radioLicenseMaxModulation, managementPortEthernetSpeedStatus=managementPortEthernetSpeedStatus, rFULockoutAlarm=rFULockoutAlarm, transmitCapacity=transmitCapacity, localPacketFiltering=localPacketFiltering, subnetMask=subnetMask, sMTPEnabledMessages=sMTPEnabledMessages, unitOutOfCalibrationTrap=unitOutOfCalibrationTrap, ptp=ptp, remoteMaximumTransmitPower=remoteMaximumTransmitPower, managementPortDisabledWarning=managementPortDisabledWarning, rFUTxPowerMax=rFUTxPowerMax, diverseAntennaGain=diverseAntennaGain, radioLicenseRxFreq=radioLicenseRxFreq, userName=userName, securityLevel=securityLevel, dataPortEthernetMediaTypeToUse=dataPortEthernetMediaTypeToUse, encryptionEnabledMismatch=encryptionEnabledMismatch, sNTPPrimaryServerDeadTime=sNTPPrimaryServerDeadTime, activeWirelessLinkAvailability=activeWirelessLinkAvailability, managementPortSpeedAndDuplex=managementPortSpeedAndDuplex, sNMPPortNumber=sNMPPortNumber, syslogStateTrap=syslogStateTrap, neighborInternetAddress=neighborInternetAddress, rxDiversityConfigurationStatus=rxDiversityConfigurationStatus, pubStats=pubStats, licensedTransmitCapacityStatusTrap=licensedTransmitCapacityStatusTrap, phyStatus=phyStatus, sNMPTrapVersion=sNMPTrapVersion, sMTPServerPortNumber=sMTPServerPortNumber, hardwareVersion=hardwareVersion, managementPortWirelessDownAlert=managementPortWirelessDownAlert, softwareVersionRemoteCompatibility=softwareVersionRemoteCompatibility, rxDiversityConfigurationStatusTrap=rxDiversityConfigurationStatusTrap, sntp=sntp, iPDSCPPriorityTableEntry=iPDSCPPriorityTableEntry, rFUPowerAlarm=rFUPowerAlarm, transmitCapacityLimitDetail=transmitCapacityLimitDetail, transmitDataRate=transmitDataRate, telnetPortNumber=telnetPortNumber, secureModeAlarmTrap=secureModeAlarmTrap, mPLSTCPriorityTableNumber=mPLSTCPriorityTableNumber, transmitPower=transmitPower, sNMPTrapInternetAddressType=sNMPTrapInternetAddressType, maxModulation=maxModulation, remotePrimaryInternetAddressType=remotePrimaryInternetAddressType, rFURfBand=rFURfBand, rFUProtectionCompatibility=rFUProtectionCompatibility, rFFeederLoss=rFFeederLoss, rFUType=rFUType, sNTPServerTableIndex=sNTPServerTableIndex, sNTPServerInternetAddress=sNTPServerInternetAddress, l2CPPriorityQueueMapping=l2CPPriorityQueueMapping, enabledDiagnosticProtectionAlarms=enabledDiagnosticProtectionAlarms, userRole=userRole, syslogLocalNearlyFullTrap=syslogLocalNearlyFullTrap, rFUVersionBank2=rFUVersionBank2, rFUCommonRFSynthLockAlarm=rFUCommonRFSynthLockAlarm, managementPortDisabledWarningTrap=managementPortDisabledWarningTrap, mPLSTCPriorityTable=mPLSTCPriorityTable, activeUnit=activeUnit, daylightSaving=daylightSaving, dataPortConfigurationMismatch=dataPortConfigurationMismatch, rFUStatusTrap=rFUStatusTrap, rFUFreqSpacing=rFUFreqSpacing, endWirelessReceiveSignalStatusTrap=endWirelessReceiveSignalStatusTrap, sNTPServerIPAddress=sNTPServerIPAddress, tFTPServerInternetAddress=tFTPServerInternetAddress, dSCPManagementPriority=dSCPManagementPriority, sMTPServerInternetAddressType=sMTPServerInternetAddressType, dataPortEthernetSpeedStatusTrap=dataPortEthernetSpeedStatusTrap, bootVersion=bootVersion, sNTPServerTableNumber=sNTPServerTableNumber, supplementary=supplementary, rFURxFreqMin=rFURxFreqMin, tFTPStartSoftwareUpgrade=tFTPStartSoftwareUpgrade, antennaReceiveLevelMeasurementWindow=antennaReceiveLevelMeasurementWindow, radioLicenseIncompatibleAlarm=radioLicenseIncompatibleAlarm, remoteIPAddress=remoteIPAddress, radioLicenseRegion=radioLicenseRegion, rFUSerial=rFUSerial, radioLicenseMaxEIRP=radioLicenseMaxEIRP, licensedTransmitCapacityStatus=licensedTransmitCapacityStatus, iPv6GatewayAddress=iPv6GatewayAddress, rFUPowerButtonPressedTrap=rFUPowerButtonPressedTrap, radioLicenseMaxCodeRate=radioLicenseMaxCodeRate, encryptionEnabledMismatchTrap=encryptionEnabledMismatchTrap, remoteSecondaryInternetAddress=remoteSecondaryInternetAddress, sNTPServerRetries=sNTPServerRetries, managementPortAutoNegAdvertisement=managementPortAutoNegAdvertisement, encryptionAlgorithmsAvail=encryptionAlgorithmsAvail, transmitCodeRate=transmitCodeRate, ptpTraps=ptpTraps, radioLicense=radioLicense, protectionState=protectionState, activeCounterMeasurementPeriod=activeCounterMeasurementPeriod, tFTPSoftwareUpgradeStatusAdditionalText=tFTPSoftwareUpgradeStatusAdditionalText, dataPortCopperForcedConfiguration=dataPortCopperForcedConfiguration, wirelessLinkAvailability=wirelessLinkAvailability, managementPortForcedConfiguration=managementPortForcedConfiguration, userTable=userTable, dataPortCopperAutoNegotiation=dataPortCopperAutoNegotiation, radioLicenseModulation=radioLicenseModulation, alignmentModeTrap=alignmentModeTrap, enableTransmission=enableTransmission, radioLicenseIdentifier=radioLicenseIdentifier, sNTPServerTableEntry=sNTPServerTableEntry, managementMode=managementMode, dataPortDisabledWarningTrap=dataPortDisabledWarningTrap, syslogControl=syslogControl, remoteInternetAddressType=remoteInternetAddressType, unitOutOfCalibration=unitOutOfCalibration, userTableNumber=userTableNumber, sNTPSync=sNTPSync, diverseRfFeederLoss=diverseRfFeederLoss, iFCableLength=iFCableLength, dataPortCopperAutoNegAdvertisement=dataPortCopperAutoNegAdvertisement, faultProtectionSwitching=faultProtectionSwitching, hTTPPortNumber=hTTPPortNumber, protectionStatus=protectionStatus, vLANManagementVIDValidation=vLANManagementVIDValidation, rFUTxPowerDegradedAlarm=rFUTxPowerDegradedAlarm, rFUFanAssemblyAlarm=rFUFanAssemblyAlarm, wirelessLinkStatus=wirelessLinkStatus, ptp800=ptp800, sMTPServerInternetAddress=sMTPServerInternetAddress, rFURpsAlarm=rFURpsAlarm, hTTPSPortNumber=hTTPSPortNumber, rxDiversityDataPortStatus=rxDiversityDataPortStatus, remoteSecondaryMACAddress=remoteSecondaryMACAddress, iPDSCPPriorityTable=iPDSCPPriorityTable, userPassword=userPassword, rfu=rfu, rFUCableAttenuationAdjustAlarm=rFUCableAttenuationAdjustAlarm, syslogClient=syslogClient, softwareVersionRemoteCompatibilityTrap=softwareVersionRemoteCompatibilityTrap, userEnabled=userEnabled, userTableEntry=userTableEntry, siteName=siteName, ethernetPriorityTableIndex=ethernetPriorityTableIndex, maximumTransmitPower=maximumTransmitPower, dataPortStatus=dataPortStatus, ethernet=ethernet, sNTPServerInternetAddressType=sNTPServerInternetAddressType, rxDiversityNeighborCompatibility=rxDiversityNeighborCompatibility, managementPortStatusTrap=managementPortStatusTrap, tFTPServerPortNumber=tFTPServerPortNumber, remotePrimaryMACAddress=remotePrimaryMACAddress, rFUActiveFirmwareBank=rFUActiveFirmwareBank, sNTPServerPortNumber=sNTPServerPortNumber, transmitModulation=transmitModulation, wirelessLinkStatusTrap=wirelessLinkStatusTrap, alignmentMode=alignmentMode, primaryRecoveryPeriod=primaryRecoveryPeriod, rFUTxIFSynthLockAlarm=rFUTxIFSynthLockAlarm, protection=protection, receiveModulation=receiveModulation, tFTPSoftwareUpgradeStatusText=tFTPSoftwareUpgradeStatusText, sMTPServerIPAddress=sMTPServerIPAddress, rFUPowerButtonPressed=rFUPowerButtonPressed, productVariant=productVariant, minCodeRate=minCodeRate, sNMPTrapIPAddress=sNMPTrapIPAddress, sMTPEmailAlert=sMTPEmailAlert, telnetAccessEnabled=telnetAccessEnabled, encryptionAlgorithm=encryptionAlgorithm, rxDiversityVid=rxDiversityVid, vLANManagementVID=vLANManagementVID, ethernetFiberSupport=ethernetFiberSupport, rFUConnectedPlatform=rFUConnectedPlatform, rxDiversityDataPortStatusTrap=rxDiversityDataPortStatusTrap, smtp=smtp, rxDiversityVlanTpidNeighborCompatibility=rxDiversityVlanTpidNeighborCompatibility, rFUTxFreqMax=rFUTxFreqMax, sNMPTrapTableEntry=sNMPTrapTableEntry, enabledDiagnosticAlarms=enabledDiagnosticAlarms, sNMPTrapTable=sNMPTrapTable, linkNameMismatch=linkNameMismatch, rFUTxRFSynthLockAlarm=rFUTxRFSynthLockAlarm, useVLANForManagementInterfaces=useVLANForManagementInterfaces, neighborInternetAddressType=neighborInternetAddressType, protectionConfigurationStatusTrap=protectionConfigurationStatusTrap, sNTPServerTimeout=sNTPServerTimeout, rFUTransceiverLocation=rFUTransceiverLocation, productName=productName, primarySecondaryMode=primarySecondaryMode, sNMPEnabledTraps=sNMPEnabledTraps, dataPortConfigurationMismatchTrap=dataPortConfigurationMismatchTrap, neighborMACAddress=neighborMACAddress, radioLicenseBand=radioLicenseBand)
mibBuilder.exportSymbols("CAMBIUM-PTP800-MIB", rFURxRFSynthLockAlarm=rFURxRFSynthLockAlarm, rxDiversityVlanTpid=rxDiversityVlanTpid, transmitterStatus=transmitterStatus, protectionAvailabilityStatus=protectionAvailabilityStatus, endWirelessReceiveSignalStatus=endWirelessReceiveSignalStatus, rFUReceiveBranchingUnitLoss=rFUReceiveBranchingUnitLoss, protectionInterfaceStatus=protectionInterfaceStatus, versions=versions, secureModeAlarm=secureModeAlarm, dataPortSpeedAndDuplex=dataPortSpeedAndDuplex, linkName=linkName, dataPortFiberStatusTrap=dataPortFiberStatusTrap, maxCodeRate=maxCodeRate, rxDiversityVidNeighborCompatibility=rxDiversityVidNeighborCompatibility, iPDSCPPriorityTableIndex=iPDSCPPriorityTableIndex, remoteInternetAddress=remoteInternetAddress, remotePrimaryInternetAddress=remotePrimaryInternetAddress, remoteMACAddress=remoteMACAddress, wirelessReceiveSignalStatus=wirelessReceiveSignalStatus, remoteSecondaryInternetAddressType=remoteSecondaryInternetAddressType, l2CPPriorityTableIndex=l2CPPriorityTableIndex, snmpControl=snmpControl, reset=reset, rxDiversityAvailabilityStatusTrap=rxDiversityAvailabilityStatusTrap, hTTPSAccessEnabled=hTTPSAccessEnabled, aggregateDataRate=aggregateDataRate, transmitCapacityLimit=transmitCapacityLimit, sNTPLastSync=sNTPLastSync, managementCommittedInformationRate=managementCommittedInformationRate, linkNameMismatchTrap=linkNameMismatchTrap, sNTPPollInterval=sNTPPollInterval, radioLicenseBandwidth=radioLicenseBandwidth, l2CPPriorityTableEntry=l2CPPriorityTableEntry, sNTPSyncTrap=sNTPSyncTrap, protectionAvailabilityStatusTrap=protectionAvailabilityStatusTrap, rFURxIFSynthLockAlarm=rFURxIFSynthLockAlarm, tFTPServerIPAddress=tFTPServerIPAddress, hTTPAccessEnabled=hTTPAccessEnabled, sNMPTrapTableIndex=sNMPTrapTableIndex, dataPortEthernetSpeedStatus=dataPortEthernetSpeedStatus, rFUHighTemperatureAlarm=rFUHighTemperatureAlarm, l2CPPriorityTable=l2CPPriorityTable, systemClock=systemClock, fiberY=fiberY, protectionStateTrap=protectionStateTrap, syslogLocalWrappedTrap=syslogLocalWrappedTrap, radioLicenseCodeRate=radioLicenseCodeRate, rFURxFreqMax=rFURxFreqMax, rFUPlatformCompatibility=rFUPlatformCompatibility, dataPortFiberStatus=dataPortFiberStatus, iPv6AutoConfiguredLinkLocalAddress=iPv6AutoConfiguredLinkLocalAddress, dataPortDisabledWarning=dataPortDisabledWarning, numberOfAntennas=numberOfAntennas, rFUTxFreqMin=rFUTxFreqMin, alarms=alarms, sMTPSourceEmailAddress=sMTPSourceEmailAddress, iPDSCPPriorityTableNumber=iPDSCPPriorityTableNumber, management=management, ethernetPriorityTableNumber=ethernetPriorityTableNumber, activeAvailableTime=activeAvailableTime, protectionSwitchCause=protectionSwitchCause, encryption=encryption, minModulation=minModulation, cambium=cambium, tFTPServerInternetAddressType=tFTPServerInternetAddressType, rFUTxPowerMin=rFUTxPowerMin, primaryRecovery=primaryRecovery, managementPortStatus=managementPortStatus, protectionInterfaceStatusTrap=protectionInterfaceStatusTrap, tFTPSoftwareUpgradeFileName=tFTPSoftwareUpgradeFileName, licence=licence, iPv6Address=iPv6Address, protectionConfig=protectionConfig, protectionStats=protectionStats, sNTPPrimaryServer=sNTPPrimaryServer, dataPortStatusTrap=dataPortStatusTrap, latitude=latitude, neighborIPAddress=neighborIPAddress, managementPortAutoNegotiation=managementPortAutoNegotiation, sNTPServerTable=sNTPServerTable, antennaGain=antennaGain, dataPortWirelessDownAlert=dataPortWirelessDownAlert, sNMPCommunityString=sNMPCommunityString, mPLSTCPriorityTableIndex=mPLSTCPriorityTableIndex, ptpTrapPrefix=ptpTrapPrefix, iPv6PrefixLength=iPv6PrefixLength, rFUStatus=rFUStatus, mPLSTCPriorityQueueMapping=mPLSTCPriorityQueueMapping, sNMPTrapPortNumber=sNMPTrapPortNumber, aAAControl=aAAControl)
