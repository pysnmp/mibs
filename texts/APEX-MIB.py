#
# PySNMP MIB module APEX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/arris/APEX-MIB
# Produced by pysmi-1.1.12 at Thu Apr  4 13:10:56 2024
# On host fv-az735-175 platform Linux version 6.5.0-1016-azure by user runner
# Using Python version 3.10.14 (main, Mar 20 2024, 15:15:25) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
giproducts, = mibBuilder.importSymbols("BCS-IDENT-MIB", "giproducts")
trapSequenceId, trapNETrapLastTrapTimeStamp, trapChangedObjectId, trapAdditionalInfoInteger1, trapChangedValueOID, trapNetworkElemAdminState, trapNetworkElemOperState, trapNetworkElemModelNumber, trapChangedValueDisplayString, trapIdentifier, trapChangedValueIpAddress, trapAdditionalInfoInteger3, trapPerceivedSeverity, trapNetworkElemAvailStatus, trapAdditionalInfoInteger2, trapNetworkElemAlarmStatus, trapNetworkElemSerialNum, trapChangedValueInteger, trapText = mibBuilder.importSymbols("BCS-TRAPS-MIB", "trapSequenceId", "trapNETrapLastTrapTimeStamp", "trapChangedObjectId", "trapAdditionalInfoInteger1", "trapChangedValueOID", "trapNetworkElemAdminState", "trapNetworkElemOperState", "trapNetworkElemModelNumber", "trapChangedValueDisplayString", "trapIdentifier", "trapChangedValueIpAddress", "trapAdditionalInfoInteger3", "trapPerceivedSeverity", "trapNetworkElemAvailStatus", "trapAdditionalInfoInteger2", "trapNetworkElemAlarmStatus", "trapNetworkElemSerialNum", "trapChangedValueInteger", "trapText")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, MibIdentifier, Gauge32, Unsigned32, Counter64, Integer32, ObjectIdentity, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, iso, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "Gauge32", "Unsigned32", "Counter64", "Integer32", "ObjectIdentity", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "iso", "TimeTicks", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
apex = ModuleIdentity((1, 3, 6, 1, 4, 1, 1166, 1, 31))
apex.setRevisions(('2014-10-22 00:00', '2014-08-04 00:00', '2014-06-27 00:00', '2013-01-25 00:00', '2012-08-27 00:00', '2011-02-15 00:00', '2010-08-17 00:00', '2010-06-30 00:00', '2010-03-05 00:00', '2010-01-19 00:00', '2009-10-16 00:00', '2009-09-14 00:00', '2009-06-09 00:00', '2009-04-20 00:00', '2009-04-08 00:00', '2009-04-14 00:00', '2009-03-23 00:00', '2009-03-10 00:00', '2008-07-24 00:00', '2008-07-08 00:00', '2008-02-18 14:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: apex.setRevisionsDescriptions(('Version 2.10:\n\n                      Nov 18, 2014\n                      - Updated description of apexAlarmQamModuleRemovalFault \n                      \n                      Oct 22, 2014\n                      - Added fileSet4 to apexQrmDownloadFileSet.\n                      \n                      Oct 17, 2014\n                      - Added apexGbeStatInTsCurPacketDropCount to apexGbeStatusInputTsEntry\n                        in apexGbeStatusInputTsTable.\n                      - Changed apexGbeStatInTsPacketDropCount to apexGbeStatInTsTotPacketDropCount.\n                      \n                      Oct 13, 2014\n                      - Added apexMcSimConfig\n                      - Added apexOutputProgramMcSimAccessCriteriaString.\n                      \n                      Sep 26, 2014\n                      - Added apexGbeStatInTsPacketDropCount to apexGbeStatusInputTsEntry\n                        in apexGbeStatusInputTsTable.\n                      - Added apexEnableGbeInputStreamPacketDrop to apexConfigAlarms.\n                      - Added apexAlarmGbeInputStreamPacketDrop to apexAlarms.\n                      - Added apexGbeStatInTsPacketDropError to apexGbeStatusInputTsErrorEntry\n                        in apexGbeStatusInputTsErrorTable.\n                      - Added apexGbeStatusInputTsDropCounter.\n                      - Added trapGbeInputStreamPacketDrop.\n                      - Added apexGbeConfigInputDataTsMaxRate to apexGbeConfigInputDataTsEntry\n                        in apexGbeConfigInputDataTsTable.\n                      \n                      Sep 24, 2014\n                      - Updated the version\n                      - Added new Alarm configuration parameter apexEnableQamModuleRemovalFault\n                        in apexConfAlarmEnable.\n                      - Added new Fault Alarm apexAlarmQamModuleRemovalFault in apexAlarms.\n                      - Added new Fault Trigger apexChassisRedundancyFailOverQamModuleRemoval\n                        in apexChassisRedundancyConfigGeneral.\n                      - Added new Trap trapQamModuleRemovalFault in apexTraps.\n                     \n                      Sep 18, 2014\n                      - Updated the version.\n                      - Added new status parameter apexOutputProgramCurrentCSN to the\n                        apexOutputProgramTable.\n                      - Added apexOutputTsConfAutoSDTEnable.\n                     ', 'Version 2.9:\n                     \n                     July 30, 2014\n                     - Updated the version.\n                     - Updated valid range of apexEcmEmmFirstPid to (2..7591)\n\n                     ', 'Version 2.8:\n                     \n                     June 27, 2014\n                     - Updated the description of apexSimulcryptExternalEisSetting,\n                       apexOutputTsConfEncryptionType.\n                     \n                     June 27, 2014\n                     - Updated the description of apexOutputTsConfSimulcryptMode.\n                     \n                     Jun 17, 2014\n                      - Changed the name of apexOutputProgramRdsSimAC to \n                        apexOutputProgramMcSimAccessCriteria.\n                      - Changed the name of to apexOutputProgramSimAcStatus\n                        apexOutputProgramMcSimAccessCriteriaStatus\n                     \n                     Jun 05, 2014\n                     - Updated the description of apexOutputTsConfOperatingMode.\n\n                     Jun 04, 2014\n                     - Added two new status values for apexRdsConnectionStatus.\n                     \n                     Jun 02,2014\n                     - Added apexPsPowerFaultFilter\n \n                      May 28, 2014\n                      - Updated valid range of apexEcmEmmFirstPid to (2..7590)\n                      \n                      May 21, 2014\n                      - Renamed apexChassisRedundancyMCSimEntitlementMismatchStatus\n                        to apexChassisRedundancyMCSimEntitlementStatus\n                      - Renamed apexChassisRedundancyAppliedEncAlgorithmMismatchStatus\n                        to apexChassisRedundancyAppliedEncAlgorithmStatus\n                        \n                      May 14, 2014\n                      - Added apexChassisRedundancyMCSimEntitlementMismatchStatus,\n                        apexChassisRedundancyAppliedEncAlgorithmMismatchStatus.\n\n                      May 12, 2014\n                      - Added the following MIB objects.\n                        apexEncryptionConfApplyChange\n                        apexEncryptionConfInvalidApplyText\n                      \n                      \n                     May 8,2014\n                     - Added (fixed/missing MediaCipher Simulcrypt mib objects)\n                     \n                      Mar 13, 2014\n                      - Added apexSimulcryptEcmgStatusTable.\n\n                     March 07, 2014\n                     - Added apexUls for support of MediaCipher Simulcrypt\n                     \n                      Oct 22, 2013\n                      - Added the following objects\n                        apexOutputProgramRdsSimAC\n                        apexOutputProgramSimAcStatus\n                        apexRdsDeviceId\n\n                      - Updated the following MIB objects\n                        apexEncryptionConfAlgorithm  - Added new Algorithms for Sierra Mode\n                        apexEncryptionStatAlgorithm  - Added new Algorithms for Sierra Mode\n\n                      - Updated the description for the following object                       \n                        apexOutputTsConfOperatingMode\n\n                     ', 'Version 2.7:\n                      Jan 25, 2013\n                      - Updated the description for the following object                       \n                        apexPsiCcErrorDetectionEnabled - changed the default value to enable\n\n                      Jan 04, 2013\n                      - Updated the description for the following objects\n                        apexPsiCcErrorDetectionTimeout\n                        apexPsiCcErrorDetectionEnabled\t\t     \n                     \n                      December 28, 2012\n                      - Added the following objects under the group apexPsiConfigGeneral\n                        apexPsiCcErrorDetectionTimeout\n                        apexPsiCcErrorDetectionEnabled\n\n                      ', "Version 2.6:\n                     \n                      August 27, 2012\n                      - Added apexEventLossOfInputAncillaryPid and trapLossOfInputAncillaryPidEvent\n                     \n                      August 21, 2012\n                      - Moved the SNMP community string change MIB parameters to private mib\n                     \n                      July 20, 2012\n                      - Added trap trapSnmpCommunityStringChanged and the apex event\n                        apexEventSnmpCommunityStringChanged\n                        Changed the OID (and moved) the trap trapEasMessageNotReceived\n                        and the apex event apexEventEasMessageNotReceived.\n                        \n                      July 17, 2012\n                      - Added the below MIB objects to detect and notify the \n                        loss of input ancillary PID.\n                        apexPidMapInputAncillaryPidDetection, \n                        apexPidMapInputAncillaryPidDetectionTimeout,\n                        apexAlarmLossOfInputAncillaryPid, \n                        apexEnableLossOfInputAncillaryPid,\n                        trapLossOfInputAncillaryPid\n                        \n                      - Added the apexOutputAncillaryPid to report the \n                        average bitrate of each ancillary PID\n                        \n                      July 12, 2012\n                      - Added apexEventEasMessageNotReceived and updated the description of \n                        trapEasMessageNotReceived\n                        \n                      July 04, 2012\n                      - Updated the description of apexPidMapConfigApplyChange parameter\n                      - Renamed apexPidMapConfigApplyChange as apexBulkPidMapInvalidApplyText\n                        and moved under apexPidMapStatus\n                      \n                      June 21, 2012\n                      - Added the below new objects to support autonegotiation\n                        configuration.\n                          apexOampNetworkDuplexMode, apexOampNetworkSpeed,\n                          apexDataIpNetworkDuplexMode, apexDataIpNetworkSpeed\n                      - Added the below new objects to get the current autonegotiation\n                        enable/disbale status.                       \n                        apexOampCurrentAutoNegotiateState,\n                        apexDataIpCurrentAutoNegotiateState \n                      - Removed the text 'disabled is not supported' from the\n                        description for the following objects as disabling of\n                        autonogotiation is supported.\n                          apexOampAutoNegotiate, apexDataIpAutoNegotiate                   \n                      - Added the following new objects to support EAS message not \n                        received event.\n                          apexEasMessageReceiveTimeoutDuration, \n                          apexEasMessageReceiveTimeoutEventEnable,\n                          apexEasLastReceivedMessageStatusTable,\n                          trapEasMessageNotReceived\n                      - Modified apexDtaGeneralConfigCatEmmPidInterface to support \n                        GIGE input.\n                      - Added apexManualRoutingServiceStatus to support maping\n                        of error status for the services in apexManualRouteTable.\n                      - Added apexBulkPidMapApplyTable,apexBulkPidMapTable and \n                        apexPidMapConfigGeneral to support ancillary PID routing for \n                        all QAM's.\n                      ", "Version 2.5:\n                     \n                      February 15, 2011\n                      - Updated the description for apexDtaConfigApplyChange\n                      - Corrected the range of values for apexQamRfPortChannelInfoChanA.\n                     \n                      January 27, 2011\n                      - Updated the description for apexDtaGeneralConfigInvalidApplyText. \n                                          \n                      January 10, 2011\n                      - Added apexChassisRedundancyRedundantApexSecIp, \n                        apexChassisRedundancyRedundantHBEnable,\n                        apexChassisRedundancyCurrHBIntfIPStatus\n                     \n                      December 20, 2010                   \n                      - apexQamConfigApplyTable does not set apply change for apexQamChannelConfigTable\n\n                      - Added channel apply table apexQamChannelConfigApplyTable\n\n                      - Added status MIB variables for 4x4 apexQamModuleStatBoardTemperature, \n                        apexQamModuleStatBoardTemperatureFault, apexQamModuleStat5VdcSupplym, \n                        apexQamModuleStat5VdcFault, apexQamModuleStat3dot3VdcSupply, \n                        apexQamModuleStat3dot3VdcFault, apexQamModuleStatCommError, \n                        apexQamModuleStatCodeInitError\n\n                      - Added QAM versions MIB variable apexQamQrmRevFpga2\n\n                      - Added QAM version status MIB variable apexQamQrmRevStatFpga2\n\n                      - Added QAM file revision information MIB variables apexQrmFileRevFpga2 \n                        and apexQrmFileRevDateTime\n\n                      - Added EM support MIB tables apexQamRfPortChannelInfoTable and \n                        apexQamChannelIdTable\n\n                      - Added 4x4 error codes dc5VoltError,dc3-3VoltError,commLost,codeVersions,\n                        codeDownload,codeDownloadError\n\n                      - Number of RF ports increased to 12 for apexQamConfigApplyRfPortNum\n                      - Number of RF ports increased to 12 for apexQamRfPortStatRfPortNum\n                      - Number of RF ports increased to 12 for apexQamRfPortMuteStatusRfPortNum\n                      - Number of File Revisisons increased to 3 for apexQrmFileRevFileSetNum\n                      - Number of RF ports increased to 12 for apexRpcRfPortNum\n                      - Number of RF ports increased to 12 for apexEasServerNum\n\n                      - Added qam4x4Channel for apexQamModuleStatInstalled\n                      - Added any4x4 for apexQamRfRedundStatusMismatch MIB parameter\n                      - Added fileSet3 for apexQrmDownloadFileSet MIB parameter\n                      \n                      December 10, 2010                   \n                      - Updated RF Port and OTS numbers mapping in the description for apexDtaConfigApplyChange.\n                      \n                      December 6, 2010                   \n                      - Changed the range of apexDtaConfigApplyIndex and apexDtaRfPortConfigIndex \n                        from '1 to 6' to '1 to 12' to support 4x4 QAM also.\n                      \n                      December 3, 2010\n                      - Added apexOutputTsStatusServicesMuxed new OutputStream stats field\n\n                      November 23, 2010\n                      - Added new pid-remapping mode 'unrestricted'\n                      \n                      November 18, 2010\n                      - Added new configuration parameter apexProgramBasedPmtOffset\n                      - Added new pid remapping mode remapProgramBased2                      \n                      \n                      November 11, 2010\n                      - Obsoleted apexEventChassisRedunPrimaryForceFailover,\n                        apexEventChassisRedunSecondaryForceFailover.\n                      - Added apexChassisRedundancyGigEMismatchStatus, apexChassisRedundancyQamMismatchStatus, \n                        apexChassisRedundancyFirmwareMismatchStatus.\n                      - Added apexChassisRedundancyGigE12LinkStatus, apexChassisRedundancyGigE34LinkStatus.\n                     ", 'Version 2.3:\n                      August 17, 2010\n                      - Added new values for apexRtspConfMhaSbeApsLevel.\n\n                      July 23, 2010\n                      - Added apexChassisRedundancyPrimaryStandbyOverride which\n                        will force the primary apex to go active\n                     ', 'Version 2.2:\n                     \n                      June 30, 2010\n                      - Renamed apexManRteGbeInRedConfigStatMapTable to apexManRteGbeInRedStatusMapTable, \n                        and moved the table to apexManualRoutingStatus Group.\n\n                      June 29, 2010\n                      - Added apexManRteGbeInRedConfigStatMapTable to provide the mapping \n                        between apexManRteGbeInRedTable and apexInputTsStatTable.\n                      - Corrected parent node for apexManRteGbeInRedApplyEntry to\n                        apexManRteGbeInRedApplyTable.\n\n                      June 25, 2010\n                      - Obsoleted apexEasApplyChange, apexEasPhysInType, \n                        apexEasPhysInPort, apexEasRcvUdpPort, apexEasMulticastIpAddress, \n                        apexEasSourceIpAddress.\n                      - Added apexEasServerTable containing apexEasServerNum,\n                        apexEasServerPhysInType, apexEasServerPhysInPort, apexEasServerRcvUdpPort, \n                        apexEasServerMulticastIpAddress, apexEasServerSourceIpAddress.\n                      - Added apexEasServerApplyTable which includes \n                        apexEasServerApplyChange.\n\n                      June 24, 2010\n                      - Added enumeration to apexQamRfPortStatCodeInitError.\n\n                      June 22, 2010\n                      - Changed range of apexQamRfPortStatNumChannelsActive to 0..8.\n                      - Changed descriptions of apexQamModuleStatTemperature,\n                        apexQamModuleStatPowerFault, apexQamQrmRevFpga,\n                        apexQamRfPortStatTemperature, and apexQamQrmRevBootLoaderFw.\n                      - Moved apexRpcRfPortTable and apexRpcRfChannelTable to the\n                        apexRpcConfig group and renumbered apexRpcAvgBandwidthEnable,\n                        and apexRpcApplyChange in apexRpcConfigGeneral.\n\n                      June 16, 2010\n                      - Added apexRpcDeviceName, apexRpcDeviceType, apexRpcControlInterface, \n                        apexRpcNumShellSessions, apexRpcRfPortTable, apexRpcRfChannelTable, \n                        apexRpcAvgBandwidthEnable, apexRpcApplyChange.\n\n                      June 14, 2010\n                      - Added apexOutputTsStatusScgsProvisioned.\n\n                      June 10, 2010\n                      - Moved apexRdsEventTable to apexRdsStatus group from\n                        apexManualRoutingStatus group.\n\n                      June 04, 2010\n                      - Removed apexDtaEventTable.\n                      - Renamed apexIppvEventTable to apexRdsEventTable and renamed\n                        all the members from apexIPPVEvent*** to apexRdsEvent***.\n                      - Added apexRdsEventPrkmWkemAvailable and apexRdsEventCcmAvailable\n                        members in the table apexRdsEventTable.\n\n                      June 03, 2010\n                      - Modified the scalar apexOutputProgramDtaServiceEncryptionMode\n                        to apexOutputProgramDtaEncryptionMode.\n                      - Updated the description of apexRdsSetDefault.\n\n                      May 28, 2010\n                      - Added the following MIB variables\n                        apexDtaEventTable, apexOutputProgramDtaServiceEncryptionMode\n                        apexOutputProgramDtaServiceEncryptionMode.\n                    \n                      May 27, 2010\n                      - Added apexChassisRedundancyEventTable.\n \n                      May 25, 2010\n                      - Added apexOutputTsStatusMessageGenerationNum.\n \n                      May 18, 2010\n                      - Changed apexPidMapIndex and apexPidMapApplyIndex size.\n\n                      May 10, 2010\n                      - Added the static routing configuration table apexFastEnetRoutingTable.\n\n                      May 5, 2010\n                      - Added Follow DTCP support variables, apexSesContConfFollowDtcp and\n                        apexUdpMapFollowDtcp.\n                       \n                      April 13, 2010\n                      - Updated the resource descriptions for MIB variables after review.\n                     \n                      April 7, 2010\n                      - Changed description of apexDepiSessionConfigUdpPort to reflect\n                        new range.\n\n                      March 25, 2010\n                      - Added the following configuration parameters:\n                        apexIppvEventTable, apexOutputProgramProgramType,\n                        apexRdsConfigRds2Enable, apexRdsConfigServerUrl,\n                        apexRdsStatusServerIp, apexRdsStatusServerPort,\n                        apexRdsStatusServerRootDirPath, and apexRdsStatusValidation.\n\n                      March 10, 2010\n                      - Changed the apexDepiSessionConfigUdpPort field possible range.\n\n                      March 8, 2010\n                      - Added apexDepiSessionStatusSessionID new Depi Session Status field.\n                     ', 'Version 2.1:\n\n                     March 5, 2010\n                     - Changed comment in apexSesContConfRedundType description field.\n                      \n                     February 19, 2010\n                     - Change range for MHA and RTSP Manager ports.\n                     ', "Version 2.0:\n                      \n                     January 19, 2010                   \n                     - Added comments in apexPsipStatusInputMessageType description field.\n                     - Added comments in apexPsipStatusOutputMessageType description field.\n \n                     January 13, 2010\n                     - Added apexRtspConfMhaSbe, apexRtspConfMhaSbeEncryptionMode,\n                       apexRtspConfMhaSbeCciLevel, apexRtspConfMhaSbeApsLevel,\n                       apexRtspConfMhaSbeCitSetting, apexRtspConfMhaSbeApplyChange,\n                       apexRtspConfMhaGeneral, and apexRtspConfMhaUdpMapEnable.\n                     - Added 'Not supported' to apexDepiControlConfigType.\n                     \n                     December 28, 2009\n                     - Added apexGbeIpFragmentedPkts and apexGbeTotalIpFragmentedPkts.\n\n                     December 22, 2009\n                     - Changed SYNTAX of apexPsipConfigApplyChange and\n                       apexPsipConfigTimeApplyChange to ApplyDataToDeviceTYPE.\n\n                     December 18, 2009\n                     - Changed apexPsipApplyChange to apexPsipConfigApplyChange\n                       in descriptions for apexPsipConfigGeneral entries. \n                     - Changed apexPsipApplyTimeChange to\n                       apexPsipConfigTimeApplyChange in descriptions for\n                       apexPsipConfigTime entries. \n                     - Changed SDM file annotation to config.ini for \n                       apexGbeConfInputUnicastTimeout,\n                       apexGbeConfInputMulticastTimeout, and\n                       apexGbeConfLossOfInputTsType.\n                     \n                     December 17, 2009\n                     - Deleted duplicate header comment and removed extraneous line\n                       termination characters.\n                     \n                     December 14, 2009\n                     - Added SDM Commit annotations and additional text to the descriptions\n                       of apexMcEmmInsertionMode, apexMcEmmInsertionPid1Enable,\n                       apexMcEmmInsertionPid1, apexMcEmmInsertionPid2Enable, and\n                       apexMcEmmInsertionPid2.\n                     \n                     December 3, 2009\n                     - Removed 'Not supported' from apexOutputTsConfPsipEnable\n                       description.\n                     \n                     November 17, 2009\n                     - Added apexGbeStatusInterfaceRedundFaultCondition.\n                     \n                     November 12, 2009\n                     - Added zero as valid integer and updated description for\n                       apexGbeStatusInterfaceRedundActiveIf. \n                     \n                     November 6, 2009\n                     - Corrected index in apexGbeStatusInterfaceRedundEntry.\n                     \n                     November 5, 2009\n                     - Changed description for apexGbeConfIfRedundForceFailover.\n                     \n                     November 4, 2009\n                     - Added apexGbeStatusInterfaceRedund and apexGbeConfigInterfaceRedundancy.\n                     - Corrected range on apexChassisRedundancyUdpPort\n                     \n                     November 2, 2009\n                     - Added trapGigeToHostCommFault\n                     \n                     October 30, 2009\n                     - Added apexQamRfPortStatCodeInitError, apexQamQrmRevisionStatusTable,\n                       apexQrmDownloadConfigTable, apexQrmDownloadSupported, apexQrmDownloadRequired,\n                       apexQrmDownloadFileSet, and apexQrmFileRevisionTable.\n\n                     October 29, 2009\n                     - Made apexSesContConfRedundThreshold obsolete.\n\n                     October 29, 2009\n                     - Added apexPsipStatusServiceTable.\n                     - Added apexPsipStatusOutputTable.\n                     - Added apexPsipStatusInputTable.\n\n                     October 29, 2009\n                     - Added apexAlarmGigeToHostCommFault\n\n                     October 26, 2009\n                     - Added apexGbeConfInRedundManualRouteRedundType and\n                       apexSesContConfRedundType.\n\n                     October 19, 2009\n                     - Merged 2.3.x MIB (version 1.9).\n                     - Brought in version 1.9 Revision Description.\n\n                     October 7, 2009\n                     - Added apexRtspStatQamMptsModeTable.\n\n                     October 2, 2009\n                     - Added apexRtspConfMhaTable.\n\n                     September 30, 2009\n                     - Added apexPsip group.\n\n                     September 17, 2009\n                     - Added apexGbeRxDocsisFrames, apexGbeRxMpegDocsisFrames,\n                       and apexGbeTotalRxDocsisFrames.\n\n                     September 9, 2009\n                     - Added apexGbeConfInputUnicastTimeout,\n                       apexGbeConfInputMulticastTimeout,\n                       and apexGbeConfLossOfInputTsType.\n\n                     June 2, 2009\n                     - Merged 2.1.1E MIB (version 1.7).\n                     - Brought in version 1.7 Revision Description.\n                     ", 'Version 1.10:\n\n                     October 16, 2009\n                     - Added apexSysConfigMcEmmInsertion.\n                     ', 'Version 1.9:\n\n                     October 8, 2009\n                     - Added enumeration for Watchdog Reboot Reason.\n\n                     September 14, 2009\n                     - Corrected @Commit annotation in Chassis redundancy and DTA\n                       CAT configuration params.\n\n                     September 07, 2009\n                     - Added apexChassisRedundancyGeneralConfigSyncStatusText.\n\n                     August 31, 2009\n                     - Changed enumeration values of\n                       apexChassisRedundancyMulticastRedundancyMode.\n\n                     August 26, 2009\n                     - Added apexQamRfPortMuteStatusTable.\n\n                     August 19, 2009\n                     - Removed DTA Network pid params from apexQamRfConfigTable,\n                       DTA Enable from apexQamChannelConfigTable,\n                       and apexQamStatusInvalidApplyText.\n                     - Added apexDtaConfigApplyTable, apexDtaRfPortConfigTable and\n                       apexDtaOtsConfigTable.\n\n                     August 17, 2009\n                     - Added apexChassisRedundancyUdpPort,\n                       apexChassisRedundancyRedundantApexIp,\n                       apexChassisRedundancyFailOverEnet2LinkLoss,\n                       apexChassisRedundancyStatusInvalidApplyText,\n                       apexEventChassisRedunPrimaryForceFailover,\n                       apexEventChassisRedunSecondaryForceFailover,\n                       apexEventChassisRedunFirmwareVersionMismatch, and\n                       apexEventChassisRedunQAMVersionMismatch.\n\n                     August 13, 2009\n                     - Added apexDtaGeneralConfigInvalidApplyText, apexQamStatusInvalidApplyText\n                       to know DTA CAT, NET and EMM pid number validation status from host.\n\n                     August 06, 2009\n                     - Removed apexEventChassisRedundancySecondaryFailOver.\n                     - Added apexAlarmChassisRedundancySecondaryFailover and\n                       apexEnableChassisRedundancySecondaryFailover.\n\n                     August 5, 2009\n                     - DTA NET and CAT/EMM pid ranges and default values are changed.\n\n                     August 3, 2009\n                     - Added apexDtaConfigApplyChange parameter.\n                     - Added/Merged Chassis level DTA parameters, RF Port level DTA\n                       parameters and DTA enable status for each OTS/QAM Channel.\n\n                     July 31, 2009\n                     - Added apexChassisRedundancyConfigApplyChange and\n                       apexChassisRedundancyConfigEnable.\n\n                     June 26, 2009\n                     - Removed apexChassisRedundancyFailOverHwFault.\n\n                     June 25, 2009\n                     - Added Suspend and Config Sync states to primary and\n                       secondary apex status params.\n\n                     June 9, 2009\n                     - Added apexOampLinkActive and apexDataIpLinkActive.\n\n                     May 27, 2009\n                     - Added Chassis Redundancy groups apexChassisRedundancyConfig\n                       and apexChassisRedundancyStatus.\n                     - Added Chassis Redundancy alarms, events, and traps.\n                     ', 'Version 1.8:\n\n                     June 9, 2009\n                     - Added apexOampLinkActive and apexDataIpLinkActive.\n                     ', "Version 1.7:\n\n                     Based on 2.1.0 and it does not contain MIB changes from\n                     MIB version 1.5 and 1.6.\n                     [Apex 2.2 release and Apex 2.1.4 release.]\n\n                     April 20, 2009\n                     - Removed @Config(config=yes, reboot=no)\n                               @Commit(param=apexDepiControlConfigApplyChange, value=2)\n                               @Save(apexSaveConfig, value=2)\n                               @File(config.ini, type='ini')\n                       from table objects and put into apexDepiControlConfigTable.\n                     - Did the same for apexDepiSessionConfigTable.\n\n                     April 08, 2009\n                     - Put back apexDepiSessionStatusInSequenceDiscards back in.\n\n                     April 02, 2009\n                     - Removed apexDepiSessionStatusInSequenceDiscards\n                     - Changed enums of Control and Session status\n\n                     March 19, 2009\n                     - Updated the DEPI Statistics and status related MIBs.\n                     - Removed Mcmts from the DEPI related MIB groups\n                     - Renamed mcmtsDocsis operating mode to Depi\n                     - Renamed apexMcmtsDepiControlConfigDynamic to\n                       apexDepiControlConfigType\n                     - Added the DtiSyncLoss Trap\n\n                     February 9, 2009\n                     - Added M-CMTS support group apexDepiControl.\n                     - Added mcmtsDocsis to apexOutputTsConfOperatingMode\n                     ", 'Version 1.6:\n\n                     [Note: Version 1.6 was for APEX Release 2.1.5.  Changes in this\n                            version are also in Version 1.5.  This description is\n                            added to the merged Version 2.0 for completeness.]\n\n                     April 8, 2009\n                     - Added apexUdpMapMulticastTable, apexUdpMapMulticastApplyTable,\n                       apexUdpMapStatusGeneral, apexUdpMapMulticastInvalidApplyText.\n                     ', 'Version 1.5:\n\n                     April 14, 2009\n                     - Added apexUdpMapStatusGeneral, apexUdpMapMulticastInvalidApplyText.\n\n                     April 13, 2009\n                     - Added apexUdpMapMulticastTable, apexUdpMapMulticastApplyTable.\n\n                     March 31, 2009\n                     - Added dvb-csa-simulcrypt to list for Encryption algorithm\n\n                     March 24, 2009\n                     - Added apexGbeInputDataTsSmoothingPeriod, apexGbeInputDataTsBufferDepth\n                       apexGbeConfigInputDataTsApplyText, apexGbeConfigInputDataTsTable,\n                       apexGbeConfigInputDataTsApplyTable.\n                     ', 'Version 1.4:\n\n                     March 24, 2009\n                     - Added remapProgramBased to apexOutputTsConfPidRemappingMode.\n\n                     March 23, 2009\n                     - Added 3, 5, and 7 to range of apexQamRfConfigNumChannelsEnabled.\n\n                     March 20, 2009\n                     - Added apexEcmEmmFirstPid, apexEcmEmmNumberPids,\n                       apexSimulcryptExternalEisSetting, apexSimulcryptEmEnable\n                     - Changed range of apexUdpMapNumberProgs.\n\n                     February 12, 2009\n                     - Added apexSimulcryptEmEnable.\n\n                     February 6, 2009\n                     - Added apexGbeSfp.\n\n                     January 8, 2009\n                     - Added apexOutputTsConfApplyTable  and\n                       apexOutputTsStatusInvalidApplyText.\n                     - Fixed header comment group numbers for apexOutputTsConfig.\n                     ', "Version 1.3:\n\n                     March 10, 2009\n                     - Added apexGbeNominalBufferLevel.\n                     - Made apexGbeJitterAbsorption obsolete.\n\n                     February 18, 2009\n                     - Added RF Redundancy and REM alarm codes to apexHwEventAlarmCode\n                       description.\n\n                     February 5, 2009\n                     - Added 'warning' severity to apexAlarmRemFault description.\n\n                     January 21, 2009\n                     - Changed apexQamRfConfigRfLevelAttenuation range and\n                       description.\n                     - Changed apexQamChanStatActive description to reflect\n                       QAM RF Redundancy.\n\n                     December 5, 2008\n                     - Added apexQamRfRedundStatusInvalidApplyText and\n                       apexQamRfRedundConfigRemDirectIpOctet1.\n                     - Changed apexQamRfRedundConfigRemIpAddr to\n                       apexQamRfRedundConfigRemCommonIpAddr.\n\n                     November 25, 2008\n                     - Added apexOutputTsStatusServicesInError.\n\n                     October 31, 2008\n                     - Added apexDpmVersion.\n\n                     October 27, 2008\n                     - Changed apexQamRfRedundConfigApplyChange Syntax to ApplyDataToDeviceTYPE.\n\n                     October 16, 2008\n                     - Added apexQamRfRedundancyConfig.\n                     - Added apexQamRfRedundancyStatus.\n                     - Added apexOampInputTsAssignedCount to apexOampStatusGeneral.\n                     - Added apexDataIpInputTsAssignedCount, apexDataIpAddrInUse,\n                       apexDataIpSubnetMaskInUse, and apexDataIpInUseReason to\n                       apexDataIpStatusGeneral.\n                     - Added apexAlarmQamRfRedundFailOver, apexAlarmQamRfRedundMismatch,\n                       apexAlarmRemCommFault, apexAlarmRemFault, apexEnableQamRfRedundFailOver,\n                       apexEnableQamRfRedundMismatch, apexEnableRemCommFault, apexEnableRemFault,\n                       trapQamRfRedundFailOver, trapQamRfRedundMismatch, trapRemCommFault,\n                       trapRemFault.\n                     ", "Version 1.2:\n\n                      July 24, 2008\n                      - Added apexEncryptionEmmGoodDeliveryTimeMs, apexEncryptionEmmMaxDeliveryTimeMs\n                        apexEncryptionEmmMinDeliveryTimeMs, and apexEncryptionMcDiagTable\n                        to apexEncryptionCwgStatus section.\n\n                      July 15, 2008\n                      - Added range to syntax of apexSntpUtcOffset.\n\n                      July 09, 2008\n                      - Added 'annexC-Asia-Pacific' enumeration to\n                        apexQamConfigTransmissionMode.\n                      - Added enumerations to apexQamRfPortStatError and changed\n                        the description.\n                      - Added apexEncryptionCwgStatus variables for debug of cwg manager\n                        processing in the field.\n\n                      June 26, 2008\n                      - Increased range of apexPsiStatusIndex from 768 to 784.\n\n                      June 25, 2008\n                      - Added apexQrmDownload group.\n                      - Added apexOutputProgramSourceId and apexOutputProgramProviderId.\n                      - Changed descriptions of apexManualRouteInputType,\n                        apexManualRouteSourceId, apexManualRouteProviderId,\n                        apexManRtePassThroughInputType, and apexPidMapInputType.\n                      - Added enumerations to apexRtspStatControllerDiscovery\n                        and apexRtspStatControllerConnection.\n\n                      June 23, 2008\n                      - Added to apexAcpStatusTable: apexAcpUnitAttribute.\n\n                      June 20, 2008\n                      - Added to apexAcpStatusTable: apexAcpEvenCsn and apexAcpOddCsn.\n\n                      June 6, 2008\n                      - Added apexFastEnetInsertRateTable, apexFastEnetStatusPacketsTable,\n                        and apexFastEnetInsertPacketsTable.\n\n                      June 3, 2008\n                      - Added udpMapping enumeration to apexInputTsStatRoutingType.\n                      - Added encryption status to apexOutputProgramTable:\n                        apexOutputProgramError, apexOutputProgramEncryptionMode,\n                        apexOutputProgramEncryptionStatus, apexOutputProgramEcmServiceId,\n                        apexOutputProgramCciLevel, apexOutputProgramApsLevel,\n                        apexOutputProgramCitSetting, apexOutputProgramNumberTiers, and\n                        apexOutputProgramTierData.\n\n                      June 2, 2008\n                      - Added apexManualRouteRmdClear.\n\n                      May 12, 2008\n                      - Added apexEncryption group and apexOutputTsConfEncryptionType.\n\n                      May 8, 2008\n                      - Added apexRds group.\n                      - Added apexAlarmRdsCommFault and trapRdsCommFault.\n\n                      April 4, 2008\n                      - Added apexUdpPortMapping group.\n                      - Added udpMapping enumeration to apexOutputTsConfOperatingMode.\n                     ", "Version 1.1:\n\n                      July 8, 2008\n                      - Added enumerations to apexQamRfPortStatError and changed\n                        the description.\n\n                      July 1, 2008\n                      Changes to support ITU-T J.83 Annex A and C QAM:\n                      - Added 'annexC-Asia-Pacific' enumeration to\n                        apexQamStatusTransmissionMode.\n                      - Changed descriptions of: apexQamRfConfigNumChannelsEnabled,\n                        apexQamRfConfigSymbolRate, apexQamRfConfigEiaFrequencyPlan,\n                        apexQamRfConfigEiaChanNumChannelA, apexQamRfConfigRfCenterFreqChannelA,\n                        apexQamRfConfigRfChanSpacing, apexQamRfConfigInterleaverDepth1,\n                        and apexQamRfConfigInterleaverDepth2.\n                     ", 'Version 1.0:\n\n                      February 18, 2008\n                      - Initial Revision.',))
if mibBuilder.loadTexts: apex.setLastUpdated('201410220000Z')
if mibBuilder.loadTexts: apex.setOrganization('ARRIS Enterprises, Inc.')
if mibBuilder.loadTexts: apex.setContactInfo('The Technical Assistance Center (TAC) provides assistance 24 hours a day, 7 days a week.\n                      To open a case, use one of these contact methods:\n                      \n                      Customers in North America should call the TAC at     : 1-888-944-HELP (1-888-944-4357)\n                      Customers outside North America should call the TAC at: 1-215-323-2345\n                      For Spanish language support, call the TAC at         : 1-215-323-2346\n                      Contact the TAC by e-mail at                          : Tac.Helpdesk@arrisi.com')
if mibBuilder.loadTexts: apex.setDescription('The MIB module for the APEX.')
class NetworkDuplexModeTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("halfDuplex", 1), ("fullDuplex", 2))

class NetworkSpeedTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("speed10Mbps", 1), ("speed100Mbps", 2))

class EnableDisableTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disabled", 1), ("enabled", 2))

class ActiveTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("notApplicable", 0), ("notActive", 1), ("active", 2))

class ApplyDataToDeviceTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("applyNotInProgress", 1), ("apply", 2), ("applyNotInProgressValidData", 3), ("applyNotInProgressInvalidData", 4))

class ResetStatisticsTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("resetNotInProgress", 1), ("reset", 2))

class ClearAlarmTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("clearAlarmNotInProgress", 1), ("clearAlarm", 2))

class RateComparisonTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("dataRate", 1), ("transportStreamRate", 2))

class InputTsStateTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("closed", 0), ("openedInUse", 1), ("openedBackup", 2), ("openedTransToBackup", 3), ("openedTransToInUse", 4))

class EthernetInterfaceTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enet1", 1), ("enet2", 2))

class InputInterfaceTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("enet1", 1), ("enet2", 2), ("gige1", 3), ("gige2", 4), ("gige3", 5), ("gige4", 6))

class ClearCountersTYPE(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("clearNotInProgress", 1), ("clear", 2))

apexSys = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1))
apexSysConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1))
apexSysConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 1))
apexSysConfigMcEmmInsertion = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2))
apexSysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2))
apexSysStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 1))
apexSysStatusVersions = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2))
apexTime = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2))
apexTimeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1))
apexTimeConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1))
apexTimeStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 2))
apexTimeStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 2, 1))
apexTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3))
apexTemperatureConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 1))
apexTemperatureConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 1, 1))
apexTemperatureStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2))
apexTemperatureStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 1))
apexMainBoardTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 2))
apexMainBoardTemperatureFault = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 3))
apexPowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4))
apexPsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 1))
apexPsConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 1, 1))
apexPsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2))
apexPsStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 1))
apexAsi = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5))
apexAsiConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5, 1))
apexAsiMonitorPortConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5, 1, 2))
apexFastEnet = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6))
apexFastEnetConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1))
apexFastEnetConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1))
apexFastEnetStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2))
apexFastEnetStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 1))
apexOamp = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3))
apexOampConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1))
apexOampConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1))
apexOampStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2))
apexOampStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1))
apexDataIp = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4))
apexDataIpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1))
apexDataIpConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1))
apexDataIpStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2))
apexDataIpStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1))
apexGbe = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7))
apexGbeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1))
apexGbeConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1))
apexGbeConfigInputRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4))
apexGbeConfigInputRedundancyGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1))
apexGbeConfigInterfaceRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7))
apexGbeConfigInterfaceRedundancyGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 1))
apexGbeStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2))
apexGbeStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 1))
apexGbeStatusFrameCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6))
apexGbeStatusFrameCounterGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 1))
apexGbeFrameBufferStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7))
apexGbeFrameBufferStatsGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 1))
apexGbeStatusInputTransportStream = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8))
apexGbeStatusInputTsGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 1))
apexGbeStatusInterfaceRedund = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9))
apexGbeStatusInputTsDropCounter = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 10))
apexGbeStatusInputTsDropCounterGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 10, 1))
apexGbeSfp = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3))
apexGbeSfpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 1))
apexGbeSfpConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 1, 1))
apexGbeSfpStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2))
apexGbeSfpStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 1))
apexQam = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8))
apexQamConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1))
apexQamConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 1))
apexQamModuleUpgrade = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 2))
apexQamRfRedundancyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6))
apexQamRfRedundancyConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1))
apexQamStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2))
apexQamStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 1))
apexQamRfRedundancyStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7))
apexQamRfRedundancyStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1))
apexQrmDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3))
apexQrmDownloadConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1))
apexQrmDownloadConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1, 1))
apexQrmDownloadStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2))
apexQrmDownloadStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 1))
apexSessionControl = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9))
apexSessionControlConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1))
apexSessionControlConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1))
apexSessionControlStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 2))
apexSessionControlStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 2, 1))
apexRpc = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3))
apexRpcConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1))
apexRpcConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1))
apexRpcStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2))
apexRpcStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 1))
apexRtsp = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4))
apexRtspConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1))
apexRtspConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 1))
apexRtspConfMhaGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 9))
apexRtspConfMhaSbe = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10))
apexRtspStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2))
apexRtspStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 1))
apexManualRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10))
apexManualRoutingConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1))
apexManualRoutingConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 1))
apexManualRouteGbeInputRedundConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6))
apexManRteGbeInRedConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 1))
apexManualRoutingStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2))
apexManualRoutingStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 1))
apexManualRouteGbeInputRedundStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2))
apexManRteGbeInRedStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2, 1))
apexManualRoutingServiceStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3))
apexManualRoutingServiceStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3, 1))
apexAncillaryPidMapping = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11))
apexPidMapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1))
apexPidMapConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 5))
apexPidMapInputAncillaryPidDetection = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 6))
apexPidMapStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2))
apexPidMapStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2, 1))
apexBulkPidMapStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2, 2))
apexInsertion = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12))
apexInsertionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 1))
apexInsertionConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 1, 1))
apexInsertionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2))
apexInsertionStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 1))
apexInputTransport = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13))
apexInputTsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 1))
apexInputTsConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 1, 1))
apexInputTsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2))
apexInputTsStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 1))
apexOutputTransport = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14))
apexOutputTsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1))
apexOutputTsConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 1))
apexOutputTsUtilizationMonitoring = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4))
apexOutputTsUtilizationMonitorGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 1))
apexOutputTsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2))
apexOutputTsStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 1))
apexOutputTsUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2))
apexOutputTsUtilizationGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 1))
apexPsi = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15))
apexPsiConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1))
apexPsiConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1))
apexPsiStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2))
apexPsiStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 1))
apexOutputProgram = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16))
apexOutputProgramConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 1))
apexOutputProgramConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 1, 1))
apexOutputProgramStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2))
apexOutputProgramStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 1))
apexAcp = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17))
apexAcpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 1))
apexAcpConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 1, 1))
apexAcpStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2))
apexAcpStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 1))
apexUdpPortMapping = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18))
apexUdpMapConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1))
apexUdpMapConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 1))
apexUdpMapStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2))
apexUdpMapStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 1))
apexRds = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19))
apexRdsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1))
apexRdsConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1))
apexRdsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2))
apexRdsStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1))
apexEncryption = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20))
apexEncryptionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1))
apexEncryptionConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1))
apexCteConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2))
apexEncryptionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2))
apexEncryptionStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1))
apexEncryptionCwgStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2))
apexEas = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21))
apexEasConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1))
apexEasConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1))
apexEasStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2))
apexEasStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 1))
apexChassisRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22))
apexChassisRedundancyConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1))
apexChassisRedundancyConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1))
apexChassisRedundancyStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2))
apexChassisRedundancyStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1))
apexDta = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23))
apexDtaConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1))
apexDtaGeneralConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1))
apexDepi = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24))
apexDepiConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 1))
apexDepiConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 1, 1))
apexDepiStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2))
apexDepiStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1))
apexDepiControl = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3))
apexDepiControlConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1))
apexDepiControlConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 1))
apexDepiControlStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2))
apexDepiControlStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1))
apexDepiSession = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4))
apexDepiSessionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1))
apexDepiSessionStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2))
apexDepiSessionStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 1))
apexPsip = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25))
apexPsipConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1))
apexPsipConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1))
apexPsipConfigTime = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2))
apexPsipStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2))
apexPsipStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 1))
apexPreencryption = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 26))
apexPreencryptionConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 26, 1))
apexPreencryptionConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 26, 1, 1))
apexOutputAncillaryPid = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27))
apexOutputAncillaryPidConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 1))
apexOutputAncillaryPidConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 1, 1))
apexOutputAncillaryPidStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2))
apexOutputAncillaryPidStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 1))
apexUls = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28))
apexUlsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1))
apexUlsConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 1))
apexUlsConfigMcSimFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 2))
apexUlsStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2))
apexUlsStatusGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 1))
apexUlsStatusMcSimFeatures = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 2))
apexSimulcryptEcmgInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29))
apexSimulcryptEcmgStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1))
apexMcSim = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30))
apexMcSimConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1))
apexMcSimConfigGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1, 1))
apexAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100))
apexEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101))
apexConfigAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102))
apexConfAlarmEnable = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1))
apexConfAlarmClear = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 2))
apexLogs = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200))
apexTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0))
apexDebug = MibIdentifier((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5000))
apexSaveConfig = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("saveNotInProgress", 1), ("startSaveToFlash", 2), ("savingConfigToFlash", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSaveConfig.setStatus('current')
if mibBuilder.loadTexts: apexSaveConfig.setDescription('Writing this object will commit the current\n         configuration to Flash.  While a read returns the\n         value savingConfigToFlash, the flash is being saved;\n         the save may not have been initiated by an SNMP set.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexProductName = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexProductName.setStatus('current')
if mibBuilder.loadTexts: apexProductName.setDescription("This is the Product Name of the APEX loaded at initialization from\n         the config.ini file.  Specific configurations of the APEX have\n         specific purposes and are identified by their product name.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2, default=yes)\n         @File(config.ini, type='ini')\n        ")
apexBootMethod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("noDhcpOrBootp", 1), ("bootpOnly", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBootMethod.setStatus('current')
if mibBuilder.loadTexts: apexBootMethod.setDescription("This parameter is used to set the boot method for the APEX.\n         Selection of noDhcpOrBootp means the APEX will not use DHCP or BOOTP\n         - this will result in about a 10 second savings in boot time.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexAutoRebootEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 1, 4), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexAutoRebootEnable.setStatus('current')
if mibBuilder.loadTexts: apexAutoRebootEnable.setDescription("Setting to 'enabled' allows the APEX to automatically reboot when\n         specific APEX hardware errors occur. Setting this to Enabled will\n         cause the APEX to automatically reboot upon specific HW faults, such\n         as a GigE processor crash, or upon a Host processor watchdog event.\n         When disabled, HW faults and watchdog events will not cause an automatic\n         reboot. This is useful when it is necessary to debug the event (to allow\n         time to gather status prior to manually rebooting).\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("outOfBand", 1), ("fullInBand", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionMode.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionMode.setDescription("Specify the mode in which MediaCipher EMMs are inserted, out of band \n         or full in band.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexMcEmmInsertionApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcEmmInsertionApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionPid1Enable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionPid1Enable.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionPid1Enable.setDescription("Enable/disable first EMM PID to include in the CAT for MediaCipher Full In Band mode.\n         Default value is enabled.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexMcEmmInsertionApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcEmmInsertionApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionPid1 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(7168, 8190))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionPid1.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionPid1.setDescription("First EMM PID to include in the CAT for MediaCipher Full In Band mode.\n         Allowed values: from 0x1C00 to 0x1FFE.\n         Default value is 0x1C02.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexMcEmmInsertionApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcEmmInsertionApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionPid2Enable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 4), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionPid2Enable.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionPid2Enable.setDescription("Enable/disable first EMM PID to include in the CAT for MediaCipher Full In Band mode.\n         Default value is disabled.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexMcEmmInsertionApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcEmmInsertionApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionPid2 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(7168, 8190))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionPid2.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionPid2.setDescription("Second EMM PID to include in the CAT for MediaCipher Full In Band mode.\n         Allowed values: from 0x1C00 to 0x1FFE.\n         Default value is 0x1C03.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexMcEmmInsertionApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcEmmInsertionApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexMcEmmInsertionApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 1, 2, 6), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcEmmInsertionApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexMcEmmInsertionApplyChange.setDescription("The Apply for the MediaCipher EMM Insertion group.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the MC EMM Insertion group to take effect in the device.  This\n         parameter MUST be set LAST after all other data in the MC Emm Insertion\n         group has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexBootReason = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("powerCycle", 0), ("operatorReboot", 1), ("hwFault", 2), ("wdFault", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexBootReason.setStatus('current')
if mibBuilder.loadTexts: apexBootReason.setDescription("Indicates reason for APEX boot:\n            'powerCycle'       - Power-up or power cycled.\n            'operatorReboot'   - Operator commanded reboot (refer to manual).\n            'hwFault'          - Automatic reboot occurred as per apexAutoRebootEnable.\n            'wdFault'          - Automatic Watchdog reboot as per apexAutoRebootEnable.\n        ")
apexMaxServiceMappings = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMaxServiceMappings.setStatus('current')
if mibBuilder.loadTexts: apexMaxServiceMappings.setDescription('Maximum number of service mappings supported by the APEX.\n        ')
apexHostProcessorBootCodeVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHostProcessorBootCodeVersion.setStatus('current')
if mibBuilder.loadTexts: apexHostProcessorBootCodeVersion.setDescription('APEX Host Processor Boot Code Version.')
apexMuxFpgaVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMuxFpgaVersion.setStatus('current')
if mibBuilder.loadTexts: apexMuxFpgaVersion.setDescription('APEX MUX FPGA Version.')
apexMuxFpgaEncryption = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("noEncryption", 0), ("des", 1), ("csa", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMuxFpgaEncryption.setStatus('current')
if mibBuilder.loadTexts: apexMuxFpgaEncryption.setDescription('APEX MUX FPGA Encryption type currently loaded.')
apexMainBoardVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardVersion.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardVersion.setDescription('APEX Main Board Version.  This is the revision of the\n         apexMainBoardType.')
apexHostApplicationDate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHostApplicationDate.setStatus('current')
if mibBuilder.loadTexts: apexHostApplicationDate.setDescription('APEX Host Processor Application Creation Date.')
apexProductType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("invalid", 0), ("apex1000", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexProductType.setStatus('current')
if mibBuilder.loadTexts: apexProductType.setDescription('APEX Product Type.  The corresponding product name\n         text setting can be found in identUnitModel.')
apexMainBoardType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardType.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardType.setDescription('APEX Main Board Type.  The revision is found in apexMainBoardVersion.')
apexGlueFpgaVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGlueFpgaVersion.setStatus('current')
if mibBuilder.loadTexts: apexGlueFpgaVersion.setDescription('APEX Glue FPGA Version.')
apexGlueCpldVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGlueCpldVersion.setStatus('current')
if mibBuilder.loadTexts: apexGlueCpldVersion.setDescription('APEX Glue CPLD Version.')
apexDtiFpgaVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDtiFpgaVersion.setStatus('current')
if mibBuilder.loadTexts: apexDtiFpgaVersion.setDescription('APEX DTI FPGA Version.')
apexMpc2FpgaVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMpc2FpgaVersion.setStatus('current')
if mibBuilder.loadTexts: apexMpc2FpgaVersion.setDescription('APEX MPC2 FPGA Version.')
apexDpmVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 1, 2, 2, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDpmVersion.setStatus('current')
if mibBuilder.loadTexts: apexDpmVersion.setDescription('APEX DPM Version.')
apexTimeSource = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sntp", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexTimeSource.setStatus('current')
if mibBuilder.loadTexts: apexTimeSource.setDescription("The source for system time.\n         The time source can be configured to come from\n         an SNTP time source, or be generated internally.\n\n         When configured as internal:\n            - The APEX will internally keep time starting at GPS time 0.\n              A user can set the time to a valid GPS time in this mode.\n            - The system time and UTC offset in internal mode are\n              not updated and therefore are not valid.\n\n         When configured to receive time via SNTP the\n         SntpServerSpecified object and SntpServiceIP objects\n         can be used to optionally define the SNTP server.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexSntpUtcOffset = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSntpUtcOffset.setStatus('current')
if mibBuilder.loadTexts: apexSntpUtcOffset.setDescription("The value of this object is the Universal Time\n         Coordinated (UTC) offset from GPS time.  Subtract\n         this from GPS time to convert from GPS to UTC.\n         Units are seconds.\n\n         When time source is SNTP, this object can be set\n         to specify the UTC offset that the APEX will use\n         in calculating GPS time.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexSntpServerSpecified = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSpecified", 1), ("specified", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSntpServerSpecified.setStatus('current')
if mibBuilder.loadTexts: apexSntpServerSpecified.setDescription("When the TimeSource is SNTP, this object specifies whether\n         the APEX will only accept time for a single SNTP server or\n         from any server that broadcasts time.\n         When notSpecified, the APEX will accept time from any SNTP\n         server.\n\n         When specified, the APEX will poll for time from the address\n         of the SNTP server specified by the SntpServerIP address object.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexSntpServerIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSntpServerIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexSntpServerIpAddr.setDescription("This contains the IP address of the specified SNTP server.\n         If apexTimeSource is SNTP and apexSntpServerSpecified\n         is set to specified, then the apex will poll for time from\n         this IP address.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexUserSuppliedTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 1, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUserSuppliedTime.setStatus('current')
if mibBuilder.loadTexts: apexUserSuppliedTime.setDescription('The value of this object is the GPS Time the APEX is given\n         via user entry.  The time is reported in GPS seconds.\n         This time is ONLY used when the APEX is set to Internal time mode.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexSystemTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexSystemTime.setStatus('current')
if mibBuilder.loadTexts: apexSystemTime.setDescription('The value of this object is the current System Time of the APEX.\n         The system time is reported in GPS seconds.  To determine the\n         APEXs system time in UTC the apexSntpUtcOffset object must also\n         be read and used in the calculation.')
apexOperationalTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOperationalTime.setStatus('current')
if mibBuilder.loadTexts: apexOperationalTime.setDescription('The Operational Time is the time in seconds since the APEX completed\n         the boot sequence.  It is the time that the APEX has been operational.')
apexMainBoardTempFrontIntake = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempFrontIntake.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempFrontIntake.setDescription('Ambient temperature at the intake vent at the front of the unit.\n         Measured in whole number degrees Celsius.')
apexMainBoardTempMuxFpga = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempMuxFpga.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempMuxFpga.setDescription('Ambient temperature at the MUX FPGAs.\n         Measured in whole number degrees Celsius.')
apexMainBoardTempAcpModule = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempAcpModule.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempAcpModule.setDescription('Ambient temperature at the ACP Module location.  This reading\n         is valid for all models whether an ACP Module is standard on\n         the model.\n         Measured in whole number degrees Celsius.')
apexMainBoardTempHostProcessor = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempHostProcessor.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempHostProcessor.setDescription('Ambient temperature at the Host Processor.\n         Measured in whole number degrees Celsius.')
apexMainBoardTempFrontIntakeFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempFrontIntakeFault.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempFrontIntakeFault.setDescription('Fault status of ambient temperature at the intake vent at\n         the front of the unit.')
apexMainBoardTempMuxFpgaFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempMuxFpgaFault.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempMuxFpgaFault.setDescription('Fault status of ambient temperature at the MUX FPGAs.')
apexMainBoardTempAcpModuleFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempAcpModuleFault.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempAcpModuleFault.setDescription('Fault status of ambient temperature at the ACP Module location.')
apexMainBoardTempHostProcessorFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 3, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMainBoardTempHostProcessorFault.setStatus('current')
if mibBuilder.loadTexts: apexMainBoardTempHostProcessorFault.setDescription('Fault status of ambient temperature at the Host Processor.')
apexPsPowerFaultFilter = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsPowerFaultFilter.setStatus('current')
if mibBuilder.loadTexts: apexPsPowerFaultFilter.setDescription("This setting enables or disables apexPsPowerFaultFilter.\n             When set to 'enabled', the device ignore the power fault alarm\n             for two consecutive positive samples of an AC power interruption.\n\n             When set to 'disabled' the alarm(apexAlarmPowerFault) will operate as described.\n             \n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexPsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2), )
if mibBuilder.loadTexts: apexPsStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusTable.setDescription('This is a table of status parameters for the two Power Supplies.')
apexPsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexPsStatusPsNum"))
if mibBuilder.loadTexts: apexPsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusEntry.setDescription('Power Supply Status Table Entry.')
apexPsStatusPsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexPsStatusPsNum.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusPsNum.setDescription('PS Number.')
apexPsStatusInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedAcInput", 2), ("installedDcInput", 3), ("fanModuleInstalled", 4), ("unsupported", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusInstalled.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusInstalled.setDescription('This parameter indicates installed status of the PS.')
apexPsStatusOutputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusOutputVoltage.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusOutputVoltage.setDescription('PS measured output voltage in milli-Volts.')
apexPsStatusOutputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusOutputCurrent.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusOutputCurrent.setDescription('PS measured output current in milli-Amps.')
apexPsStatusFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusFanSpeed.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusFanSpeed.setDescription('The fan speed in RPM an installed Power Supply or Fan Module.\n\n         Zero if not installed.')
apexPsStatusFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusFanStatus.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusFanStatus.setDescription('PS Fan Status.')
apexPsStatusTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusTemperatureStatus.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusTemperatureStatus.setDescription("Indicates whether the power supply is in protection mode due to\n         an over temperature condition.  The PS is shut down while in\n         'overTemp' and will recover when the temperature returns to normal\n         operating range.  A power cycle is not required for recovery.\n         Note that Output Power Status will be 'error' when Temperature\n         status is 'overTemp'.")
apexPsStatusInputPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusInputPowerStatus.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusInputPowerStatus.setDescription("Indicates whether AC Input is within specification.  Note that Output\n         Power Status will be 'error' when Input Power status is 'error'")
apexPsStatusOutputPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusOutputPowerStatus.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusOutputPowerStatus.setDescription('Indicates whether the +12V and +3.3V output power are within\n         specification.  If the output power error occurs with an Input\n         Power error, apply input power to recover.  If the output power\n         error occurs with an Over Temperature error, a power cycle is not\n         required for recovery.  Otherwise, a power cycle is required for\n         recovery.  If the problem persists after the power cycle, the PS\n         must be replaced for recovery.')
apexPsStatusErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("ok", 1), ("psNotInstalled", 2), ("psUnsupported", 3), ("inputPower", 4), ("fanFault", 5), ("overTemp", 6), ("outputPower", 7), ("commLost", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusErrorStatus.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusErrorStatus.setDescription('Summary of errors reported on a power supply basis.\n         The reported error will be the most severe.')
apexPsStatusFaultCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusFaultCondition.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusFaultCondition.setDescription('Current fault condition of the power supply errors.')
apexPsStatusDiagnosticData1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusDiagnosticData1.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusDiagnosticData1.setDescription('Diagnostic data word 1 (HP) - Contents for Arris\n         diagnostic purposes.')
apexPsStatusDiagnosticData2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusDiagnosticData2.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusDiagnosticData2.setDescription('Diagnostic data word 2 (PS) - Contents for Arris\n         diagnostic purposes.')
apexPsStatusCommError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusCommError.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusCommError.setDescription('Communication with the Power Supply has failed and status cannot be\n         determined.  Only applies when valid PS installed.')
apexPsStatusVersionsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 3), )
if mibBuilder.loadTexts: apexPsStatusVersionsTable.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusVersionsTable.setDescription('This is a table of version status parameters for the two Power Supplies.')
apexPsStatusVersionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexPsStatusVersionsPsNum"))
if mibBuilder.loadTexts: apexPsStatusVersionsEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusVersionsEntry.setDescription('Power Supply Version Status Table Entry.')
apexPsStatusVersionsPsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexPsStatusVersionsPsNum.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusVersionsPsNum.setDescription('PS Number.')
apexPsStatusVersionsModel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusVersionsModel.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusVersionsModel.setDescription('PS Model.')
apexPsStatusVersionsSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 4, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsStatusVersionsSerialNumber.setStatus('current')
if mibBuilder.loadTexts: apexPsStatusVersionsSerialNumber.setDescription('PS serial number.')
apexAsiMonitorPortOutputTsNum = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexAsiMonitorPortOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexAsiMonitorPortOutputTsNum.setDescription("The number of the output transport stream to route to the\n         ASI Monitor Port.  Zero indicates that no stream is to be\n         routed to the ASI Monitor port.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexAsiMonitorPortEncryption = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 5, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("preEncryption", 1), ("postEncryption", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexAsiMonitorPortEncryption.setStatus('current')
if mibBuilder.loadTexts: apexAsiMonitorPortEncryption.setDescription("Selects pre or post encryption for the ASI monitor port.\n         This parameter is only applicable to APEXs with encryption\n         capability.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexFastEnetDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetDefaultGateway.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetDefaultGateway.setDescription("This is the IP address of the default gateway for the Fast Ethernet\n         interfaces.\n\n         This should be zero or a valid Class A, B, or C IP address.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexFastEnetRoutingApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 3), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetRoutingApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingApplyChange.setDescription("The Apply for the Fast Ethernet Static Routing Table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the apexFastEnetRoutingTable to take effect.  This parameter\n         MUST be set LAST after all other data in the apexFastEnetRoutingTable \n         has been configured.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexFastEnetRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2), )
if mibBuilder.loadTexts: apexFastEnetRoutingTable.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingTable.setDescription("This table is the configuration Static Routing table for the\n         Fast Ethernet Interface.\n\n         @Commit(param=apexFastEnetRoutingApplyChange, value=2)\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexFastEnetRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexFastEnetRoutingIndex"))
if mibBuilder.loadTexts: apexFastEnetRoutingEntry.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingEntry.setDescription('Fast Ethernet Interface Configuration Static Routing Table Entry.')
apexFastEnetRoutingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: apexFastEnetRoutingIndex.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingIndex.setDescription('The index of the Routing table entry.\n         Currently limited to 16.')
apexFastEnetRoutingDestinIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetRoutingDestinIp.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingDestinIp.setDescription("The Fast Ethernet Routing Destination IP address.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexFastEnetRoutingApplyChange is set to 'apply'.  \n         In order for the change to persist through subsequent reboots or power cycles, \n         the change must be saved via the apexSaveConfig parameter.\n        ")
apexFastEnetRoutingGatewayIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetRoutingGatewayIp.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingGatewayIp.setDescription("The Fast Ethernet Routing Gateway IP address.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexFastEnetRoutingApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power cycles, \n         the change must be saved via the apexSaveConfig parameter.\n        ")
apexFastEnetRoutingSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetRoutingSubnetMask.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetRoutingSubnetMask.setDescription("The Fast Ethernet Routing Subnet Mask.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexFastEnetRoutingApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power cycles, \n         the change must be saved via the apexSaveConfig parameter.\n        ")
apexFastEnetInsertRateTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 2), )
if mibBuilder.loadTexts: apexFastEnetInsertRateTable.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertRateTable.setDescription('This is a table of configuration parameters for Output Transport\n         Rate of Fast Ethernet MPEG data Insertion.')
apexFastEnetInsertRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexFastEnetInsertRateOutputTsNum"))
if mibBuilder.loadTexts: apexFastEnetInsertRateEntry.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertRateEntry.setDescription('Output Transport Rate of Fast Ethernet MPEG Insertion Configuration Table Entry.')
apexFastEnetInsertRateOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexFastEnetInsertRateOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertRateOutputTsNum.setDescription('Output Transport Stream Number.')
apexFastEnetInsertRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexFastEnetInsertRate.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertRate.setDescription("Insertion Rate for the transport stream for Fast Ethernet MPEG\n         data. Maximum MPEG data rate to insert data received via Fast\n         Ethernet interfaces.\n         Range is 0 Kbps to 2500 Kbps for each transport stream.\n         Total for all transport streams must not exceed 10000 Kbps.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Range(min=0, max=2500)\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexFastEnetMaxInputUdpPorts = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetMaxInputUdpPorts.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetMaxInputUdpPorts.setDescription('Maximum number of Fast Ethernet input UDP ports that can be opened on\n         this APEX.')
apexFastEnetStatusPacketsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2), )
if mibBuilder.loadTexts: apexFastEnetStatusPacketsTable.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetStatusPacketsTable.setDescription('Table of Fast Ethernet Insert Packet Statistics for each\n         Fast Ethernet interface.\n         Indexed by FE interface port number.')
apexFastEnetStatusPacketsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexFastEnetPacketsPortNum"))
if mibBuilder.loadTexts: apexFastEnetStatusPacketsEntry.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetStatusPacketsEntry.setDescription('A row in the FE Insert Packets table.')
apexFastEnetPacketsPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexFastEnetPacketsPortNum.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetPacketsPortNum.setDescription('Fast Ethernet interface port Number.')
apexFastEnetPacketsNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetPacketsNumPkts.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetPacketsNumPkts.setDescription('Number of MPEG packets inserted during the last monitoring\n         period (currently 5 seconds) on this FE interface port.')
apexFastEnetPacketsTotPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetPacketsTotPkts.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetPacketsTotPkts.setDescription('Total number of MPEG packets inserted on this FE interface port.')
apexFastEnetPacketsNumDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetPacketsNumDiscarded.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetPacketsNumDiscarded.setDescription('Number of MPEG packets discarded during the last monitoring\n         period (currently 5 seconds) on this FE interface port.\n         This may be due to a buffer overflow or incorrect\n         configuration of the FE output stream insertion rate.')
apexFastEnetPacketsTotDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetPacketsTotDiscarded.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetPacketsTotDiscarded.setDescription('Total number of FE MPEG packets discarded on this Output\n         Transport Stream. Discarded packets on an FE interface port\n         are those packets discarded due to an overflow condition.')
apexFastEnetInsertPacketsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3), )
if mibBuilder.loadTexts: apexFastEnetInsertPacketsTable.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertPacketsTable.setDescription('Table of Output Transport Stream FE Insert Packet Statistics.\n         Indexed by Output Transport Stream number.')
apexFastEnetInsertPacketsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexFastEnetInsPacketsOutputTsNum"))
if mibBuilder.loadTexts: apexFastEnetInsertPacketsEntry.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsertPacketsEntry.setDescription('A row in the Output Transport Stream FE Insert Packets table.')
apexFastEnetInsPacketsOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexFastEnetInsPacketsOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsPacketsOutputTsNum.setDescription('Output Transport Stream Number.')
apexFastEnetInsPacketsNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetInsPacketsNumPkts.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsPacketsNumPkts.setDescription('Number of MPEG packets inserted during the last monitoring\n         period (currently 5 seconds) on this Output Transport\n         Stream.')
apexFastEnetInsPacketsTotPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetInsPacketsTotPkts.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsPacketsTotPkts.setDescription('Total number of MPEG packets inserted on this Output\n         Transport Stream.')
apexFastEnetInsPacketsNumDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetInsPacketsNumDiscarded.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsPacketsNumDiscarded.setDescription('Number of MPEG packets discarded during the last monitoring\n         period (currently 5 seconds) on this Output Transport\n         Stream.  This may be due to a buffer overflow or incorrect\n         configuration of the FE output stream insertion rate.')
apexFastEnetInsPacketsTotDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 2, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFastEnetInsPacketsTotDiscarded.setStatus('current')
if mibBuilder.loadTexts: apexFastEnetInsPacketsTotDiscarded.setDescription('Total number of FE MPEG packets discarded on this Output\n         Transport Stream. Discarded packets on an output stream\n         are those packets discarded due to an overflow condition.')
apexOampIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOampIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexOampIpAddr.setDescription("This is the IP address of the OAMP IP (Enet1) interface of the APEX.\n         This IP address is set via a BootP when connected\n         to a Bootp server.  When not connected to a BootP server, the IP\n         address may directly be changed by setting this parameter.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOampSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOampSubnetMask.setStatus('current')
if mibBuilder.loadTexts: apexOampSubnetMask.setDescription("This is subnet mask of the OAMP IP (Enet1) interface of the APEX.\n         The subnet mask is normally via a BootP when connected\n         to a BootP server.  When not connected to a Bootp Server, the\n         Subnet Mask may directly be changed by setting this parameter.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOampAutoNegotiate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1, 3), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOampAutoNegotiate.setStatus('current')
if mibBuilder.loadTexts: apexOampAutoNegotiate.setDescription("OAMP IP (Enet1) Ethernet Auto-Negotiation setting.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOampNetworkDuplexMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1, 4), NetworkDuplexModeTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOampNetworkDuplexMode.setStatus('current')
if mibBuilder.loadTexts: apexOampNetworkDuplexMode.setDescription("OAMP (Enet1) Ethernet Network Duplex Mode. Enet1 is set to the\n         configured mode, only if 'apexOampAutoNegotiate' is disabled.\n         \n         Default value is full duplex mode.\n        \n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n         \n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOampNetworkSpeed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 1, 1, 5), NetworkSpeedTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOampNetworkSpeed.setStatus('current')
if mibBuilder.loadTexts: apexOampNetworkSpeed.setDescription("OAMP (Enet1) Ethernet Network Speed. Enet1 is set to the\n         configured speed, only if 'apexOampAutoNegotiate' is disabled.\n         \n         Default value is 100 Mbps.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.        \n         \n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOampMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampMacAddr.setStatus('current')
if mibBuilder.loadTexts: apexOampMacAddr.setDescription("This is the MAC address of the APEX OAMP IP (Enet1) Interface.\n         It is set at the factory and cannot be changed.\n         The string length is 17 characters in the format\n         'hh:hh:hh:hh:hh:hh' where 'hh' is a hexadecimal number.")
apexOampSpeed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("interfaceSpeed10Mbps", 1), ("interfaceSpeed100Mbps", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampSpeed.setStatus('current')
if mibBuilder.loadTexts: apexOampSpeed.setDescription('OAMP IP (Enet1) Ethernet speed (10Mbps or 100Mbps). This is determined by the results of the\n         auto-negotiation process. If auto-negotiation fails, the default speed is 100Mbps.')
apexOampDuplexMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampDuplexMode.setStatus('current')
if mibBuilder.loadTexts: apexOampDuplexMode.setDescription('OAMP IP (Enet1) Ethernet Duplex Mode (full or half) This is determined by the results of the\n         auto-negotiation process. If auto-negotiation fails, the default mode is Full.')
apexOampInputTsAssignedCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampInputTsAssignedCount.setStatus('current')
if mibBuilder.loadTexts: apexOampInputTsAssignedCount.setDescription('Number of input transport streams assigned to the OAMP IP interface (Enet1).')
apexOampLinkActive = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 5), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampLinkActive.setStatus('current')
if mibBuilder.loadTexts: apexOampLinkActive.setDescription('This indicates if the OAMP (ENET1) link is active.')
apexOampCurrentAutoNegotiateState = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 3, 2, 1, 6), EnableDisableTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOampCurrentAutoNegotiateState.setStatus('current')
if mibBuilder.loadTexts: apexOampCurrentAutoNegotiateState.setDescription('Current auto-negotiation status on OAMP network\n        ')
apexDataIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDataIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexDataIpAddr.setDescription("This is the IP address of the Data IP (Enet2) interface of this APEX.\n         The data IP address may directly be changed by setting this parameter.\n         The Data IP address must be configured such that the Data IP interface\n         and the OAMP interface are on different networks.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDataIpSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDataIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: apexDataIpSubnetMask.setDescription("This is subnet mask of the Data IP (Enet2) interface of this APEX.\n         The data IP Subnet Mask may directly be changed by setting this parameter.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDataIpAutoNegotiate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1, 3), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDataIpAutoNegotiate.setStatus('current')
if mibBuilder.loadTexts: apexDataIpAutoNegotiate.setDescription("Data IP (Enet2) Ethernet Auto-Negotiation setting.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDataIpNetworkDuplexMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1, 4), NetworkDuplexModeTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDataIpNetworkDuplexMode.setStatus('current')
if mibBuilder.loadTexts: apexDataIpNetworkDuplexMode.setDescription("DATA IP (Enet2) Ethernet Network Duplex Mode. Enet2 is set to the \n         configured mode, only if 'apexDataIpAutoNegotiate'is disabled.\n         \n         Default value is full duplex mode.       \n         \n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n         \n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDataIpNetworkSpeed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 1, 1, 5), NetworkSpeedTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDataIpNetworkSpeed.setStatus('current')
if mibBuilder.loadTexts: apexDataIpNetworkSpeed.setDescription("DATA IP (Enet2) Ethernet Network Speed. Enet2 is set to the\n         configured speed, only if 'apexDataIpAutoNegotiate'is disabled.\n\n         Default value is 100 Mbps.  \n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n         \n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDataIpMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpMacAddr.setStatus('current')
if mibBuilder.loadTexts: apexDataIpMacAddr.setDescription("This is the MAC address of the APEX Data IP (Enet2) Interface.\n         It is set at the factory and cannot be changed.\n         The string length is 17 characters in the format\n         'hh:hh:hh:hh:hh:hh' where 'hh' is a hexadecimal number.")
apexDataIpSpeed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("interfaceSpeed10Mbps", 1), ("interfaceSpeed100Mbps", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpSpeed.setStatus('current')
if mibBuilder.loadTexts: apexDataIpSpeed.setDescription('Data IP (Enet2) Ethernet speed (10Mbps or 100Mbps). This is determined\n         by the results of the auto-negotiation process. If auto-negotiation\n         fails, the default speed is 100Mbps. This status item is only valid\n         when the Data IP port is enabled and properly configured.')
apexDataIpDuplexMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpDuplexMode.setStatus('current')
if mibBuilder.loadTexts: apexDataIpDuplexMode.setDescription('Data IP (Enet2) Ethernet Duplex Mode (full or half) This is determined\n         by the results of the auto-negotiation process. If auto-negotiation\n         fails, the default mode is Full. This status item is only valid when\n         the Data IP port is enabled and properly configured.')
apexDataIpInputTsAssignedCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpInputTsAssignedCount.setStatus('current')
if mibBuilder.loadTexts: apexDataIpInputTsAssignedCount.setDescription('Number of input transport streams assigned to the Data IP interface.')
apexDataIpAddrInUse = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpAddrInUse.setStatus('current')
if mibBuilder.loadTexts: apexDataIpAddrInUse.setDescription('Indicates the IP Address currently being used by the Data IP port (Enet2).\n         This parameter will be either apexDataIpAddr or an APEX selected IP address.\n         Refer to apexDataIpInUseReason for more information.')
apexDataIpSubnetMaskInUse = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpSubnetMaskInUse.setStatus('current')
if mibBuilder.loadTexts: apexDataIpSubnetMaskInUse.setDescription('Indicates the Subnet Mask currently being used by the Data IP port (Enet2).\n         This parameter will be either apexDataIpSubnetMask or an APEX selected mask.\n         Refer to apexDataIpInUseReason for more information.')
apexDataIpInUseReason = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("userConfig", 1), ("directRemConnection", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpInUseReason.setStatus('current')
if mibBuilder.loadTexts: apexDataIpInUseReason.setDescription("Reason for apexDataIpAddrInUse and apexDataIpSubnetMaskInUse Data IP\n         (Enet2) parameters.\n\n         'notApplicable'       - Enet2 not configured by user or for REM\n                                 connection.\n         'userConfig'          - APEX is not overriding user configured\n                                 parameters.\n         'directRemConnection' - The DATA IP port (Enet2) is in use for QAM RF\n                                 Redundancy so the APEX has overridden the user\n                                 configured parameters.\n        ")
apexDataIpLinkActive = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 8), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpLinkActive.setStatus('current')
if mibBuilder.loadTexts: apexDataIpLinkActive.setDescription('This indicates if the DataIP (ENET2) link is active.')
apexDataIpCurrentAutoNegotiateState = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 6, 4, 2, 1, 9), EnableDisableTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDataIpCurrentAutoNegotiateState.setStatus('current')
if mibBuilder.loadTexts: apexDataIpCurrentAutoNegotiateState.setDescription('Current auto-negotiation status on DATA IP network\n        ')
apexGbeDefaultGateway1 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeDefaultGateway1.setStatus('current')
if mibBuilder.loadTexts: apexGbeDefaultGateway1.setDescription("This is the IP address of the default gateway for Gigabit Ethernet\n         interfaces 1 and 2.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeDefaultGateway2 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeDefaultGateway2.setStatus('current')
if mibBuilder.loadTexts: apexGbeDefaultGateway2.setDescription("This is the IP address of the default gateway for Gigabit Ethernet\n         interfaces 3 and 4.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeJitterAbsorption = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeJitterAbsorption.setStatus('obsolete')
if mibBuilder.loadTexts: apexGbeJitterAbsorption.setDescription("This object is obsolete.\n\n         Jitter Absorption setting in range of 0 to 200 milliseconds\n         in increments of 5 ms.  A change to this parameter will cause the\n         Gigabit Ethernet processor to reset all of its internal Ethernet\n         frame buffers. This will result in a momentary loss of data causing\n         a minor glitch on all output streams.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Range(step=5)\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeGarpPeriodicity = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(20, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeGarpPeriodicity.setStatus('current')
if mibBuilder.loadTexts: apexGbeGarpPeriodicity.setDescription("Gratuitous ARP period in range of 20 to 300 seconds.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfigTableApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 5), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigTableApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigTableApplyChange.setDescription("The Apply for the Gigabit Ethernet Configuration Table. This parameter\n         MUST be set to 'apply' in order for any of the data in the\n         apexGbeConfigTable to take effect.  This parameter\n         MUST be set LAST after all other data in the apexGbeConfigTable\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexGbeNominalBufferLevel = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 475))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeNominalBufferLevel.setStatus('current')
if mibBuilder.loadTexts: apexGbeNominalBufferLevel.setDescription("Gigabit Ethernet Nominal Buffer Level. Range of 50 to 475 milliseconds\n         in increments of 5 ms.  A change to this parameter will cause the\n         Gigabit Ethernet processor to reset all of its internal Ethernet\n         frame buffers. This will result in a momentary loss of data causing\n         a minor glitch on all output streams.\n\n         The buffer level is the normal standard starting level for an input\n         stream buffer. It is highly recommended that this level not be changed\n         from its default setting. The buffer level needs to be set at an\n         appropriate amount to allow for network jitter, clock skew between the\n         APEX and input source, and for maximum time between PCRs (100ms). In\n         addition, the level must not be set too high as the buffer needs to be\n         able to grow as packets are received and PCR processing is applied. This\n         buffer level is the initial level the APEX will attempt to maintain at\n         all times.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeInputDataTsSmoothingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 650))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeInputDataTsSmoothingPeriod.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputDataTsSmoothingPeriod.setDescription("Input Data stream smoothing period. Amount of time in milliseconds\n         over which the GigE will smooth out input streams that do not contain\n         PCRs. This allows the GigE to play out the input streams with\n         the packets equally spaced out over this period. This helps to reduce\n         network jitter and bursts of data to the output.\n         The smoothing period is used in conjunction with the data stream\n         buffer depth to perform this smoothing algorithm. The smoothing\n         period must be equal to or less than the data stream buffer depth.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexGbeInputDataTsBufferDepth = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(250, 650))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeInputDataTsBufferDepth.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputDataTsBufferDepth.setDescription("GBE Input Data stream buffer depth. Amount of time in milliseconds\n         that the GigE will buffer input streams that do not contain\n         PCRs. This allows the GigE to buffer these streams to remove network\n         jitter and then play them out with the packets equally spaced out.\n         The buffer depth must be equal to or greater than the data stream\n         smoothing period.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexGbeConfigInputDataTsApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyText.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyText.setDescription("When apexGbeConfigInputDataTsApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexGbeConfInputUnicastTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 6000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInputUnicastTimeout.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInputUnicastTimeout.setDescription("Loss of input stream timeout value (in milliseconds) for unicast inputs.\n         This determines the amount of time a unicast input stream is missing\n         before the APEX will declare the input stream lost.\n         \n         Loss of input is used for determining all SDV failover conditions. \n         It is also used for Manual Routing failover conditions when using \n         hot/warm transport stream redundancy.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Range(step=200)\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfInputMulticastTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 6000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInputMulticastTimeout.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInputMulticastTimeout.setDescription("Loss of input stream timeout value (in milliseconds) for multicast inputs.\n         This determines the amount of time a unicast input stream is missing before\n         the APEX will declare the input stream lost.\n\n         Loss of input is used for determining all SDV failover conditions. \n         It is also used for Manual Routing failover conditions when using \n         hot/warm transport stream redundancy.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Range(step=200)\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfLossOfInputTsType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 1, 12), RateComparisonTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfLossOfInputTsType.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfLossOfInputTsType.setDescription("Loss of input stream type. Determines if detection of loss of an input\n         stream is based on data rate or stream rate. Data rate includes only\n         non-null MPEG packets (such as video and audio packets). Stream rate\n         includes all packets, including null packets. The loss of an input stream\n         uses the timeout value for the specific input (unicast or multicast) and\n         the input type. If no packets are received within the specified timeout\n         value, taking into account the loss of input type checking, then the input\n         stream is determined to be missing.\n\n         Data rate should be used for detecting loss of input when the input stream\n         is normally null filled. When a user requires notification of a loss of\n         input stream when there is no content streamed, data rate should be selected.\n\n         Stream rate should be used for detecting loss of input stream when the user\n         requires to be notified when there is no input stream at all being received.\n\n         Loss of input is used for determining all SDV failover conditions. \n         It is also used for Manual Routing failover conditions when using \n         hot/warm transport stream redundancy.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2), )
if mibBuilder.loadTexts: apexGbeConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigTable.setDescription("This is a table of configuration parameters for the\n         Gigabit Ethernet Interfaces.\n\n         Once written, the change to this table will only take immediate\n         effect after apexGbeConfigTableApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexGbeConfigTableApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfigInterfaceNum"))
if mibBuilder.loadTexts: apexGbeConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigEntry.setDescription('Gigabit Ethernet Interface Configuration Table Entry.')
apexGbeConfigInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeConfigInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInterfaceNum.setDescription('Gigabit Ethernet Interface Number.')
apexGbeConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigEnable.setDescription('This parameter enables the Gigabit Ethernet Interface.\n        ')
apexGbeConfigIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigIpAddr.setDescription('This is the IP address of this Gigabit Ethernet interface.\n\n         It is recommended that each Gigabit Ethernet interface be\n         on a different subnet.  Each must be given a unique IP address.\n\n         0.0.0.0 indicates the interface is not in use.\n        ')
apexGbeConfigIpSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigIpSubnetMask.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigIpSubnetMask.setDescription('This is subnet mask of this Gigabit Ethernet interface.\n        ')
apexGbeConfigAutoNegotiate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 2, 1, 5), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigAutoNegotiate.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigAutoNegotiate.setDescription('Auto negotiation enabled or disabled.\n        ')
apexGbeConfigFrameBufferTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 3), )
if mibBuilder.loadTexts: apexGbeConfigFrameBufferTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigFrameBufferTable.setDescription("This is a table of configuration parameters related to\n         Gigabit Ethernet Frame Buffer statistics gathering.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexGbeConfigFrameBufferEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfigFrameBufferProcessorNum"))
if mibBuilder.loadTexts: apexGbeConfigFrameBufferEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigFrameBufferEntry.setDescription('Gigabit Ethernet Frame Buffer Configuration Table Entry.')
apexGbeConfigFrameBufferProcessorNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeConfigFrameBufferProcessorNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigFrameBufferProcessorNum.setDescription('Gigabit Ethernet Processor Number.\n             Proc 1 = GBE Interfaces 1 and 2\n             Proc 2 = GBE Interfaces 3 and 4\n        ')
apexGbeConfigFrameBufferMaxInDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000000, 2000000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigFrameBufferMaxInDataRate.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigFrameBufferMaxInDataRate.setDescription('Maximum Gigabit Ethernet MPEG input data rate in bps.  This is the total amount\n         of MPEG data expected to be received by Gigabit Ethernet frame interfaces on the\n         processor.\n\n         This data rate is used to determine the frame buffer reset limit.  The expected\n         data rate should always be set equal to or greater than the actual input data rate.\n         The value of apexGbeJitterAbsorption can limit the valid range of this data rate.\n         It is highly recommended that the user consult with Arris prior to changing\n         the expected data rate.\n        ')
apexGbeConfigFrameBufferAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigFrameBufferAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigFrameBufferAlarmThreshold.setDescription('User defined threshold representing a percentage of frame buffer depth.\n         The frame buffer level is monitored by the APEX and the maximum level is\n         based on the actual input data rate.  The threshold percentage is used\n         to determine when to issue a Gigabit Ethernet Frame Buffer Fullness\n         alarm (apexAlarmGbeBufferFullness).\n        ')
apexGbeConfInRedundMonitorPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundMonitorPeriod.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundMonitorPeriod.setDescription("This is the time in seconds over which Redundant Gigabit Ethernet\n         Input Transport Stream Pairs will be monitored.  Range is 1 to 30 seconds.\n\n         Primary to Secondary Fail Over - The monitored data rate of the Primary\n         must be below the Secondary by apexManRteGbeInRedThreshold (for\n         Manual Routing) percent for apexGbeConfInRedundMonitorPeriod before fail \n         over to Secondary will occur.  Fail over to Secondary will not occur if\n         fail over is suspended for the Primary.\n\n         Secondary to Primary Switch Back - The monitored data rate of the\n         Primary must have returned above apexManRteGbeInRedThreshold (for\n         Manual Routing) percent below the Secondary for apexGbeConfInRedundMonitorPeriod\n         before switch back to Primary will occur.  Switch back to Primary will\n         not occur if fail over is suspended for the Secondary.  Once the Primary\n         is restored, switch back to Primary will be delayed by\n         apexGbeConfInRedundSwitchTime when apexGbeConfInRedundAutoSwitchBack is\n         'enabled'.  Note that if apexGbeConfInRedundAutoSwitchBack is 'disabled'\n         switch back will not occur.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfInRedundSwitchTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundSwitchTime.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundSwitchTime.setDescription("This is the time in seconds to wait before switching back to the\n         Primary of a Redundant Gigabit Ethernet Input TS pair after the Primary\n         is healthy.  Range is 0 to 3600.  This time is in addition to\n         apexGbeConfInRedundMonitorPeriod.  Switch back to Primary will\n         not occur if fail over is suspended for the Secondary.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfInRedundAutoSwitchBack = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 3), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundAutoSwitchBack.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundAutoSwitchBack.setDescription("This is the enable/disable of automatic switch back from Secondary to\n         Primary for Gigabit Ethernet redundancy.  When 'enabled', switch back\n         to the Primary will automatically occur when the Primary is restored.\n         When 'disabled', the user must force back to the Primary using\n         apexGbeConfInRedundForceToPrimary or apexManRteGbeInRedForceSwitch.\n         This parameter applies to all configured redundant pairs.\n         \n         Auto switch back to the primary will not occur if the user forced a \n         failover to the secondary. Auto switch back only occurs after a \n         non-forced failover event.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfInRedundForceToSecondary = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNotInProgress", 1), ("forceSwitch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundForceToSecondary.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundForceToSecondary.setDescription("The Gigabit Ethernet Redundant Pair force switch any\n         pair that is currently on the Primary to the Secondary.\n\n         This will have no effect if the corresponding row setting of\n         apexManRteGbeInRedEnable is 'disabled'.\n\n         This will only have an effect when the Primary is the In-Use\n         Input TS of a Redundant Pair (apexInputTsStatPriState or\n         apexInputTsStatSecState is 'openedInUse').\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexGbeConfInRedundForceToPrimary = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNotInProgress", 1), ("forceSwitch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundForceToPrimary.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundForceToPrimary.setDescription("The Gigabit Ethernet Redundant Pair force switch any\n         pair that is currently on the Secondary to the Primary.\n\n         This will have no effect if the corresponding row setting of\n         apexManRteGbeInRedEnable is 'disabled'.\n\n         This will only have an effect when the Secondary is the In-Use\n         Input TS of a Redundant Pair (apexInputTsStatPriState or\n         apexInputTsStatSecState is 'openedInUse').\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexGbeConfInRedundManualRouteRedundType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hotWarm", 1), ("hotHot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfInRedundManualRouteRedundType.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfInRedundManualRouteRedundType.setDescription("The redundancy type for output streams in Manual Routing operating\n         mode. \n         - hotWarm indicates only 1 input stream, primary or secondary, is\n         open at any one time. For multicast streams, primary will be joined initially.\n         The secondary is joined after a failover (the primary will be dropped prior\n         to joining the secondary). When falling back to the primary, the secondary is\n         dropped (closed), then the primary is joined (opened).\n         \n         - hotHot indicates both the primary and secondary streams are opened at the\n         same time. For multicast streams, both streams are joined immediately.\n\n         Changes to the redundancy type cannot be made while there are active routes. \n         All routes must be deleted prior to changing the redundancy type.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfigInputDataTsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5), )
if mibBuilder.loadTexts: apexGbeConfigInputDataTsTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsTable.setDescription("Table of data for GBE input data stream identification. Each entry in\n         this table identifies a Gigabit Ethernet input stream that is a data\n         stream only. Data streams are streams without PCR. These streams require\n         special processing to avoid overflowing the output. There are\n         128 rows in this table.\n\n         Once written, the change to this table will only take immediate\n         effect after apexGbeConfigInputDataTsApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexGbeConfigInputDataTsApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexGbeConfigInputDataTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfigInputDataTsIndex"))
if mibBuilder.loadTexts: apexGbeConfigInputDataTsEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsEntry.setDescription('GBE Input Data Stream Table Entry.')
apexGbeConfigInputDataTsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexGbeConfigInputDataTsIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsIndex.setDescription('Index of GBE Input Data Stream Table.')
apexGbeConfigInputDataTsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsEnable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsEnable.setDescription('Indicates whether this GBE Input Data Stream entry is enabled or disabled.\n        ')
apexGbeConfigInputDataTsInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsInterface.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsInterface.setDescription("Number of the input interface (Port number).\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n        ")
apexGbeConfigInputDataTsUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsUdp.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsUdp.setDescription('GBE Input UDP Port.\n\n         Range: 0-65535\n        ')
apexGbeConfigInputDataTsMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsMulticastIp.setDescription('The Multicast receive IP address.\n         An IP address of 0.0.0.0 indicates singlecast only.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexGbeConfigInputDataTsSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsSourceIp.setDescription('This is the IP address of the source device. This field is only\n         used when a multicast IP address is also specified.\n        ')
apexGbeConfigInputDataTsMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 54000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsMaxRate.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsMaxRate.setDescription('The maximum data rate in Kbps for the data stream.\n         A value of zero (0) is the default and the data stream\n         is not rate limited.\n         The maximum data rate limit may not exceed 54 Mbps.\n        ')
apexGbeConfigInputDataTsApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 6), )
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyTable.setDescription('Table of Apply Change for the GBE Input Data Stream Table.\n\n         A row in this table corresponds to the same row index in the\n         GBE Input Data Stream table (apexGbeConfigInputDataTsTable).\n        ')
apexGbeConfigInputDataTsApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfigInputDataTsApplyIndex"))
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyEntry.setDescription('GBE Input Data Stream Apply Table Entry.')
apexGbeConfigInputDataTsApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyIndex.setDescription('The index of the GBE Input Data Stream Apply Table.')
apexGbeConfigInputDataTsApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 6, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInputDataTsApplyChange.setDescription("The Apply for the row of data in the GBE Input Data Stream Table.\n\n         A row in this table corresponds to the same row index in the\n         GBE Input Data Stream table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the table rows to take effect in the APEX.  This parameter MUST\n         be set LAST after all other data in the table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexGbeConfIfRedundAutoSwitchBackEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundAutoSwitchBackEnable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundAutoSwitchBackEnable.setDescription("Enables the ability for the secondary interface to switch back when\n         link is re-detected on the primary interface. Auto switch back to the \n         primary interface will not occur if the user forced a failover to the\n         secondary. Auto switch back only occurs after a non-forced failover.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfIfRedundAutoSwitchBackPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundAutoSwitchBackPeriod.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundAutoSwitchBackPeriod.setDescription("Timer for determining that the primary interface is OK for auto-\n         switchback.  The primary interface must have link for the configured\n         amount of time.  Valid time is 1-30 seconds.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfigInterfaceRedundancyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2), )
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyTable.setDescription('This is a table of configuration parameters for GbE Interface\n         Redundancy.')
apexGbeConfigInterfaceRedundancyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfIfRedundIndex"))
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyEntry.setDescription('GbE Interface Redundancy Configuration Table Entry.')
apexGbeConfIfRedundIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeConfIfRedundIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundIndex.setDescription('GbE Interface Pair number.\n         Value of 1 is GbE1 and GbE2 pair.\n         Value of 2 is GbE3 and GbE4 pair.')
apexGbeConfIfRedundEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundEnable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundEnable.setDescription("Enables GbE Interface Redundancy for ports pair.  Failover is\n         based on link status.  If the primary GbE fails, the secondary \n         GbE will become active and will start receiving content.  \n         There is no data rate comparison, as only one interface in the \n         redundancy pair is active.  The secondary GbE cannot be in use prior \n         to enabling redundancy.  TS redundancy may not be used at\n         the same time as interface redundancy.  Interface redundancy is not\n         applicable when chassis redundancy is enabled.\n\n         Once written, the change to this table will only take immediate\n         effect after apexGbeConfIfRedundApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexGbeConfIfRedundApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfIfRedundForceFailover = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failoverNotInProgress", 1), ("failover", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundForceFailover.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundForceFailover.setDescription('When set to failover(2), this results in the APEX switching to \n         the interface that is currently not in use.  If the primary GbE is \n         in use and this is set to failover(2) mappings will be then \n         routed to the secondary GbE.  If the secondary GbE is in use and \n         this is set to failover(2) mappings will then be routed back to \n         the primary GbE.\n\n         Once written, the change to this table will take immediate\n\n         @Config(config=no, reboot=no)\n        ')
apexGbeConfIfRedundSuspendFailover = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 2, 1, 4), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundSuspendFailover.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundSuspendFailover.setDescription("Enables and disables suspending of Interface failover. Prevents failovers\n         to or from backup.  Force failover (apexGbeConfIfRedundForceFailover)\n         overrides this setting.  \n\n         Once written, the change to this table will only take immediate\n         effect after apexGbeConfIfRedundApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexGbeConfIfRedundApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexGbeConfigInterfaceRedundancyApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 3), )
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyApplyTable.setDescription('Table of Apply Change for the GBE Interface Redundancy Configuration Table.\n\n         A row in this table corresponds to the same row index in the\n         GBE Config Interface Redundancy table (apexGbeConfigInterfaceRedundancyTable).\n        ')
apexGbeConfigInterfaceRedundancyApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeConfIfRedundApplyIndex"))
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfigInterfaceRedundancyApplyEntry.setDescription('GBE Config Interface Redundancy Table Entry.')
apexGbeConfIfRedundApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeConfIfRedundApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundApplyIndex.setDescription('The index of the GBE Config Interface Redundancy Table.')
apexGbeConfIfRedundApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 1, 7, 3, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeConfIfRedundApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexGbeConfIfRedundApplyChange.setDescription("The Apply for the row of data in the GBE Config Interface Redundancy Table.\n\n         A row in this table corresponds to the same row index in the\n         GBE Config Interface Redundancy table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the GBE Input Data Stream Table row to take effect in the APEX.  This\n         parameter MUST be set LAST after all other data in the GBE Input Data Stream\n         Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexGbeBootCodeVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeBootCodeVersion.setStatus('current')
if mibBuilder.loadTexts: apexGbeBootCodeVersion.setDescription('APEX Gigabit Ethernet Processor Boot Code Version.')
apexGbeApplicationCodeVersion = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeApplicationCodeVersion.setStatus('current')
if mibBuilder.loadTexts: apexGbeApplicationCodeVersion.setDescription('APEX Gigabit Ethernet Processor Application Code Version.')
apexGbeMaxInputTs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeMaxInputTs.setStatus('current')
if mibBuilder.loadTexts: apexGbeMaxInputTs.setDescription('Maximum number of Gigabit Ethernet input transport streams\n         that can be opened on this APEX.  This is the maximum across\n         all installed GigE interfaces.  One GigE interface can use\n         all Input TS.')
apexGbeRoutedPacketUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRoutedPacketUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: apexGbeRoutedPacketUpdateInterval.setDescription('Time in seconds between Gigabit Ethernet Routed Packet\n         Count updates.  The count during this time is defined as one sample.\n\n         This time applies to packet counts contained in\n         apexGbeStatusRoutedPacketTable.\n\n         To compute rate from packet count for the last update interval:\n         Rate(bps) = (Packet_Count * 188 bytes/packet * 8 bits/byte) / Update_Interval\n\n         This value is set by the APEX at startup and is constant.\n        ')
apexGbeStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2), )
if mibBuilder.loadTexts: apexGbeStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusTable.setDescription('This is a table of status parameters for the\n         Gigabit Ethernet Interface.')
apexGbeStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeStatusGbeInterfaceNum"))
if mibBuilder.loadTexts: apexGbeStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusEntry.setDescription('Gigabit Ethernet Interface Status Table Entry.')
apexGbeStatusGbeInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeStatusGbeInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusGbeInterfaceNum.setDescription('Gigabit Ethernet Interface Number.')
apexGbeStatusMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusMacAddr.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusMacAddr.setDescription("This is the MAC address of the Gigabit Ethernet Interface.\n         It is set at the factory and cannot be changed.\n         The string length is 17 characters in the format\n         'hh:hh:hh:hh:hh:hh' where 'hh' is a hexadecimal number.")
apexGbeStatusLinkActive = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1, 3), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusLinkActive.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusLinkActive.setDescription('This indicates if the Gigabit Ethernet optical link is active.')
apexGbeStatusIgmpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("igmpV1", 1), ("igmpV2", 2), ("igmpV3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusIgmpVersion.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusIgmpVersion.setDescription('This indicates the IGMP Version being used on this interface.')
apexGbeStatusLossOfPhysicalInput = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusLossOfPhysicalInput.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusLossOfPhysicalInput.setDescription('The current severity of apexAlarmGbeLossOfPhysicalInput\n         for this interface.\n        ')
apexGbeInputTsAssignedTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 3), )
if mibBuilder.loadTexts: apexGbeInputTsAssignedTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsAssignedTable.setDescription('Table of Gigabit Ethernet Input TS Assigned data.')
apexGbeInputTsAssignedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeInputTsAssignedGbeInterfaceNum"))
if mibBuilder.loadTexts: apexGbeInputTsAssignedEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsAssignedEntry.setDescription('Gigabit Ethernet Interface Input TS Assigned Table Entry.')
apexGbeInputTsAssignedGbeInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeInputTsAssignedGbeInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsAssignedGbeInterfaceNum.setDescription('The index of the Gigabit Ethernet Input TS Assigned Table.\n         Represents the Gigabit Ethernet interface number.')
apexGbeInputTsAssignedCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsAssignedCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsAssignedCount.setDescription('Number of input transport streams assigned to the GigE interface.')
apexGbeOpenInputUdpPortTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 4), )
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortTable.setDescription('Table of Gigabit Ethernet Input Open UDP Port data.')
apexGbeOpenInputUdpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeOpenInputUdpPortGbeInterfaceNum"))
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortEntry.setDescription('Gigabit Ethernet Interface Input Open UDP Port Table Entry.')
apexGbeOpenInputUdpPortGbeInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortGbeInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortGbeInterfaceNum.setDescription('The index of the Gigabit Ethernet Input Open UDP Port Table.\n         Represents the Gigabit Ethernet interface number.')
apexGbeOpenInputUdpPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeOpenInputUdpPortCount.setDescription('Number of open Input UDP Ports on the GigE interface.')
apexGbeStatusRoutedPacketTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 5), )
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketTable.setDescription('This table contains Gigabit Ethernet MPEG packet counts for\n         each Output Transport Stream of this APEX.\n\n         Update interval is apexGbeRoutedPacketUpdateInterval.')
apexGbeStatusRoutedPacketEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeStatusRoutedPacketOutputTsNum"))
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketEntry.setDescription('Gigabit Ethernet Interface Status Routed Packet\n         Table Entry.')
apexGbeStatusRoutedPacketOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusRoutedPacketOutputTsNum.setDescription('The index of the Gigabit Ethernet Routed Packet\n         Status Table.  Represents Output Transport Stream\n         number.')
apexGbeStatusTotRoutedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusTotRoutedPackets.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusTotRoutedPackets.setDescription('Total number of Gigabit Ethernet MPEG packets routed to this\n         Output Transport Stream.')
apexGbeStatusNumRoutedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusNumRoutedPackets.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusNumRoutedPackets.setDescription('Number of Gigabit Ethernet MPEG packets routed to this Output\n         Transport Stream during the last monitoring period\n         (apexGbeRoutedPacketUpdateInterval).')
apexGbeStatusFrameCounterTableResetAll = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 1, 1), ResetStatisticsTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeStatusFrameCounterTableResetAll.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusFrameCounterTableResetAll.setDescription('Reset Ethernet Frame Counter Totals for all GigE interfaces:\n            - apexGbeTotalRxSinglecastFrames\n            - apexGbeTotalRxMulticastFrames\n            - apexGbeTotalRxBroadcastFrames\n            - apexGbeTotalRxErrorFrames\n            - apexGbeTotalRxFrames\n            - apexGbeTotalTxGoodFrames\n            - apexGbeTotalTxErrorFrames\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexGbeFrameCounterUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameCounterUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameCounterUpdateInterval.setDescription('Time in seconds between Gigabit Ethernet Frame Counter\n         updates.  The count during this time is defined as one sample.\n\n         This time applies to packet counts contained in\n         apexGbeStatusFrameCounterTable.\n\n         To compute rate from frame count for the last update interval:\n         Rate(bps) = (Frame_Count * 7 packets/frame 188 bytes/packet * 8 bits/byte)\n                     / Update_Interval\n\n         This value is set by the APEX at startup and is constant.\n        ')
apexGbeStatusFrameCounterTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2), )
if mibBuilder.loadTexts: apexGbeStatusFrameCounterTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusFrameCounterTable.setDescription('Table of Gigabit Ethernet Frame Counter Statistics.')
apexGbeStatusFrameCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeFrameCounterGbeInterfaceNum"))
if mibBuilder.loadTexts: apexGbeStatusFrameCounterEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusFrameCounterEntry.setDescription('Gigabit Ethernet Interface Frame Counter Table Entry.')
apexGbeFrameCounterGbeInterfaceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeFrameCounterGbeInterfaceNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameCounterGbeInterfaceNum.setDescription('The index of the Gigabit Ethernet Frame Counter Table.\n         Represents the Gigabit Ethernet interface number.')
apexGbeFrameCounterReset = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 2), ResetStatisticsTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeFrameCounterReset.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameCounterReset.setDescription('Reset Ethernet Frame Counter Statistics totals for a single GigE interface:\n            - apexGbeTotalRxSinglecastFrames\n            - apexGbeTotalRxMulticastFrames\n            - apexGbeTotalRxBroadcastFrames\n            - apexGbeTotalRxErrorFrames\n            - apexGbeTotalRxFrames\n            - apexGbeTotalTxGoodFrames\n            - apexGbeTotalTxErrorFrames\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexGbeTotalRxSinglecastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxSinglecastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxSinglecastFrames.setDescription('Total number of singlecast Ethernet frames received since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTotalRxMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxMulticastFrames.setDescription('Total number of multicast Ethernet frames received since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTotalRxBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxBroadcastFrames.setDescription('Total number of broadcast Ethernet frames received since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTotalRxErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxErrorFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxErrorFrames.setDescription('Total number of bad Ethernet frames received since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTotalRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxFrames.setDescription('Total number of Ethernet frames received since last reset.\n         This is the sum of apexGbeTotalRxSinglecastFrames, apexGbeTotalRxMulticastFrames,\n         apexGbeTotalRxBroadcastFrames, and apexGbeTotalRxErrorFrames.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeRxSinglecastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxSinglecastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxSinglecastFrames.setDescription('Number of singlecast Ethernet frames received during last\n         status checking interval.\n         Status checking interval is apexGbeFrameCounterUpdateInterval.')
apexGbeRxMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxMulticastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxMulticastFrames.setDescription('Number of multicast Ethernet frames received during\n         last status checking interval.\n         Status checking interval is apexGbeFrameCounterUpdateInterval.')
apexGbeRxBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxBroadcastFrames.setDescription('Number of broadcast Ethernet frames received during last status\n         checking interval.\n         Status checking interval is apexGbeFrameCounterUpdateInterval.')
apexGbeRxErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxErrorFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxErrorFrames.setDescription('Number of bad Ethernet frames received during\n         last status checking interval.\n         Status checking interval is apexGbeFrameCounterUpdateInterval.')
apexGbeRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxFrames.setDescription('Number of Ethernet frames received during last\n         status checking interval.\n         This is the sum of apexGbeRxSinglecastFrames, apexGbeRxMulticastFrames,\n         apexGbeRxBroadcastFrames, and apexGbeRxErrorFrames.\n         Status checking interval is five seconds.')
apexGbeTotalTxGoodFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalTxGoodFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalTxGoodFrames.setDescription('Total number of good Ethernet frames (singlecast, multicast, and broadcast)\n         transmitted since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTotalTxErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalTxErrorFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalTxErrorFrames.setDescription('Total number of bad Ethernet frames transmitted since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeTxGoodFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTxGoodFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTxGoodFrames.setDescription('Number of good Ethernet frames (singlecast, multicast, and broadcast)\n         transmitted during last status checking interval.\n         Status checking interval is five seconds.')
apexGbeTxErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTxErrorFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTxErrorFrames.setDescription('Number of bad Ethernet frames transmitted during last\n         status checking interval.\n         Status checking interval is five seconds.')
apexGbeRxDocsisFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxDocsisFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxDocsisFrames.setDescription('Number of good Ethernet frames containing DOCSIS (singlecast, multicast, and broadcast)\n         received during last status checking interval.\n         Status checking interval is five seconds.')
apexGbeTotalRxDocsisFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalRxDocsisFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalRxDocsisFrames.setDescription('Total number of good Ethernet frames containing DOCSIS(singlecast, multicast, and broadcast)\n         received since last reset.\n         Reset using apexGbeStatusFrameCounterTableResetAll or apexGbeFrameCounterReset.')
apexGbeRxMpegDocsisFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeRxMpegDocsisFrames.setStatus('current')
if mibBuilder.loadTexts: apexGbeRxMpegDocsisFrames.setDescription('Number of MPEG packets generated from DOCSIS data (singlecast, multicast, and broadcast)\n         received during last status checking interval.\n         Status checking interval is five seconds.')
apexGbeIpFragmentedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeIpFragmentedPkts.setStatus('current')
if mibBuilder.loadTexts: apexGbeIpFragmentedPkts.setDescription('Number of IP fragmented packets received during last status checking interval.\n         Status checking interval is five seconds.')
apexGbeTotalIpFragmentedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 6, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeTotalIpFragmentedPkts.setStatus('current')
if mibBuilder.loadTexts: apexGbeTotalIpFragmentedPkts.setDescription('Total number of IP fragmented packets received during last status checking interval.\n         Status checking interval is five seconds.')
apexGbeFrameBufferStatsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2), )
if mibBuilder.loadTexts: apexGbeFrameBufferStatsTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferStatsTable.setDescription('Table of Gigabit Ethernet Frame Buffer Statistics for each GBE processor.')
apexGbeFrameBufferStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeFrameBufferProcessorNum"))
if mibBuilder.loadTexts: apexGbeFrameBufferStatsEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferStatsEntry.setDescription('Gigabit Ethernet Frame Buffer Statistics Table Entry.')
apexGbeFrameBufferProcessorNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeFrameBufferProcessorNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferProcessorNum.setDescription('Index of the Gigabit Ethernet Buffer Statistics Table.\n\n         Gigabit Ethernet Processor Number.\n             Proc 1 = GBE Interfaces 1 and 2\n             Proc 2 = GBE Interfaces 3 and 4\n        ')
apexGbeFrameBufferResetLevelLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferResetLevelLimit.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferResetLevelLimit.setDescription('The point at which the GigE frame buffer will be reset, in milliseconds.\n         This value is equal to (maximum buffer depth - 5).  The maximum buffer\n         depth is calculated based on the expected input data rate\n         (apexGbeConfigFrameBufferMaxInDataRate).')
apexGbeFrameBufferCurrMsLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferCurrMsLevel.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferCurrMsLevel.setDescription('Current highest Gigabit Ethernet Frame Buffer level in milliseconds.')
apexGbeFrameBufferCurrPercentFull = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferCurrPercentFull.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferCurrPercentFull.setDescription('Current highest Gigabit Ethernet Frame Buffer fullness as a percentage of\n         the buffer depth available for a given aggregate rate.  This percentage is\n         calculated using the current buffer level (apexGbeFrameBufferCurrMsLevel) and\n         the actual input data rate.')
apexGbeFrameBufferUnderflowLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferUnderflowLevel.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferUnderflowLevel.setDescription('The point at which the GigE frame buffer will underflow, in milliseconds.\n         This value is calculated based on the sum of the number of received frames per second\n         for all interfaces.')
apexGbeFrameBufferOverflowLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferOverflowLevel.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferOverflowLevel.setDescription('The point at which the GigE frame buffer will overflow, in milliseconds.\n         This value is calculated based on the sum of the number of received frames per second\n         for all interfaces.')
apexGbeFrameBufferAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferAlarmStatus.setDescription('The current highest severity of apexAlarmGbeBufferFullness for the\n         GBE Processor.\n        ')
apexGbeFrameBufferHourlyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3), )
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyTable.setDescription('Table of Gigabit Ethernet Frame Buffer Statistics.  There can be up\n         to 24 entries in the table for each GBE Processor.  Each entry represents\n         one hour.  The newest entry is placed at the beginning of the table and,\n         if necessary, the oldest entry is pushed off the end of the table.  The\n         table will not be full until 24 hours have passed.')
apexGbeFrameBufferHourlyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeFrameBufferHourlyProcessorNum"), (0, "APEX-MIB", "apexGbeFrameBufferHourlyIndex"))
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyEntry.setDescription('Gigabit Ethernet Interface Frame Buffer Table Entry.')
apexGbeFrameBufferHourlyProcessorNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyProcessorNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyProcessorNum.setDescription('First index of the Gigabit Ethernet Buffer Status Table.\n\n         Gigabit Ethernet Processor Number.\n             Proc 1 = GBE Interfaces 1 and 2\n             Proc 2 = GBE Interfaces 3 and 4\n        ')
apexGbeFrameBufferHourlyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24)))
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyIndex.setDescription('Second index of the Gigabit Ethernet Buffer Status Table.\n\n         Each index represents one hour.  There can be up to 24 entries in the table.\n         The most recent entry is always at the beginning of the table.')
apexGbeFrameBufferHourlyInInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInInterface.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInInterface.setDescription('Number of the input interface for the Gigabit Ethernet\n         interface that experienced the highest buffer level for the hour.\n        ')
apexGbeFrameBufferHourlyInUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInUdp.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInUdp.setDescription('Input UDP Port for the Gigabit Ethernet\n         interface that experienced the highest buffer level for the hour.\n        ')
apexGbeFrameBufferHourlyInMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInMulticastIp.setDescription('Input Multicast IP address for the Gigabit Ethernet\n         interface that experienced the highest buffer level for the hour.\n        ')
apexGbeFrameBufferHourlyInSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyInSourceIp.setDescription('Input IGMP v3 Source IP for the Gigabit Ethernet\n         interface that experienced the highest buffer level for the hour.\n        ')
apexGbeFrameBufferHourlyMaxMsLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyMaxMsLevel.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyMaxMsLevel.setDescription('The maximum Gigabit Ethernet frame buffer level (in milliseconds)\n         recorded for the hour.')
apexGbeFrameBufferHourlyMaxPercentFull = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyMaxPercentFull.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyMaxPercentFull.setDescription('The maximum Gigabit Ethernet frame buffer level percentage recorded\n         for the hour.')
apexGbeFrameBufferHourlyGpsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyGpsTime.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyGpsTime.setDescription('The GPS time when the maximum Gigabit Ethernet frame buffer level\n         was reached.')
apexGbeFrameBufferHourlyOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyOverflows.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyOverflows.setDescription('The number of overflows recorded on Gigabit Ethernet interface\n         for the hour.')
apexGbeFrameBufferHourlyResets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 7, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyResets.setStatus('current')
if mibBuilder.loadTexts: apexGbeFrameBufferHourlyResets.setDescription('The number of resets reported by the GigE processor during the hour.')
apexGbeStatusInputTsUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusInputTsUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsUpdateInterval.setDescription('Time in seconds between Gigabit Ethernet Input Transport Stream Packet\n         Count updates.  The count during this time is defined as one sample.\n\n         This time applies to packet counts contained in\n         apexGbeStatusInputTsTable.\n\n         To compute rate from packet count for the last update interval:\n         Rate(bps) = (Packet_Count * 188 bytes/packet * 8 bits/byte) / Update_Interval\n\n         This value is set by the APEX at startup and is constant.\n        ')
apexGbeStatusInputTsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2), )
if mibBuilder.loadTexts: apexGbeStatusInputTsTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsTable.setDescription('Table of Gigabit Ethernet Input Transport Stream status.\n\n         A row in this table corresponds to the same index row in\n         apexInputTsStatTable and apexGbeStatusInputTsErrorTable.\n\n         Packet Counts are updated every apexGbeStatusInputTsUpdateInterval.\n         The count during a apexGbeStatusInputTsUpdateInterval is a sample.\n         The samples are accumulated into a set of rolling statistics that cover\n         a maximum of a 15 minute sampling time period.  The sampling period is\n         the amount of time over which the data in the corresponding row has been\n         collected.  When the sampling period reaches 15 minutes, old data is\n         removed from the accumulated statistics and new data is rolled in.  In\n         this way, the average, minimum, and peak rates for the sampling period\n         are maintained.\n        ')
apexGbeStatusInputTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeStatInTsInputTsNum"))
if mibBuilder.loadTexts: apexGbeStatusInputTsEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsEntry.setDescription('Gigabit Ethernet Input Transport Stream Status Table Entry.')
apexGbeStatInTsInputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexGbeStatInTsInputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsInputTsNum.setDescription('The Gigabit Ethernet Input Transport Stream Status table index.\n\n         A row in this table corresponds to the same index row in\n         apexInputTsStatTable and apexGbeStatusInputTsErrorTable.\n        ')
apexGbeStatInTsSamplingPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSamplingPeriod.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSamplingPeriod.setDescription('The total time, in seconds, over which the packet counts statistics\n         in this row have been collected.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriCurDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriCurDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriCurDataCount.setDescription('The Data Packet Count of the most recent sample for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriAvgDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriAvgDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriAvgDataCount.setDescription('The Average Data Packet Count per sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriMinDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriMinDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriMinDataCount.setDescription('The Minimum Data Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriPeakDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriPeakDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriPeakDataCount.setDescription('The Peak Data Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriCurStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriCurStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriCurStreamCount.setDescription('The Transport Stream Packet Count of the most recent sample for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriAvgStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriAvgStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriAvgStreamCount.setDescription('The Average Transport Stream Packet Count per sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriMinStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriMinStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriMinStreamCount.setDescription('The Minimum Transport Stream Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsPriPeakStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriPeakStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriPeakStreamCount.setDescription('The Peak Transport Stream Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the primary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecCurDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecCurDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecCurDataCount.setDescription('The Data Packet Count of the most recent sample for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecAvgDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecAvgDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecAvgDataCount.setDescription('The Average Data Packet Count per sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecMinDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecMinDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecMinDataCount.setDescription('The Minimum Data Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecPeakDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecPeakDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecPeakDataCount.setDescription('The Peak Data Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecCurStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecCurStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecCurStreamCount.setDescription('The Transport Stream Packet Count of the most recent sample for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecAvgStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecAvgStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecAvgStreamCount.setDescription('The Average Transport Stream Packet Count per sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecMinStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecMinStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecMinStreamCount.setDescription('The Minimum Transport Stream Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsSecPeakStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecPeakStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecPeakStreamCount.setDescription('The Peak Transport Stream Packet Count sample during\n         apexGbeStatInTsSamplingPeriod for the secondary.\n\n         Refer to the description of apexGbeStatusInputTsTable for an\n         explanation of packet counting.  Refer to the description of\n         apexGbeStatusInputTsUpdateInterval for an explanation of update\n         interval and computing rates.\n        ')
apexGbeStatInTsTotPacketDropCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsTotPacketDropCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsTotPacketDropCount.setDescription('The total number of dropped packets for the Input Transport Stream.\n         Clear using apexGbeStatusInputTsDropCounterClearAll.\n        ')
apexGbeStatInTsCurPacketDropCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsCurPacketDropCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsCurPacketDropCount.setDescription('The number of packets dropped for the Input Transport Stream in\n         the last five (5) seconds.\n        ')
apexGbeStatusInputTsErrorTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3), )
if mibBuilder.loadTexts: apexGbeStatusInputTsErrorTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsErrorTable.setDescription('Table of Gigabit Ethernet Input Transport Stream Error status.\n\n         A row in this table corresponds to the same index row in\n         apexInputTsStatTable and apexGbeStatusInputTsTable.\n        ')
apexGbeStatusInputTsErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeStatInTsErrorInputTsNum"))
if mibBuilder.loadTexts: apexGbeStatusInputTsErrorEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsErrorEntry.setDescription('Gigabit Ethernet Input Transport Stream Status Table Entry.')
apexGbeStatInTsErrorInputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexGbeStatInTsErrorInputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsErrorInputTsNum.setDescription('The Gigabit Ethernet Input Transport Stream Error Status table index.\n\n         A row in this table corresponds to the same index row in\n         apexInputTsStatTable and apexGbeStatusInputTsTable.\n        ')
apexGbeStatInTsPriErrorSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriErrorSummary.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriErrorSummary.setDescription('The current highest error of the following errors for the primary\n         input transport stream:\n            apexGbeStatInTsPriLowBitRateError\n            apexGbeStatInTsPriHighBitRateError\n            apexGbeStatInTsMptsRedundPriError\n            apexGbeStatInTsMptsRedundFailError\n            apexGbeStatInTsPriLossInputError\n            apexGbeStatInTsPriPacketDropError\n        ')
apexGbeStatInTsPriLowBitRateError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriLowBitRateError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriLowBitRateError.setDescription('The current low bit rate state for the primary input stream.\n         Ok indicates no errors or not checking low bit rate. Error indicates\n         primary input stream is below the low bit rate specified.\n        ')
apexGbeStatInTsPriHighBitRateError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriHighBitRateError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriHighBitRateError.setDescription('The current high bit rate state for the primary input stream.\n         Ok indicates no errors or not checking high bit rate. Error indicates\n         primary input stream is above the high bit rate specified.\n        ')
apexGbeStatInTsMptsRedundPriError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsMptsRedundPriError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsMptsRedundPriError.setDescription('The current redundant threshold state for the primary input stream.\n         Ok indicates no errors or input stream is not part of a redundant pair.\n         Error indicates primary input stream is below the threshold level specified.\n        ')
apexGbeStatInTsMptsRedundFailError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsMptsRedundFailError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsMptsRedundFailError.setDescription('The current fail over state for a redundancy pair.\n         Ok indicates no errors or input stream is not part of a redundant pair.\n         Error indicates primary input stream is no longer in use and the APEX\n         has fallen over to use the secondary input stream.\n        ')
apexGbeStatInTsSecErrorSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecErrorSummary.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecErrorSummary.setDescription('The current highest error state of the following for the secondary\n         input transport stream:\n            apexGbeStatInTsSecLowBitRateError\n            apexGbeStatInTsSecHighBitRateError\n            apexGbeStatInTsSecLossInputError\n        ')
apexGbeStatInTsSecLowBitRateError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecLowBitRateError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecLowBitRateError.setDescription('The current low bit rate state for the secondary input stream.\n         Ok indicates no errors or not checking low bit rate. Error indicates\n         secondary input stream is below the low bit rate specified.\n        ')
apexGbeStatInTsSecHighBitRateError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecHighBitRateError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecHighBitRateError.setDescription('The current high bit rate state for the secondary input stream.\n         Ok indicates no errors or not checking high bit rate. Error indicates\n         secondary input stream is above the high bit rate specified.\n        ')
apexGbeStatInTsPriLossInputError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPriLossInputError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPriLossInputError.setDescription('The current loss of input stream state for the primary input stream.\n         Ok indicates no errors or not checking for loss of input stream.\n         Error indicates primary input stream is missing.\n        ')
apexGbeStatInTsSecLossInputError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsSecLossInputError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsSecLossInputError.setDescription('The current loss of input stream state for the secondary input stream.\n         Ok indicates no errors or not checking for loss of input stream.\n         Error indicates secondary input stream is missing.\n        ')
apexGbeStatInTsPacketDropError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 8, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatInTsPacketDropError.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatInTsPacketDropError.setDescription('The current packet drop state for the active input stream.\n         Ok indicates no errors or not checking for packet drops.\n         Error indicates there are packet drops on the active input stream.\n        ')
apexGbeStatusInterfaceRedundTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1), )
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundTable.setDescription('This is a table of status parameters for GbE Interface\n         Redundancy.')
apexGbeStatusInterfaceRedundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeStatusInterfaceRedundIndex"))
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundEntry.setDescription('GbE Interface Redundancy Status Table Entry.')
apexGbeStatusInterfaceRedundIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundIndex.setDescription('GbE Interface Pair number.  Value of 1 is GbE1 and GbE2 pair.\n         Value of 2 is GbE3 and GbE4 pair.')
apexGbeStatusInterfaceRedundActiveIf = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundActiveIf.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundActiveIf.setDescription('The current active interface for the redundant pair. This is only\n        applicable if GbE Interface Redundancy is enabled for the pair.  If\n        GbE Interface Redundancy is not enabled it will be set to zero.\n        ')
apexGbeStatusInterfaceRedundInvalidApplyText = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundInvalidApplyText.setDescription('When apexGbeConfIfRedundApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of an\n         entry that was invalid.')
apexGbeStatusInterfaceRedundFaultCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundFaultCondition.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInterfaceRedundFaultCondition.setDescription('Current fault condition of the GbE Interface pair.\n         Reflects apexAlarmGbeInterfaceRedundFailOver for this redundant pair.\n        ')
apexGbeStatusInputTsDropCounterClearAll = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 2, 10, 1, 1), ClearCountersTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeStatusInputTsDropCounterClearAll.setStatus('current')
if mibBuilder.loadTexts: apexGbeStatusInputTsDropCounterClearAll.setDescription('Clear dropped packet counts for all Input Streams:\n            - apexGbeStatInTsTotPacketDropCount\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexGbeSfpUpdateStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("updateNotInProgress", 1), ("update", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexGbeSfpUpdateStatus.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpUpdateStatus.setDescription("When set to 'update' the APEX will update the apexGbeSfpStatusTable\n         by performing an one-time read of SFP memory.\n \n         APEX sets back to 'updateNotInProgress' when complete.\n \n         Once written, the change to this parameter will take immediate effect.\n \n         @Config(config=no, reboot=no)\n        ")
apexGbeSfpStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 2), )
if mibBuilder.loadTexts: apexGbeSfpStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpStatusTable.setDescription('Table of SFP status parameters.\n         Indexed by Gigabit Ethernet Interface Number.\n        ')
apexGbeSfpStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeSfpStatusGbeIfNum"))
if mibBuilder.loadTexts: apexGbeSfpStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpStatusEntry.setDescription('SFP status table entry.')
apexGbeSfpStatusGbeIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexGbeSfpStatusGbeIfNum.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpStatusGbeIfNum.setDescription('Gigabit Ethernet Interface Number.')
apexGbeSfpStatusVendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeSfpStatusVendorId.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpStatusVendorId.setDescription('ASCII format of bytes 0-127 from SFP-MSA ID Memory Map address A0h.\n         Zero-length indicates that no SFP module is installed.\n        ')
apexGbeSfpStatusDiagInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 7, 3, 2, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeSfpStatusDiagInfo.setStatus('current')
if mibBuilder.loadTexts: apexGbeSfpStatusDiagInfo.setDescription('ASCII format of bytes 96-127 from SFP Diagnostic Memory address A2h.\n         Zero-length indicates that diagnostic information is not available.\n        ')
apexQamConfigTransmissionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("annexB-ATSC-DCII", 1), ("annexA-DVB", 2), ("annexC-Asia-Pacific", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamConfigTransmissionMode.setStatus('current')
if mibBuilder.loadTexts: apexQamConfigTransmissionMode.setDescription("This is the QAM Transmission Mode as defined in:\n         Series J: Transmission of Television, Sound Programme\n         and other Multimedia Signals, ITU-T J.83.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamModuleUpgradeSlot = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamModuleUpgradeSlot.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleUpgradeSlot.setDescription("This is the QAM slot number of the QAM Module that is being upgraded\n         from a 2x4 channel module to a 2x8 channel module.\n         Zero indicates no slot selected.\n\n         Once written, the change to this table will only take immediate\n         effect after apexQamModuleUpgradeApplyChange is set to 'apply'.\n\n         @Config(config=no, reboot=no)\n         @Commit(param=apexQamModuleUpgradeApplyChange, value=2)\n        ")
apexQamModuleUpgradeCode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamModuleUpgradeCode.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleUpgradeCode.setDescription("This is the encrypted upgrade code for the QAM Module that is\n         being upgraded from a 2x4 channel module to a 2x8 channel module.\n         The Upgrade Code is specific to a QAM Module and can only be used\n         for the QAM Module with the serial number for which the Upgrade\n         Code was created.\n\n         Once written, the change to this parameter will only take immediate\n         effect after the corresponding apexQamModuleUpgradeApplyChange\n         is set to 'apply'.\n         \n         This parameter is cleared by the APEX after the apply is complete.\n\n         @Config(config=no, reboot=no)\n         @Commit(param=apexQamModuleUpgradeApplyChange, value=2)\n        ")
apexQamModuleUpgradeApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 2, 3), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamModuleUpgradeApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleUpgradeApplyChange.setDescription("This is the Apply for QAM Module Upgrade Slot and Code.\n\n         This parameter MUST be set to 'apply' in order for\n         apexQamModuleUpgradeSlot and apexQamModuleUpgradeCode to\n         take effect.  This parameter MUST be set LAST after\n         apexQamModuleUpgradeSlot and apexQamModuleUpgradeCode has\n         been configured.\n\n         The APEX will set this to applyNotInProgressInvalidData if\n         the Upgrade Code is incorrect and the QAM Module is not\n         upgraded.\n\n         @Config(config=no, reboot=no)\n        ")
apexQamConfigApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 3), )
if mibBuilder.loadTexts: apexQamConfigApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexQamConfigApplyTable.setDescription('Table of Apply Change for the data for apexQamRfConfigTable.\n        ')
apexQamConfigApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexQamConfigApplyRfPortNum"))
if mibBuilder.loadTexts: apexQamConfigApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamConfigApplyEntry.setDescription('QAM Configuration Apply Table Entry.')
apexQamConfigApplyRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexQamConfigApplyRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamConfigApplyRfPortNum.setDescription('The QAM RF Port number.\n         Port 1,2,7,8 is Slot 1\n         Port 3,4,9,10 is Slot 2\n         Port 5,6,11,12 is Slot 3')
apexQamConfigApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 3, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexQamConfigApplyChange.setDescription("The Apply for a row of data in apexQamRfConfigTable.\n\n         A row in this table corresponds to the same row index in the\n         apexQamRfConfigTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the rows to take effect in the APEX.  This parameter MUST be set\n         LAST after all other data in the configuration table rows has been\n         configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexQamRfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4), )
if mibBuilder.loadTexts: apexQamRfConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigTable.setDescription("Table of configuration items configurable on a QAM RF Port basis.\n\n         There can be up to 12 RF Ports on an APEX1000 depending on how the 3\n         QAM slots are populated. There can be 2 or 4 RF Ports in each QAM slot.\n         \n         The 2 RF Ports in a 2x8(2x4) QAM module (1,2) in a QAM slot are mapped\n         to table rows as follows:\n         \n               Slot        Rows (RF port)\n                1          1,2\n                2          3,4\n                3          5,6\n\n         If a QAM Module in a slot only has 2 RF ports, the first three rows\n         in this table for that slot are to be used.  For example, if there\n         is a 2x4 or 2x8 module in slot 3, port 5 and 6  are to be used for\n         configuring the RF Ports of the module.\n         \n         The 4 RF Ports in a 4x4 QAM module (1,2,7,8) in a QAM slot are mapped\n         to table rows as follows:\n               Slot        Rows (RF port)\n                1          1,2,7,8\n                2          3,4,9,10\n                3          5,6,11,12\n\n         All entries/rows in this table are used for the 4x4 QAM Module with\n         any exceptions noted in the descriptions for the table entries.\n         \n         All entries in this table have the same ranges for the 4x4 QAM Module\n         with any exceptions noted in the descriptions for the table entries.\n         \n         Refer to the description of apexQamChannelConfigTable for information\n         on QAM Channel to RF Port mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n         \n         Once written, the change to this table will only take immediate\n         effect after apexQamConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexQamRfConfigRfPortNum"))
if mibBuilder.loadTexts: apexQamRfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigEntry.setDescription('QAM RF Port Configuration Table Entry.')
apexQamRfConfigRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexQamRfConfigRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfPortNum.setDescription('The QAM RF Port number.')
apexQamRfConfigNumChannelsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigNumChannelsEnabled.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigNumChannelsEnabled.setDescription("The number of QAM Channels enabled on the RF Port.\n\n         APEX will not allow enabling of more channels than the installed\n         QAM Module will support.  Note that when this parameter is\n         changed and applied there will be an interruption in service on\n         all active channels on this RF Port.\n\n         When QAM Transmission Mode is 'annexA-DVB', enabled channels is\n         also limited by the Channel Spacing such that the total bandwidth\n         of the RF must not exceed 48 MHz.\n        ")
apexQamRfConfigModulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("qam64", 1), ("qam256", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigModulationMode.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigModulationMode.setDescription('The QAM Modulation mode for the QAM RF Port.  This is the QAM\n         Modulation mode of all QAM Channels enabled on the RF Port.\n         \n         For 4x4 QAM Modules: This parameter applies on an RF pair basis,\n         1-2 and 7-8.  APEX1000 will use only odd table indices.  Even index\n         of pair will be ignored and set to value for odd index of pair.\n        ')
apexQamRfConfigSymbolRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(800000, 6980000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigSymbolRate.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigSymbolRate.setDescription("The Symbol Rate Setting of the QAM Channels enabled on the RF Port.\n         It is in symbols per second (sps).\n\n         When QAM Transmission Mode is 'annexA-DVB' the range is 800,000 sps to\n         6,980,000 sps in 1000 sps steps.\n\n         When QAM Transmission Mode is 'annexC-Asia-Pacific' the range is\n         800,000 sps to 5,310,000 sps in 1000 sps steps.\n\n         The APEX will correct values not on a 1000 sps boundary so the user or\n         management system does not need to enforce the step size.\n\n         When QAM Transmission Mode is 'annexB-ATSC-DCII' this parameter is\n         not configurable and is set by the APEX based on QAM Modulation Mode.\n         \n         For 4x4 QAM Modules: This parameter applies on an RF pair basis,\n         1-2 and 7-8.  APEX1000 will use only odd table indices.  Even index\n         of pair will be ignored and set to value for odd index of pair.\n\n         @Range(step=1000)\n        ")
apexQamRfConfigSpectrumInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigSpectrumInvert.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigSpectrumInvert.setDescription('The Spectrum Inversion Setting of the QAM Channels enabled\n         on the RF Port.\n        ')
apexQamRfConfigTuningMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("frequency", 1), ("channel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigTuningMode.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigTuningMode.setDescription("The tuning mode of the QAM Channels enabled on the RF Port.\n\n         'frequency' - The APEX tunes based on frequency as configured in\n                       RF Center Frequency for QAM Channel A and channel\n                       spacing as configured in RF Channel Spacing to\n                       determine the frequency of the B - H channels.\n         'channel'   - The APEX tunes based on channel as configured in\n                       Channel Number for QAM Channel A using the selected\n                       Frequency Plan.  The APEX will set the B - H channels\n                       to the next sequential channels.  Applies only when\n                       QAM Transmission Mode is 'annexB-ATSC-DCII'.\n        ")
apexQamRfConfigEiaFrequencyPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("std", 1), ("hrc", 2), ("irc", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigEiaFrequencyPlan.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigEiaFrequencyPlan.setDescription("This is the frequency plan to use for tuning of the QAM Channels\n         enabled on the RF Port.  Frequency plans are as per CEA Standard:\n         Cable Television Channel Identification Plan (CEA-542-B).\n\n         This parameter is valid only when QAM Transmission Mode is\n         'annexB-ATSC-DCII'.\n\n         'std' - Standard (STD) North American frequency plan.\n         'hrc' - Harmonic Related Carrier (HRC) frequency plan.\n         'irc' - Incremental Related Carrier (IRC) frequency plan.\n        ")
apexQamRfConfigEiaChanNumChannelA = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 158))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigEiaChanNumChannelA.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigEiaChanNumChannelA.setDescription("The Channel Number for QAM Channel A.  Range is 0 to 158, with valid\n         channels being 1 to 158 and 0 indicating 'not applicable'.\n\n         This parameter is valid only when QAM Transmission Mode is\n         'annexB-ATSC-DCII'.\n\n         This parameter is configurable only when Tuning Mode is 'channel'.\n\n         When Tuning Mode is 'channel', this is the Channel Number used to\n         determine the output frequency of QAM Channel A using the selected\n         Frequency Plan.\n\n         When Tuning Mode is 'frequency', this value is determined by the\n         APEX using the selected Frequency Plan.  If there is no channel\n         number for the frequency, the value is set to zero.\n\n         This parameter is not configurable for Transmission Modes of\n         'annexA-DVB' or 'annexC-Asia-Pacific' and the value is set to zero\n         by the APEX.\n\n         Channel 1 is not defined in CEA Standard: Cable Television Channel\n         Identification Plan (CEA-542-B) for the Standard (STD) North American\n         frequency plan.  Channel 1 cannot be selected when\n         apexQamRfConfigEiaFrequencyPlan is 'std'.\n\n         Channel 2 as defined in defined in CEA Standard: Cable Television\n         Channel Identification Plan (CEA-542-B) for the Harmonic Related\n         Carrier (HRC) frequency plan is below the APEX 57 MHz minimum\n         frequency. Channel 2 cannot be selected when\n         apexQamRfConfigEiaFrequencyPlan is 'hrc'.\n         \n         For 4x4 QAM Modules: Channels with frequencies below 69 MHz may not\n         be available.  This limitation is dependent upon the HW version\n         installed and number of channels enabled.\n        ")
apexQamRfConfigRfCenterFreqChannelA = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(57000000, 999000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigRfCenterFreqChannelA.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfCenterFreqChannelA.setDescription("The RF Center Frequency for QAM Channel A.\n\n         When QAM Transmission Mode is 'annexA-DVB' the range is 85,000,000 Hz\n         to 999,000,000 Hz in 250,000 Hz steps.\n\n         For 2x4/2x8 QAM Modules: When QAM Transmission Mode is 'annexB-ATSC-DCII'\n         or 'annexC-Asia-Pacific' the range is 57,000,000 Hz to 999,000,000 Hz in\n         250,000 Hz steps.\n\n         For 4x4 QAM Modules: When QAM Transmission Mode is 'annexB-ATSC-DCII'\n         or 'annexC-Asia-Pacific' the range may be limited to 69,000,000 Hz\n         to 999,000,000 Hz in 250,000 Hz steps.  This limitation is dependent\n         upon the HW version installed and number of channels enabled.\n\n         The APEX will correct values not on a 250 kHz boundary so the user or\n         management system does not need to enforce the step size.\n\n         This parameter is configurable ONLY when Tuning Mode is 'frequency'.\n\n         When Tuning Mode is 'channel', the value is set by the APEX using the\n         selected Frequency Plan.\n\n         @Range(step=250000)\n        ")
apexQamRfConfigRfChanSpacing = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1000000, 8000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigRfChanSpacing.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfChanSpacing.setDescription("The Channel spacing for the QAM Channels enabled on the RF Port.\n         This value must be in Hz in the range 1,000,000 Hz to 8,000,000 Hz\n         in 500,000 Hz steps.\n\n         The APEX will correct values not on a 500,000 Hz boundary so the\n         user or management system does not need to enforce the step size.\n\n         For 2x4/2x8 QAM Modules: When Transmission Mode is 'annexA-DVB'\n         this value is configurable. Note that number of channels enabled\n         can be affected by changing channel spacing.  The total bandwidth of\n         the RF must not exceed 48 MHz.\n\n         For 2x4/2x8 QAM Modules: When Transmission Mode is 'annexB-ATSC-DCII'\n         or 'annexC-Asia-Pacific' this value is fixed and is set by the APEX.\n         \n         For 4x4 QAM Modules: This value is fixed and is set by the APEX.\n\n         @Range(step=500000)\n        ")
apexQamRfConfigRfLevelAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-300, 800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigRfLevelAttenuation.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfLevelAttenuation.setDescription("The RF level attenuation setting of each enabled channel on the\n         RF Port.\n\n         Range is -300 to 800 representing -3 to 8 dB attenuation in\n         0.01 dB steps. (See 'Note' below.)\n\n         Positive values are the amount below the nominal RF output level\n         for the number of channels enabled on the RF Port.  Negative\n         values are the amount above the nominal.\n             Number    Nominal    dBmV      dBmV\n            Channels    dBmV     W/-300     W/800\n               1         60        63        52\n               2         56        59        48\n               4         52        55        44\n               6         50        53        42\n               8         49        52        41\n               \n         Note: Early APEX only supported attenuation.  Gain was added\n               later, hence the negative attenuation values for this\n               parameter.  For clarity, the APEX Element Manager display\n               indicates 'RF Level Adjust', with a user selectable\n               range of -8.00 to +3.00 dB, rather than 'Attenuation'.\n               The APEX EM then sets this MIB parameter appropriately.\n        ")
apexQamRfConfigRfLevelLowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigRfLevelLowThreshold.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfLevelLowThreshold.setDescription('The threshold delta relative to the configured RF level that will\n         indicate an RF Low condition.  The measured output must drop this\n         amount for RF Low condition.\n\n         Range is 0 to 100 representing 0 to 10 dB in 0.1 dB steps.\n        ')
apexQamRfConfigRfLevelHighThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigRfLevelHighThreshold.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigRfLevelHighThreshold.setDescription('The threshold delta relative to the configured RF level that will\n         indicate an RF High condition. The measured output must rise this\n         amount for RF High condition.\n\n         Range is 0 to 100 representing 0 to 10 dB in 0.1 dB steps.\n        ')
apexQamRfConfigMute = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unmute", 1), ("mute", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigMute.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigMute.setDescription('Mute the RF Port.  This will mute all QAM channels enabled on the\n         RF Port.\n        ')
apexQamRfConfigInterleaverDepth1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("i64-j2", 1), ("i32-j4", 2), ("i16-j8", 3), ("i8-j16", 4), ("i128-j1", 5), ("i128-j2", 6), ("i128-j3", 7), ("i128-j4", 8), ("i128-j5", 9), ("i128-j6", 10), ("i128-j7", 11), ("i128-j8", 12), ("i12-j17", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigInterleaverDepth1.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigInterleaverDepth1.setDescription("The first of two Interleaver settings that can be assigned to the\n         QAM Channels of this RF Port.\n\n         Configurable only for Transmission Mode 'annexB-ATSC-DCII'.\n\n         Values 1 to 12 used only for Transmission Mode 'annexB-ATSC-DCII'.\n\n         Value 13 (i12-j17) used only for Transmission Modes 'annexA-DVB'\n         and 'annexC-Asia-Pacific' and is set by the APEX.\n        ")
apexQamRfConfigInterleaverDepth2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("i64-j2", 1), ("i32-j4", 2), ("i16-j8", 3), ("i8-j16", 4), ("i128-j1", 5), ("i128-j2", 6), ("i128-j3", 7), ("i128-j4", 8), ("i128-j5", 9), ("i128-j6", 10), ("i128-j7", 11), ("i128-j8", 12), ("i12-j17", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfConfigInterleaverDepth2.setStatus('current')
if mibBuilder.loadTexts: apexQamRfConfigInterleaverDepth2.setDescription("The second of two Interleaver settings that can be assigned to the\n         QAM Channels of this RF Port.\n\n         Configurable only for Transmission Mode 'annexB-ATSC-DCII'.\n\n         Values 1 to 12 used only for Transmission Mode 'annexB-ATSC-DCII'.\n\n         Value 13 (i12-j17) used only for Transmission Modes 'annexA-DVB'\n         and 'annexC-Asia-Pacific' and is set by the APEX.\n        ")
apexQamChannelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 5), )
if mibBuilder.loadTexts: apexQamChannelConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigTable.setDescription("Table of configuration items configurable on a QAM Channel basis.\n\n         There are 48 Output Transport Streams (OTS) on an APEX1000. There can\n         be up to 48 QAM Channels on an APEX1000 depending on how the 3 QAM slots\n         are populated.  There is a one-to-one mapping between QAM Channels and\n         Output Transport Streams.\n         \n         QAM Channel (OTS) ranges are mapped to QAM slots as follows:\n         \n               Slot      Channels\n                1          1..15\n                2         15..32\n                3         33..48\n\n         There can be either 4 or 8 QAM channels (OTS) on each RF Port.  The slot\n         and RF Port to QAM Channel (OTS) mappings for each QAM Module type are\n         shown below.\n         \n         For a 2x4 or 2x8 QAM Module, QAM Channels (OTS) are mapped to\n         RF Ports in a QAM Slot and table rows as follows:\n         \n                                    QAM Channel\n                         RF Port      and OTS\n            Slot/Port   Table Row   Table Rows\n                1/1         1          1..8\n                1/2         2          9..16\n                2/1         5         17..24\n                2/2         6         25..32\n                3/1         9         33..40\n                3/2        10         41..48\n\n         If a 2x4 QAM Module is in a slot, only the first four rows in this\n         table for the slot/port are to be used.  For example, if there is\n         a 2x4 module in slot 3, rows 8..12 are to be used for configuring\n         the QAM Channels of RF Port 1 on the module.\n         \n         For a 4x4 QAM Module, QAM Channels (OTS) are mapped to RF Ports in\n         a QAM Slot and table rows as follows:\n         \n                                    QAM Channel\n                         RF Port      and OTS\n            Slot/Port   Table Row   Table Rows\n                1/1         1          1..4\n                1/2         2          5..8\n                1/3         7          9..12\n                1/4         8         13..16\n                2/1         3         17..20\n                2/2         4         21..24\n                2/3         9         25..28\n                2/4         10        29..32\n                3/1         5         33..36\n                3/2         6         37..40\n                3/3         11        41..44\n                3/4         12        45..48\n         \n         Note that the QAM Channels on an RF Port are designated with the\n         letters 'A'..'H' on the APEX Element Manager.\n         \n         Refer to the description of apexQamChannelConfigTable for information\n         on QAM Channel to RF Port mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n         \n         Once written, the change to this table will only take immediate\n         effect after apexQamConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamChannelConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamChannelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexQamChanConfigChannelNum"))
if mibBuilder.loadTexts: apexQamChannelConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigEntry.setDescription('QAM Channel Configuration Table Entry.')
apexQamChanConfigChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexQamChanConfigChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChanConfigChannelNum.setDescription('The QAM RF Port number.')
apexQamChanConfigInterleaverSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("interleaverDepth1", 1), ("interleaverDepth2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamChanConfigInterleaverSelect.setStatus('current')
if mibBuilder.loadTexts: apexQamChanConfigInterleaverSelect.setDescription('The interleaver selection for this Channel.\n\n         Will use either apexQamRfConfigInterleaverDepth1\n         or apexQamRfConfigInterleaverDepth2.\n        ')
apexQamChanConfigTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("off", 0), ("cwtest", 2), ("prbs23m", 3), ("prbs23", 5), ("mpegNull", 6), ("suppress", 9), ("prbs60", 10), ("prbs63", 11), ("prbs65", 12), ("prbs68", 13), ("prbs71", 14), ("prbs73", 15), ("prbs79", 16), ("prbs81", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamChanConfigTestMode.setStatus('current')
if mibBuilder.loadTexts: apexQamChanConfigTestMode.setDescription("Test mode setting for the QAM Channel.\n\n         Setting to other than 'off' will cause a service interruption.\n        ")
apexQamRfRedundConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigApplyChange.setDescription("The Apply for QAM RF Redundancy Configuration parameters.\n         This parameter MUST be set to 'apply' in order for the data\n         to take effect.\n         \n         This parameter MUST be set LAST after all QAM RF Redundancy\n         parameters affected by this parameter have been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexQamRfRedundConfigEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigEnable.setDescription("Enables RF redundancy mode, allowing the APEX to failover to backup\n         RF port and communicate with the REM1000.  Allows for failover/\n         switching without requiring a REM1000 connection.\n\n         Cannot be 'enabled' if the backup port (RF Port 6)\n         is not present (there is no QAM Module in QAM slot 3).\n\n         Cannot be 'enabled' if there are any mappings to any QAM Channel\n         on the backup port.  RF Port 6, QAM Channels 6A to 6H\n         (Output Transport Streams 41 to 48).\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfRedundConfigRemConnection = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("direct", 1), ("common", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigRemConnection.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigRemConnection.setDescription("Configures how the APEX is connected to the REM1000.\n\n         'none'   - Not connecting to REM1000.\n         'direct' - Connected to REM1000 dedicated IP interface through\n                    APEX Data IP (Enet2).  Broadcast connection is always\n                    used in this case.  Cannot be set to 'direct' if the\n                    QAM RF Redundancy UDP Port is in use on the Data IP Port\n                    (Enet2).  QAM RF Redundancy UDP Port value is found in\n                    apexQamRfRedundStatusUdpPort.\n         'common' - Connected to REM1000 OAM&P interface through APEX OAM&P IP\n                    (Enet 1).  Requires user to configure REM1000 IP address\n                    in apexQamRfRedundConfigRemCommonIpAddr.  Cannot be set to\n                    'common' if the QAM RF Redundancy UDP Port is in use on the\n                    OAM&P IP (Enet 1).  QAM RF Redundancy UDP Port value is\n                    found in apexQamRfRedundStatusUdpPort.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfRedundConfigApexId = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigApexId.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigApexId.setDescription("Identifies which set of RF inputs on the REM1000 are associated\n         with this APEX.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfRedundConfigRemCommonIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigRemCommonIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigRemCommonIpAddr.setDescription("Target REM1000 IP address. Must be singlecast address.\n         Only used when apexQamRfRedundConfigRemConnection is set to 'common'.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfRedundConfigAutoSwitchBack = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 6), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigAutoSwitchBack.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigAutoSwitchBack.setDescription("This is the enable/disable of automatic switch back to the previous\n         RF port from backup for QAM RF redundancy.  When 'enabled',\n         switch back to the previous RF port will automatically occur when\n         the RF port comes back online.  When 'disabled', the user must force\n         back to the previous RF port using apexQamRfRedundConfigForceSwitch.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')")
apexQamRfRedundConfigSuspendFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 7), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigSuspendFailover.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigSuspendFailover.setDescription("Enables and disables suspending of RF failover. Prevents failovers\n         to or from backup.  Force failover (apexQamRfRedundConfigForceSwitch)\n         overrides this setting.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamRfRedundConfigForceSwitch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("switchNotInProgress", 0), ("forceFrom1", 1), ("forceFrom2", 2), ("forceFrom3", 3), ("forceFrom4", 4), ("forceFrom5", 5), ("forceFromBackup", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigForceSwitch.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigForceSwitch.setDescription("Force a switch of an RF Port to or from the backup.\n         Selects which RF Port to switch from.  Overrides Suspend Failover\n         (apexQamRfRedundConfigSuspendFailover).\n\n         Parameter is ignored when:\n          - apexQamRfRedundConfigEnable is 'disabled'.\n          - backup is active and other than 'forceFromBackup' is selected.\n          - backup is not active and 'forceFromBackup' is selected.\n\n         'forceFromBackup' will force back to the failed primary indicated\n         in apexQamRfRedundStatusFailedPort.\n\n         APEX sets back to 'switchNotInProgress' when complete.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexQamRfRedundConfigRemDirectIpOctet1 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 126))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamRfRedundConfigRemDirectIpOctet1.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundConfigRemDirectIpOctet1.setDescription("Target REM1000 IP address first octet.\n         Only used when apexQamRfRedundConfigRemConnection is set to 'direct'.\n         The remainder of the IP address will be filled in by the APEX.\n         The IP address used will be reflected in apexDataIpAddrInUse.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexQamRfRedundConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexQamRfRedundConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexQamChannelConfigApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 7), )
if mibBuilder.loadTexts: apexQamChannelConfigApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigApplyTable.setDescription('Table of Apply Change for the data for apexQamChannelConfigTable.\n        ')
apexQamChannelConfigApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 7, 1), ).setIndexNames((0, "APEX-MIB", "apexQamChannelConfigApplyChannelNum"))
if mibBuilder.loadTexts: apexQamChannelConfigApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigApplyEntry.setDescription('QAM Channel Configuration Apply Table Entry.')
apexQamChannelConfigApplyChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexQamChannelConfigApplyChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigApplyChannelNum.setDescription('The QAM Channel number.')
apexQamChannelConfigApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 1, 7, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQamChannelConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelConfigApplyChange.setDescription("The Apply for a row of data in apexQamChannelConfigTable.\n\n         A row in this table corresponds to the same row index in the\n         apexQamChannelConfigTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the rows to take effect in the APEX.  This parameter MUST be set\n         LAST after all other data in the configuration table rows has been\n         configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexQamStatusTransmissionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("annexB-ATSC-DCII", 1), ("annexA-DVB", 2), ("annexC-Asia-Pacific", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamStatusTransmissionMode.setStatus('current')
if mibBuilder.loadTexts: apexQamStatusTransmissionMode.setDescription('This is the QAM Transmission Mode that is currently in use.\n         QAM Transmission Mode is defined in:\n         Series J: Transmission of Television, Sound Programme\n         and other Multimedia Signals, ITU-T J.83.\n        ')
apexQamModuleInstalledCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleInstalledCount.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleInstalledCount.setDescription('Number of hot swappable QAM Modules currently installed.')
apexFanModuleInstalledCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexFanModuleInstalledCount.setStatus('current')
if mibBuilder.loadTexts: apexFanModuleInstalledCount.setDescription('Number of Fan-Only Modules currently installed in QAM\n         Module slots.')
apexQamChannelsActiveCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelsActiveCount.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelsActiveCount.setDescription('Number of QAM Channels that are present (QAM Module installed)\n         and enabled for use.')
apexQamModuleStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2), )
if mibBuilder.loadTexts: apexQamModuleStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatusTable.setDescription('Table of QAM Module Status.\n        \n         Refer to the descriptions of apexQamRfConfigTable and\n         apexQamChannelConfigTable for information on QAM slot,\n         RF Port mapping, and QAM Channel mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n        ')
apexQamModuleStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexQamModuleStatQamModuleNum"))
if mibBuilder.loadTexts: apexQamModuleStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatusEntry.setDescription('QAM Module Status Table Entry.')
apexQamModuleStatQamModuleNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: apexQamModuleStatQamModuleNum.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatQamModuleNum.setDescription('QAM Module slot number.  ')
apexQamModuleStatInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("qam2x4Channel", 2), ("qam2x8Channel", 3), ("fanModule", 4), ("unsupported", 5), ("removed", 6), ("qamDiscovery", 7), ("qam4x4Channel", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatInstalled.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatInstalled.setDescription('Indicates if a module is installed and what type.\n\n         notApplicable - When APEX does not boot properly.\n         notInstalled  - No QAM or Fan Module detected in slot. Reported\n                         in apexAlarmQamModuleFault.\n         qam2x4Channel - A 2x4 Channel QAM Module installed.\n         qam2x8Channel - A 2x8 Channel QAM Module installed.\n         fanModule     - A Fan Module installed.\n         unsupported   - Unknown module installed.  Reported in\n                         apexAlarmQamModuleFault.\n         removed       - A QAM Module removed when there are active QAM\n                         channels.  Reported in apexAlarmQamModuleFault.\n         qamDiscovery  - A QAM Module is present and type is being determined.\n         qam4x4Channel - A 4x4 Channel QAM Module is installed.\n        ')
apexQamModuleStatFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatFanSpeed.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatFanSpeed.setDescription('The fan speed in RPM for installed QAM or Fan Module.\n\n         Zero if not installed.\n        ')
apexQamModuleStatFanFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatFanFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatFanFault.setDescription('Fan Fault.\n\n         This fault is reported in apexAlarmFanFault\n         not apexAlarmQamModuleFault.\n        ')
apexQamModuleStatTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatTemperature.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatTemperature.setDescription('Temperature at sensor near the fan of the QAM Module or\n         Fan Module in degrees Celsius.\n        ')
apexQamModuleStatTemperatureFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatTemperatureFault.setDescription('Temperature fault.\n\n         This fault is reported in apexAlarmTemperatureFault\n         not apexAlarmQamModuleFault.\n        ')
apexQamModuleStatError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("removed", 2), ("unsupported", 3), ("notInstalled", 4), ("powerFault", 5), ("offline", 6), ("dc5VoltError", 7), ("dc3-3VoltError", 8), ("commLost", 9), ("codeVersions", 10), ("codeDownload", 11), ("codeDownloadError", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatError.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatError.setDescription('Summary of errors reported on an QAM Module basis.\n         \n         These errors are reported in apexAlarmQamModuleFault.\n\n         ok                - No errors.\n         removed           - Reflects apexQamModuleStatInstalled.\n         unsupported       - Reflects apexQamModuleStatInstalled.\n         notInstalled      - Reflects apexQamModuleStatInstalled.\n         powerFault        - Reflects apexQamModuleStatPowerFault.\n         offline           - Indicates the QAM Module and the RF Ports on it are\n                             being brought to operational mode after module is\n                             inserted or the module has recovered from a power\n                             fault.\n         dc5VoltError      - 5 Vdc error, see also apexQamModuleStat5VdcSupply\n                             and apexQamModuleStat5VdcFault.\n         dc3-3VoltError    - 3.3 Vdc error, see also\n                             apexQamModuleStat3dot3VdcSupply and\n                             apexQamModuleStat3dot3VdcFault.\n         commLost          - Communication Lost, see also\n                             apexQamModuleStatCommError.\n         codeVersions      - Incorrect Code Versions on module, see also\n                             apexQamModuleStatCodeInitError,\n                             apexQamQrmRevisionTable, and\n                             apexQamQrmRevisionStatusTable.\n         codeDownload      - Code Download In Progress, see also\n                             apexQrmDownloadStatusTable.\n         codeDownloadError - Code Download Error, see also\n                             apexQrmDownloadStatusTable.\n        ')
apexQamModuleStatFaultCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatFaultCondition.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatFaultCondition.setDescription('Current fault condition of the QAM Module errors.\n         Reflects apexAlarmQamModuleFault for this QAM Module.\n        ')
apexQamModuleStatFaultSumm = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatFaultSumm.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatFaultSumm.setDescription('Roll-up of QAM RF Port and QAM Channel fault conditions\n         for this QAM Module.\n        ')
apexQamModuleStatPowerFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("lowVoltageMainboard", 2), ("lowVoltageQamModule", 3), ("overCurrent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatPowerFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatPowerFault.setDescription('Power fault.\n\n         notApplicable       - No module installed.\n         ok                  - Power good.\n         lowVoltageMainboard - Low voltage detected on Mainboard side of\n                               connector.\n         lowVoltageQamModule - Low voltage detected on QAM Module side of\n                               connector.\n         overCurrent         - Over current detected on QAM Module.\n\n         This fault is reported in apexAlarmQamModuleFault.\n        ')
apexQamModuleStatBoardTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatBoardTemperature.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatBoardTemperature.setDescription("Temperature of the 4x4 QAM module board ('plate' temp) in degrees Celsius.\n         \n         Used only for 4x4 QAM Modules.\n        ")
apexQamModuleStatBoardTemperatureFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatBoardTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatBoardTemperatureFault.setDescription("Board temperature fault of the 4x4 QAM module board ('plate' temp).\n         \n         Used only for 4x4 QAM Modules.\n         \n         This fault is reported in apexAlarmTemperatureFault\n         not apexAlarmQamModuleFault.\n        ")
apexQamModuleStat5VdcSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStat5VdcSupply.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStat5VdcSupply.setDescription('Measured level of the +5 VDC supply input of the 4x4 QAM module board.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Range is 0 to 1000 representing 0 to 10 Volts in 0.01 Volt steps.\n        ')
apexQamModuleStat5VdcFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("low", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStat5VdcFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStat5VdcFault.setDescription('The +5 VDC supply fault of the 4x4 QAM module board.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Indicates there is a problem with the direct 5 VDC supply or any internal\n         module supply derived from the 5 VDC supply.\n         \n         Indicates voltage problem that can impair module function.\n        ')
apexQamModuleStat3dot3VdcSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStat3dot3VdcSupply.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStat3dot3VdcSupply.setDescription('Measured level of the +3.3 VDC supply input of the 4x4 QAM module board.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Range is 0 to 1000 representing 0 to 10 Volts in 0.01 Volt steps.\n        ')
apexQamModuleStat3dot3VdcFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("low", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStat3dot3VdcFault.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStat3dot3VdcFault.setDescription('The +3.3 VDC supply fault of the 4x4 QAM module board.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Indicates there is a problem with the direct 3.3 VDC supply or any internal\n         module supply derived from the 3.3 VDC supply.\n         \n         Indicates voltage problem that can impair module function.\n        ')
apexQamModuleStatCommError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("inComm", 1), ("commLost", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatCommError.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatCommError.setDescription('Communication with the 4x4 QAM Module has failed.\n         \n         Used only for 4x4 QAM Modules.\n        ')
apexQamModuleStatCodeInitError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleStatCodeInitError.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleStatCodeInitError.setDescription('Code initialization error of the 4x4 QAM Module.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Indicates a code, firmware, or FPGA startup issue.\n         \n         The module failed to load the FW/FPGA files to the devices or valid\n         FW/FPGA files could not be found in the module.\n         \n         Code download is required to restore the module.\n        ')
apexQamModuleSerialNumTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 3), )
if mibBuilder.loadTexts: apexQamModuleSerialNumTable.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleSerialNumTable.setDescription('Table of QAM Module Serial Numbers.\n        ')
apexQamModuleSerialNumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexQamModuleSerialNumQamModuleNum"))
if mibBuilder.loadTexts: apexQamModuleSerialNumEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleSerialNumEntry.setDescription('QAM Module Serial Number Table Entry.')
apexQamModuleSerialNumQamModuleNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: apexQamModuleSerialNumQamModuleNum.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleSerialNumQamModuleNum.setDescription('QAM Module slot number.')
apexQamModuleSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamModuleSerialNumber.setStatus('current')
if mibBuilder.loadTexts: apexQamModuleSerialNumber.setDescription('The serial number of an installed QAM Module.\n\n         Zero if not installed.')
apexQamQrmRevisionTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4), )
if mibBuilder.loadTexts: apexQamQrmRevisionTable.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevisionTable.setDescription('Table of QAM Module hardware and software revisions.\n         \n         There are 2 QRM modules on each 2x4/2x8 QAM Module.\n         QRMs in QAM Module slots are mapped to table rows as follows:\n         \n             Slot/QRM   Table Row\n                1/1         1\n                1/2         2\n                2/1         3\n                2/2         4\n                3/1         5\n                3/2         6\n         \n         4x4 QAM Modules do not use QRM boards.  There is only one\n         board.  These will be found in the odd indexed rows of this\n         table.  The even indexed rows of the table are not used for\n         4x4 QAM Modules.  4x4 QAM Modules in QAM Module slots are\n         mapped to table rows as follows:\n         \n               Slot     Table Row\n                 1          1\n                 2          3\n                 3          5\n        ')
apexQamQrmRevisionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexQamQrmRevRfPortNum"))
if mibBuilder.loadTexts: apexQamQrmRevisionEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevisionEntry.setDescription('QAM Module Revision Table Entry.')
apexQamQrmRevRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexQamQrmRevRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevRfPortNum.setDescription('QAM Module Revision Table index.')
apexQamQrmRevBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevBoardId.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevBoardId.setDescription("Model ID of the 4x4 QAM Module or the 2x4/2x8 QAM Module's QRM board.\n         Hex XXYY.")
apexQamQrmRevAppFw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevAppFw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevAppFw.setDescription("Application firmware version of the 4x4 QAM Module or the 2x4/2x8 QAM\n         Module's QRM board.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        'FFFF' indicates no valid application code is present.")
apexQamQrmRevBootLoaderFw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevBootLoaderFw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevBootLoaderFw.setDescription("Boot loader firmware version of the 4x4 QAM Module or the 2x4/2x8 QAM\n         Module's QRM board.\n         \n         Hex XXYY where XX is major version and YY is minor version.")
apexQamQrmRevFpga = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevFpga.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevFpga.setDescription("FPGA version of the 2x4/2x8 QAM Module's QRM board or\n         FPGA1 version of the 4x4 QAM Module.\n         \n         Hex XXYY where XX is major version and YY is minor version.")
apexQamQrmRevHw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevHw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevHw.setDescription("Hardware version of the 4x4 QAM Module or the 2x4/2x8 QAM Module's QRM\n         board.\n         \n         Hex XXYY where XX is major version and YY is minor version.")
apexQamQrmRevSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevSerialNumber.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevSerialNumber.setDescription("The serial number of the 2x4/2x8 QAM Module's QRM board.\n         \n         Used only for 2x4/2x8 QAM Modules.\n         Zero if not installed.")
apexQamQrmRevFpga2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 4, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevFpga2.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevFpga2.setDescription('FPGA2 version of the 4x4 QAM Module.\n         \n         Used only for 4x4 QAM Modules.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        ')
apexQamRfPortStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5), )
if mibBuilder.loadTexts: apexQamRfPortStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatusTable.setDescription('Table of QAM RF Port Status.\n        \n         Refer to the descriptions of apexQamRfConfigTable and\n         apexQamChannelConfigTable for information on QAM slot,\n         RF Port mapping, and QAM Channel mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n        ')
apexQamRfPortStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexQamRfPortStatRfPortNum"))
if mibBuilder.loadTexts: apexQamRfPortStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatusEntry.setDescription('QAM RF Port Status Table Entry.')
apexQamRfPortStatRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexQamRfPortStatRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatRfPortNum.setDescription('RF Port number.')
apexQamRfPortStatInfoRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatInfoRate.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatInfoRate.setDescription('The information rate of the QAM channels on this RF Port\n         in bits per second.')
apexQamRfPortStatNumChannelsActive = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatNumChannelsActive.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatNumChannelsActive.setDescription('Number of QAM Channels that are present (QAM Module installed)\n         and enabled for use on this RF Port.')
apexQamRfPortStatOutputLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatOutputLevel.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatOutputLevel.setDescription('Measured per channel RF Output Level.\n         Range is 0 to 8000 representing 0 to 80 dBmV in 0.01 dBmV steps.')
apexQamRfPortStatOutputLevelFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("low", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatOutputLevelFault.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatOutputLevelFault.setDescription('RF Output Level fault.  Indicates if the user configured\n         apexQamRfConfigRfLevelLowThreshold or\n         apexQamRfConfigRfLevelHighThreshold has been reached.')
apexQamRfPortStatTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatTemperature.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatTemperature.setDescription("Temperature of the 2x4/2x8 QAM Module's QRM board ('plate' temp)\n         in degrees Celsius.\n         \n         Used only for 2x4/2x8 QAM Modules.\n        ")
apexQamRfPortStatTemperatureFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("overTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatTemperatureFault.setDescription("Temperature fault of the 2x4/2x8 QAM Module's QRM board ('plate' temp).\n         \n         Used only for 2x4/2x8 QAM Modules.\n         \n         This fault is reported in apexAlarmTemperatureFault\n         not apexAlarmQamRfPortFault.")
apexQamRfPortStat5VdcSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStat5VdcSupply.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStat5VdcSupply.setDescription("Measured level of the +5 VDC supply input of the 2x4/2x8 QAM Module's\n         QRM board.\n         \n         Used only for 2x4/2x8 QAM Modules.\n         \n         Range is 0 to 1000 representing 0 to 10 Volts in 0.01 Volt steps.")
apexQamRfPortStat5VdcFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("low", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStat5VdcFault.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStat5VdcFault.setDescription("The +5 VDC supply fault of the 2x4/2x8 QAM Module's QRM board.\n         \n         Used only for 2x4/2x8 QAM Modules.\n         \n         Indicates voltage problem that can impair QRM function.")
apexQamRfPortStat3dot3VdcSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStat3dot3VdcSupply.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStat3dot3VdcSupply.setDescription("Measured level of the +3.3 VDC supply input of the 2x4/2x8 QAM Module's QRM board.\n         \n         Used only for 2x4/2x8 QAM Modules.\n         \n         Range is 0 to 1000 representing 0 to 10 Volts in 0.01 Volt steps.")
apexQamRfPortStat3dot3VdcFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("low", 2), ("high", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStat3dot3VdcFault.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStat3dot3VdcFault.setDescription("The +3.3 VDC supply fault of the 2x4/2x8 QAM Module's QRM board.\n         \n         Used only for 2x4/2x8 QAM Modules.\n         \n         Indicates voltage problem that can impair QRM function.")
apexQamRfPortStatFreqPllLock = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("locked", 1), ("notLocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatFreqPllLock.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatFreqPllLock.setDescription('Frequency tuning PLL lock status.')
apexQamRfPortStatRefClockPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("present", 1), ("notPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatRefClockPresent.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatRefClockPresent.setDescription('External reference clock present indication.')
apexQamRfPortStatRefClockLock = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("locked", 1), ("notLocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatRefClockLock.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatRefClockLock.setDescription('Board not phase-locked to the External reference clock.\n        ')
apexQamRfPortStatDataClockPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("present", 1), ("notPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatDataClockPresent.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatDataClockPresent.setDescription('Data clock present indication.')
apexQamRfPortStatDataSyncFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("inSync", 1), ("syncLost", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatDataSyncFault.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatDataSyncFault.setDescription('One or more of the QAM Channel data interfaces is not synchronized.')
apexQamRfPortStatCommError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("inComm", 1), ("commLost", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatCommError.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatCommError.setDescription("Communication with the 2x4/2x8 QAM Module's QRM board has failed.\n        ")
apexQamRfPortStatError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("outputRfLevel", 2), ("dc5VoltError", 3), ("dc3-3VoltError", 4), ("freqPllNotLocked", 5), ("extClkNotPresent", 6), ("extClkNotLocked", 7), ("dataClkNotPresent", 8), ("dataSyncLost", 9), ("commLost", 10), ("unsupportedQrm", 11), ("configFailed", 12), ("codeVersions", 13), ("codeDownload", 14), ("codeDownloadError", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatError.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatError.setDescription("Error status on an RF Port basis.\n\n         These errors are reported in apexAlarmQamRfPortFault.\n\n         'major' for:\n            'outputRfLevel', 'dc5VoltError', 'dc3-3VoltError'.\n\n         'critical' for:\n            'freqPllNotLocked', 'extClkNotPresent', 'extClkNotLocked',\n            'dataClkNotPresent', 'dataSyncLost', 'commLost', 'codeVersions',\n            'codeDownload', 'codeDownloadError', 'unsupportedQrm', or\n            'configFailed'.\n\n         outputRfLevel     - RF Output Level error, see also\n                             apexQamRfPortStatOutputLevel and\n                             apexQamRfPortStatOutputLevelFault.\n         dc5VoltError      - 5 Vdc error, see also apexQamRfPortStat5VdcSupply\n                             and apexQamRfPortStat5VdcFault.\n         dc3-3VoltError    - 3.3 Vdc error, see also\n                             apexQamRfPortStat3dot3VdcSupply and\n                             apexQamRfPortStat3dot3VdcFault.\n         freqPllNotLocked  - Frequency PLL not locked, see also\n                             apexQamRfPortStatFreqPllLock.\n         extClkNotPresent  - External Reference Clock Not Present, see also\n                             apexQamRfPortStatRefClockPresent.\n         extClkNotLocked   - Not Locked to External Reference Clock, see also\n                             apexQamRfPortStatRefClockLock.\n         dataClkNotPresent - Data Clock Not Present, see also\n                             apexQamRfPortStatDataClockPresent.\n         dataSyncLost      - Data Synchronization Lost, see also\n                             apexQamRfPortStatDataSyncFault.\n         commLost          - Communication Lost, see also\n                             apexQamRfPortStatCommError.\n         unsupportedQrm    - QRM Revision Not Supported, see also\n                             apexQamQrmRevisionTable and\n                             apexQamQrmRevisionStatusTable.\n         configFailed      - RF Port Configuration Failed.\n         codeVersions      - Incorrect Code Versions on QRM, see also\n                             apexQamRfPortStatCodeInitError,\n                             apexQamQrmRevisionTable, and\n                             apexQamQrmRevisionStatusTable.\n         codeDownload      - Code Download In Progress, see also\n                             apexQrmDownloadStatusTable.\n         codeDownloadError - Code Download Error, see also\n                             apexQrmDownloadStatusTable.\n        ")
apexQamRfPortStatFaultCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatFaultCondition.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatFaultCondition.setDescription('Current fault condition of the RF Port errors.\n         Reflects apexAlarmQamRfPortFault for this RF Port.\n        ')
apexQamRfPortStatChanFaultSumm = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatChanFaultSumm.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatChanFaultSumm.setDescription('Roll-up of Channel fault conditions for this RF Port.')
apexQamRfPortStatCodeInitError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("fpgaInitError", 2), ("calDataError", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortStatCodeInitError.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortStatCodeInitError.setDescription("Code initialization error of the 2x4/2x8 QAM Module's QRM board.\n         \n         Indicates a code, firmware, or FPGA startup issue.\n         \n         'fpgaInitError' - FPGA not loaded.  Caused by incompatible code\n                           images or corrupted FPGA image on the QRM.\n         \n         'calDataError'  - Working copy of calibration data was corrupted\n                           and needs to be restored by code download process.\n                           Caused by interruption of previous code download\n                           process.\n        ")
apexQamChannelStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6), )
if mibBuilder.loadTexts: apexQamChannelStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelStatusTable.setDescription('Table of QAM Channel Status.\n        \n         Refer to the descriptions of apexQamRfConfigTable and\n         apexQamChannelConfigTable for information on QAM slot,\n         RF Port mapping, and QAM Channel mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n        ')
apexQamChannelStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexQamChanStatChannelNum"))
if mibBuilder.loadTexts: apexQamChannelStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelStatusEntry.setDescription('QAM Channel Status Table Entry.')
apexQamChanStatChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexQamChanStatChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatChannelNum.setDescription('QAM Channel number.')
apexQamChanStatActive = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 2), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatActive.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatActive.setDescription("'active' indicates that mappings can be made to the channel.\n         This means that either:\n          1) The channel is present (apexQamModuleStatInstalled\n             'qam2x4Channel' or 'qam2x8Channel') and enabled for use\n             (apexQamRfConfigNumChannelsEnabled);\n          2) Or, the channel is on the backup RF port when QAM RF Redundancy\n             is enabled (apexQamRfRedundConfigEnable).\n        ")
apexQamChanStatRfFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatRfFreq.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatRfFreq.setDescription('The center frequency for the QAM Channel in Hz.')
apexQamChanStatEiaChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatEiaChanNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatEiaChanNum.setDescription('The EIA Channel number for the QAM Channel.\n         Will be zero if there is no EIA Channel number\n         corresponding to the frequency in use.')
apexQamChanStatDataPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("data", 1), ("noData", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatDataPresent.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatDataPresent.setDescription('Indication of MPEG data activity on the interface for this QAM channel.\n         This includes MPEG null packets.')
apexQamChanStatError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("noData", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatError.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatError.setDescription('Summary of errors reported on a QAM channel.\n\n         This is enumerated and the reported error will be the\n         most severe.\n        ')
apexQamChanStatFaultCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChanStatFaultCondition.setStatus('current')
if mibBuilder.loadTexts: apexQamChanStatFaultCondition.setDescription('Current fault condition of the QAM channel errors.\n         Reflects apexAlarmQamChannelFault for this QAM Channel.\n        ')
apexQamRfRedundStatusBackupPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("standby", 1), ("active", 2), ("failed", 3), ("removed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusBackupPort.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusBackupPort.setDescription("State of configured backup port.\n         'disabled' - QAM RF Redundancy is disabled.\n         'standby'  - QAM RF Redundancy is enabled but backup is inactive.\n                      No failure has occurred.\n         'active'   - Failover has occurred and backup is active.\n                      Refer to apexQamRfRedundStatusFailedPort for port being\n                      backed up.\n         'failed'   - Backup port has failed.  APEX cannot provide RF\n                      redundancy.\n         'removed'  - QAM Module with Backup port has been removed.\n                      APEX cannot provide RF redundancy.\n        ")
apexQamRfRedundStatusFailedPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusFailedPort.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusFailedPort.setDescription('Indicates which port (1 to 5) has failed over to the backup port.\n         Zero indicates backup port is not active.\n        ')
apexQamRfRedundStatusMismatch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("noMismatch", 1), ("backup2x4", 2), ("primary2x4", 3), ("any4x4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusMismatch.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusMismatch.setDescription("Indicates whether there is a potential for channels being lost\n         when failing to the backup or when switching back to a primary due\n         to a mixture of 2x4 and 2x8 QAM Modules.  Indicates whether RF\n         redundancy is unavailable due to a 4x4 QAM Module installed.\n\n         A 2x4 QAM Module is capable of supporting a maximum of 4 channels\n         per RF port.  A 2x8 QAM Module is capable of supporting a maximum\n         of 8 channels per RF port.  The number of channels enabled\n         (apexQamRfConfigNumChannelsEnabled) is not considered.\n\n         'notApplicable' - QAM RF Redundancy is disabled.\n         'noMismatch'    - Indicates no channels would be lost because there is\n                           no mismatch.\n         'backup2x4'     - Indicates a loss of channels could occur on failover\n                           to the backup because the backup RF Port is in a 2x4\n                           module and at least one primary RF Port is in a 2x8\n                           module.\n         'primary2x4'    - Indicates a loss of channels could occur on switch-\n                           back from the backup to the primary because the\n                           backup RF Port is in a 2x8 module and the primary RF\n                           Port is in a 2x4 module.  This would occur if the\n                           failed 2x8 primary is replaced with a 2x4.\n         'any4x4'        - Indicates a 4x4 QAM Module is installed in any slot\n                           and RF Redundancy is not available.  Failover and/or\n                           switchback are suspended until the 4x4 is replaced.\n        ")
apexQamRfRedundStatusUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusUdpPort.setDescription("UDP Port that is used for QAM RF Redundancy communication between\n         the APEX and REM.\n\n         When apexQamRfRedundConfigRemConnection is:\n         'direct' - APEX sends/receives broadcast on this UDP Port.\n         'common' - APEX sends/receives singlecast on this UDP Port.\n        ")
apexQamRfRedundStatusRemConnection = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notConnected", 1), ("connected", 2), ("connectionLost", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusRemConnection.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusRemConnection.setDescription("State of communication with REM.\n         'notApplicable'  - QAM RF Redundancy is not enabled and/or the\n                            connection to the REM is not enabled.\n         'notConnected'   - Initial condition. APEX has not sent a\n                            switch_port() message yet.\n         'connected'      - received ack() message from REM for current\n                            switch_port() message.\n         'connectionLost' - REM has not replied to last 3 heartbeat\n                            switch_port() messages.\n        ")
apexQamRfRedundStatusRemError = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusRemError.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusRemError.setDescription("Status of REM1000 taken from error_code field in REM1000 ack()\n         response (defined in REM1000 Message Stream Protocol).\n\n         Valid only when apexQamRfRedundConfigRemConnection is other than 'none'.\n\n         Values as defined in REM1000 MSP:\n         0x00 - No Errors.  No problems switching, parsing switch_port()\n                message, or with HW.\n         0x01 - Invalid apex_id value in prior switch_port() message.\n         0x02 - Invalid msg_type value in prior switch_port() message.\n         0x03 - Invalid port value in prior switch_port() message.\n         0x04 - Error switching after receiving valid switch_port() message.\n         0x05 - Minor HW error.  REM can still switch.\n         0x81 - Apex_id Conflict.  Switch_port() messages with the same apex_id\n                have been received from multiple APEXs. Switch reset to pass-\n                through configuration.\n         0x85 - Major HW error.  REM failure.  Switch reset to pass-through\n                configuration.\n        ")
apexQamRfRedundStatusRemSwitch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusRemSwitch.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusRemSwitch.setDescription("Status of the REM1000 switches indicated through ack() response\n         from REM1000 (e.g. pass-through or switching port 'x').\n\n         Valid only when apexQamRfRedundConfigRemConnection is other than\n         'none'.\n\n         Zero indicates REM is in passing inputs 1 to 5 straight through to\n         outputs 1 to 5.\n\n         Values of 1 to 5 indicate REM backup input port is switched to\n         output port 1 to 5 and other ports are passed through.\n        ")
apexQamRfRedundStatusInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 7, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfRedundStatusInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexQamRfRedundStatusInvalidApplyText.setDescription("When apexQamRfRedundConfigApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexQamRfPortMuteStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 8), )
if mibBuilder.loadTexts: apexQamRfPortMuteStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortMuteStatusTable.setDescription('Table of QAM RF Port Mute Status.\n        ')
apexQamRfPortMuteStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 8, 1), ).setIndexNames((0, "APEX-MIB", "apexQamRfPortMuteStatusRfPortNum"))
if mibBuilder.loadTexts: apexQamRfPortMuteStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortMuteStatusEntry.setDescription('QAM RF Port Mute Status Table Entry.')
apexQamRfPortMuteStatusRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexQamRfPortMuteStatusRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortMuteStatusRfPortNum.setDescription('RF Port number.')
apexQamRfPortMuteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unmuted", 1), ("muted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortMuteStatus.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortMuteStatus.setDescription('Indicates whether the QAM channels on the RF port are muted or unmuted.\n        ')
apexQamQrmRevisionStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9), )
if mibBuilder.loadTexts: apexQamQrmRevisionStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevisionStatusTable.setDescription('Table of status of QRM hardware and software revisions.\n         Indications of whether they are supported, current, etc..\n         \n         There are 2 QRM modules on each 2x4/2x8 QAM Module.\n         QRMs in QAM Module slots are mapped to table rows as follows:\n         \n             Slot/QRM   Table Row\n                1/1         1\n                1/2         2\n                2/1         3\n                2/2         4\n                3/1         5\n                3/2         6\n         \n         4x4 QAM Modules do not use QRM boards.  There is only one\n         board.  These will be found in the odd indexed rows of this\n         table.  The even indexed rows of the table are not used for\n         4x4 QAM Modules.  4x4 QAM Modules in QAM Module slots are\n         mapped to table rows as follows:\n         \n               Slot     Table Row\n                 1          1\n                 2          3\n                 3          5\n        ')
apexQamQrmRevisionStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1), ).setIndexNames((0, "APEX-MIB", "apexQamQrmRevStatQrmNum"))
if mibBuilder.loadTexts: apexQamQrmRevisionStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevisionStatusEntry.setDescription('QRM Revision Status Table Entry')
apexQamQrmRevStatQrmNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexQamQrmRevStatQrmNum.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatQrmNum.setDescription('QRM Revision Status Table index.')
apexQamQrmRevStatBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatBoardId.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatBoardId.setDescription("Status of the Model ID of the 4x4 QAM Module or the\n         2x4/2x8 QAM Module's QRM board.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each QRM.\n        ")
apexQamQrmRevStatAppFw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("belowRelease", 2), ("atRelease", 3), ("aboveRelease", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatAppFw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatAppFw.setDescription("Status of Application firmware version of the 4x4\n         QAM Module or the 2x4/2x8 QAM Module's QRM board.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each 4x4 QAM Module or the 2x4/2x8 QAM Module's\n         QRM board.\n         \n         Refer to apexQrmFileRevisionTable for the revisions\n         of files in the APEX release resident on the device.\n        ")
apexQamQrmRevStatBootLoaderFw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatBootLoaderFw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatBootLoaderFw.setDescription("Status of Boot loader firmware version of the 4x4\n         QAM Module or the 2x4/2x8 QAM Module's QRM board.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each 4x4 QAM Module or the 2x4/2x8 QAM Module's\n         QRM board.\n        ")
apexQamQrmRevStatFpga = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("belowRelease", 2), ("atRelease", 3), ("aboveRelease", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatFpga.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatFpga.setDescription("Status of FPGA version of the 2x4/2x8 QAM Module's\n         QRM board or FPGA1 version of the 4x4 QAM Module.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each 4x4 QAM Module or the 2x4/2x8 QAM Module's\n         QRM board.\n         \n         Refer to apexQrmFileRevisionTable for the revisions\n         of files in the APEX release resident on the device.\n        ")
apexQamQrmRevStatHw = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatHw.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatHw.setDescription("Status of Hardware version of the 4x4 QAM Module or\n         the 2x4/2x8 QAM Module's QRM board.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each 4x4 QAM Module or the 2x4/2x8 QAM Module's\n         QRM board.\n        ")
apexQamQrmRevStatQrmSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatQrmSupported.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatQrmSupported.setDescription("Indicates if the 4x4 QAM Module or the 2x4/2x8 QAM Module's QRM\n         board is supported.  Summary of above status.\n         \n         If any 4x4 QAM Module or the 2x4/2x8 QAM Module's QRM board\n         revision status is 'notSupported' this parameter will indicate\n         'notSupported' and apexQamRfPortStatError will report\n         'unsupportedQrm'.\n        ")
apexQamQrmRevStatFpga2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("belowRelease", 2), ("atRelease", 3), ("aboveRelease", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamQrmRevStatFpga2.setStatus('current')
if mibBuilder.loadTexts: apexQamQrmRevStatFpga2.setDescription('Status of FPGA2 version of the 4x4 QAM Module.\n         \n         Refer to apexQamQrmRevisionTable for the revisions\n         of each 4x4 QAM Module.\n         \n         Refer to apexQrmFileRevisionTable for the revisions\n         of files in the APEX release resident on the device.\n        ')
apexQamRfPortChannelInfoTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 10), )
if mibBuilder.loadTexts: apexQamRfPortChannelInfoTable.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortChannelInfoTable.setDescription('Table of QAM Channel information for each QAM RF Port.\n        \n         Refer to the descriptions of apexQamRfConfigTable and\n         apexQamChannelConfigTable for information on QAM slot,\n         RF Port mapping, and QAM Channel mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n        ')
apexQamRfPortChannelInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 10, 1), ).setIndexNames((0, "APEX-MIB", "apexQamRfPortChannelInfoRfPortNum"))
if mibBuilder.loadTexts: apexQamRfPortChannelInfoEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortChannelInfoEntry.setDescription('QAM RF Port Channel Information Table Entry.')
apexQamRfPortChannelInfoRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexQamRfPortChannelInfoRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortChannelInfoRfPortNum.setDescription('RF Port number.')
apexQamRfPortChannelInfoChanA = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(5, 5), ValueRangeConstraint(9, 9), ValueRangeConstraint(13, 13), ValueRangeConstraint(17, 17), ValueRangeConstraint(21, 21), ValueRangeConstraint(25, 25), ValueRangeConstraint(29, 29), ValueRangeConstraint(33, 33), ValueRangeConstraint(37, 37), ValueRangeConstraint(41, 41), ValueRangeConstraint(45, 45), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortChannelInfoChanA.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortChannelInfoChanA.setDescription("QAM Channel number (Output Transport number) of QAM Channel\n         'A' on this RF port.\n         \n         This may be used to access data in tables indexed by QAM Number\n         or Output Transport Stream.  Used in combination with\n         apexQamRfPortChannelInfoChanCount, data for all QAM Channels\n         on this RF Port may be accessed.\n         \n         '0' - Indicates RF Port is not present.\n        ")
apexQamRfPortChannelInfoChanCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamRfPortChannelInfoChanCount.setStatus('current')
if mibBuilder.loadTexts: apexQamRfPortChannelInfoChanCount.setDescription("The number of QAM Channels on the RF port.\n         \n         '0' - Indicates RF Port is not present.\n         '4' - RF Port has 4 QAM Channels, 'A'-'D'.\n         '8' - RF Port has 8 QAM Channels, 'A'-'H'.\n        ")
apexQamChannelIdTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11), )
if mibBuilder.loadTexts: apexQamChannelIdTable.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdTable.setDescription('Table of QAM Channel Identification data.  Identifies\n         the physical location of the QAM Channel (Output Transport\n         Stream) in the APEX chassis.\n        \n         Refer to the descriptions of apexQamRfConfigTable and\n         apexQamChannelConfigTable for information on QAM slot,\n         RF Port mapping, and QAM Channel mapping.\n         \n         Tables apexQamRfPortChannelInfoTable and apexQamChannelIdTable can be\n         used to assist in referencing between QAM slots, RF Ports, and QAM\n         Channels (Output Transport Streams) for the installed modules.\n        ')
apexQamChannelIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1), ).setIndexNames((0, "APEX-MIB", "apexQamChannelIdChannelNum"))
if mibBuilder.loadTexts: apexQamChannelIdEntry.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdEntry.setDescription('QAM Channel Identification Table Entry.')
apexQamChannelIdChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexQamChannelIdChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdChannelNum.setDescription('QAM Channel number (Output Transport number).')
apexQamChannelIdSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelIdSlotNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdSlotNum.setDescription('QAM Slot number of the channel.\n        ')
apexQamChannelIdRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelIdRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdRfPortNum.setDescription("RF Port number of the channel.\n         \n         This may be used to access data in tables indexed by RF Port\n         Number.\n         \n         '0' - Indicates QAM Channel is not present.\n        ")
apexQamChannelIdModuleRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelIdModuleRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdModuleRfPortNum.setDescription("Module RF Port number of the channel.\n        \n         Corresponds to RF Port numbering on the back of\n         physical QAM Module.\n         \n         '0' - Indicates QAM Channel is not present.\n        ")
apexQamChannelIdChannelLetter = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelIdChannelLetter.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdChannelLetter.setDescription("The letter symbol ('A'..'H') for the channel.\n\n         String will be empty if QAM Channel not present.\n        ")
apexQamChannelIdChannelDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 2, 11, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQamChannelIdChannelDescription.setStatus('current')
if mibBuilder.loadTexts: apexQamChannelIdChannelDescription.setDescription("Text description for the QAM Channel (Output Transport Stream).\n         \n         Format is as follows where brackets and bracketed descriptions are\n         replaced by a number/letter as appropriate:\n            [QAM Channel / TS Num]:Slot[QAM Slot Num]-[Module Rf Port Num][Channel Letter]\n            \n         Examples:\n            TS  9, in QAM Slot 1, on RF Port 2: '09:Slot1-2A'\n            TS 17, in QAM Slot 2, on RF Port 1: '17:Slot2-1A'\n            TS 48, in QAM Slot 3, on RF Port 2: '48:Slot3-2H'\n            TS 48, in QAM Slot 3, on RF Port 4: '48:Slot3-4D'\n            \n         This may be used for display purposes on a management system.\n         \n         String will be empty or contain '[QAM Channel / TS Num]:Inactive' if\n         apexQamChanStatActive is not set to 'active', i.e. if QAM Channel is\n         not present and/or not enabled.\n        ")
apexQrmDownloadConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1, 2), )
if mibBuilder.loadTexts: apexQrmDownloadConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadConfigTable.setDescription('Table of QAM Module Code Download Configuration.\n         \n         There are 2 QRM modules on each 2x4/2x8 QAM Module.\n         QRMs in QAM Module slots are mapped to table rows as follows:\n         \n             Slot/QRM   Table Row\n                1/1         1\n                1/2         2\n                2/1         3\n                2/2         4\n                3/1         5\n                3/2         6\n         \n         4x4 QAM Modules do not use QRM boards.  There is only one\n         board.  These will be found in the odd indexed rows of this\n         table.  The even indexed rows of the table are not used for\n         4x4 QAM Modules.  4x4 QAM Modules in QAM Module slots are\n         mapped to table rows as follows:\n         \n               Slot     Table Row\n                 1          1\n                 2          3\n                 3          5\n        ')
apexQrmDownloadConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexQrmDownloadConfigQrmNum"))
if mibBuilder.loadTexts: apexQrmDownloadConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadConfigEntry.setDescription('QAM Code Download Configuration Table Entry.')
apexQrmDownloadConfigQrmNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexQrmDownloadConfigQrmNum.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadConfigQrmNum.setDescription('QAM Code Download Configuration Table index.')
apexQrmDownloadConfigRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("requestNotInProgress", 0), ("requestDownload", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexQrmDownloadConfigRequest.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadConfigRequest.setDescription('User initiated manual 4x4 QAM Module or 2x4/2x8 QAM Module QRM board\n         Code Download request.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexQrmDownloadStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2), )
if mibBuilder.loadTexts: apexQrmDownloadStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadStatusTable.setDescription('Table of QAM Module Code Download Status.\n         \n         Refer to apexQrmDownloadConfigTable description\n         for table indexing information.\n        ')
apexQrmDownloadStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexQrmDownloadStatusRfPortNum"))
if mibBuilder.loadTexts: apexQrmDownloadStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadStatusEntry.setDescription('QRM Code Download Status Table Entry.')
apexQrmDownloadStatusRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexQrmDownloadStatusRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadStatusRfPortNum.setDescription('QAM Code Download Status Table index.')
apexQrmDownloadStatusDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmDownloadStatusDescription.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadStatusDescription.setDescription('Text description of the current state of 4x4 QAM Module or\n         2x4/2x8 QAM Module QRM board Code Download.\n        ')
apexQrmDownloadProgress = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmDownloadProgress.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadProgress.setDescription("Completion percentage of Code Download.  '-1' indicates failure.")
apexQrmDownloadSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notSupported", 1), ("supported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmDownloadSupported.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadSupported.setDescription("Indicates if the module HW and SW will support Code Download.\n\n         'notSupported' if the module is unsupported or the code download might\n         downgrade the code resident on the module.\n\n         Refer to apexQamQrmRevisionTable, apexQamQrmRevisionStatusTable,\n         and apexQrmDownloadFileSet for additional status.\n\n         The user cannot initiate a manual download (apexQrmDownloadConfigRequest)\n         when download 'notSupported'.\n        ")
apexQrmDownloadRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("notRequired", 1), ("required", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmDownloadRequired.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadRequired.setDescription("Indicates if the module requires Code Download.  Code download\n         is needed if the versions are not up to date with the resident\n         APEX FW Release.\n\n         Refer to apexQamQrmRevisionTable, apexQamQrmRevisionStatusTable,\n         and apexQrmDownloadFileSet for additional status.\n\n         The user can initiate a manual download (apexQrmDownloadConfigRequest)\n         when download 'notRequired'.\n        ")
apexQrmDownloadFileSet = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("fileSet1", 1), ("fileSet2", 2), ("fileSet3", 3), ("fileSet4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmDownloadFileSet.setStatus('current')
if mibBuilder.loadTexts: apexQrmDownloadFileSet.setDescription('Indicates which file set will be used for this module.\n        ')
apexQrmFileRevisionTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3), )
if mibBuilder.loadTexts: apexQrmFileRevisionTable.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevisionTable.setDescription('Table of revisions of QAM Module files released with the\n         resident APEX FW Release.\n         Refer to identSoftwareVersion in BCS-IDENT-MIB for\n         the release number.\n        ')
apexQrmFileRevisionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexQrmFileRevFileSetNum"))
if mibBuilder.loadTexts: apexQrmFileRevisionEntry.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevisionEntry.setDescription('QRM File Revision Table Entry.')
apexQrmFileRevFileSetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexQrmFileRevFileSetNum.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevFileSetNum.setDescription('QAM file set number.')
apexQrmFileRevFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmFileRevFirmware.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevFirmware.setDescription("Revision of the Application firmware file of the 2x4/2x8 QAM Module's QRM board or\n         revision of the Application firmware portion of the 4x4 QAM Module Code File.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        ")
apexQrmFileRevCalibration = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmFileRevCalibration.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevCalibration.setDescription("Revision of the Calibration data file of the 2x4/2x8 QAM Module's QRM board.\n         \n         Used only for 2x4/2x8 QAM Module QRM board file sets.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        ")
apexQrmFileRevFpga = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmFileRevFpga.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevFpga.setDescription("Revision of FPGA firmware file of the 2x4/2x8 QAM Module's QRM board or\n         revision of the FPGA1 firmware portion of the 4x4 QAM Module Code File.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        ")
apexQrmFileRevFpga2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmFileRevFpga2.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevFpga2.setDescription('Revision of FPGA2 firmware portion of the 4x4 QAM Module Code File.\n         \n         Used only for 4x4 QAM Module file sets.\n         \n         Hex XXYY where XX is major version and YY is minor version.\n        ')
apexQrmFileRevDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 8, 3, 2, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexQrmFileRevDateTime.setStatus('current')
if mibBuilder.loadTexts: apexQrmFileRevDateTime.setDescription("Date and time the 4x4 QAM Module code file was created.\n         \n         Used only for 4x4 QAM Module file sets.\n         \n         Format: 'MM/DD/YYYY HH:MM'  Where HH is a 24 hour clock.\n        ")
apexSesContConfProtocol = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("rpc", 1), ("rtsp", 2), ("mha-ermi", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfProtocol.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfProtocol.setDescription("The communication protocol for output streams in Session Control operating\n         mode. This determines the type of protocol the APEX will use to communicate\n         with an Edge Resource Manager/Switch Digital Video Manager. This parameter\n         cannot be changed when there are any active Session Control mappings. All\n         Session Control mappings must be removed prior to changing this protocol.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfTableApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfTableApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfTableApplyChange.setDescription("The Apply for the apexSesContConfTable. This parameter\n         MUST be set to 'apply' in order for any of the data in the\n         apexSesContConfTable to take effect.  This parameter\n         MUST be set LAST after all other data in the apexSesContConfTable\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexSesContConfRateCompareType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 3), RateComparisonTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfRateCompareType.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfRateCompareType.setDescription("This is the rate to use for comparing input streams.  It is\n         either Information rate or Stream rate.  This applies to monitoring\n         for Bit Rate alarming and monitoring of Redundant Pairs.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfRedundThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfRedundThreshold.setStatus('obsolete')
if mibBuilder.loadTexts: apexSesContConfRedundThreshold.setDescription("This object is obsolete.\n\n         Session Control Redundancy Threshold.\n\n         This is the percent used to determine Fail Over from Primary\n         to Secondary, and Switch Back from Secondary to Primary.  If\n         a value of zero is specified, Fail Over or Switch Back will\n         not occur.  Range is 0 to 100%.\n\n         Primary Fail Over to Secondary:\n         FailOver = (PrimaryRate) < (Threshold * SecondaryRate)\n         The Primary must remain below the threshold for\n         apexGbeConfInRedundMonitorPeriod.\n\n         Secondary Switch Back to Primary:\n         SwitchBack = (PrimaryRate) >= (Threshold * SecondaryRate)\n         The Primary must remain at or above the threshold for\n         apexGbeConfInRedundMonitorPeriod seconds.  The APEX will delay\n         Switch Back an additional apexGbeConfInRedundSwitchTime\n         seconds.  Switch Back will not occur when\n         apexGbeConfInRedundAutoSwitchBack is 'disabled'.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfInputPreEncryptCheck = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 5), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfInputPreEncryptCheck.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfInputPreEncryptCheck.setDescription("Session Control Pre-Encryption Checking.\n\n         Indicates if the APEX is to check if the input service is pre-encrypted or\n         clear. Pre-encrypted is determined by examining the input PMT for a CA ECM\n         descriptor (any CA ECM descriptor). If pre-encrypted, setting this flag will\n         cause the APEX to pass through ECM PID for this service. For input services\n         that have a GI CA ECM descriptor, the APEX will also pass through the PIT\n         message (extract and re-insert the PIT). The output PMT for pre-encrypted\n         services will contain a CA ECM descriptor (referencing the ECM\n         PID). When PID Remapping is enabled, pre-encryption for a service is\n         only valid when the input ECM PID is on a different PID than the\n         associated PMT PID. If this flag is set to pre-encryption and the\n         input service is not pre-encrypted, then the setting of this flag has\n         no affect on the output service.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfRedundType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hotWarm", 1), ("hotHot", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfRedundType.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfRedundType.setDescription("The redundancy type for output streams in Session Control operating\n         mode. \n         - hotWarm indicates only 1 input stream, primary or secondary, is\n         open at any one time. For multicast streams, primary will be joined initially.\n         The secondary is joined after a failover (the primary will be dropped prior\n         to joining the secondary).\n         \n         - hotHot indicates both the primary and secondary streams are opened at the\n         same time. For multicast streams, both streams are joined immediately.\n         \n         Changes to the redundancy type cannot be made while there are active routes or\n         sessions. All routes and sessions must be deleted prior to changing the \n         redundancy type.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfFollowDtcp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 1, 7), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfFollowDtcp.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfFollowDtcp.setDescription("Determines how the copy protection settings (CCI, APS, and CIT) within \n         the PRK will be set.  All outputs in Session Control (SDV) mode will use  \n         this setting for following input DTCP. \n           Disabled - Use ERM Configuration settings if encryption blob provided.\n                      Use CTE settings when in CTE encryption mode and no ERM \n                      encryption blob provided.\n\n           Enabled - Follow input DTCP\n         \n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 2), )
if mibBuilder.loadTexts: apexSesContConfTable.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfTable.setDescription("This is a table of Session Control configuration parameters for\n         each output transport stream. This table defines the primary\n         and secondary Gigabit Ethernet interfaces for each output stream\n         in Session Control operating mode. The primary and secondary\n         interfaces cannot be changed for an output stream when there are\n         active Session Control mappings. All Session Control mappings on\n         an output stream must be removed prior to changing the primary or\n         secondary interface settings.\n\n         Once written, the change to this table will only take immediate\n         effect after apexSesContConfTableApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexSesContConfTableApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexSesContConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexSesContConfOutputTsNum"))
if mibBuilder.loadTexts: apexSesContConfEntry.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfEntry.setDescription('Session Control Configuration Table Entry.')
apexSesContConfOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexSesContConfOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfOutputTsNum.setDescription('Output transport stream number (index).')
apexSesContConfGbePrimaryInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfGbePrimaryInterface.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfGbePrimaryInterface.setDescription('The primary Gbe interface for Session Control.  Zero indicates not available.\n         This parameter cannot be changed for any output stream if there is at\n         least 1 active session control mapping.\n\n         Not configurable for RTSP.\n        ')
apexSesContConfGbeSecondaryInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSesContConfGbeSecondaryInterface.setStatus('current')
if mibBuilder.loadTexts: apexSesContConfGbeSecondaryInterface.setDescription('The secondary Gbe interface for RPC SDV.  Zero indicates not available.\n         This parameter cannot be changed for any output stream if there is at\n         least 1 active session control mapping.\n\n         Secondary selection is restricted based on Primary as follows:\n           - Primary 1 or 2: Secondary must be 1 or 2\n           - Primary 3 or 4: Secondary must be 3 or 4\n\n         Not configurable for RTSP.\n        ')
apexSesContStatProtocol = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("rpc", 1), ("rtsp", 2), ("mha-ermi", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexSesContStatProtocol.setStatus('current')
if mibBuilder.loadTexts: apexSesContStatProtocol.setDescription('The communication protocol in use for output streams in Session Control\n         operating mode.\n        ')
apexRpcDataCarouselProgram = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcDataCarouselProgram.setStatus('current')
if mibBuilder.loadTexts: apexRpcDataCarouselProgram.setDescription("Indicates which Input Program Number to use for the Data\n         Carousel.  The data carousel in SDV mode (RPC or RTSP) is on a fixed\n         PMT PID along with a fixed component PID. In order to maintain\n         these PID values, the APEX will check for a specific input service\n         number defined by this parameter. This service mapping is assumed\n         to be the Data Carousel mapping. The APEX will maintain the PMT PID\n         value along with the component PID value.  To facilitate this mapping,\n         the Data Carousel input/output program number is configurable.\n           - Data Carousel Service Number Default: 0xF38F (62351)\n\n         The PMT PID and component PID will be determined by the APEX by\n         analyzing the PAT and PMT based on the program number configured. A\n         program number of zero (0) indicates that there is no data carousel.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcReportAllSessions = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcReportAllSessions.setStatus('current')
if mibBuilder.loadTexts: apexRpcReportAllSessions.setDescription("Session reporting mode.  Indicates what sessions will be reported\n         when the APEX is requested to report sessions to a manager.\n\n         When 'enabled', the APEX will report all sessions.\n         When 'disabled', the APEX will report only the sessions for the requesting\n         manager.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcDeviceName.setStatus('current')
if mibBuilder.loadTexts: apexRpcDeviceName.setDescription("The device name of this APEX.  This variable is only used to      \n         generate an XML configuration file via the EM.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n         \n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcDeviceType.setStatus('current')
if mibBuilder.loadTexts: apexRpcDeviceType.setDescription("The device type string reported in XML configuration file.  This  \n         variable is only used to generate an XML configuration file via the  \n         EM.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n         \n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcControlInterface = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 5), EthernetInterfaceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcControlInterface.setStatus('current')
if mibBuilder.loadTexts: apexRpcControlInterface.setDescription("The Enet interface that will be used to set the IP address attribute\n         in the generated XML file.  This variable is only used to generate\n         an XML configuration file via the EM.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRpcApplyChange is changed to 'apply'.\n         In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRpcApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcNumShellSessions = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcNumShellSessions.setStatus('current')
if mibBuilder.loadTexts: apexRpcNumShellSessions.setDescription("The number of shell sessions to be created on each channel marked \n         for session control mode.  This variable is only used to generate an \n         XML configuration file via    the EM.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRpcApplyChange is changed to 'apply'.  \n         In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRpcApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcAvgBandwidthEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 7), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcAvgBandwidthEnable.setStatus('current')
if mibBuilder.loadTexts: apexRpcAvgBandwidthEnable.setDescription("When enabled the APEX populates the sessionRate in the QuerySessionInfo Response \n         message with groupRate divided by the number of sessionIds in the group.  The \n         value reported makes no distinction between bound and unbound sessions.\n         \n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 1, 8), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexRpcApplyChange.setDescription('The Apply for RPC Settings.  This applies to apexRpcControlInterface,\n         apexRpcNumShellSessions, apexRpcRfPortServiceGroup.\n         \n         @Config(config=no, reboot=no)\n        ')
apexRpcRfPortTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 2), )
if mibBuilder.loadTexts: apexRpcRfPortTable.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfPortTable.setDescription('Table of Configuration data for RPC Session RF Ports.  This variable \n         is only used to generate an XML configuration file via the EM.\n        ')
apexRpcRfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexRpcRfPortNum"))
if mibBuilder.loadTexts: apexRpcRfPortEntry.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfPortEntry.setDescription('RPC RF Port Configuration Table Entry.')
apexRpcRfPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexRpcRfPortNum.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfPortNum.setDescription('The RF Port number.')
apexRpcRfPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcRfPortName.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfPortName.setDescription("The RF Port name.\n        \n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.  \n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcRfPortServiceGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcRfPortServiceGroup.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfPortServiceGroup.setDescription("The RF Port service group.\n        \n         Once written, the change to this parameter will only take immediate\n         effect after apexRpcApplyChange is changed to 'apply'.  \n         In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRpcApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcRfChannelTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 3), )
if mibBuilder.loadTexts: apexRpcRfChannelTable.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfChannelTable.setDescription("Table of Configuration data for RPC Session RF Channels.  This variable\n         is only used to generate an XML configuration file via the EM.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.  \n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRpcRfChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexRpcRfChannelNum"))
if mibBuilder.loadTexts: apexRpcRfChannelEntry.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfChannelEntry.setDescription('RPC RF Channel Configuration Table Entry.')
apexRpcRfChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRpcRfChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfChannelNum.setDescription('The RF Channel number.')
apexRpcRfChannelName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRpcRfChannelName.setStatus('current')
if mibBuilder.loadTexts: apexRpcRfChannelName.setDescription('The name of this RF Channel.\n        ')
apexRpcSessionStatTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2), )
if mibBuilder.loadTexts: apexRpcSessionStatTable.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatTable.setDescription('Table of RPC Switched Digital Video Session status.  This table\n         contains 1 row up to the maximum number of service mappings supported.\n        ')
apexRpcSessionStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexRpcSessionStatIndex"))
if mibBuilder.loadTexts: apexRpcSessionStatEntry.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatEntry.setDescription('RPC Switched Digital Video Session Status Table Entry.')
apexRpcSessionStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexRpcSessionStatIndex.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatIndex.setDescription('The RPC Switched Digital Video Session Status table index.\n        ')
apexRpcSessionStatInputTsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatInputTsIndex.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatInputTsIndex.setDescription('The index into the apexInputTsStatTable.')
apexRpcSessionStatInputProgramNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatInputProgramNum.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatInputProgramNum.setDescription('The Gigabit Ethernet Input Program Number. A value of\n         zero (0) indicates that the input is an SPTS and the first\n         program listed in the input PAT will be mapped by the APEX.\n        ')
apexRpcSessionStatSourceIpAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatSourceIpAddr3.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatSourceIpAddr3.setDescription('The Gigabit Ethernet IGMP v3 Source IP Address 3.\n\n         This IP address is currently unsupported by the APEX.\n        ')
apexRpcSessionStatOutputQamChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatOutputQamChannel.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatOutputQamChannel.setDescription('The Output QAM Channel.\n        ')
apexRpcSessionStatOutputProgramNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatOutputProgramNum.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatOutputProgramNum.setDescription('The Output Program Number (1 - 65535).\n        ')
apexRpcSessionStatProgramBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatProgramBandwidth.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatProgramBandwidth.setDescription('The Expected Program Bandwidth (bps). This is the bandwidth\n         of the program as defined in the service mapping. A value of\n         0 indicates that the program BW is unknown.\n        ')
apexRpcSessionStatSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noSession", 0), ("sdv", 1), ("vodOrBroadcast", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatSessionType.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatSessionType.setDescription('The Type of session (SDV binding or VOD/Broadcast session).\n         1 = Switched Digital Video (SDV)\n         2 = VOD or Broadcast\n        ')
apexRpcSessionStatSessionIdWord1 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord1.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord1.setDescription('The Session ID Word 1.\n\n         Session IDs are 10 byte character arrays.  Session IDs are\n         be stored as 3 4-byte words (3 ulongs) in this MIB. First\n         2 Bytes are always 0, next 10 contain the session ID.\n\n         Session ID is broken up as follows:\n            Word 1: 00:01 = 0x0000 (unused)\n            Word 1: 02:03 = 1st 2 bytes of session ID (1st 2 bytes of MAC address)\n            Word 2: 00:03 = Next 4 bytes (these 4 plus 1st 2 are the MAC address of manager)\n            Word 3: 00:03 = Last 4 bytes (unique number assigned by manager)\n        ')
apexRpcSessionStatSessionIdWord2 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord2.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord2.setDescription('The Session ID Word 2.\n\n         Session IDs are 10 byte character arrays.  Session IDs are\n         be stored as 3 4-byte words (3 Unsigned32) in this MIB. First\n         2 Bytes are always 0, next 10 contain the session ID.\n\n         Session ID is broken up as follows:\n            Word 1: 00:01 = 0x0000 (unused)\n            Word 1: 02:03 = 1st bytes of session ID (1st 2 bytes of MAC address)\n            Word 2: 00:03 = Next 4 bytes (these 4 plus 1st 2 are the MAC address of manager)\n            Word 3: 00:03 = Last 4 bytes (unique number assigned by manager)\n        ')
apexRpcSessionStatSessionIdWord3 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord3.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatSessionIdWord3.setDescription('The Session ID Word 3.\n\n         Session IDs are 10 byte character arrays.  Session IDs are\n         be stored as 3 4-byte words (3 Unsigned32) in this MIB. First\n         2 Bytes are always 0, next 10 contain the session ID.\n\n         Session ID is broken up as follows:\n            Word 1: 00:01 = 0x0000 (unused)\n            Word 1: 02:03 = 1st bytes of session ID (1st 2 bytes of MAC address)\n            Word 2: 00:03 = Next 4 bytes (these 4 plus 1st 2 are the MAC address of manager)\n            Word 3: 00:03 = Last 4 bytes (unique number assigned by manager)\n        ')
apexRpcSessionStatManagerIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcSessionStatManagerIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexRpcSessionStatManagerIpAddr.setDescription('The IP address of the RPC SDV, VOD, or Broadcast manager sending session\n         commands.\n        ')
apexRpcQamStatTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3), )
if mibBuilder.loadTexts: apexRpcQamStatTable.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatTable.setDescription('Table of RPC Switched Digital Video QAM status.  This table\n         is indexed by output stream number and 48 rows.\n        ')
apexRpcQamStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexRpcQamStatQamChannelNum"))
if mibBuilder.loadTexts: apexRpcQamStatEntry.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatEntry.setDescription('RPC Switched Digital Video QAM Status Table Entry.')
apexRpcQamStatQamChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRpcQamStatQamChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatQamChannelNum.setDescription('The RPC Switched Digital Video QAM Status table index.\n        ')
apexRpcQamStatNumSdvSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcQamStatNumSdvSessions.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatNumSdvSessions.setDescription('The Number of reserved SDV sessions on this QAM Channel. This is the\n         number of SDV sessions that have been reserved by the manager. Each\n         SDV session requires that a manager reserve a QAM. This is the count\n         of SDV sessions reserved (not the actual number of active SDV sessions).\n        ')
apexRpcQamStatNumVodBcSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcQamStatNumVodBcSessions.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatNumVodBcSessions.setDescription('The Number of VOD/Broadcast sessions on this QAM Channel. This\n         is the number of VOD/Broadcast sessions active on a QAM Channel. Since\n         VOD and Broadcast sessions are not required to be reserved for an\n         output, this is the count of active VOD and Broadcast sessions on\n         a specific QAM.\n        ')
apexRpcQamStatSdvGroupBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 3, 2, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRpcQamStatSdvGroupBandwidth.setStatus('current')
if mibBuilder.loadTexts: apexRpcQamStatSdvGroupBandwidth.setDescription('The Group BW for SDV sessions (not used for VOD/Broadcast sessions).\n         This is the total amount of BW allocated for all SDV sessions on a channel.\n         The total SDV BW for a channel is defined by the session manager. The manager\n         reserves this BW for future SDV sessions. This is not the BW of current\n         active SDV sessions, but the total BW reserved by the manager for SDV sessions.\n        ')
apexRtspReportGbeInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("reportGbe1and2", 1), ("reportGbe3and4", 2), ("pairedPortAssignment", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspReportGbeInterfaces.setStatus('current')
if mibBuilder.loadTexts: apexRtspReportGbeInterfaces.setDescription("This selects which pair of GBE interfaces are to be reported to the\n         RTSP controller (ERM) via VREP. The pairedPortAssignment selection allows\n         for both pairs of GBE interfaces to be reported to the ERM. This allows\n         for all 4 GBE interfaces to be used by the ERM for session mappings. This\n         effectively splits the APEX into 2x24 QAM devices where the first GBE\n         interface pair (1&2) are assigned to the first 24 output QAM streams\n         (output TS 1 - 24) and the second GBE pair (3&4) are assigned to the second\n         24 output QAM streams (output TS 25-48). Selecting reportGbe1and2 or\n         reportGbe3and4 limits the ERM to 2 GBE interfaces only.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfControllerApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 2), )
if mibBuilder.loadTexts: apexRtspConfControllerApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerApplyTable.setDescription('Table of Apply Change for the data for apexRtspConfControllerTable.\n\n         A row of this table corresponds to a row in apexRtspConfControllerTable.\n        ')
apexRtspConfControllerApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfControllerApplyNum"))
if mibBuilder.loadTexts: apexRtspConfControllerApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerApplyEntry.setDescription('RTSP Controller Configuration Apply Table Entry.')
apexRtspConfControllerApplyNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspConfControllerApplyNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerApplyNum.setDescription('The RTSP Session Controller number.')
apexRtspConfControllerApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControllerApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerApplyChange.setDescription("The Apply for a row of data in apexRtspConfControllerTable and\n         apexRtspConfControlNamesTable.\n\n         A row in this table corresponds to the same row index in the\n         apexRtspConfControllerTable and apexRtspConfControlNamesTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the rows to take effect in the APEX.  This parameter MUST be set\n         LAST after all other data in the configuration table rows has been\n         configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexRtspConfControllerTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3), )
if mibBuilder.loadTexts: apexRtspConfControllerTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerTable.setDescription("Table of RTSP configuration items configurable on a Controller basis.\n\n         Once written, the change to this table will only take immediate\n         effect after apexRtspConfControllerApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfControllerApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfControllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfControllerNum"))
if mibBuilder.loadTexts: apexRtspConfControllerEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerEntry.setDescription('RTSP Controller Configuration Table Entry.')
apexRtspConfControllerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspConfControllerNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerNum.setDescription('The Controller Number.\n\n         APEX currently supports only one controller.\n        ')
apexRtspConfControllerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControllerIp.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerIp.setDescription('The IP Address of the RTSP session controller.\n        ')
apexRtspConfControllerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControllerPort.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerPort.setDescription('Port for the RTSP session controller.\n        ')
apexRtspConfControllerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(9, 300), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControllerHoldTime.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerHoldTime.setDescription('The session hold time in seconds.  If the APEX does not receive a\n         keep session alive message from the controller in this time the\n         APEX will close the session.\n\n         The APEX will transmit keep session alive messages at one-third\n         of this time.\n\n         Zero indicates that the APEX should not send keep session alive\n         messages.\n        ')
apexRtspConfControllerBandwidthDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 100000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControllerBandwidthDelta.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControllerBandwidthDelta.setDescription("The Bandwidth Delta, in kilobits per second (kbps), for sending an\n         Update Message.\n\n         Whenever a QAM Channel's output utilization changes by more than the\n         bandwidth delta, the APEX will send a update message providing the\n         current BW being utilized.\n\n         Zero indicates that the APEX should not send update messages based on\n         bandwidth changes.\n        ")
apexRtspConfControlNamesTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 4), )
if mibBuilder.loadTexts: apexRtspConfControlNamesTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControlNamesTable.setDescription("Table of RTSP configuration items configurable on a Controller basis.\n         Contains the control names.  This table is a row-for-row index match\n         to the apexRtspConfControllerTable.\n\n         Once written, the change to this table will only take immediate\n         effect after apexRtspConfControllerApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfControllerApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfControlNamesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfControlNamesNum"))
if mibBuilder.loadTexts: apexRtspConfControlNamesEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControlNamesEntry.setDescription('RTSP Controller Names Configuration Table Entry.')
apexRtspConfControlNamesNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspConfControlNamesNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControlNamesNum.setDescription('The Controller Number.\n\n         APEX currently supports only one controller.\n        ')
apexRtspConfControlNamesStreamingZone = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControlNamesStreamingZone.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControlNamesStreamingZone.setDescription('The streaming zone that the APEX is a member of.\n        ')
apexRtspConfControlNamesDeviceName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfControlNamesDeviceName.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfControlNamesDeviceName.setDescription('The device name of this APEX.\n        ')
apexRtspConfQamChannelApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 5), )
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyTable.setDescription('Table of Apply Change for the data for apexRtspConfQamChannelTable.\n\n         A row of this table corresponds to a row in apexRtspConfQamChannelTable.\n        ')
apexRtspConfQamChannelApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfQamChannelApplyNum"))
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyEntry.setDescription('RTSP QAM Configuration Apply Table Entry.')
apexRtspConfQamChannelApplyNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyNum.setDescription('The QAM Channel number.')
apexRtspConfQamChannelApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 5, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelApplyChange.setDescription("The Apply for a row of data in apexRtspConfQamChannelTable.\n\n         A row in this table corresponds to the same row index in the\n         apexRtspConfQamChannelTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the rows to take effect in the APEX.  This parameter MUST be set\n         LAST after all other data in the configuration table rows has been\n         configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexRtspConfQamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 6), )
if mibBuilder.loadTexts: apexRtspConfQamChannelTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelTable.setDescription("Table of Configuration data for RTSP Session QAM Channels.\n\n         Once written, the change to this table will only take immediate\n         effect after apexRtspConfQamChannelApplyChange to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfQamChannelApplyChange , value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfQamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfQamChannelNum"))
if mibBuilder.loadTexts: apexRtspConfQamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelEntry.setDescription('RTSP QAM Configuration Table Entry.')
apexRtspConfQamChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRtspConfQamChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelNum.setDescription('The QAM Channel number.')
apexRtspConfQamChannelGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfQamChannelGroupName.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfQamChannelGroupName.setDescription('The QAM Group Name that this QAM Channel is a member of.\n        ')
apexRtspConfGbeEdgeGroupTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 7), )
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupTable.setDescription("Table of Configuration data for RTSP Session GigE Interfaces.\n\n         Once written, the change to this table will take immediate\n         effect.  In order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfGbeEdgeGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 7, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfGbeEdgeGroupNum"))
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupEntry.setDescription('RTSP GigE Edge Group Configuration Table Entry.')
apexRtspConfGbeEdgeGroupNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupNum.setDescription('The GigE Edge Group Interface number.')
apexRtspConfGbeEdgeGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupName.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfGbeEdgeGroupName.setDescription('The Name of this GigE Interface.\n        ')
apexRtspConfMhaTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 8), )
if mibBuilder.loadTexts: apexRtspConfMhaTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaTable.setDescription("Table of MHA RTSP configuration items configurable on a Controller basis.\n\n         Once written, the change to this table will only take immediate\n         effect after apexRtspConfControllerApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfControllerApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 8, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspConfMhaNum"))
if mibBuilder.loadTexts: apexRtspConfMhaEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaEntry.setDescription('MHA RTSP Configuration Table Entry.')
apexRtspConfMhaNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspConfMhaNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaNum.setDescription('The MHA Controller Number.\n\n         APEX currently supports only one controller.\n        ')
apexRtspConfMhaAddressDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaAddressDomain.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaAddressDomain.setDescription('Address Domain of the sender used in ERRP.  Address Domain of the\n         ERM and APEX must match in order to establish an ERRP connection.\n         Zero is used as the global address domain, which is interpreted to\n         mean that any advertised address can be reached from any address\n         domain.\n        ')
apexRtspConfMhaPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaPort.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaPort.setDescription('Port for the MHA session controller.\n        ')
apexRtspConfMhaUdpMapEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 9, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaUdpMapEnable.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaUdpMapEnable.setDescription("Indicates if the UDP Map is populated in the Update message\n         sent by the APEX to the ERM when in MHA mode.\n\n         When 'enabled', the APEX will report UDP ports available.\n         When 'disabled', the APEX will include the UDP Map field but will\n         not populate it with data.\n\n         Once written, the change to this table will only take immediate\n         effect after apexRtspConfControllerApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfControllerApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaSbeEncryptionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("full", 1), ("fwk", 2), ("fpk", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaSbeEncryptionMode.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaSbeEncryptionMode.setDescription("This parameter is used to set the Session based Encryption Mode.  \n         It applies to all session based encryption sessions.\n\n           - 'full'  - The APEX will use Full encryption. \n           \n           - 'fwk'   - The APEX will use Fixed Working Key (FWK) encryption.\n\n           - 'fpk'   - The APEX will use Fixed Program Key (FPK) encryption. The APEX\n                       will not attempt to get EMMs.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRtspConfMhaSbeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfMhaSbeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaSbeCciLevel = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notDefined", 1), ("copyFreely", 2), ("copyOnce", 3), ("copyNever", 4), ("noMoreCopies", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaSbeCciLevel.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaSbeCciLevel.setDescription("Copy Control Information (CCI) Level setting for session based PRK messages\n         if CCI is not defined in the XML encryption blob.\n           - notDefined   - CCI is not defined, settop box applications can\n                            configure CCI\n           - copyFreely   - program can be copied\n           - copyOnce     - program can be copied once\n           - copyNever    - program can never be copied\n           - noMoreCopies -\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRtspConfMhaSbeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfMhaSbeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaSbeApsLevel = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notDefined", 1), ("off", 2), ("splitBurstOff", 3), ("splitBurst2Line", 4), ("splitBurst4Line", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaSbeApsLevel.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaSbeApsLevel.setDescription("Analog Protection System (APS) Level setting for session based PRK \n         messages if APS is not defined in the XML encryption blob.  \n         Defines what copy protection encoding will be applied to the analog \n         composite output by the settop box.\n           - notDefined      - analog protection is not defined, settop box\n                               applications can configure APS\n           - off             - no analog protection\n           - splitBurstOff   - AGC on, split burst off\n           - splitBurst2Line - AGC on, 2 line split burst on\n           - splitBurst4Line - AGC on, 4 line split burst on\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRtspConfMhaSbeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfMhaSbeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaSbeCitSetting = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaSbeCitSetting.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaSbeCitSetting.setDescription("Copy protection Constraint Image Trigger setting. This is only\n         applicable when the session is being encrypted and the CIT setting\n         was not contained in the XML encryption blob.\n         \n         Once written, the change to this parameter will only take immediate\n         effect after apexRtspConfMhaSbeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRtspConfMhaSbeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(sdv.ini, type='ini')\n        ")
apexRtspConfMhaSbeApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 1, 10, 5), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRtspConfMhaSbeApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexRtspConfMhaSbeApplyChange.setDescription("The Apply for the MHA session based encryption settings.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in MHA SBE to take effect in the APEX.  This parameter MUST be set \n         LAST after all other data in the MHA SBE has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexRtspSessionStatTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2), )
if mibBuilder.loadTexts: apexRtspSessionStatTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatTable.setDescription('Table of RTSP Session status.  This table\n         contains 768 rows.\n        ')
apexRtspSessionStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspSessionStatIndex"))
if mibBuilder.loadTexts: apexRtspSessionStatEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatEntry.setDescription('RTSP Session Status Table Entry.')
apexRtspSessionStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexRtspSessionStatIndex.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatIndex.setDescription('The RTSP Session Status table index.\n        ')
apexRtspSessionStatInputTsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatInputTsIndex.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatInputTsIndex.setDescription('The index into the apexInputTsStatTable.')
apexRtspSessionStatInputProgramNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatInputProgramNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatInputProgramNum.setDescription('The Gigabit Ethernet Input Program Number. A value of\n         zero (0) indicates that the input is an SPTS and the first\n         program listed in the input PAT will be mapped by the APEX.\n        ')
apexRtspSessionStatOutputQamChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatOutputQamChannel.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatOutputQamChannel.setDescription('The Output QAM Channel.\n        ')
apexRtspSessionStatOutputProgramNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatOutputProgramNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatOutputProgramNum.setDescription('The Output Program Number.\n        ')
apexRtspSessionStatProgramBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatProgramBandwidth.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatProgramBandwidth.setDescription('The Expected Program Bandwidth (bps). This is the bandwidth\n         of the program as defined in the service mapping. A value of\n         0 indicates that the program BW is unknown.\n        ')
apexRtspSessionStatManagerIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionStatManagerIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionStatManagerIpAddr.setDescription('The IP address of the manager sending session commands.\n        ')
apexRtspSessionIdTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 3), )
if mibBuilder.loadTexts: apexRtspSessionIdTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionIdTable.setDescription('Table of RTSP Session Ids.  This table\n         contains 768 rows and is a row-for-row\n         index match to apexRtspSessionStatTable.\n        ')
apexRtspSessionIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspSessionIdIndex"))
if mibBuilder.loadTexts: apexRtspSessionIdEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionIdEntry.setDescription('RTSP Session ID Table Entry.')
apexRtspSessionIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexRtspSessionIdIndex.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionIdIndex.setDescription('The RTSP Session ID table index.\n         This is a row-for-row match to the\n         RTSP Session Status table index.\n        ')
apexRtspSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspSessionId.setStatus('current')
if mibBuilder.loadTexts: apexRtspSessionId.setDescription('The Session ID.\n        ')
apexRtspQamStatTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 4), )
if mibBuilder.loadTexts: apexRtspQamStatTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspQamStatTable.setDescription('Table of RTSP Session QAM status.  This table\n         is indexed by QAM channel number and contains 48 rows.\n        ')
apexRtspQamStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspQamStatQamChannelNum"))
if mibBuilder.loadTexts: apexRtspQamStatEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspQamStatEntry.setDescription('RTSP Session QAM status Table Entry.')
apexRtspQamStatQamChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRtspQamStatQamChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspQamStatQamChannelNum.setDescription('The RTSP Session Control Video QAM Status table index.\n        ')
apexRtspQamStatNumSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspQamStatNumSessions.setStatus('current')
if mibBuilder.loadTexts: apexRtspQamStatNumSessions.setDescription('The Number of active sessions on this QAM Channel.\n        ')
apexRtspQamStatAllocatedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 4, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspQamStatAllocatedBandwidth.setStatus('current')
if mibBuilder.loadTexts: apexRtspQamStatAllocatedBandwidth.setDescription('This is the total amount of BW allocated for all sessions on a channel.\n        ')
apexRtspStatControllerTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5), )
if mibBuilder.loadTexts: apexRtspStatControllerTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerTable.setDescription('Table of RTSP status items configurable on a Controller basis.\n        ')
apexRtspStatControllerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspStatControllerNum"))
if mibBuilder.loadTexts: apexRtspStatControllerEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerEntry.setDescription('RTSP Controller Status Table Entry.')
apexRtspStatControllerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: apexRtspStatControllerNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerNum.setDescription('The Controller Number.\n\n         APEX currently supports only one controller.\n        ')
apexRtspStatControllerDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("notDiscovered", 1), ("discovered", 2), ("discoveredConnectionLost", 3), ("discoveredAnotB", 4), ("discoveredBnotA", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspStatControllerDiscovery.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerDiscovery.setDescription('Status of Controller to APEX discovery.\n        ')
apexRtspStatControllerConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notApplicable", 0), ("notConnected", 1), ("connected", 2), ("connectedPort554", 3), ("connectedPort2048", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspStatControllerConnection.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerConnection.setDescription("Status of the connection between the APEX and the Controller.\n\n         'notConnected' causes apexAlarmRtspControllerCommFault.\n        ")
apexRtspStatControllerCommFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspStatControllerCommFault.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatControllerCommFault.setDescription('Current fault condition of apexRtspStatControllerConnection.\n\n         This is the apexAlarmRtspControllerCommFault level for this controller.\n        ')
apexRtspStatQamChannelTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 6), )
if mibBuilder.loadTexts: apexRtspStatQamChannelTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamChannelTable.setDescription('Table of Status data for RTSP Session QAM Channels.\n        ')
apexRtspStatQamChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspStatQamChannelNum"))
if mibBuilder.loadTexts: apexRtspStatQamChannelEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamChannelEntry.setDescription('RTSP QAM Configuration Table Entry.')
apexRtspStatQamChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRtspStatQamChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamChannelNum.setDescription('The QAM Channel number.')
apexRtspStatQamChannelName = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspStatQamChannelName.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamChannelName.setDescription('The Name of this QAM Channel.\n        ')
apexRtspStatQamMptsModeTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 7), )
if mibBuilder.loadTexts: apexRtspStatQamMptsModeTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamMptsModeTable.setDescription('Table of MPTS Mode Status data for RTSP Session QAM Channels.\n        ')
apexRtspStatQamMptsModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 7, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspStatQamMptsModeQamChannelNum"))
if mibBuilder.loadTexts: apexRtspStatQamMptsModeEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamMptsModeEntry.setDescription('RTSP QAM MPTS Mode Configuration Table Entry.')
apexRtspStatQamMptsModeQamChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRtspStatQamMptsModeQamChannelNum.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamMptsModeQamChannelNum.setDescription('The QAM Channel number.')
apexRtspStatQamMptsModeQamChannelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 9, 4, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("passthrough", 1), ("multiplexing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspStatQamMptsModeQamChannelMode.setStatus('current')
if mibBuilder.loadTexts: apexRtspStatQamMptsModeQamChannelMode.setDescription('The MPTS mode of this QAM Channel.  The first session\n         established on the QAM channel defines the\n         MPTS mode.  Each new session must have the same\n         mode as long as one session is still active.\n        ')
apexManualRouteRmdClear = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 1, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteRmdClear.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteRmdClear.setDescription(' Clear all RMD information from DRAM and flash.\n\n          Note that apexManualRouteEnable must be set to disabled for\n          all rows before RMD information will be cleared by this\n          parameter.\n\n          If RMD information was cleared, the APEX will set\n          this parameter to applyNotInProgressValidData.  If RMD\n          information was not cleared, the APEX will set this parameter\n          to applyNotInProgressInvalidData.\n\n          Once written, the change to this parameter will take effect immediately.\n\n          @Config(config=no, reboot=no)\n        ')
apexManualRouteApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 2), )
if mibBuilder.loadTexts: apexManualRouteApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteApplyTable.setDescription('Table of Apply Change for the data for Manual Route Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Route table.\n        ')
apexManualRouteApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexManualRouteApplyIndex"))
if mibBuilder.loadTexts: apexManualRouteApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteApplyEntry.setDescription('Manual Route Apply Table Entry.')
apexManualRouteApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManualRouteApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteApplyIndex.setDescription('The index of the Manual Route Apply Table.')
apexManualRouteApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteApplyChange.setDescription("The Apply for the row of data in the Manual Route Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Route table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the Manual Route Table row to take effect in the APEX.  This\n         parameter MUST be set LAST after all other data in the Manual Route\n         Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexManualRouteTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3), )
if mibBuilder.loadTexts: apexManualRouteTable.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteTable.setDescription("Table of data for Manual Routes.\n\n         Once written, the change to a row this table will only take\n         immediate effect after the appropriate apexManualRouteApplyChange\n         is set to 'apply'.  In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexManualRouteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexManualRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexManualRouteIndex"))
if mibBuilder.loadTexts: apexManualRouteEntry.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteEntry.setDescription('Manual Route Table Entry.')
apexManualRouteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManualRouteIndex.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteIndex.setDescription('The index of the Manual Route Table.')
apexManualRouteEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteEnable.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteEnable.setDescription('Indicates that this Manual Route is enabled or disabled.\n        ')
apexManualRouteInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputType.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputType.setDescription('Input Type of input from which to obtain data.\n        ')
apexManualRouteInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputInterface.setDescription("Number of the input interface, of type configured by Input Type,\n         from which to obtain data.\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n            FastEnet = 1-2\n        ")
apexManualRouteInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputUdp.setDescription('Input UDP Port from which to obtain data.\n\n         Range:\n            GBE      = 0-65535\n            FastEnet = 1024-65535\n        ')
apexManualRouteInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputMulticastIp.setDescription('Input Multicast IP address from which to obtain data.\n\n         An IP address of 0.0.0.0 indicates table entry not in use.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexManualRouteInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputSourceIp.setDescription('Input IGMP v3 Source IP from which to obtain data.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexManualRouteInputProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputProgNum.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputProgNum.setDescription('Input MPEG Program Number to multiplex. A value of 0 can be used as\n         a wild card. This will cause the APEX to map the first program listed in\n         the input PAT to the specified output (regardless of input program number).\n         Input program number zero should only be used when mapping Single Program\n         Transport Streams (SPTS).\n        ')
apexManualRouteInputPreEncryptCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 9), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteInputPreEncryptCheck.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInputPreEncryptCheck.setDescription('Manual Routing Pre-Encryption Checking.\n\n         Indicates if the APEX is to check if the input service is pre-encrypted or\n         clear. Pre-encrypted is determined by examining the input PMT for a CA ECM\n         descriptor (any CA ECM descriptor). If pre-encrypted, setting this flag will\n         cause the APEX to pass through ECM PID for this service. For input services\n         that have a GI CA ECM descriptor, the APEX will also pass through the PIT\n         message (extract and re-insert the PIT). The output PMT for pre-encrypted\n         services will contain a CA ECM descriptor (referencing the ECM\n         PID). When PID Remapping is enabled, pre-encryption for a service is\n         only valid when the input ECM PID is on a different PID than the\n         associated PMT PID. If this flag is set to pre-encryption and the\n         input service is not pre-encrypted, then the setting of this flag has\n         no affect on the output service.\n        ')
apexManualRouteOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteOutputTsNum.setDescription('Output Transport Stream Number of the output on which to place data.\n         Zero = NotApplicable and is only valid if the apexManualRouteTable\n         entry is not being used.\n        ')
apexManualRouteOutputProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteOutputProgNum.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteOutputProgNum.setDescription('Output Program number to use for the program.\n         Zero = NotApplicable and is only valid if the apexManualRouteTable\n         entry is not being used.\n        ')
apexManualRouteOutputEncryptMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteOutputEncryptMode.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteOutputEncryptMode.setDescription('Encryption Mode.\n\n         Not supported.\n        ')
apexManualRouteOutputCopyProtectSource = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followInputDtcp", 1), ("configuredSource", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteOutputCopyProtectSource.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteOutputCopyProtectSource.setDescription('Copy Protection Source.\n\n         Not supported.\n        ')
apexManualRouteSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteSourceId.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteSourceId.setDescription("Broadcast Encryption Source ID.\n\n         Only applies to programs if the input type is Gbe and the\n         output encryption mode is Broadcast Encryption.\n         (apexOutputTsConfEncryptionType set to 'broadcastEncryption')\n        ")
apexManualRouteProviderId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManualRouteProviderId.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteProviderId.setDescription("Broadcast Encryption Provider ID.\n\n         Only applies to programs if the input type is Gbe and the\n         output encryption mode is Broadcast Encryption.\n         (apexOutputTsConfEncryptionType set to 'broadcastEncryption')\n        ")
apexManRtePassThroughApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 4), )
if mibBuilder.loadTexts: apexManRtePassThroughApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughApplyTable.setDescription('Table of Apply Change for the data for Manual Route Pass Through Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Route Pass Through table.\n        ')
apexManRtePassThroughApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexManRtePassThroughApplyOutputTsNum"))
if mibBuilder.loadTexts: apexManRtePassThroughApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughApplyEntry.setDescription('Manual Route Apply Table Entry.')
apexManRtePassThroughApplyOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexManRtePassThroughApplyOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughApplyOutputTsNum.setDescription('The index of the Manual Route Pass Through Apply Table.')
apexManRtePassThroughApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 4, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughApplyChange.setDescription("The Apply for the row of data in the Manual Route Pass Through Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Route Pass Through table.\n\n         This parameter MUST be set to 'apply' in order for any of the\n         data in the Manual Route Pass Through Table row to take effect\n         in the APEX.  This parameter MUST be set LAST after all other\n         data in the Manual Route Pass Through Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexManRtePassThroughTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5), )
if mibBuilder.loadTexts: apexManRtePassThroughTable.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughTable.setDescription("Table of data for Manual Route Pass Through. This table is used to\n         pass through an entire input stream to an output stream.\n\n         Once written, the change to a row this table will only take\n         immediate effect after the appropriate apexManRtePassThroughApplyChange\n         is set to 'apply'.  In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexManRtePassThroughApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexManRtePassThroughEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexManRtePassThroughOutputTsNum"))
if mibBuilder.loadTexts: apexManRtePassThroughEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughEntry.setDescription('Manual Route Pass Through Table Entry.')
apexManRtePassThroughOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexManRtePassThroughOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughOutputTsNum.setDescription('The index of the Manual Route Pass Through Table.')
apexManRtePassThroughEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughEnable.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughEnable.setDescription('Indicates that this Manual Route Pass Through is enabled or disabled.\n         An input stream can only be passed through to an output stream when\n         there are no active service or PID mappings to the output stream.\n        ')
apexManRtePassThroughInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughInputType.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInputType.setDescription('Input Type of input from which to obtain data.\n        ')
apexManRtePassThroughInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInputInterface.setDescription("Number of the input interface, of type configured by Input Type,\n         from which to obtain data.\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n            FastEnet = 1-2\n        ")
apexManRtePassThroughInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInputUdp.setDescription('Input UDP Port from which to obtain data.\n\n         Range:\n            GBE      = 0-65535\n            FastEnet = 1024-65535\n        ')
apexManRtePassThroughInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInputMulticastIp.setDescription('Input Multicast IP address from which to obtain data.\n\n         An IP address of 0.0.0.0 indicates table entry not in use.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexManRtePassThroughInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 5, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRtePassThroughInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInputSourceIp.setDescription('Input IGMP v3 Source IP address from which to obtain data.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexManRteGbeInRedApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 2), )
if mibBuilder.loadTexts: apexManRteGbeInRedApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedApplyTable.setDescription('Table of Apply Change for the data for Manual Route Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Route table.\n        ')
apexManRteGbeInRedApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexManRteGbeInRedApplyIndex"))
if mibBuilder.loadTexts: apexManRteGbeInRedApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedApplyEntry.setDescription('Manual Routing Gbe Input Ts Configuration Apply Table Entry.')
apexManRteGbeInRedApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManRteGbeInRedApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedApplyIndex.setDescription('The index of the Manual Routing Gbe Input Ts Configuration\n         Apply Table.')
apexManRteGbeInRedApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedApplyChange.setDescription("The Apply for the row of data in the Manual Routing Gbe Input Ts\n         Configuration Table.\n\n         A row in this table corresponds to the same row index in the\n         Manual Routing Gbe Input Ts Configuration table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the Manual Routing Gbe Input Ts Configuration Table row to take\n         effect in the APEX.  This parameter MUST be set LAST after all other\n         data in the Manual Routing Gbe Input Ts Configuration Table row has\n         been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexManRteGbeInRedTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3), )
if mibBuilder.loadTexts: apexManRteGbeInRedTable.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedTable.setDescription("This table is the Manual Routing Gigabit Ethernet Input Transport\n         Stream Configuration Table.  This table contains 768 rows.\n\n         For Force Switching a Redundancy pair for an Input TS configured\n         in this table, refer to the same row index in\n         apexManRteGbeInRedForceSwitchTable.\n\n         Once written, the change to this table will only take immediate\n         effect after apexManRteGbeInRedApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexManRteGbeInRedApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(gige_red.ini, type='ini')\n        ")
apexManRteGbeInRedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexManRteGbeInRedIndex"))
if mibBuilder.loadTexts: apexManRteGbeInRedEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedEntry.setDescription('Manual Routing Gigabit Ethernet Input Transport Stream Configuration\n         Table Entry.')
apexManRteGbeInRedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManRteGbeInRedIndex.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedIndex.setDescription('The Manual Routing Gbe Input Ts Configuration table index.\n        ')
apexManRteGbeInRedPriInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriInterface.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriInterface.setDescription('The primary Gigabit Ethernet Interface.\n\n         Zero indicates this row of the table is not in use.\n        ')
apexManRteGbeInRedPriUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriUdp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriUdp.setDescription('The primary Gigabit Ethernet Input UDP Port.\n        ')
apexManRteGbeInRedPriMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriMulticastIp.setDescription('The primary Multicast receive IP address.\n\n         An IP address of 0.0.0.0 indicates table entry not in use.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexManRteGbeInRedPriSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriSourceIp.setDescription('This is the IP address of the source device for the primary interface.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexManRteGbeInRedPriLowAlarmBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriLowAlarmBitRate.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriLowAlarmBitRate.setDescription('This is the bit rate, in bits per second, below which the\n         APEX will issue the apexAlarmGbeInputStreamLowBitRate alarm\n         for the primary interface.\n\n         The APEX will compare either the current Information rate or Stream\n         rate as configured in apexManRteGbeInRedRateCompareType.\n         Setting to zero disables the bit rate alarming.\n\n         The APEX updates the bit rate statistics every five seconds.\n        ')
apexManRteGbeInRedPriHighAlarmBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedPriHighAlarmBitRate.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedPriHighAlarmBitRate.setDescription('This is the bit rate, in bits per second, above which the\n         APEX will issue the apexAlarmGbeInputStreamHighBitRate alarm\n         for the primary interface.\n\n         The APEX will compare either the current Information rate or Stream\n         rate as configured in apexManRteGbeInRedRateCompareType.\n         Setting to zero disables the bit rate alarming.\n\n         The APEX updates the bit rate statistics every five seconds.\n\n         Not supported.\n        ')
apexManRteGbeInRedRateCompareType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 8), RateComparisonTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedRateCompareType.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedRateCompareType.setDescription('This is the rate to use for comparing input streams.  It is\n         either Information rate or Stream rate.  This applies to monitoring\n         for Bit Rate alarming and monitoring of Redundant Pairs.\n        ')
apexManRteGbeInRedEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 9), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedEnable.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedEnable.setDescription('This entry is used to enable Redundancy.\n        ')
apexManRteGbeInRedThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedThreshold.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedThreshold.setDescription("Manual Routing Gigabit Ethernet Redundancy Threshold.\n\n         This is the percent used to determine Fail Over from Primary\n         to Secondary, and Switch Back from Secondary to Primary.  If\n         a value of zero is specified, Fail Over or Switch Back will\n         not occur.  Range is 0 to 100%.\n\n         Primary Fail Over to Secondary:\n         FailOver = (PrimaryRate) < (Threshold * SecondaryRate)\n         The Primary must remain below the threshold for\n         apexGbeConfInRedundMonitorPeriod.  Fail Over will not occur when\n         apexManRteGbeInRedSuspend is set to 'suspended'.\n\n         Secondary Switch Back to Primary:\n         SwitchBack = (PrimaryRate) >= (Threshold * SecondaryRate)\n         The Primary must remain at or above the threshold for\n         apexGbeConfInRedundMonitorPeriod seconds.  The APEX will delay\n         Switch Back an additional apexGbeConfInRedundSwitchTime\n         seconds.  Switch Back will not occur when\n         apexManRteGbeInRedSuspend is set to 'suspended' or\n         apexGbeConfInRedundAutoSwitchBack is 'disabled'.\n        ")
apexManRteGbeInRedSuspend = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSuspended", 1), ("suspended", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSuspend.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSuspend.setDescription("This suspends Redundant Pair switching when set to 'suspended'.\n\n         This has no effect when redundancy is disabled.\n\n         Forced switching of Redundant Pairs is not prevented when this is\n         set to 'suspended'.\n        ")
apexManRteGbeInRedSecInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecInterface.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecInterface.setDescription('The secondary Gigabit Ethernet Interface for redundancy.\n\n         Zero is invalid when redundancy is enabled.\n        ')
apexManRteGbeInRedSecUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecUdp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecUdp.setDescription('The secondary Gigabit Ethernet Input UDP Port for redundancy.\n        ')
apexManRteGbeInRedSecMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecMulticastIp.setDescription('The secondary Multicast receive IP address for redundancy.\n\n         An IP address of 0.0.0.0 indicates singlecast only.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexManRteGbeInRedSecSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecSourceIp.setDescription('This is the IP address of the source device for the secondary interface.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexManRteGbeInRedSecLowAlarmBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecLowAlarmBitRate.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecLowAlarmBitRate.setDescription('This is the bit rate, in bits per second, below which the\n         APEX will issue the apexAlarmGbeInputStreamLowBitRate alarm\n         for the secondary interface.\n\n         The APEX will compare either the current Information rate or Stream\n         rate as configured in apexManRteGbeInRedRateCompareType.\n         Setting to zero disables the bit rate alarming.\n\n         The APEX updates the bit rate statistics every five seconds.\n        ')
apexManRteGbeInRedSecHighAlarmBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecHighAlarmBitRate.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecHighAlarmBitRate.setDescription('This is the bit rate, in bits per second, above which the\n         APEX will issue the apexAlarmGbeInputStreamHighBitRate alarm\n         for the secondary interface.\n\n         The APEX will compare either the current Information rate or Stream\n         rate as configured in apexManRteGbeInRedRateCompareType.\n         Setting to zero disables the bit rate alarming.\n\n         The APEX updates the bit rate statistics every five seconds.\n\n         Not supported.\n        ')
apexManRteGbeInRedSecRedundMcJoin = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noJoinOnOpen", 1), ("joinOnOpen", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedSecRedundMcJoin.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedSecRedundMcJoin.setDescription('This is not currently supported and is reserved for future use.\n        ')
apexManRteGbeInRedForceSwitchTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 4), )
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchTable.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchTable.setDescription('This table is the Manual Routing Gigabit Ethernet Input Transport\n         Stream Redundancy Configuration Table.  This table contains 768 rows.\n         A row in this table corresponds to the same index in the\n         apexManRteGbeInRedTable.\n        ')
apexManRteGbeInRedForceSwitchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexManRteGbeInRedForceSwitchIndex"))
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchEntry.setDescription('Gigabit Ethernet Input Stream Redundancy Configuration Table Entry.')
apexManRteGbeInRedForceSwitchIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchIndex.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitchIndex.setDescription('The Manual Routing Gbe Input Ts Redundancy Configuration table index.\n         A row in this table corresponds to the same index in the\n         apexManRteGbeInRedTable.')
apexManRteGbeInRedForceSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 1, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNotInProgress", 1), ("forceSwitch", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitch.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedForceSwitch.setDescription("The Gigabit Ethernet Redundant Pair force switch.\n\n         This will have no effect if the corresponding row setting of\n         apexManRteGbeInRedEnable is 'disabled'.\n\n         The corresponding row setting apexManRteGbeInRedSuspend is\n         ignored when 'forceSwitch' is set.  The switch will occur even if\n         apexManRteGbeInRedSuspend is 'suspended'.\n\n         When forced to the Secondary of the pair, the APEX will stay on the\n         Secondary until the user forces back to the Primary.  The APEX will\n         not automatically switch back to the Primary when the Primary is\n         restored above the failover threshold.\n\n         The APEX will not allow a force to the Primary unless the Primary\n         is above the failover threshold.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexManualRouteInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexManualRouteInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexManualRouteInvalidApplyText.setDescription('When apexManualRouteApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of a\n         table entry that was invalid.')
apexManRtePassThroughInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexManRtePassThroughInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexManRtePassThroughInvalidApplyText.setDescription('When apexManRtePassThroughApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of a\n         table entry that was invalid.')
apexManRteGbeInRedInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexManRteGbeInRedInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedInvalidApplyText.setDescription('When apexManRteGbeInRedTableApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of a\n         table entry that was invalid.')
apexManRteGbeInRedStatusMapTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2, 2), )
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapTable.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapTable.setDescription('This table provides the mapping between the indexes in \n         Manual Routing Gigabit Ethernet Input Transport Stream Redundancy Configuration \n         and Input TS Status. This table contains 768 rows. \n         The index in this table corresponds to the same index in the apexManRteGbeInRedTable.\n        ')
apexManRteGbeInRedStatusMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexManRteGbeInRedStatusMapIndex"))
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapEntry.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapEntry.setDescription('Gigabit Ethernet Input Stream Redundancy Configuration and\n         Status Mapping Table Entry.')
apexManRteGbeInRedStatusMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapIndex.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapIndex.setDescription('The Manual Routing Gbe Input Ts Redundancy Configuration and\n         status mapping table index.\n         A index in this table corresponds to the same index in the\n         apexManRteGbeInRedTable.')
apexManRteGbeInRedStatusMapInputTsStatRow = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 784))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapInputTsStatRow.setStatus('current')
if mibBuilder.loadTexts: apexManRteGbeInRedStatusMapInputTsStatRow.setDescription('The Manual Routing Gbe Input TS Status index.\n         This provides the mapping between the entries in apexManRteGbeInRedTable\n         and apexInputTsStatTable.\n         The range of the index is 0 - 784, where 0 indicates no direct association \n         between configuration and status and the 1-784 is the actual Input Stream \n         status row (relative 1).        \n\n         @Config(config=no, reboot=no)\n        ')
apexManualRoutingServiceStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3, 2), )
if mibBuilder.loadTexts: apexManualRoutingServiceStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexManualRoutingServiceStatusTable.setDescription('This table provides the error status for manual routed service routing.\n         For each routing in manual routing table, the corresponding entry in \n         this table gives the service error status.\n        ')
apexManualRoutingServiceStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexManualRoutingServiceStatusIndex"))
if mibBuilder.loadTexts: apexManualRoutingServiceStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexManualRoutingServiceStatusEntry.setDescription('Manual routing service status table entry.')
apexManualRoutingServiceStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexManualRoutingServiceStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexManualRoutingServiceStatusIndex.setDescription('Manual Routing Service Status Index.\n         \n         This index in this table corresponds to the same index in the\n         apexManualRouteTable.')
apexManualRoutingServiceErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 10, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexManualRoutingServiceErrorStatus.setStatus('current')
if mibBuilder.loadTexts: apexManualRoutingServiceErrorStatus.setDescription('Program service error for the service routed in manual routing table.        \n         The entry in this table corresponds to the same index entry in the\n         apexManualRouteTable.\n        ')
apexPidMapTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1), )
if mibBuilder.loadTexts: apexPidMapTable.setStatus('current')
if mibBuilder.loadTexts: apexPidMapTable.setDescription("Table of data for Ancillary Pid Mapping. There are\n         480 rows in this table (APEX supports up to 480 ancillary PID mappings).\n\n         Once written, the change to this table will only take immediate\n         effect after apexPidMapApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPidMapApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexPidMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1), ).setIndexNames((0, "APEX-MIB", "apexPidMapIndex"))
if mibBuilder.loadTexts: apexPidMapEntry.setStatus('current')
if mibBuilder.loadTexts: apexPidMapEntry.setDescription('Pid Mapping Table Entry.')
apexPidMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 480)))
if mibBuilder.loadTexts: apexPidMapIndex.setStatus('current')
if mibBuilder.loadTexts: apexPidMapIndex.setDescription('Index of Pid Mapping Table.')
apexPidMapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapEnable.setStatus('current')
if mibBuilder.loadTexts: apexPidMapEnable.setDescription('Indicates whether this PID Mapping is enabled or disabled.\n        ')
apexPidMapInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputType.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputType.setDescription('Input Type of input from which to obtain data.\n        ')
apexPidMapInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputInterface.setDescription("Number of the input, of type configured by Input Type,\n         from which to obtain data.\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n            FastEnet = 1-2\n        ")
apexPidMapInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputUdp.setDescription('Input UDP Port from which to obtain data.\n\n         Range:\n            GBE      = 0-65535\n            FastEnet = 1024-65535\n        ')
apexPidMapInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputMulticastIp.setDescription('The Multicast receive IP address on which to receive data.\n\n         An IP address of 0.0.0.0 indicates singlecast only.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexPidMapInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputSourceIp.setDescription('This is the IP address of the source device.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexPidMapInputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputPid.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputPid.setDescription('Input MPEG PID to multiplex. When PID Remapping for an output is\n         enabled, the input PID value and output PID value can be different. When\n         PID Remapping for an output is disabled, the input and output PIDs must\n         be the same. Input PID 0 (PAT PID) cannot be mapped by the user.\n        ')
apexPidMapOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexPidMapOutputTsNum.setDescription('Output Transport Stream Number of the output on which to place data.\n         Zero is only valid if the apexPidMapTable entry is not being used.\n        ')
apexPidMapOutputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapOutputPid.setStatus('current')
if mibBuilder.loadTexts: apexPidMapOutputPid.setDescription('Output PID to use for the data. This output PID value must match the input\n         PID value when PID Remapping for the output stream is disabled.\n         Zero is only valid if the apexPidMapTable entry is not being used.\n        ')
apexPidMapApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 2), )
if mibBuilder.loadTexts: apexPidMapApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexPidMapApplyTable.setDescription('Table of Apply Change for the data for PID Map Table.\n\n         A row in this table corresponds to the same row index in the\n         PID Map table.\n        ')
apexPidMapApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexPidMapApplyIndex"))
if mibBuilder.loadTexts: apexPidMapApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexPidMapApplyEntry.setDescription('PID Map Apply Table Entry.')
apexPidMapApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 480)))
if mibBuilder.loadTexts: apexPidMapApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexPidMapApplyIndex.setDescription('The index of the PID Map Apply Table.')
apexPidMapApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexPidMapApplyChange.setDescription("The Apply for the row of data in the PID Map Table.\n\n         A row in this table corresponds to the same row index in the\n         PID Map table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the PID Map Table row to take effect in the APEX.  This\n         parameter MUST be set LAST after all other data in the PID Map\n         Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexBulkPidMapTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3), )
if mibBuilder.loadTexts: apexBulkPidMapTable.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapTable.setDescription("Table of data for Ancillary Bulk Pid Mapping. Apex supports 480\n         ancillary PID map routings. There are 480 rows in this table which\n         allows user to configure upto 480*48 PID configurations, but only\n         480 ancillary PID mappings will be routed on apex.\n         \n         Once written, the change to this table will only take immediate\n         effect after apexBulkPidMapApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexBulkPidMapApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexBulkPidMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexBulkPidMapIndex"))
if mibBuilder.loadTexts: apexBulkPidMapEntry.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapEntry.setDescription('Bulk Pid Mapping Table Entry.')
apexBulkPidMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 480)))
if mibBuilder.loadTexts: apexBulkPidMapIndex.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapIndex.setDescription('Index of Bulk Pid Mapping Table. This index maps with apexBulkPidMapApplyIndex\n         Also, defines this table row size\n        ')
apexBulkPidMapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapEnable.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapEnable.setDescription('Indicates whether this Bulk PID Mapping entry is enabled or disabled.\n        ')
apexBulkPidMapInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputType.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputType.setDescription('Input Type. Indicates if mapping is from gigabit ethernet or fast ethernet\n        ')
apexBulkPidMapInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputInterface.setDescription("Number of the input, of type configured by Input Type,\n         from which to obtain data.\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n            FastEnet = 1-2\n        ")
apexBulkPidMapInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputUdp.setDescription('Input UDP Port from which to obtain data.\n\n         Range:\n            GBE      = 0-65535\n            FastEnet = 1024-65535\n        ')
apexBulkPidMapInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputMulticastIp.setDescription('The Multicast receive IP address on which to receive data.\n         An IP address of 0.0.0.0 indicates singlecast only.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexBulkPidMapInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputSourceIp.setDescription('This is the IP address of the source device.\n\n         If the router supports IGMP v3 the GBE will only receive data from\n         this source IP.  If Source IP is not specified or the router does not\n         support IGMP v3 the GBE will receive data from any source device.\n         Source IP address must be a valid singlecast address.\n        ')
apexBulkPidMapInputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapInputPid.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInputPid.setDescription('Input MPEG PID to multiplex. When PID Remapping for an output is\n         enabled, the input PID value and output PID value can be different. When\n         PID Remapping for an output is disabled, the input and output PIDs must\n         be the same. Input PID 0 (PAT PID) cannot be mapped by the user.\n         \n         Zero is only valid if the apexBulkPidMapTable entry is not being used.\n        ')
apexBulkPidMapOutputTsNum01to32 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapOutputTsNum01to32.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapOutputTsNum01to32.setDescription('Bitfield for inserting PID streams into OTS 1 through 32 where:\n         bit 0(lsb) = OTS 1, bit 31(msb) = OTS 32. If the bit for the OTS\n         is set, then the current PID is inserted into the output.\n        ')
apexBulkPidMapOutputTsNum33to48 = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 10), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapOutputTsNum33to48.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapOutputTsNum33to48.setDescription('Bitfield for inserting PID streams into OTS 33 through 48 where:\n         bit 0(lsb) = OTS 33, bit 15 = OTS 48. If the bit for the OTS\n         is set, then the current PID is inserted into the output.\n         Other bits are reserved.\n        ')
apexBulkPidMapOutputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapOutputPid.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapOutputPid.setDescription('Output PID to use for the data. This output PID value must match the input\n         PID value when PID Remapping for the output stream is disabled.\n         \n         Zero is only valid if the apexBulkPidMapTable entry is not being used.\n        ')
apexBulkPidMapApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 4), )
if mibBuilder.loadTexts: apexBulkPidMapApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapApplyTable.setDescription('Table of Apply Change for the data for Bulk PID Map Table\n         (apexBulkPidMapTable).\n\n         A row in this table corresponds to the same row index in the\n         Bulk PID Map table.\n        ')
apexBulkPidMapApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexBulkPidMapApplyIndex"))
if mibBuilder.loadTexts: apexBulkPidMapApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapApplyEntry.setDescription('Bulk PID Map Apply Table Entry.')
apexBulkPidMapApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 480)))
if mibBuilder.loadTexts: apexBulkPidMapApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapApplyIndex.setDescription('The index of the bulk PID map Apply Table.\n         A row in this table corresponds to the same row index in the\n         entry in bulk PID map table.')
apexBulkPidMapApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 4, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexBulkPidMapApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapApplyChange.setDescription("The Apply for the row of data in the Bulk PID Map Table.\n\n         A row in this table corresponds to the same row index in the\n         Bulk PID Map table.\n\n         This paramter MUST be set to 'apply' in order for any of the data\n         in apexBulkPidMapTable row to take effect in the APEX. If\n         apexBulkPidMapTable is valid, host sets apexBulkPidMapApplyChange to\n         applyNotInProgressValidData. Otherwise, host sets apexPidMapApplyChange\n         to applyNotInProgressInvalidData. Also updates the parameter\n         apexBulkPidMapInvalidApplyText with text description of what is\n         wrong with changing apexBulkPidMapTable.\n        ")
apexPidMapConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 5, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexPidMapConfigApplyChange.setDescription("This paramter MUST be set to 'apply' in order for any of the\n         data in apexPidMapConfigBulkPidEnable to effect. If enabled, host\n         deletes the pid mappings created based on apexPidMapTable and creates\n         based on apexBulkPidMapTable. If disabled, host deletes the pid mappings\n         created based on apexBulkPidMapTable and creates based on apexPidMapTable\n         \n         Host after creating pid mapping, sets apexPidMapApplyChange with\n         applyNotInProgressValidData when the entry is successfully created.\n         Host sets the apply change to applyNotInProgressInvalidData when any error\n         occurs when PID mapping entry is created or when the apexPidMapConfigBulkPidEnable\n         is set with unknown value.\n         \n         @Config(config=no, reboot=no)\n        ")
apexPidMapConfigBulkPidEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 5, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapConfigBulkPidEnable.setStatus('current')
if mibBuilder.loadTexts: apexPidMapConfigBulkPidEnable.setDescription("When enabled, this parameter indicates the host to route ancillary PIDs based\n         on apexBulkPidMapTable. When disabled, this parameter indicates the host to\n         route ancillary PIDs based on apexPidMapTable.\n         \n         Once written, a change to apexPidMapConfigBulkPidEnable, will\n         only take effect after the appropriate apexPidMapConfigApplyChange\n         is set to 'apply'. In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPidMapConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPidMapInputAncillaryPidDetectionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 1, 6, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPidMapInputAncillaryPidDetectionTimeout.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInputAncillaryPidDetectionTimeout.setDescription("The loss of input ancillary PID detection timeout value in minutes. \n         The APEX will monitor for the configured number of minutes to check\n         whether atleast one TS packet for an input ancillay PID is received.\n         If no packet is received the APEX will raise the alarm \n         'apexAlarmLossOfInputAncillaryPid' and sends event\n         'apexEventLossOfInputAncillaryPid'. Each ancillary PID previously\n         received will be checked to determine that it is still being received\n         based on this setting.\n         \n         Default value is 1 minute.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPidMapMaxPidMappings = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPidMapMaxPidMappings.setStatus('current')
if mibBuilder.loadTexts: apexPidMapMaxPidMappings.setDescription('Maximum number of Ancillary PID mappings supported.')
apexPidMapInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPidMapInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexPidMapInvalidApplyText.setDescription('When apexPidMapApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of a\n         table entry that was invalid.')
apexBulkPidMapInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 11, 2, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexBulkPidMapInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexBulkPidMapInvalidApplyText.setDescription('When apexBulkPidMapApplyChange is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply of a\n         table entry that was invalid.\n        ')
apexInsertionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("efficient", 1), ("singleSection", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexInsertionMode.setStatus('current')
if mibBuilder.loadTexts: apexInsertionMode.setDescription("This parameter is used to set the insertion mode for the APEX.\n         The APEX may be configured to insert messages as efficiently as\n         possible (efficient) or restrict insertion to a single section\n         starting per packet (singleSection).\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexInsertPacketStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 2), )
if mibBuilder.loadTexts: apexInsertPacketStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: apexInsertPacketStatisticsTable.setDescription('Table of Output Transport Stream Insert Packet Statistics.\n         Indexed by Output Transport Stream number.')
apexInsertPacketStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexInsertPacketStatOutputTsNum"))
if mibBuilder.loadTexts: apexInsertPacketStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: apexInsertPacketStatisticsEntry.setDescription('A row in the Output Transport Stream Insert Packet Statistics table.')
apexInsertPacketStatOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexInsertPacketStatOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexInsertPacketStatOutputTsNum.setDescription('Output Transport Stream Number.')
apexInsertPacketStatTotPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInsertPacketStatTotPkts.setStatus('current')
if mibBuilder.loadTexts: apexInsertPacketStatTotPkts.setDescription('Total number of packets inserted.')
apexInsertPacketStatNumPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 12, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInsertPacketStatNumPkts.setStatus('current')
if mibBuilder.loadTexts: apexInsertPacketStatNumPkts.setDescription('Number of packets inserted during the last monitoring\n         period (currently 5 seconds).')
apexInputTsStatTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2), )
if mibBuilder.loadTexts: apexInputTsStatTable.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatTable.setDescription('Table of Input Transport Stream Status data. For each input stream\n         in use, an entry in this row will be utilized. This table will indicate\n         the input stream in use by type, interface, UDP, multicast IP, and Source\n         IP address. This table will also indicate if the input stream is a Primary\n         or Secondary input stream.\n\n         Table of 768 GigE entries plus 16 Host entries (784 total input\n         entries). List of GigE and Host Ethernet input streams currently\n         in use. Each row contains an entry for Primary and Secondary\n         information along with the 1 currently in use.\n        ')
apexInputTsStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexInputTsStatIndex"))
if mibBuilder.loadTexts: apexInputTsStatEntry.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatEntry.setDescription('Input Transport Stream Status Table Entry.')
apexInputTsStatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 784)))
if mibBuilder.loadTexts: apexInputTsStatIndex.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatIndex.setDescription('Index of Input Transport Stream Status Table.')
apexInputTsStatStreamInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatStreamInUse.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatStreamInUse.setDescription('Indicates whether the primary or secondary is in use. Zero\n         indicates this row is not in use.\n        ')
apexInputTsStatInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatInputType.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatInputType.setDescription('Input Type of both primary and secondary inputs.\n        ')
apexInputTsStatRoutingType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("session", 1), ("manual", 2), ("udpMapping", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatRoutingType.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatRoutingType.setDescription("Routing Type of both primary and secondary inputs.\n\n         'session' - applies to SDV session routes (RPC, RTSP).\n         'manual'  - applies to all manual routes (Manual Routing, PID\n                     Mapping, and stream pass through).\n         'udpMapping - applies to UDP Port Mapping routes.\n        ")
apexInputTsStatPriState = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 5), InputTsStateTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatPriState.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatPriState.setDescription("The current state of the primary Gigabit Ethernet Input TS configured\n         in apexManRteGbeInRedTable.  States are:\n            closed              (0) - Input TS is closed or table row is not in use.\n            openedInUse         (1) - Input TS is opened and in use.\n            openedBackup        (2) - Input TS is opened as backup only.\n            openedTransToBackup (3) - Input TS is opened, transitioning to backup state.\n            openedTransToInUse  (4) - Input TS is opened, transitioning to in use state.\n\n         The states of 'openedBackup', 'openedTransToBackup', and 'openedTransToBackup'\n         apply only to Redundant Pairs.  The state of\n         'openedBackup' applies to the Input TS of the pair that is not currently in\n         use.  The state of 'openedTransToBackup' applies to the Input TS of the pair\n         that is currently in use but is transitioning to be the backup, as when a Fail\n         Over or Switch Back is occurring.  The state of 'openedTransToInUse' applies\n         to the Input TS of the pair that is currently the backup use but is\n         transitioning to be the in use, as when a Fail Over or Switch Back is\n         occurring.\n        ")
apexInputTsStatPriInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatPriInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatPriInputInterface.setDescription('Number of the primary input interface of type Input Type.\n        ')
apexInputTsStatPriInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatPriInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatPriInputUdp.setDescription('Input UDP Port for primary input.\n        ')
apexInputTsStatPriInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatPriInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatPriInputMulticastIp.setDescription('The Multicast receive IP address for primary input.\n        ')
apexInputTsStatPriInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatPriInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatPriInputSourceIp.setDescription('This is the IGMP v3 Source IP address of the source device for the primary input.\n        ')
apexInputTsStatSecState = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 10), InputTsStateTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatSecState.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatSecState.setDescription("The current state of the secondary Gigabit Ethernet Input TS configured\n         in apexManRteGbeInRedTable.  States are:\n            closed              (0) - Input TS is closed or table row is not in use.\n            openedInUse         (1) - Input TS is opened and in use.\n            openedBackup        (2) - Input TS is opened as backup only.\n            openedTransToBackup (3) - Input TS is opened, transitioning to backup state.\n            openedTransToInUse  (4) - Input TS is opened, transitioning to in use state.\n\n         The states of 'openedBackup', 'openedTransToBackup', and 'openedTransToBackup'\n         apply only to Redundant Pairs.  The state of\n         'openedBackup' applies to the Input TS of the pair that is not currently in\n         use.  The state of 'openedTransToBackup' applies to the Input TS of the pair\n         that is currently in use but is transitioning to be the backup, as when a Fail\n         Over or Switch Back is occurring.  The state of 'openedTransToInUse' applies\n         to the Input TS of the pair that is currently the backup use but is\n         transitioning to be the in use, as when a Fail Over or Switch Back is\n         occurring.\n        ")
apexInputTsStatSecInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatSecInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatSecInputInterface.setDescription('Number of the secondary input interface of type Input Type.\n        ')
apexInputTsStatSecInputUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatSecInputUdp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatSecInputUdp.setDescription('Input UDP Port for secondary input.\n        ')
apexInputTsStatSecInputMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatSecInputMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatSecInputMulticastIp.setDescription('The Multicast receive IP address for secondary input.\n        ')
apexInputTsStatSecInputSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatSecInputSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatSecInputSourceIp.setDescription('This is the IGMP v3 Source IP address of the source device for the secondary input.\n        ')
apexInputTsStatRateCompareType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 13, 2, 2, 1, 15), RateComparisonTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInputTsStatRateCompareType.setStatus('current')
if mibBuilder.loadTexts: apexInputTsStatRateCompareType.setDescription('This is the rate in use for comparing input streams.  It is\n         either Information rate or Stream rate.  This applies to monitoring\n         for Bit Rate alarming and monitoring of Redundant Pairs.\n        ')
apexOutputTsUtilMonAlarmThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsUtilMonAlarmThreshold.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilMonAlarmThreshold.setDescription("The threshold, in percent, used to produce the\n         apexAlarmOutputUtilizationFault alarm 'minor' while\n         monitoring Output Transport Stream Bandwidth Utilization.\n         An alarm of 'minor' will occur when this threshold is met\n         or exceeded for apexOutputTsUtilMonSetAlarmDelay.  The alarm\n         will clear after remaining below this threshold for\n         apexOutputTsUtilMonClearAlarmDelay.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOutputTsUtilMonSetAlarmDelay = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsUtilMonSetAlarmDelay.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilMonSetAlarmDelay.setDescription("This is the time in seconds that the Output Transport Stream\n         must be at or exceeding apexOutputTsUtilMonAlarmThreshold before\n         setting the apexAlarmOutputUtilizationFault alarm.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOutputTsUtilMonClearAlarmDelay = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsUtilMonClearAlarmDelay.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilMonClearAlarmDelay.setDescription("This is the time in seconds that the Output Transport Stream\n         must be below apexOutputTsUtilMonAlarmThreshold before\n         clearing the apexAlarmOutputUtilizationFault alarm.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOutputTsUtilizationMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 2), )
if mibBuilder.loadTexts: apexOutputTsUtilizationMonitorTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizationMonitorTable.setDescription('This is a table of configuration parameters for Rate Monitoring\n         of the Output Transport Stream Bandwidth Utilization.  Utilization\n         information is accessed via apexOutputTsUtilizationTable.')
apexOutputTsUtilizationMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsUtilMonOutputTsNum"))
if mibBuilder.loadTexts: apexOutputTsUtilizationMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizationMonitorEntry.setDescription('Output Transport Rate Monitoring Configuration Table Entry.')
apexOutputTsUtilMonOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexOutputTsUtilMonOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilMonOutputTsNum.setDescription('Output Transport Stream Number.')
apexOutputTsUtilMonResetTotDropPacket = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 4, 2, 1, 2), ResetStatisticsTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsUtilMonResetTotDropPacket.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilMonResetTotDropPacket.setDescription("Output Ts Reset total dropped packets.\n\n         Setting to 'reset' resets same apexOutputTsUtilizTotalDropPackets\n         index row in apexOutputTsUtilizationTable.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexOutputTsConfApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 5), )
if mibBuilder.loadTexts: apexOutputTsConfApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfApplyTable.setDescription('Table of Apply Change for Output Ts Config Table.\n\n         This apply is only used for apexOutputTsConfOperatingMode,\n         apexOutputTsConfEncryptionType, and apexOutputTsConfSimulcryptMode.')
apexOutputTsConfApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsConfApplyIndex"))
if mibBuilder.loadTexts: apexOutputTsConfApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfApplyEntry.setDescription('Output Transport Stream Apply Table Entry.')
apexOutputTsConfApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexOutputTsConfApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfApplyIndex.setDescription('Index of Output Transport Stream Apply Table.')
apexOutputTsConfApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 5, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfApplyChange.setDescription("The apply for Output Ts Config Table.  This apply is only used for\n         apexOutputTsConfOperatingMode, apexOutputTsConfEncryptionType,\n         and apexOutputTsConfSimulcryptMode.\n\n         A row in this table corresponds to the same row index in the\n         Output Ts Config table.\n\n         This parameter MUST be set to 'apply' in order for the items listed\n         above to take effect in the APEX.  This parameter MUST be set LAST\n         after the relevant data in the Output Ts Config row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexOutputTsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6), )
if mibBuilder.loadTexts: apexOutputTsConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfigTable.setDescription("This is a table of configuration parameters for Output Transport\n         Streams.\n\n         Once written, a change to apexOutputTsConfEncryptionType,\n         apexOutputTsConfOperatingMode, or apexOutputTsConfSimulcryptMode will\n         only take immediate effect after the appropriate apexOutputTsConfApplyChange\n         is set to 'apply'.  All other changes to this table will take immediate effect.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOutputTsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsConfOutputTsNum"))
if mibBuilder.loadTexts: apexOutputTsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfigEntry.setDescription('Output Transport Stream Configuration Table Entry.')
apexOutputTsConfOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexOutputTsConfOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfOutputTsNum.setDescription('Output Transport Stream Number.')
apexOutputTsConfPidRemappingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("remapWithoutReuse", 2), ("remapProgramBased", 3), ("remapProgramBased2", 4), ("unrestricted", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfPidRemappingMode.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfPidRemappingMode.setDescription("The PID Remapping mode setting.\n\n         When 'disabled', the output PIDs for all services and ancillary PIDs\n         are the same as the input PID values. This scheme can only be used\n         when either mapping an entire MPTS to a QAM output or when SPTS are\n         mapped and the user has already ensured that all of the PIDs across\n         all inputs mapped to the same output stream are unique.\n\n         When 'remapWithoutReuse', the APEX will determine the output PIDs\n         from a predetermined range of PIDs for services and ancillary PIDs.\n         The APEX will use a scheme to limit the reuse of service PIDs for each\n         service mapping. This scheme MUST be used for outputs in Session Control\n         mode and in normally in UDP Port Mapping mode (exception noted below).\n         When receiving SPTS inputs, in order to ensure there are no PID conflicts,\n         this scheme should be selected.\n\n         When 'remapProgramBased', the APEX will determine the output PIDs\n         from a predetermined range of PIDs for services and ancillary PIDs.\n         The APEX uses a scheme to select the PMT PID based on the program\n         number. The PMT PID is calculated as follows:\n                (Program Number + 1) * 16.\n\n         The component PIDs are sequential after the PMT PID. This scheme only\n         allows for a total of 15 component PIDs per program. Output program\n         numbers are also limited (1-256). This scheme is intended to be used\n         when in UDP Port Mapping mode at specific sites.\n\n         When 'unrestricted', the APEX will allocate output PIDs as long as they are\n         needed using the whole available PIDs range, unlike other pid-remapping modes where\n         PID values are internally pre-allocated for different uses (PMT, components, ECM, ...).\n         This scheme is only recommended for cases when the user need a special pre-assigned\n         EMM pid that can't be configured in the other pid-remapping modes.\n\n         PID Remapping mode changes can only occur when the output is not in use\n         (no service, PID, or stream mapping active to the output).\n        ")
apexOutputTsConfOperatingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notInUse", 0), ("sessionControl", 1), ("manualRouting", 2), ("udpMapping", 3), ("depi", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfOperatingMode.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfOperatingMode.setDescription("This parameter is used to set the operating mode of the output.\n\n         Operating mode changes can only occur when the output is not in use\n         (no service, PID, or stream mapping active to the output).\n         Session Control\n            - User must select either RTSP or RPC to communicate with external\n              resource manager. All service mappings on output are controlled\n              by the external manager.\n            - Only valid when Encryption Type is set to CTE or None\n            - If 'apexEncryptionConfAlgorithm' is set to dvb-csa-simulcrypt, then\n              it is valid only when Simulcrypt Mode is set to None.\n            - PID Remapping mode should be Enabled (Without Reuse)\n\n         Manual Routing\n            - User manually maps each service\n            - Encryption Type can be any valid setting (none, CTE, or Broadcast)\n            - Simulcrypt Mode must be None or External EIS\n\n         UDP Port Mapping\n            - Standard UDP Port Mapping for use with VOD servers. Uses specific\n              algorithm based on UDP Port to determine output program mappings.\n            - Encryption Type must be None or CTE (broadcast not supported)\n            - Simulcrypt Mode must be None or External EIS\n\n         Operating mode changes can only occur when the output is not in use\n         (no service, PID, or stream mapping active to the output).\n\n         @Commit(param=apexOutputTsConfApplyChange, value=2)\n        ")
apexOutputTsConfOutPatTsId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfOutPatTsId.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfOutPatTsId.setDescription('Output Transport Stream ID to use for the output PAT in this Output\n         Transport Stream. Changes to the output PAT TS ID can be made at any\n         time and will cause the output PAT to automatically be updated to\n         reflect the new TS ID setting.\n        ')
apexOutputTsConfPsipEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 5), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfPsipEnable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfPsipEnable.setDescription('This parameter indicates that PSIP is enabled for the Output\n         Transport Stream.\n        ')
apexOutputTsConfEncryptionType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noEncryption", 0), ("cte", 1), ("broadcastEncryption", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfEncryptionType.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfEncryptionType.setDescription("This parameter is used to set the encryption type of the output.\n\n         'noEncryption'\n            - All services are output in the clear\n\n         'cte'\n            - Services on output use Common Tier Encryption. CTE parameters\n              determine encryption mode, copy protection, and tiers. All services\n              in CTE mode use the exact same configuration settings.\n            - Valid for all operating modes\n            - Simulcrypt Mode must be set to None if the Encryption Algorithm \n              is set to 'dvb-csa-simulcrypt'.\n\n         'broadcastEncryption'\n            - Services on output use Broadcast Encryption. Requires connection to\n              RDS (DAC) to get EMMs and Rights Meta Data (tiers, encryption mode, and\n              copy protection settings) for each individual service.\n            - Only valid when Operating Mode is Manual Routing.\n            - Simulcrypt Mode must be set to None if the Encryption Algorithm \n              is set to 'dvb-csa-simulcrypt'.\n\n            @Commit(param=apexOutputTsConfApplyChange, value=2)\n        ")
apexOutputTsConfSimulcryptMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("externalEIS", 1), ("internalEIS", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfSimulcryptMode.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfSimulcryptMode.setDescription("This parameter is used to set the Simulcrypt mode of the output. The actual\n         behavior is disable/enable (none/externalEIS). It can be set to externalEIS\n         if:\n            - The Encryption Algorithm is set to 'dvb-csa-simulcrypt' and the Operating\n               Mode is set to 'ManualRouting' or 'udpMapping'. \n            - The Encryption Algorithm is set to 'mc-scte-52-simulcrypt' or \n               'mc-csa-simulcrypt' and the Operating Mode is set to 'ManualRouting',\n               'udpMapping' or 'SessionControl'.\n            \n         It only can be none if there are no SCGs provisioned on that output TS.\n\n         'none'\n            - Used for normal Mediacypher only encryption (CTE or Broadcast Encryption).\n\n         'externalEIS'\n            - When Encryption Algorithm is set to 'dvb-csa-simulcrypt', it is \n              used to indicate an external EIS can control the encryption of all \n              services on the output.\n            - When Encryption Algorithm is set to 'mc-scte-52-simulcrypt' or \n              'mc-csa-simulcrypt', it is used to indicate that APEX will act as\n              the EIS to control encryption of all services on the output.\n            - Only valid when:\n               - Encryption Algorithm is set to 'dvb-csa-simulcrypt' and \n                 Operating Mode is set to 'ManualRouting' or 'udpMapping'\n               - Encryption Algorithm is set to 'mc-scte-52-simulcrypt' or \n                 'mc-csa-simulcrypt' and the Operating Mode is set to \n                 'ManualRouting', 'udpMapping' or 'SessionControl'.\n\n         'internalEIS'\n            - Not supported at this time and is invalid to select.\n\n            @Commit(param=apexOutputTsConfApplyChange, value=2)\n        ")
apexOutputTsConfPcrLess = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 8), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfPcrLess.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfPcrLess.setDescription('This parameter indicates that PCR-less is enabled for the Output\n         Transport Stream.\n        ')
apexOutputTsConfAutoSDTEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 1, 6, 1, 9), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexOutputTsConfAutoSDTEnable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsConfAutoSDTEnable.setDescription('This parameter enables/disables the Auto SDT mapping feature for the Output\n         Transport Stream.\n        ')
apexOutputTsStatusInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusInvalidApplyText.setDescription("When apexOutputTsConfApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexOutputTsUtilizationSamplePeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizationSamplePeriod.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizationSamplePeriod.setDescription('Sample Period for Output Transport Stream Bandwidth Utilization\n         Rate Monitoring.\n         This parameter indicates the length of time in milliseconds the\n         stream is monitored during a single sample.\n         This can be used with apexOutputTsUtilizNumSamples to\n         determine the amount of time or percent of time the stream was\n         monitored during a fifteen minute sampling interval.')
apexOutputTsUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2), )
if mibBuilder.loadTexts: apexOutputTsUtilizationTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizationTable.setDescription('This is a table of status parameters containing bandwidth\n         utilization for Output Transport Streams.  The sampling\n         interval is up to fifteen minutes.  There is a rolling\n         average as well as last sample, peak, and minimum information.\n         There is overflow information and dropped packet counts.\n\n         This table is indexed by Output Transport Stream Number.')
apexOutputTsUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsUtilizOutpuTsNum"))
if mibBuilder.loadTexts: apexOutputTsUtilizationEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizationEntry.setDescription('Output Transport Stream Bandwidth Utilization Table Entry.')
apexOutputTsUtilizOutpuTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexOutputTsUtilizOutpuTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizOutpuTsNum.setDescription('Output Transport Stream Number.')
apexOutputTsUtilizDataFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("samplingComplete", 1), ("samplingIncomplete", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizDataFlag.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizDataFlag.setDescription("Flag to indicate whether the Output Transport Stream was monitored\n         a full fifteen minute sampling interval and a complete set of samples\n         was obtained.\n\n         'samplingComplete'   - indicates sampling complete with good samples.\n         'samplingIncomplete' - indicates incomplete sampling due to APEX\n                                startup or OTS rate changed during the period.")
apexOutputTsUtilizNumSamples = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizNumSamples.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizNumSamples.setDescription('Number of samples included in the data.\n         This can be used with apexOutputTsUtilizationSamplePeriod\n         to determine the amount of time or percent of time the\n         stream was monitored during the sampling interval.')
apexOutputTsUtilizThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("noError", 1), ("alarmThresholdReached", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizThreshold.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizThreshold.setDescription('Indicates whether there is a utilization error has occurred.\n         The error occurs when Output Utilization Alarm Threshold has\n         been reached for Output Utilization Set Alarm Delay seconds\n         and will clear after the output is below the Output Utilization\n         Alarm Threshold for Output Utilization Clear Alarm Delay.  This\n         field is also cleared when the QAM output is disabled.')
apexOutputTsUtilizTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizTime.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizTime.setDescription('Time in GPS seconds (apexSystemTime) that this table row was saved.\n         When GPS time is not available to the apex (apexSystemTime=0) a clock\n         maintained inside the APEX will be used.  This clock starts at GPS time\n         zero when the apex is booted.  The APEX will use real GPS time if and\n         when GPS time becomes available to the APEX.')
apexOutputTsUtilizCurPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizCurPercent.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizCurPercent.setDescription('Percent utilization of most recently taken sample.')
apexOutputTsUtilizAvgPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizAvgPercent.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizAvgPercent.setDescription('Average percent utilization over the rolling sampling interval.')
apexOutputTsUtilizMinPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizMinPercent.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizMinPercent.setDescription('Minimum percent utilization for a sample during the rolling\n         sampling interval.')
apexOutputTsUtilizPeakPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizPeakPercent.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizPeakPercent.setDescription('Peak percent utilization for a sample during the rolling\n         sampling interval.')
apexOutputTsUtilizCurRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizCurRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizCurRate.setDescription('Utilization of most recently taken sample\n         in bits per second (bps).')
apexOutputTsUtilizAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizAvgRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizAvgRate.setDescription('Average utilization for the rolling sampling interval\n         in bits per second (bps).')
apexOutputTsUtilizMinRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizMinRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizMinRate.setDescription('Minimum utilization for a sample during this\n         sampling interval in bits per second (bps).')
apexOutputTsUtilizPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizPeakRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizPeakRate.setDescription('Peak utilization for a sample during the rolling\n         sampling interval in bits per second (bps).')
apexOutputTsUtilizOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("noError", 1), ("overflow", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizOverflow.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizOverflow.setDescription('Indicates whether an overflow error has occurred.\n         This field will clear if the output has no overflows.\n         This field is also cleared when the QAM output is\n         disabled.')
apexOutputTsUtilizCurDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizCurDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizCurDropPackets.setDescription('MPEG packets dropped during the most recently\n         taken sample.')
apexOutputTsUtilizPeakDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizPeakDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizPeakDropPackets.setDescription('Peak MPEG packets dropped for a sample during the\n         rolling sampling interval.')
apexOutputTsUtilizRollingDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizRollingDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizRollingDropPackets.setDescription('Total MPEG packets dropped during the rolling sampling interval.')
apexOutputTsUtilizTotalDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizTotalDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizTotalDropPackets.setDescription('Total MPEG packets dropped on the QAM Output.  Can be\n         reset using apexOutputTsUtilMonResetTotDropPacket.')
apexOutputTsUtilizThresholdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizThresholdAlarm.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizThresholdAlarm.setDescription('Current fault condition of apexOutputTsUtilizThreshold.  This is\n         the apexAlarmOutputUtilizationFault level for this output.')
apexOutputTsUtilizOverflowAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsUtilizOverflowAlarm.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsUtilizOverflowAlarm.setDescription('Current fault condition of apexOutputTsUtilizOverflow.  This is\n         the apexAlarmOutputOverflow level for this output.')
apexOutputTsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5), )
if mibBuilder.loadTexts: apexOutputTsStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusTable.setDescription('Table of Output Transport Status.\n         Indexed by Output Transport Stream number.')
apexOutputTsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsStatusOutputTsNum"))
if mibBuilder.loadTexts: apexOutputTsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusEntry.setDescription('A row in the Output Transport Stream Status table.')
apexOutputTsStatusOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexOutputTsStatusOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusOutputTsNum.setDescription('Output Transport Stream Number.')
apexOutputTsStatusProgramsPerTs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusProgramsPerTs.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusProgramsPerTs.setDescription('Number of Output Programs supported on this Output Transport Stream.\n        ')
apexOutputTsStatusServicesMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusServicesMapped.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusServicesMapped.setDescription('Number of services currently mapped to the output.')
apexOutputTsStatusAncillaryPidsMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusAncillaryPidsMapped.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusAncillaryPidsMapped.setDescription('Number of ancillary PIDs currently mapped to the output.')
apexOutputTsStatusInputStreamsMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusInputStreamsMapped.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusInputStreamsMapped.setDescription('Number of input streams currently mapped to the output.')
apexOutputTsStatusFault = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusFault.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusFault.setDescription('Highest current fault condition associated with this Output\n         Transport Stream.  The following Alarms are included:\n            - apexAlarmOutputOverflow\n            - apexAlarmOutputUtilizationFault\n            - apexAlarmQamModuleFault\n            - apexAlarmQamRfPortFault\n            - apexAlarmQamChannelFault\n        ')
apexOutputTsStatusServicesInError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusServicesInError.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusServicesInError.setDescription('Number of services in error mapped to the output stream.')
apexOutputTsStatusDepiSessionsMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusDepiSessionsMapped.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusDepiSessionsMapped.setDescription('Number of DEPI sessions currently mapped to the output.')
apexOutputTsStatusMessageGenerationNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusMessageGenerationNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusMessageGenerationNum.setDescription('Number of messages generated (DVB tables) currently in the output.')
apexOutputTsStatusScgsProvisioned = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusScgsProvisioned.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusScgsProvisioned.setDescription('Number of SCGs provisioned currently in the output.')
apexOutputTsStatusServicesMuxed = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 14, 2, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsStatusServicesMuxed.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsStatusServicesMuxed.setDescription('Number of services successfully multiplexed.')
apexPsiDetectionEnabled = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiDetectionEnabled.setStatus('current')
if mibBuilder.loadTexts: apexPsiDetectionEnabled.setDescription("The loss of input PSI detection enabled or disabled setting. When enabled,\n         the APEX will check for missing input PSI (PATs and PMTs) based on the PSI\n         detection timeout value. When an input PSI message is determined to be\n         missing, the APEX will assume the input service or services are no longer\n         being streamed and unmap the service(s). This checking only occurs after\n         an initial PSI message has been extracted.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiDetectionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 21600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiDetectionTimeout.setStatus('current')
if mibBuilder.loadTexts: apexPsiDetectionTimeout.setDescription("The loss of input PSI detection timeout value. When PSI detection is enabled,\n         this is the number of seconds the APEX will use to determine if an input PSI\n         message is missing. Each PSI message previously extracted will be checked to\n         determine that it is still being received based on this setting.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiRangeStart = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiRangeStart.setStatus('current')
if mibBuilder.loadTexts: apexPsiRangeStart.setDescription("Minimum PSI version number. Used to limit the APEX to use a specific range\n         of PSI numbers. Set this to 0 to allow the APEX to use the full range of\n         PSI version numbers (requires apexPsiRangeStop to be set to 31).\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiRangeStop = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiRangeStop.setStatus('current')
if mibBuilder.loadTexts: apexPsiRangeStop.setDescription("Maximum PSI version number. Used to limit the APEX to use a specific range\n         of PSI numbers. Set this to 31 to allow the APEX to use the full range of\n         PSI version numbers (requires apexPsiRangeStart to be set to 0).\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPatVersionIncrement = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPatVersionIncrement.setStatus('current')
if mibBuilder.loadTexts: apexPatVersionIncrement.setDescription("Increment of PAT version upon reboot. Used to force the APEX to use a different\n         PAT version number upon rebooting.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPmtVersionIncrement = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPmtVersionIncrement.setStatus('current')
if mibBuilder.loadTexts: apexPmtVersionIncrement.setDescription("Increment of PMT version upon reboot. Used to force the APEX to use a different\n         PMT version number upon rebooting.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEcmEmmFirstPid = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 7591))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEcmEmmFirstPid.setStatus('current')
if mibBuilder.loadTexts: apexEcmEmmFirstPid.setDescription("First ECM-EMM PID when PID Remapping is disabled on an output stream.\n         This PID along with the apexEcmEmmNumberPids defines a range of PIDs that\n         the APEX will use for all ECMs and EMMs. These configuration settings allow\n         a user to select a range that other service and ancillary PIDs will not\n         use. This allows the APEX to use PIDs for ECMs and EMMs without having PID\n         collisions. PID collisions will cause the APEX to select another ECM or EMM\n         PID causing momentary glitches of the output video and audio.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n         ")
apexEcmEmmNumberPids = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEcmEmmNumberPids.setStatus('current')
if mibBuilder.loadTexts: apexEcmEmmNumberPids.setDescription("Number of ECM-EMM PIDs to use when PID Remapping is disabled on an output stream.\n         Refer to the apexEcmEmmFirstPid parameter for a complete description.\n\n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexProgramBasedPmtOffset = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexProgramBasedPmtOffset.setStatus('current')
if mibBuilder.loadTexts: apexProgramBasedPmtOffset.setDescription("Program Based PID Remapping PMT PID offset. Determines the first\n         PMT PID to use when Program Based algorithm selected. PMT PID\n         is calculated as:\n            (Program Number + Offset) * 16\n         \n         Program Numbers can range from 1 - 255, allowing for PMTs to start\n         at 0x0020 or 0x0030 up to 0x1000 and 0x1010. \n\n         Changes to offset will NOT require a reboot, but if there are \n         any service mappings already in use on an output in \n         Program Based mode, then the change will NOT take effect and the \n         user will have to remove all mappings on outputs in Program \n         Based mode.\n         \n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiCcErrorDetectionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiCcErrorDetectionTimeout.setStatus('current')
if mibBuilder.loadTexts: apexPsiCcErrorDetectionTimeout.setDescription("Time in seconds to wait for PSI extraction after a CC error is detected.\n\t This is applicable if the object apexPsiCcErrorDetectionEnabled is set to\n\t enabled only.\n\t \n         Default value is 2 seconds.\n\n    \t @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiCcErrorDetectionEnabled = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 1, 1, 11), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsiCcErrorDetectionEnabled.setStatus('current')
if mibBuilder.loadTexts: apexPsiCcErrorDetectionEnabled.setDescription("Enable/disable field to start/stop PSI extraction when a Continuity Counter\n\t error is detected.\n         \n         The PSI extraction is stopped for the time duration configured in the object \n\t apexPsiCcErrorDetectionTimeout.\n\t \n         Default value is enabled.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsiStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2), )
if mibBuilder.loadTexts: apexPsiStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusTable.setDescription('The following table contains a list of messages that are either being extracted\n         from the input side or being inserted to the output side of the apex.  On the\n         input side all extracted messages that are being used by the APEX are displayed.\n         On the output side, only PATs, PMTs, and CATs are displayed.  These messages\n         were either given to the apex when it is in external mode or created by the apex\n         when it is in internal mode.')
apexPsiStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexPsiStatusTableType"), (0, "APEX-MIB", "apexPsiStatusIndex"), (0, "APEX-MIB", "apexPsiStatusPid"), (0, "APEX-MIB", "apexPsiStatusMessageType"), (0, "APEX-MIB", "apexPsiStatusProgramNumber"), (0, "APEX-MIB", "apexPsiStatusSegment"), (0, "APEX-MIB", "apexPsiStatusPart"))
if mibBuilder.loadTexts: apexPsiStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusEntry.setDescription('PSI Table Entry.')
apexPsiStatusTableType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inputPsiTable", 1), ("outputPsiTable", 2))))
if mibBuilder.loadTexts: apexPsiStatusTableType.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusTableType.setDescription('Indicates whether this message is extracted from an input or\n         being inserted on an output.')
apexPsiStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 784)))
if mibBuilder.loadTexts: apexPsiStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusIndex.setDescription('Indicates the input index or output number for which this message applies.\n         For input, this is the index into the apexInputTsStatTable (1..784).\n         For output, this is the Output Transport Stream number (1..48). ')
apexPsiStatusPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191)))
if mibBuilder.loadTexts: apexPsiStatusPid.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusPid.setDescription('Indicates the PID that this message is contained in.')
apexPsiStatusMessageType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: apexPsiStatusMessageType.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusMessageType.setDescription('Indicates the MPEG message type of this message.')
apexPsiStatusProgramNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: apexPsiStatusProgramNumber.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusProgramNumber.setDescription('Indicates the Program Number which this message is part of.  When a\n         message is not specifically related to a program, this value is 0.')
apexPsiStatusSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)))
if mibBuilder.loadTexts: apexPsiStatusSegment.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusSegment.setDescription('Indicates the segment number of this message.  Useful for PAT messages.\n         Otherwise this is 0.')
apexPsiStatusPart = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: apexPsiStatusPart.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusPart.setDescription('Since a message can be 1024 bytes long the message may divided into parts.\n         Each part of the message is indexed using this index.')
apexPsiStatusBody = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsiStatusBody.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusBody.setDescription('Raw ASCII hex of the PSI message.')
apexPsiStatusGpsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 15, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsiStatusGpsTime.setStatus('current')
if mibBuilder.loadTexts: apexPsiStatusGpsTime.setDescription('The GPS time when the PSI was added to the table.')
apexOutputProgramTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2), )
if mibBuilder.loadTexts: apexOutputProgramTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramTable.setDescription('This table shows the input program to output program\n         mapping status.')
apexOutputProgramEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputProgramIndex"))
if mibBuilder.loadTexts: apexOutputProgramEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramEntry.setDescription('Output Program Table Entry.')
apexOutputProgramIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexOutputProgramIndex.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramIndex.setDescription('Output Program Table Index. ')
apexOutputProgramInputTsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramInputTsIndex.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramInputTsIndex.setDescription('The index into the apexInputTsStatTable.')
apexOutputProgramInputProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramInputProgNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramInputProgNum.setDescription('Input MPEG Program Number.')
apexOutputProgramOutputProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramOutputProgNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramOutputProgNum.setDescription('Output MPEG Program Number.')
apexOutputProgramRoutingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramRoutingStatus.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramRoutingStatus.setDescription('Current Program Routing Status.')
apexOutputProgramInputPreEncrypted = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("clear", 1), ("preEncrypted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramInputPreEncrypted.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramInputPreEncrypted.setDescription('Indicates whether the program was pre-encrypted.\n         Pre-encryption status is determined by the presence or\n         absence of a CA ECM descriptor within the input PMT.')
apexOutputProgramOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramOutputTsNum.setDescription('Output Transport Stream Number.')
apexOutputProgramError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramError.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramError.setDescription('Indicates if the program is in error.')
apexOutputProgramEncryptionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("full", 1), ("fwk", 2), ("fpk", 3), ("clear", 4), ("unencrypted", 5), ("preEncrypted", 6), ("unencryptedWithCci", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramEncryptionMode.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramEncryptionMode.setDescription('Currently configured encryption mode for the program.\n         none - indicates the program is not being encrypted for\n           CTE or Broadcast encryption.\n         unencrypted - Applies to Broadcast services only. Unencrypted\n           services are treated the same as clear services (no encryption).\n         preEncrypted - Applies to Broadcast services only. Input\n           program pre-encryption checking is applied. Output program is\n           not encrypted by the APEX, regardless if input encrypted or not.\n         unencryptedWithCci - True unencrypted mode where packets are not\n           scrambled, but ECMs are inserted and ECM CA reference is added\n           to output PMT (PRK contains Copy Protection information).')
apexOutputProgramEncryptionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramEncryptionStatus.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramEncryptionStatus.setDescription('Current Program Encryption Status.')
apexOutputProgramEcmServiceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramEcmServiceId.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramEcmServiceId.setDescription('The ECM service ID used when this program is encrypted. This\n         is the service ID used in all ECM messages for this program.')
apexOutputProgramCciLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("notDefined", 1), ("copyFreely", 2), ("copyOnce", 3), ("copyNever", 4), ("noMoreCopies", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCciLevel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCciLevel.setDescription('Copy protection CCI Level. This is only applicable when the\n         program is being encrypted.')
apexOutputProgramApsLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("notDefined", 1), ("off", 2), ("splitBurstOff", 3), ("splitBurst2Line", 4), ("splitBurst4Line", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramApsLevel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramApsLevel.setDescription('Copy protection Analog Protection Services Level. This is only\n         applicable when the program is being encrypted.')
apexOutputProgramCitSetting = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCitSetting.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCitSetting.setDescription('Copy protection Constraint Image Trigger setting. This is only\n         applicable when the program is being encrypted.')
apexOutputProgramNumberTiers = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramNumberTiers.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramNumberTiers.setDescription('The number of program tiers. This is only applicable when the\n         program is being encrypted.')
apexOutputProgramTierData = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramTierData.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramTierData.setDescription('Current Program Tier Data. Tier information is in\n         hexadecimal format. Up to 7 tiers of information are\n         provided for each program. Tier information for each\n         program consists of 8 bytes of information.\n         First 4 bytes are the program tier value in hexadecimal.\n         Next 4 bytes are the tier type in hexadecimal format.\n         This is only applicable when the program is being encrypted.')
apexOutputProgramSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramSourceId.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramSourceId.setDescription("Broadcast Encryption Source ID.\n\n         Only applies to programs when the input type is Gbe and the\n         output encryption mode is Broadcast Encryption.\n         (apexOutputTsConfEncryptionType set to 'broadcastEncryption')\n        ")
apexOutputProgramProviderId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramProviderId.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramProviderId.setDescription("Broadcast Encryption Provider ID.\n\n         Only applies to programs when the input type is Gbe and the\n         output encryption mode is Broadcast Encryption.\n         (apexOutputTsConfEncryptionType set to 'broadcastEncryption')\n        ")
apexOutputProgramProgramType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("programsDerived", 1), ("programInfoProvided", 2), ("programEcmProvided", 3), ("programInfoAndEcmProvided", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramProgramType.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramProgramType.setDescription("Indicates how programs are to be built by the encryptor.\n\n         1 - programsDerived (default) - programs are derived where the encryptor\n             builds the programs internally for the specified service.  \n             The program related ECM messages and program name/info messages are \n             derived from the service RMD data and internal schedules.  \n             This program type is typically used for subscription services.\n         2 - programInfoProvided - the encryptor should build the programs based \n             on the program information provided by the controller via the \n             <programInfo> element of the ServiceProgramReply payload.  \n             The service RMD data is still used to generate the program related \n             ECM messages.\n         3 - programEcmProvided -  the encryptor should use pre-built ECM program\n             messages as provided by the controller via the <programEcm> element \n             of the ServiceProgramReply payload.  For this program type, the \n             controller provides the schedules; however, the encryptor must default \n             much of the program info message since not detailed program information \n             is provided.  DTA content protection encryption makes use of the \n             'programEcmProvided' program type since the ECM messages cannot be \n             derived by the encryptor. \n         4 - programInfoAndEcmProvided - the encryptor should build the programs \n             based on both the program information and pre-built ECM messages \n             provided by the controller via the <programInfo> and <programEcm> \n             elements of the ServiceProgramReply payload.\n        ")
apexOutputProgramDtaEncryptionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("dtaWithCcm", 1), ("dtaWithoutCcm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramDtaEncryptionMode.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramDtaEncryptionMode.setDescription("This parameter identifies whether a service in Full Encryption is\n         in Modified Privacy Mode (DTA) and whether the DTA service has CCM\n         messages. \n         This parameter is applicable only when apexOutputProgramEncryptionMode\n         is 'full'.  In other encryption modes this value is ignored.\n         notApplicable - Non DTA Service and/or No DTA CA descriptor found\n         dtaWithCcm    - DTA, Full Encryption, Modified Privacy Mode, CCM present\n         dtaWithoutCcm - DTA, Full Encryption, Modified Privacy Mode, CCM absent.\n        ")
apexOutputProgramMcSimAccessCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteria.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteria.setDescription("MC SimulCrypt Access Criteria.\n         This is only applicable when 'apexEncryptionConfAlgorithm' is set to\n         either mc-scte-52-simulcrypt or mc-csa-simulcrypt.\n        ")
apexOutputProgramMcSimAccessCriteriaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notRequired", 0), ("retrievedAC", 1), ("waitingForAC", 2), ("invalidAC", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteriaStatus.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteriaStatus.setDescription("SimulCrypt Access Criteria Status.\n         This is only applicable when 'apexEncryptionConfAlgorithm' is set to\n         either mc-scte-52-simulcrypt or mc-csa-simulcrypt.\n        ")
apexOutputProgramCurrentCSN = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCurrentCSN.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCurrentCSN.setDescription('Current Category Sequence Number.\n         This is Category Sequence Number which is used for encrypt the current service.\n\t\t The valid range is 0 to 255 and -1 is for NOT Applicable.\n\t\t This is not applicable for broadcast unencrypted, pre-encrypted , CTE clear services \n\t\t and for the services which MC encryption type is NONE.\n        ')
apexOutputProgramMcSimAccessCriteriaString = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 16, 2, 2, 1, 24), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteriaString.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramMcSimAccessCriteriaString.setDescription('Access Criteria used in the ECMG CW Provision Request \n         when MC SimulCrypt is enabled.\n         \n         An empty string means the Access Criteria (AC) \n         is not being used.\n        ')
apexAcpStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2), )
if mibBuilder.loadTexts: apexAcpStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexAcpStatusTable.setDescription('This table shows the status of the Control Word Generating ACPs.')
apexAcpStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexAcpStatusIndex"))
if mibBuilder.loadTexts: apexAcpStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexAcpStatusEntry.setDescription('Output Program Table Entry.')
apexAcpStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexAcpStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexAcpStatusIndex.setDescription('Acp Status Index. Index for one of six control word generating ACPs.')
apexAcpUnitAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAcpUnitAddress.setStatus('current')
if mibBuilder.loadTexts: apexAcpUnitAddress.setDescription('The unit address of the ACP in ASCII Hex.  The Unit address is a 5 byte value.')
apexAcpHealthByte = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAcpHealthByte.setStatus('current')
if mibBuilder.loadTexts: apexAcpHealthByte.setDescription('The health byte of the ACP.  Indicates whether the ACP has intact fuses.  The\n         health should read 255 (hex 0xFF) for all APEX ACPs.  Otherwise, the ACP will\n         not properly function.')
apexAcpEvenCsn = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAcpEvenCsn.setStatus('current')
if mibBuilder.loadTexts: apexAcpEvenCsn.setDescription('The Even Category Sequence Number of the ACP.\n         Should match the even CSN assigned by DAC,\n         if not may indicate a communications problem.')
apexAcpOddCsn = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAcpOddCsn.setStatus('current')
if mibBuilder.loadTexts: apexAcpOddCsn.setDescription('The Odd Category Sequence Number of the ACP.\n         Should match the odd CSN assigned by DAC,\n         if not may indicate a communications problem.')
apexAcpUnitAttribute = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 17, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAcpUnitAttribute.setStatus('current')
if mibBuilder.loadTexts: apexAcpUnitAttribute.setDescription('Unit attribute byte is made available to verify that the MC2.1 was\n         properly unit created during factory production.')
apexUdpMapPreEncryptCheck = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapPreEncryptCheck.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapPreEncryptCheck.setDescription("UDP Mapping pre-encryption checking.\n\n         Indicates if the APEX is to check if input services are pre-encrypted or\n         clear. Pre-encrypted is determined by examining the input PMT for a CA ECM\n         descriptor (any CA ECM descriptor). If pre-encrypted, setting this flag will\n         cause the APEX to pass through ECM PID for the service. For input services\n         that have a GI CA ECM descriptor, the APEX will also pass through the PIT\n         message (extract and re-insert the PIT). The output PMT for pre-encrypted\n         services will contain a CA ECM descriptor (referencing the ECM\n         PID). When PID Remapping is enabled, pre-encryption for a service is\n         only valid when the input ECM PID is on a different PID than the\n         associated PMT PID. If this flag is set to pre-encryption and the\n         input service is not pre-encrypted, then the setting of this flag has\n         no affect on the output service.\n\n         Once written, the change to this parameter will take immediate\n         effect and all mappings will be removed.  Mappings will not be\n         re-added until apexUdpMapApplyChange is set to 'apply' for\n         all transport streams.  In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapModeBits = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapModeBits.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapModeBits.setDescription("Value that will be placed in the two MSBs of each the calculated UDP\n         port number (bits 14 and 15).\n\n         Once written, the change to this parameter will take immediate\n         effect and all mappings will be removed.  Mappings will not be\n         re-added until apexUdpMapApplyChange is set to 'apply' for\n         all transport streams.  In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapTsOffset = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapTsOffset.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapTsOffset.setDescription("Used as part of the Standardized UDP Port calculation. Transport Stream\n         index can be relative 0 or relative 1.\n\n         Once written, the change to this parameter will take immediate\n         effect and all mappings will be removed.  Mappings will not be\n         re-added until apexUdpMapApplyChange is set to 'apply' for\n         all transport streams.  In order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapFollowDtcp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 1, 4), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapFollowDtcp.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapFollowDtcp.setDescription("Determines how the copy protection settings (CCI, APS, and CIT) within \n         the PRK will be set.  All outputs in UDP Port Mapping mode will use  \n         this setting for following input DTCP. \n           Disabled - Use CTE configured settings if output in CTE encryption mode\n           Enabled - Follow input DTCP\n         \n         Once written, the change to this parameter will take immediate effect.\n         However, in order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 2), )
if mibBuilder.loadTexts: apexUdpMapApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapApplyTable.setDescription('Table of Apply Change for the data for UDP Map Table.\n\n         A row in this table corresponds to the same row index in the\n         UDP Map table.\n        ')
apexUdpMapApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexUdpMapApplyOutputTsNum"))
if mibBuilder.loadTexts: apexUdpMapApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapApplyEntry.setDescription('UDP Map Apply Table Entry.')
apexUdpMapApplyOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexUdpMapApplyOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapApplyOutputTsNum.setDescription('The index of the Udp Map Apply Table.')
apexUdpMapApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapApplyChange.setDescription("The Apply for the row of data in the Udp Map Table.\n\n         A row in this table corresponds to the same row index in the\n         Udp Map table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the Udp Map Table row to take effect in the APEX.  This\n         parameter MUST be set LAST after all other data in the Udp Map\n         Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexUdpMapTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3), )
if mibBuilder.loadTexts: apexUdpMapTable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapTable.setDescription("Table of data for Udp Mapping. There are\n         48 rows in this table.  Each row corresponds to one\n         QAM channel.\n\n         Once written, the change to this table will only take immediate\n         effect after apexUdpMapApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexUdpMapApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexUdpMapOutputTsNum"))
if mibBuilder.loadTexts: apexUdpMapEntry.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapEntry.setDescription('Udp Mapping Table Entry.')
apexUdpMapOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexUdpMapOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapOutputTsNum.setDescription('Index of Udp Mapping Table.\n        ')
apexUdpMapInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapInputInterface.setDescription("Input GBE port.\n\n         Range:\n            '1 - 4' = GBE port number\n        ")
apexUdpMapStartProgNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapStartProgNum.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapStartProgNum.setDescription('Indicates the first program number in a sequential range of programs\n         that are to be routed to the same output transport stream.\n        ')
apexUdpMapNumberProgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapNumberProgs.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapNumberProgs.setDescription('Indicates the number of programs that are to be mapped to the output\n         transport stream.  One UDP port is opened for each program mapped to\n         the output transport stream.\n        ')
apexUdpMapMulticastTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4), )
if mibBuilder.loadTexts: apexUdpMapMulticastTable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastTable.setDescription("Table of data for UDP Map Multicast. Each entry in\n         this table identifies a Gigabit Ethernet input stream that is\n         used for multicast UDP Port Mapping.\n\n         Once written, the change to this table will only take immediate\n         effect after apexUdpMapMulticastApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexUdpMapMulticastApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(bcmr.ini, type='ini')\n        ")
apexUdpMapMulticastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexUdpMapMulticastIndex"))
if mibBuilder.loadTexts: apexUdpMapMulticastEntry.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastEntry.setDescription('UDP Map Multicast Table Entry.')
apexUdpMapMulticastIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: apexUdpMapMulticastIndex.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastIndex.setDescription('Index of UDP Map Multicast Stream Table.')
apexUdpMapMulticastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastEnable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastEnable.setDescription('Indicates whether this UDP Map Multicast entry is enabled or disabled.\n        ')
apexUdpMapMulticastInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastInterface.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastInterface.setDescription("Number of the input interface (Port number).\n\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n        ")
apexUdpMapMulticastUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastUdp.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastUdp.setDescription('GBE Input UDP Port.\n\n         Range: 0-65535\n        ')
apexUdpMapMulticastMcastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastMcastIp.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastMcastIp.setDescription('The Multicast receive IP address.\n         An IP address of 0.0.0.0 indicates singlecast only.\n\n         Multicast IP addresses 224.0.0.0 to 224.0.0.255 are reserved.\n        ')
apexUdpMapMulticastSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastSourceIp.setDescription('This is the IP address of the source device. This field is only\n         used when a multicast IP address is also specified.\n        ')
apexUdpMapMulticastApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 5), )
if mibBuilder.loadTexts: apexUdpMapMulticastApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastApplyTable.setDescription('Table of Apply Change for the UDP Map Multicast Table.\n\n         A row in this table corresponds to the same row index in the\n         UDP Map Multicast Table (apexUdpMapMulticastTable).\n        ')
apexUdpMapMulticastApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexUdpMapMulticastApplyIndex"))
if mibBuilder.loadTexts: apexUdpMapMulticastApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastApplyEntry.setDescription('UDP Map Multicast Apply Table Entry.')
apexUdpMapMulticastApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)))
if mibBuilder.loadTexts: apexUdpMapMulticastApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastApplyIndex.setDescription('The index of the UDP Map Multicast Table.')
apexUdpMapMulticastApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 1, 5, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUdpMapMulticastApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastApplyChange.setDescription("The Apply for the row of data in the UDP Map Multicast Table.\n\n         A row in this table corresponds to the same row index in the\n         UDP Map Multicast Table.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the UDP Map Multicast Table row to take effect in the APEX.  This\n         parameter MUST be set LAST after all other data in the UDP Map Multicast\n         Table row has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexUdpMapMulticastInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUdpMapMulticastInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapMulticastInvalidApplyText.setDescription("When apexUdpMapMulticastApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexUdpMapStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 2), )
if mibBuilder.loadTexts: apexUdpMapStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapStatusTable.setDescription('Table of status data for Udp Mapping. There are\n         48 rows in this table.  Each row corresponds to one\n         QAM channel.\n        ')
apexUdpMapStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexUdpMapStatusOutputTsNum"))
if mibBuilder.loadTexts: apexUdpMapStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapStatusEntry.setDescription('Udp Mapping Status Table Entry.')
apexUdpMapStatusOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexUdpMapStatusOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapStatusOutputTsNum.setDescription('Index of Udp Mapping Status Table.')
apexUdpMapInvalidApplyText = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 18, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUdpMapInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexUdpMapInvalidApplyText.setDescription('When apexUdpMapApplyChange is set to applyNotInProgressInvalidData,\n         this entry may contain a text description of what was wrong with the data.\n        ')
apexRdsIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexRdsIpAddr.setDescription("Rights Data Server IP address.  Class A, B, or C IP address of the RDS.\n         Changing this parameter will cause the APEX to perform an EMM rollover\n         sequence.\n\n         This parameter is not changed by apexRdsSetDefault.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsTcpPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsTcpPort.setStatus('current')
if mibBuilder.loadTexts: apexRdsTcpPort.setDescription("Rights Data Server TCP port.\n         Changing this parameter will cause the APEX to perform an EMM rollover\n         sequence.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsProgramEpochDuration = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsProgramEpochDuration.setStatus('current')
if mibBuilder.loadTexts: apexRdsProgramEpochDuration.setDescription("The Program Epoch Duration in minutes.  Changes are not\n         applied until the end of the current epoch.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsCetPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsCetPollInterval.setStatus('current')
if mibBuilder.loadTexts: apexRdsCetPollInterval.setDescription("Interval that the APEX will use to poll for CSN/State information.\n         After receiving the CSN/State information, the APEX will determine if it\n         needs to retrieve new EMMs.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsCetRefresh = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("refreshNotInProgress", 1), ("refresh", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsCetRefresh.setStatus('current')
if mibBuilder.loadTexts: apexRdsCetRefresh.setDescription("Setting to 'refresh' forces the APEX to retrieve new\n         EMMs (APEX performs an EMM rollover sequence).\n\n         Once written, the change to this parameter will take effect immediately.\n\n         @Config(config=no, reboot=no)\n        ")
apexRdsRmdPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(15, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsRmdPollInterval.setStatus('current')
if mibBuilder.loadTexts: apexRdsRmdPollInterval.setDescription("Interval that the APEX will use to poll for RMD information.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsRmdRefresh = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("refreshNotInProgress", 1), ("refresh", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsRmdRefresh.setStatus('current')
if mibBuilder.loadTexts: apexRdsRmdRefresh.setDescription("Setting to 'refresh' forces the APEX to retrieve new\n         RMD data from RDS server.\n\n         Once written, the change to this parameter will take effect immediately.\n\n         @Config(config=no, reboot=no)\n        ")
apexRdsPollRandomization = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsPollRandomization.setStatus('current')
if mibBuilder.loadTexts: apexRdsPollRandomization.setDescription("RDS Polling Randomization Time.  Maximum time in minutes to delay\n         polling at startup in order to avoid having many APEXs polling the\n         RDS simultaneously.  The actual delay time will be\n         randomly calculated by the APEX and will be no greater than this value.\n         A value of zero means no delay and the APEX will poll immediately at\n         startup.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsSetDefault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notSettingToDefault", 1), ("setToDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsSetDefault.setStatus('current')
if mibBuilder.loadTexts: apexRdsSetDefault.setDescription("This parameter sets apexRdsCetPollInterval, apexRdsPollRandomization,\n         apexRdsTcpPort, apexRdsRmdPollInterval, apexRdsProgramEpochDuration \n         and apexRdsInitialEcmRetryInterval to default values.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'..\n\n         @Config(config=no, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n        ")
apexRdsErrorCountReset = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 10), ResetStatisticsTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsErrorCountReset.setStatus('current')
if mibBuilder.loadTexts: apexRdsErrorCountReset.setDescription('Resets RDS Communication error counts.\n\n         Once written, the change to this parameter will take effect immediately.\n\n         @Config(config=no, reboot=no)\n        ')
apexRdsConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 11), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexRdsConfigApplyChange.setDescription("The Apply for RDS configuration items. This parameter\n         MUST be set to 'apply' in order for any of the following to\n         take effect:\n            apexRdsIpAddr\n            apexRdsTcpPort\n            apexRdsPollRandomization\n            apexRdsCetPollInterval\n            apexRdsRmdPollInterval\n            apexRdsProgramEpochDuration\n            apexRdsConfigRds2Enable\n            apexRdsConfigServerUrl\n\n         This parameter MUST be set LAST after all associated parameters\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexRdsConfigRds2Enable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 12), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsConfigRds2Enable.setStatus('current')
if mibBuilder.loadTexts: apexRdsConfigRds2Enable.setDescription("Indicates whether RDS-2 Interface is enabled or disabled.\n        \n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini') \n        ")
apexRdsConfigServerUrl = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsConfigServerUrl.setStatus('current')
if mibBuilder.loadTexts: apexRdsConfigServerUrl.setDescription("Rights Data Server Uniform Resource Locator (RDS-2 Server URL).\n         This is introduced to support RDS 2 Interface since APEX 2.5 release.         \n                                             \n         The syntax of this parameter shall be: \n         [http://]<RDS-2 Server IP>[:<TCP Port>]/<Server Root Directory Path>\n         Note:\n         1. The 'http://' protocol part is default and optional, \n         2. 'RDS-2 Server IP' is Class A, B, or C IP address,\n         3. 'TCP Port' is optional, if not present, default to 80,\n         4. 'Server Root Directory Path' is not optional\n         e.g. \n            http://192.168.30.107:1020/rds/controller\n            192.168.30.107:1020/rds/controller                 \n            192.168.30.107/rds/controller (default port is 80)\n         \n         The apex host will validate this parameter upon applying change,\n         and set the following three status parameter accordingly:\n           - apexRdsStatusServerIp\n           - apexRdsStatusServerPort\n           - apexRdsStatusServerRootDirPath\n           - apexRdsStatusValidation\n         \n         This parameter is not changed by apexRdsSetDefault.                                      \n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')                                 \n        ")
apexRdsInitialEcmRetryInterval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsInitialEcmRetryInterval.setStatus('current')
if mibBuilder.loadTexts: apexRdsInitialEcmRetryInterval.setDescription("This parameter is used to configure RDS2 server ECM retry time.\n         This value defines when the next retry will be performed by the host.\n         Units are seconds.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsDeviceId = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexRdsDeviceId.setStatus('current')
if mibBuilder.loadTexts: apexRdsDeviceId.setDescription("This parameter is used to configure Device ID.\n         This value will be used by APEX1000 to fetch the Access Criteria,\n         using RDS1 interface when 'apexEncryptionConfAlgorithm' is set to\n         either mc-scte-52-simulcrypt or mc-csa-simulcrypt.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexRdsConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexRdsConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexRdsConnectionStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("notConnectedInHoldoff", 1), ("notConnectedNoRdsIpAddress", 2), ("csnAquisitionSuccessful", 3), ("emmAquisitionSuccessful", 4), ("serviceListAquisitionSuccessful", 5), ("rmdAquisitionSuccessful", 6), ("csnAquisitionFailed", 7), ("emmAquisitionFailed", 8), ("serviceListAquisitionFailed", 9), ("rmdAquisitionFailed", 10), ("acAquisitionSuccessful", 11), ("acAquisitionFailed", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsConnectionStatus.setStatus('current')
if mibBuilder.loadTexts: apexRdsConnectionStatus.setDescription('Rights Data Server connection status.')
apexRdsCurrentCsn = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsCurrentCsn.setStatus('current')
if mibBuilder.loadTexts: apexRdsCurrentCsn.setDescription('This is the current CSN that the APEX is\n         using for encrypting all programs.\n        ')
apexRdsCetNextPollTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsCetNextPollTime.setStatus('current')
if mibBuilder.loadTexts: apexRdsCetNextPollTime.setDescription('Time in seconds until the next CET polling period.')
apexRdsRmdNextPollTime = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsRmdNextPollTime.setStatus('current')
if mibBuilder.loadTexts: apexRdsRmdNextPollTime.setDescription('Time in seconds until the next RMD polling period.')
apexRdsEmmStatusTableSize = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusTableSize.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusTableSize.setDescription('EMM Status Table Size.  This is the maximum number of rows in the EMM Status\n         Table and is the limit on apexRdsEmmStatusIndex.\n        ')
apexRdsProgramMessagesReceived = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsProgramMessagesReceived.setStatus('current')
if mibBuilder.loadTexts: apexRdsProgramMessagesReceived.setDescription('Number of successful ServiceEncrypt messages received in the last 15 minutes.')
apexRdsProgramMessagesFailed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsProgramMessagesFailed.setStatus('current')
if mibBuilder.loadTexts: apexRdsProgramMessagesFailed.setDescription('Number of failed ServiceEncrypt messages received in the last 15 minutes.')
apexRdsCommErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsCommErrorCount.setStatus('current')
if mibBuilder.loadTexts: apexRdsCommErrorCount.setDescription('Count of total server communication errors.\n         This parameter is set to 0 when the APEX boots up.')
apexRdsCommStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("ok", 1), ("error", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsCommStatus.setStatus('current')
if mibBuilder.loadTexts: apexRdsCommStatus.setDescription('Status of communication with RDS.')
apexRdsFlashWriteCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsFlashWriteCount.setStatus('current')
if mibBuilder.loadTexts: apexRdsFlashWriteCount.setDescription('Running count of the number of flash memory erasures/writes.')
apexRdsMcast16 = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsMcast16.setStatus('current')
if mibBuilder.loadTexts: apexRdsMcast16.setDescription('Multicast-16 bit address used for build PRK messages. The\n         multicast-16 bit address is from the EMMs received.')
apexRdsStatusServerIp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsStatusServerIp.setStatus('current')
if mibBuilder.loadTexts: apexRdsStatusServerIp.setDescription('Effective Rights Data Server IP address. Derived from RDS Server URL. \n         This is set to 0.0.0.0 when validation on RDS Server URL fails.\n\n         See apexRdsConfigServerUrl. \n        ')
apexRdsStatusServerPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsStatusServerPort.setStatus('current')
if mibBuilder.loadTexts: apexRdsStatusServerPort.setDescription('Effective Rights Data Server TCP port. Derived from RDS Server URL. \n         This is set to 0 when validation on RDS Server URL fails.\n\n         See apexRdsConfigServerUrl. \n        ')
apexRdsStatusServerRootDirPath = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 254))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsStatusServerRootDirPath.setStatus('current')
if mibBuilder.loadTexts: apexRdsStatusServerRootDirPath.setDescription('Effective Rights Data Server Root Directory Path. Derived from RDS\n         Server URL. This is set to Null String when validation on RDS Server\n         URL fails.\n    \n         See apexRdsConfigServerUrl. \n        ')
apexRdsStatusValidation = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("urlValid", 1), ("missingIpOrPath", 2), ("emptyRootPath", 3), ("invalidTcpPort", 4), ("invalidIpClass", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsStatusValidation.setStatus('current')
if mibBuilder.loadTexts: apexRdsStatusValidation.setDescription('Indicates whether the current RDS Server URL parameter is valid.\n\n         urlValid        (1) - RDS-2 URL is valid,\n         missingIpOrPath (2) - RDS-2 IP or Root Path is missing,\n         emptyRootPath   (3) - RDS-2 Root Path cannot be empty,\n         invalidTcpPort  (4) - RDS-2 TCP Port ranges from 1~65535, default to 80, \n         invalidIpClass  (5) - RDS-2 IP shall be class A/B/C.\n\n         See apexRdsConfigServerUrl. \n        ')
apexRdsEmmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2), )
if mibBuilder.loadTexts: apexRdsEmmStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusTable.setDescription(' Table of the most recent RDS responses.')
apexRdsEmmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexRdsEmmStatusIndex"))
if mibBuilder.loadTexts: apexRdsEmmStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusEntry.setDescription('RDS EMM Status Table Entry.')
apexRdsEmmStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: apexRdsEmmStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusIndex.setDescription('Index of EMM Status Table.\n         Size of table can be found in apexRdsEmmStatusTableSize.')
apexRdsEmmStatusCsn = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusCsn.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusCsn.setDescription('Category Sequence Number (CSN). ')
apexRdsEmmStatusState = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transitionComplete", 1), ("transitionStart", 2), ("startOfNewEpoch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusState.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusState.setDescription('Category Epoch Transition (CET) State.')
apexRdsEmmStatusGpsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusGpsTime.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusGpsTime.setDescription('This is the time in GPS seconds that this row was written.')
apexRdsEmmStatusServerError = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusServerError.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusServerError.setDescription('This is the error code reported to the APEX by\n         the RDS.  Zero indicates no error.')
apexRdsEmmStatusUnitAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEmmStatusUnitAddress.setStatus('current')
if mibBuilder.loadTexts: apexRdsEmmStatusUnitAddress.setDescription('This is the ACP address of the ACP associated\n         with the error reported in apexRdsEmmStatusServerError.\n         If no address is contained in this entry, the error\n         applies to all ACPs or to the entire APEX.\n\n         The address is made up of decimal digits formatted as\n         ###-#####-#####-###.\n        ')
apexRdsSourceLookupTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3), )
if mibBuilder.loadTexts: apexRdsSourceLookupTable.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupTable.setDescription('This table provides a list of Source IDs and Provider IDs along\n         with an associated string.  This table of information is provided by the\n         RDS to make it easier for a user to figure out the Source\n         ID and Provider ID for a particular service.\n        ')
apexRdsSourceLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexRdsSourceLookupIndex"))
if mibBuilder.loadTexts: apexRdsSourceLookupEntry.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupEntry.setDescription('Source Lookup Table Entry.')
apexRdsSourceLookupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3, 1, 1), Integer32())
if mibBuilder.loadTexts: apexRdsSourceLookupIndex.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupIndex.setDescription('Source Lookup Table Index.')
apexRdsSourceLookupDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsSourceLookupDescription.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupDescription.setDescription('Text Description of the service provided by the Rights Data Server.')
apexRdsSourceLookupSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsSourceLookupSourceId.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupSourceId.setDescription('Source Id of the service.')
apexRdsSourceLookupProviderId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsSourceLookupProviderId.setStatus('current')
if mibBuilder.loadTexts: apexRdsSourceLookupProviderId.setDescription('Provider Id of the service.')
apexRdsEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4), )
if mibBuilder.loadTexts: apexRdsEventTable.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventTable.setDescription('Table of Rds2 Events.\n         The first index (apexRdsEventProgramIndex) matches to the same \n         row index in the apexManualRouteTable.\n        ')
apexRdsEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexRdsEventProgramIndex"), (0, "APEX-MIB", "apexRdsEventEventIndex"))
if mibBuilder.loadTexts: apexRdsEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventEntry.setDescription('Rds2 Events Table Entry.')
apexRdsEventProgramIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexRdsEventProgramIndex.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventProgramIndex.setDescription('apexRdsEventProgramIndex is the last 10 bits of\n         apexOutputProgramEcmServiceId from apexOutputProgramTable.')
apexRdsEventEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexRdsEventEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventEventIndex.setDescription('Rds Event Index.')
apexRdsEventEpochNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventEpochNumber.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventEpochNumber.setDescription('Uniquely identifies a program epoch for the specified service.')
apexRdsEventEpochStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventEpochStart.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventEpochStart.setDescription('Start time in GPS seconds of the returned program epoch \n         for the specified service.\n        ')
apexRdsEventEpochEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventEpochEnd.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventEpochEnd.setDescription('End time in GPS seconds of the returned program epoch.')
apexRdsEventInterstitialDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventInterstitialDuration.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventInterstitialDuration.setDescription('The interstitial duration provides the time duration \n         in seconds between the start of the program epoch and \n         the start of the actual program or event.\n        ')
apexRdsEventPreviewDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventPreviewDuration.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventPreviewDuration.setDescription('The preview window provides the time duration in seconds\n         between the start of the program epoch and the start of \n         the pay portion of the program.\n        ')
apexRdsEventPurchaseDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventPurchaseDuration.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventPurchaseDuration.setDescription('The purchase window provides the time duration in seconds\n         between the start of the program epoch that IPPV purchases\n         are allowed. \n        ')
apexRdsEventNumberTiers = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventNumberTiers.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventNumberTiers.setDescription('A program can be associated with at most 7 tiers.')
apexRdsEventTierData = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventTierData.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventTierData.setDescription('Program Tier Data in Hexadecimal format (28 bytes). \n         Up to 7 tiers of information are provided for each program. \n         Tier information for each program consists of 4 bytes.\n         First 3 bytes are the Tier Value, next 1 bytes are the Tier Type.\n        ')
apexRdsEventProgramCost = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventProgramCost.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventProgramCost.setDescription('Represents the cost, in program units, of the program epoch.')
apexRdsEventRatingRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventRatingRegion.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventRatingRegion.setDescription('Identifies the Program Rating Region. The US region attribute is 0.')
apexRdsEventRatingData = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventRatingData.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventRatingData.setDescription('Program Rating Data in Hexadecimal format (3 bytes). \n         Contains 6 rating dimensions where each rating dimension is a 4-bit \n         integer that represents a different rating control for the region.\n         A US region defines 4 rating dimensions: MPAA rating, violence content\n         rating, language content rating and sexual content rating. \n        ')
apexRdsEventRatingText = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventRatingText.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventRatingText.setDescription('Program Rating optionally contains a Rating Text.')
apexRdsEventControlByte = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventControlByte.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventControlByte.setDescription('The program control byte used in the PRKM (1 Hexadecimal byte).')
apexRdsEventPrkmWkemAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("available", 1), ("notAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventPrkmWkemAvailable.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventPrkmWkemAvailable.setDescription('The flag indicates that PRKM, WKEM (odd and even) is available\n         for the associated epoch.')
apexRdsEventCcmAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 19, 2, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("available", 1), ("notAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRdsEventCcmAvailable.setStatus('current')
if mibBuilder.loadTexts: apexRdsEventCcmAvailable.setDescription('The flag indicates that CCM (odd and even) is available\n         for the associated epoch.')
apexEncryptionConfAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("des-dcii", 1), ("des-scte-52", 2), ("dvb-csa", 3), ("dvb-csa-simulcrypt", 4), ("mc-scte-52-simulcrypt", 5), ("mc-csa-simulcrypt", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEncryptionConfAlgorithm.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionConfAlgorithm.setDescription("Configured encryption algorithm.  This value determines which\n         MUX FPGA image will be loaded. dvb-csa-simulcrypt must be selected\n         to allow for configuration of Simulcrypt. Operator need to procure\n         the license to select mc-scte-52-simulcrypt or mc-csa-simulcrypt. \n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=yes)\n         @Commit(param=apexEncryptionConfApplyChange, value=2)         \n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexSimulcryptExternalEisSetting = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("clear", 0), ("encrypt", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSimulcryptExternalEisSetting.setStatus('current')
if mibBuilder.loadTexts: apexSimulcryptExternalEisSetting.setDescription("Default simulcrypt External EIS encryption setting. This determines if\n         services are sent out in the clear or are encrypted when Simulcrypt\n         mode is set to External EIS and the services have not yet been provisioned.\n         This allows a user to have services scrambled but unviewable prior to\n         services being provisioned (to prevent services from being viewable). This\n         parameter is only applicable for output streams that are in Simulcrypt External\n         EIS mode.\n\n         When this setting is changed, it only affects new service mappings. Services\n         that are already mapped will not be modified.\n         \n         Not used when the APEX1000 is in MC-SCTE52-SimulCrypt or MC-CSA SimulCrypt mode.\n\n         Once written, a save must be performed via the apexSaveConfig\n         parameter and the APEX must be rebooted for the change to take effect.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexSimulcryptEmEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1, 3), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSimulcryptEmEnable.setStatus('current')
if mibBuilder.loadTexts: apexSimulcryptEmEnable.setDescription("Simulcrypt EM Enable.\n         If set to 'enabled' the EM will display the Simulcrypt specific\n         screens. User will be allowed to view Simulcrypt status and perform\n         configuration changes via the EM. This parameter only enables and\n         disables the ability to use the EM Simulcrypt screens. It does not\n         enable or disable Simulcrypt as there is a specific Simulcrypt mode\n         per output stream.\n\n         Once written, the change to this parameter will only take immediate\n         effect.  In order for the change to persist through subsequent reboots\n         or power cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEncryptionConfApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1, 4), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEncryptionConfApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionConfApplyChange.setDescription("The Apply for apexEncryptionConfAlgorithm. This parameter\n         MUST be set to 'apply' in order for apexEncryptionConfAlgorithm to\n         take effect:\n\n         This parameter MUST be set LAST after apexEncryptionConfAlgorithm parameter\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexEncryptionConfInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionConfInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionConfInvalidApplyText.setDescription("When apexEncryptionConfApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data.\n        ")
apexCteEncryptionMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("full", 1), ("fwk", 2), ("fpk", 3), ("clear", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteEncryptionMode.setStatus('current')
if mibBuilder.loadTexts: apexCteEncryptionMode.setDescription("This parameter is used to set the Encryption Mode.  It applies\n         to all services on all QAMs in CTE mode.\n\n           - 'full'  - The APEX will use Full encryption. The APEX will only be able to\n                       encrypt programs in Full encryption mode if the APEX is able to\n                       communicate with an RDS.\n\n           - 'fwk'   - The APEX will use Fixed Working Key (FWK) encryption.\n\n           - 'fpk'   - The APEX will use Fixed Program Key (FPK) encryption. The APEX\n                       will not attempt to get EMMs.\n\n           - 'clear' - The APEX performs no encryption of output programs.\n\n         If the APEX is unable to encrypt programs in the configured mode, then those\n         programs will not be mapped.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexCteApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexCteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexCteCciLevel = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notDefined", 1), ("copyFreely", 2), ("copyOnce", 3), ("copyNever", 4), ("noMoreCopies", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteCciLevel.setStatus('current')
if mibBuilder.loadTexts: apexCteCciLevel.setDescription("Copy Control Information (CCI) Level setting for PRK messages.\n           - notDefined   - CCI is not defined, settop box applications can\n                            configure CCI\n           - copyFreely   - program can be copied\n           - copyOnce     - program can be copied once\n           - copyNever    - program can never be copied\n           - noMoreCopies -\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexCteApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexCteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexCteApsLevel = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notDefined", 1), ("off", 2), ("splitBurstOff", 3), ("splitBurst2Line", 4), ("splitBurst4Line", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteApsLevel.setStatus('current')
if mibBuilder.loadTexts: apexCteApsLevel.setDescription("Analog Protection System (APS)\n         Level setting for PRK messages.  Defines what copy protection encoding\n         will be applied to the analog composite output by the settop box.\n           - notDefined      - analog protection is not defined, settop box\n                               applications can configure APS\n           - off             - no analog protection\n           - splitBurstOff   - AGC on, split burst off\n           - splitBurst2Line - AGC on, 2 line split burst on\n           - splitBurst4Line - AGC on, 4 line split burst on\n\n         The APEX will set Tier Type based on apexCteApsLevel.\n         The APEX will set tier type to subscription with right to tape\n         when apexCteApsLevel is 'off' or 'notDefined'.\n         The APEX will set tier type to subscription without right to tape when\n         apexCteApsLevel is 'splitBurstOff', 'splitBurst2Line', or 'splitBurst4Line'.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexCteApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexCteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexCteCitEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 4), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteCitEnable.setStatus('current')
if mibBuilder.loadTexts: apexCteCitEnable.setDescription("Constrained Image Trigger (CIT) setting.\n         If set to 'enabled' the settop box is notified not to allow a high\n         quality digital output unless the receiving device also adheres to\n         CIT processing. If the apexCteApsLevel is set to 'notDefined', the\n         setting of the CIT value has no affect (CIT and APS are only used\n         when APS is set to a defined value).\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexCteApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexCteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexCteCommonTier = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteCommonTier.setStatus('current')
if mibBuilder.loadTexts: apexCteCommonTier.setDescription("EncryptionCommon Tier.  Identifies the tier\n         number for which access is granted.  Range is 0 to 16777215.\n         65535 is reserved and cannot be used.\n\n         The APEX will set Tier Type based on apexCteApsLevel setting.\n         Refer to the apexCteApsLevel description for more details.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexCteApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexCteApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexCteApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 1, 2, 6), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexCteApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexCteApplyChange.setDescription("The Apply for CTE configuration items. This parameter\n         MUST be set to 'apply' in order for any of the following to\n         take effect:\n            apexCteEncryptionMode\n            apexCteCciLevel\n            apexCteApsLevel\n            apexCteCitEnable\n            apexCteCommonTier\n\n         This parameter MUST be set LAST after all associated parameters\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexEncryptionStatAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("des-dcii", 1), ("des-scte-52", 2), ("dvb-csa", 3), ("dvb-csa-simulcrypt", 4), ("mc-scte-52-simulcrypt", 5), ("mc-csa-simulcrypt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionStatAlgorithm.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionStatAlgorithm.setDescription('Current encryption algorithm.  This value determines which\n         MUX FPGA image will be loaded.\n        ')
apexEncryptionCwgPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionCwgPerSecond.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionCwgPerSecond.setDescription('Average control words per second generated integrated over the last minute.')
apexEncryptionMux1CollisionCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionMux1CollisionCount.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMux1CollisionCount.setDescription('Triton collision counter for MUX FPGA #1.')
apexEncryptionMux2CollisionCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionMux2CollisionCount.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMux2CollisionCount.setDescription('Triton collision counter for MUX FPGA #2.')
apexEncryptionMux1RolloverCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionMux1RolloverCount.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMux1RolloverCount.setDescription('Counts rollovers of triton message circular buffer for MUX FPGA #1.')
apexEncryptionMux2RolloverCount = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionMux2RolloverCount.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMux2RolloverCount.setDescription('Counts rollovers of triton message circular buffer for MUX FPGA #2.')
apexEncryptionEmmRequestsSent = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmRequestsSent.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmRequestsSent.setDescription('Counts number of triton EMM reports sent to 6 MC2.1 devices.')
apexEncryptionEmmGoodRepliesRecvd = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmGoodRepliesRecvd.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmGoodRepliesRecvd.setDescription('Counts number of triton EMM replies marked good received from mc2.1 devices.')
apexEncryptionEmmBadRepliesRecvd = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmBadRepliesRecvd.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmBadRepliesRecvd.setDescription('Counts number of triton EMM replies marked bad received from mc2.1 devices.')
apexEncryptionEmmGoodDeliveryTimeMs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmGoodDeliveryTimeMs.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmGoodDeliveryTimeMs.setDescription('Amount of time expressed in milliseconds taken to deliver\n         entire set of EMMs for most recent successful attempt.\n         Note it takes MC2.1 a significant amount of time to process an EMM.\n         They are delivered in batches of 6 (1 per MC2.1) the firmware then\n         waits for all 6 EMM replies before continuing with the next batch.')
apexEncryptionEmmMaxDeliveryTimeMs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmMaxDeliveryTimeMs.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmMaxDeliveryTimeMs.setDescription('Maximum amount of time expressed in milliseconds taken to deliver\n         an entire set of EMMs since the Apex unit was last rebooted.')
apexEncryptionEmmMinDeliveryTimeMs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionEmmMinDeliveryTimeMs.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionEmmMinDeliveryTimeMs.setDescription('Minimum amount of time expressed in milliseconds taken to deliver\n         an entire set of EMMs since the Apex unit was last rebooted.')
apexEncryptionMcDiagTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 12), )
if mibBuilder.loadTexts: apexEncryptionMcDiagTable.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMcDiagTable.setDescription('Diagnostic table that breaks out individual mc21 performance parameters.\n         Indexed 1-6 for the 6 MC2.1 devices in an APEX ACP Module.')
apexEncryptionMcDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 12, 1), ).setIndexNames((0, "APEX-MIB", "apexEncryptionMcDiagDeviceIndex"))
if mibBuilder.loadTexts: apexEncryptionMcDiagEntry.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMcDiagEntry.setDescription('A row in the mc2.1 diagnostic table.')
apexEncryptionMcDiagDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: apexEncryptionMcDiagDeviceIndex.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionMcDiagDeviceIndex.setDescription('Index represents 1 of 6 MC2.1 devices installed on ACP Module.')
apexEncryptionCwCountsPerSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 20, 2, 1, 2, 12, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEncryptionCwCountsPerSecond.setStatus('current')
if mibBuilder.loadTexts: apexEncryptionCwCountsPerSecond.setDescription('Number of CW successfully generated on this MC2.1 per second,\n         integrated over the last minute.')
apexEasApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasApplyChange.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasApplyChange.setDescription("This object is obsolete.\n\n         The Apply for any entries in the apexEasConfigGeneral group.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the apexEasConfigGeneral group to take effect.  This\n         parameter MUST be set LAST after all other data in the group has\n         been configured.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexEasPhysInType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasPhysInType.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasPhysInType.setDescription("This object is obsolete.\n\n         Input Type of input from which to extract EAS messages. When set\n         to 0, no EAS is received (disables EAS extraction).\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasPhysInPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasPhysInPort.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasPhysInPort.setDescription("This object is obsolete.\n\n         Number of the input, of type configured by apexEasPhysInType,\n         from which to extract EAS messages.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Range(min=0)\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasRcvUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasRcvUdpPort.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasRcvUdpPort.setDescription("This object is obsolete.\n\n         This parameter indicates the UDP port on which to receive\n         EAS messages.\n\n         Range is 1024 to 65535 when apexEasPhysInType is 'fastEnet'.\n         Range is 0 to 65535 when apexEasPhysInType is 'gbe'.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasMulticastIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasMulticastIpAddress.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasMulticastIpAddress.setDescription("This object is obsolete.\n\n         This parameter indicates the Multicast IP Receive address on which\n         to receive EAS messages.\n\n         If 0.0.0.0, then EAS messages will be received via singlecast only.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasSourceIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasSourceIpAddress.setStatus('obsolete')
if mibBuilder.loadTexts: apexEasSourceIpAddress.setDescription("This object is obsolete.\n\n         This parameter indicates the Source IP Receive address on which\n         to receive EAS messages. This is only for IGMP v3 networks.\n\n         If 0.0.0.0, then source IP is not used.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasMessageReceiveTimeoutDuration = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasMessageReceiveTimeoutDuration.setStatus('current')
if mibBuilder.loadTexts: apexEasMessageReceiveTimeoutDuration.setDescription("It is the timeout duration(in days)that the device expects at least one \n         EAS message from the each EAS server configured in 'apexEasServerTable'. \n         \n         Default value is 7 days. \n         \n         Value can be configured with the increment of 1 day in the given range.\n          \n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasMessageReceiveTimeoutEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 1, 8), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasMessageReceiveTimeoutEventEnable.setStatus('current')
if mibBuilder.loadTexts: apexEasMessageReceiveTimeoutEventEnable.setDescription("It enables or disables raising of the event 'trapEasMessageNotReceived'\n         \n         Default value is disabled.\n         \n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasOutputTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 2), )
if mibBuilder.loadTexts: apexEasOutputTable.setStatus('current')
if mibBuilder.loadTexts: apexEasOutputTable.setDescription("Table of parameters for configuring EAS Output.\n\n         Table is indexed by Output Transport Stream Number.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexEasOutputStreamNum"))
if mibBuilder.loadTexts: apexEasOutputEntry.setStatus('current')
if mibBuilder.loadTexts: apexEasOutputEntry.setDescription('A row in the EAS output table.')
apexEasOutputStreamNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexEasOutputStreamNum.setStatus('current')
if mibBuilder.loadTexts: apexEasOutputStreamNum.setDescription('The output transport stream number.')
apexEasOutputEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 2, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasOutputEnable.setStatus('current')
if mibBuilder.loadTexts: apexEasOutputEnable.setDescription('The enable setting for EAS output on this Output Transport Stream.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n        ')
apexEasServerApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 3), )
if mibBuilder.loadTexts: apexEasServerApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexEasServerApplyTable.setDescription('Apply table for the apexEasServerTable.\n\n         Table is indexed by RF Port number.\n        ')
apexEasServerApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexEasServerApplyNum"))
if mibBuilder.loadTexts: apexEasServerApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexEasServerApplyEntry.setDescription('EAS Server Configuration Apply Table Entry.')
apexEasServerApplyNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexEasServerApplyNum.setStatus('current')
if mibBuilder.loadTexts: apexEasServerApplyNum.setDescription('The EAS Server number.')
apexEasServerApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 3, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexEasServerApplyChange.setDescription("The Apply for a row in the apexEasServerTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the apexEasServerTable table to take effect.  This\n         parameter MUST be set LAST after all other data in the table has\n         been configured.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexEasServerTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4), )
if mibBuilder.loadTexts: apexEasServerTable.setStatus('current')
if mibBuilder.loadTexts: apexEasServerTable.setDescription("Table of parameters for configuring EAS Servers.\n\n         Table is indexed by RF Port number.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexEasServerApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEasServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexEasServerNum"))
if mibBuilder.loadTexts: apexEasServerEntry.setStatus('current')
if mibBuilder.loadTexts: apexEasServerEntry.setDescription('A row in the EAS server table.')
apexEasServerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexEasServerNum.setStatus('current')
if mibBuilder.loadTexts: apexEasServerNum.setDescription('The EAS Server number.')
apexEasServerPhysInType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerPhysInType.setStatus('current')
if mibBuilder.loadTexts: apexEasServerPhysInType.setDescription("Input Type of input from which to extract EAS messages. When set\n         to 0, no EAS is received (disables EAS extraction).\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasServerApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n        ")
apexEasServerPhysInPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerPhysInPort.setStatus('current')
if mibBuilder.loadTexts: apexEasServerPhysInPort.setDescription("Number of the input, of type configured by apexEasServerPhysInType,\n         from which to extract EAS messages.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasServerApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n\n         @Range(min=0)\n        ")
apexEasServerRcvUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerRcvUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexEasServerRcvUdpPort.setDescription("This parameter indicates the UDP port on which to receive\n         EAS messages.\n\n         Range is 1024 to 65535 when apexEasServerPhysInType is 'fastEnet'.\n         Range is 0 to 65535 when apexEasServerPhysInType is 'gbe'.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasServerApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n        ")
apexEasServerMulticastIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerMulticastIpAddress.setStatus('current')
if mibBuilder.loadTexts: apexEasServerMulticastIpAddress.setDescription("This parameter indicates the Multicast IP Receive address on which\n         to receive EAS messages.\n\n         If 0.0.0.0, then EAS messages will be received via singlecast only.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasServerApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n        ")
apexEasServerSourceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 1, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEasServerSourceIpAddress.setStatus('current')
if mibBuilder.loadTexts: apexEasServerSourceIpAddress.setDescription("This parameter indicates the Source IP Receive address on which\n         to receive EAS messages. This is only for IGMP v3 networks.\n\n         If 0.0.0.0, then source IP is not used.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexEasServerApplyChange is set to 'apply'.  In order for the\n         change to persist through subsequent reboots or power cycles, the\n         change must be saved via the apexSaveConfig parameter.\n        ")
apexEasNumRcvMsgs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEasNumRcvMsgs.setStatus('current')
if mibBuilder.loadTexts: apexEasNumRcvMsgs.setDescription('Total number of EAS messages received.')
apexEasNumInvalRcvMsgs = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEasNumInvalRcvMsgs.setStatus('current')
if mibBuilder.loadTexts: apexEasNumInvalRcvMsgs.setDescription('Total number of Invalid EAS messages received (invalid CRC).\n         These messages are discarded.')
apexEasLastReceivedMessageStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 2), )
if mibBuilder.loadTexts: apexEasLastReceivedMessageStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexEasLastReceivedMessageStatusTable.setDescription('Table of parameters for last received EAS message details.')
apexEasLastReceivedMessageStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexEasLastReceivedMessageServerNum"))
if mibBuilder.loadTexts: apexEasLastReceivedMessageStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexEasLastReceivedMessageStatusEntry.setDescription('A row in the last received EAS message details table.')
apexEasLastReceivedMessageServerNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexEasLastReceivedMessageServerNum.setStatus('current')
if mibBuilder.loadTexts: apexEasLastReceivedMessageServerNum.setDescription('The EAS Server index number.')
apexEasLastReceivedMessageTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 21, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEasLastReceivedMessageTime.setStatus('current')
if mibBuilder.loadTexts: apexEasLastReceivedMessageTime.setDescription('Time when the last EAS message was received. Zero indicates EAS\n         message is yet to be received or not configured. This time is\n         reported in GPS seconds. To determine the system time in UTC the\n         apexSntpUtcOffset object must also be read and used in the calculation.\n        ')
apexChassisRedundancyConfigEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyConfigEnable.setDescription("This is to enable/disable APEX chassis redundancy.\n         When set to disabled(1), APEX is not allowed to failover.\n         When set to enabled(2), APEX can failover on its redundant APEX.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexChassisRedundancyConfigApplyChange is set to 'apply'.\n         In order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyMode.setDescription("Configures the desired role of APEX. Primary has active output ports,\n         secondary is inactive with output ports muted.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyMulticastRedundancyMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hot", 1), ("warm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyMulticastRedundancyMode.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyMulticastRedundancyMode.setDescription("This is used to process route mappings by the standby APEX.\n\n         When set to hot(0) on standby APEX, all the routes processed by the\n         active APEX will also be processed by standby APEX.\n\n         When set to warm(1) on standby APEX, all the routes processed by the\n         active APEX will be muted by standby APEX.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyUdpPort.setDescription("This UDP port number value is used as:\n\n         (1) The port number on which to receive heartbeat messages from the\n             redundant APEX\n         (2) The port number to which heartbeat messages are sent to the\n             redundant APEX.\n\n         Valid range of UDP port numbers are 1024 to 65535.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyRedundantApexIp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyRedundantApexIp.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyRedundantApexIp.setDescription("Unicast IP address of redundant APEX.\n         This IP address is used to send heartbeat messages to the redundant IP.\n         This IP address should match with the ENET1 or ENET2 IP address of the\n         redundant APEX.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancySuspend = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 6), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancySuspend.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancySuspend.setDescription("When set to enabled(2), this results in APEX unit failover and become\n         active if it is in standby or suspend state.\n         If the condition above is not met, setting the value to enabled(2) has\n         no effect.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyForceFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failoverNotInProgress", 1), ("failover", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyForceFailOver.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyForceFailOver.setDescription('When set to failover(2), this results in the APEX unit failing over\n         if it is in active state and the redundant APEX is in standby state.\n         If the condition above is not met, setting the value to failvoer(2)\n         has no effect.\n\n         @Config(config=no, reboot=no)\n        ')
apexChassisRedundancyFailOverGigE12LinkLoss = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 8), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverGigE12LinkLoss.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverGigE12LinkLoss.setDescription("Configures if both GigE 1&2 link loss is cause for a failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverGigE34LinkLoss = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 9), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverGigE34LinkLoss.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverGigE34LinkLoss.setDescription("Configures if both GigE 3&4 experience link loss is cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverEnet1LinkLoss = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 10), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverEnet1LinkLoss.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverEnet1LinkLoss.setDescription("Configures if ENET1 link loss is cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverEnet2LinkLoss = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 11), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverEnet2LinkLoss.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverEnet2LinkLoss.setDescription("Configures if ENET2 link loss is cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverTemperatureFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 12), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverTemperatureFault.setDescription("Configures if the temperature fault is a cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverQamModuleFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 13), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamModuleFault.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamModuleFault.setDescription("Configures if a QAM module fault is a cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverQamRfPortFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 14), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamRfPortFault.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamRfPortFault.setDescription("Configures if a QAM RF port fault is a cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverQamChannelFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 15), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamChannelFault.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamChannelFault.setDescription("Configures if a QAM channel fault is a cause for failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 16), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyConfigApplyChange.setDescription("The Apply for Chassis Redundancy Configuration parameters.\n\n         This parameter MUST be set to 'apply' in order for the data\n         to take effect. This parameter MUST be set LAST after all Chassis\n         Redundancy parameters affected by this parameter have been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexChassisRedundancyPrimaryStandbyOverride = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 17), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyPrimaryStandbyOverride.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyPrimaryStandbyOverride.setDescription('This parameter is set to ENABLED while configuring the apex\n         as primary apex. If this parameter is set, the apex will goto\n         ACTIVE state irrespective of secondary status.\n         \n         @Config(config=no, reboot=no)\n        ')
apexChassisRedundancyRedundantApexSecIp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyRedundantApexSecIp.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyRedundantApexSecIp.setDescription("Unicast IP address of redundant APEX heartbeat backup interface.\n         This IP address is used to send backup heartbeat messages to the redundant IP.\n         This IP address should match with the ENET1 or ENET2 IP address of the\n         redundant APEX.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyRedundantHBEnable = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 19), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyRedundantHBEnable.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyRedundantHBEnable.setDescription("This parameter is set to ENABLED to configure backup heartbeat interface IP.\n         Heartbeat message in the Backup heartbeat interface is used if the Primary \n         heartbeat inteface fails.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyFailOverQamModuleRemoval = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 1, 1, 20), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamModuleRemoval.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFailOverQamModuleRemoval.setDescription("If this parameter is set to ENABLED then QAM Module removal fault will cause the failover.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexChassisRedundancyConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexChassisRedundancyPrimaryApexStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("active", 1), ("standby", 2), ("fault", 3), ("suspend", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyPrimaryApexStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyPrimaryApexStatus.setDescription('This parameter is applicable for an APEX where chassis redundancy is\n         enabled.\n\n         The APEX configured as primary will report the following values:\n\n         active(1):  Primary RF outputs are active.\n         standby(2): Primary RF outputs are muted. Waiting to become active.\n         fault(3):   Primary has experienced a fault.\n         suspend(4): Primary is suspended.\n\n         The APEX configured as secondary will report the following values.\n         These are based on its knowledge about the primary APEX from heartbeat\n         messages.\n\n         unknown(0): State of primary is not known (heartbeat not received).\n         active(1):  Primary RF outputs are active.\n         standby(2): Primary RF outputs are muted. Waiting to become active.\n         fault(3):   Primary has experienced a fault.\n         suspend(4): Primary is suspended.\n        ')
apexChassisRedundancySecondaryApexStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("active", 1), ("standby", 2), ("fault", 3), ("suspend", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancySecondaryApexStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancySecondaryApexStatus.setDescription('This parameter is applicable for an APEX where chassis redundancy is\n         enabled.\n\n         The APEX configured as primary will report the following values:\n         These are based on its knowledge about the secondary APEX from heartbeat\n         messages.\n\n         unknown(0): State of secondary is not known (heartbeat not received).\n         active(1):  Secondary RF outputs are active.\n         standby(2): Secondary RF outputs are muted. Waiting to become active.\n         fault(3):   Secondary has experienced a fault.\n         suspend(4): Secondary is suspended.\n\n         The APEX configured as secondary will report the following values:\n\n         active(1):  Secondary RF outputs are active.\n         standby(2): Secondary RF outputs are muted. Waiting to become active.\n         fault(3):   Secondary has experienced a fault.\n         suspend(4): Secondary is suspended.\n        ')
apexChassisRedundancyState = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("available", 1), ("protected", 2), ("unavailable", 3), ("synchronizing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyState.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyState.setDescription("This parameter is applicable for an APEX where chassis redundancy is\n         enabled.\n\n         This parameter will report the chassis redundancy availability status.\n         These are based on its knowledge about the secondary APEX from heartbeat\n         messages.\n\n         The APEX configured as primary will report the following values:\n\n         unknown(0):       State of redundancy is not known (heartbeat not\n                           received).\n         available(1):     Primary is active and secondary is in standby,\n                           configurations are synchronized and no critical faults\n                           on either of the APEX.\n         protected(2):     Primary is fault and secondary is in active.\n         unavailable(3):   Configuration not synchronized or primary has not\n                           received heartbeat message from secondary.\n         synchronizing(4): Synchronizing configuration between active and standby\n                           APEX's.\n\n         The APEX configured as secondary will report the following values:\n\n         unknown(0):       State of redundancy is not known (heartbeat not\n                           received).\n         available(1):     Secondary is active and primary is in standby,\n                           configurations are synchronized and no critical faults\n                           on either of the APEX.\n         protected(2):     Secondary is in active and primary is fault state.\n         unavailable(3):   Configuration not synchronized or secondary is in\n                           fault state or secondary has not received heartbeat\n                           message from primary.\n         synchronizing(4): Synchronizing configuration between active and standby APEX's.\n        ")
apexChassisRedundancyCommunicationStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disconnected", 0), ("connected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyCommunicationStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyCommunicationStatus.setDescription('This parameter is applicable for an APEX where chassis redundancy is\n         enabled.\n\n         This parameter will report the chassis redundancy communication status.\n         These are based on its knowledge about the secondary APEX from heartbeat\n         messages.\n\n         The APEX configured as primary will report the following values:\n\n         disconnected(0): No heartbeat messages are received from secondary or\n                          communication timed out.\n         connected(1):    Heartbeat messages are received from secondary and\n                          communication has not timed out.\n\n         The APEX configured as secondary will report the following values:\n\n         disconnected(0): No heartbeat messages are received from primary or\n                          communication timed out.\n         connected(1):    Heartbeat messages are received from primary and\n                          communication has not timed out.\n        ')
apexChassisRedundancyConfigurationStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("synchronized", 1), ("outofsync", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyConfigurationStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyConfigurationStatus.setDescription('This parameter is applicable for an APEX where chassis redundancy is\n         enabled.\n\n         This parameter will report the chassis redundancy configuration status.\n         These are based on its knowledge about the secondary APEX from heartbeat\n         messages.\n\n         The APEX configured as primary will report the following values:\n\n         unknown(0):      Secondary configuration is not known or secondary is not\n                          connected.\n         synchronized(1): Secondary has same configuration as primary (except for\n                          QAM outputs).\n         outofsync(2):    Secondary configuration is not in sync with primary.\n\n         The APEX configured as secondary will report the following values:\n\n         unknown(0):      Primary configuration is not known or primary is not\n                          connected.\n         synchronized(1): Primary has same configuration as secondary (except for\n                          QAM outputs).\n         outofsync(2):    Primary configuration is not in sync with secondary.\n        ')
apexChassisRedundancyStatusInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyStatusInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyStatusInvalidApplyText.setDescription("When apexChassisRedundancyConfigApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data.\n        ")
apexChassisRedundancyGeneralConfigSyncStatusText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyGeneralConfigSyncStatusText.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyGeneralConfigSyncStatusText.setDescription('GigE Config Sync Error info ')
apexChassisRedundancyGigEMismatchStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("match", 1), ("mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyGigEMismatchStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyGigEMismatchStatus.setDescription('This parameter indicates whether the GigE configuration of the apexes in \n         Chassis Redundancy pair match.\n\n         Both the APEXs will report the following values:\n         These are based on its knowledge about the secondary APEX GigE configuration \n         from heartbeat messages.\n\n         unknown  (0): GigE configuration of pair APEX is not known (heartbeat not received).\n         match    (1): GigE configuration of APEXs in redundancy pair match.\n         mismatch (2): GigE configuration of APEXs in redundancy pair do not match.\n\n        ')
apexChassisRedundancyQamMismatchStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("match", 1), ("mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyQamMismatchStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyQamMismatchStatus.setDescription('This parameter indicates whether the QAM configuration of the apexes in \n         Chassis Redundancy pair match.\n\n         Both the APEXs will report the following values:\n         These are based on its knowledge about the secondary APEX QAM configuration \n         from heartbeat messages.\n\n         unknown  (0): QAM configuration of pair APEX is not known (heartbeat not received).\n         match    (1): QAM configuration of APEXs in redundancy pair match.\n         mismatch (2): QAM configuration of APEXs in redundancy pair do not match.\n\n        ')
apexChassisRedundancyFirmwareMismatchStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("match", 1), ("mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyFirmwareMismatchStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyFirmwareMismatchStatus.setDescription('This parameter indicates whether the Firmware version of the apexes in \n         Chassis Redundancy pair match.\n\n         Both the APEXs will report the following values:\n         These are based on its knowledge about the secondary APEX Firmware version \n         from heartbeat messages.\n\n         unknown  (0): Firmware version of pair APEX is not known (heartbeat not received).\n         match    (1): Firmware version of APEXs in redundancy pair match.\n         mismatch (2): Firmware version of APEXs in redundancy pair do not match.\n\n        ')
apexChassisRedundancyGigE12LinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyGigE12LinkStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyGigE12LinkStatus.setDescription('This parameter indicates the combined alarm status of the GigE 1 and GigE 2.\n         Indicates the lower of the gigE input interface alarm conditions.\n\n         ok           (1): No alarm on either of GigE1 and GigE2.\n         warning      (3): Warning alarm on both GigE1 or GigE2\n         minor        (4): minor alarm on both  GigE1 or GigE2\n         major        (5): Major alarm on both GigE1 or GigE2   \n         critical     (6): critical alarm on both GigE1 and GigE2.\n\n        ')
apexChassisRedundancyGigE34LinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyGigE34LinkStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyGigE34LinkStatus.setDescription('This parameter indicates the combined alarm status of the GigE3 and GigE4.\n         Indicates the lower of the gigE input interface alarm conditions.\n\n         ok           (1): No alarm on either of GigE3 and GigE4.\n         warning      (3): Warning alarm on both GigE3 or GigE4\n         minor        (4): minor alarm on both  GigE3 or GigE4\n         major        (5): Major alarm on both GigE3 or GigE4   \n         critical     (6): critical alarm on both GigE3 and GigE4.\n\n        ')
apexChassisRedundancyCurrHBIntfIPStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyCurrHBIntfIPStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyCurrHBIntfIPStatus.setDescription('This parameter indicates the heartbeat interface used for receiving heartbeat\n         from the redundant APEX.\n        ')
apexChassisRedundancyAppliedEncAlgorithmStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("match", 1), ("mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyAppliedEncAlgorithmStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyAppliedEncAlgorithmStatus.setDescription('This parameter indicates if there is a match/mismatch in the applied encryption\n         algorithm of the pair APEXs in chassis redundancy.\n\n         Both the APEXs will report the following values:\n         These are based on its knowledge about the secondary APEX GigE configuration \n         from heartbeat messages.\n\n         unknown  (0): Applied encryption Algorithm of pair APEX is not known (heartbeat not received).\n         match    (1): Applied encryption Algorithm of APEXs in redundancy pair match.\n         mismatch (2): Applied encryption Algorithm of APEXs in redundancy pair do not match.\n\n        ')
apexChassisRedundancyMCSimEntitlementStatus = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 22, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("match", 1), ("mismatch", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyMCSimEntitlementStatus.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyMCSimEntitlementStatus.setDescription('This parameter indicates if there is a match/mismatch in the ULS license\n         of MC SimulCrypt for the chassis redundancy pair APEXes.\n         The mismatch will be indicated only when both the pair APEXs are configured\n         for MC SimulCrypt encryption mode.\n\n         Both the APEXs will report the following values:\n         These are based on its knowledge about the secondary APEX GigE configuration \n         from heartbeat messages.\n\n         unknown  (0): ULS license for MC SimulCrypt of pair APEX is not known (heartbeat not received).\n         match    (1): ULS license for MC SimulCrypt of APEXs in redundancy pair match.\n         mismatch (2): ULS license for MC SimulCrypt of APEXs in redundancy pair do not match.\n\n        ')
apexDtaGeneralConfigCatSourceType = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigCatSourceType.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigCatSourceType.setDescription("When set to internal(0), APEX generates CAT and inserts EMM pid received from DAC.\n         When set to external(1), APEX will not generate CAT,\n         it will receive both CAT and EMM pids from DAC and inserts EMM pid into CAT.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigCatEmmPidMulticastIP = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidMulticastIP.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidMulticastIP.setDescription("Multicast IPv4 address on which CAT/EMM PID stream is available.\n         An IP Address of 0.0.0.0 indicates unicast stream.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigCatEmmPidSourceIP = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidSourceIP.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidSourceIP.setDescription("Source IP address to receive CAT/EMM PID stream.\n         This is used only if apexQamRfConfigDtaNetworkPidMulticastIP is set\n         to a multicast address.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigCatEmmPidUdpPort = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidUdpPort.setDescription("UDP port to receive CAT/EMM PID stream.\n         The range of valid UDP port numbers are 1024 to 65535.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigCatEmmPidInterface = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 5), InputInterfaceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidInterface.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigCatEmmPidInterface.setDescription("Fast Ethernet or GIGE Interface to receive CAT/EMM PID stream.\n         CAT/EMM PID streams can be received from either fast etherent\n         (ENET1 or ENET2) or GIGE etherent port (GIGE1, GIGE2, GIGE3, GIGE4).\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigEmmPidNum = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7168, 8190))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigEmmPidNum.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigEmmPidNum.setDescription("EMM PID to insert on DTA enabled OTS.\n         The range of valid PID numbers are 0x1C00 to 0x1FFE.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaGeneralConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaGeneralConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 7), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaGeneralConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigApplyChange.setDescription("The Apply for DTA Configuration parameters.\n\n         This parameter MUST be set to 'apply' in order for the DTA Cat Config data\n         to take effect. This parameter MUST be set LAST after all DTA Config\n         parameters affected by this parameter have been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexDtaGeneralConfigInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDtaGeneralConfigInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexDtaGeneralConfigInvalidApplyText.setDescription("When apexDtaGeneralConfigApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with DTA CAT/EMM PID Config data\n         or NET PID Config data.         \n        ")
apexDtaConfigApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 2), )
if mibBuilder.loadTexts: apexDtaConfigApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexDtaConfigApplyTable.setDescription('Apply table for the configuration tables apexDtaRfPortConfigTable and\n         apexDtaOtsConfigTable.\n        ')
apexDtaConfigApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexDtaConfigApplyIndex"))
if mibBuilder.loadTexts: apexDtaConfigApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexDtaConfigApplyEntry.setDescription('DTA RF Port Configuration Apply Table Entry.')
apexDtaConfigApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexDtaConfigApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexDtaConfigApplyIndex.setDescription('Defines the size of apexDtaRfPortConfigTable. DTA NET PID can be configured \n         for each RF port. This shall be the number of maximum number of QAM RF port.')
apexDtaConfigApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexDtaConfigApplyChange.setDescription("The Apply for a row of data in apexDtaRfPortConfigTable.\n\n         The Apply for eight rows of data in apexDtaOtsConfigTable.\n\n         A row in this table corresponds to the same row index in the\n         apexDtaRfPortConfigTable.\n\n         A row in this table corresponds to eight rows in the\n         apexDtaOtsConfigTable when QAM module is type of either \n         2x4 or 2x8 as follows:\n            Apply Table     DTA OTS/QAM Config Table\n            -----------     -----------------\n                 1                1-8\n                 2                9-16\n                 3               17-24\n                 4               25-32\n                 5               33-40\n                 6               41-48\n\n         A row in this table corresponds to four rows in the\n         apexDtaOtsConfigTable when QAM module is type of 4x4 as follows:\n            Apply Table     DTA OTS/QAM Config Table\n            -----------     -----------------\n                 1                1-4\n                 2                5-8\n                 3               17-20\n                 4               21-24                 \n                 5               33-36\n                 6               37-40                 \n                 7                9-12\n                 8               13-16\n                 9               25-28\n                10               29-32\n                11               41-44\n                12               45-48\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the rows to take effect in the APEX.  This parameter MUST be set\n         LAST after all other data in the configuration table rows has been\n         configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexDtaRfPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3), )
if mibBuilder.loadTexts: apexDtaRfPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigTable.setDescription("Table of DTA configuration items configurable on a RF Port basis.\n\n         Once written, the change to this table will only take immediate\n         effect after apexDtaConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaRfPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexDtaRfPortConfigIndex"))
if mibBuilder.loadTexts: apexDtaRfPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigEntry.setDescription('DTA RF port configuration Table Entry.')
apexDtaRfPortConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12)))
if mibBuilder.loadTexts: apexDtaRfPortConfigIndex.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigIndex.setDescription('The QAM RF Port number.')
apexDtaRfPortConfigNetPidMulticastIP = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidMulticastIP.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidMulticastIP.setDescription('Multicast IPv4 address on which Network PID stream is available.\n         An IP Address of 0.0.0.0 indicates unicast stream.\n        ')
apexDtaRfPortConfigNetPidSourceIP = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidSourceIP.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidSourceIP.setDescription('Source IP address to receive Network PID stream.\n         This is used only if apexDtaRfPortConfigNetPidMulticastIP is set\n         to a multicast address.\n        ')
apexDtaRfPortConfigNetPidUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidUdpPort.setDescription('UDP port number to receive Network PID stream.\n         The range of valid port numbers are 1024 to 65535.\n        ')
apexDtaRfPortConfigNetPidInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 5), InputInterfaceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidInterface.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidInterface.setDescription('Fast Ethernet or GIGE Interface to receive Network PID stream.\n         Network PID stream can be received from either fast etherent (ENET1 or ENET2)\n         or GIGE etherent port (GIGE1, GIGE2, GIGE3, GIGE4).\n        ')
apexDtaRfPortConfigNetPidNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(7168, 8190))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidNum.setStatus('current')
if mibBuilder.loadTexts: apexDtaRfPortConfigNetPidNum.setDescription('Network PID to insert on DTA enabled OTS.\n         The range of valid PID numbers are 0x1C00 to 0x1FFE.\n        ')
apexDtaOtsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 4), )
if mibBuilder.loadTexts: apexDtaOtsConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexDtaOtsConfigTable.setDescription("Table of DTA configuration items for output transport streams (OTS).\n\n         Once written, the change to this table will only take immediate\n         effect after apexDtaConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDtaConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDtaOtsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexDtaOtsConfigIndex"))
if mibBuilder.loadTexts: apexDtaOtsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexDtaOtsConfigEntry.setDescription('DTA OTS enable configuration Table Entry.')
apexDtaOtsConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexDtaOtsConfigIndex.setStatus('current')
if mibBuilder.loadTexts: apexDtaOtsConfigIndex.setDescription('The Output Transport Stream(OTS) number.')
apexDtaOtsConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 23, 1, 4, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDtaOtsConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexDtaOtsConfigEnable.setDescription('This is to enable/disable of inserting DTA messages on OTS.\n         When set to disabled(1), DTA messages are not allowed to insert on OTS.\n         When set to enabled(2), DTA messages are allowed to insert on OTS.\n        ')
apexDepiConfigHostname = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiConfigHostname.setStatus('current')
if mibBuilder.loadTexts: apexDepiConfigHostname.setDescription("Host name defined as the FQDM of the APEX-EQAM device.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2, default=yes)\n         @File(config.ini, type='ini')\n        ")
apexDepiStatusGeneralDtiPort1LinkActive = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 1), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort1LinkActive.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort1LinkActive.setDescription('This indicates if the DTI Ethernet link is active.')
apexDepiStatusGeneralDtiPort2LinkActive = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 2), ActiveTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort2LinkActive.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort2LinkActive.setDescription('This indicates if the second DTI Ethernet link is active.')
apexDepiStatusGeneralDtiClientStatusMode = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("warmup", 1), ("free-run", 2), ("fast", 3), ("normal", 4), ("bridging", 5), ("holdover", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiClientStatusMode.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiClientStatusMode.setDescription('The DTI Client MUST support and report these operational modes.')
apexDepiStatusGeneralDtiClientPhaseError = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiClientPhaseError.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiClientPhaseError.setDescription("24-bit Phase Error in units of 149.8 MHz sample clock cycles.\n         The lower eight bits of the 24-bit field MUST be padded with\n         zeros and MUST NOT be used by the DTI server. The value MUST be a\n         signed 2's complement number. If the DTI client supports more bits of\n         resolution, the DTI client MUST round the reported value to the nearest\n         integer sample clock cycle.\n        ")
apexDepiStatusGeneralDtiCurrentTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiCurrentTimestamp.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiCurrentTimestamp.setDescription('DOCSIS 32-bit timestamp (DTS). ')
apexDepiStatusGeneralDtiPort1CableAdvanceValue = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort1CableAdvanceValue.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort1CableAdvanceValue.setDescription('24-bit Cable Advance value is derived by dividing the cable delay by 2.')
apexDepiStatusGeneralDtiPort2CableAdvanceValue = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort2CableAdvanceValue.setStatus('current')
if mibBuilder.loadTexts: apexDepiStatusGeneralDtiPort2CableAdvanceValue.setDescription('24-bit Cable Advance value is derived by dividing the cable delay by 2.')
apexDepiControlConfigGeneralKeepaliveTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigGeneralKeepaliveTimeout.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigGeneralKeepaliveTimeout.setDescription("Timeout in seconds to wait while no control or data messages are received\n         within the connection before sending a DEPI:HELLO message.\n         Default is 60 seconds.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDepiControlConfigApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 2), )
if mibBuilder.loadTexts: apexDepiControlConfigApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigApplyTable.setDescription('Table of Apply Change for the data for apexDepiControlConfigTable.\n\n         Entries in the apexDepiControlConfigTable cannot be modified while DEPI Control\n         Connections and DEPI Sessions currently exist.\n        ')
apexDepiControlConfigApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiControlConfigApplyIndex"))
if mibBuilder.loadTexts: apexDepiControlConfigApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigApplyEntry.setDescription('DEPI Control Configuration Apply Table Entry.\n        ')
apexDepiControlConfigApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: apexDepiControlConfigApplyIndex.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigApplyIndex.setDescription('The index of the Depi Control Config Apply Table.')
apexDepiControlConfigApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 2, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigApplyChange.setDescription("The Apply for any entries in the apexDepiControlConfigTable.\n\n         Entries in the apexDepiControlConfigTable cannot be modified while DEPI Control\n         Connections and DEPI Sessions currently exist.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the apexDepiControlConfigTable to take effect.  This\n         parameter MUST be set LAST after all other data in the group has\n         been configured.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexDepiControlConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3), )
if mibBuilder.loadTexts: apexDepiControlConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigTable.setDescription("This table provides a list of DEPI Control Connections initiated by\n         M-CMTS Cores.  A maximum of 10 connections is accepted.\n\n         Entries in the apexDepiControlConfigTable cannot be modified while DEPI Control\n         Connections and DEPI Sessions currently exist.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDepiControlConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDepiControlConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiControlConfigIndex"))
if mibBuilder.loadTexts: apexDepiControlConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigEntry.setDescription('DEPI Control Configuration Table Entry.\n        ')
apexDepiControlConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: apexDepiControlConfigIndex.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigIndex.setDescription('The index of the Depi Control Config Table.')
apexDepiControlConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigEnable.setDescription('The enable setting for DEPI Control Connection.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n        ')
apexDepiControlConfigInterfaceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigInterfaceNumber.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigInterfaceNumber.setDescription("Represents the Gigabit Ethernet interface number.\n         Range:\n            '0'      = Not Applicable\n            GBE      = 1-4\n        ")
apexDepiControlConfigSrcIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigSrcIpAddr.setDescription('This parameter indicates the M-CMTS Core IP address.\n        ')
apexDepiControlConfigOverUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("over-IP", 1), ("over-UDP", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigOverUdp.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigOverUdp.setDescription('This parameter indicates whether the DEPI Control Connection and\n         Sessions will be accepted over the UDP protocol.\n        ')
apexDepiControlConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiControlConfigType.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlConfigType.setDescription('This parameter indicates whether DEPI Sessions are established\n         dynamically using the DEPI control protocol or statically.\n         \n         Not supported.\n        ')
apexDepiControlStatusGeneralTotalConnections = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralTotalConnections.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralTotalConnections.setDescription('The number of DEPI Control Connections established since reboot.')
apexDepiControlStatusGeneralCurrentConnections = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralCurrentConnections.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralCurrentConnections.setDescription('The current number of DEPI Control Connections currently connected.')
apexDepiControlStatusGeneralRejectedConnections = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralRejectedConnections.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralRejectedConnections.setDescription('The number of control connection requests rejected for any reason.')
apexDepiControlStatusGeneralUnknownConnectionMessages = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralUnknownConnectionMessages.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralUnknownConnectionMessages.setDescription('The number of DEPI control messages ignored not related to any\n        existing control connection i.e. unrecognized connection identifier.')
apexDepiControlStatusGeneralUnknownSessionMessages = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralUnknownSessionMessages.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralUnknownSessionMessages.setDescription('The number of DEPI messages ignored not related to any existing\n        session i.e. unrecognized session identifier.')
apexDepiControlStatusGeneralInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusGeneralInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusGeneralInvalidApplyText.setDescription("When apexDepiControlConfigApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexDepiControlStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2), )
if mibBuilder.loadTexts: apexDepiControlStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusTable.setDescription('Table of read-only status information pertaining to the DEPI Control\n         Connections.')
apexDepiControlStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiControlStatusIndex"))
if mibBuilder.loadTexts: apexDepiControlStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusEntry.setDescription('DEPI Control Status Table Entry.')
apexDepiControlStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: apexDepiControlStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusIndex.setDescription('DEPI Session ID')
apexDepiControlStatusLocalUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusLocalUdp.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusLocalUdp.setDescription('The EQAM UDP port used in DEPI session messages from M-CMTS core.\n         Only valid for DEPI connections using L2TPv3/UDP/IP.\n        ')
apexDepiControlStatusRemoteUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusRemoteUdp.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusRemoteUdp.setDescription('The M-CMTS UDP port used in DEPI session messages from M-CMTS core.\n         Only valid for DEPI connections using L2TPv3/UDP/IP.\n        ')
apexDepiControlStatusConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("terminated", 1), ("failed", 2), ("waiting", 3), ("established", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusConnectionStatus.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusConnectionStatus.setDescription('M-CMTS core to the EQAM control connection status')
apexDepiControlStatusUnknownCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusUnknownCtl.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusUnknownCtl.setDescription('Number of unrecognized DEPI messages not marked as mandatory\n         received on this control connection.\n        ')
apexDepiControlStatusMalformedCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusMalformedCtl.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusMalformedCtl.setDescription('Number of malformed DEPI messages received on this control\n         connection.\n        ')
apexDepiControlStatusUnknownAvp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusUnknownAvp.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusUnknownAvp.setDescription('Number of messages received on this control connection with an\n         unsupported AVP.\n        ')
apexDepiControlStatusMalformedAvp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusMalformedAvp.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusMalformedAvp.setDescription('Number of messages received on this control connection with\n         malformed AVP.\n        ')
apexDepiControlStatusInvalidVendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusInvalidVendorId.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusInvalidVendorId.setDescription('Number of messages with an unsupported Vendor ID received on this\n         control connection. The supported vendor IDs are 0 or 4491.\n        ')
apexDepiControlStatusHbitSet = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusHbitSet.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusHbitSet.setDescription('Number of messages received on this control connection with H-bit\n         set to 1.\n        ')
apexDepiControlStatusTotalSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusTotalSessions.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusTotalSessions.setDescription('Total number of sessions established on this control connection since\n         EQAM reboot. Only valid for dynamically established connections.\n        ')
apexDepiControlStatusCurrentSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusCurrentSessions.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusCurrentSessions.setDescription('Number of session currently  established on this control connection.\n         Only valid for dynamically established connections.\n        ')
apexDepiControlStatusRejectedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 3, 2, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiControlStatusRejectedSessions.setStatus('current')
if mibBuilder.loadTexts: apexDepiControlStatusRejectedSessions.setDescription('Number of session setup related (ICQR/ICCN) messages rejected on\n         this control connection.\n        ')
apexDepiSessionConfigApplyTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 1), )
if mibBuilder.loadTexts: apexDepiSessionConfigApplyTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigApplyTable.setDescription('Table of Apply Change for the data for apexDepiSessionConfigTable.\n        ')
apexDepiSessionConfigApplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 1, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiSessionConfigApplyOutputTsNum"))
if mibBuilder.loadTexts: apexDepiSessionConfigApplyEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigApplyEntry.setDescription('DEPI Session Status Table Entry.')
apexDepiSessionConfigApplyOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexDepiSessionConfigApplyOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigApplyOutputTsNum.setDescription('The index of the Depi Session Config Apply Table.')
apexDepiSessionConfigApplyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 1, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigApplyChange.setDescription("The Apply for any entries in the apexDepiSessionConfigTable.\n\n         This parameter MUST be set to 'apply' in order for any of the data\n         in the apexDepiSessionConfigTable to take effect.  This\n         parameter MUST be set LAST after all other data in the table entry has\n         been configured.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexDepiSessionConfigTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2), )
if mibBuilder.loadTexts: apexDepiSessionConfigTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigTable.setDescription("Table of data for DEPI Session Mapping. There are\n         48 rows in this table mapping QAM output TS to DEPI Session.\n\n         Once written, the change to this table will only take immediate\n         effect after apexDepiSessionConfigApplyChange is set to 'apply'.\n         However, in order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via apexSaveConfig.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexDepiSessionConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexDepiSessionConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiSessionConfigOutputTsNum"))
if mibBuilder.loadTexts: apexDepiSessionConfigEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigEntry.setDescription('DEPI Session  Config Table Entry.')
apexDepiSessionConfigOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexDepiSessionConfigOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigOutputTsNum.setDescription('The QAM output transport stream number which to associate the DEPI Session.\n        ')
apexDepiSessionConfigEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 2), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigEnable.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigEnable.setDescription('The enable setting for DEPI Session.\n\n         Once written, the change to this parameter will take immediate\n         effect.  In order for the change to persist through subsequent\n         reboots or power cycles, the change must be saved via the\n         apexSaveConfig parameter.\n        ')
apexDepiSessionConfigControlId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigControlId.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigControlId.setDescription('DOCSIS Control ID assignment. Value of 0 indicates transport stream to be used\n         for Video only.\n        ')
apexDepiSessionConfigDocsisTsid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigDocsisTsid.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigDocsisTsid.setDescription('The system wide unique M-CMTS TSID mapped to the QAM. This TSID is specified by the\n         remote ID from the ICRQ message.\n        ')
apexDepiSessionConfigUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigUdpPort.setDescription('UDP port number defining the DEPI Session (if UDP is enabled.) The\n         range of valid port numbers is 1 to 65535.\n        ')
apexDepiSessionConfigSyncCorrection = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 1, 2, 1, 6), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexDepiSessionConfigSyncCorrection.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionConfigSyncCorrection.setDescription('Enable or disable updating the timestamp in the SYNC messages. This\n        is only valid for static connections. (For dynamically established\n        sessions, M-CMTS core enables or disables the SYNC correction during\n        session establishment)\n        ')
apexDepiSessionStatusGeneralInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusGeneralInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusGeneralInvalidApplyText.setDescription("When apexDepiSessionConfigApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of what was wrong with the data. This\n         entry contains the description for the most recent apply\n         of a related entry that was invalid.\n        ")
apexDepiSessionStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2), )
if mibBuilder.loadTexts: apexDepiSessionStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusTable.setDescription('Table of read-only status information pertaining to the DEPI Sessions.')
apexDepiSessionStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexDepiSessionStatusIndex"))
if mibBuilder.loadTexts: apexDepiSessionStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusEntry.setDescription('DEPI Session Status Table Entry.')
apexDepiSessionStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexDepiSessionStatusIndex.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusIndex.setDescription('DEPI Session ID.')
apexDepiSessionStatusControlId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusControlId.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusControlId.setDescription('The DEPI Control ID this session belongs to.')
apexDepiSessionStatusOutputQAMChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusOutputQAMChannel.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusOutputQAMChannel.setDescription('The QAM Channel number this session is mapped to.')
apexDepiSessionStatusLocalUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusLocalUdp.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusLocalUdp.setDescription('The local UDP port used by the APEX to communicate the DEPI Session\n         messages to the M-CMTS Core')
apexDepiSessionStatusRemoteUdp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusRemoteUdp.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusRemoteUdp.setDescription('The remote UDP port used by the M-CMTS Core to communicate the DEPI\n         Session messages to the Apex.')
apexDepiSessionStatusStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("terminated", 1), ("failed", 2), ("waiting", 3), ("established", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusStatus.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusStatus.setDescription('M-CMTS core to the EQAM control connection status')
apexDepiSessionStatusPerHopBehavior = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusPerHopBehavior.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusPerHopBehavior.setDescription('Per Hop Behavior value for this session.')
apexDepiSessionStatusUnknownCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusUnknownCtl.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusUnknownCtl.setDescription('Number of unrecognized DEPI messages not marked as mandatory\n         received on this session.')
apexDepiSessionStatusMalformedCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusMalformedCtl.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusMalformedCtl.setDescription('Number of malformed DEPI messages received on this session.')
apexDepiSessionStatusUnknownAvp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusUnknownAvp.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusUnknownAvp.setDescription('Number of messages received on this session with an unsupported AVP.')
apexDepiSessionStatusMalformedAvp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusMalformedAvp.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusMalformedAvp.setDescription('Number of messages received on this session with malformed AVP.')
apexDepiSessionStatusInvalidVendorId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusInvalidVendorId.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusInvalidVendorId.setDescription('Number of messages with an unsupported Vendor ID received on this\n         session. The supported vendor IDs are 0 or 4491.')
apexDepiSessionStatusHbitSet = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusHbitSet.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusHbitSet.setDescription('Number of messages received on this session with H-bit set to 1.')
apexDepiSessionStatusInSLIMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusInSLIMsgs.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusInSLIMsgs.setDescription('Number of SLI messages received on this session.')
apexDepiSessionStatusOutSLIMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusOutSLIMsgs.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusOutSLIMsgs.setDescription('Number of SLI messages sent on this session.')
apexDepiSessionStatusIngressDlmMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusIngressDlmMsgs.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusIngressDlmMsgs.setDescription('Number of DLM messages received on this session.')
apexDepiSessionStatusEgressDlmMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusEgressDlmMsgs.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusEgressDlmMsgs.setDescription('Number of DLM messages sent on this session.')
apexDepiSessionStatusLatencyStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusLatencyStart.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusLatencyStart.setDescription('Last latency related timestamp start value received.')
apexDepiSessionStatusLatencyEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusLatencyEnd.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusLatencyEnd.setDescription('Last latency related timestamp end value received.')
apexDepiSessionStatusInDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusInDataPackets.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusInDataPackets.setDescription('Number of data packets received on this session.')
apexDepiSessionStatusInSequenceDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusInSequenceDiscards.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusInSequenceDiscards.setDescription('Number of data packets received on this session that are discarded\n         due to sequencing error.')
apexDepiSessionStatusInDataPacketDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusInDataPacketDiscards.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusInDataPacketDiscards.setDescription('Number of data packets received on this session that are discarded\n         for reasons other than sequencing errors.')
apexDepiSessionStatusSessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 24, 4, 2, 2, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexDepiSessionStatusSessionID.setStatus('current')
if mibBuilder.loadTexts: apexDepiSessionStatusSessionID.setDescription('Remote DEPI Session ID, used by the Remote End to identify the DEPI\n         Session and locally to bind the Session to a QAM Channel.')
apexPsipConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigApplyChange.setDescription("The Apply for parameters in apexPsipConfigGeneral.\n\n         This parameter MUST be set to 'apply' in order for other\n         apexPsipConfigGeneral parameters to take effect.\n         This parameter MUST be set LAST after other apexPsipConfigGeneral\n         parameters have been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexPsipConfigMgtMsgInsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(150, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigMgtMsgInsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigMgtMsgInsertionPeriod.setDescription("Specify insertion rate (ms) for MGT PSIP table.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigSttMsgInsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigSttMsgInsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigSttMsgInsertionPeriod.setDescription("Specify insertion rate (ms) for STT PSIP table.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigCvctMsgInsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigCvctMsgInsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigCvctMsgInsertionPeriod.setDescription("Specify insertion rate (ms) for CVCT PSIP table.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigRrtMsgInsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30000, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigRrtMsgInsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigRrtMsgInsertionPeriod.setDescription("Specify insertion rate (ms) for RRT PSIP table.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigEit0InsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigEit0InsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigEit0InsertionPeriod.setDescription("EIT insertion rate (ms) of EIT-0.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigEit1InsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigEit1InsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigEit1InsertionPeriod.setDescription("EIT insertion rate (ms) of EIT-1.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigEit2InsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigEit2InsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigEit2InsertionPeriod.setDescription("EIT insertion rate (ms) of EIT-2.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigEit3InsertionPeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigEit3InsertionPeriod.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigEit3InsertionPeriod.setDescription("EIT insertion rate (ms) of EIT-3.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeApplyChange.setDescription("The Apply for parameters in apexPsipConfigTime group.\n\n         This parameter MUST be set to 'apply' in order for other\n         apexPsipConfigTime parameters to take effect.\n         This parameter MUST be set LAST after other apexPsipConfigTime\n         parameters have been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexPsipConfigTimeDsMonthIn = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsMonthIn.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsMonthIn.setDescription("Configurable month for entering DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeDsDayIn = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsDayIn.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsDayIn.setDescription("Configurable day for entering DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeDsHourIn = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsHourIn.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsHourIn.setDescription("Configurable hour for entering DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeDsMonthOut = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsMonthOut.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsMonthOut.setDescription("Configurable month for exiting DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeDsDayOut = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsDayOut.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsDayOut.setDescription("Configurable day for exiting DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipConfigTimeDsHourOut = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 1, 2, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 18))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexPsipConfigTimeDsHourOut.setStatus('current')
if mibBuilder.loadTexts: apexPsipConfigTimeDsHourOut.setDescription("Configurable hour for exiting DST.\n\n         Once written, the change to this parameter will only take immediate\n         effect after apexPsipConfigTimeApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Commit(param=apexPsipConfigTimeApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexPsipStatusInputTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2), )
if mibBuilder.loadTexts: apexPsipStatusInputTable.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputTable.setDescription('The following table contains a list of messages that are being extracted\n         from the input side.\n        ')
apexPsipStatusInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexPsipStatusInputIndex"), (0, "APEX-MIB", "apexPsipStatusInputPid"), (0, "APEX-MIB", "apexPsipStatusInputMessageType"), (0, "APEX-MIB", "apexPsipStatusInputSourceId"), (0, "APEX-MIB", "apexPsipStatusInputSegment"), (0, "APEX-MIB", "apexPsipStatusInputPart"))
if mibBuilder.loadTexts: apexPsipStatusInputEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputEntry.setDescription('PSIP Table Entry.')
apexPsipStatusInputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 784)))
if mibBuilder.loadTexts: apexPsipStatusInputIndex.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputIndex.setDescription('Indicates the input index for which this message applies.')
apexPsipStatusInputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191)))
if mibBuilder.loadTexts: apexPsipStatusInputPid.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputPid.setDescription('Indicates the PID that this message is contained in.')
apexPsipStatusInputMessageType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: apexPsipStatusInputMessageType.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputMessageType.setDescription('Indicates the PSIP message type.\n         199 - MGT\n         200 - TVCT\n         201 - CVCT\n         203 - EIT\n         202 - RRT\n         205 - STT\n        ')
apexPsipStatusInputSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: apexPsipStatusInputSourceId.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputSourceId.setDescription('Indicates the Source Id of EIT tables.  When a\n         message is not specifically related to a program,\n         this value is 0.')
apexPsipStatusInputSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)))
if mibBuilder.loadTexts: apexPsipStatusInputSegment.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputSegment.setDescription('Indicates the segment number of this message.\n         Otherwise this is 0.')
apexPsipStatusInputPart = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: apexPsipStatusInputPart.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputPart.setDescription('Since a message can be 4096 bytes long the message\n         may divided into parts. Each part of the message is\n         indexed using this index.')
apexPsipStatusInputBody = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusInputBody.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputBody.setDescription('Raw ASCII hex of the PSIP message.')
apexPsipStatusInputGpsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusInputGpsTime.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputGpsTime.setDescription('The GPS time when the PSIP message was added to the table.')
apexPsipStatusInputInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusInputInfo.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusInputInfo.setDescription('Comma-separated string showing Input Interface, UDP port,\n         Multicast IP, and Source IP for this PSIP message.')
apexPsipStatusOutputTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3), )
if mibBuilder.loadTexts: apexPsipStatusOutputTable.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputTable.setDescription('The following table contains a list of messages that are\n         being inserted to the output side of the apex.\n        ')
apexPsipStatusOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexPsipStatusOutputIndex"), (0, "APEX-MIB", "apexPsipStatusOutputPid"), (0, "APEX-MIB", "apexPsipStatusOutputMessageType"), (0, "APEX-MIB", "apexPsipStatusOutputSourceId"), (0, "APEX-MIB", "apexPsipStatusOutputSegment"), (0, "APEX-MIB", "apexPsipStatusOutputPart"))
if mibBuilder.loadTexts: apexPsipStatusOutputEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputEntry.setDescription('PSIP Table Entry.')
apexPsipStatusOutputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48)))
if mibBuilder.loadTexts: apexPsipStatusOutputIndex.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputIndex.setDescription('Indicates the Output index for which this message applies.\n         This is the Output Transport Stream number (1..48).\n        ')
apexPsipStatusOutputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8191)))
if mibBuilder.loadTexts: apexPsipStatusOutputPid.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputPid.setDescription('Indicates the PID that this message is contained in.')
apexPsipStatusOutputMessageType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: apexPsipStatusOutputMessageType.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputMessageType.setDescription('Indicates the PSIP message type.\n         199 - MGT\n         200 - TVCT\n         201 - CVCT\n         203 - EIT\n         202 - RRT\n         205 - STT')
apexPsipStatusOutputSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: apexPsipStatusOutputSourceId.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputSourceId.setDescription('Indicates the Source Id of EIT tables.  When a\n         message is not specifically related to a program,\n         this value is 0.')
apexPsipStatusOutputSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)))
if mibBuilder.loadTexts: apexPsipStatusOutputSegment.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputSegment.setDescription('Indicates the segment number of this message.\n         Otherwise this is 0.')
apexPsipStatusOutputPart = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: apexPsipStatusOutputPart.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputPart.setDescription('Since a message can be 4096 bytes long the message may divided into parts.\n         Each part of the message is indexed using this index.')
apexPsipStatusOutputBody = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusOutputBody.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputBody.setDescription('Raw ASCII hex of the PSIP message.')
apexPsipStatusOutputGpsTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusOutputGpsTime.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusOutputGpsTime.setDescription('The GPS time when the PSIP message was added to the table.')
apexPsipStatusServiceTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4), )
if mibBuilder.loadTexts: apexPsipStatusServiceTable.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceTable.setDescription('The following table shows the PSIP status per service.\n         For each service, the service number, the Output Transport\n         Stream number, its PSIP state and its source id are shown\n         in the current entry. This table is indexed the same as\n         apexOutputProgramTable.\n        ')
apexPsipStatusServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexPsipStatusServiceIndex"))
if mibBuilder.loadTexts: apexPsipStatusServiceEntry.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceEntry.setDescription('PSIP Status Table Entry per service.')
apexPsipStatusServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexPsipStatusServiceIndex.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceIndex.setDescription('Output Program Table Index.')
apexPsipStatusServiceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusServiceNum.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceNum.setDescription('Current Output Service Number.')
apexPsipStatusServiceOutputTs = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusServiceOutputTs.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceOutputTs.setDescription('Current Output Transport Stream of this service.')
apexPsipStatusServiceState = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusServiceState.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceState.setDescription('Current program PSIP state.')
apexPsipStatusServiceSourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 25, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexPsipStatusServiceSourceId.setStatus('current')
if mibBuilder.loadTexts: apexPsipStatusServiceSourceId.setDescription('Current PSIP Program Source Id.')
apexSupportPreencryptedSimulcrypt = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 26, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexSupportPreencryptedSimulcrypt.setStatus('current')
if mibBuilder.loadTexts: apexSupportPreencryptedSimulcrypt.setDescription("Allows to configure the APEX to support services pre-encrypted with Simulcrypt.\n         All the CA descriptors present in the input PMT will be copied to the output PMT,\n         modifying the ECM PID references if needed.\n         Default value is enabled.\n         \n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexOutputAncillaryPidBitrateSamplePeriod = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidBitrateSamplePeriod.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidBitrateSamplePeriod.setDescription('Sample Period for Output Ancillary PID bitrate collection.\n         This parameter indicates the length of time in the unit of \n         milliseconds the TS packets are collected during a sample.\n        ')
apexOutputAncillaryPidStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2), )
if mibBuilder.loadTexts: apexOutputAncillaryPidStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidStatusTable.setDescription("This table shows the status of input ancillary PID to output ancillary\n         PID mappings which are configured through either apexPidMapTable or\n         apexBulkPidMapTable. As 'apexBulkPidMapTable' maps the same PID\n         to multiple output transport streams, then for each selected OTSs \n         a separate PID mapping will be created. Accordingly, for each mapping \n         there will be a separate status entry in the status table.\n        ")
apexOutputAncillaryPidStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputAncillaryPidIndex"))
if mibBuilder.loadTexts: apexOutputAncillaryPidStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidStatusEntry.setDescription("Output Ancillary PID Status Table Entry.\n         As 'apexBulkPidMapTable' maps the same PID to multiple output \n         transport streams, then for each selected OTSs a separate PID\n         mapping will be created. Accordingly, for each mapping\n         there will be a separate status entry in the status table.\n         \n         The manually configurable ancillary PIDs are 480. DTA configured\n         ancillary PIDs are 144 (CAT, EMM and NET pids routed to all 48 OTSs)\n        ")
apexOutputAncillaryPidIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 624)))
if mibBuilder.loadTexts: apexOutputAncillaryPidIndex.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidIndex.setDescription('Output Ancillary PID Status Table Index.\n        ')
apexOutputAncillaryPidInputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 784))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidInputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidInputTsNum.setDescription("This input TS number points the index in the 'apexInputTsStatTable'.\n         The index will be used to retrieve the input TS details like\n         Input Interface, UDP port, Multicast IP and Source IP.\n        ")
apexOutputAncillaryPidInputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidInputPid.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidInputPid.setDescription("This input ancillary PID will be extracted from the input TS \n         pointed by the 'apexOutputAncillaryPidInputTsNum'.\n        ")
apexOutputAncillaryPidOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidOutputTsNum.setDescription('Output Transport Stream Number to which the Input ancillary\n         PID is routed.\n        ')
apexOutputAncillaryPidOutputPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidOutputPid.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidOutputPid.setDescription('Output Ancillary PID.\n        ')
apexOutputAncillaryPidRoutingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidRoutingStatus.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidRoutingStatus.setDescription('Ancillary PID Routing Status. The list of status information is \n         mentioned below.\n         Not Defined                    - When a PID is mapped, but not \n                                          activated.\n         Successfully multiplexing      - When a PID is mapped, activated and\n                                          input PID is available.\n         Input ancillary PID is missing - When a PID is mapped and activated,\n                                          but the input PID is not available.\n        ')
apexOutputAncillaryPidAverageBitrate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 27, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputAncillaryPidAverageBitrate.setStatus('current')
if mibBuilder.loadTexts: apexOutputAncillaryPidAverageBitrate.setDescription("Bitrate is measured for the sample period\n         'apexOutputAncillaryPidBitrateSamplePeriod'.\n         This parameter contains the average bitrate, \n         calculated from the samples collected for the \n         rolling sampling interval. The sampling interval\n         is upto last fifteen minutes.\n         This parameter is in bits per second (bps).\n        ")
apexUlsConfigGenerateRequest = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 1, 1), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUlsConfigGenerateRequest.setStatus('current')
if mibBuilder.loadTexts: apexUlsConfigGenerateRequest.setDescription("The Apply for generating ULS Feature Requests.\n        \n         This parameter MUST be set to 'apply' in order for \n         apexUlsConfigMcSimChannelsRequest\n         to take effect.\n         This parameter MUST be set LAST after all other data has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexUlsConfigValidateResponse = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 1, 2), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUlsConfigValidateResponse.setStatus('current')
if mibBuilder.loadTexts: apexUlsConfigValidateResponse.setDescription("The Apply for validating ULS Feature Response.\n        \n         This parameter MUST be set to 'apply' in order for \n         ULS-generated feature key file to be submitted.\n         This parameter MUST be set after the binary key file \n         has been SFTP to the target device.\n\n         @Config(config=no, reboot=no)\n        ")
apexUlsConfigCommitNewFeatures = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 1, 3), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUlsConfigCommitNewFeatures.setStatus('current')
if mibBuilder.loadTexts: apexUlsConfigCommitNewFeatures.setDescription("The Apply for committing ULS feature Keys.\n        \n         This parameter MUST be set to 'apply' in order for \n         the validated feature keys to be committed.\n\n         @Config(config=no, reboot=no)\n        ")
apexUlsConfigMcSimChannelsRequest = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 1, 2, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexUlsConfigMcSimChannelsRequest.setStatus('current')
if mibBuilder.loadTexts: apexUlsConfigMcSimChannelsRequest.setDescription('Number of MediaCipher Simulcrypt channels, being requested in this feature.\n         \n         @Config(config=no, reboot=no)\n         @Commit(param=apexUlsConfigGenerateRequest , value=2)\n        ')
apexUlsStatusGenerateRequestText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusGenerateRequestText.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusGenerateRequestText.setDescription('When apexUlsConfigGenerateRequest is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply that was invalid.\n        ')
apexUlsStatusValidateResponseText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusValidateResponseText.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusValidateResponseText.setDescription('When apexUlsConfigValidateResponse is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply that was invalid.\n        ')
apexUlsStatusCommitNewFeaturesText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusCommitNewFeaturesText.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusCommitNewFeaturesText.setDescription('When apexUlsConfigCommitNewFeatures is set to applyNotInProgressInvalidData\n         this entry may contain a text description of what was wrong with the data.\n         This entry contains the description for the most recent apply that was invalid.\n        ')
apexUlsStatusMcSimChannelsCurrent = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsCurrent.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsCurrent.setDescription('Number of MediaCipher Simulcrypt channels, currently allowed in this feature.')
apexUlsStatusMcSimChannelsInUse = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsInUse.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsInUse.setDescription('Number of MediaCipher Simulcrypt channels, in use.')
apexUlsStatusMcSimChannelsMax = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 28, 2, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsMax.setStatus('current')
if mibBuilder.loadTexts: apexUlsStatusMcSimChannelsMax.setDescription('Maximum number of MediaCipher Simulcrypt channels allowed to be used, even if the\n         license provides for more.')
apexSimulcryptEcmgStatusTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4), )
if mibBuilder.loadTexts: apexSimulcryptEcmgStatusTable.setStatus('current')
if mibBuilder.loadTexts: apexSimulcryptEcmgStatusTable.setDescription('Table of Rds2 Events.\n         The index apexSimulcryptEcmgProgramIndex matches the\n         row index in apexManualRouteTable.\n        ')
apexSimulcryptEcmgStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexSimulcryptEcmgProgramIndex"))
if mibBuilder.loadTexts: apexSimulcryptEcmgStatusEntry.setStatus('current')
if mibBuilder.loadTexts: apexSimulcryptEcmgStatusEntry.setDescription('Rds2 Events Table Entry.')
apexSimulcryptEcmgProgramIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 768)))
if mibBuilder.loadTexts: apexSimulcryptEcmgProgramIndex.setStatus('current')
if mibBuilder.loadTexts: apexSimulcryptEcmgProgramIndex.setDescription('apexSimulcryptEcmgProgramIndex is the last 10 bits of\n         apexOutputProgramEcmServiceId from apexOutputProgramTable.')
apexOutputProgramCAS1EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS1EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS1EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the first CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS1EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS1EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS1EcmgStream.setDescription('This combined with apexOutputProgramCAS1EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the first CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS2EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS2EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS2EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the second CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS2EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS2EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS2EcmgStream.setDescription('This combined with apexOutputProgramCAS2EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the second CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS3EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS3EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS3EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the third CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS3EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS3EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS3EcmgStream.setDescription('This combined with apexOutputProgramCAS3EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the third CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS4EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS4EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS4EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the fourth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS4EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS4EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS4EcmgStream.setDescription('This combined with apexOutputProgramCAS4EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the fourth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS5EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS5EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS5EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the fifth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS5EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS5EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS5EcmgStream.setDescription('This combined with apexOutputProgramCAS5EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the fifth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS6EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS6EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS6EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the sixth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS6EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS6EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS6EcmgStream.setDescription('This combined with apexOutputProgramCAS6EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the sixth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS7EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS7EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS7EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the seventh CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS7EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS7EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS7EcmgStream.setDescription('This combined with apexOutputProgramCAS7EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the seventh CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS8EcmgChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS8EcmgChannel.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS8EcmgChannel.setDescription('The index into the simulcryptEcmgStatChannelTable for the eigth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexOutputProgramCAS8EcmgStream = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 29, 1, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputProgramCAS8EcmgStream.setStatus('current')
if mibBuilder.loadTexts: apexOutputProgramCAS8EcmgStream.setDescription('This combined with apexOutputProgramCAS8EcmgChannel gives the \n         index into simulcryptEcmgStatStreamTable for the eigth CAS system.\n         This is applicable only when Simulcrypt is enabled.\n        ')
apexMcSimEnableDacId = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1, 1, 1), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcSimEnableDacId.setStatus('current')
if mibBuilder.loadTexts: apexMcSimEnableDacId.setDescription("This enables prepending the DAC ID to the Access Criteria in the \n         SCS<=>ECMG Control Word Provision request.\n                   \n         Once written, the change to this parameter will only take immediate\n         effect after apexMcSimConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         Default value is disabled.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcSimConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')                                 \n        ")
apexMcSimDacId = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcSimDacId.setStatus('current')
if mibBuilder.loadTexts: apexMcSimDacId.setDescription("The DAC ID to be prepended to the Access Criteria in the \n         SCS<=>ECMG Control Word Provision request.\n                   \n         Once written, the change to this parameter will only take immediate\n         effect after apexMcSimConfigApplyChange is set to 'apply'.  In\n         order for the change to persist through subsequent reboots or power\n         cycles, the change must be saved via apexSaveConfig.\n\n         Default value is 0.\n         \n         @Config(config=yes, reboot=no)\n         @Commit(param=apexMcSimConfigApplyChange, value=2)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')                                 \n        ")
apexMcSimConfigApplyChange = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1, 1, 3), ApplyDataToDeviceTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexMcSimConfigApplyChange.setStatus('current')
if mibBuilder.loadTexts: apexMcSimConfigApplyChange.setDescription("The Apply for MC SimulCrypt Configuration.\n\n         This parameter MUST be set to 'apply' in order for the Queuing Device ID, \n         or DAC ID to take effect in the APEX.  \n         This parameter MUST be set LAST after the MC Simulcrypt Enable\n         has been configured.\n\n         @Config(config=no, reboot=no)\n        ")
apexMcSimConfigInvalidApplyText = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 30, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMcSimConfigInvalidApplyText.setStatus('current')
if mibBuilder.loadTexts: apexMcSimConfigInvalidApplyText.setDescription("When corresponding apexMcSimEnableApplyChange is set to\n         'applyNotInProgressInvalidData' this entry may contain\n         a text description of why MC Simulcrypt was not enabled/disabled.\n        ")
apexAlarmHardwareFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8000), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmHardwareFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmHardwareFault.setDescription("Indicates that a Hardware related error occurred.  Examples include\n         missing or uncommunicative HW, failures in initialization of HW, and\n         failures to configure HW.  These can occur at startup or when the\n         system is operational.  Types of HW Faults include:  Application File(s)\n         Download failure; SPI Interface Initialization failure; PCI Interface\n         Initialization failure; GigE Configuration failure; MUX Configuration\n         failure; QAM Module Communication failure; Unsupported/Incorrect\n         HW/FW Version (QAM, etc.); Fatal Host Firmware Exception.\n\n         'critical' indicates a fatal error occurred that prevents the APEX\n          from performing operational requirements.\n\n         'warning' indicates an error that does not prevent the APEX from\n         performing operational requirements.\n        ")
apexAlarmInvalidInitData = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8001), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmInvalidInitData.setStatus('current')
if mibBuilder.loadTexts: apexAlarmInvalidInitData.setDescription('Set when invalid Initialization data (ini files) is encountered.\n        ')
apexAlarmTemperatureFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8002), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmTemperatureFault.setDescription("'critical' indicates one or more temperature sensors is reporting a\n         high temperature condition.\n        ")
apexAlarmFanFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8003), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmFanFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmFanFault.setDescription("'major' indicates one or more fans has reduced RPM readings.\n        ")
apexAlarmPowerFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8004), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmPowerFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmPowerFault.setDescription("Power Supply Fault Alarm.\n\n         'warning' indicates power supply not compatible (apexPsStatusInstalled).\n         'major' indicates power supply or fan only module) removed\n            (apexPsStatusInstalled).\n         'major' indicates power supply input power fault (apexPsStatusInputPowerStatus),\n            output power fault (apexPsStatusOutputPowerStatus), or comm fault\n            (apexPsStatusCommError).\n         'critical' indicates power supply over temperature fault\n            (apexPsStatusTemperatureStatus).\n        ")
apexAlarmGbeLossOfPhysicalInput = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8020), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeLossOfPhysicalInput.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeLossOfPhysicalInput.setDescription("Loss of Physical Gigabit Ethernet Input Alarm.\n\n         'critical' indicates that one or more physical interfaces that are\n         configured as enabled to receive input have a failure\n         (apexGbeStatusLossOfPhysicalInput).\n\n         Physical input interfaces can be disabled to prevent this alarm\n         when no input is connected.\n        ")
apexAlarmGbeBufferFullness = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8021), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeBufferFullness.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeBufferFullness.setDescription("Gigabit Ethernet Frame Buffer Fullness Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Frame buffers are about to or have overflowed.  The overflow level is\n         based on the actual input data rate.\n\n         'major' when the frame buffer crosses a user specified threshold\n         (apexGbeConfigFrameBufferAlarmThreshold).  Cleared when the buffer level drops\n         below the threshold.\n\n         'critical' when the frame buffer is completely full and frames are being\n         dropped.  Cleared when the overflow condition stops.\n\n         A Major alarm, depending on the threshold setting, indicates that the\n         APEX is getting close to overflowing it's internal Gigabit Ethernet\n         frame buffers.\n\n         A Critical alarm indicates that the frame buffer levels have overflowed.\n         This will cause loss of packets and may result in tiling and other output\n         anomalies.\n        ")
apexAlarmGbeInputStreamLowBitRate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8022), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeInputStreamLowBitRate.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeInputStreamLowBitRate.setDescription("Gigabit Ethernet Input Stream Low Bit Rate Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams as configured in apexManRteGbeInRedTable have a low\n         bit rate condition.  For alarm status of each stream refer to entries\n         apexGbeStatInTsPriLowBitRateAlarm and apexGbeStatInTsSecLowBitRateAlarm.\n\n         'major' when one or more stream bit rates are below their\n         apexManRteGbeInRedPriLowAlarmBitRate or apexManRteGbeInRedSecLowAlarmBitRate.\n         Clears when all streams have been restored to at or above their configured\n         apexManRteGbeInRedPriLowAlarmBitRate or apexManRteGbeInRedSecLowAlarmBitRate.\n        ")
apexAlarmGbeInputStreamHighBitRate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8023), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeInputStreamHighBitRate.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeInputStreamHighBitRate.setDescription("Gigabit Ethernet Input Stream High Bit Rate Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams as configured in apexManRteGbeInRedTable or via a Session\n         Controller have a high bit rate condition.  For alarm status of each\n         stream refer to entry apexGbeStatInTsPriHighBitRateAlarm and\n         apexGbeStatInTsSecHighBitRateAlarm.\n\n         'major' when one or more stream bit rates are above their\n         apexManRteGbeInRedPriHighAlarmBitRate or apexManRteGbeInRedSecHighAlarmBitRate.\n         Clears when all streams have been restored to at or below their configured\n         apexManRteGbeInRedPriHighAlarmBitRate or apexManRteGbeInRedSecHighAlarmBitRate.\n        ")
apexAlarmGbeMptsRedundPrimaryThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8024), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeMptsRedundPrimaryThreshold.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeMptsRedundPrimaryThreshold.setDescription("Gigabit Ethernet Input MPTS Redundant Primary Stream Below Threshold Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams configured in apexManRteGbeInRedTable as being the Primary\n         stream of a Redundant Pair are below the configured threshold.\n         For alarm status of each stream refer to entry\n         apexGbeStatInTsMptsRedundPriAlarm.\n\n         'major' when one or more stream bit rates are below their threshold\n         as specified in apexManRteGbeInRedThreshold.  Clears when all\n         streams have been restored to at or above their configured\n         apexManRteGbeInRedThreshold.\n        ")
apexAlarmGbeMptsRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8025), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeMptsRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeMptsRedundFailOver.setDescription("Gigabit Ethernet Input MPTS Redundant Fail Over Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams configured in apexManRteGbeInRedTable as being the Primary\n         stream of a Redundant Pair have Failed Over to the Secondary stream.\n         For alarm status of each stream refer to entry apexGbeStatInTsMptsRedundFailAlarm.\n\n         'major' when one or more Redundant Primary streams have failed over to\n         the Secondary.  Clears when all Primary streams have been restored and the\n         APEX has switched back to the Primary from the Secondary.\n        ")
apexAlarmServiceInError = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8026), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmServiceInError.setStatus('current')
if mibBuilder.loadTexts: apexAlarmServiceInError.setDescription("Alarm Service In Error.\n\n         'major' indicates that one or more services is in error (unable\n         to fully continue processing). However, this is only for very\n         specific errors where the error could be caused by either the\n         input stream being invalid or another command along with the\n         input stream is causing the error. For example, if mapping an\n         input service to an output and that PMT is not referenced in\n         the PAT, or the number of PIDs in the PMT is greater than the\n         number of PIDs supported, then the command is in error. This\n         error condition would be cleared if a new PAT is received\n         referencing the PMT or in the other case, if a new PMT is\n         received referencing a valid number of PIDs.\n\n         Refer to apexOutputProgramRoutingStatus for more information.\n\n         This alarm occurs on the first error.  It is not issued for\n         additional errors.  It is cleared when all errors are cleared.\n        ")
apexAlarmGbeLossOfInputStream = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8027), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeLossOfInputStream.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeLossOfInputStream.setDescription('Loss of Gbe Input Stream Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams is missing. A missing input stream is determined based\n         on user configured data or stream rate and detection timeout value. This\n         alarm is only applicable when the input streams are configured to be\n         monitored for loss of input stream.\n\n          This alarm occurs on the first error.  It is not issued for\n         additional errors.  It is cleared when all errors are cleared.\n        ')
apexAlarmGigeToHostCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8028), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGigeToHostCommFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGigeToHostCommFault.setDescription('Loss of Communications from Gige to Host Alarm.\n\n         This alarm is used to inform the user when the Host processor is no longer receiving\n         periodic status messages from the Gige processor.\n\n         This alarm occurs on the first error.  It is not issued for\n         additional errors. It is cleared when the condition is resolved.\n        ')
apexAlarmGbeInterfaceRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8029), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeInterfaceRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeInterfaceRedundFailOver.setDescription("Gigabit Ethernet Interface Redundant Fail Over Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         interfaces have Failed Over to the Secondary interface.  The APEX determines an\n         interface as failed when link has been lost.\n\n         'major' when one or more Primary interfaces have failed over to\n         the Secondary.  Clears when all Primary interfaces have been restored and the\n         APEX has switched back to the Primary from the Secondary.\n        ")
apexAlarmLossOfInputAncillaryPid = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8030), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmLossOfInputAncillaryPid.setStatus('current')
if mibBuilder.loadTexts: apexAlarmLossOfInputAncillaryPid.setDescription("Loss of input ancillary PID Alarm.\n\n         This alarm is raised when one or more input ancillary PID(s)\n         is(are) missing in the input transport streams. The APEX \n         monitors each input ancillary PID configured through either \n         'apexPidMapTable' or 'apexBulkPidMapTable' or 'apexDtaOtsConfigTable'.\n         The APEX will monitor for the 'apexPidMapInputAncillaryPidDetectionTimeout'\n         period, before declaring the loss of input ancillary PID.\n         \n         'minor' - When one or more input ancillary PIDs are missing.\n         'clear' - When all the ancillary PIDs are available in the input.\n        ")
apexAlarmGbeInputStreamPacketDrop = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8031), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmGbeInputStreamPacketDrop.setStatus('current')
if mibBuilder.loadTexts: apexAlarmGbeInputStreamPacketDrop.setDescription("Gigabit Ethernet Input Stream Packet Drop Alarm.\n\n         This alarm is used to inform the user when one or more Gigabit Ethernet\n         Input Streams have a dropped packet condition.\n\n         'major' when one of the stream's packets is dropped.\n        ")
apexAlarmOutputUtilizationFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8040), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmOutputUtilizationFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmOutputUtilizationFault.setDescription("Output Transport Stream Utilization Threshold Alarm.\n\n         'minor' when apexOutputTsUtilMonAlarmThreshold is met or\n         exceeded for apexOutputTsUtilMonSetAlarmDelay for an OTS.\n\n         The alarm will clear after the OTS remains below\n         apexOutputTsUtilMonAlarmThreshold for\n         apexOutputTsUtilMonClearAlarmDelay.\n        ")
apexAlarmOutputOverflow = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8041), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmOutputOverflow.setStatus('current')
if mibBuilder.loadTexts: apexAlarmOutputOverflow.setDescription("Output Transport Stream Overflow Alarm.\n\n         'critical' when apexOutputTsUtilizOverflow occurs for an OTS.\n\n         The alarm will clear when OTS no longer in overflow.\n        ")
apexAlarmQamModuleFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8042), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamModuleFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamModuleFault.setDescription("QAM Port Fault Alarm.\n\n         'major' when apexQamModuleStatError occurs when all QAM channels on\n         the QAM Module have apexQamChanStatActive of not 'active'.\n\n         'critical' when apexQamModuleStatError occurs when all QAM channels on\n         the QAM Module have apexQamChanStatActive of 'active'.\n\n         The alarm will clear after all faults clear on the QAM Module.\n\n         The current alarm status on a QAM Module basis can be found in\n         apexQamModuleStatFaultCondition.\n        ")
apexAlarmQamRfPortFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8043), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamRfPortFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamRfPortFault.setDescription("QAM RF Port Fault Alarm.\n\n         'major' when power voltage or output RF level error occurs on the RF Port.\n\n         'critical' when clock, PLL, or data sync error occurs on the RF Port.\n\n         The alarm will clear after all faults clear for the RF Port.\n\n         The current alarm status on an RF port basis can be found in\n         apexQamRfPortStatFaultCondition.\n        ")
apexAlarmQamChannelFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8044), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamChannelFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamChannelFault.setDescription("QAM Channel Fault Alarm.\n\n         'critical' when any or all of the QAM Channel errors\n         enumerated in apexQamChanStatError occur on a QAM channel.\n\n         The alarm will clear after all faults clear on the QAM channel.\n\n         The current alarm status on a QAM channel basis can be found in\n         apexQamChanStatFaultCondition.\n        ")
apexAlarmQamRfRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8045), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamRfRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamRfRedundFailOver.setDescription("QAM RF Redundancy Fail Over Alarm.\n         'major' when the backup QAM RF Port status is 'active' (apexQamRfRedundStatusBackupPort).\n                 This occurs when a primary QAM RF Port has failed over to the backup RF Port or\n                 the user has forced a primary to the backup.\n\n         The alarm will clear when the backup QAM RF Port status returns to 'standby'.\n         The alarm is relevant only when apexQamRfRedundConfigEnable is 'enabled'.\n         The current QAM RF Port that is active on the backup port can be found\n         in apexQamRfRedundStatusFailedPort.\n         ")
apexAlarmQamRfRedundMismatch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8046), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamRfRedundMismatch.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamRfRedundMismatch.setDescription("QAM RF Redundancy Mismatch Alarm.\n         'warning' when channels could be lost on QAM RF Fail Over to backup or on Switch Back to\n                   primary.  Refer to apexQamRfRedundStatusMismatch for more information.\n\n         The alarm will clear when mismatch condition clears.\n         The alarm is relevant only when apexQamRfRedundConfigEnable is 'enabled'.\n        ")
apexAlarmQamModuleRemovalFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8047), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmQamModuleRemovalFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmQamModuleRemovalFault.setDescription("QAM Module Removal Fault Alarm.\n\n         'critical' when apexQamModuleStatError occurs when any QAM channels on\n         the QAM Module have apexQamChanStatActive of 'active'.\n\n         The alarm will clear after the fault is cleared on the QAM Module.\n\n\n        ")
apexAlarmRtspControllerCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8050), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmRtspControllerCommFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmRtspControllerCommFault.setDescription("RTSP Controller Communication Fault.\n\n         'major' when the RTSP Controller is experiencing a\n         communication fault.\n\n         The alarm will clear when connection is restored the RTSP\n         controller.\n        ")
apexAlarmRdsCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8060), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmRdsCommFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmRdsCommFault.setDescription("RDS Communication Fault.\n\n         'major' when experiencing an RDS\n         communication fault.\n\n         The alarm will clear when RDS connection is restored.\n        ")
apexAlarmRemCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8070), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmRemCommFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmRemCommFault.setDescription("REM Communication Fault.\n         'major' when experiencing an REM communication fault.\n\n         The alarm will clear when REM connection is restored.\n         Refer to apexQamRfRedundStatusRemConnection for more information.\n         The alarm is relevant only when apexQamRfRedundConfigEnable is 'enabled'\n         and apexQamRfRedundConfigRemConnection is not 'none'.\n        ")
apexAlarmRemFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8071), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmRemFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmRemFault.setDescription("REM Fault.\n         'warning' when REM is reporting a 0x05 error code.\n\n         'major'   when error received from REM (other than 0x05) or REM is reporting\n                   incorrect switch configuration.\n\n         The alarm will clear when REM errors clear.\n         Refer to apexQamRfRedundStatusRemError and apexQamRfRedundStatusRemSwitch\n         for more information.\n         The alarm is relevant only when apexQamRfRedundConfigEnable is 'enabled'\n         and apexQamRfRedundConfigRemConnection is not 'none'.\n        ")
apexAlarmDepiControlConnectionFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8080), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmDepiControlConnectionFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmDepiControlConnectionFault.setDescription('DEPI Control connection setup Fault.\n        ')
apexAlarmDepiSessionSetupFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8081), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmDepiSessionSetupFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmDepiSessionSetupFault.setDescription('DEPI Session Setup Fault.\n        ')
apexAlarmDtiSyncLossFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8082), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmDtiSyncLossFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmDtiSyncLossFault.setDescription('EQAM lost SYNC with the DTI Server.\n        ')
apexAlarmChassisRedundancyPrimaryFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8090), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmChassisRedundancyPrimaryFailover.setStatus('current')
if mibBuilder.loadTexts: apexAlarmChassisRedundancyPrimaryFailover.setDescription('Generated when the primary active APEX fails over to the secondary standby unit.\n        Trap tells if failover is operator induced, or automatic because of a fault.\n        Major if automatic due to some fault Warning if force-failover.\n        Cleared when redundancy is disabled or when the primary becomes active and\n        the secondary is standby.\n        ')
apexAlarmChassisRedundancySecondaryFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8091), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmChassisRedundancySecondaryFailover.setStatus('current')
if mibBuilder.loadTexts: apexAlarmChassisRedundancySecondaryFailover.setDescription('Generated when the secondary active APEX fails over to the primary standby unit.\n        Trap tells if failover is operator induced, or automatic because of a fault.\n        Major if automatic due to some fault Warning if force-failover.\n        Cleared when redundancy is disabled or when the secondary becomes active and\n        the primary is standby.\n        ')
apexAlarmChassisRedundancyAvailabilityFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8092), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmChassisRedundancyAvailabilityFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmChassisRedundancyAvailabilityFault.setDescription('Generated when redundancy status is unavailable (except for link loss)\n        configuration not synchronized secondary in fault state Cleared\n        when redundancy status is available or redundancy disabled.\n        ')
apexAlarmChassisRedundancyLinkFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8093), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmChassisRedundancyLinkFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmChassisRedundancyLinkFault.setDescription('Generated when ENET2 link is lost\n        Cleared when ENET 2 link is present or redundancy disabled.')
apexAlarmChassisRedundancyConfigurationFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 100, 8094), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexAlarmChassisRedundancyConfigurationFault.setStatus('current')
if mibBuilder.loadTexts: apexAlarmChassisRedundancyConfigurationFault.setDescription('Generated when primary APEX receives heartbeat from another primary.\n        Critical if APEX was in active state (sourcing broadcast content)\n        Major if APEX was in standby state (broadcast ports muted).\n        Cleared when primary APEX receives heartbeat from a secondary, configuration is changed to secondary,\n        or redundancy is disabled.')
apexEventEmUserLoginFailed = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8100), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventEmUserLoginFailed.setStatus('current')
if mibBuilder.loadTexts: apexEventEmUserLoginFailed.setDescription('Event to indicate APEX EM User login failed 5 times.')
apexEventQamModuleUpgraded = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8101), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventQamModuleUpgraded.setStatus('current')
if mibBuilder.loadTexts: apexEventQamModuleUpgraded.setDescription('Event to indicate a QAM Module has been upgraded from 2x4 to 2x8\n         channel capability.')
apexEventSnmpCommunityStringChanged = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8102), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventSnmpCommunityStringChanged.setStatus('current')
if mibBuilder.loadTexts: apexEventSnmpCommunityStringChanged.setDescription('Event to indicate that the read/read-write SNMP community strings are changed\n         Trap description is given in trapSnmpCommunityStringChanged\n        ')
apexEventEasMessageNotReceived = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8103), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventEasMessageNotReceived.setStatus('current')
if mibBuilder.loadTexts: apexEventEasMessageNotReceived.setDescription("Generated when the EAS message is not received for the amount of time configured by\n        the object 'apexEasMessageReceiveTimeoutDuration'")
apexEventLossOfInputAncillaryPid = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8104), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventLossOfInputAncillaryPid.setStatus('current')
if mibBuilder.loadTexts: apexEventLossOfInputAncillaryPid.setDescription("Event to indicate that the input PID has not received.\n         \n         This event is sent when one or more input ancillary PID(s)\n         is(are) missing in the input transport streams. The APEX \n         monitors each input ancillary PID configured through either \n         'apexPidMapTable' or 'apexBulkPidMapTable' or 'apexDtaOtsConfigTable'.\n         The APEX will monitor for the 'apexPidMapInputAncillaryPidDetectionTimeout'\n         period, before declaring the loss of input ancillary PID.\n         \n         'minor' - When one or more input ancillary PIDs are missing.\n         'clear' - When the ancillary PIDs and input TS are not available in the input")
apexEventChassisRedunPrimaryForceFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8110), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventChassisRedunPrimaryForceFailover.setStatus('obsolete')
if mibBuilder.loadTexts: apexEventChassisRedunPrimaryForceFailover.setDescription('Generated when the operator forces a failover from the primary, back to the secondary APEX.')
apexEventChassisRedunSecondaryForceFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8111), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventChassisRedunSecondaryForceFailover.setStatus('obsolete')
if mibBuilder.loadTexts: apexEventChassisRedunSecondaryForceFailover.setDescription('Generated when the operator forces a failover from the secondary, back to the primary APEX.')
apexEventChassisRedunFirmwareVersionMismatch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8112), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventChassisRedunFirmwareVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: apexEventChassisRedunFirmwareVersionMismatch.setDescription('Generated when the primary and secondary APEX firmware versions are mismatched.')
apexEventChassisRedunQAMVersionMismatch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 101, 8113), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexEventChassisRedunQAMVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: apexEventChassisRedunQAMVersionMismatch.setDescription('Generated when the primary and secondary APEX QAM versions are mismatched.')
apexEnableInvalidInitData = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8001), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableInvalidInitData.setStatus('current')
if mibBuilder.loadTexts: apexEnableInvalidInitData.setDescription("This setting enables or disables apexAlarmInvalidInitData.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeLossOfPhysicalInput = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8020), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeLossOfPhysicalInput.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeLossOfPhysicalInput.setDescription("This setting enables or disables apexAlarmGbeLossOfPhysicalInput.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeBufferFullness = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8021), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeBufferFullness.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeBufferFullness.setDescription("This setting enables or disables apexAlarmGbeBufferFullness.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeInputStreamLowBitRate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8022), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeInputStreamLowBitRate.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeInputStreamLowBitRate.setDescription("This setting enables or disables apexAlarmGbeInputStreamLowBitRate.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeInputStreamHighBitRate = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8023), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeInputStreamHighBitRate.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeInputStreamHighBitRate.setDescription("This setting enables or disables apexAlarmGbeInputStreamHighBitRate.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeMptsRedundPrimaryThreshold = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8024), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeMptsRedundPrimaryThreshold.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeMptsRedundPrimaryThreshold.setDescription("This setting enables or disables apexAlarmGbeMptsRedundPrimaryThreshold.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeMptsRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8025), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeMptsRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeMptsRedundFailOver.setDescription("This setting enables or disables apexAlarmGbeMptsRedundFailOver.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableServiceInError = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8026), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableServiceInError.setStatus('current')
if mibBuilder.loadTexts: apexEnableServiceInError.setDescription("This setting enables or disables apexAlarmServiceInError.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeLossOfInputTsFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8027), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeLossOfInputTsFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeLossOfInputTsFault.setDescription("This setting enables or disables apexAlarmGbeLossOfInputStream.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeInterfaceRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8029), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeInterfaceRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeInterfaceRedundFailOver.setDescription("This setting enables or disables apexAlarmGbeInterfaceRedundFailOver.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableLossOfInputAncillaryPid = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8030), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableLossOfInputAncillaryPid.setStatus('current')
if mibBuilder.loadTexts: apexEnableLossOfInputAncillaryPid.setDescription("It enables or disables the alarm 'apexAlarmLossOfInputAncillaryPid'.\n\n         When set to 'enabled', the alarm will operate as described in the \n         description for 'apexAlarmLossOfInputAncillaryPid' and sends event\n         'apexEventLossOfInputAncillaryPid'.\n         \n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n         \n         Also, when set to 'disabled', clear/minor apexEventLossOfInputAncillaryPid\n         events will not be sent.\n         \n         Default value is disabled.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableGbeInputStreamPacketDrop = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8031), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableGbeInputStreamPacketDrop.setStatus('current')
if mibBuilder.loadTexts: apexEnableGbeInputStreamPacketDrop.setDescription("This setting enables or disables apexAlarmGbeInputStreamPacketDrop.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableOutputUtilizationFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8040), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableOutputUtilizationFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableOutputUtilizationFault.setDescription("This setting enables or disables apexAlarmOutputUtilizationFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableOutputOverflow = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8041), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableOutputOverflow.setStatus('current')
if mibBuilder.loadTexts: apexEnableOutputOverflow.setDescription("This setting enables or disables apexAlarmOutputOverflow.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamModuleFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8042), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamModuleFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamModuleFault.setDescription("This setting enables or disables apexAlarmQamModuleFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamRfPortFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8043), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamRfPortFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamRfPortFault.setDescription("This setting enables or disables apexAlarmQamRfPortFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamChannelFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8044), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamChannelFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamChannelFault.setDescription("This setting enables or disables apexAlarmQamChannelFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamRfRedundFailOver = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8045), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamRfRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamRfRedundFailOver.setDescription("This setting enables or disables apexAlarmQamRfRedundFailOver.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamRfRedundMismatch = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8046), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamRfRedundMismatch.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamRfRedundMismatch.setDescription("This setting enables or disables apexAlarmQamRfRedundMismatch.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableQamModuleRemovalFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8047), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableQamModuleRemovalFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableQamModuleRemovalFault.setDescription("This setting enables or disables apexAlarmQamModuleRemovalFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableRtspControllerCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8050), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableRtspControllerCommFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableRtspControllerCommFault.setDescription("This setting enables or disables apexAlarmRtspControllerCommFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableRdsCommAlarmFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8060), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableRdsCommAlarmFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableRdsCommAlarmFault.setDescription("This setting enables or disables apexAlarmRdsCommFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableRemCommFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8070), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableRemCommFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableRemCommFault.setDescription("This setting enables or disables apexAlarmRemCommFault.\n\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableRemFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8071), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableRemFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableRemFault.setDescription("This setting enables or disables apexAlarmRemFault.\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableDepiControlConnectionFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8080), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableDepiControlConnectionFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableDepiControlConnectionFault.setDescription("This setting enables or disables apexAlarmDepiControlConnectionFault.\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableDepiSessionSetupFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8081), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableDepiSessionSetupFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableDepiSessionSetupFault.setDescription("This setting enables or disables apexAlarmDepiSessionSetupFault.\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableDtiSyncLossFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8082), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableDtiSyncLossFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableDtiSyncLossFault.setDescription("This setting enables or disables apexAlarmDtiSyncLossFault.\n         When set to 'enabled' the alarm will operate as described.\n\n         When set to 'disabled' the alarm will not be reported or wrapped\n         into unitAlarmStatus and the alarm condition will remain 'ok'.\n         If the alarm condition is not 'ok' when it is 'disabled', the\n         alarm will be cleared.\n\n         Once written, the change to this parameter will take immediate\n         effect.  However, in order for the change to persist through\n         subsequent reboots or power cycles, the change must be saved via\n         the apexSaveConfig parameter.\n\n         @Config(config=yes, reboot=no)\n         @Save(apexSaveConfig, value=2)\n         @File(config.ini, type='ini')\n        ")
apexEnableChassisRedundancyPrimaryFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8090), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableChassisRedundancyPrimaryFailover.setStatus('current')
if mibBuilder.loadTexts: apexEnableChassisRedundancyPrimaryFailover.setDescription("This setting enables or disables apexEnableChassisRedundancyPrimaryFailover.\n             When set to 'enabled' the alarm will operate as described.\n\n             When set to 'disabled' the alarm will not be reported or wrapped\n             into unitAlarmStatus and the alarm condition will remain 'ok'.\n             If the alarm condition is not 'ok' when it is 'disabled', the\n             alarm will be cleared.\n\n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexEnableChassisRedundancySecondaryFailover = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8091), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableChassisRedundancySecondaryFailover.setStatus('current')
if mibBuilder.loadTexts: apexEnableChassisRedundancySecondaryFailover.setDescription("This setting enables or disables apexEnableChassisRedundancySecondaryFailover.\n             When set to 'enabled' the alarm will operate as described.\n\n             When set to 'disabled' the alarm will not be reported or wrapped\n             into unitAlarmStatus and the alarm condition will remain 'ok'.\n             If the alarm condition is not 'ok' when it is 'disabled', the\n             alarm will be cleared.\n\n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexEnableChassisRedundancyAvailabilityFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8092), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableChassisRedundancyAvailabilityFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableChassisRedundancyAvailabilityFault.setDescription("This setting enables or disables apexEnableChassisRedundancyAvailabilityFault.\n             When set to 'enabled' the alarm will operate as described.\n\n             When set to 'disabled' the alarm will not be reported or wrapped\n             into unitAlarmStatus and the alarm condition will remain 'ok'.\n             If the alarm condition is not 'ok' when it is 'disabled', the\n             alarm will be cleared.\n\n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexEnableChassisRedundancyLinkFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8093), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableChassisRedundancyLinkFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableChassisRedundancyLinkFault.setDescription("This setting enables or disables apexEnableChassisRedundancyLinkFault.\n             When set to 'enabled' the alarm will operate as described.\n\n             When set to 'disabled' the alarm will not be reported or wrapped\n             into unitAlarmStatus and the alarm condition will remain 'ok'.\n             If the alarm condition is not 'ok' when it is 'disabled', the\n             alarm will be cleared.\n\n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexEnableChassisRedundancyConfigurationFault = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 1, 8094), EnableDisableTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexEnableChassisRedundancyConfigurationFault.setStatus('current')
if mibBuilder.loadTexts: apexEnableChassisRedundancyConfigurationFault.setDescription("This setting enables or disables apexEnableChassisRedundancyConfigurationFault.\n             When set to 'enabled' the alarm will operate as described.\n\n             When set to 'disabled' the alarm will not be reported or wrapped\n             into unitAlarmStatus and the alarm condition will remain 'ok'.\n             If the alarm condition is not 'ok' when it is 'disabled', the\n             alarm will be cleared.\n\n             Once written, the change to this parameter will take immediate\n             effect.  However, in order for the change to persist through\n             subsequent reboots or power cycles, the change must be saved via\n             the apexSaveConfig parameter.\n\n             @Config(config=yes, reboot=no)\n             @Save(apexSaveConfig, value=2)\n             @File(config.ini, type='ini')\n        ")
apexClearInvalidInitData = MibScalar((1, 3, 6, 1, 4, 1, 1166, 1, 31, 102, 2, 8001), ClearAlarmTYPE()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apexClearInvalidInitData.setStatus('current')
if mibBuilder.loadTexts: apexClearInvalidInitData.setDescription("Setting to 'clearAlarm' clears the apexAlarmInvalidInitData.\n\n         The APEX will set this parameter back to 'clearAlarmNotInProgress'\n         after clearing the alarm.\n\n         Once written, the change to this parameter will take immediate effect.\n\n         @Config(config=no, reboot=no)\n        ")
apexHwEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1), )
if mibBuilder.loadTexts: apexHwEventTable.setStatus('current')
if mibBuilder.loadTexts: apexHwEventTable.setDescription('Table of Hardware Events that have occurred.\n         Maximum of 100 events will be recorded.\n        ')
apexHwEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1), ).setIndexNames((0, "APEX-MIB", "apexHwEventIndex"))
if mibBuilder.loadTexts: apexHwEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexHwEventEntry.setDescription('Hardware Event Table Entry.')
apexHwEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexHwEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexHwEventIndex.setDescription('Index to HW Event table entry.')
apexHwEventTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHwEventTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexHwEventTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexHwEventAlarmCode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHwEventAlarmCode.setStatus('current')
if mibBuilder.loadTexts: apexHwEventAlarmCode.setDescription('Last number of alarm OID.  Can be one of the following:\n               0 Indicates event is informational and may or may not cause an alarm.\n            8000 apexAlarmHardwareFault\n            8002 apexAlarmTemperatureFault\n            8003 apexAlarmFanFault\n            8004 apexAlarmPowerFault\n            8042 apexAlarmQamModuleFault\n            8043 apexAlarmQamRfPortFault\n            8044 apexAlarmQamChannelFault\n            8045 apexAlarmQamRfRedundFailOver\n            8046 apexAlarmQamRfRedundMismatch\n            8070 apexAlarmRemCommFault\n            8071 apexAlarmRemFault\n\n         More details about the error can be found in apexHwEventDescription.\n        ')
apexHwEventAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHwEventAlarmSeverity.setStatus('current')
if mibBuilder.loadTexts: apexHwEventAlarmSeverity.setDescription('Alarm severity level of this event.\n        ')
apexHwEventData = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHwEventData.setStatus('current')
if mibBuilder.loadTexts: apexHwEventData.setDescription('Additional integer data.\n\n         When apexHwEventAlarmCode is non-zero, this will be the same as Additional\n         Data 1 as in the trap for the alarm.\n\n         When apexHwEventAlarmCode is zero, this may contain additional data\n         helpful in debug.\n        ')
apexHwEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexHwEventDescription.setStatus('current')
if mibBuilder.loadTexts: apexHwEventDescription.setDescription('Text description of the event.')
apexInvalidInitDataTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 2), )
if mibBuilder.loadTexts: apexInvalidInitDataTable.setStatus('current')
if mibBuilder.loadTexts: apexInvalidInitDataTable.setDescription('Table of Invalid Initialization Data Errors.\n         Maximum of 100 errors will be recorded.\n        ')
apexInvalidInitDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 2, 1), ).setIndexNames((0, "APEX-MIB", "apexInvalidInitDataIndex"))
if mibBuilder.loadTexts: apexInvalidInitDataEntry.setStatus('current')
if mibBuilder.loadTexts: apexInvalidInitDataEntry.setDescription('Invalid Initialization Data Table Entry.')
apexInvalidInitDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexInvalidInitDataIndex.setStatus('current')
if mibBuilder.loadTexts: apexInvalidInitDataIndex.setDescription('Index to Invalid Initialization Data table entry.')
apexInvalidInitDataTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInvalidInitDataTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexInvalidInitDataTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexInvalidInitDataDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexInvalidInitDataDescription.setStatus('current')
if mibBuilder.loadTexts: apexInvalidInitDataDescription.setDescription('Text string describing the data error.')
apexOutputTsEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3), )
if mibBuilder.loadTexts: apexOutputTsEventTable.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventTable.setDescription('Table of Output Stream events that have occurred.\n\n         Maximum of 200 events will be recorded.\n        ')
apexOutputTsEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1), ).setIndexNames((0, "APEX-MIB", "apexOutputTsEventIndex"))
if mibBuilder.loadTexts: apexOutputTsEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventEntry.setDescription('Output Stream Error Table Entry.')
apexOutputTsEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexOutputTsEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventIndex.setDescription('Index to Output Stream Error table.\n        ')
apexOutputTsEventTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexOutputTsEventAlarmCode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventAlarmCode.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventAlarmCode.setDescription('Last number of alarm OID.  Can be one of the following:\n               0 Indicates event is informational and may or may not cause an alarm.\n            8040 apexAlarmOutputUtilizationFault\n            8041 apexAlarmOutputOverflow\n\n         More details about the error can be found in apexOutputTsEventDescription.\n        ')
apexOutputTsEventAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventAlarmSeverity.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventAlarmSeverity.setDescription('Alarm severity level of this event.\n        ')
apexOutputTsEventOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventOutputTsNum.setDescription('The number of the output transport stream for this event.\n        ')
apexOutputTsEventCurRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventCurRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventCurRate.setDescription('Value of apexOutputTsUtilizCurRate when event occurred.\n        ')
apexOutputTsEventAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventAvgRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventAvgRate.setDescription('Value of apexOutputTsUtilizAvgRate when event occurred.\n        ')
apexOutputTsEventMinRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventMinRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventMinRate.setDescription('Value of apexOutputTsUtilizMinRate when event occurred.\n        ')
apexOutputTsEventPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventPeakRate.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventPeakRate.setDescription('Value of apexOutputTsUtilizPeakRate when event occurred.\n        ')
apexOutputTsEventCurDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventCurDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventCurDropPackets.setDescription('Value of apexOutputTsUtilizCurDropPackets when event occurred.\n        ')
apexOutputTsEventPeakDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventPeakDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventPeakDropPackets.setDescription('Value of apexOutputTsUtilizPeakDropPackets when event occurred.\n        ')
apexOutputTsEventRollingDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventRollingDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventRollingDropPackets.setDescription('Value of apexOutputTsUtilizRollingDropPackets when event occurred.\n        ')
apexOutputTsEventTotalDropPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventTotalDropPackets.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventTotalDropPackets.setDescription('Value of apexOutputTsUtilizTotalDropPackets when event occurred.\n        ')
apexOutputTsEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 3, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexOutputTsEventDescription.setStatus('current')
if mibBuilder.loadTexts: apexOutputTsEventDescription.setDescription('Text description of the event.\n         Maximum length is 128 characters.\n        ')
apexGbeInputTsEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4), )
if mibBuilder.loadTexts: apexGbeInputTsEventTable.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventTable.setDescription('Table of Gigabit Ethernet Input Transport Stream Events that have occurred.\n         Maximum of 100 events will be recorded.\n        ')
apexGbeInputTsEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1), ).setIndexNames((0, "APEX-MIB", "apexGbeInputTsEventIndex"))
if mibBuilder.loadTexts: apexGbeInputTsEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventEntry.setDescription('Gigabit Ethernet Input Transport Stream Event Table Entry.')
apexGbeInputTsEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexGbeInputTsEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventIndex.setDescription('Index to Gigabit Ethernet Input Transport Stream Event table.\n        ')
apexGbeInputTsEventTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexGbeInputTsEventAlarmCode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventAlarmCode.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventAlarmCode.setDescription('Last number of alarm OID.  Can be one of the following:\n               0 Indicates event is informational and may or may not cause an alarm.\n            8022 apexAlarmGbeInputStreamLowBitRate\n            8023 apexAlarmGbeInputStreamHighBitRate\n            8024 apexAlarmGbeMptsRedundPrimaryThreshold\n            8025 apexAlarmGbeMptsRedundFailOver\n\n         More details about the error may be found in apexGbeInputTsEventDescription.\n        ')
apexGbeInputTsEventAlarmSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ok", 1), ("indeterminate", 2), ("warning", 3), ("minor", 4), ("major", 5), ("critical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventAlarmSeverity.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventAlarmSeverity.setDescription('Alarm severity level of this event.\n        ')
apexGbeInputTsEventRedundantConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("primary", 1), ("secondary", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventRedundantConfig.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventRedundantConfig.setDescription('Indicates whether this input transport stream was\n         configured as a primary or secondary at the time of the event.\n        ')
apexGbeInputTsEventGbeInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventGbeInterface.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventGbeInterface.setDescription('Value of apexInputTsStatPriInputInterface or apexInputTsStatSecInputInterface\n         at the time of the event.\n        ')
apexGbeInputTsEventUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventUdpPort.setDescription('Value of apexInputTsStatPriInputUdp or apexInputTsStatSecInputUdp\n         at the time of the event.\n        ')
apexGbeInputTsEventMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventMulticastIp.setDescription('Value of apexInputTsStatPriInputMulticastIp or apexInputTsStatSecInputMulticastIp\n         at the time of the event.\n        ')
apexGbeInputTsEventSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventSourceIp.setDescription('Value of apexInputTsStatPriInputSourceIp or apexInputTsStatSecInputSourceIp\n         at the time of the event.\n        ')
apexGbeInputTsEventInputTsState = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 10), InputTsStateTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventInputTsState.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventInputTsState.setDescription('Value of apexInputTsStatPriState or apexInputTsStatSecState\n         at the time of the event. For threshold or fail over events, the\n         state reported is always the Primary input stream state.\n        ')
apexGbeInputTsEventRateCompareType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 11), RateComparisonTYPE()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventRateCompareType.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventRateCompareType.setDescription('Comparison type at time of event (stream or data).\n        ')
apexGbeInputTsEventSamplingPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventSamplingPeriod.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventSamplingPeriod.setDescription('Sample period in seconds of the stream and data counts reported.\n         Using the sample period and the stream or data counts, the actual\n         input rate at the time of the event can be computed.\n        ')
apexGbeInputTsEventPriCurStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventPriCurStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventPriCurStreamCount.setDescription('Current Primary input stream Packet Count at the time of the event.\n         This is the number of packets received, including Nulls, during the\n         sample period defined in apexGbeInputTsEventSamplingPeriod.\n        ')
apexGbeInputTsEventPriCurDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventPriCurDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventPriCurDataCount.setDescription('Current Primary input data Packet Count at the time of the event.\n         This is the number of data packets received (non-Nulls), during the\n         sample period defined in apexGbeInputTsEventSamplingPeriod.\n        ')
apexGbeInputTsEventSecCurStreamCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventSecCurStreamCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventSecCurStreamCount.setDescription('Current Secondary input stream Packet Count at the time of the event.\n         This is the number of packets received, including Nulls, during the\n         sample period defined in apexGbeInputTsEventSamplingPeriod.\n        ')
apexGbeInputTsEventSecCurDataCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventSecCurDataCount.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventSecCurDataCount.setDescription('Current Secondary input data Packet Count at the time of the event.\n         This is the number of data packets received (non-Nulls), during the\n         sample period defined in apexGbeInputTsEventSamplingPeriod.\n        ')
apexGbeInputTsEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 4, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexGbeInputTsEventDescription.setStatus('current')
if mibBuilder.loadTexts: apexGbeInputTsEventDescription.setDescription('Text description of the event.\n         Maximum length is 128 characters.\n        ')
apexRtspEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5), )
if mibBuilder.loadTexts: apexRtspEventTable.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventTable.setDescription('Table of RTSP Events that have occurred.\n         Maximum of 100 events will be recorded.\n        ')
apexRtspEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1), ).setIndexNames((0, "APEX-MIB", "apexRtspEventIndex"))
if mibBuilder.loadTexts: apexRtspEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventEntry.setDescription('RTSP Event Table Entry.')
apexRtspEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexRtspEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventIndex.setDescription('Index to RTSP Event table entry.')
apexRtspEventTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspEventTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexRtspEventControllerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspEventControllerIp.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventControllerIp.setDescription('IP address of the RTSP Controller associated with this event.  Value\n         will be zero if the event is not associated with a specific controller.\n         Refer to apexRtspEventSourceDescription for the source of the event.\n        ')
apexRtspEventSessionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspEventSessionCount.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventSessionCount.setDescription('Number of active sessions for the RTSP Controller associated with this\n         event.  Value will be total count of all sessions for all controllers\n         if the event is not associated with a specific controller.  Refer\n         to apexRtspEventSourceDescription for the source of the event.\n        ')
apexRtspEventSourceDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspEventSourceDescription.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventSourceDescription.setDescription('Text description of the source of the event.  May indicate a controller\n         identifier or an APEX application process.\n        ')
apexRtspEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 5, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexRtspEventDescription.setStatus('current')
if mibBuilder.loadTexts: apexRtspEventDescription.setDescription('Text description of the event.')
apexMappingErrorTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6), )
if mibBuilder.loadTexts: apexMappingErrorTable.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorTable.setDescription('Table of program, ancillary PID, and stream pass through mapping errors\n         that have occurred. Maximum of 100 error events will be recorded.\n        ')
apexMappingErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1), ).setIndexNames((0, "APEX-MIB", "apexMappingErrorIndex"))
if mibBuilder.loadTexts: apexMappingErrorEntry.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorEntry.setDescription('Program, PID, Stream Pass Through Error Table Entry.')
apexMappingErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexMappingErrorIndex.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorIndex.setDescription('Index to Program, PID, Stream Pass Through,\n         DEPI Control, DEPI Session Error table.\n        ')
apexMappingErrorTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this error was logged.\n        ')
apexMappingErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorCode.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorCode.setDescription('Error code for this mapping error. 0 indicates no error.\n        ')
apexMappingErrorMappingType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("notApplicable", 0), ("program", 1), ("ancillaryPid", 2), ("streamPassthru", 3), ("depiControl", 4), ("depiSession", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorMappingType.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorMappingType.setDescription('Type of mapping (program, ancillary PID, or stream pass through).\n        ')
apexMappingErrorInputType = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("gbe", 1), ("fastEnet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorInputType.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorInputType.setDescription('Input Type. Indicates if mapping is from Gigabit Ethernet or Fast Ethernet.\n        ')
apexMappingErrorInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorInputInterface.setDescription('Interface port number of the primary input interface.\n        ')
apexMappingErrorUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorUdpPort.setDescription('Input UDP Port for primary input.\n        ')
apexMappingErrorMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorMulticastIp.setDescription('The Multicast receive IP address for primary input.\n        ')
apexMappingErrorSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorSourceIp.setDescription('This is the IGMP v3 Source IP address of the source device for the primary input.\n        ')
apexMappingErrorInputProgramPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorInputProgramPid.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorInputProgramPid.setDescription('For program mappings, this is the input program number of the program being mapped.\n         For ancillary PID mappings, this is the input PID number being mapped.\n         For stream pass through mappings, this field is not used and is set to 0.\n        ')
apexMappingErrorOutputProgramPid = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorOutputProgramPid.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorOutputProgramPid.setDescription('For program mappings, this is the output program number of the program being mapped.\n         For ancillary PID mappings, this is the output PID number being mapped.\n         For stream pass through mappings, this field is not used and is set to 0.\n        ')
apexMappingErrorOutputOpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notInUse", 0), ("sessionControl", 1), ("manualRouting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorOutputOpMode.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorOutputOpMode.setDescription('Operating mode of the output transport stream for this mapping.\n        ')
apexMappingErrorOutputTsNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorOutputTsNum.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorOutputTsNum.setDescription('The number of the output transport stream for this mapping error.\n        ')
apexMappingErrorSecInputInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorSecInputInterface.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorSecInputInterface.setDescription('Interface port number of the secondary input interface.\n         An interface number of 0 indicates no secondary input.\n        ')
apexMappingErrorSecUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorSecUdpPort.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorSecUdpPort.setDescription('Input UDP Port for secondary input.\n        ')
apexMappingErrorSecMulticastIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorSecMulticastIp.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorSecMulticastIp.setDescription('The Multicast receive IP address for secondary input.\n        ')
apexMappingErrorSecSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 6, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexMappingErrorSecSourceIp.setStatus('current')
if mibBuilder.loadTexts: apexMappingErrorSecSourceIp.setDescription('This is the IGMP v3 Source IP address of the source device for the secondary input.\n        ')
apexChassisRedundancyEventTable = MibTable((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 7), )
if mibBuilder.loadTexts: apexChassisRedundancyEventTable.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyEventTable.setDescription('Table of Chassis Redundancy Events.\n         Maximum of 300 events will be recorded.\n        ')
apexChassisRedundancyEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 7, 1), ).setIndexNames((0, "APEX-MIB", "apexChassisRedundancyEventIndex"))
if mibBuilder.loadTexts: apexChassisRedundancyEventEntry.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyEventEntry.setDescription('Chassis Redundancy Event Table Entry.')
apexChassisRedundancyEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: apexChassisRedundancyEventIndex.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyEventIndex.setDescription('Index for Chassis Redundancy Event table.')
apexChassisRedundancyEventTimeLogged = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyEventTimeLogged.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyEventTimeLogged.setDescription('Time in GPS seconds (apexSystemTime) that this event was logged.\n        ')
apexChassisRedundancyEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 1166, 1, 31, 200, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: apexChassisRedundancyEventDescription.setStatus('current')
if mibBuilder.loadTexts: apexChassisRedundancyEventDescription.setDescription('Text string describing the event.')
trapConfigurationChangeInteger = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 3)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"))
if mibBuilder.loadTexts: trapConfigurationChangeInteger.setStatus('current')
if mibBuilder.loadTexts: trapConfigurationChangeInteger.setDescription("This trap is issued if configuration of a single variable\n         with integer type was changed (via ANY interface).\n         TrapChangedValueInteger variable may contain current reading\n         of that variable.\n         trapPerceivedSeverity - 'indeterminate'")
trapConfigurationChangeDisplayString = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 4)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueDisplayString"))
if mibBuilder.loadTexts: trapConfigurationChangeDisplayString.setStatus('current')
if mibBuilder.loadTexts: trapConfigurationChangeDisplayString.setDescription("This trap is issued if configuration of a single variable\n         with DisplayString type was changed (via ANY interface).\n         TrapChangedValueDisplayString variable may contain current\n         reading of that variable.\n         trapPerceivedSeverity - 'indeterminate'")
trapConfigurationChangeOID = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 5)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueOID"))
if mibBuilder.loadTexts: trapConfigurationChangeOID.setStatus('current')
if mibBuilder.loadTexts: trapConfigurationChangeOID.setDescription("This trap is issued if configuration of a single variable\n         with OID type was changed (via ANY interface).\n         TrapChangedValueOID variable may contain current reading\n         of that variable.\n         trapPerceivedSeverity - 'indeterminate'")
trapConfigurationChangeIpAddress = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 6)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueIpAddress"))
if mibBuilder.loadTexts: trapConfigurationChangeIpAddress.setStatus('current')
if mibBuilder.loadTexts: trapConfigurationChangeIpAddress.setDescription("This trap is issued if configuration of a single variable\n         with IpAddress type was changed (via ANY interface).\n         TrapChangedValueIpAddress variable may contain current reading\n         of that variable.\n         trapPerceivedSeverity - 'indeterminate'")
trapConditionNotInList = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 20)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapConditionNotInList.setStatus('current')
if mibBuilder.loadTexts: trapConditionNotInList.setDescription('This trap is issued if a condition is being cleared and\n         it is not in the condition list.\n         trapAdditionalInfoInteger1 : Task and Function ID (task\n                          and function generates the\n                          error condition)\n         trapAdditionalInfoInteger2 : Condition number\n         trapAdditionalInfoInteger3 : Condition severity')
trapConditionAlreadyInList = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 21)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapConditionAlreadyInList.setStatus('current')
if mibBuilder.loadTexts: trapConditionAlreadyInList.setDescription('This trap is issued if a condition is being set and\n         it is already in the condition list.\n         trapAdditionalInfoInteger1 : Task and Function ID (task\n                          and function generates the\n                          error condition)\n         trapAdditionalInfoInteger2 : Condition number\n         trapAdditionalInfoInteger3 : Condition severity')
trapConditionListFull = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 22)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapConditionListFull.setStatus('current')
if mibBuilder.loadTexts: trapConditionListFull.setDescription('This trap is issued if a condition is being set and\n         the condition list is full.\n         trapAdditionalInfoInteger1 : Task and Function ID (task\n                          and function generates the\n                          error condition)\n         trapAdditionalInfoInteger2 : Condition number\n         trapAdditionalInfoInteger3 : Condition severity')
trapInvalidCaseInSwitch = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 23)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapInvalidCaseInSwitch.setStatus('current')
if mibBuilder.loadTexts: trapInvalidCaseInSwitch.setDescription('This trap is issued when in a switch statement the\n         default case is reached.  The trapAdditionalInfoInteger1\n         will contain the task and Function ID.  The\n         trapAdditionalInfoInteger2 will contain value of the switch.\n         The trapAdditionalInfoInteger3 is not used.')
trapCannotCreateSemaphore = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 24)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapCannotCreateSemaphore.setStatus('current')
if mibBuilder.loadTexts: trapCannotCreateSemaphore.setDescription('This trap is issued when a semaphore cannot\n         be created. The trapAdditionalInfoInteger1 will contain the\n         task and Function ID, the trapAdditionalInfoInteger2 and\n         trapAdditionalInfoInteger3 will not be used.')
trapCannotOpenSocket = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 25)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapCannotOpenSocket.setStatus('current')
if mibBuilder.loadTexts: trapCannotOpenSocket.setDescription('This trap is issued when a socket cannot\n         be opened. The trapAdditionalInfoInteger1 will contain the\n         task and Function ID. The trapAdditionalInfoInteger2 will\n         contain the errno returned by the call to socket(). The\n         trapAdditionalInfoInteger3 is not used.')
trapUnknownMessageReceived = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 26)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapUnknownMessageReceived.setStatus('current')
if mibBuilder.loadTexts: trapUnknownMessageReceived.setDescription('This trap is issued when an unknown message\n         is received.  The trapAdditionalInfoInteger1 will contain the\n         task and Function ID. The trapAdditionalInfoInteger2 will\n         contain the message ID and the trapAdditionalInfoInteger3 is\n         not used.')
trapInvalidMessageReceived = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 27)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapInvalidMessageReceived.setStatus('current')
if mibBuilder.loadTexts: trapInvalidMessageReceived.setDescription('This trap is issued when an invalid message\n         is received.  The trapAdditionalInfoInteger1 will contain the\n         task and Function ID. The trapAdditionalInfoInteger2 will\n         contain the message ID and the trapAdditionalInfoInteger3 is\n         not used.')
trapHardwareFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8000)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapHardwareFault.setStatus('current')
if mibBuilder.loadTexts: trapHardwareFault.setDescription('See corresponding alarm apexAlarmHardwareFault.\n\n         Additional Info 1 carries HW Error Code (refer to HW Event Log for details).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapInvalidInitData = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8001)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapInvalidInitData.setStatus('current')
if mibBuilder.loadTexts: trapInvalidInitData.setDescription('See corresponding alarm apexAlarmInvalidInitData.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapTemperatureFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8002)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapTemperatureFault.setStatus('current')
if mibBuilder.loadTexts: trapTemperatureFault.setDescription('See corresponding alarm apexAlarmTemperatureFault.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapFanFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8003)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapFanFault.setStatus('current')
if mibBuilder.loadTexts: trapFanFault.setDescription('See corresponding alarm apexAlarmFanFault.\n\n         This trap is sent on summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapPowerFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8004)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapPowerFault.setStatus('current')
if mibBuilder.loadTexts: trapPowerFault.setDescription('See corresponding alarm apexAlarmPowerFault.\n\n         Additional Info 1 carries the apexPsStatusTable index (1 to 2).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeLossOfPhysicalInput = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8020)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeLossOfPhysicalInput.setStatus('current')
if mibBuilder.loadTexts: trapGbeLossOfPhysicalInput.setDescription('See corresponding alarm apexAlarmGbeLossOfPhysicalInput.\n\n         Additional Info 1 carries the Gigabit Ethernet Interface Number (1 to 4).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeBufferFullness = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8021)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeBufferFullness.setStatus('current')
if mibBuilder.loadTexts: trapGbeBufferFullness.setDescription('See corresponding alarm apexAlarmGbeBufferFullness.\n\n         Additional Info 1 carries the Gigabit Ethernet Processor Number (1 to 2).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeInputStreamLowBitRate = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8022)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeInputStreamLowBitRate.setStatus('current')
if mibBuilder.loadTexts: trapGbeInputStreamLowBitRate.setDescription('See corresponding alarm apexAlarmGbeInputStreamLowBitRate.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeInputStreamHighBitRate = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8023)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeInputStreamHighBitRate.setStatus('current')
if mibBuilder.loadTexts: trapGbeInputStreamHighBitRate.setDescription('See corresponding alarm apexAlarmGbeInputStreamHighBitRate.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeMptsRedundPrimaryThreshold = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8024)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeMptsRedundPrimaryThreshold.setStatus('current')
if mibBuilder.loadTexts: trapGbeMptsRedundPrimaryThreshold.setDescription('See corresponding alarm apexAlarmGbeMptsRedundPrimaryThreshold.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeMptsRedundFailOver = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8025)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeMptsRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: trapGbeMptsRedundFailOver.setDescription('See corresponding alarm apexAlarmGbeMptsRedundFailOver.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapServiceInError = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8026)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapServiceInError.setStatus('current')
if mibBuilder.loadTexts: trapServiceInError.setDescription('See corresponding alarm apexAlarmServiceInError.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeLossOfInputStream = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8027)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeLossOfInputStream.setStatus('current')
if mibBuilder.loadTexts: trapGbeLossOfInputStream.setDescription('See corresponding alarm apexAlarmGbeLossOfInputStream.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGigeToHostCommFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8028)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGigeToHostCommFault.setStatus('current')
if mibBuilder.loadTexts: trapGigeToHostCommFault.setDescription('See corresponding alarm apexAlarmGigeToHostCommFault.\n\n         This trap is sent on a summary basis.\n\n         Additional Info 1 is not used.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapGbeInterfaceRedundFailOver = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8029)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeInterfaceRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: trapGbeInterfaceRedundFailOver.setDescription('See corresponding alarm apexAlarmGbeInterfaceRedundFailOver.\n\n         This trap is sent on a GbE Redundant Pair basis.\n\n         Additional Info 1 contains the GbE interface number that lost link.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapLossOfInputAncillaryPid = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8030)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapLossOfInputAncillaryPid.setStatus('current')
if mibBuilder.loadTexts: trapLossOfInputAncillaryPid.setDescription("This trap is sent if 'apexAlarmLossOfInputAncillaryPid' is \n         enabled by 'apexEnableLossOfInputAncillaryPid' and if any of\n         the input ancillary PID is not received for the duration\n         'apexPidMapInputAncillaryPidDetectionTimeout'.\n         \n         Severity level of the alarm is minor.\n        ")
trapGbeInputStreamPacketDrop = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8031)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapGbeInputStreamPacketDrop.setStatus('current')
if mibBuilder.loadTexts: trapGbeInputStreamPacketDrop.setDescription("This trap is sent if 'apexAlarmGbeInputStreamPacketDrop' is \n         enabled by 'apexEnableGbeInputStreamPacketDrop' and if any of\n         the input data streams drops a packet.\n        ")
trapOutputUtilizationFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8040)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapOutputUtilizationFault.setStatus('current')
if mibBuilder.loadTexts: trapOutputUtilizationFault.setDescription('See corresponding alarm apexAlarmOutputUtilizationFault.\n\n         This trap is sent on an Output Transport Stream basis.\n\n         Additional Info 1 carries the Output Transport Stream number (1 to 48).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapOutputOverflow = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8041)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapOutputOverflow.setStatus('current')
if mibBuilder.loadTexts: trapOutputOverflow.setDescription('See corresponding alarm apexAlarmOutputOverflow.\n\n         This trap is sent on an Output Transport Stream basis.\n\n         Additional Info 1 carries the Output Transport Stream number (1 to 48).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapQamModuleFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8042)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamModuleFault.setStatus('current')
if mibBuilder.loadTexts: trapQamModuleFault.setDescription('See corresponding alarm apexAlarmQamModuleFault.\n\n         This trap is sent on a QAM Module basis.\n\n         Additional Info 1 carries the QAM Module number (1 to 3).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapQamRfPortFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8043)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamRfPortFault.setStatus('current')
if mibBuilder.loadTexts: trapQamRfPortFault.setDescription('See corresponding alarm apexAlarmQamRfPortFault.\n\n         This trap is sent on a QAM RF Port basis.\n\n         Additional Info 1 carries the QAM RF Port number:\n            RF Port 1 = QAM Module 1, RF 1\n            RF Port 2 = QAM Module 1, RF 2\n            RF Port 3 = QAM Module 2, RF 1\n            RF Port 4 = QAM Module 2, RF 2\n            RF Port 5 = QAM Module 3, RF 1\n            RF Port 6 = QAM Module 3, RF 2\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapQamChannelFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8044)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamChannelFault.setStatus('current')
if mibBuilder.loadTexts: trapQamChannelFault.setDescription('See corresponding alarm apexAlarmQamChannelFault.\n\n         This trap is sent on a QAM Channel basis.\n\n         Additional Info 1 carries the QAM Channel number.\n             1 to  8 = QAM Module 1, RF 1, QAM Channel A to H\n             9 to 16 = QAM Module 1, RF 2, QAM Channel A to H\n            17 to 24 = QAM Module 2, RF 1, QAM Channel A to H\n            25 to 32 = QAM Module 2, RF 2, QAM Channel A to H\n            33 to 40 = QAM Module 3, RF 1, QAM Channel A to H\n            41 to 48 = QAM Module 3, RF 2, QAM Channel A to H\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapQamRfRedundFailOver = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8045)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamRfRedundFailOver.setStatus('current')
if mibBuilder.loadTexts: trapQamRfRedundFailOver.setDescription('See corresponding alarm apexAlarmQamRfRedundFailOver.\n\n         This trap is sent on a Primary QAM RF Port basis.\n         Additional Info 1 carries the Primary QAM RF Port number.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapQamRfRedundMismatch = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8046)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamRfRedundMismatch.setStatus('current')
if mibBuilder.loadTexts: trapQamRfRedundMismatch.setDescription('See corresponding alarm apexAlarmQamRfRedundMismatch.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapQamModuleRemovalFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8047)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamModuleRemovalFault.setStatus('current')
if mibBuilder.loadTexts: trapQamModuleRemovalFault.setDescription('See corresponding alarm apexAlarmQamModuleRemovalFault.\n\n         This trap is sent on a QAM Module Removal basis.\n\n         Additional Info 1 carries the QAM Module number (1 to 3).\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapRtspControllerCommFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8050)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapRtspControllerCommFault.setStatus('current')
if mibBuilder.loadTexts: trapRtspControllerCommFault.setDescription('See corresponding alarm apexAlarmRtspControllerCommFault.\n\n         This trap is sent on a controller basis.\n\n         Additional Info 1 carries the controller number.\n         Additional Info 2 is not used.\n         Additional Info 3 is not used.\n        ')
trapRdsCommFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8060)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapRdsCommFault.setStatus('current')
if mibBuilder.loadTexts: trapRdsCommFault.setDescription('See corresponding alarm apexAlarmRdsCommFault.\n\n         Additional Info is not used.\n        ')
trapRemCommFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8070)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapRemCommFault.setStatus('current')
if mibBuilder.loadTexts: trapRemCommFault.setDescription('See corresponding alarm apexAlarmRemCommFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapRemFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8071)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapRemFault.setStatus('current')
if mibBuilder.loadTexts: trapRemFault.setDescription('See corresponding alarm apexAlarmRemFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapDepiControlConnectionFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8080)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapDepiControlConnectionFault.setStatus('current')
if mibBuilder.loadTexts: trapDepiControlConnectionFault.setDescription('See corresponding alarm apexAlarmDepiControlConnectionFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapDepiSessionSetupFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8081)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapDepiSessionSetupFault.setStatus('current')
if mibBuilder.loadTexts: trapDepiSessionSetupFault.setDescription('See corresponding alarm apexAlarmDepiSessionSetupFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapDtiSyncLossFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8082)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapDtiSyncLossFault.setStatus('current')
if mibBuilder.loadTexts: trapDtiSyncLossFault.setDescription('See corresponding alarm apexAlarmDtiSyncLossFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapChassisRedundancyPrimaryFailover = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8090)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyPrimaryFailover.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyPrimaryFailover.setDescription('See corresponding alarm apexAlarmChassisRedundancyPrimaryFailover.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapChassisRedundancySecondaryFailover = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8091)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancySecondaryFailover.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancySecondaryFailover.setDescription('See corresponding alarm apexAlarmChassisRedundancySecondaryFailover.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapChassisRedundancyAvailabilityFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8092)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyAvailabilityFault.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyAvailabilityFault.setDescription('See corresponding alarm apexAlarmChassisRedundancyAvailabilityFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapChassisRedundancyLinkFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8093)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyLinkFault.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyLinkFault.setDescription('See corresponding alarm apexAlarmChassisRedundancyLinkFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapChassisRedundancyConfigurationFault = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8094)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyConfigurationFault.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyConfigurationFault.setDescription('See corresponding alarm apexAlarmChassisRedundancyConfigurationFault.\n\n         This trap is sent on a summary basis.\n         Additional Info is not used.\n        ')
trapEmUserLoginFailed = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8100)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapEmUserLoginFailed.setStatus('current')
if mibBuilder.loadTexts: trapEmUserLoginFailed.setDescription('See corresponding event apexEventEmUserLoginFailed.\n\n         Additional Info is not used.')
trapQamModuleUpgraded = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8101)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapQamModuleUpgraded.setStatus('current')
if mibBuilder.loadTexts: trapQamModuleUpgraded.setDescription('See corresponding event apexEventQamModuleUpgraded.\n\n         Additional Info is not used.')
trapSnmpCommunityStringChanged = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8102)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapSnmpCommunityStringChanged.setStatus('current')
if mibBuilder.loadTexts: trapSnmpCommunityStringChanged.setDescription("This trap event is sent when read/read-write SNMP community strings are changed.\n         See corresponding event 'apexEventSnmpCommunityStringChanged'.\n         \n         Severity level of the event is warning.\n         \n         The type of community strings which are changed is sent in the\n         'Additional Info' parameters as explained below.\n         trapAdditionalInfoInteger1 - 1 - read community string is changed\n                                      0 - read community string is not changed\n         trapAdditionalInfoInteger2 - 1 - read write community string is changed\n                                      0 - read write community string is not changed\n         trapAdditionalInfoInteger3 - Not used\n        ")
trapEasMessageNotReceived = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8103)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapEasMessageNotReceived.setStatus('current')
if mibBuilder.loadTexts: trapEasMessageNotReceived.setDescription("This event is raised, if 'apexEasMessageReceiveTimeoutEventEnable'\n         is enabled, when there is no EAS message received from any\n         of the EAS sever configured in 'apexEasServerTable' in the duration\n         'apexEasMessageReceiveTimeoutDuration'.\n         \n         Severity level of this event is warning.\n         \n         Input interface, input UDP port, multicast IP and source IP details are\n         passed with the below optional parameters.\n        \n         trapAdditionalInfoInteger1 -\n                    bits 0 to 15  : Input UDP port number\n                    bit 16       : Type of interface                          \n                          value 0 : GIGE\n                          value 1 : Fast Enet\n                    bits 17 to 18 : Interface Number and it is zero based\n                         Ex: If this value is 3 and the type of interface is \n                             GIGE then it represents GIGE4 interface\n                    bits 21 to 31 : Reserved\n         trapAdditionalInfoInteger2 - contains EAS multicast IP address\n         trapAdditionalInfoInteger3 - contains EAS source IP address\n         \n         Note: As trapAdditionalInfoInteger2, trapAdditionalInfoInteger3 \n         contains IP addresses in the 'IpAddress' type format.\n         \n         See corresponding event apexEventEasMessageNotReceived.\n        ")
trapLossOfInputAncillaryPidEvent = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8104)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapLossOfInputAncillaryPidEvent.setStatus('current')
if mibBuilder.loadTexts: trapLossOfInputAncillaryPidEvent.setDescription("This trap is sent if apexEnableLossOfInputAncillaryPid enabled and\n         if any of the input ancillary PID is not received for the duration\n         'apexPidMapInputAncillaryPidDetectionTimeout'. Refer\n         'apexEventLossOfInputAncillaryPid' for more details.\n         \n         Severity level of the event is minor.\n         \n         The trap with clear severity is sent, when the event is cleared.\n         \n         Input interface type, Input interface type\n         input UDP port, multicast IP and source IP details are\n         passed with the below optional parameters.\n        \n         trapAdditionalInfoInteger1 - bits  0 to 12 - Input ancillary PID\n                                      bit  13       - Input interface type\n                                                      0 - GIGE\n                                                      1 - Fast Enet\n                                      bits 14 to 15 - Input interface number\n                                                      Zero based index runs from \n                                                      0 to 3.\n                                      bits 16 to 31 - Input UDP port number\n         trapAdditionalInfoInteger2 - Input multicast IP address\n         trapAdditionalInfoInteger3 - Input source IP address\n         \n         Note: As trapAdditionalInfoInteger2, trapAdditionalInfoInteger3 \n         contains IP addresses which is in the 'IpAddress' type format,this\n         should be decoded as the same way as the type 'IpAddress'.\n        ")
trapChassisRedundancyPrimaryForceFailover = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8110)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyPrimaryForceFailover.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyPrimaryForceFailover.setDescription('See corresponding event apexEventChassisRedunPrimaryForceFailover.\n\n         Additional Info is not used.')
trapChassisRedundancySecondaryForceFailover = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8111)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancySecondaryForceFailover.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancySecondaryForceFailover.setDescription('See corresponding event apexEventChassisRedunSecondaryForceFailover.\n\n         Additional Info is not used.')
trapChassisRedundancyFirmwareVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8112)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyFirmwareVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyFirmwareVersionMismatch.setDescription('See corresponding event apexEventChassisRedunFirmwareVersionMismatch.\n\n         Additional Info is not used.')
trapChassisRedundancyQAMVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 1166, 1, 31, 0, 8113)).setObjects(("BCS-TRAPS-MIB", "trapIdentifier"), ("BCS-TRAPS-MIB", "trapSequenceId"), ("BCS-TRAPS-MIB", "trapNetworkElemModelNumber"), ("BCS-TRAPS-MIB", "trapNetworkElemSerialNum"), ("BCS-TRAPS-MIB", "trapPerceivedSeverity"), ("BCS-TRAPS-MIB", "trapNetworkElemOperState"), ("BCS-TRAPS-MIB", "trapNetworkElemAlarmStatus"), ("BCS-TRAPS-MIB", "trapNetworkElemAdminState"), ("BCS-TRAPS-MIB", "trapNetworkElemAvailStatus"), ("BCS-TRAPS-MIB", "trapText"), ("BCS-TRAPS-MIB", "trapNETrapLastTrapTimeStamp"), ("BCS-TRAPS-MIB", "trapChangedObjectId"), ("BCS-TRAPS-MIB", "trapChangedValueInteger"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger1"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger2"), ("BCS-TRAPS-MIB", "trapAdditionalInfoInteger3"))
if mibBuilder.loadTexts: trapChassisRedundancyQAMVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: trapChassisRedundancyQAMVersionMismatch.setDescription('See corresponding event apexEventChassisRedunQAMVersionMismatch.\n\n         Additional Info is not used.')
mibBuilder.exportSymbols("APEX-MIB", apexOamp=apexOamp, apexQamQrmRevStatAppFw=apexQamQrmRevStatAppFw, apexMappingErrorIndex=apexMappingErrorIndex, apexRdsEmmStatusTable=apexRdsEmmStatusTable, apexRdsEmmStatusServerError=apexRdsEmmStatusServerError, apexRtspEventDescription=apexRtspEventDescription, apexRtspSessionIdEntry=apexRtspSessionIdEntry, apexOutputTsConfig=apexOutputTsConfig, apexBootReason=apexBootReason, apexOutputProgramCAS2EcmgChannel=apexOutputProgramCAS2EcmgChannel, apexDepiSessionStatusOutSLIMsgs=apexDepiSessionStatusOutSLIMsgs, apexGbeInputTsEventSourceIp=apexGbeInputTsEventSourceIp, apexGbeRxDocsisFrames=apexGbeRxDocsisFrames, apexPsStatusDiagnosticData1=apexPsStatusDiagnosticData1, apexAlarmChassisRedundancyLinkFault=apexAlarmChassisRedundancyLinkFault, apexInsertion=apexInsertion, apexQamModuleSerialNumQamModuleNum=apexQamModuleSerialNumQamModuleNum, apexGbeStatInTsPriCurDataCount=apexGbeStatInTsPriCurDataCount, trapConfigurationChangeIpAddress=trapConfigurationChangeIpAddress, apexGbeStatusFrameCounter=apexGbeStatusFrameCounter, apexFastEnetInsertRate=apexFastEnetInsertRate, apexGbeConfigInterfaceRedundancyTable=apexGbeConfigInterfaceRedundancyTable, apexGbeInputTsAssignedEntry=apexGbeInputTsAssignedEntry, apexOutputTsUtilizMinPercent=apexOutputTsUtilizMinPercent, apexOutputTsEventIndex=apexOutputTsEventIndex, apexFastEnetStatusGeneral=apexFastEnetStatusGeneral, apexEasServerNum=apexEasServerNum, apexGbeFrameCounterReset=apexGbeFrameCounterReset, apexDepiSessionStatusUnknownAvp=apexDepiSessionStatusUnknownAvp, apexSimulcryptEcmgProgramIndex=apexSimulcryptEcmgProgramIndex, apexEasNumRcvMsgs=apexEasNumRcvMsgs, apexMappingErrorOutputOpMode=apexMappingErrorOutputOpMode, apexRpcSessionStatInputProgramNum=apexRpcSessionStatInputProgramNum, apexChassisRedundancyGeneralConfigSyncStatusText=apexChassisRedundancyGeneralConfigSyncStatusText, apexEnableServiceInError=apexEnableServiceInError, apexChassisRedundancyCommunicationStatus=apexChassisRedundancyCommunicationStatus, apexGbeInputTsEventUdpPort=apexGbeInputTsEventUdpPort, apexRtspStatControllerEntry=apexRtspStatControllerEntry, apexOampLinkActive=apexOampLinkActive, apexChassisRedundancyEventIndex=apexChassisRedundancyEventIndex, apexTemperatureConfig=apexTemperatureConfig, apexEventChassisRedunQAMVersionMismatch=apexEventChassisRedunQAMVersionMismatch, apexQamRfPortStatFreqPllLock=apexQamRfPortStatFreqPllLock, apexQamChannelIdTable=apexQamChannelIdTable, apexOutputProgramMcSimAccessCriteria=apexOutputProgramMcSimAccessCriteria, apexPsipStatusGeneral=apexPsipStatusGeneral, apexSessionControl=apexSessionControl, apexOampIpAddr=apexOampIpAddr, apexFastEnetInsPacketsTotDiscarded=apexFastEnetInsPacketsTotDiscarded, apexGbeConfInputMulticastTimeout=apexGbeConfInputMulticastTimeout, apexBulkPidMapOutputTsNum33to48=apexBulkPidMapOutputTsNum33to48, apexGbeInputTsEventPriCurDataCount=apexGbeInputTsEventPriCurDataCount, apexOutputTsUtilizationTable=apexOutputTsUtilizationTable, apexEasServerEntry=apexEasServerEntry, apexQamQrmRevisionStatusTable=apexQamQrmRevisionStatusTable, apexManRteGbeInRedForceSwitch=apexManRteGbeInRedForceSwitch, apexDepiStatusGeneralDtiCurrentTimestamp=apexDepiStatusGeneralDtiCurrentTimestamp, apexGbeInputTsEventSamplingPeriod=apexGbeInputTsEventSamplingPeriod, apexPsipConfigTimeDsMonthIn=apexPsipConfigTimeDsMonthIn, apexRdsStatusServerRootDirPath=apexRdsStatusServerRootDirPath, apexUlsStatusValidateResponseText=apexUlsStatusValidateResponseText, apexDtaGeneralConfigInvalidApplyText=apexDtaGeneralConfigInvalidApplyText, apexGbeStatInTsPriMinDataCount=apexGbeStatInTsPriMinDataCount, apexQamRfPortStatusTable=apexQamRfPortStatusTable, trapOutputOverflow=trapOutputOverflow, apexRtspEventSourceDescription=apexRtspEventSourceDescription, apexAsi=apexAsi, apexGbeFrameBufferHourlyInMulticastIp=apexGbeFrameBufferHourlyInMulticastIp, apexRdsEmmStatusState=apexRdsEmmStatusState, apexOutputTsStatusInvalidApplyText=apexOutputTsStatusInvalidApplyText, apexChassisRedundancyRedundantApexIp=apexChassisRedundancyRedundantApexIp, apexPsiStatusPid=apexPsiStatusPid, apexGbeConfigInputDataTsUdp=apexGbeConfigInputDataTsUdp, apexQamRfConfigRfChanSpacing=apexQamRfConfigRfChanSpacing, apexDtaGeneralConfigEmmPidNum=apexDtaGeneralConfigEmmPidNum, apexGbeConfInRedundMonitorPeriod=apexGbeConfInRedundMonitorPeriod, apexManRteGbeInRedApplyChange=apexManRteGbeInRedApplyChange, apexChassisRedundancyPrimaryStandbyOverride=apexChassisRedundancyPrimaryStandbyOverride, apexPsStatusErrorStatus=apexPsStatusErrorStatus, apexAlarmGbeInputStreamHighBitRate=apexAlarmGbeInputStreamHighBitRate, apexGbeStatusEntry=apexGbeStatusEntry, apexMcEmmInsertionPid1Enable=apexMcEmmInsertionPid1Enable, apexGbeTxGoodFrames=apexGbeTxGoodFrames, ActiveTYPE=ActiveTYPE, apexOutputAncillaryPid=apexOutputAncillaryPid, apexOutputProgramMcSimAccessCriteriaStatus=apexOutputProgramMcSimAccessCriteriaStatus, apexQamChannelConfigEntry=apexQamChannelConfigEntry, apexRdsEventEntry=apexRdsEventEntry, apexAcpOddCsn=apexAcpOddCsn, apexOutputTsUtilizCurDropPackets=apexOutputTsUtilizCurDropPackets, apexAlarmRdsCommFault=apexAlarmRdsCommFault, apexEasMessageReceiveTimeoutDuration=apexEasMessageReceiveTimeoutDuration, apexDataIpAutoNegotiate=apexDataIpAutoNegotiate, apexPowerSupply=apexPowerSupply, apexOutputAncillaryPidStatus=apexOutputAncillaryPidStatus, apexPsStatusTemperatureStatus=apexPsStatusTemperatureStatus, apexRdsEmmStatusIndex=apexRdsEmmStatusIndex, apexHwEventDescription=apexHwEventDescription, apexGbeConfInputUnicastTimeout=apexGbeConfInputUnicastTimeout, apexDataIpStatusGeneral=apexDataIpStatusGeneral, trapGigeToHostCommFault=trapGigeToHostCommFault, apexRdsRmdPollInterval=apexRdsRmdPollInterval, apexGbeStatusInterfaceRedundActiveIf=apexGbeStatusInterfaceRedundActiveIf, apexDepiControlStatusGeneralUnknownConnectionMessages=apexDepiControlStatusGeneralUnknownConnectionMessages, apexPidMapInputInterface=apexPidMapInputInterface, apexPreencryption=apexPreencryption, apexDepiSessionConfig=apexDepiSessionConfig, apexQamRfRedundConfigRemConnection=apexQamRfRedundConfigRemConnection, apexRtspConfControllerTable=apexRtspConfControllerTable, apexOutputTsUtilizMinRate=apexOutputTsUtilizMinRate, apexGbeFrameBufferStatsGeneral=apexGbeFrameBufferStatsGeneral, apexGbeConfIfRedundAutoSwitchBackPeriod=apexGbeConfIfRedundAutoSwitchBackPeriod, apexOutputTsStatus=apexOutputTsStatus, apexGbeInputTsEventDescription=apexGbeInputTsEventDescription, apexEventEmUserLoginFailed=apexEventEmUserLoginFailed, apexMainBoardTemperature=apexMainBoardTemperature, apexMainBoardType=apexMainBoardType, apexRpcAvgBandwidthEnable=apexRpcAvgBandwidthEnable, apexAsiMonitorPortEncryption=apexAsiMonitorPortEncryption, apexOutputTsUtilizationMonitorEntry=apexOutputTsUtilizationMonitorEntry, apexPidMapMaxPidMappings=apexPidMapMaxPidMappings, apexEncryptionEmmRequestsSent=apexEncryptionEmmRequestsSent, ClearAlarmTYPE=ClearAlarmTYPE, apexDepiSessionStatusLocalUdp=apexDepiSessionStatusLocalUdp, apexOutputAncillaryPidRoutingStatus=apexOutputAncillaryPidRoutingStatus, apexRtspQamStatEntry=apexRtspQamStatEntry, trapCannotCreateSemaphore=trapCannotCreateSemaphore, apexDepiSessionConfigEnable=apexDepiSessionConfigEnable, apexRtspConfMhaSbeCciLevel=apexRtspConfMhaSbeCciLevel, apexRdsSourceLookupDescription=apexRdsSourceLookupDescription, apexQamRfConfigModulationMode=apexQamRfConfigModulationMode, apexGbeStatInTsCurPacketDropCount=apexGbeStatInTsCurPacketDropCount, apexQrmDownloadConfig=apexQrmDownloadConfig, apexGbeConfIfRedundIndex=apexGbeConfIfRedundIndex, apexOutputTsUtilizCurRate=apexOutputTsUtilizCurRate, apexUdpMapFollowDtcp=apexUdpMapFollowDtcp, apexGbeConfIfRedundSuspendFailover=apexGbeConfIfRedundSuspendFailover, apexOutputProgramCAS2EcmgStream=apexOutputProgramCAS2EcmgStream, apexEnableQamModuleRemovalFault=apexEnableQamModuleRemovalFault, apexRdsIpAddr=apexRdsIpAddr, apexGbeInputTsAssignedGbeInterfaceNum=apexGbeInputTsAssignedGbeInterfaceNum, apexMcEmmInsertionPid2=apexMcEmmInsertionPid2, apexAutoRebootEnable=apexAutoRebootEnable, apexMappingErrorSecSourceIp=apexMappingErrorSecSourceIp, apexOutputProgram=apexOutputProgram, apexFastEnetPacketsNumPkts=apexFastEnetPacketsNumPkts, apexChassisRedundancyFailOverTemperatureFault=apexChassisRedundancyFailOverTemperatureFault, apexRtspConfControllerApplyChange=apexRtspConfControllerApplyChange, apexDtaRfPortConfigNetPidInterface=apexDtaRfPortConfigNetPidInterface, apexManualRouteOutputEncryptMode=apexManualRouteOutputEncryptMode, apexRtspStatControllerConnection=apexRtspStatControllerConnection, apexUdpMapStartProgNum=apexUdpMapStartProgNum, apexRdsEmmStatusUnitAddress=apexRdsEmmStatusUnitAddress, apexSesContConfGbeSecondaryInterface=apexSesContConfGbeSecondaryInterface, apexRtspConfMhaEntry=apexRtspConfMhaEntry, apexGbeFrameBufferOverflowLevel=apexGbeFrameBufferOverflowLevel, apexGbeInputTsEventTable=apexGbeInputTsEventTable, apexManualRoutingConfig=apexManualRoutingConfig, apexUdpMapInputInterface=apexUdpMapInputInterface, apexMappingErrorInputProgramPid=apexMappingErrorInputProgramPid, apexRtspConfControlNamesNum=apexRtspConfControlNamesNum, apexGbeStatInTsPriPeakStreamCount=apexGbeStatInTsPriPeakStreamCount, apexUdpMapMulticastApplyIndex=apexUdpMapMulticastApplyIndex, apexPsipStatusServiceState=apexPsipStatusServiceState, apexUdpMapStatus=apexUdpMapStatus, apexOutputProgramTierData=apexOutputProgramTierData, apexQamRfRedundStatusUdpPort=apexQamRfRedundStatusUdpPort, apexEncryptionCwgStatus=apexEncryptionCwgStatus, apexDepiControlStatusGeneral=apexDepiControlStatusGeneral, apexGbeStatusInputTsGeneral=apexGbeStatusInputTsGeneral, apexConfAlarmEnable=apexConfAlarmEnable, apexFastEnetInsPacketsNumPkts=apexFastEnetInsPacketsNumPkts, apexUlsConfigMcSimChannelsRequest=apexUlsConfigMcSimChannelsRequest, apexRtspConfControlNamesTable=apexRtspConfControlNamesTable, apexRdsInitialEcmRetryInterval=apexRdsInitialEcmRetryInterval, apexAlarmRemFault=apexAlarmRemFault, apexQamModuleStatTemperatureFault=apexQamModuleStatTemperatureFault, apexCteEncryptionMode=apexCteEncryptionMode, apexGbeInputTsEventAlarmSeverity=apexGbeInputTsEventAlarmSeverity, apexMainBoardTempFrontIntake=apexMainBoardTempFrontIntake, apexGbeConfigInputDataTsEnable=apexGbeConfigInputDataTsEnable, apexInvalidInitDataTable=apexInvalidInitDataTable, apexManRtePassThroughEnable=apexManRtePassThroughEnable, apexProductType=apexProductType, apexOutputProgramOutputProgNum=apexOutputProgramOutputProgNum, apexEnableGbeInputStreamLowBitRate=apexEnableGbeInputStreamLowBitRate, apexOutputTsUtilizRollingDropPackets=apexOutputTsUtilizRollingDropPackets, apexDepiSessionStatusEgressDlmMsgs=apexDepiSessionStatusEgressDlmMsgs, apexGbeStatusInputTransportStream=apexGbeStatusInputTransportStream, apexChassisRedundancyConfigGeneral=apexChassisRedundancyConfigGeneral, apexOperationalTime=apexOperationalTime, apexGbeFrameBufferHourlyOverflows=apexGbeFrameBufferHourlyOverflows, apexGbeConfigInterfaceRedundancyEntry=apexGbeConfigInterfaceRedundancyEntry, apexGbeBootCodeVersion=apexGbeBootCodeVersion, apexGbeInputDataTsSmoothingPeriod=apexGbeInputDataTsSmoothingPeriod, apexQamRfPortMuteStatus=apexQamRfPortMuteStatus, apexRdsMcast16=apexRdsMcast16, apexManRteGbeInRedTable=apexManRteGbeInRedTable, apexManRteGbeInRedPriMulticastIp=apexManRteGbeInRedPriMulticastIp, apexGbeConfigInputDataTsApplyChange=apexGbeConfigInputDataTsApplyChange, apexMappingErrorOutputTsNum=apexMappingErrorOutputTsNum, apexPsiStatusEntry=apexPsiStatusEntry, apexAlarmGbeInterfaceRedundFailOver=apexAlarmGbeInterfaceRedundFailOver, apexManualRouteOutputCopyProtectSource=apexManualRouteOutputCopyProtectSource, apexAlarmDtiSyncLossFault=apexAlarmDtiSyncLossFault, apexMcEmmInsertionPid2Enable=apexMcEmmInsertionPid2Enable, apexGbeConfInRedundManualRouteRedundType=apexGbeConfInRedundManualRouteRedundType, apexEnableOutputUtilizationFault=apexEnableOutputUtilizationFault, apexUdpMapMulticastEnable=apexUdpMapMulticastEnable, trapSnmpCommunityStringChanged=trapSnmpCommunityStringChanged, apexRpcReportAllSessions=apexRpcReportAllSessions, trapDepiSessionSetupFault=trapDepiSessionSetupFault, apexEncryptionConfInvalidApplyText=apexEncryptionConfInvalidApplyText, apexQamModuleStatFanSpeed=apexQamModuleStatFanSpeed, apexManRteGbeInRedApplyTable=apexManRteGbeInRedApplyTable, apexPsipStatusInputGpsTime=apexPsipStatusInputGpsTime, apexQamRfPortStatDataSyncFault=apexQamRfPortStatDataSyncFault, apexInputTsStatSecInputMulticastIp=apexInputTsStatSecInputMulticastIp, apexEnableDepiControlConnectionFault=apexEnableDepiControlConnectionFault, trapChassisRedundancyPrimaryFailover=trapChassisRedundancyPrimaryFailover, apexAcpStatus=apexAcpStatus, apexInsertPacketStatNumPkts=apexInsertPacketStatNumPkts, apexChassisRedundancyGigE34LinkStatus=apexChassisRedundancyGigE34LinkStatus, apexAcpUnitAttribute=apexAcpUnitAttribute, apexChassisRedundancyFailOverGigE34LinkLoss=apexChassisRedundancyFailOverGigE34LinkLoss, apexOutputProgramConfig=apexOutputProgramConfig, apexOutputTsEventPeakDropPackets=apexOutputTsEventPeakDropPackets, apexRpcApplyChange=apexRpcApplyChange, apexGbeTotalRxSinglecastFrames=apexGbeTotalRxSinglecastFrames, apexRdsEventEpochEnd=apexRdsEventEpochEnd, apexDepiSessionStatusEntry=apexDepiSessionStatusEntry, apexAlarmServiceInError=apexAlarmServiceInError, apexRdsCurrentCsn=apexRdsCurrentCsn, apexGbeConfigInputDataTsSourceIp=apexGbeConfigInputDataTsSourceIp, apexDepiControlStatusGeneralTotalConnections=apexDepiControlStatusGeneralTotalConnections, apexDtaGeneralConfigApplyChange=apexDtaGeneralConfigApplyChange, apexGbeStatInTsSecHighBitRateError=apexGbeStatInTsSecHighBitRateError, apexGbeStatusInputTsErrorEntry=apexGbeStatusInputTsErrorEntry, apexDepiControlStatusGeneralUnknownSessionMessages=apexDepiControlStatusGeneralUnknownSessionMessages, apexChassisRedundancyStatusGeneral=apexChassisRedundancyStatusGeneral, apexBulkPidMapApplyIndex=apexBulkPidMapApplyIndex, apexGbeStatusMacAddr=apexGbeStatusMacAddr, apexQamRfPortChannelInfoChanCount=apexQamRfPortChannelInfoChanCount, apexQamModuleStatPowerFault=apexQamModuleStatPowerFault, apexGbeFrameBufferStatsEntry=apexGbeFrameBufferStatsEntry, apexPsipStatusInputPart=apexPsipStatusInputPart, apexRdsCommErrorCount=apexRdsCommErrorCount, apexPsipConfigTimeApplyChange=apexPsipConfigTimeApplyChange, apexPsipStatusInputEntry=apexPsipStatusInputEntry, apexChassisRedundancyFailOverQamModuleRemoval=apexChassisRedundancyFailOverQamModuleRemoval, apexRpcQamStatSdvGroupBandwidth=apexRpcQamStatSdvGroupBandwidth, apexSysConfigGeneral=apexSysConfigGeneral, apexPsStatusOutputVoltage=apexPsStatusOutputVoltage, apexPsipStatusInputSourceId=apexPsipStatusInputSourceId)
mibBuilder.exportSymbols("APEX-MIB", apexPsipStatusServiceSourceId=apexPsipStatusServiceSourceId, apexOutputTsEventTable=apexOutputTsEventTable, apexPidMapOutputTsNum=apexPidMapOutputTsNum, apexGbeStatInTsSecAvgStreamCount=apexGbeStatInTsSecAvgStreamCount, apexInputTsStatus=apexInputTsStatus, apexEas=apexEas, apexInsertPacketStatTotPkts=apexInsertPacketStatTotPkts, apexDtaGeneralConfigCatEmmPidUdpPort=apexDtaGeneralConfigCatEmmPidUdpPort, apexEnableChassisRedundancyConfigurationFault=apexEnableChassisRedundancyConfigurationFault, apexDepiSessionStatusInSLIMsgs=apexDepiSessionStatusInSLIMsgs, apexSessionControlStatus=apexSessionControlStatus, trapServiceInError=trapServiceInError, apexEasMulticastIpAddress=apexEasMulticastIpAddress, apexOutputTsUtilizPeakRate=apexOutputTsUtilizPeakRate, apexDepiControl=apexDepiControl, apexQamRfRedundStatusRemError=apexQamRfRedundStatusRemError, apexRtspConfControlNamesStreamingZone=apexRtspConfControlNamesStreamingZone, apexDepiControlConfigEnable=apexDepiControlConfigEnable, apexAlarmQamModuleRemovalFault=apexAlarmQamModuleRemovalFault, apexQamRfRedundStatusRemSwitch=apexQamRfRedundStatusRemSwitch, apexRtspConfGbeEdgeGroupName=apexRtspConfGbeEdgeGroupName, apexEncryptionEmmMaxDeliveryTimeMs=apexEncryptionEmmMaxDeliveryTimeMs, apexRtspStatControllerCommFault=apexRtspStatControllerCommFault, apexMcSim=apexMcSim, apexRtspStatQamMptsModeTable=apexRtspStatQamMptsModeTable, apexEasServerSourceIpAddress=apexEasServerSourceIpAddress, apexGbeOpenInputUdpPortEntry=apexGbeOpenInputUdpPortEntry, apexHwEventTable=apexHwEventTable, apexUserSuppliedTime=apexUserSuppliedTime, apexManualRoutingStatus=apexManualRoutingStatus, apexRdsStatusServerIp=apexRdsStatusServerIp, apexOutputTsEventDescription=apexOutputTsEventDescription, apexAlarmQamRfRedundMismatch=apexAlarmQamRfRedundMismatch, apexOutputTsConfOperatingMode=apexOutputTsConfOperatingMode, apexDepiSession=apexDepiSession, apexOutputProgramCAS7EcmgChannel=apexOutputProgramCAS7EcmgChannel, apexRtspEventEntry=apexRtspEventEntry, apexUdpMapStatusTable=apexUdpMapStatusTable, apexManualRoutingServiceErrorStatus=apexManualRoutingServiceErrorStatus, apexQamRfPortStatOutputLevel=apexQamRfPortStatOutputLevel, apexGbeFrameBufferHourlyGpsTime=apexGbeFrameBufferHourlyGpsTime, apexManRteGbeInRedSecUdp=apexManRteGbeInRedSecUdp, apexOutputAncillaryPidIndex=apexOutputAncillaryPidIndex, apexPsPowerFaultFilter=apexPsPowerFaultFilter, apexUdpMapTsOffset=apexUdpMapTsOffset, apexQamChanConfigInterleaverSelect=apexQamChanConfigInterleaverSelect, apexFastEnetDefaultGateway=apexFastEnetDefaultGateway, apexOutputProgramError=apexOutputProgramError, apexPsipStatus=apexPsipStatus, apexQamRfPortMuteStatusTable=apexQamRfPortMuteStatusTable, apexPsipConfigTimeDsDayOut=apexPsipConfigTimeDsDayOut, apexEcmEmmFirstPid=apexEcmEmmFirstPid, apexDepiStatusGeneralDtiClientStatusMode=apexDepiStatusGeneralDtiClientStatusMode, apexGbeOpenInputUdpPortCount=apexGbeOpenInputUdpPortCount, apexBulkPidMapInputType=apexBulkPidMapInputType, apexRdsFlashWriteCount=apexRdsFlashWriteCount, apexDepiControlConfigApplyEntry=apexDepiControlConfigApplyEntry, apexChassisRedundancySuspend=apexChassisRedundancySuspend, apexPidMapStatus=apexPidMapStatus, apexManRtePassThroughTable=apexManRtePassThroughTable, trapChassisRedundancySecondaryFailover=trapChassisRedundancySecondaryFailover, apexOutputProgramRoutingStatus=apexOutputProgramRoutingStatus, apexManualRoutingServiceStatus=apexManualRoutingServiceStatus, apexGbeConfIfRedundAutoSwitchBackEnable=apexGbeConfIfRedundAutoSwitchBackEnable, apexSesContConfEntry=apexSesContConfEntry, apexInvalidInitDataDescription=apexInvalidInitDataDescription, apexManRteGbeInRedSecInterface=apexManRteGbeInRedSecInterface, apexChassisRedundancyRedundantApexSecIp=apexChassisRedundancyRedundantApexSecIp, apexManRtePassThroughInputSourceIp=apexManRtePassThroughInputSourceIp, apexDepiSessionStatusInSequenceDiscards=apexDepiSessionStatusInSequenceDiscards, apexGbeConfigFrameBufferProcessorNum=apexGbeConfigFrameBufferProcessorNum, apexRpcRfChannelNum=apexRpcRfChannelNum, apexOampDuplexMode=apexOampDuplexMode, apexGbeConfInRedundSwitchTime=apexGbeConfInRedundSwitchTime, apexRtspConfMhaAddressDomain=apexRtspConfMhaAddressDomain, apexUlsConfig=apexUlsConfig, apexQamModuleSerialNumEntry=apexQamModuleSerialNumEntry, apexOutputTsUtilMonOutputTsNum=apexOutputTsUtilMonOutputTsNum, apexTimeSource=apexTimeSource, apexEventChassisRedunPrimaryForceFailover=apexEventChassisRedunPrimaryForceFailover, apexInputTsStatRoutingType=apexInputTsStatRoutingType, apexGbeFrameBufferStatsTable=apexGbeFrameBufferStatsTable, apexGbeConfigInterfaceRedundancy=apexGbeConfigInterfaceRedundancy, apexGbeConfigInterfaceNum=apexGbeConfigInterfaceNum, apexRdsEventPreviewDuration=apexRdsEventPreviewDuration, apexPsStatusOutputCurrent=apexPsStatusOutputCurrent, apexRdsEventControlByte=apexRdsEventControlByte, apexOutputTsUtilMonSetAlarmDelay=apexOutputTsUtilMonSetAlarmDelay, apexDpmVersion=apexDpmVersion, apexQamRfPortChannelInfoTable=apexQamRfPortChannelInfoTable, apexUdpPortMapping=apexUdpPortMapping, apexQrmFileRevCalibration=apexQrmFileRevCalibration, apexRdsEventPurchaseDuration=apexRdsEventPurchaseDuration, apexGbeConfIfRedundForceFailover=apexGbeConfIfRedundForceFailover, apexInsertPacketStatisticsTable=apexInsertPacketStatisticsTable, apexGbeStatInTsErrorInputTsNum=apexGbeStatInTsErrorInputTsNum, apexPatVersionIncrement=apexPatVersionIncrement, apexRtspConfMhaTable=apexRtspConfMhaTable, apexManRteGbeInRedPriSourceIp=apexManRteGbeInRedPriSourceIp, apexGbeSfpConfig=apexGbeSfpConfig, apexPsipConfigSttMsgInsertionPeriod=apexPsipConfigSttMsgInsertionPeriod, apexGbeStatInTsSecPeakStreamCount=apexGbeStatInTsSecPeakStreamCount, apexRtspConfControlNamesDeviceName=apexRtspConfControlNamesDeviceName, apexGbeSfpStatusTable=apexGbeSfpStatusTable, trapQamRfRedundFailOver=trapQamRfRedundFailOver, apexSys=apexSys, apexQamQrmRevisionTable=apexQamQrmRevisionTable, apexGbeInputTsEventInputTsState=apexGbeInputTsEventInputTsState, apexRdsEventTable=apexRdsEventTable, apexRtspConfQamChannelApplyTable=apexRtspConfQamChannelApplyTable, apexChassisRedundancyEventEntry=apexChassisRedundancyEventEntry, trapChassisRedundancyQAMVersionMismatch=trapChassisRedundancyQAMVersionMismatch, apexGbeStatusRoutedPacketOutputTsNum=apexGbeStatusRoutedPacketOutputTsNum, apexRtspConfControllerBandwidthDelta=apexRtspConfControllerBandwidthDelta, apexInputTsStatPriInputSourceIp=apexInputTsStatPriInputSourceIp, apexUdpMapPreEncryptCheck=apexUdpMapPreEncryptCheck, apexInsertPacketStatisticsEntry=apexInsertPacketStatisticsEntry, apexDepiControlStatusUnknownCtl=apexDepiControlStatusUnknownCtl, apexSystemTime=apexSystemTime, apexRdsSourceLookupTable=apexRdsSourceLookupTable, apexPsipConfigApplyChange=apexPsipConfigApplyChange, apexDataIpSubnetMaskInUse=apexDataIpSubnetMaskInUse, apexRtspConfControllerApplyTable=apexRtspConfControllerApplyTable, apexPsStatusGeneral=apexPsStatusGeneral, apexDepiStatusGeneralDtiPort2LinkActive=apexDepiStatusGeneralDtiPort2LinkActive, apexRtspConfControllerApplyEntry=apexRtspConfControllerApplyEntry, apexGbeInputTsEventRedundantConfig=apexGbeInputTsEventRedundantConfig, apexRpcStatusGeneral=apexRpcStatusGeneral, apexRdsStatus=apexRdsStatus, apexFastEnetInsPacketsTotPkts=apexFastEnetInsPacketsTotPkts, apexRpcSessionStatManagerIpAddr=apexRpcSessionStatManagerIpAddr, apexRtspConfQamChannelApplyNum=apexRtspConfQamChannelApplyNum, apexOutputTsStatusTable=apexOutputTsStatusTable, apexDtaConfigApplyEntry=apexDtaConfigApplyEntry, apexQamRfRedundConfigApplyChange=apexQamRfRedundConfigApplyChange, apexEnableQamRfPortFault=apexEnableQamRfPortFault, apexUlsStatusMcSimChannelsMax=apexUlsStatusMcSimChannelsMax, apexManualRouteOutputProgNum=apexManualRouteOutputProgNum, apexMappingErrorSecMulticastIp=apexMappingErrorSecMulticastIp, apexPsipConfigEit1InsertionPeriod=apexPsipConfigEit1InsertionPeriod, apexDepiSessionStatusInDataPacketDiscards=apexDepiSessionStatusInDataPacketDiscards, apexRdsEventEpochStart=apexRdsEventEpochStart, apexDepiControlStatusCurrentSessions=apexDepiControlStatusCurrentSessions, apexManualRoutingServiceStatusTable=apexManualRoutingServiceStatusTable, apexManRteGbeInRedSuspend=apexManRteGbeInRedSuspend, apexTimeConfig=apexTimeConfig, apexRpcRfPortNum=apexRpcRfPortNum, apexBulkPidMapInputMulticastIp=apexBulkPidMapInputMulticastIp, apexSesContConfProtocol=apexSesContConfProtocol, apexQamQrmRevStatQrmSupported=apexQamQrmRevStatQrmSupported, apexOutputTsStatusGeneral=apexOutputTsStatusGeneral, apexRtspConfMhaPort=apexRtspConfMhaPort, apexGbeConfigInterfaceRedundancyGeneral=apexGbeConfigInterfaceRedundancyGeneral, apexPsipStatusInputInfo=apexPsipStatusInputInfo, apexDtaOtsConfigEntry=apexDtaOtsConfigEntry, apexGbeConfIfRedundEnable=apexGbeConfIfRedundEnable, apexUdpMapInvalidApplyText=apexUdpMapInvalidApplyText, apexDepiControlConfigOverUdp=apexDepiControlConfigOverUdp, apexQamChannelStatusEntry=apexQamChannelStatusEntry, apexOutputProgramCAS8EcmgStream=apexOutputProgramCAS8EcmgStream, apexPsiStatusIndex=apexPsiStatusIndex, NetworkSpeedTYPE=NetworkSpeedTYPE, apexManRtePassThroughEntry=apexManRtePassThroughEntry, apexOutputTsUtilizTime=apexOutputTsUtilizTime, apexEnableGbeLossOfInputTsFault=apexEnableGbeLossOfInputTsFault, apexRpcSessionStatProgramBandwidth=apexRpcSessionStatProgramBandwidth, apexQamModuleStatBoardTemperature=apexQamModuleStatBoardTemperature, apexFastEnetMaxInputUdpPorts=apexFastEnetMaxInputUdpPorts, apexOutputTsConfigGeneral=apexOutputTsConfigGeneral, apexGbeInputTsEventSecCurDataCount=apexGbeInputTsEventSecCurDataCount, apexGbeStatusGbeInterfaceNum=apexGbeStatusGbeInterfaceNum, apexEncryptionConfig=apexEncryptionConfig, apexAlarmQamModuleFault=apexAlarmQamModuleFault, apexHwEventData=apexHwEventData, apexFastEnetPacketsNumDiscarded=apexFastEnetPacketsNumDiscarded, apexEnableGbeInterfaceRedundFailOver=apexEnableGbeInterfaceRedundFailOver, apexAcpStatusGeneral=apexAcpStatusGeneral, apexMappingErrorInputType=apexMappingErrorInputType, apexPsStatusTable=apexPsStatusTable, apexChassisRedundancyCurrHBIntfIPStatus=apexChassisRedundancyCurrHBIntfIPStatus, apexChassisRedundancyConfigurationStatus=apexChassisRedundancyConfigurationStatus, apexGbeTotalRxMulticastFrames=apexGbeTotalRxMulticastFrames, apexEncryptionEmmGoodRepliesRecvd=apexEncryptionEmmGoodRepliesRecvd, InputTsStateTYPE=InputTsStateTYPE, apexQrmDownloadConfigRequest=apexQrmDownloadConfigRequest, apexGbeStatInTsPriErrorSummary=apexGbeStatInTsPriErrorSummary, apexCteCciLevel=apexCteCciLevel, apexPsipStatusOutputPid=apexPsipStatusOutputPid, apexGbeStatusInterfaceRedundFaultCondition=apexGbeStatusInterfaceRedundFaultCondition, apexQamModuleUpgrade=apexQamModuleUpgrade, apexPsStatusInstalled=apexPsStatusInstalled, apexChassisRedundancyFirmwareMismatchStatus=apexChassisRedundancyFirmwareMismatchStatus, apexFastEnet=apexFastEnet, apexRpcRfPortName=apexRpcRfPortName, apexQamModuleUpgradeApplyChange=apexQamModuleUpgradeApplyChange, apexPsipConfigEit3InsertionPeriod=apexPsipConfigEit3InsertionPeriod, apexDta=apexDta, apexPidMapInputAncillaryPidDetection=apexPidMapInputAncillaryPidDetection, apexOutputTsUtilMonClearAlarmDelay=apexOutputTsUtilMonClearAlarmDelay, apexGbeConfigFrameBufferAlarmThreshold=apexGbeConfigFrameBufferAlarmThreshold, trapGbeBufferFullness=trapGbeBufferFullness, apexTemperatureConfigGeneral=apexTemperatureConfigGeneral, apexRtspStatControllerDiscovery=apexRtspStatControllerDiscovery, apexQamModuleUpgradeCode=apexQamModuleUpgradeCode, apexUlsStatusMcSimChannelsCurrent=apexUlsStatusMcSimChannelsCurrent, apexRtspStatQamChannelNum=apexRtspStatQamChannelNum, apexGbeConfInRedundForceToSecondary=apexGbeConfInRedundForceToSecondary, apexUdpMapApplyTable=apexUdpMapApplyTable, apexManualRouting=apexManualRouting, apexTimeStatus=apexTimeStatus, apexOutputTsUtilMonAlarmThreshold=apexOutputTsUtilMonAlarmThreshold, apexRtspEventTimeLogged=apexRtspEventTimeLogged, apexEncryptionConfAlgorithm=apexEncryptionConfAlgorithm, apexAcpStatusEntry=apexAcpStatusEntry, apexManRteGbeInRedForceSwitchEntry=apexManRteGbeInRedForceSwitchEntry, apexSesContConfTableApplyChange=apexSesContConfTableApplyChange, apexQamRfPortStatNumChannelsActive=apexQamRfPortStatNumChannelsActive, apexAncillaryPidMapping=apexAncillaryPidMapping, apexMainBoardTempMuxFpga=apexMainBoardTempMuxFpga, apexUlsStatusGenerateRequestText=apexUlsStatusGenerateRequestText, apexManRteGbeInRedApplyIndex=apexManRteGbeInRedApplyIndex, apexRpcRfPortTable=apexRpcRfPortTable, apexEncryptionCwCountsPerSecond=apexEncryptionCwCountsPerSecond, apexEventChassisRedunFirmwareVersionMismatch=apexEventChassisRedunFirmwareVersionMismatch, apexDepiControlStatusConnectionStatus=apexDepiControlStatusConnectionStatus, apexUlsConfigGeneral=apexUlsConfigGeneral, apexQrmFileRevFpga2=apexQrmFileRevFpga2, apexUdpMapMulticastIndex=apexUdpMapMulticastIndex, apexGbeConfigInterfaceRedundancyApplyEntry=apexGbeConfigInterfaceRedundancyApplyEntry, apexQamChannelIdModuleRfPortNum=apexQamChannelIdModuleRfPortNum, apexDepiSessionConfigApplyOutputTsNum=apexDepiSessionConfigApplyOutputTsNum, apexRtspStatQamChannelTable=apexRtspStatQamChannelTable, apexUdpMapNumberProgs=apexUdpMapNumberProgs, apexGbeStatInTsInputTsNum=apexGbeStatInTsInputTsNum, apexEnableQamRfRedundFailOver=apexEnableQamRfRedundFailOver, apexAcpConfigGeneral=apexAcpConfigGeneral, apexTemperatureStatus=apexTemperatureStatus, apexProductName=apexProductName, apexFastEnetConfig=apexFastEnetConfig, apexRpcQamStatNumSdvSessions=apexRpcQamStatNumSdvSessions, apexOutputTsStatusServicesInError=apexOutputTsStatusServicesInError, apexGbeStatusFrameCounterTable=apexGbeStatusFrameCounterTable, apexGbeConfigInterfaceRedundancyApplyTable=apexGbeConfigInterfaceRedundancyApplyTable, apexDtiFpgaVersion=apexDtiFpgaVersion, apexGbeSfpStatusGbeIfNum=apexGbeSfpStatusGbeIfNum, apexRpcSessionStatOutputQamChannel=apexRpcSessionStatOutputQamChannel, trapChassisRedundancyLinkFault=trapChassisRedundancyLinkFault, apexDepiStatusGeneralDtiPort1LinkActive=apexDepiStatusGeneralDtiPort1LinkActive, apexRdsStatusValidation=apexRdsStatusValidation, apexDepiSessionStatusGeneralInvalidApplyText=apexDepiSessionStatusGeneralInvalidApplyText, apexBulkPidMapInputPid=apexBulkPidMapInputPid, apexMainBoardTempAcpModuleFault=apexMainBoardTempAcpModuleFault, apexDepiSessionStatusRemoteUdp=apexDepiSessionStatusRemoteUdp, trapRdsCommFault=trapRdsCommFault)
mibBuilder.exportSymbols("APEX-MIB", trapInvalidCaseInSwitch=trapInvalidCaseInSwitch, apexSimulcryptEcmgStatusEntry=apexSimulcryptEcmgStatusEntry, apexAlarmGbeMptsRedundFailOver=apexAlarmGbeMptsRedundFailOver, apexRpcRfChannelName=apexRpcRfChannelName, apexManRteGbeInRedConfigGeneral=apexManRteGbeInRedConfigGeneral, apexGbeTotalTxErrorFrames=apexGbeTotalTxErrorFrames, apexChassisRedundancyConfigApplyChange=apexChassisRedundancyConfigApplyChange, apexDepiConfigHostname=apexDepiConfigHostname, apexGbeStatusInterfaceRedundEntry=apexGbeStatusInterfaceRedundEntry, apexQamRfPortStatRefClockPresent=apexQamRfPortStatRefClockPresent, apexRtspConfMhaSbe=apexRtspConfMhaSbe, apexBulkPidMapEnable=apexBulkPidMapEnable, apexBulkPidMapInputSourceIp=apexBulkPidMapInputSourceIp, apexOutputTsConfOutPatTsId=apexOutputTsConfOutPatTsId, apexQrmDownload=apexQrmDownload, apexManRteGbeInRedApplyEntry=apexManRteGbeInRedApplyEntry, apexSessionControlConfigGeneral=apexSessionControlConfigGeneral, InputInterfaceTYPE=InputInterfaceTYPE, apexManualRouteGbeInputRedundConfig=apexManualRouteGbeInputRedundConfig, apexOutputProgramStatus=apexOutputProgramStatus, apexEnableOutputOverflow=apexEnableOutputOverflow, apexQamChannelConfigApplyEntry=apexQamChannelConfigApplyEntry, apexEnableChassisRedundancyLinkFault=apexEnableChassisRedundancyLinkFault, apexOutputProgramSourceId=apexOutputProgramSourceId, apexDepiSessionConfigDocsisTsid=apexDepiSessionConfigDocsisTsid, apexQamRfRedundancyConfig=apexQamRfRedundancyConfig, apexGbeConfigGeneral=apexGbeConfigGeneral, apexQamModuleStatCommError=apexQamModuleStatCommError, NetworkDuplexModeTYPE=NetworkDuplexModeTYPE, apexOutputProgramCAS3EcmgChannel=apexOutputProgramCAS3EcmgChannel, apexPsipConfigEit0InsertionPeriod=apexPsipConfigEit0InsertionPeriod, apexRpcDeviceName=apexRpcDeviceName, apexEasServerApplyChange=apexEasServerApplyChange, apexGbeTotalRxErrorFrames=apexGbeTotalRxErrorFrames, apexAcpEvenCsn=apexAcpEvenCsn, apexAlarmInvalidInitData=apexAlarmInvalidInitData, apexOutputTsUtilizThreshold=apexOutputTsUtilizThreshold, apexDataIpAddrInUse=apexDataIpAddrInUse, apexGbeStatInTsSecCurDataCount=apexGbeStatInTsSecCurDataCount, apexOutputTsStatusMessageGenerationNum=apexOutputTsStatusMessageGenerationNum, apexPsStatusFanStatus=apexPsStatusFanStatus, apexDepiSessionStatusSessionID=apexDepiSessionStatusSessionID, apexEasLastReceivedMessageStatusEntry=apexEasLastReceivedMessageStatusEntry, apexOutputAncillaryPidConfigGeneral=apexOutputAncillaryPidConfigGeneral, apexGbeFrameBufferHourlyEntry=apexGbeFrameBufferHourlyEntry, apexEnableLossOfInputAncillaryPid=apexEnableLossOfInputAncillaryPid, apexChassisRedundancyGigE12LinkStatus=apexChassisRedundancyGigE12LinkStatus, apexOutputProgramInputTsIndex=apexOutputProgramInputTsIndex, apexRtspConfMhaSbeApplyChange=apexRtspConfMhaSbeApplyChange, apexMainBoardTempFrontIntakeFault=apexMainBoardTempFrontIntakeFault, apexOutputProgramCitSetting=apexOutputProgramCitSetting, apexRdsEmmStatusGpsTime=apexRdsEmmStatusGpsTime, apexGbeInputTsAssignedCount=apexGbeInputTsAssignedCount, apexMainBoardTempHostProcessorFault=apexMainBoardTempHostProcessorFault, apexRpcQamStatTable=apexRpcQamStatTable, apexGbeConfigInputDataTsIndex=apexGbeConfigInputDataTsIndex, apexDepiControlConfigApplyIndex=apexDepiControlConfigApplyIndex, apexEncryptionMcDiagTable=apexEncryptionMcDiagTable, apexMcSimConfigInvalidApplyText=apexMcSimConfigInvalidApplyText, apexManualRouteEntry=apexManualRouteEntry, apexOutputProgramCAS1EcmgStream=apexOutputProgramCAS1EcmgStream, apexRtspConfQamChannelApplyChange=apexRtspConfQamChannelApplyChange, apexOampConfig=apexOampConfig, apexEncryptionStatAlgorithm=apexEncryptionStatAlgorithm, apexDepiSessionStatusStatus=apexDepiSessionStatusStatus, apexOutputTsStatusAncillaryPidsMapped=apexOutputTsStatusAncillaryPidsMapped, trapRtspControllerCommFault=trapRtspControllerCommFault, apexEventSnmpCommunityStringChanged=apexEventSnmpCommunityStringChanged, apexRpcRfChannelTable=apexRpcRfChannelTable, apexOutputAncillaryPidOutputTsNum=apexOutputAncillaryPidOutputTsNum, apexDepiSessionStatusPerHopBehavior=apexDepiSessionStatusPerHopBehavior, apexQamModuleStatCodeInitError=apexQamModuleStatCodeInitError, apexOutputProgramApsLevel=apexOutputProgramApsLevel, apexOampStatusGeneral=apexOampStatusGeneral, apexSimulcryptEcmgStatusTable=apexSimulcryptEcmgStatusTable, apexRtspConfControllerNum=apexRtspConfControllerNum, apexOampSpeed=apexOampSpeed, apexOutputProgramProgramType=apexOutputProgramProgramType, apexEasServerApplyEntry=apexEasServerApplyEntry, apexEasServerApplyNum=apexEasServerApplyNum, apexBulkPidMapTable=apexBulkPidMapTable, apexPidMapInvalidApplyText=apexPidMapInvalidApplyText, apexOutputTsUtilizationEntry=apexOutputTsUtilizationEntry, apexGbeConfigInputDataTsEntry=apexGbeConfigInputDataTsEntry, apexManRteGbeInRedStatusMapTable=apexManRteGbeInRedStatusMapTable, apexRtspStatControllerTable=apexRtspStatControllerTable, apexEnableChassisRedundancyAvailabilityFault=apexEnableChassisRedundancyAvailabilityFault, EthernetInterfaceTYPE=EthernetInterfaceTYPE, apexEasServerPhysInPort=apexEasServerPhysInPort, apexDepiSessionStatusLatencyEnd=apexDepiSessionStatusLatencyEnd, apexRdsProgramMessagesReceived=apexRdsProgramMessagesReceived, apexGbeStatInTsMptsRedundFailError=apexGbeStatInTsMptsRedundFailError, apexQamRfConfigRfLevelAttenuation=apexQamRfConfigRfLevelAttenuation, apexQamQrmRevisionStatusEntry=apexQamQrmRevisionStatusEntry, apexDepiControlStatusMalformedAvp=apexDepiControlStatusMalformedAvp, apexUlsStatusCommitNewFeaturesText=apexUlsStatusCommitNewFeaturesText, apexInputTsStatSecInputSourceIp=apexInputTsStatSecInputSourceIp, trapGbeMptsRedundFailOver=trapGbeMptsRedundFailOver, apexOutputTsConfPcrLess=apexOutputTsConfPcrLess, apexEasStatusGeneral=apexEasStatusGeneral, apexRtspConfMhaNum=apexRtspConfMhaNum, apexSimulcryptEcmgInfo=apexSimulcryptEcmgInfo, apexDataIpNetworkSpeed=apexDataIpNetworkSpeed, apexFastEnetRoutingDestinIp=apexFastEnetRoutingDestinIp, apexEnableGbeInputStreamHighBitRate=apexEnableGbeInputStreamHighBitRate, apexDepiControlStatusEntry=apexDepiControlStatusEntry, apexGbeInputTsEventPriCurStreamCount=apexGbeInputTsEventPriCurStreamCount, apexOampNetworkSpeed=apexOampNetworkSpeed, apexRdsCetRefresh=apexRdsCetRefresh, apexEncryptionEmmGoodDeliveryTimeMs=apexEncryptionEmmGoodDeliveryTimeMs, apexUdpMapMulticastApplyEntry=apexUdpMapMulticastApplyEntry, apexAlarmQamRfRedundFailOver=apexAlarmQamRfRedundFailOver, apexManualRouteEnable=apexManualRouteEnable, apexGbeConfigInputDataTsTable=apexGbeConfigInputDataTsTable, apexOampAutoNegotiate=apexOampAutoNegotiate, apexPidMapOutputPid=apexPidMapOutputPid, apexDataIpNetworkDuplexMode=apexDataIpNetworkDuplexMode, apexFastEnetStatusPacketsEntry=apexFastEnetStatusPacketsEntry, trapChassisRedundancyPrimaryForceFailover=trapChassisRedundancyPrimaryForceFailover, trapConfigurationChangeOID=trapConfigurationChangeOID, apexPsip=apexPsip, apexRtspEventControllerIp=apexRtspEventControllerIp, apexGbeTotalRxDocsisFrames=apexGbeTotalRxDocsisFrames, apexPsipStatusInputIndex=apexPsipStatusInputIndex, apexFastEnetRoutingIndex=apexFastEnetRoutingIndex, apexRtspStatQamMptsModeQamChannelNum=apexRtspStatQamMptsModeQamChannelNum, apexOutputProgramMcSimAccessCriteriaString=apexOutputProgramMcSimAccessCriteriaString, apexQamQrmRevSerialNumber=apexQamQrmRevSerialNumber, apexOutputProgramEcmServiceId=apexOutputProgramEcmServiceId, apexManRtePassThroughApplyTable=apexManRtePassThroughApplyTable, apexChassisRedundancyEventDescription=apexChassisRedundancyEventDescription, apexRtspSessionIdTable=apexRtspSessionIdTable, apexGbeFrameBufferCurrPercentFull=apexGbeFrameBufferCurrPercentFull, apexGbeRxErrorFrames=apexGbeRxErrorFrames, apexChassisRedundancyRedundantHBEnable=apexChassisRedundancyRedundantHBEnable, apexChassisRedundancyQamMismatchStatus=apexChassisRedundancyQamMismatchStatus, apexBootMethod=apexBootMethod, apexOutputTsEventTimeLogged=apexOutputTsEventTimeLogged, apexQamQrmRevAppFw=apexQamQrmRevAppFw, apexEnableRemFault=apexEnableRemFault, trapChassisRedundancyFirmwareVersionMismatch=trapChassisRedundancyFirmwareVersionMismatch, apexOutputTsStatusScgsProvisioned=apexOutputTsStatusScgsProvisioned, apexPsStatusDiagnosticData2=apexPsStatusDiagnosticData2, apexEnableGbeMptsRedundPrimaryThreshold=apexEnableGbeMptsRedundPrimaryThreshold, apexQamRfRedundConfigAutoSwitchBack=apexQamRfRedundConfigAutoSwitchBack, trapConditionNotInList=trapConditionNotInList, apexAlarmLossOfInputAncillaryPid=apexAlarmLossOfInputAncillaryPid, apexEnableGbeLossOfPhysicalInput=apexEnableGbeLossOfPhysicalInput, apexPsConfig=apexPsConfig, apexGbeSfpUpdateStatus=apexGbeSfpUpdateStatus, apexChassisRedundancy=apexChassisRedundancy, apexPsStatusFanSpeed=apexPsStatusFanSpeed, apexQamChannelIdChannelLetter=apexQamChannelIdChannelLetter, apexSessionControlConfig=apexSessionControlConfig, ApplyDataToDeviceTYPE=ApplyDataToDeviceTYPE, apexAlarmOutputUtilizationFault=apexAlarmOutputUtilizationFault, apexManualRoutingStatusGeneral=apexManualRoutingStatusGeneral, apexUdpMapMulticastApplyTable=apexUdpMapMulticastApplyTable, apexChassisRedundancyMode=apexChassisRedundancyMode, apexFastEnetInsPacketsNumDiscarded=apexFastEnetInsPacketsNumDiscarded, apexQamConfigApplyTable=apexQamConfigApplyTable, apexMappingErrorCode=apexMappingErrorCode, apexRpcSessionStatSessionIdWord2=apexRpcSessionStatSessionIdWord2, apexBulkPidMapInvalidApplyText=apexBulkPidMapInvalidApplyText, apexMappingErrorInputInterface=apexMappingErrorInputInterface, apexRtsp=apexRtsp, apexGbeStatusLinkActive=apexGbeStatusLinkActive, apexOutputTsConfApplyEntry=apexOutputTsConfApplyEntry, apexEasLastReceivedMessageTime=apexEasLastReceivedMessageTime, apexRdsEventInterstitialDuration=apexRdsEventInterstitialDuration, apexPidMapEntry=apexPidMapEntry, apexRtspSessionStatTable=apexRtspSessionStatTable, apexQamModuleStatFaultSumm=apexQamModuleStatFaultSumm, apexDepiSessionConfigApplyTable=apexDepiSessionConfigApplyTable, apexRtspConfControllerEntry=apexRtspConfControllerEntry, apexQamConfigApplyRfPortNum=apexQamConfigApplyRfPortNum, apexQamModuleStat3dot3VdcSupply=apexQamModuleStat3dot3VdcSupply, apexQamConfigTransmissionMode=apexQamConfigTransmissionMode, apexManualRouteInputProgNum=apexManualRouteInputProgNum, apexPsipStatusInputPid=apexPsipStatusInputPid, apexPsStatusPsNum=apexPsStatusPsNum, apexQamQrmRevStatFpga=apexQamQrmRevStatFpga, apexGbeRxFrames=apexGbeRxFrames, apexRpcSessionStatOutputProgramNum=apexRpcSessionStatOutputProgramNum, apexRdsCetNextPollTime=apexRdsCetNextPollTime, apexGbeStatusIgmpVersion=apexGbeStatusIgmpVersion, apexDepiSessionStatusControlId=apexDepiSessionStatusControlId, apexAsiConfig=apexAsiConfig, apexGbeFrameBufferHourlyIndex=apexGbeFrameBufferHourlyIndex, apexDataIpAddr=apexDataIpAddr, apexOutputProgramCciLevel=apexOutputProgramCciLevel, apexQamQrmRevStatBoardId=apexQamQrmRevStatBoardId, apexOutputTsStatusServicesMuxed=apexOutputTsStatusServicesMuxed, apexQamModuleStatusTable=apexQamModuleStatusTable, apexRtspConfigGeneral=apexRtspConfigGeneral, apexGbeConfigInputDataTsMaxRate=apexGbeConfigInputDataTsMaxRate, apexCteApsLevel=apexCteApsLevel, apexGbeStatInTsPriLossInputError=apexGbeStatInTsPriLossInputError, apexQamRfPortStat5VdcFault=apexQamRfPortStat5VdcFault, apexOutputProgramCAS5EcmgChannel=apexOutputProgramCAS5EcmgChannel, apexOampConfigGeneral=apexOampConfigGeneral, apexAlarmChassisRedundancySecondaryFailover=apexAlarmChassisRedundancySecondaryFailover, apexGbeApplicationCodeVersion=apexGbeApplicationCodeVersion, apexSesContConfInputPreEncryptCheck=apexSesContConfInputPreEncryptCheck, apexDtaConfigApplyTable=apexDtaConfigApplyTable, apexFastEnetInsertRateOutputTsNum=apexFastEnetInsertRateOutputTsNum, apexRtspStatQamMptsModeQamChannelMode=apexRtspStatQamMptsModeQamChannelMode, trapLossOfInputAncillaryPid=trapLossOfInputAncillaryPid, apexOutputTsUtilizAvgRate=apexOutputTsUtilizAvgRate, apexOutputTsStatusOutputTsNum=apexOutputTsStatusOutputTsNum, apexFastEnetPacketsTotPkts=apexFastEnetPacketsTotPkts, apexQrmDownloadConfigEntry=apexQrmDownloadConfigEntry, apexGbeSfpConfigGeneral=apexGbeSfpConfigGeneral, apexPsipStatusServiceNum=apexPsipStatusServiceNum, apexQamRfPortStatDataClockPresent=apexQamRfPortStatDataClockPresent, apexEnableQamChannelFault=apexEnableQamChannelFault, apexPsiStatusGeneral=apexPsiStatusGeneral, apexQamChannelIdChannelDescription=apexQamChannelIdChannelDescription, apexPsipStatusServiceIndex=apexPsipStatusServiceIndex, apexMappingErrorSecUdpPort=apexMappingErrorSecUdpPort, apexManualRouteApplyTable=apexManualRouteApplyTable, apexGbeInputTsEventTimeLogged=apexGbeInputTsEventTimeLogged, apexOutputProgramTable=apexOutputProgramTable, apexOutputAncillaryPidInputTsNum=apexOutputAncillaryPidInputTsNum, trapFanFault=trapFanFault, trapGbeInterfaceRedundFailOver=trapGbeInterfaceRedundFailOver, apexOutputTsStatusProgramsPerTs=apexOutputTsStatusProgramsPerTs, apexGbeStatusFrameCounterEntry=apexGbeStatusFrameCounterEntry, apexUdpMapOutputTsNum=apexUdpMapOutputTsNum, apexDepiControlConfigSrcIpAddr=apexDepiControlConfigSrcIpAddr, apexPidMapTable=apexPidMapTable, apexRtspSessionStatOutputProgramNum=apexRtspSessionStatOutputProgramNum, apexPsipStatusInputBody=apexPsipStatusInputBody, apexManualRouteOutputTsNum=apexManualRouteOutputTsNum, apexRdsSourceLookupIndex=apexRdsSourceLookupIndex, apexPsStatusVersionsModel=apexPsStatusVersionsModel, apexAlarmRemCommFault=apexAlarmRemCommFault, apexGbeConfigInputDataTsApplyText=apexGbeConfigInputDataTsApplyText, apexGbeConfigFrameBufferTable=apexGbeConfigFrameBufferTable, apexPsStatusEntry=apexPsStatusEntry, apexQamRfPortStatCommError=apexQamRfPortStatCommError, apexRdsCommStatus=apexRdsCommStatus, apexEasOutputEntry=apexEasOutputEntry, trapEmUserLoginFailed=trapEmUserLoginFailed, apexRtspConfQamChannelGroupName=apexRtspConfQamChannelGroupName, apexEncryption=apexEncryption, apexDtaRfPortConfigNetPidUdpPort=apexDtaRfPortConfigNetPidUdpPort, apexGlueCpldVersion=apexGlueCpldVersion, apexDtaGeneralConfigCatEmmPidInterface=apexDtaGeneralConfigCatEmmPidInterface, apexEventLossOfInputAncillaryPid=apexEventLossOfInputAncillaryPid, apexFastEnetRoutingApplyChange=apexFastEnetRoutingApplyChange, apexDepiSessionStatusOutputQAMChannel=apexDepiSessionStatusOutputQAMChannel, apexDtaConfigApplyChange=apexDtaConfigApplyChange, apexHwEventAlarmSeverity=apexHwEventAlarmSeverity)
mibBuilder.exportSymbols("APEX-MIB", trapLossOfInputAncillaryPidEvent=trapLossOfInputAncillaryPidEvent, apexOutputProgramCurrentCSN=apexOutputProgramCurrentCSN, apexQamRfConfigTuningMode=apexQamRfConfigTuningMode, apexQamRfRedundConfigSuspendFailover=apexQamRfRedundConfigSuspendFailover, apexOutputTsEventEntry=apexOutputTsEventEntry, apexSysConfigMcEmmInsertion=apexSysConfigMcEmmInsertion, apexGbeFrameBufferResetLevelLimit=apexGbeFrameBufferResetLevelLimit, apexOutputProgramCAS4EcmgStream=apexOutputProgramCAS4EcmgStream, apexRtspConfMhaSbeEncryptionMode=apexRtspConfMhaSbeEncryptionMode, apexPidMapInputSourceIp=apexPidMapInputSourceIp, apexManRteGbeInRedStatusMapIndex=apexManRteGbeInRedStatusMapIndex, apexChassisRedundancyForceFailOver=apexChassisRedundancyForceFailOver, apexTemperature=apexTemperature, apexGbeFrameBufferProcessorNum=apexGbeFrameBufferProcessorNum, apexAcpStatusIndex=apexAcpStatusIndex, apexGbeSfpStatusVendorId=apexGbeSfpStatusVendorId, apexQamRfPortStatTemperature=apexQamRfPortStatTemperature, apexBulkPidMapOutputPid=apexBulkPidMapOutputPid, apexRdsEventTierData=apexRdsEventTierData, apexAcpHealthByte=apexAcpHealthByte, apexRtspStatQamChannelName=apexRtspStatQamChannelName, apexSntpUtcOffset=apexSntpUtcOffset, apexGbeRoutedPacketUpdateInterval=apexGbeRoutedPacketUpdateInterval, apexPidMapConfigApplyChange=apexPidMapConfigApplyChange, apexRdsConfigApplyChange=apexRdsConfigApplyChange, trapChassisRedundancyAvailabilityFault=trapChassisRedundancyAvailabilityFault, apexManRteGbeInRedPriInterface=apexManRteGbeInRedPriInterface, apexRpcDeviceType=apexRpcDeviceType, apexEcmEmmNumberPids=apexEcmEmmNumberPids, apexChassisRedundancyPrimaryApexStatus=apexChassisRedundancyPrimaryApexStatus, apexOutputTsUtilizationMonitoring=apexOutputTsUtilizationMonitoring, apexRtspConfQamChannelEntry=apexRtspConfQamChannelEntry, apexMainBoardTemperatureFault=apexMainBoardTemperatureFault, apexOutputProgramCAS4EcmgChannel=apexOutputProgramCAS4EcmgChannel, apexFastEnetInsertPacketsEntry=apexFastEnetInsertPacketsEntry, apexEncryptionMux1RolloverCount=apexEncryptionMux1RolloverCount, apexRds=apexRds, trapConfigurationChangeInteger=trapConfigurationChangeInteger, apexGlueFpgaVersion=apexGlueFpgaVersion, apexGbeConfInRedundForceToPrimary=apexGbeConfInRedundForceToPrimary, apexQrmFileRevFileSetNum=apexQrmFileRevFileSetNum, apexRdsErrorCountReset=apexRdsErrorCountReset, apexDepiSessionStatusInvalidVendorId=apexDepiSessionStatusInvalidVendorId, apexClearInvalidInitData=apexClearInvalidInitData, apexAlarmTemperatureFault=apexAlarmTemperatureFault, apexRtspConfMhaGeneral=apexRtspConfMhaGeneral, apexManRteGbeInRedForceSwitchIndex=apexManRteGbeInRedForceSwitchIndex, apexQamModuleStat3dot3VdcFault=apexQamModuleStat3dot3VdcFault, apexGbeConfIfRedundApplyIndex=apexGbeConfIfRedundApplyIndex, apexRtspConfGbeEdgeGroupNum=apexRtspConfGbeEdgeGroupNum, apexPidMapInputType=apexPidMapInputType, apexQamConfigApplyChange=apexQamConfigApplyChange, apexBulkPidMapStatusGeneral=apexBulkPidMapStatusGeneral, apexMpc2FpgaVersion=apexMpc2FpgaVersion, apexGbeStatusFrameCounterTableResetAll=apexGbeStatusFrameCounterTableResetAll, apexQrmDownloadStatusRfPortNum=apexQrmDownloadStatusRfPortNum, apexQamRfPortChannelInfoRfPortNum=apexQamRfPortChannelInfoRfPortNum, apexAsiMonitorPortConfig=apexAsiMonitorPortConfig, apexMuxFpgaEncryption=apexMuxFpgaEncryption, apexQamChanStatChannelNum=apexQamChanStatChannelNum, apexRdsEventRatingText=apexRdsEventRatingText, apexPsipStatusServiceOutputTs=apexPsipStatusServiceOutputTs, apexSaveConfig=apexSaveConfig, apexQamChanConfigTestMode=apexQamChanConfigTestMode, apexQamStatusGeneral=apexQamStatusGeneral, apexDepiControlStatusLocalUdp=apexDepiControlStatusLocalUdp, trapDepiControlConnectionFault=trapDepiControlConnectionFault, apexOutputTsConfigTable=apexOutputTsConfigTable, apexPsipStatusOutputIndex=apexPsipStatusOutputIndex, apexRpcSessionStatSessionIdWord3=apexRpcSessionStatSessionIdWord3, apexManualRouteSourceId=apexManualRouteSourceId, apexQamRfRedundConfigApexId=apexQamRfRedundConfigApexId, apexGbeDefaultGateway2=apexGbeDefaultGateway2, apexQamModuleStatError=apexQamModuleStatError, trapGbeLossOfInputStream=trapGbeLossOfInputStream, apexRdsRmdNextPollTime=apexRdsRmdNextPollTime, apexPsStatusVersionsSerialNumber=apexPsStatusVersionsSerialNumber, apexQamRfConfigInterleaverDepth2=apexQamRfConfigInterleaverDepth2, apexBulkPidMapOutputTsNum01to32=apexBulkPidMapOutputTsNum01to32, apexQrmDownloadConfigTable=apexQrmDownloadConfigTable, apexPsiStatusPart=apexPsiStatusPart, apexDataIpConfigGeneral=apexDataIpConfigGeneral, apexEnableChassisRedundancySecondaryFailover=apexEnableChassisRedundancySecondaryFailover, apexGbeStatusTotRoutedPackets=apexGbeStatusTotRoutedPackets, apexPidMapInputUdp=apexPidMapInputUdp, apexEncryptionMux2RolloverCount=apexEncryptionMux2RolloverCount, apexOutputTsUtilizOverflow=apexOutputTsUtilizOverflow, apexGbeStatusGeneral=apexGbeStatusGeneral, apexChassisRedundancyConfigEnable=apexChassisRedundancyConfigEnable, apexQrmDownloadStatus=apexQrmDownloadStatus, apexGbeTxErrorFrames=apexGbeTxErrorFrames, apexDepiConfig=apexDepiConfig, apexQamModuleStatFaultCondition=apexQamModuleStatFaultCondition, apexGbeStatInTsPriLowBitRateError=apexGbeStatInTsPriLowBitRateError, apexGbeStatusInputTsTable=apexGbeStatusInputTsTable, apexGbeStatInTsSecMinStreamCount=apexGbeStatInTsSecMinStreamCount, apexOutputTsUtilizationGeneral=apexOutputTsUtilizationGeneral, apexEasConfigGeneral=apexEasConfigGeneral, apexPidMapInputMulticastIp=apexPidMapInputMulticastIp, apexQamChanStatRfFreq=apexQamChanStatRfFreq, apexRdsProgramMessagesFailed=apexRdsProgramMessagesFailed, apexOutputProgramOutputTsNum=apexOutputProgramOutputTsNum, apexPsiDetectionTimeout=apexPsiDetectionTimeout, apexGbeTotalTxGoodFrames=apexGbeTotalTxGoodFrames, apexDepiSessionConfigControlId=apexDepiSessionConfigControlId, apexDepi=apexDepi, apexGbeConfigFrameBufferMaxInDataRate=apexGbeConfigFrameBufferMaxInDataRate, apexInputTsStatIndex=apexInputTsStatIndex, apexOutputAncillaryPidInputPid=apexOutputAncillaryPidInputPid, apexHwEventIndex=apexHwEventIndex, apexQamConfigApplyEntry=apexQamConfigApplyEntry, apexDtaGeneralConfigCatEmmPidSourceIP=apexDtaGeneralConfigCatEmmPidSourceIP, apexDepiSessionConfigUdpPort=apexDepiSessionConfigUdpPort, apexChassisRedundancyMCSimEntitlementStatus=apexChassisRedundancyMCSimEntitlementStatus, apexEncryptionCwgPerSecond=apexEncryptionCwgPerSecond, apexUdpMapApplyChange=apexUdpMapApplyChange, apexDepiControlStatusTotalSessions=apexDepiControlStatusTotalSessions, apexOampInputTsAssignedCount=apexOampInputTsAssignedCount, apexDepiControlStatusRejectedSessions=apexDepiControlStatusRejectedSessions, apexDepiSessionConfigTable=apexDepiSessionConfigTable, apexUlsConfigGenerateRequest=apexUlsConfigGenerateRequest, apexManRtePassThroughOutputTsNum=apexManRtePassThroughOutputTsNum, apexSesContConfRedundType=apexSesContConfRedundType, apexDtaOtsConfigEnable=apexDtaOtsConfigEnable, apexAlarmQamRfPortFault=apexAlarmQamRfPortFault, apexOutputTsUtilMonResetTotDropPacket=apexOutputTsUtilMonResetTotDropPacket, apexSessionControlStatusGeneral=apexSessionControlStatusGeneral, trapQamRfRedundMismatch=trapQamRfRedundMismatch, apexRtspStatus=apexRtspStatus, apexSimulcryptEmEnable=apexSimulcryptEmEnable, apexChassisRedundancyFailOverEnet2LinkLoss=apexChassisRedundancyFailOverEnet2LinkLoss, apexOutputTsUtilization=apexOutputTsUtilization, apexAlarmChassisRedundancyPrimaryFailover=apexAlarmChassisRedundancyPrimaryFailover, apexChassisRedundancyFailOverEnet1LinkLoss=apexChassisRedundancyFailOverEnet1LinkLoss, apexDepiSessionConfigSyncCorrection=apexDepiSessionConfigSyncCorrection, apexGbeConfigInputDataTsApplyEntry=apexGbeConfigInputDataTsApplyEntry, apexUdpMapMulticastApplyChange=apexUdpMapMulticastApplyChange, apexQamRfConfigInterleaverDepth1=apexQamRfConfigInterleaverDepth1, apexOutputTsEventPeakRate=apexOutputTsEventPeakRate, apexGbeInputTsAssignedTable=apexGbeInputTsAssignedTable, apexAlarmRtspControllerCommFault=apexAlarmRtspControllerCommFault, apexRdsCetPollInterval=apexRdsCetPollInterval, apexEasServerTable=apexEasServerTable, apexGbeConfigFrameBufferEntry=apexGbeConfigFrameBufferEntry, apexDepiSessionConfigOutputTsNum=apexDepiSessionConfigOutputTsNum, apexQamRfRedundStatusMismatch=apexQamRfRedundStatusMismatch, apexRtspConfMhaUdpMapEnable=apexRtspConfMhaUdpMapEnable, apexChassisRedundancyUdpPort=apexChassisRedundancyUdpPort, apexQamRfConfigSpectrumInvert=apexQamRfConfigSpectrumInvert, apexPreencryptionConfig=apexPreencryptionConfig, apexOutputTsEventOutputTsNum=apexOutputTsEventOutputTsNum, apexQamChannelConfigApplyTable=apexQamChannelConfigApplyTable, apexSesContConfOutputTsNum=apexSesContConfOutputTsNum, apexPidMapConfigGeneral=apexPidMapConfigGeneral, apexEnableRdsCommAlarmFault=apexEnableRdsCommAlarmFault, apexQrmDownloadConfigQrmNum=apexQrmDownloadConfigQrmNum, apexRpcStatus=apexRpcStatus, apexPsStatusVersionsPsNum=apexPsStatusVersionsPsNum, apexEasApplyChange=apexEasApplyChange, apexOutputTsEventCurRate=apexOutputTsEventCurRate, apexManRteGbeInRedStatusMapInputTsStatRow=apexManRteGbeInRedStatusMapInputTsStatRow, apexQamChanStatDataPresent=apexQamChanStatDataPresent, apexGbeConfigInputRedundancyGeneral=apexGbeConfigInputRedundancyGeneral, apexRtspQamStatTable=apexRtspQamStatTable, apexFastEnetStatusPacketsTable=apexFastEnetStatusPacketsTable, apexEasPhysInPort=apexEasPhysInPort, apexRpcSessionStatTable=apexRpcSessionStatTable, apexTime=apexTime, apexEncryptionConfigGeneral=apexEncryptionConfigGeneral, apexDepiSessionConfigEntry=apexDepiSessionConfigEntry, apexQrmFileRevFpga=apexQrmFileRevFpga, apexHwEventTimeLogged=apexHwEventTimeLogged, apexMappingErrorSecInputInterface=apexMappingErrorSecInputInterface, apexRtspConfMhaSbeCitSetting=apexRtspConfMhaSbeCitSetting, apexManRteGbeInRedRateCompareType=apexManRteGbeInRedRateCompareType, apexUls=apexUls, apexPsipStatusInputTable=apexPsipStatusInputTable, apexQamQrmRevStatBootLoaderFw=apexQamQrmRevStatBootLoaderFw, apexPsipConfigTimeDsDayIn=apexPsipConfigTimeDsDayIn, apexGbeFrameBufferUnderflowLevel=apexGbeFrameBufferUnderflowLevel, PYSNMP_MODULE_ID=apex, apexDtaRfPortConfigIndex=apexDtaRfPortConfigIndex, apexRtspEventIndex=apexRtspEventIndex, apexOutputTsStatusDepiSessionsMapped=apexOutputTsStatusDepiSessionsMapped, apexFastEnetConfigGeneral=apexFastEnetConfigGeneral, apexMappingErrorTable=apexMappingErrorTable, apexQamRfPortStatRfPortNum=apexQamRfPortStatRfPortNum, apexOutputTsEventAlarmCode=apexOutputTsEventAlarmCode, apexFastEnetRoutingSubnetMask=apexFastEnetRoutingSubnetMask, apexAlarmGbeLossOfInputStream=apexAlarmGbeLossOfInputStream, apexRtspSessionStatInputTsIndex=apexRtspSessionStatInputTsIndex, apexOutputProgramCAS6EcmgChannel=apexOutputProgramCAS6EcmgChannel, apexGbeStatInTsSamplingPeriod=apexGbeStatInTsSamplingPeriod, apexTemperatureStatusGeneral=apexTemperatureStatusGeneral, apexSupportPreencryptedSimulcrypt=apexSupportPreencryptedSimulcrypt, apexQamRfPortStatCodeInitError=apexQamRfPortStatCodeInitError, apexQamQrmRevisionEntry=apexQamQrmRevisionEntry, apexGbeSfpStatusDiagInfo=apexGbeSfpStatusDiagInfo, trapPowerFault=trapPowerFault, apexRpcConfigGeneral=apexRpcConfigGeneral, apexQamQrmRevRfPortNum=apexQamQrmRevRfPortNum, apexOutputTsUtilizCurPercent=apexOutputTsUtilizCurPercent, apexMappingErrorMappingType=apexMappingErrorMappingType, apexAcpUnitAddress=apexAcpUnitAddress, apexRdsSourceLookupEntry=apexRdsSourceLookupEntry, apexInvalidInitDataTimeLogged=apexInvalidInitDataTimeLogged, apexRtspStatQamChannelEntry=apexRtspStatQamChannelEntry, apexGbeSfpStatusGeneral=apexGbeSfpStatusGeneral, apexAlarmOutputOverflow=apexAlarmOutputOverflow, apexUlsConfigMcSimFeatures=apexUlsConfigMcSimFeatures, apexRdsEventRatingData=apexRdsEventRatingData, apexQam=apexQam, trapChassisRedundancySecondaryForceFailover=trapChassisRedundancySecondaryForceFailover, apexPsiStatusSegment=apexPsiStatusSegment, apexOutputTsUtilizationMonitorGeneral=apexOutputTsUtilizationMonitorGeneral, apexDepiStatusGeneralDtiPort1CableAdvanceValue=apexDepiStatusGeneralDtiPort1CableAdvanceValue, apexPsiStatusMessageType=apexPsiStatusMessageType, apexGbeConfigInputDataTsApplyIndex=apexGbeConfigInputDataTsApplyIndex, apexRdsEventProgramCost=apexRdsEventProgramCost, apexEasServerApplyTable=apexEasServerApplyTable, apexQamQrmRevStatQrmNum=apexQamQrmRevStatQrmNum, apexPreencryptionConfigGeneral=apexPreencryptionConfigGeneral, apexEnableQamRfRedundMismatch=apexEnableQamRfRedundMismatch, apexBulkPidMapApplyEntry=apexBulkPidMapApplyEntry, apexInputTsStatusGeneral=apexInputTsStatusGeneral, apexPsipConfigTimeDsHourOut=apexPsipConfigTimeDsHourOut, apexDataIpStatus=apexDataIpStatus, apexInputTsConfigGeneral=apexInputTsConfigGeneral, trapTemperatureFault=trapTemperatureFault, apexLogs=apexLogs, apexQrmDownloadSupported=apexQrmDownloadSupported, apexGbeStatInTsSecLowBitRateError=apexGbeStatInTsSecLowBitRateError, apexGbeConfigIpAddr=apexGbeConfigIpAddr, apexRdsEmmStatusCsn=apexRdsEmmStatusCsn, apexPsStatusVersionsTable=apexPsStatusVersionsTable, trapConfigurationChangeDisplayString=trapConfigurationChangeDisplayString, apexRtspSessionStatEntry=apexRtspSessionStatEntry, apexPsipStatusInputMessageType=apexPsipStatusInputMessageType, apexQamRfRedundStatusBackupPort=apexQamRfRedundStatusBackupPort, apexSesContConfFollowDtcp=apexSesContConfFollowDtcp, apexAlarmGbeInputStreamLowBitRate=apexAlarmGbeInputStreamLowBitRate, apexManualRouteGbeInputRedundStatus=apexManualRouteGbeInputRedundStatus, apexPidMapConfigBulkPidEnable=apexPidMapConfigBulkPidEnable, apexChassisRedundancyFailOverQamModuleFault=apexChassisRedundancyFailOverQamModuleFault, apexGbeOpenInputUdpPortTable=apexGbeOpenInputUdpPortTable, apexGbeStatusInputTsUpdateInterval=apexGbeStatusInputTsUpdateInterval, apexOutputProgramDtaEncryptionMode=apexOutputProgramDtaEncryptionMode, apexQamChanStatError=apexQamChanStatError, apexManualRouteApplyEntry=apexManualRouteApplyEntry, apexPidMapEnable=apexPidMapEnable, apexGbeRxMpegDocsisFrames=apexGbeRxMpegDocsisFrames, apexInputTsStatInputType=apexInputTsStatInputType, apexOutputTsUtilizationMonitorTable=apexOutputTsUtilizationMonitorTable, apexUdpMapMulticastSourceIp=apexUdpMapMulticastSourceIp)
mibBuilder.exportSymbols("APEX-MIB", apexManRtePassThroughInputUdp=apexManRtePassThroughInputUdp, apexQamRfConfigMute=apexQamRfConfigMute, apexSimulcryptEcmgStatus=apexSimulcryptEcmgStatus, apexQamQrmRevFpga2=apexQamQrmRevFpga2, trapGbeInputStreamPacketDrop=trapGbeInputStreamPacketDrop, apexInputTsStatEntry=apexInputTsStatEntry, apexRpcDataCarouselProgram=apexRpcDataCarouselProgram, apexUdpMapMulticastMcastIp=apexUdpMapMulticastMcastIp, apexFastEnetInsertPacketsTable=apexFastEnetInsertPacketsTable, apexGbeConfigEnable=apexGbeConfigEnable, apexGbeStatInTsPriMinStreamCount=apexGbeStatInTsPriMinStreamCount, apexInputTsStatSecState=apexInputTsStatSecState, apexQamModuleStatFanFault=apexQamModuleStatFanFault, apexDataIpSpeed=apexDataIpSpeed, apexDepiControlStatusHbitSet=apexDepiControlStatusHbitSet, apexGbeStatusInputTsErrorTable=apexGbeStatusInputTsErrorTable, apexQamRfRedundancyStatusGeneral=apexQamRfRedundancyStatusGeneral, apexEasNumInvalRcvMsgs=apexEasNumInvalRcvMsgs, apexPsiStatusTableType=apexPsiStatusTableType, apexUdpMapStatusOutputTsNum=apexUdpMapStatusOutputTsNum, apexEasConfig=apexEasConfig, apexFanModuleInstalledCount=apexFanModuleInstalledCount, apexManRteGbeInRedSecRedundMcJoin=apexManRteGbeInRedSecRedundMcJoin, apexGbeRxSinglecastFrames=apexGbeRxSinglecastFrames, apexOutputTsEventAlarmSeverity=apexOutputTsEventAlarmSeverity, apexQamModuleStatInstalled=apexQamModuleStatInstalled, apexPsipConfigCvctMsgInsertionPeriod=apexPsipConfigCvctMsgInsertionPeriod, apexDtaConfig=apexDtaConfig, apexManualRoutingServiceStatusIndex=apexManualRoutingServiceStatusIndex, apexQrmDownloadStatusEntry=apexQrmDownloadStatusEntry, apexRdsEmmStatusTableSize=apexRdsEmmStatusTableSize, apexUlsStatusGeneral=apexUlsStatusGeneral, apexDtaOtsConfigTable=apexDtaOtsConfigTable, apexAlarmPowerFault=apexAlarmPowerFault, apexPsiCcErrorDetectionEnabled=apexPsiCcErrorDetectionEnabled, apexManualRouteTable=apexManualRouteTable, apexOampMacAddr=apexOampMacAddr, apexBulkPidMapInputInterface=apexBulkPidMapInputInterface, apexRpcSessionStatEntry=apexRpcSessionStatEntry, apexDataIpDuplexMode=apexDataIpDuplexMode, apexOutputProgramCAS7EcmgStream=apexOutputProgramCAS7EcmgStream, apexManualRouteProviderId=apexManualRouteProviderId, apexEnableGbeInputStreamPacketDrop=apexEnableGbeInputStreamPacketDrop, apexAcpConfig=apexAcpConfig, apexQamRfConfigNumChannelsEnabled=apexQamRfConfigNumChannelsEnabled, apexBulkPidMapInputUdp=apexBulkPidMapInputUdp, apexAlarms=apexAlarms, apexOutputTsConfPsipEnable=apexOutputTsConfPsipEnable, apexPsiCcErrorDetectionTimeout=apexPsiCcErrorDetectionTimeout, apexEasLastReceivedMessageServerNum=apexEasLastReceivedMessageServerNum, apexAlarmQamChannelFault=apexAlarmQamChannelFault, apexMainBoardVersion=apexMainBoardVersion, apexQrmDownloadRequired=apexQrmDownloadRequired, apexPsStatus=apexPsStatus, apexGbeStatusRoutedPacketEntry=apexGbeStatusRoutedPacketEntry, apexAlarmChassisRedundancyConfigurationFault=apexAlarmChassisRedundancyConfigurationFault, apexMappingErrorMulticastIp=apexMappingErrorMulticastIp, apexPsiConfig=apexPsiConfig, apexQamRfPortMuteStatusRfPortNum=apexQamRfPortMuteStatusRfPortNum, apexOutputTsEventTotalDropPackets=apexOutputTsEventTotalDropPackets, apexEasRcvUdpPort=apexEasRcvUdpPort, apexChassisRedundancyFailOverQamChannelFault=apexChassisRedundancyFailOverQamChannelFault, apexManRtePassThroughApplyEntry=apexManRtePassThroughApplyEntry, apexUlsStatus=apexUlsStatus, apexOutputProgramEncryptionStatus=apexOutputProgramEncryptionStatus, apexDepiControlStatusGeneralRejectedConnections=apexDepiControlStatusGeneralRejectedConnections, apexGbeStatusTable=apexGbeStatusTable, apexGbeInputTsEventEntry=apexGbeInputTsEventEntry, apexGbeStatusInterfaceRedund=apexGbeStatusInterfaceRedund, apexPsiStatus=apexPsiStatus, apexInputTsStatPriInputMulticastIp=apexInputTsStatPriInputMulticastIp, apexQamRfConfigEiaFrequencyPlan=apexQamRfConfigEiaFrequencyPlan, apexGbeSfpStatus=apexGbeSfpStatus, apexEncryptionEmmMinDeliveryTimeMs=apexEncryptionEmmMinDeliveryTimeMs, apexOutputAncillaryPidOutputPid=apexOutputAncillaryPidOutputPid, apexTimeStatusGeneral=apexTimeStatusGeneral, apexManualRoutingConfigGeneral=apexManualRoutingConfigGeneral, apexDepiSessionStatusIndex=apexDepiSessionStatusIndex, apexOutputTsUtilizTotalDropPackets=apexOutputTsUtilizTotalDropPackets, apexUdpMapConfigGeneral=apexUdpMapConfigGeneral, apexGbeStatusInputTsDropCounterGeneral=apexGbeStatusInputTsDropCounterGeneral, apexBulkPidMapApplyChange=apexBulkPidMapApplyChange, apexChassisRedundancyStatusInvalidApplyText=apexChassisRedundancyStatusInvalidApplyText, apexGbeTotalIpFragmentedPkts=apexGbeTotalIpFragmentedPkts, apexRtspConfQamChannelApplyEntry=apexRtspConfQamChannelApplyEntry, apexGbeStatInTsTotPacketDropCount=apexGbeStatInTsTotPacketDropCount, apexUdpMapMulticastInterface=apexUdpMapMulticastInterface, apexManualRouteInputSourceIp=apexManualRouteInputSourceIp, apexRpcNumShellSessions=apexRpcNumShellSessions, apexRdsProgramEpochDuration=apexRdsProgramEpochDuration, apexProgramBasedPmtOffset=apexProgramBasedPmtOffset, apexRtspConfControllerHoldTime=apexRtspConfControllerHoldTime, apexGbeFrameBufferStats=apexGbeFrameBufferStats, apexGbe=apexGbe, apexOutputAncillaryPidStatusGeneral=apexOutputAncillaryPidStatusGeneral, apexUdpMapApplyOutputTsNum=apexUdpMapApplyOutputTsNum, apexGbeConfigInputDataTsApplyTable=apexGbeConfigInputDataTsApplyTable, apexEncryptionMux2CollisionCount=apexEncryptionMux2CollisionCount, apexUlsStatusMcSimChannelsInUse=apexUlsStatusMcSimChannelsInUse, apexGbeConfIfRedundApplyChange=apexGbeConfIfRedundApplyChange, apexGbeStatusInputTsEntry=apexGbeStatusInputTsEntry, apexInputTsStatSecInputUdp=apexInputTsStatSecInputUdp, apexPsStatusInputPowerStatus=apexPsStatusInputPowerStatus, apexDepiSessionStatusHbitSet=apexDepiSessionStatusHbitSet, apexManRteGbeInRedForceSwitchTable=apexManRteGbeInRedForceSwitchTable, apexFastEnetRoutingTable=apexFastEnetRoutingTable, apexEncryptionMcDiagEntry=apexEncryptionMcDiagEntry, apexManRteGbeInRedSecSourceIp=apexManRteGbeInRedSecSourceIp, apexQamRfPortChannelInfoEntry=apexQamRfPortChannelInfoEntry, apexOampCurrentAutoNegotiateState=apexOampCurrentAutoNegotiateState, apexQamChanConfigChannelNum=apexQamChanConfigChannelNum, apexUdpMapConfig=apexUdpMapConfig, apexChassisRedundancyConfig=apexChassisRedundancyConfig, apexFastEnetInsertRateEntry=apexFastEnetInsertRateEntry, apexUdpMapMulticastEntry=apexUdpMapMulticastEntry, apexOutputTsEventRollingDropPackets=apexOutputTsEventRollingDropPackets, apexPsipStatusOutputMessageType=apexPsipStatusOutputMessageType, apexEncryptionMcDiagDeviceIndex=apexEncryptionMcDiagDeviceIndex, apexManRtePassThroughApplyOutputTsNum=apexManRtePassThroughApplyOutputTsNum, apexGbeTotalRxBroadcastFrames=apexGbeTotalRxBroadcastFrames, apexGbeStatInTsSecLossInputError=apexGbeStatInTsSecLossInputError, apexPidMapIndex=apexPidMapIndex, apexOutputTsConfOutputTsNum=apexOutputTsConfOutputTsNum, apexEasOutputEnable=apexEasOutputEnable, trapInvalidInitData=trapInvalidInitData, apexPidMapConfig=apexPidMapConfig, apexRdsConfigServerUrl=apexRdsConfigServerUrl, apexDtaRfPortConfigTable=apexDtaRfPortConfigTable, apexPsipStatusOutputTable=apexPsipStatusOutputTable, apexQamChannelIdEntry=apexQamChannelIdEntry, apexQamChannelIdChannelNum=apexQamChannelIdChannelNum, apexOutputProgramCAS5EcmgStream=apexOutputProgramCAS5EcmgStream, apexDepiSessionConfigApplyChange=apexDepiSessionConfigApplyChange, apexEnableChassisRedundancyPrimaryFailover=apexEnableChassisRedundancyPrimaryFailover, apexOutputAncillaryPidStatusEntry=apexOutputAncillaryPidStatusEntry, apexQamChanStatActive=apexQamChanStatActive, apexInsertionMode=apexInsertionMode, apexEvents=apexEvents, apexDtaRfPortConfigNetPidMulticastIP=apexDtaRfPortConfigNetPidMulticastIP, apexOutputTsUtilizThresholdAlarm=apexOutputTsUtilizThresholdAlarm, apexManRtePassThroughInvalidApplyText=apexManRtePassThroughInvalidApplyText, apexQamModuleUpgradeSlot=apexQamModuleUpgradeSlot, apexPidMapApplyChange=apexPidMapApplyChange, apexQamRfRedundancyConfigGeneral=apexQamRfRedundancyConfigGeneral, apexManualRouteInputPreEncryptCheck=apexManualRouteInputPreEncryptCheck, apexRdsEventPrkmWkemAvailable=apexRdsEventPrkmWkemAvailable, apexQamRfPortStatChanFaultSumm=apexQamRfPortStatChanFaultSumm, apexEnableRtspControllerCommFault=apexEnableRtspControllerCommFault, apexGbeStatusInterfaceRedundIndex=apexGbeStatusInterfaceRedundIndex, apexQamModuleStat5VdcFault=apexQamModuleStat5VdcFault, apexDepiControlStatusMalformedCtl=apexDepiControlStatusMalformedCtl, apexDataIpInUseReason=apexDataIpInUseReason, apexRdsEventEpochNumber=apexRdsEventEpochNumber, apexQamStatusTransmissionMode=apexQamStatusTransmissionMode, apexEasOutputStreamNum=apexEasOutputStreamNum, apexPsi=apexPsi, apexMappingErrorSourceIp=apexMappingErrorSourceIp, apexQamRfConfigRfCenterFreqChannelA=apexQamRfConfigRfCenterFreqChannelA, apexOutputProgramCAS6EcmgStream=apexOutputProgramCAS6EcmgStream, apexPmtVersionIncrement=apexPmtVersionIncrement, apexRdsConfigRds2Enable=apexRdsConfigRds2Enable, apexRtspSessionStatInputProgramNum=apexRtspSessionStatInputProgramNum, apexMaxServiceMappings=apexMaxServiceMappings, apexManRtePassThroughInputMulticastIp=apexManRtePassThroughInputMulticastIp, apexQamChannelConfigApplyChange=apexQamChannelConfigApplyChange, apexInputTsStatPriInputUdp=apexInputTsStatPriInputUdp, apexRpc=apexRpc, apexDepiSessionStatusGeneral=apexDepiSessionStatusGeneral, apexUdpMapMulticastInvalidApplyText=apexUdpMapMulticastInvalidApplyText, apexOutputTsConfSimulcryptMode=apexOutputTsConfSimulcryptMode, apexOutputProgramCAS3EcmgStream=apexOutputProgramCAS3EcmgStream, apexQamRfPortStatTemperatureFault=apexQamRfPortStatTemperatureFault, apexGbeFrameBufferHourlyTable=apexGbeFrameBufferHourlyTable, apexEasStatus=apexEasStatus, apexDepiControlConfigEntry=apexDepiControlConfigEntry, apexPsiStatusBody=apexPsiStatusBody, apexDtaOtsConfigIndex=apexDtaOtsConfigIndex, trapRemCommFault=trapRemCommFault, apexEnableQamModuleFault=apexEnableQamModuleFault, apexRtspSessionStatIndex=apexRtspSessionStatIndex, apexDebug=apexDebug, apexOutputTsStatusServicesMapped=apexOutputTsStatusServicesMapped, apexSysStatus=apexSysStatus, apexSimulcryptExternalEisSetting=apexSimulcryptExternalEisSetting, apexSesContConfGbePrimaryInterface=apexSesContConfGbePrimaryInterface, apexDtaRfPortConfigNetPidNum=apexDtaRfPortConfigNetPidNum, apexDepiControlConfigApplyTable=apexDepiControlConfigApplyTable, apexRdsSourceLookupProviderId=apexRdsSourceLookupProviderId, apexGbeConfigInputRedundancy=apexGbeConfigInputRedundancy, apexInsertPacketStatOutputTsNum=apexInsertPacketStatOutputTsNum, apexRpcQamStatQamChannelNum=apexRpcQamStatQamChannelNum, apexInputTsStatPriInputInterface=apexInputTsStatPriInputInterface, apexQamRfPortStatusEntry=apexQamRfPortStatusEntry, apexGbeConfLossOfInputTsType=apexGbeConfLossOfInputTsType, apexAlarmGbeLossOfPhysicalInput=apexAlarmGbeLossOfPhysicalInput, apexDtaRfPortConfigNetPidSourceIP=apexDtaRfPortConfigNetPidSourceIP, apexAlarmDepiControlConnectionFault=apexAlarmDepiControlConnectionFault, apexSysStatusGeneral=apexSysStatusGeneral, apexRtspConfQamChannelNum=apexRtspConfQamChannelNum, apexEasOutputTable=apexEasOutputTable, apexQamModuleSerialNumber=apexQamModuleSerialNumber, apexPsipStatusOutputPart=apexPsipStatusOutputPart, apexQamRfRedundConfigRemDirectIpOctet1=apexQamRfRedundConfigRemDirectIpOctet1, apexRpcRfPortServiceGroup=apexRpcRfPortServiceGroup, apexGbeFrameBufferHourlyMaxMsLevel=apexGbeFrameBufferHourlyMaxMsLevel, apexGbeInputTsEventIndex=apexGbeInputTsEventIndex, apexGbeStatInTsSecCurStreamCount=apexGbeStatInTsSecCurStreamCount, apexQamRfPortStatRefClockLock=apexQamRfPortStatRefClockLock, apexAlarmFanFault=apexAlarmFanFault, apexManRteGbeInRedSecHighAlarmBitRate=apexManRteGbeInRedSecHighAlarmBitRate, apexGbeStatInTsPacketDropError=apexGbeStatInTsPacketDropError, apexOutputTsStatusEntry=apexOutputTsStatusEntry, apexQamRfPortStatOutputLevelFault=apexQamRfPortStatOutputLevelFault, apexMcSimConfigApplyChange=apexMcSimConfigApplyChange, apexPsipConfigGeneral=apexPsipConfigGeneral, apexRdsConfig=apexRdsConfig, apexDtaGeneralConfigCatEmmPidMulticastIP=apexDtaGeneralConfigCatEmmPidMulticastIP, apexQamModuleInstalledCount=apexQamModuleInstalledCount, apexEventEasMessageNotReceived=apexEventEasMessageNotReceived, apexDepiSessionStatusMalformedAvp=apexDepiSessionStatusMalformedAvp, apexChassisRedundancyStatus=apexChassisRedundancyStatus, apexGbeConfigEntry=apexGbeConfigEntry, apexDepiControlStatusGeneralInvalidApplyText=apexDepiControlStatusGeneralInvalidApplyText, apexPsipStatusOutputSegment=apexPsipStatusOutputSegment, apexGbeFrameBufferAlarmStatus=apexGbeFrameBufferAlarmStatus, apexOutputProgramEntry=apexOutputProgramEntry, apexEncryptionStatusGeneral=apexEncryptionStatusGeneral, apexDataIpCurrentAutoNegotiateState=apexDataIpCurrentAutoNegotiateState, apexSntpServerIpAddr=apexSntpServerIpAddr, apexQamRfPortStat3dot3VdcSupply=apexQamRfPortStat3dot3VdcSupply, apexRpcControlInterface=apexRpcControlInterface, apexQrmDownloadConfigGeneral=apexQrmDownloadConfigGeneral, apexRtspEventSessionCount=apexRtspEventSessionCount, apexManRteGbeInRedSecLowAlarmBitRate=apexManRteGbeInRedSecLowAlarmBitRate, apexPidMapApplyTable=apexPidMapApplyTable, apexDepiSessionStatusIngressDlmMsgs=apexDepiSessionStatusIngressDlmMsgs, apexOutputProgramEncryptionMode=apexOutputProgramEncryptionMode, apexRdsDeviceId=apexRdsDeviceId, apexMappingErrorUdpPort=apexMappingErrorUdpPort, trapGbeLossOfPhysicalInput=trapGbeLossOfPhysicalInput, trapOutputUtilizationFault=trapOutputUtilizationFault, trapInvalidMessageReceived=trapInvalidMessageReceived, apexGbeStatInTsSecErrorSummary=apexGbeStatInTsSecErrorSummary, apexQamRfPortStatInfoRate=apexQamRfPortStatInfoRate, apexGbeFrameBufferHourlyMaxPercentFull=apexGbeFrameBufferHourlyMaxPercentFull, apexEasPhysInType=apexEasPhysInType, apexOutputProgramNumberTiers=apexOutputProgramNumberTiers, apexRpcRfChannelEntry=apexRpcRfChannelEntry, apexRtspSessionStatManagerIpAddr=apexRtspSessionStatManagerIpAddr, apexSntpServerSpecified=apexSntpServerSpecified, apexConfAlarmClear=apexConfAlarmClear, apexRdsPollRandomization=apexRdsPollRandomization, apexInsertionStatus=apexInsertionStatus, apexEventQamModuleUpgraded=apexEventQamModuleUpgraded)
mibBuilder.exportSymbols("APEX-MIB", apexPidMapApplyEntry=apexPidMapApplyEntry, trapQamRfPortFault=trapQamRfPortFault, apexRtspConfControlNamesEntry=apexRtspConfControlNamesEntry, apexInvalidInitDataEntry=apexInvalidInitDataEntry, apexPsipStatusServiceTable=apexPsipStatusServiceTable, apexRtspConfig=apexRtspConfig, apexRtspConfControllerIp=apexRtspConfControllerIp, apexManRteGbeInRedEntry=apexManRteGbeInRedEntry, apexEnableGbeBufferFullness=apexEnableGbeBufferFullness, apexEventChassisRedunSecondaryForceFailover=apexEventChassisRedunSecondaryForceFailover, trapConditionAlreadyInList=trapConditionAlreadyInList, apexRpcQamStatEntry=apexRpcQamStatEntry, apexChassisRedundancyEventTable=apexChassisRedundancyEventTable, apexQamRfPortStatFaultCondition=apexQamRfPortStatFaultCondition, apexRpcSessionStatSourceIpAddr3=apexRpcSessionStatSourceIpAddr3, apexQamRfPortChannelInfoChanA=apexQamRfPortChannelInfoChanA, apexGbeDefaultGateway1=apexGbeDefaultGateway1, apexManualRouteRmdClear=apexManualRouteRmdClear, apexSysConfig=apexSysConfig, apexInputTsStatRateCompareType=apexInputTsStatRateCompareType, apexEasMessageReceiveTimeoutEventEnable=apexEasMessageReceiveTimeoutEventEnable, apexMainBoardTempHostProcessor=apexMainBoardTempHostProcessor, apexMcSimConfigGeneral=apexMcSimConfigGeneral, apexDataIpConfig=apexDataIpConfig, apexRpcConfig=apexRpcConfig, apexInputTsStatSecInputInterface=apexInputTsStatSecInputInterface, apexManRteGbeInRedPriLowAlarmBitRate=apexManRteGbeInRedPriLowAlarmBitRate, apexGbeFrameBufferHourlyProcessorNum=apexGbeFrameBufferHourlyProcessorNum, apexQrmDownloadStatusGeneral=apexQrmDownloadStatusGeneral, apexQamModuleStat5VdcSupply=apexQamModuleStat5VdcSupply, apexDtaConfigApplyIndex=apexDtaConfigApplyIndex, apexDepiSessionConfigApplyEntry=apexDepiSessionConfigApplyEntry, apexGbeInputTsEventGbeInterface=apexGbeInputTsEventGbeInterface, apexQamRfRedundStatusRemConnection=apexQamRfRedundStatusRemConnection, apexGbeFrameCounterGbeInterfaceNum=apexGbeFrameCounterGbeInterfaceNum, apexGbeStatInTsPriPeakDataCount=apexGbeStatInTsPriPeakDataCount, apexQamRfPortStatError=apexQamRfPortStatError, apexDepiControlConfigGeneralKeepaliveTimeout=apexDepiControlConfigGeneralKeepaliveTimeout, apexUdpMapStatusEntry=apexUdpMapStatusEntry, apexEasServerPhysInType=apexEasServerPhysInType, apexGbeStatusInputTsDropCounterClearAll=apexGbeStatusInputTsDropCounterClearAll, apexDtaGeneralConfig=apexDtaGeneralConfig, apexManRteGbeInRedSecMulticastIp=apexManRteGbeInRedSecMulticastIp, apexRdsStatusServerPort=apexRdsStatusServerPort, apexQamQrmRevBootLoaderFw=apexQamQrmRevBootLoaderFw, apexAlarmGbeMptsRedundPrimaryThreshold=apexAlarmGbeMptsRedundPrimaryThreshold, apexHwEventEntry=apexHwEventEntry, trapRemFault=trapRemFault, apexManRteGbeInRedPriHighAlarmBitRate=apexManRteGbeInRedPriHighAlarmBitRate, apexDepiStatusGeneralDtiClientPhaseError=apexDepiStatusGeneralDtiClientPhaseError, apexRpcQamStatNumVodBcSessions=apexRpcQamStatNumVodBcSessions, apexPsipStatusOutputGpsTime=apexPsipStatusOutputGpsTime, ResetStatisticsTYPE=ResetStatisticsTYPE, apexGbeTotalRxFrames=apexGbeTotalRxFrames, apexDepiSessionStatusInDataPackets=apexDepiSessionStatusInDataPackets, apexInputTsConfig=apexInputTsConfig, apexFastEnetInsPacketsOutputTsNum=apexFastEnetInsPacketsOutputTsNum, apexChassisRedundancySecondaryApexStatus=apexChassisRedundancySecondaryApexStatus, apexDataIpSubnetMask=apexDataIpSubnetMask, apexPsipConfigRrtMsgInsertionPeriod=apexPsipConfigRrtMsgInsertionPeriod, apexOutputTsEventCurDropPackets=apexOutputTsEventCurDropPackets, apexConfigAlarms=apexConfigAlarms, apexPsiStatusGpsTime=apexPsiStatusGpsTime, apexInputTsStatTable=apexInputTsStatTable, apexFastEnetPacketsTotDiscarded=apexFastEnetPacketsTotDiscarded, apexOutputTsStatusFault=apexOutputTsStatusFault, apexRdsConnectionStatus=apexRdsConnectionStatus, apexInputTsStatStreamInUse=apexInputTsStatStreamInUse, apexPsipConfigTimeDsHourIn=apexPsipConfigTimeDsHourIn, apexRtspConfGbeEdgeGroupEntry=apexRtspConfGbeEdgeGroupEntry, apexUlsConfigValidateResponse=apexUlsConfigValidateResponse, apexRpcRfPortEntry=apexRpcRfPortEntry, trapConditionListFull=trapConditionListFull, apexCteCitEnable=apexCteCitEnable, apexEnableDepiSessionSetupFault=apexEnableDepiSessionSetupFault, apexEncryptionEmmBadRepliesRecvd=apexEncryptionEmmBadRepliesRecvd, apexEnableGbeMptsRedundFailOver=apexEnableGbeMptsRedundFailOver, apexRtspQamStatAllocatedBandwidth=apexRtspQamStatAllocatedBandwidth, apexMcEmmInsertionMode=apexMcEmmInsertionMode, apexGbeFrameBufferHourlyInUdp=apexGbeFrameBufferHourlyInUdp, apexOutputProgramStatusGeneral=apexOutputProgramStatusGeneral, apexQamRfConfigEntry=apexQamRfConfigEntry, apexOutputProgramInputPreEncrypted=apexOutputProgramInputPreEncrypted, apexUdpMapApplyEntry=apexUdpMapApplyEntry, apexGbeStatus=apexGbeStatus, apexDtaRfPortConfigEntry=apexDtaRfPortConfigEntry, apexQamQrmRevHw=apexQamQrmRevHw, apexOutputTsConfApplyIndex=apexOutputTsConfApplyIndex, trapQamChannelFault=trapQamChannelFault, apexManualRoutingServiceStatusGeneral=apexManualRoutingServiceStatusGeneral, apexOutputProgramConfigGeneral=apexOutputProgramConfigGeneral, apexGbeStatusLossOfPhysicalInput=apexGbeStatusLossOfPhysicalInput, apexRtspSessionId=apexRtspSessionId, apexTimeConfigGeneral=apexTimeConfigGeneral, apexRtspStatQamMptsModeEntry=apexRtspStatQamMptsModeEntry, apexAsiMonitorPortOutputTsNum=apexAsiMonitorPortOutputTsNum, apexFastEnetPacketsPortNum=apexFastEnetPacketsPortNum, apexGbeConfigAutoNegotiate=apexGbeConfigAutoNegotiate, apexManualRouteInputType=apexManualRouteInputType, apexQamQrmRevBoardId=apexQamQrmRevBoardId, apexOutputTsEventMinRate=apexOutputTsEventMinRate, apexGbeJitterAbsorption=apexGbeJitterAbsorption, apexRdsSetDefault=apexRdsSetDefault, apexQamConfig=apexQamConfig, apexOutputTsConfEncryptionType=apexOutputTsConfEncryptionType, apexAlarmDepiSessionSetupFault=apexAlarmDepiSessionSetupFault, apexQamModuleStatQamModuleNum=apexQamModuleStatQamModuleNum, apexManRtePassThroughInputInterface=apexManRtePassThroughInputInterface, apexGbeConfigTable=apexGbeConfigTable, apexMcSimEnableDacId=apexMcSimEnableDacId, apexMappingErrorEntry=apexMappingErrorEntry, apexPsiRangeStop=apexPsiRangeStop, apexGbeStatInTsPriCurStreamCount=apexGbeStatInTsPriCurStreamCount, apexEasServerMulticastIpAddress=apexEasServerMulticastIpAddress, apexRdsSourceLookupSourceId=apexRdsSourceLookupSourceId, apexAlarmChassisRedundancyAvailabilityFault=apexAlarmChassisRedundancyAvailabilityFault, apexMappingErrorTimeLogged=apexMappingErrorTimeLogged, apexDepiControlStatusInvalidVendorId=apexDepiControlStatusInvalidVendorId, apexUdpMapEntry=apexUdpMapEntry, apexGbeInputDataTsBufferDepth=apexGbeInputDataTsBufferDepth, apexBulkPidMapIndex=apexBulkPidMapIndex, apexChassisRedundancyGigEMismatchStatus=apexChassisRedundancyGigEMismatchStatus, apexInsertionConfigGeneral=apexInsertionConfigGeneral, apexRpcSessionStatSessionIdWord1=apexRpcSessionStatSessionIdWord1, apexInvalidInitDataIndex=apexInvalidInitDataIndex, trapChassisRedundancyConfigurationFault=trapChassisRedundancyConfigurationFault, apexQamQrmRevStatHw=apexQamQrmRevStatHw, apexRdsEmmStatusEntry=apexRdsEmmStatusEntry, apexOutputTsConfigEntry=apexOutputTsConfigEntry, apexMuxFpgaVersion=apexMuxFpgaVersion, apexOutputAncillaryPidAverageBitrate=apexOutputAncillaryPidAverageBitrate, apexGbeConfig=apexGbeConfig, apexPsStatusOutputPowerStatus=apexPsStatusOutputPowerStatus, apexRdsEventCcmAvailable=apexRdsEventCcmAvailable, apexDataIp=apexDataIp, apexRtspSessionStatOutputQamChannel=apexRtspSessionStatOutputQamChannel, apexRdsConfigGeneral=apexRdsConfigGeneral, apexMainBoardTempAcpModule=apexMainBoardTempAcpModule, apexDepiControlConfigInterfaceNumber=apexDepiControlConfigInterfaceNumber, apexDepiControlConfig=apexDepiControlConfig, apexDepiControlStatusRemoteUdp=apexDepiControlStatusRemoteUdp, apexOutputProgramCAS8EcmgChannel=apexOutputProgramCAS8EcmgChannel, apexRtspSessionIdIndex=apexRtspSessionIdIndex, apexInsertionStatusGeneral=apexInsertionStatusGeneral, apexRtspQamStatQamChannelNum=apexRtspQamStatQamChannelNum, apexDepiControlConfigApplyChange=apexDepiControlConfigApplyChange, apexDepiStatus=apexDepiStatus, apexQamRfRedundancyStatus=apexQamRfRedundancyStatus, apexPsStatusCommError=apexPsStatusCommError, apexQrmFileRevisionTable=apexQrmFileRevisionTable, apexRdsRmdRefresh=apexRdsRmdRefresh, apexQamRfConfigSymbolRate=apexQamRfConfigSymbolRate, ClearCountersTYPE=ClearCountersTYPE, apexManRteGbeInRedInvalidApplyText=apexManRteGbeInRedInvalidApplyText, apexChassisRedundancyAppliedEncAlgorithmStatus=apexChassisRedundancyAppliedEncAlgorithmStatus, apexOampSubnetMask=apexOampSubnetMask, apexQamChanStatFaultCondition=apexQamChanStatFaultCondition, apexPidMapStatusGeneral=apexPidMapStatusGeneral, apexFastEnetRoutingEntry=apexFastEnetRoutingEntry, apexGbeStatInTsSecPeakDataCount=apexGbeStatInTsSecPeakDataCount, apexGbeNominalBufferLevel=apexGbeNominalBufferLevel, apexDepiStatusGeneral=apexDepiStatusGeneral, apexManualRouteApplyIndex=apexManualRouteApplyIndex, apexQamRfConfigRfLevelHighThreshold=apexQamRfConfigRfLevelHighThreshold, apexDepiControlStatusGeneralCurrentConnections=apexDepiControlStatusGeneralCurrentConnections, apexQrmFileRevFirmware=apexQrmFileRevFirmware, apexPsiConfigGeneral=apexPsiConfigGeneral, apexQamRfConfigTable=apexQamRfConfigTable, apexManRteGbeInRedStatusGeneral=apexManRteGbeInRedStatusGeneral, apexTraps=apexTraps, apexOutputTsUtilizOverflowAlarm=apexOutputTsUtilizOverflowAlarm, apexDepiStatusGeneralDtiPort2CableAdvanceValue=apexDepiStatusGeneralDtiPort2CableAdvanceValue, apexOutputTransport=apexOutputTransport, apexManualRouteInvalidApplyText=apexManualRouteInvalidApplyText, apexQamRfRedundConfigForceSwitch=apexQamRfRedundConfigForceSwitch, apexMappingErrorOutputProgramPid=apexMappingErrorOutputProgramPid, apexUlsStatusMcSimFeatures=apexUlsStatusMcSimFeatures, apexOutputProgramProviderId=apexOutputProgramProviderId, apexQamChanStatEiaChanNum=apexQamChanStatEiaChanNum, apexQrmDownloadFileSet=apexQrmDownloadFileSet, apexQamRfPortMuteStatusEntry=apexQamRfPortMuteStatusEntry, trapEasMessageNotReceived=trapEasMessageNotReceived, apexRtspConfGbeEdgeGroupTable=apexRtspConfGbeEdgeGroupTable, apexDepiSessionStatusMalformedCtl=apexDepiSessionStatusMalformedCtl, apexManualRouteIndex=apexManualRouteIndex, apexOutputTsConfPidRemappingMode=apexOutputTsConfPidRemappingMode, apexQamRfPortStat5VdcSupply=apexQamRfPortStat5VdcSupply, trapQamModuleRemovalFault=trapQamModuleRemovalFault, apexOutputAncillaryPidStatusTable=apexOutputAncillaryPidStatusTable, apexChassisRedundancyState=apexChassisRedundancyState, apexUlsConfigCommitNewFeatures=apexUlsConfigCommitNewFeatures, apexDataIpMacAddr=apexDataIpMacAddr, apexEasSourceIpAddress=apexEasSourceIpAddress, apexMcEmmInsertionPid1=apexMcEmmInsertionPid1, apexPsConfigGeneral=apexPsConfigGeneral, apexRdsTcpPort=apexRdsTcpPort, apexDataIpInputTsAssignedCount=apexDataIpInputTsAssignedCount, apexGbeSfpStatusEntry=apexGbeSfpStatusEntry, apexManRteGbeInRedEnable=apexManRteGbeInRedEnable, apexGbeOpenInputUdpPortGbeInterfaceNum=apexGbeOpenInputUdpPortGbeInterfaceNum, apexDepiControlConfigTable=apexDepiControlConfigTable, apexDepiControlStatusTable=apexDepiControlStatusTable, apexQamConfigGeneral=apexQamConfigGeneral, apexRpcSessionStatInputTsIndex=apexRpcSessionStatInputTsIndex, apexGbeInputTsEventRateCompareType=apexGbeInputTsEventRateCompareType, apexRdsEventEventIndex=apexRdsEventEventIndex, apexGbeInputTsEventMulticastIp=apexGbeInputTsEventMulticastIp, apexGbeInputTsEventSecCurStreamCount=apexGbeInputTsEventSecCurStreamCount, apexQamChannelIdSlotNum=apexQamChannelIdSlotNum, apexGbeRxMulticastFrames=apexGbeRxMulticastFrames, apexPidMapApplyIndex=apexPidMapApplyIndex, apexQamQrmRevFpga=apexQamQrmRevFpga, apexFastEnetRoutingGatewayIp=apexFastEnetRoutingGatewayIp, apexGbeFrameCounterUpdateInterval=apexGbeFrameCounterUpdateInterval, apexQamModuleStatBoardTemperatureFault=apexQamModuleStatBoardTemperatureFault, apexOampNetworkDuplexMode=apexOampNetworkDuplexMode, trapDtiSyncLossFault=trapDtiSyncLossFault, apexBulkPidMapEntry=apexBulkPidMapEntry, apexOutputTsUtilizOutpuTsNum=apexOutputTsUtilizOutpuTsNum, apexOutputTsUtilizAvgPercent=apexOutputTsUtilizAvgPercent, apexManualRoutingServiceStatusEntry=apexManualRoutingServiceStatusEntry, apexPsiRangeStart=apexPsiRangeStart, apexChassisRedundancyMulticastRedundancyMode=apexChassisRedundancyMulticastRedundancyMode, apexOutputTsConfApplyChange=apexOutputTsConfApplyChange, apexEnableRemCommFault=apexEnableRemCommFault, apexChassisRedundancyEventTimeLogged=apexChassisRedundancyEventTimeLogged, apexManualRouteApplyChange=apexManualRouteApplyChange, apexPsipStatusOutputEntry=apexPsipStatusOutputEntry, apexDepiControlStatus=apexDepiControlStatus, apexQamRfConfigRfPortNum=apexQamRfConfigRfPortNum, apexRtspConfControllerPort=apexRtspConfControllerPort, apexPsipStatusServiceEntry=apexPsipStatusServiceEntry, apexQamModuleStatusEntry=apexQamModuleStatusEntry, apexInsertionConfig=apexInsertionConfig, apexGbeStatusInterfaceRedundTable=apexGbeStatusInterfaceRedundTable, apexRdsEventNumberTiers=apexRdsEventNumberTiers, apexUdpMapModeBits=apexUdpMapModeBits, apexGbeStatusInputTsDropCounter=apexGbeStatusInputTsDropCounter, apexGbeStatInTsSecMinDataCount=apexGbeStatInTsSecMinDataCount, apexOutputTsUtilizPeakPercent=apexOutputTsUtilizPeakPercent, apexGbeFrameBufferHourlyInInterface=apexGbeFrameBufferHourlyInInterface, apexAlarmHardwareFault=apexAlarmHardwareFault, apexEncryptionMux1CollisionCount=apexEncryptionMux1CollisionCount, apexBulkPidMapApplyTable=apexBulkPidMapApplyTable, apexQamRfConfigRfLevelLowThreshold=apexQamRfConfigRfLevelLowThreshold, apexAlarmGbeBufferFullness=apexAlarmGbeBufferFullness, apexUdpMapMulticastUdp=apexUdpMapMulticastUdp, apexAcp=apexAcp, apexRtspStatControllerNum=apexRtspStatControllerNum, apexGbeRxBroadcastFrames=apexGbeRxBroadcastFrames, apexSesContConfRateCompareType=apexSesContConfRateCompareType, apexOutputProgramIndex=apexOutputProgramIndex, apexMcSimDacId=apexMcSimDacId, apexHostProcessorBootCodeVersion=apexHostProcessorBootCodeVersion)
mibBuilder.exportSymbols("APEX-MIB", apexEncryptionConfApplyChange=apexEncryptionConfApplyChange, apexQamChannelIdRfPortNum=apexQamChannelIdRfPortNum, apexManualRouteInputMulticastIp=apexManualRouteInputMulticastIp, apexRtspConfMhaSbeApsLevel=apexRtspConfMhaSbeApsLevel, apexManRteGbeInRedIndex=apexManRteGbeInRedIndex, apexGbeConfigInputDataTsInterface=apexGbeConfigInputDataTsInterface, apexAcpStatusTable=apexAcpStatusTable, apexOutputAncillaryPidBitrateSamplePeriod=apexOutputAncillaryPidBitrateSamplePeriod, apexEncryptionStatus=apexEncryptionStatus, apexPsipConfigMgtMsgInsertionPeriod=apexPsipConfigMgtMsgInsertionPeriod, apexQrmDownloadProgress=apexQrmDownloadProgress, apexPsiStatusProgramNumber=apexPsiStatusProgramNumber, apexRtspSessionStatProgramBandwidth=apexRtspSessionStatProgramBandwidth, apexPsipConfig=apexPsipConfig, apex=apex, apexManRtePassThroughInputType=apexManRtePassThroughInputType, apexPsipStatusInputSegment=apexPsipStatusInputSegment, apexDepiSessionStatusTable=apexDepiSessionStatusTable, apexPsipConfigTimeDsMonthOut=apexPsipConfigTimeDsMonthOut, apexOutputAncillaryPidConfig=apexOutputAncillaryPidConfig, apexQamChannelConfigTable=apexQamChannelConfigTable, apexDepiControlConfigType=apexDepiControlConfigType, trapUnknownMessageReceived=trapUnknownMessageReceived, apexMcEmmInsertionApplyChange=apexMcEmmInsertionApplyChange, apexAlarmGbeInputStreamPacketDrop=apexAlarmGbeInputStreamPacketDrop, trapQamModuleUpgraded=trapQamModuleUpgraded, apexRdsEventRatingRegion=apexRdsEventRatingRegion, apexOutputTsUtilizNumSamples=apexOutputTsUtilizNumSamples, apexQamRfConfigEiaChanNumChannelA=apexQamRfConfigEiaChanNumChannelA, apexSesContStatProtocol=apexSesContStatProtocol, apexDtaGeneralConfigCatSourceType=apexDtaGeneralConfigCatSourceType, apexMainBoardTempMuxFpgaFault=apexMainBoardTempMuxFpgaFault, apexPidMapInputPid=apexPidMapInputPid, apexSysStatusVersions=apexSysStatusVersions, apexPsStatusVersionsEntry=apexPsStatusVersionsEntry, apexInputTransport=apexInputTransport, apexDepiControlStatusIndex=apexDepiControlStatusIndex, apexQamRfPortStat3dot3VdcFault=apexQamRfPortStat3dot3VdcFault, trapCannotOpenSocket=trapCannotOpenSocket, apexGbeFrameBufferHourlyResets=apexGbeFrameBufferHourlyResets, apexQrmDownloadStatusDescription=apexQrmDownloadStatusDescription, EnableDisableTYPE=EnableDisableTYPE, apexOutputTsConfApplyTable=apexOutputTsConfApplyTable, apexQamChannelConfigApplyChannelNum=apexQamChannelConfigApplyChannelNum, apexManRtePassThroughApplyChange=apexManRtePassThroughApplyChange, apexManualRouteInputUdp=apexManualRouteInputUdp, apexGbeStatusInterfaceRedundInvalidApplyText=apexGbeStatusInterfaceRedundInvalidApplyText, apexOutputProgramCAS1EcmgChannel=apexOutputProgramCAS1EcmgChannel, apexUdpMapStatusGeneral=apexUdpMapStatusGeneral, apexManRteGbeInRedPriUdp=apexManRteGbeInRedPriUdp, apexQamRfRedundConfigEnable=apexQamRfRedundConfigEnable, apexGbeStatusFrameCounterGeneral=apexGbeStatusFrameCounterGeneral, apexDepiControlStatusUnknownAvp=apexDepiControlStatusUnknownAvp, apexGbeStatInTsSecAvgDataCount=apexGbeStatInTsSecAvgDataCount, apexRdsStatusGeneral=apexRdsStatusGeneral, apexGbeGarpPeriodicity=apexGbeGarpPeriodicity, apexEnableInvalidInitData=apexEnableInvalidInitData, apexGbeStatusRoutedPacketTable=apexGbeStatusRoutedPacketTable, apexRtspQamStatNumSessions=apexRtspQamStatNumSessions, apexGbeMaxInputTs=apexGbeMaxInputTs, apexOampStatus=apexOampStatus, apexGbeStatusNumRoutedPackets=apexGbeStatusNumRoutedPackets, apexOutputTsEventAvgRate=apexOutputTsEventAvgRate, apexRtspConfQamChannelTable=apexRtspConfQamChannelTable, apexRtspConfControllerApplyNum=apexRtspConfControllerApplyNum, apexOutputTsUtilizationSamplePeriod=apexOutputTsUtilizationSamplePeriod, apexQrmFileRevisionEntry=apexQrmFileRevisionEntry, apexDepiControlConfigGeneral=apexDepiControlConfigGeneral, apexInputTsStatPriState=apexInputTsStatPriState, apexPsiDetectionEnabled=apexPsiDetectionEnabled, apexQrmDownloadStatusTable=apexQrmDownloadStatusTable, apexEasLastReceivedMessageStatusTable=apexEasLastReceivedMessageStatusTable, apexQamChannelStatusTable=apexQamChannelStatusTable, apexHwEventAlarmCode=apexHwEventAlarmCode, trapGbeInputStreamLowBitRate=trapGbeInputStreamLowBitRate, apexPsipStatusOutputSourceId=apexPsipStatusOutputSourceId, apexUdpMapMulticastTable=apexUdpMapMulticastTable, apexRtspEventTable=apexRtspEventTable, trapHardwareFault=trapHardwareFault, apexPsipConfigTime=apexPsipConfigTime, apexMcSimConfig=apexMcSimConfig, apexGbeStatInTsPriAvgDataCount=apexGbeStatInTsPriAvgDataCount, apexCteApplyChange=apexCteApplyChange, apexCteConfig=apexCteConfig, apexManRteGbeInRedThreshold=apexManRteGbeInRedThreshold, apexUdpMapTable=apexUdpMapTable, apexPsipStatusOutputBody=apexPsipStatusOutputBody, apexChassisRedundancyFailOverQamRfPortFault=apexChassisRedundancyFailOverQamRfPortFault, apexQamModuleStatTemperature=apexQamModuleStatTemperature, apexGbeStatInTsMptsRedundPriError=apexGbeStatInTsMptsRedundPriError, apexDepiSessionStatus=apexDepiSessionStatus, apexDepiControlConfigIndex=apexDepiControlConfigIndex, apexGbeInputTsEventAlarmCode=apexGbeInputTsEventAlarmCode, apexOutputTsConfAutoSDTEnable=apexOutputTsConfAutoSDTEnable, apexManualRouteInputInterface=apexManualRouteInputInterface, apexRpcSessionStatSessionType=apexRpcSessionStatSessionType, apexCteCommonTier=apexCteCommonTier, apexGbeConfInRedundAutoSwitchBack=apexGbeConfInRedundAutoSwitchBack, apexFastEnetInsertRateTable=apexFastEnetInsertRateTable, apexChassisRedundancyFailOverGigE12LinkLoss=apexChassisRedundancyFailOverGigE12LinkLoss, apexGbeConfigTableApplyChange=apexGbeConfigTableApplyChange, apexDepiConfigGeneral=apexDepiConfigGeneral, apexGbeFrameBufferCurrMsLevel=apexGbeFrameBufferCurrMsLevel, apexQamRfRedundConfigRemCommonIpAddr=apexQamRfRedundConfigRemCommonIpAddr, apexPsiStatusTable=apexPsiStatusTable, apexGbeStatInTsPriHighBitRateError=apexGbeStatInTsPriHighBitRateError, trapGbeInputStreamHighBitRate=trapGbeInputStreamHighBitRate, apexQamModuleSerialNumTable=apexQamModuleSerialNumTable, apexDepiSessionStatusLatencyStart=apexDepiSessionStatusLatencyStart, apexAlarmGigeToHostCommFault=apexAlarmGigeToHostCommFault, apexPsStatusFaultCondition=apexPsStatusFaultCondition, apexRtspStatusGeneral=apexRtspStatusGeneral, apexRtspReportGbeInterfaces=apexRtspReportGbeInterfaces, trapGbeMptsRedundPrimaryThreshold=trapGbeMptsRedundPrimaryThreshold, apexOutputTsStatusInputStreamsMapped=apexOutputTsStatusInputStreamsMapped, apexGbeStatInTsPriAvgStreamCount=apexGbeStatInTsPriAvgStreamCount, RateComparisonTYPE=RateComparisonTYPE, apexQrmFileRevDateTime=apexQrmFileRevDateTime, apexDataIpLinkActive=apexDataIpLinkActive, apexSesContConfTable=apexSesContConfTable, apexGbeConfigInputDataTsMulticastIp=apexGbeConfigInputDataTsMulticastIp, apexQamChannelsActiveCount=apexQamChannelsActiveCount, apexQamRfRedundStatusInvalidApplyText=apexQamRfRedundStatusInvalidApplyText, apexSesContConfRedundThreshold=apexSesContConfRedundThreshold, apexQamQrmRevStatFpga2=apexQamQrmRevStatFpga2, apexQamRfRedundStatusFailedPort=apexQamRfRedundStatusFailedPort, apexQamStatus=apexQamStatus, apexDepiSessionStatusUnknownCtl=apexDepiSessionStatusUnknownCtl, apexGbeFrameBufferHourlyInSourceIp=apexGbeFrameBufferHourlyInSourceIp, apexPsipConfigEit2InsertionPeriod=apexPsipConfigEit2InsertionPeriod, apexGbeSfp=apexGbeSfp, apexRpcSessionStatIndex=apexRpcSessionStatIndex, apexOutputProgramInputProgNum=apexOutputProgramInputProgNum, apexRdsEventProgramIndex=apexRdsEventProgramIndex, apexPidMapInputAncillaryPidDetectionTimeout=apexPidMapInputAncillaryPidDetectionTimeout, trapQamModuleFault=trapQamModuleFault, apexManRteGbeInRedStatusMapEntry=apexManRteGbeInRedStatusMapEntry, apexHostApplicationDate=apexHostApplicationDate, apexGbeConfigIpSubnetMask=apexGbeConfigIpSubnetMask, apexGbeIpFragmentedPkts=apexGbeIpFragmentedPkts, apexFastEnetStatus=apexFastEnetStatus, apexEnableDtiSyncLossFault=apexEnableDtiSyncLossFault, apexOutputTsUtilizDataFlag=apexOutputTsUtilizDataFlag, apexEasServerRcvUdpPort=apexEasServerRcvUdpPort, apexOutputTsUtilizPeakDropPackets=apexOutputTsUtilizPeakDropPackets)
