#
# PySNMP MIB module CTRON-BRIDGE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/enterasys/CTRON-BRIDGE-MIB
# Produced by pysmi-1.1.3 at Tue Dec  7 17:08:44 2021
# On host fv-az74-115 platform Linux version 5.11.0-1021-azure by user runner
# Using Python version 3.10.0 (default, Oct 18 2021, 13:54:29) [GCC 9.3.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
BridgeId, = mibBuilder.importSymbols("BRIDGE-MIB", "BridgeId")
ctBridge, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctBridge")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, ObjectIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, iso, Bits, ModuleIdentity, Unsigned32, NotificationType, Gauge32, TimeTicks, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "ObjectIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "iso", "Bits", "ModuleIdentity", "Unsigned32", "NotificationType", "Gauge32", "TimeTicks", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ctBridgeStp = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2))
ctBridgeSr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3))
ctBridgeTp = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4))
ctBridgeSdbEnet = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5))
ctBridgeSdbTr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6))
ctBridgeTransTrEnet = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7))
ctBridgeExtendedControl = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 8))
ctBridgeSdbGeneric = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9))
ctBridgeLoadShare = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10))
ctBridgeStpProtocolSpecification = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeStpProtocolSpecification.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeStpProtocolSpecification.setDescription("This object allows the network manager to select\n                 which Spanning Tree Protocol will be operational on\n                 the bridge.  The value 'decLb100(2)' indicates the\n                 DEC LANbridge 100 Spanning Tree protocol. The value\n                 'ieee8021d(3)' indicates the IEEE 802.1d Spanning\n                 Tree Protocol. The value 'none(1)' indicates no\n                 Spanning Tree Protocol is operational.")
ctBridgePvst = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2))
ctPvstStpMode = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dot1qMode", 1), ("pvstMode", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpMode.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpMode.setDescription('Specifies whether the switch is in 802.1D/Q single spanning\n                tree mode, or PVST mode. If the switch is configured with PVST\n                information for some VLANs, setting this object to dot1qMode(1)\n                will cause it to ignore the PVST settings and move all VLANs\n                into the single 802.1Q spanning tree.')
ctPvstMaxNumStp = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstMaxNumStp.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstMaxNumStp.setDescription('Returns maximum number of spanning trees that this device\n                can implement. This will limit the number of VLANs\n                that can be configured with distinct spanning trees.')
ctPvstNumStps = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstNumStps.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstNumStps.setDescription('When read, this returns the number of PVST spanning trees\n                active in the switch, which should correspond to the number\n                of entries in ctPvstStpTable.  When written with 4094, it\n                should create a spanning tree for each currently configured\n                VLAN. If a switch cannot create as many spanning trees as\n                configured VLANs, this write should return an error.\n                Writing any value other than 4094 should return an\n                error.')
ctPvstLastTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstLastTopologyChange.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstLastTopologyChange.setDescription('This summary object contains the value of sysUpTime when\n                any of the rows in ctPvstStpTable last incremented\n                ctPvstStpTopChanges. Poll this object to determine if\n                any of the STP instances had topology changes.')
ctPvstStpTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5), )
if mibBuilder.loadTexts: ctPvstStpTable.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpTable.setDescription('A collection of spanning tree objects per VLAN.')
ctPvstStpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctPvstStpVlanId"))
if mibBuilder.loadTexts: ctPvstStpEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpEntry.setDescription('An entry related to a specific spanning tree.')
ctPvstStpVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpVlanId.setDescription('The VLAN-ID of the VLAN on which this spanning tree is\n                running. Writing a VLAN-ID will create\n                a separate spanning tree for that VLAN, if it previously\n                was part of the single 802.1Q VLAN.')
ctPvstStpProtocolSpecification = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpProtocolSpecification.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpProtocolSpecification.setDescription("An indication of what version of the Spanning\n                Tree Protocol is being run.  The value\n                'decLb100(2)' indicates the DEC LANbridge 100\n                Spanning Tree protocol.  IEEE 802.1d\n                implementations will return 'ieee8021d(3)'.  If\n                future versions of the IEEE Spanning Tree Protocol\n                are released that are incompatible with the\n                current version a new value will be defined.")
ctPvstStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpPriority.setReference('IEEE 802.1D-1990: Section 4.5.3.7')
if mibBuilder.loadTexts: ctPvstStpPriority.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPriority.setDescription('The value of the write-able portion of the Bridge\n                ID, i.e., the first two octets of the (8 octet\n                long) Bridge ID.')
ctPvstStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpTimeSinceTopologyChange.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ctPvstStpTimeSinceTopologyChange.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the\n                last time a topology change was detected by the\n                bridge entity.')
ctPvstStpTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpTopChanges.setReference('IEEE 802.1D-1990: Section 6.8.1.1.3')
if mibBuilder.loadTexts: ctPvstStpTopChanges.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpTopChanges.setDescription('The total number of topology changes detected by\n                this bridge since the management entity was last\n                reset or initialized.')
ctPvstStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpDesignatedRoot.setReference('IEEE 802.1D-1990: Section 4.5.3.1')
if mibBuilder.loadTexts: ctPvstStpDesignatedRoot.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning\n                tree as determined by the Spanning Tree Protocol\n                as executed by this node.  This value is used as\n                the Root Identifier parameter in all Configuration\n                Bridge PDUs originated by this node.')
ctPvstStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpRootCost.setReference('IEEE 802.1D-1990: Section 4.5.3.2')
if mibBuilder.loadTexts: ctPvstStpRootCost.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpRootCost.setDescription('The cost of the path to the root as seen from\n                this bridge.')
ctPvstStpRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpRootPort.setReference('IEEE 802.1D-1990: Section 4.5.3.3')
if mibBuilder.loadTexts: ctPvstStpRootPort.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpRootPort.setDescription('The port number of the port which offers the\n                lowest cost path from this bridge to the root\n                bridge.')
ctPvstStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.4')
if mibBuilder.loadTexts: ctPvstStpMaxAge.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol\n                information learned from the network on any port\n                before it is discarded, in units of hundredths of\n                a second.  This is the actual value that this\n                bridge is currently using.')
ctPvstStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.5')
if mibBuilder.loadTexts: ctPvstStpHelloTime.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpHelloTime.setDescription('The amount of time between the transmission of\n                Configuration bridge PDUs by this node on any port\n                when it is the root of the spanning tree or trying\n                to become so, in units of hundredths of a second.\n                This is the actual value that this bridge is\n                currently using.')
ctPvstStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpHoldTime.setReference('IEEE 802.1D-1990: Section 4.5.3.14')
if mibBuilder.loadTexts: ctPvstStpHoldTime.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpHoldTime.setDescription('This time value determines the interval length\n                during which no more than two Configuration bridge\n                PDUs shall be transmitted by this node, in units\n                of hundredths of a second.')
ctPvstStpForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.6')
if mibBuilder.loadTexts: ctPvstStpForwardDelay.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpForwardDelay.setDescription('This time value, measured in units of hundredths\n                of a second, controls how fast a port changes its\n                spanning state when moving towards the Forwarding\n                state.  The value determines how long the port\n                stays in each of the Listening and Learning\n                states, which precede the Forwarding state.  This\n                value is also used, when a topology change has\n                been detected and is underway, to age all dynamic\n                entries in the Forwarding Database.  [Note that\n                this value is the one that this bridge is\n                currently using, in contrast to\n                ctPvstStpBridgeForwardDelay which is the value that\n                this bridge and all others would start using\n                if/when this bridge were to become the root.]')
ctPvstStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpBridgeMaxAge.setReference('IEEE 802.1D-1990: Section 4.5.3.8')
if mibBuilder.loadTexts: ctPvstStpBridgeMaxAge.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpBridgeMaxAge.setDescription('The value that all bridges use for MaxAge when\n                this bridge is acting as the root.  Note that\n                802.1D-1990 specifies that the range for this\n                parameter is related to the value of\n                ctPvstStpBridgeHelloTime. The granularity of this\n                timer is specified by 802.1D-1990 to be 1 second.\n                An agent may return a badValue error if a set is\n                attempted to a value which is not a whole number\n                of seconds.')
ctPvstStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpBridgeHelloTime.setReference('IEEE 802.1D-1990: Section 4.5.3.9')
if mibBuilder.loadTexts: ctPvstStpBridgeHelloTime.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpBridgeHelloTime.setDescription('The value that all bridges use for HelloTime when\n                this bridge is acting as the root.  The\n                granularity of this timer is specified by 802.1D-\n                1990 to be 1 second.  An agent may return a\n                badValue error if a set is attempted to a value\n                which is not a whole number of seconds.')
ctPvstStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpBridgeForwardDelay.setReference('IEEE 802.1D-1990: Section 4.5.3.10')
if mibBuilder.loadTexts: ctPvstStpBridgeForwardDelay.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpBridgeForwardDelay.setDescription('The value that all bridges use for ForwardDelay\n                when this bridge is acting as the root.  Note that\n                802.1D-1990 specifies that the range for this\n                parameter is related to the value of\n                ctPvstStpBridgeMaxAge.  The granularity of this\n                timer is specified by 802.1D-1990 to be 1 second.\n                An agent may return a badValue error if a set is\n                attempted to a value which is not a whole number\n                of seconds.')
ctPvstStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6), )
if mibBuilder.loadTexts: ctPvstStpPortTable.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortTable.setDescription('A collection of per-port spanning tree objects per VLAN.')
ctPvstStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctPvstStpVlanId"), (0, "CTRON-BRIDGE-MIB", "ctPvstStpPort"))
if mibBuilder.loadTexts: ctPvstStpPortEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortEntry.setDescription('A port entry related to a specific spanning tree. Only\n                ports which are in a VLAN which is running a PVST should\n                be reported for that VLAN.')
ctPvstStpPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortVlanId.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortVlanId.setDescription('The VLAN-ID of the VLAN on which this spanning tree is\n                running.')
ctPvstStpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPort.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPort.setDescription('The port number of the port for which this entry\n                contains Spanning Tree Protocol management information.')
ctPvstStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpPortPriority.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortPriority.setDescription('The value of the priority field which is\n                contained in the first (in network byte order)\n                octet of the (2 octet long) Port ID.  The other\n                octet of the Port ID is given by the value of\n                ctPvstStpPort.')
ctPvstStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortState.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortState.setDescription("The port's current state as defined by\n                application of the Spanning Tree Protocol.  This\n                state controls what action a port takes on\n                reception of a frame.  If the bridge has detected\n                a port that is malfunctioning it will place that\n                port into the broken(6) state.  For ports which\n                are disabled (see ctPvstStpPortEnable), this object\n                will have a value of disabled(1).")
ctPvstStpPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpPortEnable.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortEnable.setDescription('The enabled/disabled status of the port.')
ctPvstStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctPvstStpPortPathCost.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortPathCost.setDescription('The contribution of this port to the path cost of\n                paths towards the spanning tree root which include\n                this port.  802.1D-1990 recommends that the\n                default value of this parameter be in inverse\n                proportion to the speed of the attached LAN.')
ctPvstStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 7), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortDesignatedRoot.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge\n                recorded as the Root in the Configuration BPDUs\n                transmitted by the Designated Bridge for the\n                segment to which the port is attached.')
ctPvstStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortDesignatedCost.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the\n                segment connected to this port.  This value is\n                compared to the Root Path Cost field in received\n                bridge PDUs.')
ctPvstStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortDesignatedBridge.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this\n                port considers to be the Designated Bridge for\n                this port's segment.")
ctPvstStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortDesignatedPort.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated\n                Bridge for this port's segment.")
ctPvstStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 2, 2, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctPvstStpPortForwardTransitions.setStatus('deprecated')
if mibBuilder.loadTexts: ctPvstStpPortForwardTransitions.setDescription('The number of times this port has transitioned\n                from the Learning state to the Forwarding state.')
ctBridgeSrPortPairTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1), )
if mibBuilder.loadTexts: ctBridgeSrPortPairTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairTable.setDescription('A table containing information of source and\n              destination port pairs for source routing.')
ctBridgeSrPortPairEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSrPortPairSrcPort"), (0, "CTRON-BRIDGE-MIB", "ctBridgeSrPortPairDestPort"))
if mibBuilder.loadTexts: ctBridgeSrPortPairEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairEntry.setDescription('An entry consisting of objects specifying information\n              for the source and destination port pairs used for source \n              routing.')
ctBridgeSrPortPairSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSrPortPairSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairSrcPort.setDescription('The source port (ie the port which received the packets)\n              for which this entry has source routing information.')
ctBridgeSrPortPairDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSrPortPairDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairDestPort.setDescription('The destination port (ie the port which transmitted the\n              packets) for which this entry has source routing information.')
ctBridgeSrPortPairPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSrPortPairPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairPackets.setDescription('The number of packets forward by the source route bridge\n              from the SrcPort to the DestPort.')
ctBridgeSrPortPairState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSrPortPairState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrPortPairState.setDescription('The state of source route bridging on this port pair.  \n              This is the desired state of the administrator.  The\n              operational state of the port pair is determined by this \n              state along with the states of dot1dStpPortState within \n              the IETF Bridge MIB and ifOperStatus of the IETF MIB II\n              for each port.')
ctBridgeSrConfigPortType = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transparentonly", 1), ("sourcerouteonly", 2), ("srt", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSrConfigPortType.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSrConfigPortType.setDescription('This object selects the type of Bridging performed on a\n              given bridge port. It is used by the bridge to determine\n              if conversion from a Source Routing packet to a Transparent\n              packet or vice verse is required.')
ctBridgeTpPortPairTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1), )
if mibBuilder.loadTexts: ctBridgeTpPortPairTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairTable.setDescription('A table containing information of source and\n              destination port pairs for transparent MAC briding.')
ctBridgeTpPortPairEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeTpPortPairSrcPort"), (0, "CTRON-BRIDGE-MIB", "ctBridgeTpPortPairDestPort"))
if mibBuilder.loadTexts: ctBridgeTpPortPairEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairEntry.setDescription('An entry consisting of objects specifying information \n              for the source and destination port pairs used for \n              transparent bridging.')
ctBridgeTpPortPairSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeTpPortPairSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairSrcPort.setDescription('The source port (ie the port which received the packets)\n              for which this entry has transparent bridge information.')
ctBridgeTpPortPairDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeTpPortPairDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairDestPort.setDescription('The destination port (ie the port which the packets\n              were transmitted out) for which this entry has \n              transparent bridge information.')
ctBridgeTpPortPairPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeTpPortPairPackets.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairPackets.setDescription('The number of packets transparently forwarded by the bridge\n              from the SrcPort to the DestPort.')
ctBridgeTpPortPairState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTpPortPairState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTpPortPairState.setDescription('The state of transparent bridging on this port pair.\n              This is the desired state of the administrator.  The\n              operational state of the port pair is determined by this\n              state along with the states of dot1dStpPortState within\n              the IETF Bridge MIB and ifOperStatus of the IETF MIB II\n              for each port.')
ctBridgeSdbEnetTotFtrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbEnetTotFtrs.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetTotFtrs.setDescription('The total number of Ethernet filters in the special\n              database.')
ctBridgeSdbEnetNoMatch = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("forward", 2), ("searchFDB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetNoMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetNoMatch.setDescription('The process to be performed if no match is found\n              in the Ethernet special database.  The process of \n              filtering or forwarding is for all ports.  searchFDB\n              results in searching the IEEE 802.1D transparent filter\n              database referenced by the IETF Bridge MIB. ')
ctBridgeSdbEnetTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3), )
if mibBuilder.loadTexts: ctBridgeSdbEnetTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetTable.setDescription('A table containing filtering information configured into\n              the bridge by (local or network) management specifying\n              the specific packet string (destination address, source \n              address, type/length field as well as a window of 64 bytes \n              of packet data beginning at a data offset) to be used \n              for filtering decisions.  The filters are to be searched in\n              the order of incrementing filter number.')
ctBridgeSdbEnetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbEnetFtrNo"))
if mibBuilder.loadTexts: ctBridgeSdbEnetEntry.setReference(' IETF RFC:1286 ')
if mibBuilder.loadTexts: ctBridgeSdbEnetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetEntry.setDescription('Filtering information which extends the filtering\n              capability of IEEE 802.1d.')
ctBridgeSdbEnetFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbEnetFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbEnetState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetState.setDescription('The state of the filter for which this entry contains\n              filtering information.')
ctBridgeSdbEnetFtrData = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetFtrData.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetFtrData.setDescription("The specific packet string representing the\n              destination address, source address, type/length \n              field and a window of 64 bytes of packet data \n              beginning at DataOffset to be used for filtering \n              decisions. Each ASCII character of the string \n              represents a nibble of packet data, therefore the \n              packet string should be (14+64) * 2 = 156 characters\n              long.  A value of 'x' in the packet string is\n              used to indicate a 'Don't care' and no filtering is \n              to be performed on that nibble.  The string may be \n              be of size 0 to 78 bytes.  If a size less than 78 \n              bytes is used, the string will still begin at the \n              destination address.")
ctBridgeSdbEnetDataOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetDataOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetDataOffset.setDescription("The offset into a packet from which the bridge begins\n              its filtering decisions on the 64 byte data window. The \n              value '0' indicates that the window begins at the first\n              byte after the Ethernet MAC header. The largest value of\n              DataOffset is  max_Enet_pkt - MAC header - window - 1\n              (1514 - 14 - 64 - 1 = 1435).")
ctBridgeSdbEnetIOTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4), )
if mibBuilder.loadTexts: ctBridgeSdbEnetIOTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIOTable.setDescription("A table containing the set of ports to which\n              frames received from specific ports and containing the\n              specific packet string (destination address, source address,\n              type/length field as well as a window of 64 bytes of\n              packet data beginning at a data offset) of the corresponding \n              filter number of SdbEnetTable are allowed to be forwarded. \n              The value of '0' in this table as the RcvPort is used to\n              specify all ports which are not already specified in this \n              table for a particular entry.")
ctBridgeSdbEnetIOEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbEnetIOFtrNo"), (0, "CTRON-BRIDGE-MIB", "ctBridgeSdbEnetIORcvPort"))
if mibBuilder.loadTexts: ctBridgeSdbEnetIOEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIOEntry.setDescription('The set of ports to which frames received by the RcvPort\n              and containing the specific packet string of the \n              corresponding filter number of SdbEnetTable are allowed\n              to be forwarded.')
ctBridgeSdbEnetIOFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbEnetIOFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIOFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbEnetIORcvPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetIORcvPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIORcvPort.setDescription("Either the value '0', or the port number of the port\n              from which a frame must be received in order for this\n              entry's filtering information to apply.  A value of\n              '0' indicates that this entry applies on all ports of\n              the bridge for which there is no other applicable entry.")
ctBridgeSdbEnetIOAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetIOAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIOAllowedToGoTo.setDescription("The set of ports to which frames received from a\n              specific port and containing the specific packet\n              string of the corresponding filter number are allowed\n              to be forwarded.  Each octet within the value of this\n              object specifies a set of eight ports, with the first\n              octet specifying ports 1 through 8, the second octet\n              specifying ports 9 through 16, etc.  Within each octet,\n              the most significant bit represents the lowest numbered\n              port, and the least significant bit represents the\n              highest numbered port.  Thus, each port of the bridge is\n              represented by a single bit within the value of this\n              object.  If that bit has a value of '1' then that port\n              is included in the set of ports; the port is not\n              included if its bit has a value of '0'.  (Note that the\n              setting of the bit corresponding to the port from which\n              a frame is received is irrelevant.)")
ctBridgeSdbEnetIODelEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("deleteEntry", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbEnetIODelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbEnetIODelEntry.setDescription("Writing a '1' to this object deletes this entry from the\n              Ethernet special database. This object will always return\n              a '1' when read.")
ctBridgeSdbTrTotFtrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbTrTotFtrs.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrTotFtrs.setDescription('The total number of Token Ring filters in the special\n              database.')
ctBridgeSdbTrNoMatch = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("forward", 2), ("searchFDB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrNoMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrNoMatch.setDescription('The process to be performed if no match is found\n              in the Token Ring special database.  The process of\n              filtering or forwarding is for all ports. searchFDB\n              results in searching the IEEE 802.1D transparent filter\n              database referenced by the IETF Bridge MIB. ')
ctBridgeSdbTrTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3), )
if mibBuilder.loadTexts: ctBridgeSdbTrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrTable.setDescription('A table containing filtering information configured into\n              the bridge by (local or network) management specifying\n              the specific packet string (AC, FC, destination address, \n              source address, as well as a window of 64 bytes of packet \n              data beginning at a data offset) to be used for filtering\n              decisions.  The filters are to be searched in the order of\n              incrementing filter number.')
ctBridgeSdbTrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbTrFtrNo"))
if mibBuilder.loadTexts: ctBridgeSdbTrEntry.setReference(' IETF RFC:1286 ')
if mibBuilder.loadTexts: ctBridgeSdbTrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrEntry.setDescription('Filtering information which extends the filtering\n              capability of IEEE 802.1d.')
ctBridgeSdbTrFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbTrFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbTrState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrState.setDescription('The state of the filter for which this entry contains\n              filtering information.')
ctBridgeSdbTrFtrData = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrFtrData.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrFtrData.setDescription("The specific packet string consisting of the AC, FC,\n              destination address, source address, and a window of \n              64 bytes of packet data beginning at DataOffset\n              to be used for filtering decisions.  Each ASCII \n              character of the string represents a nibble of \n              packet data, therefore the packet string should be \n              (14+64) * 2 = 156 characters long.  A value of 'x' in\n              the packet string is used to indicate a 'Don't care' \n              and no filtering is to be performed on that nibble.\n              If a size less than 78 bytes is used, the string \n              will still begin at the AC field.")
ctBridgeSdbTrDataOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrDataOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrDataOffset.setDescription("The offset into a packet from which the bridge begins\n              its filtering decisions on the 64 byte data window. The \n              value '0' indicates that the window begins at the first\n              byte after the Token Ring MAC header. The largest value of\n              DataOffset is max_TR_pkt - MAC header - window - 1 \n              (17800 - 14 - 64 - 1 = 17721). ")
ctBridgeSdbTrIOTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4), )
if mibBuilder.loadTexts: ctBridgeSdbTrIOTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIOTable.setDescription("A table containing the set of ports to which frames \n              received from specific ports and containing the specific\n              packet string (AC, FC, destination address, source address,\n              as well as a window of 64 bytes of packet data beginning \n              at a data offset) of the corresponding filter number of \n              SdbTrTable are allowed to be forwarded.  The value of '0' \n              in this table as the RcvPort is used to specify all ports\n              which are not already specified in this table for a \n              particular entry.")
ctBridgeSdbTrIOEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbTrIOFtrNo"), (0, "CTRON-BRIDGE-MIB", "ctBridgeSdbTrIORcvPort"))
if mibBuilder.loadTexts: ctBridgeSdbTrIOEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIOEntry.setDescription('The set of ports to which frames received by the RcvPort\n              and containing the specific packet string of the \n              corresponding filter number of SdbTrTable are allowed\n              to be forwarded.')
ctBridgeSdbTrIOFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbTrIOFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIOFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbTrIORcvPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrIORcvPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIORcvPort.setDescription("Either the value '0', or the port number of the port\n              from which a frame must be received in order for this\n              entry's filtering information to apply.  A value of\n              '0' indicates that this entry applies on all ports of\n              the bridge for which there is no other applicable entry.")
ctBridgeSdbTrIOAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrIOAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIOAllowedToGoTo.setDescription("The set of ports to which frames received from a\n              specific port and containing the specific packet\n              string of the corresponding filter number are allowed\n              to be forwarded.  Each octet within the value of this\n              object specifies a set of eight ports, with the first\n              octet specifying ports 1 through 8, the second octet\n              specifying ports 9 through 16, etc.  Within each octet,\n              the most significant bit represents the lowest numbered\n              port, and the least significant bit represents the\n              highest numbered port.  Thus, each port of the bridge is\n              represented by a single bit within the value of this\n              object.  If that bit has a value of '1' then that port\n              is included in the set of ports; the port is not\n              included if its bit has a value of '0'.  (Note that the\n              setting of the bit corresponding to the port from which\n              a frame is received is irrelevant.)")
ctBridgeSdbTrIODelEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("deleteEntry", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbTrIODelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbTrIODelEntry.setDescription("Writing a '1' to this object deletes this entry from the\n              Token Ring special database. This object will always return\n              a '1' when read.")
ctBridgeTransTrEnetAutoMode = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetAutoMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetAutoMode.setDescription('This object selects whether the auto translation mode\n              is enabled.  Auto translation means a bridge learns, from\n              the CSMA/CD ports,  which frame format (ie Ethernet or\n              IEEE 802.3 w/snap) a source address is using.  Subsequently,\n              the bridge will translate a Token Ring packet, destined to\n              the learned address, with the learned format. ')
ctBridgeTransTrEnetDualMode = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetDualMode.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetDualMode.setDescription('This object selects whether dual mode is enabled.  Dual\n              mode means a bridge translates a Token Ring broadcast or \n              multicast packet to both CSMA/CD frame formats (ie Ethernet\n              and IEEE 802.3 w/snap) when the format has not previously\n              been learned.')
ctBridgeTransTrEnetNovell = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee8023snap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetNovell.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetNovell.setDescription('This object selects the CSMA/CD frame format (ie Ethernet\n              or IEEE 802.3 w/snap) to which the bridge translates a \n              Novell Token Ring packet.  This selection is overidden \n              by the learned format when ctBridgeTransTrEnetAutoMode is\n              enabled and the format has been learned.')
ctBridgeTransTrEnetIP = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee8023snap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetIP.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIP.setDescription('This object selects the CSMA/CD frame format (ie Ethernet \n              or IEEE 802.3 w/snap) to which the bridge translates an IP\n              Token Ring packet including ARP packets.  This selection is \n              overidden by the learned format when ctBridgeTransTrEnetAutoMode\n              is enabled and the format has been learned.')
ctBridgeTransTrEnetAARP = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee8023snap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetAARP.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetAARP.setDescription('This object selects the CSMA/CD frame format (ie Ethernet or\n              IEEE 802.3 w/snap) to which the bridge translates an Appletalk\n              ARP Token Ring packet.  This selection is overidden by the\n              learned format when ctBridgeTransTrEnetAutoMode is enabled\n              and the format has been learned.')
ctBridgeTransTrEnetNovAdd = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("msb", 1), ("lsb", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetNovAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetNovAdd.setDescription("This object selects the bit ordering of the Hardware Addresses \n              located in the 'data field' of a Token Ring NOVELL packet. The \n              'data field' includes all bytes of the packet excluding the MAC \n              Header and CRC. The Hardware Addresses in the MAC Header are\n              always MSB for Token Ring packets. The default value is 2.")
ctBridgeTransTrEnetIBMTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 7), )
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMTable.setDescription('A table containing SAP (Service Access Point) values of \n              IBM protocols that the bridge will translate from Token Ring \n              (802.5 w/o snap) to Ethernet.')
ctBridgeTransTrEnetIBMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 7, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeTransTrEnetIBMIndex"))
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMEntry.setDescription('This entry contains the SAP value of an IBM protocol\n              that is to be translated to Ethernet. The value of the\n              Ethernet type field used in the translation is 80D5.\n              Only SAP values whose entry is enabled will be translated\n              to Ethernet. All other Token Ring packets not having a \n              snap will be translated as an 802.3/802.2 formatted packet.')
ctBridgeTransTrEnetIBMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMIndex.setDescription('The index of an entry in the Token Ring to Ethernet Translation\n              table for IBM protocols. The index ranges from 1 to 20.')
ctBridgeTransTrEnetIBMSap = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 7, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMSap.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMSap.setDescription('The SAP value of an IBM protocol. The bridge will translate\n              all Token Ring/802.5 packets without a snap header having \n              this SAP value to Ethernet packets with the Ethernet type\n              field set to 80D5. The SAP value is one octet.')
ctBridgeTransTrEnetIBMState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetIBMState.setDescription("The state of this entry. A value of 2 indicates that this\n              entry will not be used in the bridge's translation decisions.")
ctBridgeTransTrEnetSnapFormat = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("ieee8023snap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapFormat.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapFormat.setDescription('This object selects the CSMA/CD frame format (ie Ethernet or\n              IEEE 802.3 w/snap) to which the bridge translates all\n              Token Ring packets with a snap header whose Ethernet type\n              resides in the ctBridgeTransTrEnetSnapTable and is enabled. \n              This selection is overidden by the learned format when\n              ctBridgeTransTrEnetAutoMode is enable and the format has\n              been learned.')
ctBridgeTransTrEnetSnapTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 9), )
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapTable.setDescription('A table containing Ethernet type field entries that the \n              bridge will use to determine how to translate a Token Ring \n              (802.5 w/snap) packet to a CSMA/CD packet. If a received \n              Token Ring packet matches the Ethernet type field of an \n              enabled entry, the bridge will translate the Token Ring\n              packet to the frame format specified by\n              ctBridgeTransTrEnetSnapFormat. Else, it will translate the\n              packet to the opposite frame format.')
ctBridgeTransTrEnetSnapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 9, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeTransTrEnetSnapIndex"))
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapEntry.setDescription('This entry contains an Ethernet type field value and its\n              associated state.')
ctBridgeTransTrEnetSnapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapIndex.setDescription('The index of an entry in the Token Ring to Ethernet Translation\n              table for Ethernet type fields. The index ranges from 1 to 20.')
ctBridgeTransTrEnetSnapType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 9, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapType.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapType.setDescription('The Ethernet type field value which the bridge will translate\n              all Token Ring/802.5 packets with a snap header having\n              this type to the format specified by \n              ctBridgeTransTrEnetSnapFormat.  The Ethernet type field value\n              is two octets.')
ctBridgeTransTrEnetSnapState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 7, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeTransTrEnetSnapState.setDescription("The state of this entry. A value of 2 indicates that this\n              entry will not be used in the bridge's translation decisions.")
ctBridgeBaseChassisMgr = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notSupported", 1), ("managementDisabled", 2), ("managementEnabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeBaseChassisMgr.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeBaseChassisMgr.setDescription('This object reports the chassis management capability of\n        the bridging device.  Chassis management is defined as the\n        ability of the device to report status on MIM boards which\n        the device might be responsible for managing, modifying the\n        state of the MIM boards and the ports residing on the MIM\n        board, and tracking and reporting on the status of the networks\n        being bridged and the stations generating traffic on those\n        networks.  Note that this is not a comprehensive list of the\n        activities which comprise chassis management.\n\n        If chassis management is unsupported by this device, then the\n        value notSupported is returned.  If chassis management is\n        supported by this device and the device is, in fact, operating\n        as a chassis manager, then the value managementEnabled is re-\n        turned.  If chassis management is supported by this device but\n        the device is not functioning as a chassis manager, the value\n        managementDisabled is returned.')
ctBridgeSdbGenericTotFtrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbGenericTotFtrs.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericTotFtrs.setDescription('The total number of Generic filters in the special\n              database.')
ctBridgeSdbGenericNoMatch = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("filter", 1), ("forward", 2), ("searchFDB", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericNoMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericNoMatch.setDescription('The process to be performed if no match is found\n              in the Generic special database.  The process of \n              filtering or forwarding is for all ports.  searchFDB\n              results in searching the IEEE 802.1D transparent filter\n              database referenced by the IETF Bridge MIB. ')
ctBridgeSdbGenericTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3), )
if mibBuilder.loadTexts: ctBridgeSdbGenericTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericTable.setDescription('A table containing filtering information configured into\n              the bridge by (local or network) management specifying\n              the specific packet string (destination address, source \n              address, type/length field as well as a window of 64 bytes \n              of packet data beginning at a data offset) to be used \n              for filtering decisions.  The filters are to be searched in\n              the order of incrementing filter number.')
ctBridgeSdbGenericEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbGenericFtrNo"))
if mibBuilder.loadTexts: ctBridgeSdbGenericEntry.setReference(' IETF RFC:1286 ')
if mibBuilder.loadTexts: ctBridgeSdbGenericEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericEntry.setDescription('Filtering information which extends the filtering\n              capability of IEEE 802.1d.')
ctBridgeSdbGenericFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbGenericFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbGenericState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericState.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericState.setDescription('The state of the filter for which this entry contains\n              filtering information.')
ctBridgeSdbGenericFtrData = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericFtrData.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericFtrData.setDescription("The specific packet string representing the\n              destination address, source address, type/length \n              field and a window of 64 bytes of packet data \n              beginning at DataOffset to be used for filtering \n              decisions. Each ASCII character of the string \n              represents a nibble of packet data, therefore the \n              packet string should be (14+64) * 2 = 156 characters\n              long.  A value of 'x' in the packet string is\n              used to indicate a 'Don't care' and no filtering is \n              to be performed on that nibble.  The string may be \n              be of size 0 to 78 bytes.  If a size less than 78 \n              bytes is used, the string will still begin at the \n              destination address.")
ctBridgeSdbGenericDataOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericDataOffset.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericDataOffset.setDescription("The offset into a packet from which the bridge begins\n              its filtering decisions on the 64 byte data window. The \n              value '0' indicates that the window begins at the first\n              byte after the Generic MAC header. The largest value of\n              DataOffset dependent upon the media type.")
ctBridgeSdbGenericFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericFilterType.setDescription('This object specifies the type of media for which this\n                special filter entry applies.  The value of this object\n                is a bit encoding which allows for multiple medias to\n                share the same filter.  The bit numbers are defined as\n                follows, note that bit 0 is considered to be least significant:\n\n                        ethernet        - bit 0\n                        Token Ring      - bit 1\n                        FDDI            - bit 2\n                There for a filter that was enabled for both FDDI and\n                ethernet would have a value of 5.')
ctBridgeSdbGenericIOTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4), )
if mibBuilder.loadTexts: ctBridgeSdbGenericIOTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIOTable.setDescription("A table containing the set of ports to which\n              frames received from specific ports and containing the\n              specific packet string (destination address, source address,\n              type/length field as well as a window of 64 bytes of\n              packet data beginning at a data offset) of the corresponding \n              filter number of SdbGenericTable are allowed to be forwarded. \n              The value of '0' in this table as the RcvPort is used to\n              specify all ports which are not already specified in this \n              table for a particular entry.")
ctBridgeSdbGenericIOEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeSdbGenericIOFtrNo"), (0, "CTRON-BRIDGE-MIB", "ctBridgeSdbGenericIORcvPort"))
if mibBuilder.loadTexts: ctBridgeSdbGenericIOEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIOEntry.setDescription('The set of ports to which frames received by the RcvPort\n              and containing the specific packet string of the \n              corresponding filter number of SdbGenericTable are allowed\n              to be forwarded.')
ctBridgeSdbGenericIOFtrNo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeSdbGenericIOFtrNo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIOFtrNo.setDescription('The Filter number for which this entry contains\n              filtering information.')
ctBridgeSdbGenericIORcvPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericIORcvPort.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIORcvPort.setDescription("Either the value '0', or the port number of the port\n              from which a frame must be received in order for this\n              entry's filtering information to apply.  A value of\n              '0' indicates that this entry applies on all ports of\n              the bridge for which there is no other applicable entry.")
ctBridgeSdbGenericIOAllowedToGoTo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericIOAllowedToGoTo.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIOAllowedToGoTo.setDescription("The set of ports to which frames received from a\n              specific port and containing the specific packet\n              string of the corresponding filter number are allowed\n              to be forwarded.  Each octet within the value of this\n              object specifies a set of eight ports, with the first\n              octet specifying ports 1 through 8, the second octet\n              specifying ports 9 through 16, etc.  Within each octet,\n              the most significant bit represents the lowest numbered\n              port, and the least significant bit represents the\n              highest numbered port.  Thus, each port of the bridge is\n              represented by a single bit within the value of this\n              object.  If that bit has a value of '1' then that port\n              is included in the set of ports; the port is not\n              included if its bit has a value of '0'.  (Note that the\n              setting of the bit corresponding to the port from which\n              a frame is received is irrelevant.)")
ctBridgeSdbGenericIODelEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 9, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("deleteEntry", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeSdbGenericIODelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeSdbGenericIODelEntry.setDescription("Writing a '1' to this object deletes this entry from the\n              Generic special database. This object will always return\n              a '1' when read.")
ctBridgeLoadShareInstanceTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 1), )
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceTable.setDescription('A list of load share instance objects.')
ctBridgeLoadShareInstanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 1, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeLoadShareInstanceId"))
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceEntry.setDescription('A list of objects for a particular load share instance.')
ctBridgeLoadShareInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadShareInstanceId.setDescription('Returns the instance for a load share member in the\n              table of load share instances.')
ctBridgeLoadShareAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeLoadShareAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadShareAdminStatus.setDescription('The administrative state of load sharing for this instance.')
ctBridgeLoadShareOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadShareOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadShareOperStatus.setDescription('The operational status of load sharing for this instance.')
ctBridgeLoadSharePortTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2), )
if mibBuilder.loadTexts: ctBridgeLoadSharePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortTable.setDescription('A list of load share port objects.')
ctBridgeLoadSharePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1), ).setIndexNames((0, "CTRON-BRIDGE-MIB", "ctBridgeLoadSharePortInstanceId"), (0, "CTRON-BRIDGE-MIB", "ctBridgeLoadSharePortNum"))
if mibBuilder.loadTexts: ctBridgeLoadSharePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortEntry.setDescription('A load share port entry containing objects pertaining to\n              a particular load share port.')
ctBridgeLoadSharePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortNum.setDescription('Returns the port number of a member port belonging to a\n              load share instance.')
ctBridgeLoadSharePortInstanceId = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortInstanceId.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortInstanceId.setDescription('A unique value indentifying a member instance in the table\n              of load share instances.  This value is similar to \n              ctBridgeLoadShareInstanceId.')
ctBridgeLoadSharePortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctBridgeLoadSharePortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortAdminStatus.setDescription('The administrative state of the port associated with \n              this instance of load share.')
ctBridgeLoadSharePortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortOperStatus.setDescription('The operational state of the port associated with\n              this instance of load share.')
ctBridgeLoadSharePortForwardMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortForwardMask.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortForwardMask.setDescription('The Mask used to foward unknown packets on.')
ctBridgeLoadSharePortForwardInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortForwardInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortForwardInstance.setDescription('The instance that the ctLoadSharePortFowardMask \n              is running on for this ctLoadSharePortNumber.')
ctBridgeLoadSharePortNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 3, 10, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctBridgeLoadSharePortNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: ctBridgeLoadSharePortNumPorts.setDescription('Displays the number of SmartTrunk ports in this redundant path.')
mibBuilder.exportSymbols("CTRON-BRIDGE-MIB", ctBridgeSdbTrIORcvPort=ctBridgeSdbTrIORcvPort, ctPvstStpHelloTime=ctPvstStpHelloTime, ctBridgeLoadShareInstanceEntry=ctBridgeLoadShareInstanceEntry, ctBridgeSdbGenericTable=ctBridgeSdbGenericTable, ctBridgeSdbGeneric=ctBridgeSdbGeneric, ctBridgeLoadSharePortTable=ctBridgeLoadSharePortTable, ctBridgeSrPortPairState=ctBridgeSrPortPairState, ctPvstStpTimeSinceTopologyChange=ctPvstStpTimeSinceTopologyChange, ctPvstStpForwardDelay=ctPvstStpForwardDelay, ctBridgeSdbTrTotFtrs=ctBridgeSdbTrTotFtrs, ctBridgeLoadSharePortForwardInstance=ctBridgeLoadSharePortForwardInstance, ctBridgeExtendedControl=ctBridgeExtendedControl, ctBridgeTransTrEnetIBMEntry=ctBridgeTransTrEnetIBMEntry, ctBridgeLoadShareAdminStatus=ctBridgeLoadShareAdminStatus, ctBridgeSdbTrDataOffset=ctBridgeSdbTrDataOffset, ctBridgeLoadSharePortEntry=ctBridgeLoadSharePortEntry, ctBridgeSdbGenericEntry=ctBridgeSdbGenericEntry, ctBridgeSdbEnetIODelEntry=ctBridgeSdbEnetIODelEntry, ctBridgeTransTrEnet=ctBridgeTransTrEnet, ctBridgeSdbEnetIOAllowedToGoTo=ctBridgeSdbEnetIOAllowedToGoTo, ctPvstStpPortState=ctPvstStpPortState, ctPvstStpRootPort=ctPvstStpRootPort, ctBridgeTransTrEnetIP=ctBridgeTransTrEnetIP, ctBridgeBaseChassisMgr=ctBridgeBaseChassisMgr, ctBridgeTransTrEnetAARP=ctBridgeTransTrEnetAARP, ctBridgePvst=ctBridgePvst, ctBridgeLoadSharePortInstanceId=ctBridgeLoadSharePortInstanceId, ctBridgeTpPortPairDestPort=ctBridgeTpPortPairDestPort, ctBridgeSdbEnetTable=ctBridgeSdbEnetTable, ctBridgeTpPortPairState=ctBridgeTpPortPairState, ctBridgeSdbTrEntry=ctBridgeSdbTrEntry, ctBridgeTpPortPairTable=ctBridgeTpPortPairTable, ctBridgeSdbEnetFtrData=ctBridgeSdbEnetFtrData, ctBridgeTransTrEnetSnapType=ctBridgeTransTrEnetSnapType, ctBridgeLoadShareOperStatus=ctBridgeLoadShareOperStatus, ctPvstStpRootCost=ctPvstStpRootCost, ctBridgeSdbEnetState=ctBridgeSdbEnetState, ctPvstStpPortEntry=ctPvstStpPortEntry, ctPvstStpPort=ctPvstStpPort, ctPvstStpPortDesignatedCost=ctPvstStpPortDesignatedCost, ctBridgeSdbTrIODelEntry=ctBridgeSdbTrIODelEntry, ctBridgeTransTrEnetSnapState=ctBridgeTransTrEnetSnapState, ctBridgeTransTrEnetSnapTable=ctBridgeTransTrEnetSnapTable, ctBridgeSdbTrTable=ctBridgeSdbTrTable, ctBridgeSdbEnetIORcvPort=ctBridgeSdbEnetIORcvPort, ctPvstStpPortPriority=ctPvstStpPortPriority, ctBridgeTransTrEnetSnapFormat=ctBridgeTransTrEnetSnapFormat, ctBridgeSdbTrFtrNo=ctBridgeSdbTrFtrNo, ctBridgeSdbGenericIORcvPort=ctBridgeSdbGenericIORcvPort, ctBridgeTransTrEnetIBMSap=ctBridgeTransTrEnetIBMSap, ctBridgeStp=ctBridgeStp, ctPvstStpPortPathCost=ctPvstStpPortPathCost, ctBridgeSdbTrIOFtrNo=ctBridgeSdbTrIOFtrNo, ctBridgeSdbGenericIOAllowedToGoTo=ctBridgeSdbGenericIOAllowedToGoTo, ctBridgeTpPortPairPackets=ctBridgeTpPortPairPackets, ctBridgeSr=ctBridgeSr, ctBridgeStpProtocolSpecification=ctBridgeStpProtocolSpecification, ctBridgeSrPortPairTable=ctBridgeSrPortPairTable, ctBridgeSrPortPairSrcPort=ctBridgeSrPortPairSrcPort, ctBridgeTransTrEnetSnapIndex=ctBridgeTransTrEnetSnapIndex, ctPvstStpProtocolSpecification=ctPvstStpProtocolSpecification, ctPvstStpEntry=ctPvstStpEntry, ctPvstStpTopChanges=ctPvstStpTopChanges, ctBridgeSdbGenericIOFtrNo=ctBridgeSdbGenericIOFtrNo, ctPvstStpPriority=ctPvstStpPriority, ctPvstStpPortDesignatedBridge=ctPvstStpPortDesignatedBridge, ctBridgeLoadSharePortNumPorts=ctBridgeLoadSharePortNumPorts, ctBridgeLoadShare=ctBridgeLoadShare, ctBridgeSdbTrFtrData=ctBridgeSdbTrFtrData, ctBridgeSdbTrIOEntry=ctBridgeSdbTrIOEntry, ctBridgeTransTrEnetIBMTable=ctBridgeTransTrEnetIBMTable, ctBridgeLoadSharePortNum=ctBridgeLoadSharePortNum, ctBridgeTpPortPairSrcPort=ctBridgeTpPortPairSrcPort, ctBridgeTransTrEnetIBMState=ctBridgeTransTrEnetIBMState, ctBridgeLoadSharePortOperStatus=ctBridgeLoadSharePortOperStatus, ctPvstLastTopologyChange=ctPvstLastTopologyChange, ctBridgeTransTrEnetNovAdd=ctBridgeTransTrEnetNovAdd, ctPvstStpPortTable=ctPvstStpPortTable, ctBridgeTransTrEnetAutoMode=ctBridgeTransTrEnetAutoMode, ctBridgeSdbEnetNoMatch=ctBridgeSdbEnetNoMatch, ctPvstStpBridgeForwardDelay=ctPvstStpBridgeForwardDelay, ctBridgeSdbGenericIOEntry=ctBridgeSdbGenericIOEntry, ctBridgeLoadSharePortAdminStatus=ctBridgeLoadSharePortAdminStatus, ctBridgeSdbGenericDataOffset=ctBridgeSdbGenericDataOffset, ctPvstStpTable=ctPvstStpTable, ctPvstStpPortForwardTransitions=ctPvstStpPortForwardTransitions, ctPvstStpVlanId=ctPvstStpVlanId, ctBridgeSdbEnetDataOffset=ctBridgeSdbEnetDataOffset, ctBridgeLoadShareInstanceId=ctBridgeLoadShareInstanceId, ctPvstStpPortDesignatedRoot=ctPvstStpPortDesignatedRoot, ctBridgeSdbEnetIOFtrNo=ctBridgeSdbEnetIOFtrNo, ctBridgeSdbEnet=ctBridgeSdbEnet, ctPvstStpMaxAge=ctPvstStpMaxAge, ctPvstStpDesignatedRoot=ctPvstStpDesignatedRoot, ctBridgeSrPortPairEntry=ctBridgeSrPortPairEntry, ctPvstStpBridgeHelloTime=ctPvstStpBridgeHelloTime, ctBridgeTransTrEnetNovell=ctBridgeTransTrEnetNovell, ctBridgeLoadSharePortForwardMask=ctBridgeLoadSharePortForwardMask, ctBridgeSdbGenericFtrData=ctBridgeSdbGenericFtrData, ctBridgeTransTrEnetSnapEntry=ctBridgeTransTrEnetSnapEntry, ctPvstStpPortVlanId=ctPvstStpPortVlanId, ctBridgeSdbGenericIODelEntry=ctBridgeSdbGenericIODelEntry, ctPvstStpMode=ctPvstStpMode, ctBridgeSrPortPairPackets=ctBridgeSrPortPairPackets, ctPvstStpPortDesignatedPort=ctPvstStpPortDesignatedPort, ctBridgeSdbEnetIOEntry=ctBridgeSdbEnetIOEntry, ctBridgeSdbGenericFtrNo=ctBridgeSdbGenericFtrNo, ctBridgeSdbEnetIOTable=ctBridgeSdbEnetIOTable, ctBridgeTransTrEnetIBMIndex=ctBridgeTransTrEnetIBMIndex, ctBridgeSrConfigPortType=ctBridgeSrConfigPortType, ctBridgeSdbTrNoMatch=ctBridgeSdbTrNoMatch, ctBridgeSdbGenericFilterType=ctBridgeSdbGenericFilterType, ctBridgeTp=ctBridgeTp, ctBridgeSdbGenericState=ctBridgeSdbGenericState, ctBridgeTransTrEnetDualMode=ctBridgeTransTrEnetDualMode, ctPvstStpHoldTime=ctPvstStpHoldTime, ctBridgeSdbEnetEntry=ctBridgeSdbEnetEntry, ctBridgeSdbGenericIOTable=ctBridgeSdbGenericIOTable, ctPvstStpPortEnable=ctPvstStpPortEnable, ctBridgeSdbTrState=ctBridgeSdbTrState, ctPvstMaxNumStp=ctPvstMaxNumStp, ctBridgeSdbTrIOAllowedToGoTo=ctBridgeSdbTrIOAllowedToGoTo, ctBridgeSdbTr=ctBridgeSdbTr, ctBridgeSdbGenericNoMatch=ctBridgeSdbGenericNoMatch, ctBridgeLoadShareInstanceTable=ctBridgeLoadShareInstanceTable, ctBridgeTpPortPairEntry=ctBridgeTpPortPairEntry, ctPvstStpBridgeMaxAge=ctPvstStpBridgeMaxAge, ctBridgeSrPortPairDestPort=ctBridgeSrPortPairDestPort, ctBridgeSdbEnetFtrNo=ctBridgeSdbEnetFtrNo, ctBridgeSdbTrIOTable=ctBridgeSdbTrIOTable, ctBridgeSdbEnetTotFtrs=ctBridgeSdbEnetTotFtrs, ctBridgeSdbGenericTotFtrs=ctBridgeSdbGenericTotFtrs, ctPvstNumStps=ctPvstNumStps)
