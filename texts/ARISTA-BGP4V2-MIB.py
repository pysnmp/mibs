#
# PySNMP MIB module ARISTA-BGP4V2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/arista/ARISTA-BGP4V2-MIB
# Produced by pysmi-1.1.10 at Mon Feb 19 02:53:55 2024
# On host fv-az1016-227 platform Linux version 6.2.0-1019-azure by user runner
# Using Python version 3.10.13 (main, Aug 28 2023, 08:28:42) [GCC 11.4.0]
#
AristaBgp4V2IdentifierTC, AristaBgp4V2AddressFamilyIdentifierTC, AristaBgp4V2SubsequentAddressFamilyIdentifierTC = mibBuilder.importSymbols("ARISTA-BGP4V2-TC-MIB", "AristaBgp4V2IdentifierTC", "AristaBgp4V2AddressFamilyIdentifierTC", "AristaBgp4V2SubsequentAddressFamilyIdentifierTC")
aristaExperiment, = mibBuilder.importSymbols("ARISTA-SMI-MIB", "aristaExperiment")
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
InetAutonomousSystemNumber, InetAddressPrefixLength, InetPortNumber, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAutonomousSystemNumber", "InetAddressPrefixLength", "InetPortNumber", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Bits, TimeTicks, Counter64, Gauge32, iso, NotificationType, Integer32, IpAddress, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, ObjectIdentity, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Bits", "TimeTicks", "Counter64", "Gauge32", "iso", "NotificationType", "Integer32", "IpAddress", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "ObjectIdentity", "Unsigned32")
DisplayString, TextualConvention, TimeStamp, RowPointer, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeStamp", "RowPointer", "TruthValue")
aristaBgp4V2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 30065, 4, 1))
aristaBgp4V2.setRevisions(('2014-08-15 00:00', '2012-10-19 00:00', '2012-03-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: aristaBgp4V2.setRevisionsDescriptions(('Updated postal and e-mail addresses.', 'Renumbered inside the Arista enterprise space.', 'This MIB updates and replaces the BGP MIB defined in\n                    RFC 4273.',))
if mibBuilder.loadTexts: aristaBgp4V2.setLastUpdated('201408150000Z')
if mibBuilder.loadTexts: aristaBgp4V2.setOrganization('Arista Networks, Inc.')
if mibBuilder.loadTexts: aristaBgp4V2.setContactInfo('Arista Networks, Inc.\n\n                 Postal: 5453 Great America Parkway\n                         Santa Clara, CA 95054\n\n                 Tel: +1 408 547-5500\n\n                 E-mail: snmp@arista.com')
if mibBuilder.loadTexts: aristaBgp4V2.setDescription('The MIB module for the BGP-4 protocol.\n                     This version was published in\n                     draft-ietf-idr-bgp4-mibv2-13, and\n                     modified to be homed inside the Arista\n                     enterprise.  There were no other\n                     modifications.\n\n                     Copyright (C) The IETF Trust (2012).  This\n                     version of this MIB module is part of\n                     draft-ietf-idr-bgp4-mibv2-13.txt;\n                     see the draft itself for full legal notices.')
aristaBgp4V2Notifications = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0))
aristaBgp4V2Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1))
aristaBgp4V2Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2))
aristaBgp4V2DiscontinuityTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1), )
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTable.setDescription('Table of BGP-4 discontinuities.  Discontinuities that have\n             external visibility occur on a per-BGP instance basis.\n             Transitions by a given BGP peer will result in a consistent\n             BGP view within that instance and thus do not represent a\n             discontinuity from a protocol standpoint.')
aristaBgp4V2DiscontinuityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1, 1), ).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"))
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityEntry.setDescription('Entry repsenting information about a discontinuity event\n             for a given BGP instance.')
aristaBgp4V2DiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTime.setDescription('The value of sysUpTime at the most recent occasion at which\n             this BGP management instance has suffered a discontinuity.')
aristaBgp4V2PeerTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2), )
if mibBuilder.loadTexts: aristaBgp4V2PeerTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerTable.setDescription('BGP peer table.  This table contains, one entry per BGP\n             peer, information about the connections with BGP peers.')
aristaBgp4V2PeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1), ).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"))
if mibBuilder.loadTexts: aristaBgp4V2PeerEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerEntry.setDescription('Entry containing information about the connection with\n             a remote BGP peer.')
aristaBgp4V2PeerInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: aristaBgp4V2PeerInstance.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerInstance.setDescription('The routing instance index.\n\n             Some BGP implementations permit the creation of\n             multiple instances of a BGP routing process. An\n             example includes routers running BGP/MPLS IP Virtual\n             Private Networks.\n\n             Implementations that do not support multiple\n             routing instances should return 1 for this object.')
aristaBgp4V2PeerLocalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddrType.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddrType.setDescription('The address family of the local end of the peering\n             session.')
aristaBgp4V2PeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddr.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddr.setDescription("The local IP address of this entry's BGP connection.\n\n             An implementation is required to support IPv4 peering\n             sessions in which case the length of this object is 4.\n             An implementation MAY support IPv6 peering\n             sessions in which case the length of this object is 16.\n             IPv6 link-local peering sessions MAY be supported by\n             this MIB.  In this case the length of this object is 20.")
aristaBgp4V2PeerRemoteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 4), InetAddressType())
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddrType.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddrType.setDescription('The address family of the remote end of the peering\n             session.\n\n             An implementation is required to support IPv4 peering\n             sessions in which case the length of this object is 4.\n             An implementation MAY support IPv6 peering\n             sessions in which case the length of this object is 16.\n             IPv6 link-local peering sessions MAY be supported by\n             this MIB.  In this case the length of this object is 20.')
aristaBgp4V2PeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 5), InetAddress())
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddr.setDescription("The remote IP address of this entry's BGP peer.")
aristaBgp4V2PeerLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 6), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalPort.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalPort.setDescription('The local port for the TCP connection between the BGP\n             peers.')
aristaBgp4V2PeerLocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 7), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAs.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAs.setDescription('Some implementations of BGP can represent themselves\n             as multiple ASes. This is the AS that this peering\n             session is representing itself as to the remote peer.')
aristaBgp4V2PeerLocalIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 8), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalIdentifier.setReference("RFC 4271, Section 4.2, 'BGP Identifier'.")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalIdentifier.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalIdentifier.setDescription('The BGP Identifier of the local system for this peering\n             session.  It is REQUIRED that all aristaBgp4V2PeerLocalIdentifier\n             values for the same aristaBgp4V2PeerInstance be identical.')
aristaBgp4V2PeerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 9), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemotePort.setReference('RFC 2012 - SNMPv2 Management Information Base for the\n             Transmission Control Protocol using SMIv2.\n             RFC 4022 - IP Version 6 Management Information Base\n             for the Transmission Control Protocol.')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemotePort.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemotePort.setDescription('The remote port for the TCP connection between the BGP\n             peers.\n\n             Note that the objects aristaBgp4V2PeerLocalAddr,\n             aristaBgp4V2PeerLocalPort, aristaBgp4V2PeerRemoteAddr and\n             aristaBgp4V2PeerRemotePort provide the appropriate reference to\n             the standard MIB TCP connection table, or even the ipv6\n             TCP MIB as in RFC 4022.')
aristaBgp4V2PeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 10), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAs.setReference('RFC 4271, Section 4.2.')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAs.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAs.setDescription('The remote autonomous system number received in the BGP\n             OPEN message.')
aristaBgp4V2PeerRemoteIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 11), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteIdentifier.setReference("RFC 4271, Section 4.2, 'BGP Identifier'.")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteIdentifier.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteIdentifier.setDescription("The BGP Identifier of this entry's remote BGP peer.\n\n             This entry should be 0.0.0.0 unless the\n             aristaBgp4V2PeerState is in the openconfirm or the\n             established state.")
aristaBgp4V2PeerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("halted", 1), ("running", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerAdminStatus.setReference('RFC 4271, Section 8.1.2.')
if mibBuilder.loadTexts: aristaBgp4V2PeerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerAdminStatus.setDescription('Whether or not the BGP FSM for this remote peer is\n             halted or running. The BGP FSM for a remote peer is\n             halted after processing a Stop event. Likewise, it is\n             in the running state after a Start event.\n\n             The aristaBgp4V2PeerState will generally be in the idle state\n             when the FSM is halted, although some extensions such\n             as Graceful Restart will leave the peer in the Idle\n             state but with the FSM running.')
aristaBgp4V2PeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerState.setReference('RFC 4271, Section 8.2.2.')
if mibBuilder.loadTexts: aristaBgp4V2PeerState.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerState.setDescription('The BGP peer connection state.')
aristaBgp4V2PeerDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 14), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerDescription.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerDescription.setDescription('A user configured description identifying this peer.  When\n             this object is not the empty string, this object SHOULD\n             contain a description that is unique within a given BGP\n             instance for this peer.')
aristaBgp4V2PeerErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3), )
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsTable.setDescription('On a per-peer basis, this table reflects the last\n             protocol-defined error encountered and reported on\n             the peer session.')
aristaBgp4V2PeerErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1), )
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerErrorsEntry"))
aristaBgp4V2PeerErrorsEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsEntry.setDescription('Each entry contains information about errors sent\n             and received for a particular BGP peer.')
aristaBgp4V2PeerLastErrorCodeReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeReceived.setReference('RFC 4271, Section 4.5.\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeReceived.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeReceived.setDescription('The last error code received from this peer via\n             NOTIFICATION message on this connection.  If no error has\n             occurred, this field is zero.')
aristaBgp4V2PeerLastErrorSubCodeReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeReceived.setReference('RFC 4271, Section 4.5.\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeReceived.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeReceived.setDescription('The last subcode received from this peer via NOTIFICATION\n             message on this connection.  If no error has occurred, this\n             field is zero.')
aristaBgp4V2PeerLastErrorReceivedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedTime.setReference('RFC 4271, Section 4.5.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedTime.setDescription('The timestamp that the last NOTIFICATION was received from\n             this peer.')
aristaBgp4V2PeerLastErrorReceivedText = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedText.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedText.setDescription('This object contains an implementation specific\n             explanation of the error that was reported.')
aristaBgp4V2PeerLastErrorReceivedData = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedData.setReference('RFC 4271, Section 4.5,\n             RFC 2578, Section 7.1.2,\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedData.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedData.setDescription("The last error code's data seen by this peer.\n\n             Per RFC 2578, some implementations may have limitations\n             dealing with OCTET STRINGS larger than 255.  Thus, this\n             data may be truncated.")
aristaBgp4V2PeerLastErrorCodeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeSent.setReference('RFC 4271, Section 4.5.\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeSent.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeSent.setDescription('The last error code sent to this peer via NOTIFICATION\n             message on this connection.  If no error has occurred, this\n             field is zero.')
aristaBgp4V2PeerLastErrorSubCodeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeSent.setReference('RFC 4271, Section 4.5.\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeSent.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeSent.setDescription('The last subcode sent to this peer via NOTIFICATION\n             message on this connection.  If no error has occurred, this\n             field is zero.')
aristaBgp4V2PeerLastErrorSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentTime.setReference('RFC 4271, Section 4.5.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentTime.setDescription('The timestamp that the last NOTIFICATION was sent to\n             this peer.')
aristaBgp4V2PeerLastErrorSentText = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentText.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentText.setDescription('This object contains an implementation specific\n             explanation of the error that is being reported.')
aristaBgp4V2PeerLastErrorSentData = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentData.setReference('RFC 4271, Section 4.5,\n             RFC 2578, Section 7.1.2\n             RFC 4486 optionally supported.\n             RFC 3362, Section 5 optionally supported.')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentData.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentData.setDescription("The last error code's data sent to this peer.\n\n             Per RFC 2578, some implementations may have limitations\n             dealing with OCTET STRINGS larger than 255.  Thus, this\n             data may be truncated.")
aristaBgp4V2PeerEventTimesTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4), )
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesTable.setDescription('A table reporting the per-peering session amount\n             of time elapsed and update events since the peering\n             session advanced into the established state.')
aristaBgp4V2PeerEventTimesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1), )
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerEventTimesEntry"))
aristaBgp4V2PeerEventTimesEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesEntry.setDescription('Each row contains a set of statistics about time\n             spent and events encountered in the peer session\n             established state.')
aristaBgp4V2PeerFsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1, 1), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTime.setReference('RFC 4271, Section 8.')
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTime.setDescription('This timer indicates how long (in seconds) this peer\n             has been in the established state or how long since this\n             peer was last in the established state.  It is set to\n             zero when a new peer is configured or when the router is\n             booted.  If the peer has never reached the established\n             state, the value remains zero.')
aristaBgp4V2PeerInUpdatesElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1, 2), Gauge32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdatesElapsedTime.setReference('RFC 4271, Section 4.3.\n             RFC 4271, Section 8.2.2, Established state.')
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdatesElapsedTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdatesElapsedTime.setDescription('Elapsed time (in seconds) since the last BGP UPDATE\n             message was received from the peer.  Each time\n             bgpPeerInUpdates is incremented, the value of this\n             object is set to zero (0).')
aristaBgp4V2PeerConfiguredTimersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5), )
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersTable.setDescription('Per peer management data on BGP session timers.')
aristaBgp4V2PeerConfiguredTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1), )
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerConfiguredTimersEntry"))
aristaBgp4V2PeerConfiguredTimersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersEntry.setDescription('Each entry corresponds to the current state of\n             BGP timers on a given peering session.')
aristaBgp4V2PeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerConnectRetryInterval.setReference("RFC 4271, Section 8.2.2.  This is the value used\n             to initialize the 'ConnectRetryTimer'.")
if mibBuilder.loadTexts: aristaBgp4V2PeerConnectRetryInterval.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerConnectRetryInterval.setDescription('Time interval (in seconds) for the ConnectRetry timer.\n             The suggested value for this timer is 120 seconds.')
aristaBgp4V2PeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 65535), ))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTimeConfigured.setReference('RFC 4271, Section 4.2.')
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTimeConfigured.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTimeConfigured.setDescription('Time interval (in seconds) for the Hold Timer\n             established with the peer.  The value of this object is\n             calculated by this BGP speaker, using the smaller of the\n             values in bgpPeerHoldTimeConfigured and the Hold Time\n             received in the OPEN message.\n\n             This value must be at least three seconds if it is not\n             zero (0).\n\n             If the Hold Timer has not been established with the\n             peer this object MUST have a value of zero (0).\n\n             If the bgpPeerHoldTimeConfigured object has a value of\n             (0), then this object MUST have a value of (0).')
aristaBgp4V2PeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 21845), ))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAliveConfigured.setReference('RFC 4271, Section 4.4.\n             RFC 4271, Section 10.')
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAliveConfigured.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAliveConfigured.setDescription("Time interval (in seconds) for the KeepAlive timer\n             configured for this BGP speaker with this peer.  The\n             value of this object will only determine the KEEPALIVE\n             messages' frequency relative to the value specified in\n             bgpPeerHoldTimeConfigured; the actual time interval for\n             the KEEPALIVE messages is indicated by bgpPeerKeepAlive.\n\n             A reasonable maximum value for this timer would be one\n             third of that of bgpPeerHoldTimeConfigured.\n\n             If the value of this object is zero (0), no periodic\n             KEEPALIVE messages are sent to the peer after the BGP\n             connection has been established.  The suggested value\n             for this timer is 30 seconds.")
aristaBgp4V2PeerMinASOrigInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerMinASOrigInterval.setReference('RFC 4271, Section 9.2.1.2.\n             RFC 4271, Section 10.')
if mibBuilder.loadTexts: aristaBgp4V2PeerMinASOrigInterval.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerMinASOrigInterval.setDescription('Time interval (in seconds) for the\n             MinASOriginationInterval timer.\n\n             The suggested value for this timer is 15 seconds.')
aristaBgp4V2PeerMinRouteAdverInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerMinRouteAdverInterval.setReference('RFC 4271, Section 9.2.1.1.\n             RFC 4271, Section 10.')
if mibBuilder.loadTexts: aristaBgp4V2PeerMinRouteAdverInterval.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerMinRouteAdverInterval.setDescription('Time interval (in seconds) for the\n             MinRouteAdvertisementInterval timer.\n\n             The suggested value for this timer is 30 seconds for\n             EBGP connections and 5 seconds for IBGP connections.')
aristaBgp4V2PeerNegotiatedTimersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6), )
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersTable.setDescription('Configured values of per-peer timers are seen\n             in the aristaBgp4V2PeerConfiguredTimersTable.\n\n             Values in this table reflect the current\n             operational values, after negotiation from values\n             derived from initial configuration.')
aristaBgp4V2PeerNegotiatedTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1), )
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerNegotiatedTimersEntry"))
aristaBgp4V2PeerNegotiatedTimersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersEntry.setDescription('Each entry reflects a value of the currently\n             operational, negotiated timer as reflected in the\n             AristaBgp4V2PeerNegotiatedTimersEntry.')
aristaBgp4V2PeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(3, 65535), ))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTime.setReference('RFC 4271, Section 4.2.')
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTime.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTime.setDescription('The value of this object is calculated by this BGP\n             Speaker as being;\n\n             zero (0) - if this was the value sent by the peer and\n             this value is permitted by this BGP Speaker. In this\n             case, no keepalive messages are sent and the Hold Timer\n             is not set.\n\n             At least three (3). This value is the smaller of\n             the value sent by this peer in the OPEN message and\n             aristaBgp4V2PeerHoldTimeConfigured for this peer.\n\n             If the peer is not in the established state, the value\n             of this object is zero (0).')
aristaBgp4V2PeerKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 21845), ))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAlive.setReference('RFC 4271, Section 4.4.')
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAlive.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAlive.setDescription('Time interval in seconds for the KeepAlive timer\n             established with the peer. The value of this object\n             is calculated by this BGP speaker such that, when\n             compared with aristaBgp4V2PeerHoldTime, it has the same\n             proportion as what aristaBgp4V2PeerKeepAliveConfigured has\n             when compared with aristaBgp4V2PeerHoldTimeConfigured. If\n             the value of this object is zero (0), it indicates\n             that the KeepAlive timer has not been established\n             with the peer, or, the value of\n             aristaBgp4V2PeerKeepAliveConfigured is zero (0).\n\n             If the peer is not in the established state, the value\n             of this object is zero (0).')
aristaBgp4V2PeerCountersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7), )
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersTable.setDescription('The counters associated with a BGP Peer.')
aristaBgp4V2PeerCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1), )
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerCountersEntry"))
aristaBgp4V2PeerCountersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersEntry.setDescription('Each entry contains counters of message transmissions\n             and FSM transitions for a given BGP Peering session.')
aristaBgp4V2PeerInUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdates.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdates.setDescription('The number of BGP UPDATE messages received on this\n             connection.')
aristaBgp4V2PeerOutUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerOutUpdates.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerOutUpdates.setDescription('The number of BGP UPDATE messages transmitted on this\n             connection.')
aristaBgp4V2PeerInTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInTotalMessages.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerInTotalMessages.setDescription('The total number of messages received from the remote\n             peer on this connection.')
aristaBgp4V2PeerOutTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerOutTotalMessages.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerOutTotalMessages.setDescription('The total number of messages transmitted to the remote\n             peer on this connection.')
aristaBgp4V2PeerFsmEstablishedTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTransitions.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTransitions.setDescription('The total number of times the BGP FSM transitioned into\n             the established state for this peer.')
aristaBgp4V2PrefixGaugesTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8), )
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesTable.setDescription('Additional per-peer, per AFI-SAFI counters for\n             prefixes')
aristaBgp4V2PrefixGaugesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1), ).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixGaugesAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixGaugesSafi"))
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesEntry.setDescription('Entry containing information about a bgp-peers prefix\n             counters.')
aristaBgp4V2PrefixGaugesAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 1), AristaBgp4V2AddressFamilyIdentifierTC())
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesAfi.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesAfi.setDescription('The AFI index of the per-peer, per prefix counters')
aristaBgp4V2PrefixGaugesSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 2), AristaBgp4V2SubsequentAddressFamilyIdentifierTC())
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesSafi.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesSafi.setDescription('The SAFI index of the per-peer, per prefix counters')
aristaBgp4V2PrefixInPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixes.setReference('RFC 4271, Sections 3.2 and 9.')
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixes.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixes.setDescription('The number of prefixes received from a peer and are\n             stored in the Adj-Ribs-In for that peer.\n\n             Note that this number does not reflect prefixes that\n             have been discarded due to policy.')
aristaBgp4V2PrefixInPrefixesAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixesAccepted.setReference('RFC 4271, Sections 3.2 and 9.')
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixesAccepted.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixesAccepted.setDescription('The number of prefixes for a peer that are installed\n             in the Adj-Ribs-In and are eligible to become active\n             in the Loc-Rib.')
aristaBgp4V2PrefixOutPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixOutPrefixes.setReference('RFC 4271, Sections 3.2 and 9.')
if mibBuilder.loadTexts: aristaBgp4V2PrefixOutPrefixes.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2PrefixOutPrefixes.setDescription("The number of prefixes for a peer that are installed\n             in that peer's Adj-Ribs-Out.")
aristaBgp4V2NlriTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9), )
if mibBuilder.loadTexts: aristaBgp4V2NlriTable.setReference('RFC 4271, Sections 3.2 and 9.')
if mibBuilder.loadTexts: aristaBgp4V2NlriTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriTable.setDescription('The BGP-4 Received Path Attribute Table contains\n             information about paths to destination networks\n             received from all BGP4 peers. Collectively, this\n             represents the Adj-Ribs-In. The route where\n             aristaBgp4V2NlriBest is true represents, for this NLRI,\n             the route that is installed in the LocRib from the\n             Adj-Ribs-In.')
aristaBgp4V2NlriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1), ).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriSafi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefix"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixLen"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriIndex"))
if mibBuilder.loadTexts: aristaBgp4V2NlriEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriEntry.setDescription('Information about a path to a network.')
aristaBgp4V2NlriIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: aristaBgp4V2NlriIndex.setReference('RFC 3107 - Carrying Label Information in BGP-4.')
if mibBuilder.loadTexts: aristaBgp4V2NlriIndex.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriIndex.setDescription('This index allows for multiple instances of a base\n             prefix for a certain AFI-SAFI from a given peer.\n             This is currently useful for two things:\n             1. Allowing for a peer in future implementations to\n                send more than a single route instance.\n             2. Allow for extensions which extend the NLRI field\n                to send the same prefix while utilizing other\n                extension specific information. An example of\n                this is RFC 3107 - Carrying MPLS labels in BGP.')
aristaBgp4V2NlriAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 2), AristaBgp4V2AddressFamilyIdentifierTC())
if mibBuilder.loadTexts: aristaBgp4V2NlriAfi.setReference('RFC 4760 - Multiprotocol Extensions for BGP-4')
if mibBuilder.loadTexts: aristaBgp4V2NlriAfi.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAfi.setDescription('The address family of the prefix for this NLRI.\n\n             Note that the AFI is not necessarily equivalent to\n             the an InetAddressType.')
aristaBgp4V2NlriSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 3), AristaBgp4V2SubsequentAddressFamilyIdentifierTC())
if mibBuilder.loadTexts: aristaBgp4V2NlriSafi.setReference('RFC 4760 - Multiprotocol Extensions for BGP-4')
if mibBuilder.loadTexts: aristaBgp4V2NlriSafi.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriSafi.setDescription('The subsequent address family of the prefix for\n             this NLRI')
aristaBgp4V2NlriPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 4), InetAddressType())
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixType.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixType.setDescription('The type of the IP address prefix in the\n             Network Layer Reachability Information field.\n             The value of this object is derived from the\n             appropriate value from the aristaBgp4V2NlriAfi field.\n             Where an appropriate InetAddressType is not\n             available, the value of the object must be\n             unknown(0).')
aristaBgp4V2NlriPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 5), InetAddress())
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefix.setReference('RFC 4271, Section 4.3.')
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefix.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefix.setDescription('An IP address prefix in the Network Layer\n             Reachability Information field. This object\n             is an IP address containing the prefix with\n             length specified by aristaBgp4V2NlriPrefixLen.\n             Any bits beyond the length specified by\n             aristaBgp4V2NlriPrefixLen are zeroed.\n\n             An implementation is required to support IPv4\n             prefixes.  In this case, the object length\n             is (0..4).\n\n             An implementation MAY support IPv6 prefixes.\n             In this case, the object length is (0..16)')
aristaBgp4V2NlriPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 6), InetAddressPrefixLength())
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixLen.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixLen.setDescription('Length in bits of the address prefix in\n             the Network Layer Reachability Information field.')
aristaBgp4V2NlriBest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriBest.setReference('RFC 4271, Section 9.1.2.')
if mibBuilder.loadTexts: aristaBgp4V2NlriBest.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriBest.setDescription('An indication of whether or not this route\n             was chosen as the best BGP4 route for this\n             destination.')
aristaBgp4V2NlriCalcLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriCalcLocalPref.setReference('RFC 4271, Section 9.1.1')
if mibBuilder.loadTexts: aristaBgp4V2NlriCalcLocalPref.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriCalcLocalPref.setDescription('The degree of preference calculated by the\n             receiving BGP4 speaker for an advertised\n             route.\n\n             In the case where this prefix is ineligible, the\n             value of this object will be zero (0).')
aristaBgp4V2NlriOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriOrigin.setReference('RFC 4271, Section 4.3.\n             RFC 4271, Section 5.1.1.')
if mibBuilder.loadTexts: aristaBgp4V2NlriOrigin.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriOrigin.setDescription('The ultimate origin of the path information.')
aristaBgp4V2NlriNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddrType.setDescription('The address family of the address for\n             the border router that should be used\n             to access the destination network.')
aristaBgp4V2NlriNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 11), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddr.setReference('RFC 4271, Section 4.3,\n             RFC 4271, Section 5.1.3,\n             RFC 2545, Section 3.')
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddr.setDescription('The address of the border router that\n             should be used to access the destination\n             network. This address is the nexthop\n             address received in the UPDATE packet associated with\n             this prefix.\n\n             Note that for RFC2545 style double nexthops,\n             this object will always contain the global scope\n             nexthop. bgpPathAttrLinkLocalNextHop will contain\n             the linklocal scope nexthop, if it is present.\n\n             In the case a mechanism is developed to use only a link\n             local nexthop, aristaBgp4V2NlriNextHopAddr will contain the\n             link local nexthop.')
aristaBgp4V2NlriLinkLocalNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 12), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddrType.setReference('RFC 2545, Section 3.')
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddrType.setDescription('The address type for IPv6 link local addresses.\n             This is present only when receiving RFC 2545\n             style double nexthops.\n\n             This object is optionally present in BGP\n             implementations that do not support IPv6.\n\n             When no IPv6 link local nexthop is present, the value of\n             this object should be unknown(0).')
aristaBgp4V2NlriLinkLocalNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddr.setReference('RFC 2545, Section 3.')
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddr.setDescription('This value contains an IPv6 link local address\n             and is present only when receiving RFC 2545 style\n             double nexthops.\n\n             This object is optionally present in BGP\n             implementations that do not support IPv6.\n\n             When no IPv6 link local nexthop is present, the length of\n             this object should be zero.')
aristaBgp4V2NlriLocalPrefPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPrefPresent.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPrefPresent.setDescription('This value is true when the LOCAL_PREF value was sent in\n             the UPDATE message.')
aristaBgp4V2NlriLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPref.setReference('RFC 4271, Section 4.3.\n             RFC 4271, Section 5.1.5.')
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPref.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPref.setDescription('The originating BGP4 speakers degree of preference for an\n             advertised route.')
aristaBgp4V2NlriMedPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriMedPresent.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriMedPresent.setDescription('This value is true when the MED value was sent in\n             the UPDATE message.')
aristaBgp4V2NlriMed = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriMed.setReference('RFC 4271, Section 4.3.\n             RFC 4271, Section 5.1.4.')
if mibBuilder.loadTexts: aristaBgp4V2NlriMed.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriMed.setDescription('This metric is used to discriminate between multiple\n             exit points to an adjacent autonomous system.  When the MED\n             value is absent but has a calculated default value, this\n             object will contain the calculated value.')
aristaBgp4V2NlriAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAtomicAggregate.setReference('RFC 4271, Sections 5.1.6 and 9.1.4.')
if mibBuilder.loadTexts: aristaBgp4V2NlriAtomicAggregate.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAtomicAggregate.setDescription('This value is true when the ATOMIC_AGGREGATE Path Attribute\n             is present and indicates that the NLRI MUST NOT be made\n             more specific.')
aristaBgp4V2NlriAggregatorPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorPresent.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorPresent.setDescription('This value is true when the AGGREGATOR path attribute\n             was sent in the UPDATE message.')
aristaBgp4V2NlriAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 20), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAS.setReference('RFC 4271, Section 5.1.7.\n             RFC 4271, Section 9.2.2.2.')
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAS.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAS.setDescription('The AS number of the last BGP4 speaker that performed route\n             aggregation. When aristaBgp4V2NlriAggregatorPresent is\n             false, the value of this object should be zero (0).')
aristaBgp4V2NlriAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 21), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAddr.setReference('RFC 4271, Section 5.1.7.\n             RFC 4271, Section 9.2.2.2.')
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAddr.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAddr.setDescription('The IP address of the last BGP4 speaker that performed\n             route aggregation.  When aristaBgp4V2NlriAggregatorPresent is\n             false, the value of this object should be 0.0.0.0')
aristaBgp4V2NlriAsPathCalcLength = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathCalcLength.setReference('RFC 4271, Section 9.1.2.2.a')
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathCalcLength.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathCalcLength.setDescription('This value represents the calculated length of the\n             AS Path according to the rules of the BGP\n             specification.  This value is used in route selection.')
aristaBgp4V2NlriAsPathString = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 23), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathString.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathString.setDescription("This is a string depicting the autonomous system\n             path to this network which was received from the\n             peer which advertised it. The format of the string\n             is implementation-dependent, and should be designed\n             for operator readability.\n\n             Note that SnmpAdminString is only capable of representing a\n             maximum of 255 characters.  This may lead to the string\n             being truncated in the presence of a large AS Path.  It is\n             RECOMMENDED that when this object's contents will be\n             truncated that the final 3 octets be reserved for the\n             ellipses string, '...'.  aristaBgp4V2NlriAsPath may give access\n             to the full AS Path.")
aristaBgp4V2NlriAsPath = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 4072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPath.setReference('RFC 4271, Section 4.3.\n              RFC 5065, Section 5.\n              RFC 4893.')
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPath.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPath.setDescription("In order to provide a canonicalized form of the BGP-4\n             AS_PATH along with the human-readable\n             aristaBgp4V2NlriAsPathString, which may be truncated, this object\n             contains the contents of the BGP-4 AS_PATH Path Attribute.\n             This object may be parsed using the rules defined for\n             Four-octet ASes as defined in RFC 4893.  RFC 4271, Section\n             4.3, 'Path Attributes: b) AS_PATH' as amended by RFC 5065,\n             Section 3 defines the general format of the AS_PATH path\n             attribute and its code points.\n\n             In brief, the AS_PATH is composed of a sequence of AS\n             Segments.  Each AS Segment is represented by a triple:\n             <path segment type, path segment length,\n             path segment value>.\n\n             The path segment type and path segment length fields are\n             one octet in length each.\n\n             The path segment type field may be one of:\n               1 - AS_SET (RFC 4721, Section 4.3)\n               2 - AS_SEQUENCE (RFC 4721, Section 4.3)\n               3 - AS_CONFED_SEQUENCE (RFC 3065, Section 5)\n               4 - AS_CONFED_SET (RFC 3065, Section 5)\n\n             The path segment length field contains the number of ASes\n             (not the number of octets) in the path segment value field.\n             The path segment value field contains one or more AS\n             numbers, each encoded as a 4-octet length field in network\n             byte order.\n\n             Note that since an SNMP agent may truncate this object to\n             less than its maximum theoretical length of 4072 octets\n             users of this object should be prepared to deal with a\n             truncated and thus malformed AS_PATH.  It is RECOMMENDED\n             that when such truncation would occur on the boundary of an\n             encoded AS that the partial AS be discarded from this\n             object and the object's size be adjusted accordingly.\n             Further, it is also RECOMMENDED that when such truncation,\n             either alone or in conjuction with the truncation of a\n             partially encoded AS described previously, would yield an\n             empty path segment value field that the path segment type\n             and path segment length components of the truncated AS_PATH\n             also be discarded and the object's size be adjusted\n             accordingly.")
aristaBgp4V2NlriPathAttrUnknown = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriPathAttrUnknown.setReference('RFC 4271, Section 4.3.')
if mibBuilder.loadTexts: aristaBgp4V2NlriPathAttrUnknown.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2NlriPathAttrUnknown.setDescription("Path Attributes not understood by this implementation\n             SHOULD be be presented in this object.  Those Path\n             Attributes use the type, length, value encoding documented\n             in RFC 4271, Section 4.3, 'Path Attributes'.\n\n             Note that since an SNMP agent may truncate this object to\n             less than its maximum theoretical length of 4072 octets\n             users of this object should be prepared to deal with a\n             truncated and thus malformed Path Attribute.")
aristaBgp4V2AdjRibsOutTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10), )
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutTable.setReference('RFC 4271, Section 3.2.')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutTable.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutTable.setDescription("This table contains on a per-peer basis one or more\n             routes from the aristaBgp4V2NlriTable that have been\n             placed in this peer's Adj-Ribs-Out.")
aristaBgp4V2AdjRibsOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1), ).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriSafi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefix"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixLen"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2AdjRibsOutIndex"))
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutEntry.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutEntry.setDescription("List of BGP routes that have been placed into a\n             peer's Adj-Ribs-Out.")
aristaBgp4V2AdjRibsOutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutIndex.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutIndex.setDescription('Certain extensions to BGP permit multiple instance of\n             a per afi, per safi prefix to be advertised to a peer.\n             This object allows the enumeration of them.')
aristaBgp4V2AdjRibsOutRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutRoute.setReference('RFC 4271, Section 9.2.')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutRoute.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutRoute.setDescription("This object points to the route in the aristaBgp4V2NlriTable\n             that corresponds to the entry in the peer's\n             Adj-Rib-Out. Outgoing route maps are not\n             reflected at this point as those are part of the\n             Update-Send process.")
aristaBgp4V2EstablishedNotification = NotificationType((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0, 1)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"))
if mibBuilder.loadTexts: aristaBgp4V2EstablishedNotification.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2EstablishedNotification.setDescription('The BGP Established event is generated when\n             the BGP FSM enters the established state.')
aristaBgp4V2BackwardTransitionNotification = NotificationType((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0, 2)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedText"))
if mibBuilder.loadTexts: aristaBgp4V2BackwardTransitionNotification.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2BackwardTransitionNotification.setDescription('The BGPBackwardTransition Event is generated\n             when the BGP FSM moves from a higher numbered\n             state to a lower numbered state.\n\n             Due to the nature of the BGP state machine, an\n             implementation MAY rate limit the generation of this event.\n             An implementation MAY also generate this notification ONLY\n             when the state machine moves out of the established state.\n             An implementation should document its specific behavior.')
aristaBgp4V2Compliances = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 1))
aristaBgp4V2Groups = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2))
aristaBgp4V2Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 1, 4)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBTimersGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBCountersGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBErrorsGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBPeerGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBNlriGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2GlobalsGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2Compliance = aristaBgp4V2Compliance.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2Compliance.setDescription('The compliance statement for entities which\n            implement the BGP4 mib.')
aristaBgp4V2GlobalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 1)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2DiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2GlobalsGroup = aristaBgp4V2GlobalsGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2GlobalsGroup.setDescription('A collection of objects providing information on global\n             BGP state.')
aristaBgp4V2StdMIBTimersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 2)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerFsmEstablishedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInUpdatesElapsedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerConnectRetryInterval"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerHoldTimeConfigured"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerKeepAliveConfigured"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerMinASOrigInterval"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerMinRouteAdverInterval"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerHoldTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerKeepAlive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBTimersGroup = aristaBgp4V2StdMIBTimersGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBTimersGroup.setDescription('Objects associated with BGP peering timers.')
aristaBgp4V2StdMIBCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 3)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInUpdates"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerOutUpdates"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInTotalMessages"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerOutTotalMessages"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerFsmEstablishedTransitions"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixInPrefixes"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixInPrefixesAccepted"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixOutPrefixes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBCountersGroup = aristaBgp4V2StdMIBCountersGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBCountersGroup.setDescription('Objects to count discrete events and exchanges on BGP\n             sessions.')
aristaBgp4V2StdMIBErrorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 5)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedData"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedText"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeSent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeSent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentData"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentText"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBErrorsGroup = aristaBgp4V2StdMIBErrorsGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBErrorsGroup.setDescription('Errors received on BGP peering sessions.')
aristaBgp4V2StdMIBPeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 6)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerAdminStatus"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAs"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAs"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalIdentifier"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteIdentifier"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerDescription"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBPeerGroup = aristaBgp4V2StdMIBPeerGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBPeerGroup.setDescription('Core object types on BGP peering sessions.')
aristaBgp4V2StdMIBNlriGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 7)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPathCalcLength"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPathString"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriBest"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriCalcLocalPref"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2AdjRibsOutRoute"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorAS"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAtomicAggregate"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLocalPref"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLocalPrefPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriMed"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriMedPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriNextHopAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriNextHopAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLinkLocalNextHopAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLinkLocalNextHopAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriOrigin"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPath"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPathAttrUnknown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBNlriGroup = aristaBgp4V2StdMIBNlriGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBNlriGroup.setDescription('Attributes received on BGP peering sessions.')
aristaBgp4V2StdMIBNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 8)).setObjects(("ARISTA-BGP4V2-MIB", "aristaBgp4V2EstablishedNotification"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2BackwardTransitionNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aristaBgp4V2StdMIBNotificationGroup = aristaBgp4V2StdMIBNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: aristaBgp4V2StdMIBNotificationGroup.setDescription('Notifications in this modules are completely optional.')
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", aristaBgp4V2PeerFsmEstablishedTransitions=aristaBgp4V2PeerFsmEstablishedTransitions, aristaBgp4V2PeerErrorsEntry=aristaBgp4V2PeerErrorsEntry, aristaBgp4V2PrefixInPrefixes=aristaBgp4V2PrefixInPrefixes, aristaBgp4V2NlriAggregatorAddr=aristaBgp4V2NlriAggregatorAddr, aristaBgp4V2PeerDescription=aristaBgp4V2PeerDescription, aristaBgp4V2NlriTable=aristaBgp4V2NlriTable, aristaBgp4V2PeerLastErrorReceivedTime=aristaBgp4V2PeerLastErrorReceivedTime, aristaBgp4V2NlriIndex=aristaBgp4V2NlriIndex, aristaBgp4V2StdMIBNotificationGroup=aristaBgp4V2StdMIBNotificationGroup, aristaBgp4V2AdjRibsOutRoute=aristaBgp4V2AdjRibsOutRoute, aristaBgp4V2PrefixGaugesEntry=aristaBgp4V2PrefixGaugesEntry, aristaBgp4V2PeerHoldTime=aristaBgp4V2PeerHoldTime, aristaBgp4V2PeerLocalIdentifier=aristaBgp4V2PeerLocalIdentifier, aristaBgp4V2NlriAtomicAggregate=aristaBgp4V2NlriAtomicAggregate, aristaBgp4V2NlriNextHopAddrType=aristaBgp4V2NlriNextHopAddrType, aristaBgp4V2EstablishedNotification=aristaBgp4V2EstablishedNotification, aristaBgp4V2PeerInstance=aristaBgp4V2PeerInstance, aristaBgp4V2PeerErrorsTable=aristaBgp4V2PeerErrorsTable, aristaBgp4V2PrefixGaugesTable=aristaBgp4V2PrefixGaugesTable, aristaBgp4V2NlriLocalPrefPresent=aristaBgp4V2NlriLocalPrefPresent, aristaBgp4V2NlriBest=aristaBgp4V2NlriBest, aristaBgp4V2NlriAsPath=aristaBgp4V2NlriAsPath, aristaBgp4V2PeerKeepAlive=aristaBgp4V2PeerKeepAlive, aristaBgp4V2PeerInUpdatesElapsedTime=aristaBgp4V2PeerInUpdatesElapsedTime, aristaBgp4V2NlriEntry=aristaBgp4V2NlriEntry, aristaBgp4V2NlriCalcLocalPref=aristaBgp4V2NlriCalcLocalPref, aristaBgp4V2StdMIBErrorsGroup=aristaBgp4V2StdMIBErrorsGroup, aristaBgp4V2PeerOutUpdates=aristaBgp4V2PeerOutUpdates, aristaBgp4V2NlriLinkLocalNextHopAddr=aristaBgp4V2NlriLinkLocalNextHopAddr, aristaBgp4V2NlriOrigin=aristaBgp4V2NlriOrigin, aristaBgp4V2BackwardTransitionNotification=aristaBgp4V2BackwardTransitionNotification, aristaBgp4V2Objects=aristaBgp4V2Objects, aristaBgp4V2PeerConfiguredTimersEntry=aristaBgp4V2PeerConfiguredTimersEntry, aristaBgp4V2PeerOutTotalMessages=aristaBgp4V2PeerOutTotalMessages, aristaBgp4V2NlriPrefixLen=aristaBgp4V2NlriPrefixLen, aristaBgp4V2PeerLocalAddr=aristaBgp4V2PeerLocalAddr, aristaBgp4V2Groups=aristaBgp4V2Groups, aristaBgp4V2Compliances=aristaBgp4V2Compliances, aristaBgp4V2NlriAsPathCalcLength=aristaBgp4V2NlriAsPathCalcLength, aristaBgp4V2PeerHoldTimeConfigured=aristaBgp4V2PeerHoldTimeConfigured, aristaBgp4V2PeerLocalAs=aristaBgp4V2PeerLocalAs, aristaBgp4V2PeerEntry=aristaBgp4V2PeerEntry, aristaBgp4V2NlriMedPresent=aristaBgp4V2NlriMedPresent, aristaBgp4V2PeerConfiguredTimersTable=aristaBgp4V2PeerConfiguredTimersTable, aristaBgp4V2NlriAggregatorPresent=aristaBgp4V2NlriAggregatorPresent, aristaBgp4V2PeerRemoteAs=aristaBgp4V2PeerRemoteAs, aristaBgp4V2NlriPrefix=aristaBgp4V2NlriPrefix, aristaBgp4V2NlriNextHopAddr=aristaBgp4V2NlriNextHopAddr, aristaBgp4V2AdjRibsOutEntry=aristaBgp4V2AdjRibsOutEntry, aristaBgp4V2Compliance=aristaBgp4V2Compliance, aristaBgp4V2NlriAfi=aristaBgp4V2NlriAfi, aristaBgp4V2=aristaBgp4V2, aristaBgp4V2PeerCountersEntry=aristaBgp4V2PeerCountersEntry, aristaBgp4V2StdMIBTimersGroup=aristaBgp4V2StdMIBTimersGroup, aristaBgp4V2Notifications=aristaBgp4V2Notifications, aristaBgp4V2NlriPrefixType=aristaBgp4V2NlriPrefixType, aristaBgp4V2NlriLocalPref=aristaBgp4V2NlriLocalPref, aristaBgp4V2PeerRemoteIdentifier=aristaBgp4V2PeerRemoteIdentifier, PYSNMP_MODULE_ID=aristaBgp4V2, aristaBgp4V2AdjRibsOutIndex=aristaBgp4V2AdjRibsOutIndex, aristaBgp4V2PeerCountersTable=aristaBgp4V2PeerCountersTable, aristaBgp4V2PrefixGaugesAfi=aristaBgp4V2PrefixGaugesAfi, aristaBgp4V2DiscontinuityTable=aristaBgp4V2DiscontinuityTable, aristaBgp4V2PeerEventTimesTable=aristaBgp4V2PeerEventTimesTable, aristaBgp4V2PeerLastErrorCodeSent=aristaBgp4V2PeerLastErrorCodeSent, aristaBgp4V2GlobalsGroup=aristaBgp4V2GlobalsGroup, aristaBgp4V2NlriSafi=aristaBgp4V2NlriSafi, aristaBgp4V2PeerNegotiatedTimersTable=aristaBgp4V2PeerNegotiatedTimersTable, aristaBgp4V2PeerLastErrorReceivedData=aristaBgp4V2PeerLastErrorReceivedData, aristaBgp4V2PeerRemotePort=aristaBgp4V2PeerRemotePort, aristaBgp4V2PeerLastErrorSentData=aristaBgp4V2PeerLastErrorSentData, aristaBgp4V2PeerAdminStatus=aristaBgp4V2PeerAdminStatus, aristaBgp4V2NlriAggregatorAS=aristaBgp4V2NlriAggregatorAS, aristaBgp4V2PeerLastErrorSentText=aristaBgp4V2PeerLastErrorSentText, aristaBgp4V2StdMIBNlriGroup=aristaBgp4V2StdMIBNlriGroup, aristaBgp4V2PeerLastErrorSubCodeReceived=aristaBgp4V2PeerLastErrorSubCodeReceived, aristaBgp4V2PeerConnectRetryInterval=aristaBgp4V2PeerConnectRetryInterval, aristaBgp4V2PeerMinASOrigInterval=aristaBgp4V2PeerMinASOrigInterval, aristaBgp4V2PeerRemoteAddr=aristaBgp4V2PeerRemoteAddr, aristaBgp4V2DiscontinuityEntry=aristaBgp4V2DiscontinuityEntry, aristaBgp4V2PeerLastErrorSubCodeSent=aristaBgp4V2PeerLastErrorSubCodeSent, aristaBgp4V2NlriAsPathString=aristaBgp4V2NlriAsPathString, aristaBgp4V2PeerKeepAliveConfigured=aristaBgp4V2PeerKeepAliveConfigured, aristaBgp4V2StdMIBCountersGroup=aristaBgp4V2StdMIBCountersGroup, aristaBgp4V2PrefixInPrefixesAccepted=aristaBgp4V2PrefixInPrefixesAccepted, aristaBgp4V2NlriPathAttrUnknown=aristaBgp4V2NlriPathAttrUnknown, aristaBgp4V2PrefixGaugesSafi=aristaBgp4V2PrefixGaugesSafi, aristaBgp4V2PeerTable=aristaBgp4V2PeerTable, aristaBgp4V2PrefixOutPrefixes=aristaBgp4V2PrefixOutPrefixes, aristaBgp4V2PeerState=aristaBgp4V2PeerState, aristaBgp4V2PeerInTotalMessages=aristaBgp4V2PeerInTotalMessages, aristaBgp4V2NlriMed=aristaBgp4V2NlriMed, aristaBgp4V2PeerFsmEstablishedTime=aristaBgp4V2PeerFsmEstablishedTime, aristaBgp4V2PeerLastErrorReceivedText=aristaBgp4V2PeerLastErrorReceivedText, aristaBgp4V2PeerLastErrorSentTime=aristaBgp4V2PeerLastErrorSentTime, aristaBgp4V2PeerLastErrorCodeReceived=aristaBgp4V2PeerLastErrorCodeReceived, aristaBgp4V2PeerLocalPort=aristaBgp4V2PeerLocalPort, aristaBgp4V2PeerMinRouteAdverInterval=aristaBgp4V2PeerMinRouteAdverInterval, aristaBgp4V2PeerNegotiatedTimersEntry=aristaBgp4V2PeerNegotiatedTimersEntry, aristaBgp4V2PeerLocalAddrType=aristaBgp4V2PeerLocalAddrType, aristaBgp4V2PeerRemoteAddrType=aristaBgp4V2PeerRemoteAddrType, aristaBgp4V2DiscontinuityTime=aristaBgp4V2DiscontinuityTime, aristaBgp4V2PeerInUpdates=aristaBgp4V2PeerInUpdates, aristaBgp4V2PeerEventTimesEntry=aristaBgp4V2PeerEventTimesEntry, aristaBgp4V2StdMIBPeerGroup=aristaBgp4V2StdMIBPeerGroup, aristaBgp4V2AdjRibsOutTable=aristaBgp4V2AdjRibsOutTable, aristaBgp4V2NlriLinkLocalNextHopAddrType=aristaBgp4V2NlriLinkLocalNextHopAddrType, aristaBgp4V2Conformance=aristaBgp4V2Conformance)
