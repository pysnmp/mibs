#
# PySNMP MIB module CAMBIUM-PTP670-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/cambium/CAMBIUM-PTP670-MIB
# Produced by pysmi-1.1.12 at Fri Jul 19 11:33:17 2024
# On host fv-az702-886 platform Linux version 6.5.0-1023-azure by user runner
# Using Python version 3.10.14 (main, Jun 20 2024, 15:20:03) [GCC 11.4.0]
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
IpAddress, NotificationType, Counter64, TimeTicks, enterprises, Counter32, Gauge32, MibIdentifier, Integer32, ModuleIdentity, Bits, iso, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "NotificationType", "Counter64", "TimeTicks", "enterprises", "Counter32", "Gauge32", "MibIdentifier", "Integer32", "ModuleIdentity", "Bits", "iso", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cambium = ModuleIdentity((1, 3, 6, 1, 4, 1, 17713))
cambium.setRevisions(('2018-09-04 23:49', '2018-05-25 18:14', '2017-11-24 09:19', '2017-09-06 16:59', '2017-06-15 18:31', '2017-02-24 11:59',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cambium.setRevisionsDescriptions(('PTP670-02-65:\n         Added Secure License Signature Alarm.\n         Renamed ethernet statistics counters for clarity and added ethernet Tx counters.\n         Added erroredSeconds (ES), Severely Errored Seconds (SES) and unavailableSeconds (UAS) to the MIB.', 'PTP670-02-60:\n         Added DNS feature support.\n         Added ethernet statistics configuration data.\n         Added syncE slave port and overwrite quality level.\n         Added counters for wireless packets transmitted and received.\n         Added installation mode setting.\n         Added SNTP SHA1 configuration support.\n         Added PCB temperature setting.\n         Removed Transparent Clock Source Port Alarm Trap.', 'PTP670-02-55:\n         Added PCB temperature setting.', 'PTP670-02-50:\n         Revision with HCMP topology support.', 'PTP670-02-00:\n         Added encryption algorithms TLS-RSA, TLS-PSK 128 bit and TLS-PSK 256 bits.\n         Deprecated static AES 128-bit and AES 256-bit encryption algorithms.\n         Added Cambium Sync support.', 'PTP670-01-00: Initial revision.',))
if mibBuilder.loadTexts: cambium.setLastUpdated('201809042349Z')
if mibBuilder.loadTexts: cambium.setOrganization('Cambium Networks Ltd.')
if mibBuilder.loadTexts: cambium.setContactInfo('Post:  Simon Whitaker\n                 Cambium Networks Ltd.\n                 Unit B2,\n                 Linhay Business Park,\n                 Eastern Road,\n                 Ashburton,\n                 Devon.\n                 TQ13 7UP\n                 United Kingdom\n         Phone:  +44 (0) 1364 655 500\n         Email:  simon.whitaker@cambiumnetworks.com')
if mibBuilder.loadTexts: cambium.setDescription('MIB for non-line-of-sight (NLOS) wireless ethernet bridge.')
ptp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 1))
ptmp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 2))
ptp670 = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11))
dfs = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 3))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 4))
configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 5))
ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 6))
tDM = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 7))
license = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 8))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 9))
phyControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 10))
phyStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 12))
alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 13))
apc = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 14))
smtp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 15))
snmpControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 16))
sntp = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 17))
reset = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 18))
versions = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 19))
pubStats = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 20))
encryption = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 22))
tDDControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 23))
aAAControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 25))
syslogControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 24))
routerProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 26))
cableDiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 27))
unitIdentification = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 28))
authorizationControl = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 29))
dNS = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 30))
supplementary = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 96))
ptpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 98))
ptpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 99))
ptpTrapPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0))
ptpCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 17713, 11, 97)).setObjects(("CAMBIUM-PTP670-MIB", "dfsGroup"), ("CAMBIUM-PTP670-MIB", "bridgeGroup"), ("CAMBIUM-PTP670-MIB", "configurationGroup"), ("CAMBIUM-PTP670-MIB", "ethernetGroup"), ("CAMBIUM-PTP670-MIB", "tDMGroup"), ("CAMBIUM-PTP670-MIB", "licenseGroup"), ("CAMBIUM-PTP670-MIB", "managementGroup"), ("CAMBIUM-PTP670-MIB", "phyControlGroup"), ("CAMBIUM-PTP670-MIB", "phyStatusGroup"), ("CAMBIUM-PTP670-MIB", "alarmsGroup"), ("CAMBIUM-PTP670-MIB", "apcGroup"), ("CAMBIUM-PTP670-MIB", "smtpGroup"), ("CAMBIUM-PTP670-MIB", "snmpControlGroup"), ("CAMBIUM-PTP670-MIB", "sntpGroup"), ("CAMBIUM-PTP670-MIB", "resetGroup"), ("CAMBIUM-PTP670-MIB", "versionsGroup"), ("CAMBIUM-PTP670-MIB", "pubStatsGroup"), ("CAMBIUM-PTP670-MIB", "encryptionGroup"), ("CAMBIUM-PTP670-MIB", "tDDControlGroup"), ("CAMBIUM-PTP670-MIB", "aAAControlGroup"), ("CAMBIUM-PTP670-MIB", "syslogControlGroup"), ("CAMBIUM-PTP670-MIB", "routerProtocolsGroup"), ("CAMBIUM-PTP670-MIB", "cableDiagnosticsGroup"), ("CAMBIUM-PTP670-MIB", "unitIdentificationGroup"), ("CAMBIUM-PTP670-MIB", "authorizationControlGroup"), ("CAMBIUM-PTP670-MIB", "dNSGroup"), ("CAMBIUM-PTP670-MIB", "supplementaryGroup"), ("CAMBIUM-PTP670-MIB", "notificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ptpCompliance = ptpCompliance.setStatus('current')
if mibBuilder.loadTexts: ptpCompliance.setDescription('The compliance statement for the Cambium PTP MIB')
dfsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 3)).setObjects(("CAMBIUM-PTP670-MIB", "dfsTableNumber"), ("CAMBIUM-PTP670-MIB", "extendedSpectrumScanning"), ("CAMBIUM-PTP670-MIB", "dfsMeans"), ("CAMBIUM-PTP670-MIB", "dfsNineNinePointNinePercentiles"), ("CAMBIUM-PTP670-MIB", "dfsPeaks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dfsGroup = dfsGroup.setStatus('current')
if mibBuilder.loadTexts: dfsGroup.setDescription('The dfs object group.')
bridgeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 4)).setObjects(("CAMBIUM-PTP670-MIB", "localPacketFiltering"), ("CAMBIUM-PTP670-MIB", "packetsToInternalStack"), ("CAMBIUM-PTP670-MIB", "packetsFromInternalStack"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    bridgeGroup = bridgeGroup.setStatus('current')
if mibBuilder.loadTexts: bridgeGroup.setDescription('The bridge object group.')
configurationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 5)).setObjects(("CAMBIUM-PTP670-MIB", "iPv4Address"), ("CAMBIUM-PTP670-MIB", "subnetMask"), ("CAMBIUM-PTP670-MIB", "gatewayIPAddress"), ("CAMBIUM-PTP670-MIB", "targetMACAddress"), ("CAMBIUM-PTP670-MIB", "masterSlaveMode"), ("CAMBIUM-PTP670-MIB", "maximumTransmitPower"), ("CAMBIUM-PTP670-MIB", "antennaGain"), ("CAMBIUM-PTP670-MIB", "cableLoss"), ("CAMBIUM-PTP670-MIB", "eIRP"), ("CAMBIUM-PTP670-MIB", "channelBandwidth"), ("CAMBIUM-PTP670-MIB", "linkName"), ("CAMBIUM-PTP670-MIB", "siteName"), ("CAMBIUM-PTP670-MIB", "accessMethod"), ("CAMBIUM-PTP670-MIB", "groupID"), ("CAMBIUM-PTP670-MIB", "iPv6Address"), ("CAMBIUM-PTP670-MIB", "iPVersion"), ("CAMBIUM-PTP670-MIB", "iPv6AutoConfiguredLinkLocalAddress"), ("CAMBIUM-PTP670-MIB", "iPv6PrefixLength"), ("CAMBIUM-PTP670-MIB", "iPv6GatewayAddress"), ("CAMBIUM-PTP670-MIB", "remoteInternetAddressTypeLinked"), ("CAMBIUM-PTP670-MIB", "remoteInternetAddressLinked"), ("CAMBIUM-PTP670-MIB", "subbandLowestFrequency"), ("CAMBIUM-PTP670-MIB", "subbandHighestFrequency"), ("CAMBIUM-PTP670-MIB", "enableTransmission"), ("CAMBIUM-PTP670-MIB", "antennaSelection"), ("CAMBIUM-PTP670-MIB", "transmitterChannels"), ("CAMBIUM-PTP670-MIB", "wirelessTopology"), ("CAMBIUM-PTP670-MIB", "configurationInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "unitName"), ("CAMBIUM-PTP670-MIB", "authorizationMethod"), ("CAMBIUM-PTP670-MIB", "remoteUnitNameLinked"), ("CAMBIUM-PTP670-MIB", "remoteInternetAddressType"), ("CAMBIUM-PTP670-MIB", "remoteInternetAddress"), ("CAMBIUM-PTP670-MIB", "remoteUnitName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    configurationGroup = configurationGroup.setStatus('current')
if mibBuilder.loadTexts: configurationGroup.setDescription('The configuration object group.')
ethernetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 6)).setObjects(("CAMBIUM-PTP670-MIB", "mainPSUPortAutoNegotiation"), ("CAMBIUM-PTP670-MIB", "mainPSUPortAutoNegAdvertisement"), ("CAMBIUM-PTP670-MIB", "mainPSUPortAutoMdix"), ("CAMBIUM-PTP670-MIB", "mainPSUPortStatus"), ("CAMBIUM-PTP670-MIB", "mainPSUPortSpeedAndDuplex"), ("CAMBIUM-PTP670-MIB", "dataPortWirelessDownAlert"), ("CAMBIUM-PTP670-MIB", "useVLANForManagementInterfaces"), ("CAMBIUM-PTP670-MIB", "vLANManagementPriority"), ("CAMBIUM-PTP670-MIB", "vLANManagementVID"), ("CAMBIUM-PTP670-MIB", "auxPortStatus"), ("CAMBIUM-PTP670-MIB", "auxPortSpeedAndDuplex"), ("CAMBIUM-PTP670-MIB", "ethernetPriorityTableNumber"), ("CAMBIUM-PTP670-MIB", "l2CPPriorityTableNumber"), ("CAMBIUM-PTP670-MIB", "iPDSCPPriorityTableNumber"), ("CAMBIUM-PTP670-MIB", "mPLSTCPriorityTableNumber"), ("CAMBIUM-PTP670-MIB", "managementPortWirelessDownAlert"), ("CAMBIUM-PTP670-MIB", "qOSPriorityScheme"), ("CAMBIUM-PTP670-MIB", "unknownNetworkPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "dSCPManagementPriority"), ("CAMBIUM-PTP670-MIB", "dataBridgingStatusLinked"), ("CAMBIUM-PTP670-MIB", "mainPSUPortAllocation"), ("CAMBIUM-PTP670-MIB", "auxPortAllocation"), ("CAMBIUM-PTP670-MIB", "sFPPortAllocation"), ("CAMBIUM-PTP670-MIB", "dataPortPauseFrames"), ("CAMBIUM-PTP670-MIB", "sFPPortAutoNegotiation"), ("CAMBIUM-PTP670-MIB", "sFPPortAutoNegAdvertisement"), ("CAMBIUM-PTP670-MIB", "sFPPortAutoMdix"), ("CAMBIUM-PTP670-MIB", "sFPPortStatus"), ("CAMBIUM-PTP670-MIB", "sFPPortSpeedAndDuplex"), ("CAMBIUM-PTP670-MIB", "auxPortPowerOverEthernetOutput"), ("CAMBIUM-PTP670-MIB", "auxPortPowerOverEthernetOutputStatus"), ("CAMBIUM-PTP670-MIB", "syncETracking"), ("CAMBIUM-PTP670-MIB", "syncEEquipmentClock"), ("CAMBIUM-PTP670-MIB", "mainPSUPortQLRxOverwrite"), ("CAMBIUM-PTP670-MIB", "mainPSUPortSSMTx"), ("CAMBIUM-PTP670-MIB", "sFPPortSSMTx"), ("CAMBIUM-PTP670-MIB", "auxPortSSMTx"), ("CAMBIUM-PTP670-MIB", "syncETrackingState"), ("CAMBIUM-PTP670-MIB", "mainPSUPortQLRx"), ("CAMBIUM-PTP670-MIB", "auxPortQLRx"), ("CAMBIUM-PTP670-MIB", "sFPPortQLRx"), ("CAMBIUM-PTP670-MIB", "mainPSUPortQLTx"), ("CAMBIUM-PTP670-MIB", "auxPortQLTx"), ("CAMBIUM-PTP670-MIB", "sFPPortQLTx"), ("CAMBIUM-PTP670-MIB", "mainPSUPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "auxPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "sFPPortSyncEMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "mainPSUPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "auxPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "sFPPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "transparentClock"), ("CAMBIUM-PTP670-MIB", "transparentClockVLAN"), ("CAMBIUM-PTP670-MIB", "transparentClockVID"), ("CAMBIUM-PTP670-MIB", "mainPSUPortAcceptedQLRx"), ("CAMBIUM-PTP670-MIB", "auxPortAcceptedQLRx"), ("CAMBIUM-PTP670-MIB", "sFPPortAcceptedQLRx"), ("CAMBIUM-PTP670-MIB", "mainPSUPortSyncERxStatus"), ("CAMBIUM-PTP670-MIB", "auxPortSyncERxStatus"), ("CAMBIUM-PTP670-MIB", "sFPPortSyncERxStatus"), ("CAMBIUM-PTP670-MIB", "nIDULanPortStatus"), ("CAMBIUM-PTP670-MIB", "nIDULanPortSpeedAndDuplex"), ("CAMBIUM-PTP670-MIB", "oOBPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "nIDULanPortAutoNegotiation"), ("CAMBIUM-PTP670-MIB", "nIDULanPortAutoNegAdvertisement"), ("CAMBIUM-PTP670-MIB", "nIDULanPortAutoMdix"), ("CAMBIUM-PTP670-MIB", "nIDULanPortGigabitMasterSlaveStatus"), ("CAMBIUM-PTP670-MIB", "txMABFrames"), ("CAMBIUM-PTP670-MIB", "managementNetworkAccessEnabled"), ("CAMBIUM-PTP670-MIB", "transparentClockPort"), ("CAMBIUM-PTP670-MIB", "syncESlavePort"), ("CAMBIUM-PTP670-MIB", "sFPPortQLRxOverwrite"), ("CAMBIUM-PTP670-MIB", "ethernetInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsTableNumber"), ("CAMBIUM-PTP670-MIB", "ethernetPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "l2CPPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "iPDSCPPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "mPLSTCPriorityQueueMapping"), ("CAMBIUM-PTP670-MIB", "dataBridgingStatus"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsDataSource"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxOctets"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxFrames"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxBroadcasts"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxFramesWithError"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxFramesUndersize"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsRxFramesOversize"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsTxOctets"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsTxFrames"), ("CAMBIUM-PTP670-MIB", "ethernetStatisticsTxBroadcasts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ethernetGroup = ethernetGroup.setStatus('current')
if mibBuilder.loadTexts: ethernetGroup.setDescription('The ethernet object group.')
tDMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 7)).setObjects(("CAMBIUM-PTP670-MIB", "tDMInterfaceControl"), ("CAMBIUM-PTP670-MIB", "tDMInterfaceStatus"), ("CAMBIUM-PTP670-MIB", "tDMEnabledChannels"), ("CAMBIUM-PTP670-MIB", "tdmTableNumber"), ("CAMBIUM-PTP670-MIB", "tDMConfigurationMismatch"), ("CAMBIUM-PTP670-MIB", "lowestTDMModulationMode"), ("CAMBIUM-PTP670-MIB", "tDMChannelStatus"), ("CAMBIUM-PTP670-MIB", "tDMChannelLineCode"), ("CAMBIUM-PTP670-MIB", "tDMChannelCableLength"), ("CAMBIUM-PTP670-MIB", "tDMChannelLoopback"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tDMGroup = tDMGroup.setStatus('current')
if mibBuilder.loadTexts: tDMGroup.setDescription('The tDM object group.')
licenseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 8)).setObjects(("CAMBIUM-PTP670-MIB", "regulatoryBand"), ("CAMBIUM-PTP670-MIB", "productVariant"), ("CAMBIUM-PTP670-MIB", "productName"), ("CAMBIUM-PTP670-MIB", "frequencyVariant"), ("CAMBIUM-PTP670-MIB", "sNMPv3Enable"), ("CAMBIUM-PTP670-MIB", "licenseVersion"), ("CAMBIUM-PTP670-MIB", "licenseUnitSerialNumber"), ("CAMBIUM-PTP670-MIB", "licenseIssueNumber"), ("CAMBIUM-PTP670-MIB", "licenseCountry"), ("CAMBIUM-PTP670-MIB", "licenseNumberOfRegulatoryBands"), ("CAMBIUM-PTP670-MIB", "licenseBandwidthCap"), ("CAMBIUM-PTP670-MIB", "licenseEncryption"), ("CAMBIUM-PTP670-MIB", "licenseSecurityLevel"), ("CAMBIUM-PTP670-MIB", "licenseGroupAccess"), ("CAMBIUM-PTP670-MIB", "licenseOOBManagementSupport"), ("CAMBIUM-PTP670-MIB", "licenseSFPPortSupport"), ("CAMBIUM-PTP670-MIB", "licenseAuxiliaryPortSupport"), ("CAMBIUM-PTP670-MIB", "licenseCapacity"), ("CAMBIUM-PTP670-MIB", "licenseMaxNumberOfTDMChannels"), ("CAMBIUM-PTP670-MIB", "licenseIEEE1588Support"), ("CAMBIUM-PTP670-MIB", "licenseSyncESupport"), ("CAMBIUM-PTP670-MIB", "licenseIPv6Support"), ("CAMBIUM-PTP670-MIB", "licenseMinimumFirmwareVersion"), ("CAMBIUM-PTP670-MIB", "licenseFullCapabilityTrialStatus"), ("CAMBIUM-PTP670-MIB", "licenseRemainingTrialPeriod"), ("CAMBIUM-PTP670-MIB", "licenseRemainingTrialPeriodAlarm"), ("CAMBIUM-PTP670-MIB", "capacityVariantMismatchLinked"), ("CAMBIUM-PTP670-MIB", "licenseTDDSyncSupport"), ("CAMBIUM-PTP670-MIB", "licenseMaxLinkRange"), ("CAMBIUM-PTP670-MIB", "licenseTrialPeriod"), ("CAMBIUM-PTP670-MIB", "licenseRARSupport"), ("CAMBIUM-PTP670-MIB", "licenseGasGroup"), ("CAMBIUM-PTP670-MIB", "licenseLongMinimumFirmwareVersion"), ("CAMBIUM-PTP670-MIB", "licenseHCMPSupport"), ("CAMBIUM-PTP670-MIB", "licenseInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "licenseTLSRekey"), ("CAMBIUM-PTP670-MIB", "licenseAdvanceHCMPSupport"), ("CAMBIUM-PTP670-MIB", "licenseMinFirmwareVersionPTP650Emulation"), ("CAMBIUM-PTP670-MIB", "capacityVariantMismatch"), ("CAMBIUM-PTP670-MIB", "licenseRegulatoryBandsList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    licenseGroup = licenseGroup.setStatus('current')
if mibBuilder.loadTexts: licenseGroup.setDescription('The license object group.')
managementGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 9)).setObjects(("CAMBIUM-PTP670-MIB", "targetRange"), ("CAMBIUM-PTP670-MIB", "rangingMode"), ("CAMBIUM-PTP670-MIB", "installStatusLinked"), ("CAMBIUM-PTP670-MIB", "installArmState"), ("CAMBIUM-PTP670-MIB", "tFTPServerPortNumber"), ("CAMBIUM-PTP670-MIB", "tFTPSoftwareUpgradeFileName"), ("CAMBIUM-PTP670-MIB", "tFTPStartSoftwareUpgrade"), ("CAMBIUM-PTP670-MIB", "tFTPSoftwareUpgradeStatus"), ("CAMBIUM-PTP670-MIB", "tFTPSoftwareUpgradeStatusText"), ("CAMBIUM-PTP670-MIB", "tFTPSoftwareUpgradeStatusAdditionalText"), ("CAMBIUM-PTP670-MIB", "hTTPAccessEnabled"), ("CAMBIUM-PTP670-MIB", "telnetAccessEnabled"), ("CAMBIUM-PTP670-MIB", "hTTPPortNumber"), ("CAMBIUM-PTP670-MIB", "hTTPSPortNumber"), ("CAMBIUM-PTP670-MIB", "telnetPortNumber"), ("CAMBIUM-PTP670-MIB", "hTTPSAccessEnabled"), ("CAMBIUM-PTP670-MIB", "tFTPServerInternetAddressType"), ("CAMBIUM-PTP670-MIB", "tFTPServerInternetAddress"), ("CAMBIUM-PTP670-MIB", "lowestDataModulationMode"), ("CAMBIUM-PTP670-MIB", "tFTPClient"), ("CAMBIUM-PTP670-MIB", "mgmtInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "tFTPServerResolvedInternetAddress"), ("CAMBIUM-PTP670-MIB", "installationMode"), ("CAMBIUM-PTP670-MIB", "installStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    managementGroup = managementGroup.setStatus('current')
if mibBuilder.loadTexts: managementGroup.setDescription('The management object group.')
phyControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 10)).setObjects(("CAMBIUM-PTP670-MIB", "linkSymmetry"), ("CAMBIUM-PTP670-MIB", "userConfiguredMaxModulationMode"), ("CAMBIUM-PTP670-MIB", "linkModeOptimization"), ("CAMBIUM-PTP670-MIB", "txColorCode"), ("CAMBIUM-PTP670-MIB", "rxColorCode"), ("CAMBIUM-PTP670-MIB", "remoteMaximumTransmitPowerLinked"), ("CAMBIUM-PTP670-MIB", "phyControlInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "remoteMaximumTransmitPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    phyControlGroup = phyControlGroup.setStatus('current')
if mibBuilder.loadTexts: phyControlGroup.setDescription('The phyControl object group.')
phyStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 12)).setObjects(("CAMBIUM-PTP670-MIB", "linkLossLinked"), ("CAMBIUM-PTP670-MIB", "receivePowerLinked"), ("CAMBIUM-PTP670-MIB", "vectorErrorLinked"), ("CAMBIUM-PTP670-MIB", "transmitPowerLinked"), ("CAMBIUM-PTP670-MIB", "receiveChannel"), ("CAMBIUM-PTP670-MIB", "transmitChannel"), ("CAMBIUM-PTP670-MIB", "receiveFreqMHz"), ("CAMBIUM-PTP670-MIB", "transmitFreqMHz"), ("CAMBIUM-PTP670-MIB", "signalStrengthRatioLinked"), ("CAMBIUM-PTP670-MIB", "receiveFreqKHz"), ("CAMBIUM-PTP670-MIB", "transmitFreqKHz"), ("CAMBIUM-PTP670-MIB", "rawReceivePowerLinked"), ("CAMBIUM-PTP670-MIB", "rangeLinked"), ("CAMBIUM-PTP670-MIB", "receiveModulationModeLinked"), ("CAMBIUM-PTP670-MIB", "transmitModulationModeLinked"), ("CAMBIUM-PTP670-MIB", "searchStateLinked"), ("CAMBIUM-PTP670-MIB", "remoteMACAddressLinked"), ("CAMBIUM-PTP670-MIB", "phyInstancedStatusTableNumber"), ("CAMBIUM-PTP670-MIB", "tempPcb"), ("CAMBIUM-PTP670-MIB", "linkLoss"), ("CAMBIUM-PTP670-MIB", "receivePower"), ("CAMBIUM-PTP670-MIB", "vectorError"), ("CAMBIUM-PTP670-MIB", "signalStrengthRatio"), ("CAMBIUM-PTP670-MIB", "range"), ("CAMBIUM-PTP670-MIB", "receiveModulationMode"), ("CAMBIUM-PTP670-MIB", "transmitModulationMode"), ("CAMBIUM-PTP670-MIB", "searchState"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"), ("CAMBIUM-PTP670-MIB", "rawReceivePower"), ("CAMBIUM-PTP670-MIB", "transmitPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    phyStatusGroup = phyStatusGroup.setStatus('current')
if mibBuilder.loadTexts: phyStatusGroup.setDescription('The phyStatus object group.')
alarmsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 13)).setObjects(("CAMBIUM-PTP670-MIB", "unitOutOfCalibration"), ("CAMBIUM-PTP670-MIB", "incompatibleRegulatoryBandsLinked"), ("CAMBIUM-PTP670-MIB", "noWirelessChannelAvailable"), ("CAMBIUM-PTP670-MIB", "wirelessLinkDisabledWarning"), ("CAMBIUM-PTP670-MIB", "mainPSUPortDisabledWarning"), ("CAMBIUM-PTP670-MIB", "sFPError"), ("CAMBIUM-PTP670-MIB", "mainPSUPortConfigurationMismatch"), ("CAMBIUM-PTP670-MIB", "incompatibleMasterAndSlaveLinked"), ("CAMBIUM-PTP670-MIB", "tDDSynchronizationStatus"), ("CAMBIUM-PTP670-MIB", "auxPortDisabledWarning"), ("CAMBIUM-PTP670-MIB", "tDDSynchronizationAlarm"), ("CAMBIUM-PTP670-MIB", "linkModeOptimizationMismatchLinked"), ("CAMBIUM-PTP670-MIB", "auxPortConfigurationMismatch"), ("CAMBIUM-PTP670-MIB", "secureModeAlarm"), ("CAMBIUM-PTP670-MIB", "dataBridgingStatusAlarmLinked"), ("CAMBIUM-PTP670-MIB", "sFPPortDisabledWarning"), ("CAMBIUM-PTP670-MIB", "sFPPortConfigurationMismatch"), ("CAMBIUM-PTP670-MIB", "maxLinkRangeExceededLinked"), ("CAMBIUM-PTP670-MIB", "nIDULanPortDisabledWarning"), ("CAMBIUM-PTP670-MIB", "nIDULanPortConfigurationMismatch"), ("CAMBIUM-PTP670-MIB", "portAllocationMismatchLinked"), ("CAMBIUM-PTP670-MIB", "transparentClockSourcePortAlarm"), ("CAMBIUM-PTP670-MIB", "alarmInstancedTableNumber"), ("CAMBIUM-PTP670-MIB", "secureLicenseSignatureAlarm"), ("CAMBIUM-PTP670-MIB", "incompatibleMasterAndSlave"), ("CAMBIUM-PTP670-MIB", "linkModeOptimizationMismatch"), ("CAMBIUM-PTP670-MIB", "dataBridgingStatusAlarm"), ("CAMBIUM-PTP670-MIB", "maxLinkRangeExceeded"), ("CAMBIUM-PTP670-MIB", "portAllocationMismatch"), ("CAMBIUM-PTP670-MIB", "wirelessLinkStatusAlarm"), ("CAMBIUM-PTP670-MIB", "incompatibleRegulatoryBands"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    alarmsGroup = alarmsGroup.setStatus('current')
if mibBuilder.loadTexts: alarmsGroup.setDescription('The alarms object group.')
apcGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 14)).setObjects(("CAMBIUM-PTP670-MIB", "atpcHcmpMasterTargetRxPower"), ("CAMBIUM-PTP670-MIB", "atpcHcmpMasterTxPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    apcGroup = apcGroup.setStatus('current')
if mibBuilder.loadTexts: apcGroup.setDescription('The apc object group.')
smtpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 15)).setObjects(("CAMBIUM-PTP670-MIB", "sMTPEmailAlert"), ("CAMBIUM-PTP670-MIB", "sMTPServerPortNumber"), ("CAMBIUM-PTP670-MIB", "sMTPSourceEmailAddress"), ("CAMBIUM-PTP670-MIB", "sMTPDestinationEmailAddress"), ("CAMBIUM-PTP670-MIB", "sMTPEnabledMessages"), ("CAMBIUM-PTP670-MIB", "sMTPServerInternetAddressType"), ("CAMBIUM-PTP670-MIB", "sMTPServerInternetAddress"), ("CAMBIUM-PTP670-MIB", "sMTPServerResolvedInternetAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smtpGroup = smtpGroup.setStatus('current')
if mibBuilder.loadTexts: smtpGroup.setDescription('The smtp object group.')
snmpControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 16)).setObjects(("CAMBIUM-PTP670-MIB", "sNMPPortNumber"), ("CAMBIUM-PTP670-MIB", "sNMPCommunityString"), ("CAMBIUM-PTP670-MIB", "sNMPTrapTableNumber"), ("CAMBIUM-PTP670-MIB", "sNMPTrapVersion"), ("CAMBIUM-PTP670-MIB", "sNMPEnabledTraps"), ("CAMBIUM-PTP670-MIB", "enabledDiagnosticAlarms"), ("CAMBIUM-PTP670-MIB", "sNMPSendAllTrapsAtStartup"), ("CAMBIUM-PTP670-MIB", "sNMPTrapPortNumber"), ("CAMBIUM-PTP670-MIB", "sNMPTrapInternetAddressType"), ("CAMBIUM-PTP670-MIB", "sNMPTrapInternetAddress"), ("CAMBIUM-PTP670-MIB", "sNMPTrapReceiverEnabled"), ("CAMBIUM-PTP670-MIB", "sNMPTrapResolvedInternetAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    snmpControlGroup = snmpControlGroup.setStatus('current')
if mibBuilder.loadTexts: snmpControlGroup.setDescription('The snmpControl object group.')
sntpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 17)).setObjects(("CAMBIUM-PTP670-MIB", "sNTPState"), ("CAMBIUM-PTP670-MIB", "sNTPPollInterval"), ("CAMBIUM-PTP670-MIB", "sNTPSync"), ("CAMBIUM-PTP670-MIB", "sNTPLastSync"), ("CAMBIUM-PTP670-MIB", "systemClock"), ("CAMBIUM-PTP670-MIB", "timeZone"), ("CAMBIUM-PTP670-MIB", "daylightSaving"), ("CAMBIUM-PTP670-MIB", "sNTPPrimaryServer"), ("CAMBIUM-PTP670-MIB", "sNTPPrimaryServerDeadTime"), ("CAMBIUM-PTP670-MIB", "sNTPServerRetries"), ("CAMBIUM-PTP670-MIB", "sNTPServerTimeout"), ("CAMBIUM-PTP670-MIB", "sNTPServerTableNumber"), ("CAMBIUM-PTP670-MIB", "sNTPServerPortNumber"), ("CAMBIUM-PTP670-MIB", "sNTPServerStatus"), ("CAMBIUM-PTP670-MIB", "sNTPServerInternetAddressType"), ("CAMBIUM-PTP670-MIB", "sNTPServerInternetAddress"), ("CAMBIUM-PTP670-MIB", "sNTPServerResolvedInternetAddress"), ("CAMBIUM-PTP670-MIB", "sNTPServerAuthenticationProtocol"), ("CAMBIUM-PTP670-MIB", "sNTPServerKeyIdentifier"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sntpGroup = sntpGroup.setStatus('current')
if mibBuilder.loadTexts: sntpGroup.setDescription('The sntp object group.')
resetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 18)).setObjects(("CAMBIUM-PTP670-MIB", "systemReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    resetGroup = resetGroup.setStatus('current')
if mibBuilder.loadTexts: resetGroup.setDescription('The reset object group.')
versionsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 19)).setObjects(("CAMBIUM-PTP670-MIB", "softwareVersion"), ("CAMBIUM-PTP670-MIB", "hardwareVersion"), ("CAMBIUM-PTP670-MIB", "secondarySoftwareVersion"), ("CAMBIUM-PTP670-MIB", "bootVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    versionsGroup = versionsGroup.setStatus('current')
if mibBuilder.loadTexts: versionsGroup.setDescription('The versions object group.')
pubStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 20)).setObjects(("CAMBIUM-PTP670-MIB", "receiveDataRateLinked"), ("CAMBIUM-PTP670-MIB", "transmitDataRateLinked"), ("CAMBIUM-PTP670-MIB", "aggregateDataRateLinked"), ("CAMBIUM-PTP670-MIB", "wirelessLinkAvailabilityLinked"), ("CAMBIUM-PTP670-MIB", "wirelessLinkStatusLinked"), ("CAMBIUM-PTP670-MIB", "byteErrorRatioLinked"), ("CAMBIUM-PTP670-MIB", "receiveModulationModeDetailLinked"), ("CAMBIUM-PTP670-MIB", "dataBridgingAvailabilityLinked"), ("CAMBIUM-PTP670-MIB", "pubInstancedStatsTableNumber"), ("CAMBIUM-PTP670-MIB", "receiveDataRate"), ("CAMBIUM-PTP670-MIB", "transmitDataRate"), ("CAMBIUM-PTP670-MIB", "aggregateDataRate"), ("CAMBIUM-PTP670-MIB", "wirelessLinkAvailability"), ("CAMBIUM-PTP670-MIB", "wirelessLinkStatus"), ("CAMBIUM-PTP670-MIB", "receiveModulationModeDetail"), ("CAMBIUM-PTP670-MIB", "dataBridgingAvailability"), ("CAMBIUM-PTP670-MIB", "byteErrorRatio"), ("CAMBIUM-PTP670-MIB", "wirelessOutEthernetOctets"), ("CAMBIUM-PTP670-MIB", "wirelessOutAllOctets"), ("CAMBIUM-PTP670-MIB", "wirelessOutOctets"), ("CAMBIUM-PTP670-MIB", "erroredSeconds"), ("CAMBIUM-PTP670-MIB", "severelyErroredSeconds"), ("CAMBIUM-PTP670-MIB", "unavailableSeconds"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pubStatsGroup = pubStatsGroup.setStatus('current')
if mibBuilder.loadTexts: pubStatsGroup.setDescription('The pubStats object group.')
encryptionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 22)).setObjects(("CAMBIUM-PTP670-MIB", "encryptionAlgorithm"), ("CAMBIUM-PTP670-MIB", "tLSMinimumSecurityLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    encryptionGroup = encryptionGroup.setStatus('current')
if mibBuilder.loadTexts: encryptionGroup.setDescription('The encryption object group.')
tDDControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 23)).setObjects(("CAMBIUM-PTP670-MIB", "tDDSynchronizationMode"), ("CAMBIUM-PTP670-MIB", "hCMPMaximumLinkRange"), ("CAMBIUM-PTP670-MIB", "maximumNumberOfSlaves"), ("CAMBIUM-PTP670-MIB", "hCMPLinkSymmetry"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tDDControlGroup = tDDControlGroup.setStatus('current')
if mibBuilder.loadTexts: tDDControlGroup.setDescription('The tDDControl object group.')
aAAControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 25)).setObjects(("CAMBIUM-PTP670-MIB", "userTableNumber"), ("CAMBIUM-PTP670-MIB", "userName"), ("CAMBIUM-PTP670-MIB", "userRole"), ("CAMBIUM-PTP670-MIB", "userEnabled"), ("CAMBIUM-PTP670-MIB", "userPassword"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    aAAControlGroup = aAAControlGroup.setStatus('current')
if mibBuilder.loadTexts: aAAControlGroup.setDescription('The aAAControl object group.')
syslogControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 24)).setObjects(("CAMBIUM-PTP670-MIB", "syslogClient"), ("CAMBIUM-PTP670-MIB", "syslogState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    syslogControlGroup = syslogControlGroup.setStatus('current')
if mibBuilder.loadTexts: syslogControlGroup.setDescription('The syslogControl object group.')
routerProtocolsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 26)).setObjects(("CAMBIUM-PTP670-MIB", "microwaveAdaptiveBandwidth"), ("CAMBIUM-PTP670-MIB", "mABNominalModulationMode"), ("CAMBIUM-PTP670-MIB", "mABTransmissionInterval"), ("CAMBIUM-PTP670-MIB", "mABHoldoffPeriod"), ("CAMBIUM-PTP670-MIB", "mABMaintenanceLevel"), ("CAMBIUM-PTP670-MIB", "useVLANForMABProtocol"), ("CAMBIUM-PTP670-MIB", "mABProtocolVID"), ("CAMBIUM-PTP670-MIB", "mABProtocolVLANPriority"), ("CAMBIUM-PTP670-MIB", "mABState"), ("CAMBIUM-PTP670-MIB", "mABNominalTransmitCapacity"), ("CAMBIUM-PTP670-MIB", "mABCurrentTransmitCapacity"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    routerProtocolsGroup = routerProtocolsGroup.setStatus('current')
if mibBuilder.loadTexts: routerProtocolsGroup.setDescription('The routerProtocols object group.')
cableDiagnosticsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 27)).setObjects(("CAMBIUM-PTP670-MIB", "cableDiagnosticsPorts"), ("CAMBIUM-PTP670-MIB", "cableDiagnosticsControl"), ("CAMBIUM-PTP670-MIB", "cableDiagnosticsWarning"), ("CAMBIUM-PTP670-MIB", "cableDiagnosticsResultTableNumber"), ("CAMBIUM-PTP670-MIB", "cableDiagnosticsResultsDateTime"), ("CAMBIUM-PTP670-MIB", "cableDiagPair1Results"), ("CAMBIUM-PTP670-MIB", "cableDiagPair1Distance"), ("CAMBIUM-PTP670-MIB", "cableDiagPair2Results"), ("CAMBIUM-PTP670-MIB", "cableDiagPair2Distance"), ("CAMBIUM-PTP670-MIB", "cableDiagPair3Results"), ("CAMBIUM-PTP670-MIB", "cableDiagPair3Distance"), ("CAMBIUM-PTP670-MIB", "cableDiagPair4Results"), ("CAMBIUM-PTP670-MIB", "cableDiagPair4Distance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cableDiagnosticsGroup = cableDiagnosticsGroup.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsGroup.setDescription('The cableDiagnostics object group.')
unitIdentificationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 28)).setObjects(("CAMBIUM-PTP670-MIB", "deviceMACAddress"), ("CAMBIUM-PTP670-MIB", "deviceESN"), ("CAMBIUM-PTP670-MIB", "deviceMSN"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    unitIdentificationGroup = unitIdentificationGroup.setStatus('current')
if mibBuilder.loadTexts: unitIdentificationGroup.setDescription('The unitIdentification object group.')
authorizationControlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 29)).setObjects(("CAMBIUM-PTP670-MIB", "authorizationControlTableNumber"), ("CAMBIUM-PTP670-MIB", "whitelistRMMacAddress"), ("CAMBIUM-PTP670-MIB", "whitelistRMEnabled"), ("CAMBIUM-PTP670-MIB", "blacklistRMMacAddress"), ("CAMBIUM-PTP670-MIB", "blacklistRMEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    authorizationControlGroup = authorizationControlGroup.setStatus('current')
if mibBuilder.loadTexts: authorizationControlGroup.setDescription('The authorizationControl object group.')
dNSGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 30)).setObjects(("CAMBIUM-PTP670-MIB", "dNSResolver"), ("CAMBIUM-PTP670-MIB", "dNSPrimaryServer"), ("CAMBIUM-PTP670-MIB", "dNSServerTableNumber"), ("CAMBIUM-PTP670-MIB", "dNSServerInternetAddressType"), ("CAMBIUM-PTP670-MIB", "dNSServerInternetAddress"), ("CAMBIUM-PTP670-MIB", "dNSServerPortNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dNSGroup = dNSGroup.setStatus('current')
if mibBuilder.loadTexts: dNSGroup.setDescription('The dNS object group.')
supplementaryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 96)).setObjects(("CAMBIUM-PTP670-MIB", "longitude"), ("CAMBIUM-PTP670-MIB", "latitude"), ("CAMBIUM-PTP670-MIB", "altitude"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    supplementaryGroup = supplementaryGroup.setStatus('current')
if mibBuilder.loadTexts: supplementaryGroup.setDescription('The supplementary object group.')
notificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 17713, 11, 98, 99)).setObjects(("CAMBIUM-PTP670-MIB", "channelChangeTrap"), ("CAMBIUM-PTP670-MIB", "dfsImpulsiveInterferenceTrap"), ("CAMBIUM-PTP670-MIB", "mainPSUPortStatusTrap"), ("CAMBIUM-PTP670-MIB", "mainPSUPortDisabledWarningTrap"), ("CAMBIUM-PTP670-MIB", "mainPSUPortConfigurationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "auxPortStatusTrap"), ("CAMBIUM-PTP670-MIB", "auxPortDisabledWarningTrap"), ("CAMBIUM-PTP670-MIB", "regulatoryBandTrap"), ("CAMBIUM-PTP670-MIB", "installStatusTrap"), ("CAMBIUM-PTP670-MIB", "installArmStateTrap"), ("CAMBIUM-PTP670-MIB", "unitOutOfCalibrationTrap"), ("CAMBIUM-PTP670-MIB", "auxPortPowerOverEthernetOutputStatusTrap"), ("CAMBIUM-PTP670-MIB", "incompatibleRegulatoryBandsTrap"), ("CAMBIUM-PTP670-MIB", "noWirelessChannelAvailableTrap"), ("CAMBIUM-PTP670-MIB", "wirelessLinkDisabledWarningTrap"), ("CAMBIUM-PTP670-MIB", "auxPortConfigurationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "sFPErrorTrap"), ("CAMBIUM-PTP670-MIB", "sFPPortStatusTrap"), ("CAMBIUM-PTP670-MIB", "incompatibleMasterAndSlaveTrap"), ("CAMBIUM-PTP670-MIB", "sNTPSyncTrap"), ("CAMBIUM-PTP670-MIB", "tDDSynchronizationAlarmTrap"), ("CAMBIUM-PTP670-MIB", "sFPPortDisabledWarningTrap"), ("CAMBIUM-PTP670-MIB", "sFPPortConfigurationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "linkModeOptimizationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "tDMInterfaceStatusTrap"), ("CAMBIUM-PTP670-MIB", "tDMChannelStatusTrap"), ("CAMBIUM-PTP670-MIB", "tDMChannelLoopbackTrap"), ("CAMBIUM-PTP670-MIB", "nIDULanPortStatusTrap"), ("CAMBIUM-PTP670-MIB", "syslogStateTrap"), ("CAMBIUM-PTP670-MIB", "syslogLocalNearlyFullTrap"), ("CAMBIUM-PTP670-MIB", "syslogLocalWrappedTrap"), ("CAMBIUM-PTP670-MIB", "syslogClientTrap"), ("CAMBIUM-PTP670-MIB", "secureModeAlarmTrap"), ("CAMBIUM-PTP670-MIB", "dataBridgingStatusAlarmTrap"), ("CAMBIUM-PTP670-MIB", "licenseRemainingTrialPeriodAlarmTrap"), ("CAMBIUM-PTP670-MIB", "capacityVariantMismatchTrap"), ("CAMBIUM-PTP670-MIB", "maxLinkRangeExceededTrap"), ("CAMBIUM-PTP670-MIB", "tDMConfigurationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "nIDULanPortDisabledWarningTrap"), ("CAMBIUM-PTP670-MIB", "nIDULanPortConfigurationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "portAllocationMismatchTrap"), ("CAMBIUM-PTP670-MIB", "wirelessLinkStatusAlarmTrap"), ("CAMBIUM-PTP670-MIB", "lbtDetectedTrap"), ("CAMBIUM-PTP670-MIB", "secureLicenseSignatureAlarmTrap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    notificationsGroup = notificationsGroup.setStatus('current')
if mibBuilder.loadTexts: notificationsGroup.setDescription('The notifications group.')
dfsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2), )
if mibBuilder.loadTexts: dfsTable.setStatus('current')
if mibBuilder.loadTexts: dfsTable.setDescription(' A table storing a snapshot of various DFS measurements for each channel')
dfsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "dfsTableIndex"))
if mibBuilder.loadTexts: dfsTableEntry.setStatus('current')
if mibBuilder.loadTexts: dfsTableEntry.setDescription('Table DfsTable')
configurationInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33), )
if mibBuilder.loadTexts: configurationInstancedTable.setStatus('current')
if mibBuilder.loadTexts: configurationInstancedTable.setDescription(' Instanced Public stats table.')
configurationInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "configurationInstancedTableIndex"))
if mibBuilder.loadTexts: configurationInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: configurationInstancedTableEntry.setDescription('Table ConfigurationInstancedTable')
ethernetPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 15), )
if mibBuilder.loadTexts: ethernetPriorityTable.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by Ethernet priority.')
ethernetPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "ethernetPriorityTableIndex"))
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableEntry.setDescription('Table EthernetPriorityTable')
l2CPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 17), )
if mibBuilder.loadTexts: l2CPPriorityTable.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by L2CP priority.')
l2CPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 17, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "l2CPPriorityTableIndex"))
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableEntry.setDescription('Table L2CPPriorityTable')
iPDSCPPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 19), )
if mibBuilder.loadTexts: iPDSCPPriorityTable.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTable.setDescription(' A priority queue mapping table. This is a list of packet queues indexed by L3 IP DSCP priority.')
iPDSCPPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 19, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "iPDSCPPriorityTableIndex"))
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableEntry.setDescription('Table IPDSCPPriorityTable')
mPLSTCPriorityTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 21), )
if mibBuilder.loadTexts: mPLSTCPriorityTable.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTable.setDescription(' A priority queue mapping table. This is a list of priority queues indexed by MPLS TC priority.')
mPLSTCPriorityTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 21, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "mPLSTCPriorityTableIndex"))
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableEntry.setDescription('Table MPLSTCPriorityTable')
ethernetInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 85), )
if mibBuilder.loadTexts: ethernetInstancedTable.setStatus('current')
if mibBuilder.loadTexts: ethernetInstancedTable.setDescription(' Instanced table showing the ethernet status')
ethernetInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 85, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "ethernetInstancedTableIndex"))
if mibBuilder.loadTexts: ethernetInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetInstancedTableEntry.setDescription('Table EthernetInstancedTable')
ethernetStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87), )
if mibBuilder.loadTexts: ethernetStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTable.setDescription(' Instanced table showing the ethernet statistics')
ethernetStatisticsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "ethernetStatisticsTableIndex"))
if mibBuilder.loadTexts: ethernetStatisticsTableEntry.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTableEntry.setDescription('Table EthernetStatisticsTable')
tdmTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5), )
if mibBuilder.loadTexts: tdmTable.setStatus('current')
if mibBuilder.loadTexts: tdmTable.setDescription(' A table storing a configuration and status for each TDM channel')
tdmTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "tdmTableIndex"))
if mibBuilder.loadTexts: tdmTableEntry.setStatus('current')
if mibBuilder.loadTexts: tdmTableEntry.setDescription('Table TdmTable')
licenseInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 8, 45), )
if mibBuilder.loadTexts: licenseInstancedTable.setStatus('current')
if mibBuilder.loadTexts: licenseInstancedTable.setDescription(' Instanced license table')
licenseInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 8, 45, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "licenseInstancedTableIndex"))
if mibBuilder.loadTexts: licenseInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: licenseInstancedTableEntry.setDescription('Table LicenseInstancedTable')
licenseRegulatoryBandsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 8, 18), )
if mibBuilder.loadTexts: licenseRegulatoryBandsTable.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTable.setDescription('')
licenseRegulatoryBandsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 8, 18, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "licenseRegulatoryBandsTableIndex"))
if mibBuilder.loadTexts: licenseRegulatoryBandsTableEntry.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTableEntry.setDescription('Table LicenseRegulatoryBandsTable')
mgmtInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 9, 24), )
if mibBuilder.loadTexts: mgmtInstancedTable.setStatus('current')
if mibBuilder.loadTexts: mgmtInstancedTable.setDescription(' Instanced management table.')
mgmtInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 9, 24, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "mgmtInstancedTableIndex"))
if mibBuilder.loadTexts: mgmtInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: mgmtInstancedTableEntry.setDescription('Table MgmtInstancedTable')
phyControlInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 10, 8), )
if mibBuilder.loadTexts: phyControlInstancedTable.setStatus('current')
if mibBuilder.loadTexts: phyControlInstancedTable.setDescription('')
phyControlInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 10, 8, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "phyControlInstancedTableIndex"))
if mibBuilder.loadTexts: phyControlInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: phyControlInstancedTableEntry.setDescription('Table PhyControlInstancedTable')
phyInstancedStatusTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19), )
if mibBuilder.loadTexts: phyInstancedStatusTable.setStatus('current')
if mibBuilder.loadTexts: phyInstancedStatusTable.setDescription(' Instanced PHY status table.')
phyInstancedStatusTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "phyInstancedStatusTableIndex"))
if mibBuilder.loadTexts: phyInstancedStatusTableEntry.setStatus('current')
if mibBuilder.loadTexts: phyInstancedStatusTableEntry.setDescription('Table PhyInstancedStatusTable')
alarmInstancedTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27), )
if mibBuilder.loadTexts: alarmInstancedTable.setStatus('current')
if mibBuilder.loadTexts: alarmInstancedTable.setDescription(' Instanced alarm table.')
alarmInstancedTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "alarmInstancedTableIndex"))
if mibBuilder.loadTexts: alarmInstancedTableEntry.setStatus('current')
if mibBuilder.loadTexts: alarmInstancedTableEntry.setDescription('Table AlarmInstancedTable')
sNMPTrapTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4), )
if mibBuilder.loadTexts: sNMPTrapTable.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTable.setDescription(' SNMP trap configuration table.')
sNMPTrapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "sNMPTrapTableIndex"))
if mibBuilder.loadTexts: sNMPTrapTableEntry.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableEntry.setDescription('Table SNMPTrapTable')
sNTPServerTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15), )
if mibBuilder.loadTexts: sNTPServerTable.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTable.setDescription('')
sNTPServerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "sNTPServerTableIndex"))
if mibBuilder.loadTexts: sNTPServerTableEntry.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableEntry.setDescription('Table SNTPServerTable')
pubInstancedStatsTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10), )
if mibBuilder.loadTexts: pubInstancedStatsTable.setStatus('current')
if mibBuilder.loadTexts: pubInstancedStatsTable.setDescription(' Instanced Public stats table.')
pubInstancedStatsTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "pubInstancedStatsTableIndex"))
if mibBuilder.loadTexts: pubInstancedStatsTableEntry.setStatus('current')
if mibBuilder.loadTexts: pubInstancedStatsTableEntry.setDescription('Table PubInstancedStatsTable')
userTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2), )
if mibBuilder.loadTexts: userTable.setStatus('current')
if mibBuilder.loadTexts: userTable.setDescription(' The User Table Control group contains objects specifically for user account management.')
userTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "userTableIndex"))
if mibBuilder.loadTexts: userTableEntry.setStatus('current')
if mibBuilder.loadTexts: userTableEntry.setDescription('Table UserTable')
cableDiagnosticsResultTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5), )
if mibBuilder.loadTexts: cableDiagnosticsResultTable.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTable.setDescription('')
cableDiagnosticsResultTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "cableDiagnosticsResultTableIndex"))
if mibBuilder.loadTexts: cableDiagnosticsResultTableEntry.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableEntry.setDescription('Table CableDiagnosticsResultTable')
authorizationControlTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2), )
if mibBuilder.loadTexts: authorizationControlTable.setStatus('current')
if mibBuilder.loadTexts: authorizationControlTable.setDescription(' AuthorizationControlTable - used to validate an RM trying to connect to it.')
authorizationControlTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "authorizationControlTableIndex"))
if mibBuilder.loadTexts: authorizationControlTableEntry.setStatus('current')
if mibBuilder.loadTexts: authorizationControlTableEntry.setDescription('Table AuthorizationControlTable')
dNSServerTable = MibTable((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4), )
if mibBuilder.loadTexts: dNSServerTable.setStatus('current')
if mibBuilder.loadTexts: dNSServerTable.setDescription('')
dNSServerTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4, 1), ).setIndexNames((0, "CAMBIUM-PTP670-MIB", "dNSServerTableIndex"))
if mibBuilder.loadTexts: dNSServerTableEntry.setStatus('current')
if mibBuilder.loadTexts: dNSServerTableEntry.setDescription('Table DNSServerTable')
dfsTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 305))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsTableNumber.setStatus('current')
if mibBuilder.loadTexts: dfsTableNumber.setDescription('Number of entries in the dfsTable')
extendedSpectrumScanning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: extendedSpectrumScanning.setStatus('current')
if mibBuilder.loadTexts: extendedSpectrumScanning.setDescription('Enables Extended Spectrum Scanning')
dfsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 305)))
if mibBuilder.loadTexts: dfsTableIndex.setStatus('current')
if mibBuilder.loadTexts: dfsTableIndex.setDescription('used to index values in the dfsTable.')
dfsMeans = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsMeans.setStatus('current')
if mibBuilder.loadTexts: dfsMeans.setDescription('Snapshot of DFS means')
dfsNineNinePointNinePercentiles = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsNineNinePointNinePercentiles.setStatus('current')
if mibBuilder.loadTexts: dfsNineNinePointNinePercentiles.setDescription('Snapshot of DFS 99.9 percentiles')
dfsPeaks = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dfsPeaks.setStatus('current')
if mibBuilder.loadTexts: dfsPeaks.setDescription('Snapshot of DFS peaks')
localPacketFiltering = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: localPacketFiltering.setStatus('current')
if mibBuilder.loadTexts: localPacketFiltering.setDescription('When Local Packet Filtering is Enabled, the unit keeps \n             track of the port (Main, SFP, Aux or Wireless) on which a \n             packet with a given MAC source address destined to the \n             management agent has been received. This MAC address to \n             port mapping is then used in order to route any response \n             from the management agent to the right port. When Local \n             Packet Filtering is Disabled, any Ethernet packet from \n             the management agent is sent to all ports.')
packetsToInternalStack = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 4, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsToInternalStack.setStatus('current')
if mibBuilder.loadTexts: packetsToInternalStack.setDescription('Total number of good packets the bridge has transmitted \n             to the internal TCP/IP stack.')
packetsFromInternalStack = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 4, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: packetsFromInternalStack.setStatus('current')
if mibBuilder.loadTexts: packetsFromInternalStack.setDescription('Total number of good packets the bridge has received \n             from the internal TCP/IP stack.')
iPv4Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv4Address.setStatus('current')
if mibBuilder.loadTexts: iPv4Address.setDescription('Internet protocol (IPv4) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
subnetMask = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetMask.setStatus('current')
if mibBuilder.loadTexts: subnetMask.setDescription('A subnet allows the flow of network traffic between \n             hosts to be segregated based on a network configuration. \n             By organizing hosts into logical groups, subnetting can \n             improve network security and performance.')
gatewayIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gatewayIPAddress.setStatus('current')
if mibBuilder.loadTexts: gatewayIPAddress.setDescription('The IPv4 address of a device on the current network that \n             acts as an IPv4 network gateway. A gateway acts as an \n             entrance / exit to packets from / to other networks')
targetMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: targetMACAddress.setStatus('current')
if mibBuilder.loadTexts: targetMACAddress.setDescription('MAC address of the unit forming the other end of the \n             link')
masterSlaveMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: masterSlaveMode.setStatus('current')
if mibBuilder.loadTexts: masterSlaveMode.setDescription('The wireless link operates using a master and slave \n             relationship')
maximumTransmitPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maximumTransmitPower.setStatus('current')
if mibBuilder.loadTexts: maximumTransmitPower.setDescription('Maximum transmit power the wireless unit is permitted to \n             use when establishing and maintaining the wireless link. \n             This may be reduced during installation')
antennaGain = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 610))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: antennaGain.setStatus('current')
if mibBuilder.loadTexts: antennaGain.setDescription('Antenna Gain. Expressed in 10ths of dBi.')
cableLoss = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableLoss.setStatus('current')
if mibBuilder.loadTexts: cableLoss.setDescription('Loss in the cable between the ODU and the antenna. \n             Expressed in 10ths of dB. NB: This attribute is ignored \n             for variants with an integral antenna.')
eIRP = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eIRP.setStatus('current')
if mibBuilder.loadTexts: eIRP.setDescription('Effective Isotropic Radiated Power (EIRP) describes the \n             strength of the radio signal leaving the wireless unit. \n             Expressed in 10ths of dBm')
channelBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bw30MHz", 0), ("bw15MHz", 1), ("bw10MHz", 2), ("bw5MHz", 3), ("bw20MHz", 4), ("bw56MHz", 5), ("bw50MHz", 6), ("bw40MHz", 7), ("bw45MHz", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelBandwidth.setStatus('current')
if mibBuilder.loadTexts: channelBandwidth.setDescription('This control sets the bandwidth of the transmit and \n             receive radio channels')
linkName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linkName.setStatus('current')
if mibBuilder.loadTexts: linkName.setDescription('Name of the link allocated by the System Administrator. \n             Used to establish a connection with the correct wireless \n             unit at the other end of the link. NOTE: The link name \n             MUST be the same at both ends of the link.')
siteName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: siteName.setStatus('current')
if mibBuilder.loadTexts: siteName.setDescription('This field contains a user-provided description of the \n             site name together with any additional notes')
accessMethod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("linkAccess", 0), ("linkNameAccess", 1), ("groupAccess", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessMethod.setStatus('current')
if mibBuilder.loadTexts: accessMethod.setDescription('ODUs must be configured in pairs before a link can be \n             established. The Access Method attribute determines how \n             the paired ODUs will recognise each other. For the Link \n             Access method, each ODU must be configured with Target \n             MAC Address equal to the MAC Address of the other unit. \n             For the Link Name Access method, both units must be \n             configured with the same Link Name. For the Group Access \n             method, both units must be configured with the same Group \n             ID.')
groupID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: groupID.setStatus('current')
if mibBuilder.loadTexts: groupID.setDescription('When Access Method is set to Group Access, the Group ID \n             identifies all the units belonging to the same group')
iPv6Address = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6Address.setStatus('current')
if mibBuilder.loadTexts: iPv6Address.setDescription('Internet protocol (IPv6) address. This address is used \n             by the family of Internet protocols to uniquely identify \n             the unit on a network.')
iPVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("iPv4", 0), ("iPv6", 1), ("dualIPv4andIPv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPVersion.setStatus('current')
if mibBuilder.loadTexts: iPVersion.setDescription('IP protocol selection. Choice of IPv4, IPv6 or Dual.')
iPv6AutoConfiguredLinkLocalAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setStatus('current')
if mibBuilder.loadTexts: iPv6AutoConfiguredLinkLocalAddress.setDescription('The auto configured link local IPv6 address')
iPv6PrefixLength = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6PrefixLength.setStatus('current')
if mibBuilder.loadTexts: iPv6PrefixLength.setDescription('IPv6 prefix length')
iPv6GatewayAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 39))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPv6GatewayAddress.setStatus('current')
if mibBuilder.loadTexts: iPv6GatewayAddress.setDescription('The IPv6 address of a device on the current network that \n             is currently acting as an IPv6 network gateway. A gateway \n             acts as an entrance / exit to packets from / to other \n             networks.')
remoteInternetAddressTypeLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddressTypeLinked.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddressTypeLinked.setDescription('The type of Internet address specified by the associated \n             remoteInternetAddressType.')
remoteInternetAddressLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 25), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddressLinked.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddressLinked.setDescription('INET address used to identify the peer wireless unit')
subbandLowestFrequency = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: subbandLowestFrequency.setStatus('current')
if mibBuilder.loadTexts: subbandLowestFrequency.setDescription('Lowest center frequency of the subset of channels.')
subbandHighestFrequency = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: subbandHighestFrequency.setStatus('current')
if mibBuilder.loadTexts: subbandHighestFrequency.setDescription('Highest center frequency of the subset of channels.')
enableTransmission = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("muted", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableTransmission.setStatus('current')
if mibBuilder.loadTexts: enableTransmission.setDescription('Control for enabling/disabling the radio transmitter of \n             the Master. Note: Use Web Properties to control this \n             feature.')
antennaSelection = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("integrated", 0), ("connectorized", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: antennaSelection.setStatus('current')
if mibBuilder.loadTexts: antennaSelection.setDescription('Antenna Selection. Choice of Integrated or \n             Connectorized')
transmitterChannels = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("handV", 0), ("hOnly", 1), ("vOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transmitterChannels.setStatus('current')
if mibBuilder.loadTexts: transmitterChannels.setDescription('To select transmitter channel(s) (H,V)')
wirelessTopology = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("highCapacityMultiPoint", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessTopology.setStatus('current')
if mibBuilder.loadTexts: wirelessTopology.setDescription('This attribute determines whether the device operates as \n             part of a PTP or an HCMP network topology.')
configurationInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configurationInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: configurationInstancedTableNumber.setDescription('Number of entries in the ConfigurationInstancedTable.')
unitName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unitName.setStatus('current')
if mibBuilder.loadTexts: unitName.setDescription('This field contains user-provided name for this unit')
authorizationMethod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("whitelist", 0), ("blacklist", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authorizationMethod.setStatus('current')
if mibBuilder.loadTexts: authorizationMethod.setDescription('Authorization Method to be used - Whitelist or \n             Blacklist')
remoteUnitNameLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 5, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteUnitNameLinked.setStatus('current')
if mibBuilder.loadTexts: remoteUnitNameLinked.setDescription('This field contains user-provided name of the peer \n             received over the wireless link')
configurationInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: configurationInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: configurationInstancedTableIndex.setDescription('Used to index the ConfigurationInstancedTable.')
remoteInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddressType.setDescription('The type of Internet address specified by the associated \n             remoteInternetAddressType.')
remoteInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteInternetAddress.setStatus('current')
if mibBuilder.loadTexts: remoteInternetAddress.setDescription('INET address used to identify the peer wireless unit')
remoteUnitName = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 5, 33, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteUnitName.setStatus('current')
if mibBuilder.loadTexts: remoteUnitName.setDescription('This field contains user-provided name of the peer \n             received over the wireless link')
mainPSUPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoNegotiation.setDescription('This controls whether the local Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
mainPSUPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 2), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoNegAdvertisement.setDescription('This sets the different Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
mainPSUPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
mainPSUPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortStatus.setDescription('Current status of the Main PSU Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSpeedAndDuplex.setDescription('The current speed and duplex of the Main PSU Ethernet \n             link')
dataPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setStatus('current')
if mibBuilder.loadTexts: dataPortWirelessDownAlert.setDescription('When enabled, this causes the Ethernet link to be \n             dropped briefly when the wireless link drops. This is so \n             that spanning tree algorithms can quickly detect that \n             there is a problem.')
useVLANForManagementInterfaces = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("noVLANTagging", 0), ("iEEE8021QTaggedCTagType8100", 1), ("iEEE8021adTaggedSTagorBTagType88a8", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setStatus('current')
if mibBuilder.loadTexts: useVLANForManagementInterfaces.setDescription('This controls whether the management interfaces \n             (WWW/SNMP/SMTP/SNTP) use VLAN tags or not. NB: The new \n             setting will only take effect after a system reboot')
vLANManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("p0", 0), ("p1", 1), ("p2", 2), ("p3", 3), ("p4", 4), ("p5", 5), ("p6", 6), ("p7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementPriority.setStatus('current')
if mibBuilder.loadTexts: vLANManagementPriority.setDescription('This VLAN Priority (0-7) will be included in packets \n             generated by the management interfaces')
vLANManagementVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vLANManagementVID.setStatus('current')
if mibBuilder.loadTexts: vLANManagementVID.setDescription('This VLAN VID (0-4094) will be included in packets \n             generated by the management interfaces. Note the new \n             setting will only take effect after a system reboot')
auxPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortStatus.setDescription('Current status of the Aux Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
auxPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: auxPortSpeedAndDuplex.setDescription('The current speed and duplex of the Aux Ethernet link')
ethernetPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(9, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableNumber.setDescription('Number of entries in the vLANPriorityTable.')
l2CPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableNumber.setDescription('Number of entries in the l2CPPriorityTable.')
iPDSCPPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableNumber.setDescription('Number of entries in the iPDSCPPriorityTable.')
mPLSTCPriorityTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableNumber.setDescription('Number of entries in the mPLSTCPriorityTable.')
managementPortWirelessDownAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setStatus('current')
if mibBuilder.loadTexts: managementPortWirelessDownAlert.setDescription('When enabled, this causes the management link to be \n             dropped briefly when the wireless link drops. This is so \n             that spanning tree algorithms can quickly detect that \n             there is a problem.')
qOSPriorityScheme = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ethernet", 0), ("iPMPLS", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qOSPriorityScheme.setStatus('current')
if mibBuilder.loadTexts: qOSPriorityScheme.setDescription('Selects classification based on fields in the Ethernet \n             header (Layer 2) or in the Network header (Layer 3). The \n             unit recognises two network layer protocols: IP and MPLS')
unknownNetworkPriorityQueueMapping = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: unknownNetworkPriorityQueueMapping.setDescription('Configures the classification of unknown network \n             protocols to an egress queue at the wireless port. \n             Unknown means something other than IP and MPLS')
dSCPManagementPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dSCPManagementPriority.setStatus('current')
if mibBuilder.loadTexts: dSCPManagementPriority.setDescription('This Differentiated Services Code Point value will be \n             inserted in the IP Header of all IP Datagrams transmitted \n             by the management interfaces')
dataBridgingStatusLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatusLinked.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusLinked.setDescription('Current status of Ethernet Data traffic bridging over \n             the wireless link')
mainPSUPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAllocation.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAllocation.setDescription('Indicates the service or services supported by the Main \n             PSU Ethernet port')
auxPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortAllocation.setStatus('current')
if mibBuilder.loadTexts: auxPortAllocation.setDescription('Indicates the service or services supported by the Aux \n             Ethernet port')
sFPPortAllocation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 0), ("dataOnly", 1), ("dataandInBandManagement", 2), ("outofBandLocalManagement", 3), ("outofBandRemoteManagement", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAllocation.setStatus('current')
if mibBuilder.loadTexts: sFPPortAllocation.setDescription('Indicates the service or services supported by the SFP \n             Ethernet port')
dataPortPauseFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tunnel", 0), ("discard", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataPortPauseFrames.setStatus('current')
if mibBuilder.loadTexts: dataPortPauseFrames.setDescription('Controls whether the bridge tunnels or discards Layer 2 \n             PAUSE frames arriving at the Data Port. Such frames are \n             identified by the destination MAC Address being equal to \n             01-80-C2-00-00-01')
sFPPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoNegotiation.setDescription('This controls whether the local SFP Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
sFPPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 33), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoNegAdvertisement.setDescription('This sets the different SFP Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
sFPPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: sFPPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
sFPPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortStatus.setDescription('Current status of the SFP Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
sFPPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: sFPPortSpeedAndDuplex.setDescription('The current speed and duplex of the SFP Ethernet link')
auxPortPowerOverEthernetOutput = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutput.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutput.setDescription('The state of the Power Over Ethernet (PoE) output of the \n             Aux port. Enabling PoE output may lead to system \n             instability; please refer to the User Guide before \n             enabling this control')
auxPortPowerOverEthernetOutputStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("poEOutputOn", 0), ("poEOutputDisabled", 1), ("poEOutputEnabledbutNotActiveErrororNoLoadPresent", 2), ("poEOutputOverloadError", 3), ("poEOutputOverTempError", 4), ("poEOutputErrorDetected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatus.setDescription('Current status of the Power Over Ethernet (PoE) output \n             of the Aux port')
syncETracking = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("internalTDMUseOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syncETracking.setStatus('current')
if mibBuilder.loadTexts: syncETracking.setDescription('Controls whether Synchronous Ethernet (SyncE) network \n             synchronization is enabled.')
syncEEquipmentClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("eECOption1", 0), ("eECOption2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syncEEquipmentClock.setStatus('current')
if mibBuilder.loadTexts: syncEEquipmentClock.setDescription('EEC-Option 1 applies to synchronous Ethernet equipments \n             that are designed to interwork with networks optimized \n             for the 2048-kbit/s hierarchy. Corresponds to ITU-T G.813 \n             Option 1; EEC-Option 2 applies to synchronous Ethernet \n             equipments that are designed to interwork with networks \n             optimized for the 1544-kbit/s hierarchy. Corresponds to \n             Type IV clock from ITU-T G.812.')
mainPSUPortQLRxOverwrite = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("disabled", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mainPSUPortQLRxOverwrite.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLRxOverwrite.setDescription('Override for the Synchronous Ethernet (SyncE) received \n             Quality Level (QL) on the main PSU port.')
mainPSUPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mainPSUPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the Main PSU port')
sFPPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFPPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: sFPPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the SFP port')
auxPortSSMTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: auxPortSSMTx.setStatus('current')
if mibBuilder.loadTexts: auxPortSSMTx.setDescription('Controls whether the Synchronous Ethernet (SyncE) \n             Quality Level (QL) is transmitted on the Aux port')
syncETrackingState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 0), ("acquiringWirelessLock", 1), ("freeRunning", 2), ("lockedLocalAcquiringHoldover", 3), ("lockedLocalHoldoverAcquired", 4), ("holdover", 5), ("lockedRemoteAcquiringHoldover", 6), ("lockedRemoteHoldoverAcquired", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syncETrackingState.setStatus('current')
if mibBuilder.loadTexts: syncETrackingState.setDescription('The current state of Synchronous Ethernet (SyncE) \n             network synchronization.')
mainPSUPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortQLRx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the main PSU port.')
auxPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortQLRx.setStatus('current')
if mibBuilder.loadTexts: auxPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the auxiliary port.')
sFPPortQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortQLRx.setStatus('current')
if mibBuilder.loadTexts: sFPPortQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently being received on the SFP port.')
mainPSUPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortQLTx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the main PSU port.')
auxPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortQLTx.setStatus('current')
if mibBuilder.loadTexts: auxPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the auxiliary port.')
sFPPortQLTx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortQLTx.setStatus('current')
if mibBuilder.loadTexts: sFPPortQLTx.setDescription('The Synchronous Ethernet (SyncE) transmit Quality Level \n             (QL) of the SFP port.')
mainPSUPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSyncEMasterSlaveStatus.setDescription('The main PSU port Synchronous Ethernet (SyncE) \n             Master/Slave status')
auxPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortSyncEMasterSlaveStatus.setDescription('The auxiliary port Synchronous Ethernet (SyncE) \n             Master/Slave status')
sFPPortSyncEMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("master", 0), ("slave", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSyncEMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortSyncEMasterSlaveStatus.setDescription('The SFP port Synchronous Ethernet (SyncE) Master/Slave \n             status')
mainPSUPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortGigabitMasterSlaveStatus.setDescription('The main PSU port Gigabit Ethernet Master/Slave status')
auxPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortGigabitMasterSlaveStatus.setDescription('The auxiliary port Gigabit Ethernet Master/Slave status')
sFPPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortGigabitMasterSlaveStatus.setDescription('The SFP port Gigabit Ethernet Master/Slave status')
transparentClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClock.setStatus('current')
if mibBuilder.loadTexts: transparentClock.setDescription('This control enables the Precision Time Protocol \n             (IEEE-1588) Transparent Clock. Once enabled the unit will \n             modify the correction field in PTP event messages to take \n             account of the time these frames have been resident in \n             this system. This will happen for all PTP frames at Layer \n             2 & Layer 3 (IPv4 & IPv6) unless a transparent clock VLAN \n             is enabled.')
transparentClockVLAN = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("all", 0), ("sTagged", 1), ("cTagged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockVLAN.setStatus('current')
if mibBuilder.loadTexts: transparentClockVLAN.setDescription('If All is selected then all PTP frames will have their \n             correction fields modified with the residence time. If an \n             S-TAG or C-TAG is selected, only frames with this VLAN \n             tag and matching the VLAN ID in the Transparent Clock VID \n             will have their correction fields modified.')
transparentClockVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockVID.setStatus('current')
if mibBuilder.loadTexts: transparentClockVID.setDescription('The VLAN ID which frames must match if they are to be \n             corrected. Only valid when an S-TAG or C-TAG has been \n             selected.')
mainPSUPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the main PSU port.')
auxPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: auxPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the auxiliary port.')
sFPPortAcceptedQLRx = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("none", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12), ("qLFAILED", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortAcceptedQLRx.setStatus('current')
if mibBuilder.loadTexts: sFPPortAcceptedQLRx.setDescription('The Synchronous Ethernet (SyncE) Quality Level (QL) \n             currently accepted (validated) on the SFP port.')
mainPSUPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             main PSU port')
auxPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: auxPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             auxiliary port')
sFPPortSyncERxStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 66), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("good", 0), ("waittoRestore", 1), ("failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortSyncERxStatus.setStatus('current')
if mibBuilder.loadTexts: sFPPortSyncERxStatus.setDescription('The Synchronous Ethernet (SyncE) Receive Status of the \n             SFP port')
nIDULanPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 67), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("down", 0), ("copperLinkUp", 1), ("fiberLinkUp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortStatus.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortStatus.setDescription('Current status of the NIDU LAN Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
nIDULanPortSpeedAndDuplex = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 68), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("speed1000MbpsFullDuplex", 0), ("speed100MbpsFullDuplex", 1), ("speed100MbpsHalfDuplex", 2), ("speed10MbpsFullDuplex", 3), ("speed10MbpsHalfDuplex", 4), ("speedUnknown6", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortSpeedAndDuplex.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortSpeedAndDuplex.setDescription('The current speed and duplex of the Ethernet link to the \n             NIDU LAN Port')
oOBPriorityQueueMapping = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oOBPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: oOBPriorityQueueMapping.setDescription('Configures the classification of traffic to an egress \n             queue at the wireless port')
nIDULanPortAutoNegotiation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoNegotiation.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoNegotiation.setDescription('This controls whether the local Ethernet interface \n             configuration is automatically negotiated or forced. Do \n             not use a forced setting together with auto negotiation \n             at the Ethernet link partner. If you want to run your \n             Ethernet link at a fixed speed and duplex then you would \n             normally leave auto negotiation enabled and only enable \n             the single Auto Neg Advertisement option that you want \n             the link to run in - FORCING ETHERNET CONFIGURATION IS A \n             LAST RESORT WHICH SHOULD ONLY BE PERFORMED IF YOU ARE \n             HAVING PROBLEMS WITH AUTO NEGOTIATION - AND YOU MUST \n             ENSURE THAT YOU CONFIGURE BOTH THIS UNIT AND THE ETHERNET \n             LINK PARTNER TO WHICH IT IS CONNECTED IDENTICALLY (THE \n             LINK PARTNER MUST NOT HAVE AUTO NEGOTIATION ENABLED \n             EITHER, OTHERWISE A DUPLEX MISMATCH WILL OCCUR). NB: The \n             new setting will only take effect after a system reboot.')
nIDULanPortAutoNegAdvertisement = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 71), Bits().clone(namedValues=NamedValues(("negInvalid", 2), ("neg10MbpsHalfDuplex", 3), ("neg10MbpsFullDuplex", 4), ("neg100MbpsHalfDuplex", 5), ("neg100MbpsFullDuplex", 6), ("neg1000MbpsFullDuplex", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoNegAdvertisement.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoNegAdvertisement.setDescription('This sets the different Ethernet configurations that \n             will be advertised during auto negotiation. Note the new \n             setting will only take effect after a system reboot. \n             WARNING: Duplex mismatch may result if both ends of the \n             Ethernet link do not have the same settings. Do not auto \n             negotiation together with a fixed setting at the Ethernet \n             link partner. WARNING: Make sure that you select \n             option(s) that you know your connected equipment can \n             cater for!')
nIDULanPortAutoMdix = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortAutoMdix.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortAutoMdix.setDescription('This enables/disables the Auto MDI/MDIX capability. NB: \n             The new setting will only take effect after a system \n             reboot')
nIDULanPortGigabitMasterSlaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 73), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("master", 0), ("slave", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortGigabitMasterSlaveStatus.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortGigabitMasterSlaveStatus.setDescription('The NIDU LAN port Gigabit Ethernet Master/Slave status')
txMABFrames = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMABFrames.setStatus('current')
if mibBuilder.loadTexts: txMABFrames.setDescription('Number of MAB frames transmitted')
managementNetworkAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: managementNetworkAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: managementNetworkAccessEnabled.setDescription('When enabled the local Out-of-Band interface can be used \n             to access the remote management network. If not enabled \n             the local management agent can still be accessed from the \n             remote management network and the local Out-of-Band \n             interface')
transparentClockPort = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mainPSU", 0), ("aux", 1), ("sFP", 2), ("mainPSUplusAux", 3), ("mainPSUplusSFP", 4), ("auxplusSFP", 5), ("mainPSUplusAuxplusSFP", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: transparentClockPort.setStatus('current')
if mibBuilder.loadTexts: transparentClockPort.setDescription('IEEE 1588 Transparent Clock source')
syncESlavePort = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("mainPSUPort", 0), ("sFPPort", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syncESlavePort.setStatus('current')
if mibBuilder.loadTexts: syncESlavePort.setDescription('Select a Sync E Slave Port')
sFPPortQLRxOverwrite = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("disabled", 0), ("qLPRS", 1), ("qLSTU", 2), ("qLPRC", 3), ("qLST2", 4), ("qLSSUAQLTNC", 5), ("qLSSUB", 6), ("qLST3E", 7), ("qLEEC2QLST3", 8), ("qLEEC1QLSEC", 9), ("qLSMC", 10), ("qLPROV", 11), ("qLDNUQLDUS", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFPPortQLRxOverwrite.setStatus('current')
if mibBuilder.loadTexts: sFPPortQLRxOverwrite.setDescription('Override for the Synchronous Ethernet (SyncE) received \n             Quality Level (QL) on the SFP Port.')
ethernetInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 84), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: ethernetInstancedTableNumber.setDescription('Number of entries in the ethernetInstancedTable.')
ethernetStatisticsTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 6, 86), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsTableNumber.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTableNumber.setDescription('Number of entries in the ethernetStatisticsTable.')
ethernetPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("p0", 1), ("p1", 2), ("p2", 3), ("p3", 4), ("p4", 5), ("p5", 6), ("p6", 7), ("p7", 8), ("untagged", 9))))
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityTableIndex.setDescription('Ethernet priority flag, used to index values in the \n             ethernetPriorityTable')
ethernetPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: ethernetPriorityQueueMapping.setDescription('Configures the classification of this Ethernet priority \n             (also known as IEEE 802.1p value) to an egress queue at \n             the wireless port')
l2CPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("bridge", 1), ("mRP", 2), ("cFM", 3), ("rAPS", 4), ("eAPS", 5), ("pPPoEDiscoveryLCP", 6))))
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityTableIndex.setDescription('L2CP priority flag, used to index values in the \n             l2CPPriorityTable')
l2CPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: l2CPPriorityQueueMapping.setDescription('Configures the classification of this layer two control \n             protocol (L2CP) to an egress queue at the wireless port')
iPDSCPPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityTableIndex.setDescription('IP DSCP priority flag, used to index values in the \n             iPDSCPPriorityTable')
iPDSCPPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: iPDSCPPriorityQueueMapping.setDescription('Configures the classification of this IP differentiated \n             services code point (DSCP) value to an egress queue at \n             the wireless port')
mPLSTCPriorityTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityTableIndex.setDescription('MPLS TC priority flag, used to index values in the \n             mPLSTCPriorityTable')
mPLSTCPriorityQueueMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("q0", 0), ("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4), ("q5", 5), ("q6", 6), ("q7", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setStatus('current')
if mibBuilder.loadTexts: mPLSTCPriorityQueueMapping.setDescription('Configures the classification of this MPLS traffic class \n             (the field formerly known as EXP) to an egress queue at \n             the wireless port')
ethernetInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 85, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: ethernetInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: ethernetInstancedTableIndex.setDescription('Used to index the ethernetInstancedTable.')
dataBridgingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 85, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatus.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatus.setDescription('Current status of Ethernet Data traffic bridging over \n             the wireless link')
ethernetStatisticsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: ethernetStatisticsTableIndex.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTableIndex.setDescription('Used to index the ethernetStatisticsTable.')
ethernetStatisticsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsDataSource.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsDataSource.setDescription('This object identifies the ethernet interface that this \n             ethernetStatistics entry is configured to report. In \n             order to identify a particular interface, this object \n             shall identify the instance of the ifIndex object, \n             defined in RFC 2233 [17], for the desired interface. For \n             example, if an entry were to receive data from interface \n             #1, this object would be set to ifIndex.1.')
ethernetStatisticsRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxOctets.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxOctets.setDescription('Total number of octets (excluding framing bits but \n             including FCS octets) received from the LAN in good \n             packets')
ethernetStatisticsRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxFrames.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxFrames.setDescription('Total number of packets (including bad packets, \n             broadcast packets, and multicast packets) received')
ethernetStatisticsRxBroadcasts = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxBroadcasts.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxBroadcasts.setDescription('Number of good and bad broadcast packets received from \n             the LAN. Note that this does not include multicast \n             packets.')
ethernetStatisticsRxFramesWithError = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxFramesWithError.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxFramesWithError.setDescription('Number of frames received with errors. The errors can be \n             a frame check sequence (CRC) error, an alignment error or \n             an incorrect frame length')
ethernetStatisticsRxFramesUndersize = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxFramesUndersize.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxFramesUndersize.setDescription('Number of short frames (<64 Bytes) received from the LAN \n             with or without a valid CRC')
ethernetStatisticsRxFramesOversize = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsRxFramesOversize.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsRxFramesOversize.setDescription('Number of oversize frames received from the LAN with or \n             without a valid CRC')
ethernetStatisticsTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsTxOctets.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTxOctets.setDescription('Total number of octets transmitted to the LAN')
ethernetStatisticsTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsTxFrames.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTxFrames.setDescription('Total number of frames transmitted to the LAN')
ethernetStatisticsTxBroadcasts = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 6, 87, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethernetStatisticsTxBroadcasts.setStatus('current')
if mibBuilder.loadTexts: ethernetStatisticsTxBroadcasts.setDescription('Number of broadcast frames transmitted to the LAN. Note \n             that this does not include multicast packets.')
tDMInterfaceControl = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("e1", 1), ("t1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMInterfaceControl.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceControl.setDescription("The line interface type. If this is set to 'None' then \n             the TDM interfaces are disabled, and the TDM settings \n             will be ignored.")
tDMInterfaceStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("connectedNotConfigured", 1), ("notConnected", 2), ("nIDUdetectedonAUXport", 3), ("error", 4), ("codeDownloadInProgress", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMInterfaceStatus.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceStatus.setDescription("@Current status of the connection to the TDM Box. A \n             state of 'Up' on a green background indicates that the \n             TDM Box is connected OK. When connecting a TDM Box only \n             the Main Ethernet port should be used")
tDMEnabledChannels = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMEnabledChannels.setStatus('current')
if mibBuilder.loadTexts: tDMEnabledChannels.setDescription('The number of TDM channels enabled in the system')
tdmTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tdmTableNumber.setStatus('current')
if mibBuilder.loadTexts: tdmTableNumber.setDescription('Number of entries in the TdmTable')
tDMConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("linetypemismatch", 1), ("enabledchannelsmismatch", 2), ("linetypeandenabledchannelsmismatch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: tDMConfigurationMismatch.setDescription("Current status of the configuration of the TDM Box. A \n             state of 'Ok' on a green background indicates that the \n             TDM Box configuration is matched OK with the remote end.")
lowestTDMModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lowestTDMModulationMode.setStatus('current')
if mibBuilder.loadTexts: lowestTDMModulationMode.setDescription('The lowest modulation mode at which tdm data will be \n             sent. The effective lowest modulation mode is displayed \n             in the TDM Configuration page')
tdmTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tdmTableIndex.setStatus('current')
if mibBuilder.loadTexts: tdmTableIndex.setDescription('TDM Channel flag, used to index channels in the \n             TdmTable')
tDMChannelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 0), ("noSignalLocal", 1), ("noSignalRemote", 2), ("noSignalLocalandRemote", 3), ("remoteTiming", 4), ("noSignalLocalandRemoteTiming", 5), ("disabled", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelStatus.setStatus('current')
if mibBuilder.loadTexts: tDMChannelStatus.setDescription('Current status of the TDM channels. A value of 0 \n             indicates that a TDM channel is established')
tDMChannelLineCode = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("aMI", 0), ("b8ZSorHDB3", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelLineCode.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLineCode.setDescription('The line code setting of the TDM interfaces. This must \n             match the setting of the device connected to an \n             interface')
tDMChannelCableLength = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("feet133", 0), ("feet266", 1), ("feet399", 2), ("feet533", 3), ("feet655", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelCableLength.setStatus('current')
if mibBuilder.loadTexts: tDMChannelCableLength.setDescription('The lengths of the cables connected to the TDM \n             interfaces, measured in feet')
tDMChannelLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 7, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("copper", 1), ("wireless", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDMChannelLoopback.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLoopback.setDescription("The loopback status of TDM channels. This is intended \n             for installation testing and should be set to 'None' for \n             normal operation. The wire connections to a unit can be \n             tested by applying a 'Copper' loopback to the local unit. \n             The wireless connection to the remote unit can be tested \n             by applying a 'Wireless' loopback to the remote unit with \n             no loopback on the local unit. NB: a change of state may \n             generate an SNMP trap and/or SMTP email alert")
regulatoryBand = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("regInvalid", 0), ("reg158GHz", 1), ("reg258GHz", 2), ("reg358GHz", 3), ("reg458GHzWithRTTT", 4), ("reg558GHz", 5), ("reg658GHz", 6), ("reg754GHz", 7), ("reg854GHz", 8), ("reg954GHz", 9), ("reg1058GHz", 10), ("reg1158GHz", 11), ("reg1254GHz", 12), ("reg1354GHz", 13), ("reg1449GHzPublicSafety", 14), ("reg15", 15), ("reg1659GHz", 16), ("reg1759GHz", 17), ("reg1849GHzPublicSafety", 18), ("reg1958GHz", 19), ("reg2054GHz", 20), ("reg2154GHz", 21), ("reg2258GHz", 22), ("reg23", 23), ("reg2458GHz", 24), ("reg2558GHz", 25), ("reg2654GHz", 26), ("reg2758GHz", 27), ("reg2858GHz", 28), ("reg2958GHz", 29), ("reg3054GHz", 30), ("reg3158GHz", 31), ("reg3249GHzLicensed", 32), ("reg3349GHzETSIBroadbandDisasterRelief", 33), ("reg3458GHz", 34), ("reg3558GHz", 35), ("reg3654GHz", 36), ("reg3758GHz", 37), ("reg3852GHz", 38), ("reg3951GHzETSIBroadbandDisasterRelief", 39), ("reg4054GHz", 40), ("reg4154GHz", 41), ("reg4254GHz", 42), ("reg4354GHz", 43), ("reg4458GHz", 44), ("reg4558GHz", 45), ("reg4658GHz", 46), ("reg4758GHz", 47), ("reg4858GHz", 48), ("reg4958GHz", 49), ("reg5058GHz", 50), ("reg5158GHz", 51), ("reg5258GHz", 52), ("reg5358GHz", 53), ("reg5458GHz", 54), ("reg5558GHz", 55), ("reg5654GHz", 56), ("reg5754GHz", 57), ("reg5858GHz", 58), ("reg5958GHz", 59), ("reg6058GHz", 60), ("reg6149GHz", 61), ("reg6251GHz52GHz", 62), ("reg6352GHz", 63), ("reg6451GHz", 64), ("reg6551GHz", 65), ("reg6651GHz", 66), ("reg6752GHz", 67), ("reg6852GHz", 68), ("reg6952GHz", 69), ("reg7052GHz", 70), ("reg7152GHz", 71), ("reg7252GHz", 72), ("reg7352GHz", 73), ("reg7452GHz", 74), ("reg7552GHz", 75), ("reg7652GHz", 76), ("reg7752GHz", 77), ("reg7849GHz", 78), ("reg7954GHz", 79), ("reg8049GHz", 80), ("reg8147GHz", 81), ("reg8247GHz", 82), ("reg8352GHz", 83), ("reg8451GHz", 84), ("reg8551GHz52GHz", 85), ("reg8652GHz54GHz", 86), ("reg8758GHz", 87), ("reg8849GHz", 88), ("reg8949GHz", 89), ("reg9054GHzParabolicantenna", 90), ("reg9152GHzParabolicantenna", 91), ("reg9251GHzParabolicantenna", 92), ("reg9349GHz", 93), ("reg9449GHz", 94), ("reg9545GHz", 95), ("reg9648GHz", 96), ("reg9752GHz", 97), ("reg9849GHz27dBiantenna", 98), ("reg9949GHz29dBiantenna", 99), ("reg10048GHz", 100), ("reg10158GHz", 101), ("reg102", 102), ("reg103", 103), ("reg10458GHzNoRTTT", 104), ("reg105", 105), ("reg106", 106), ("reg107", 107), ("reg108", 108), ("reg109", 109), ("reg110", 110), ("reg111", 111), ("reg112", 112), ("reg113", 113), ("reg114", 114), ("reg115", 115), ("reg116", 116), ("reg117", 117), ("reg118", 118), ("reg119", 119), ("reg120", 120), ("reg121", 121), ("reg122", 122), ("reg123", 123), ("reg124", 124), ("reg125", 125), ("reg126", 126), ("reg127", 127), ("reg128", 128), ("reg129", 129), ("reg130", 130), ("reg131", 131), ("reg132", 132), ("reg133", 133), ("reg134", 134), ("reg135", 135), ("reg136", 136), ("reg137", 137), ("reg138", 138), ("reg139", 139), ("reg140", 140), ("reg141", 141), ("reg142", 142), ("reg143", 143), ("reg144", 144), ("reg145", 145), ("reg146", 146), ("reg147", 147), ("reg148", 148), ("reg149", 149), ("reg150", 150), ("reg151", 151), ("reg152", 152), ("reg153", 153), ("reg154", 154), ("reg155", 155), ("reg156", 156), ("reg157", 157), ("reg158", 158), ("reg159", 159), ("reg160", 160), ("reg161", 161), ("reg162", 162), ("reg163", 163), ("reg164", 164), ("reg165", 165), ("reg166", 166), ("reg167", 167), ("reg168", 168), ("reg169", 169), ("reg170", 170), ("reg171", 171), ("reg172", 172), ("reg173", 173), ("reg174", 174), ("reg175", 175), ("reg176", 176), ("reg177", 177), ("reg178", 178), ("reg179", 179), ("reg180", 180), ("reg181", 181), ("reg182", 182), ("reg183", 183), ("reg184", 184), ("reg185", 185), ("reg186", 186), ("reg187", 187), ("reg188", 188), ("reg189", 189), ("reg190", 190), ("reg191", 191), ("reg192", 192), ("reg193", 193), ("reg194", 194), ("reg195", 195), ("reg196", 196), ("reg197", 197), ("reg198", 198), ("reg199", 199), ("reg200", 200), ("reg201", 201), ("reg202", 202), ("reg203", 203), ("reg204", 204), ("reg205", 205), ("reg206", 206), ("reg207", 207), ("reg208", 208), ("reg209", 209), ("reg210", 210), ("reg211", 211), ("reg212", 212), ("reg213", 213), ("reg214", 214), ("reg215", 215), ("reg216", 216), ("reg217", 217), ("reg218", 218), ("reg219", 219), ("reg220", 220), ("reg221", 221), ("reg222", 222), ("reg223", 223), ("reg224", 224), ("reg225", 225), ("reg226", 226), ("reg227", 227), ("reg228", 228), ("reg229", 229), ("reg230", 230), ("reg231", 231), ("reg232", 232), ("reg233", 233), ("reg234", 234), ("reg235", 235), ("reg236", 236), ("reg237", 237), ("reg238", 238), ("reg239", 239), ("reg240", 240), ("reg241", 241), ("reg242", 242), ("reg243", 243), ("reg244", 244), ("reg245", 245), ("reg246", 246), ("reg247", 247), ("reg248", 248), ("reg249", 249), ("reg250", 250), ("reg251", 251), ("reg252", 252), ("reg253", 253), ("reg254", 254)) + NamedValues(("reg255", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: regulatoryBand.setStatus('current')
if mibBuilder.loadTexts: regulatoryBand.setDescription('The Regulatory Band prohibits the wireless unit from \n             operating outside the regulated limits. An invalid \n             Regulatory Band may be caused by a missing or incorrect \n             License Key, a corrupt MAC Address or an attempt to \n             configure a Regulatory Band not allowed by the License \n             Key or an execution of Reset Configuration. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert.')
productVariant = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("pTPxx400Full", 0), ("pTPxx400Deprecated1", 1), ("pTPxx400Deprecated2", 2), ("pTPxx400Lite", 3), ("spare1", 4), ("pTPxx300", 5), ("spare2", 6), ("spare3", 7), ("pTPxx500FullDeprecated", 8), ("pTPxx500LiteDeprecated", 9), ("pTPxx500", 10), ("pTPxx600Lite", 11), ("pTPxx600Full", 12), ("pTPxx650", 13), ("pMP455", 14), ("pTP800", 15), ("pMPMedusa", 16), ("pTPxx700", 17), ("pTP50670", 18), ("pTP50670ATEX", 19), ("pTP48670", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productVariant.setStatus('current')
if mibBuilder.loadTexts: productVariant.setDescription('The product variant')
productName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: productName.setStatus('current')
if mibBuilder.loadTexts: productName.setDescription('Name of the product variant')
frequencyVariant = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("freq50XXX", 0), ("freq45XXX", 1), ("freq48XXX", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: frequencyVariant.setStatus('current')
if mibBuilder.loadTexts: frequencyVariant.setDescription('The hardware frequency variant')
sNMPv3Enable = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPv3Enable.setStatus('current')
if mibBuilder.loadTexts: sNMPv3Enable.setDescription('SNMPv3 availability control')
licenseVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseVersion.setStatus('current')
if mibBuilder.loadTexts: licenseVersion.setDescription('The license key version.')
licenseUnitSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseUnitSerialNumber.setStatus('current')
if mibBuilder.loadTexts: licenseUnitSerialNumber.setDescription('The unit serial number.')
licenseIssueNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIssueNumber.setStatus('current')
if mibBuilder.loadTexts: licenseIssueNumber.setDescription('The license key issue number for this unit.')
licenseCountry = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 103))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseCountry.setStatus('current')
if mibBuilder.loadTexts: licenseCountry.setDescription('The country in which this unit is licensed to operate.')
licenseNumberOfRegulatoryBands = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseNumberOfRegulatoryBands.setStatus('current')
if mibBuilder.loadTexts: licenseNumberOfRegulatoryBands.setDescription('The number of regulatory bands for which the unit is \n             licensed to operate.')
licenseBandwidthCap = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseBandwidthCap.setStatus('current')
if mibBuilder.loadTexts: licenseBandwidthCap.setDescription('The wireless link bandwidth cap in MHz. Zero indicates \n             no bandwidth cap.')
licenseEncryption = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("aES128bit", 1), ("aES192bit", 2), ("aES256bit", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseEncryption.setStatus('current')
if mibBuilder.loadTexts: licenseEncryption.setDescription('The license key encryption algorithms available.')
licenseSecurityLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("fIPS", 1), ("uCAPL", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: licenseSecurityLevel.setDescription('The license key security level.')
licenseGroupAccess = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseGroupAccess.setStatus('current')
if mibBuilder.loadTexts: licenseGroupAccess.setDescription('The license key group access setting. Note that for HCMP \n             topology, license group access must be enabled.')
licenseOOBManagementSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseOOBManagementSupport.setStatus('current')
if mibBuilder.loadTexts: licenseOOBManagementSupport.setDescription('The license key Out-Of-Band (OOB) support setting.')
licenseSFPPortSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSFPPortSupport.setStatus('current')
if mibBuilder.loadTexts: licenseSFPPortSupport.setDescription('The license key Ethernet SFP Port support setting.')
licenseAuxiliaryPortSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseAuxiliaryPortSupport.setStatus('current')
if mibBuilder.loadTexts: licenseAuxiliaryPortSupport.setDescription('The license key Ethernet Auxiliary Port support \n             setting.')
licenseCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("full", 0), ("mid", 1), ("lite", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseCapacity.setStatus('current')
if mibBuilder.loadTexts: licenseCapacity.setDescription('The license key capacity. Note that for HCMP topology, \n             license capacity must be full.')
licenseMaxNumberOfTDMChannels = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMaxNumberOfTDMChannels.setStatus('current')
if mibBuilder.loadTexts: licenseMaxNumberOfTDMChannels.setDescription('The license key maximum TDM channels setting. Zero \n             indicates TDM not available.')
licenseIEEE1588Support = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIEEE1588Support.setStatus('current')
if mibBuilder.loadTexts: licenseIEEE1588Support.setDescription('The license key IEEE-1588 support setting.')
licenseSyncESupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseSyncESupport.setStatus('current')
if mibBuilder.loadTexts: licenseSyncESupport.setDescription('The license key SyncE support setting.')
licenseIPv6Support = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseIPv6Support.setStatus('current')
if mibBuilder.loadTexts: licenseIPv6Support.setDescription('The license key IPv6 support setting.')
licenseMinimumFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMinimumFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: licenseMinimumFirmwareVersion.setDescription('The minimum firmware version required to support this \n             license key.')
licenseFullCapabilityTrialStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("available", 0), ("active", 1), ("inactive", 2), ("expired", 3), ("unavailable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseFullCapabilityTrialStatus.setStatus('current')
if mibBuilder.loadTexts: licenseFullCapabilityTrialStatus.setDescription('The license key full capability trial period status.')
licenseRemainingTrialPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31536000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRemainingTrialPeriod.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriod.setDescription('The remaining time for the license key full capability \n             trial period.')
licenseRemainingTrialPeriodAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("fullCapabilityTrialNotActiveOrMoreThan7DaysRemaining", 0), ("fullCapabilityTrialExpiringInLessThan7Days", 1), ("fullCapabilityTrialExpiringInLessThan6Days", 2), ("fullCapabilityTrialExpiringInLessThan5Days", 3), ("fullCapabilityTrialExpiringInLessThan4Days", 4), ("fullCapabilityTrialExpiringInLessThan3Days", 5), ("fullCapabilityTrialExpiringInLessThan2Days", 6), ("fullCapabilityTrialExpiringInLessThan1Day", 7), ("fullCapabilityTrialHasExpired", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarm.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarm.setDescription('If the full capability trial license period is about to \n             expire then purchase a license upgrade from your \n             reseller.')
capacityVariantMismatchLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capacityVariantMismatchLinked.setStatus('current')
if mibBuilder.loadTexts: capacityVariantMismatchLinked.setDescription('The remote node of this link has a lower link capacity. \n             Operating with a reduced effective link capacity.')
licenseTDDSyncSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseTDDSyncSupport.setStatus('current')
if mibBuilder.loadTexts: licenseTDDSyncSupport.setDescription('The license key TDD Synchronization support setting.')
licenseMaxLinkRange = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2499))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMaxLinkRange.setStatus('current')
if mibBuilder.loadTexts: licenseMaxLinkRange.setDescription('Maximum licensed range for the wireless link in tenths \n             of km. A value of zero indicates that the maximum link \n             range is not limited by the license.')
licenseTrialPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 365))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseTrialPeriod.setStatus('current')
if mibBuilder.loadTexts: licenseTrialPeriod.setDescription('The license key maximum trial period, in days.')
licenseRARSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("mAB", 1), ("dLEP", 2), ("mABandDLEP", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRARSupport.setStatus('current')
if mibBuilder.loadTexts: licenseRARSupport.setDescription('The license key Radio Aware Routing support setting.')
licenseGasGroup = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("nonHAZLOCUnit", 0), ("gasGroupA", 1), ("gasGroupB", 2), ("gasGroupC", 3), ("gasGroupD", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseGasGroup.setStatus('current')
if mibBuilder.loadTexts: licenseGasGroup.setDescription('The HAZLOC/ATEX Configuration of this unit. The Gas \n             Group is configured by the license key.')
licenseLongMinimumFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseLongMinimumFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: licenseLongMinimumFirmwareVersion.setDescription('The minimum long firmware version required to support \n             this license key.')
licenseHCMPSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("slaveEnabled", 1), ("masterEnabled", 2), ("masterandSlaveEnabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseHCMPSupport.setStatus('current')
if mibBuilder.loadTexts: licenseHCMPSupport.setDescription('The license High Capacity MultiPoint support setting')
licenseInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: licenseInstancedTableNumber.setDescription('Number of entries in the licenseInstancedTable.')
licenseTLSRekey = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseTLSRekey.setStatus('current')
if mibBuilder.loadTexts: licenseTLSRekey.setDescription('The license TLS Rekey support setting')
licenseAdvanceHCMPSupport = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("disabled", 0), ("slaveEnabled", 1), ("masterEnabled", 2), ("masterandSlaveEnabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseAdvanceHCMPSupport.setStatus('current')
if mibBuilder.loadTexts: licenseAdvanceHCMPSupport.setDescription('The license Advance High Capacity MultiPoint support \n             setting')
licenseMinFirmwareVersionPTP650Emulation = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 8, 48), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseMinFirmwareVersionPTP650Emulation.setStatus('current')
if mibBuilder.loadTexts: licenseMinFirmwareVersionPTP650Emulation.setDescription('The minimum long firmware version of 650-Emulation \n             required to support this license key.')
licenseInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 8, 45, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: licenseInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: licenseInstancedTableIndex.setDescription('Used to index the LicenseInstancedTable.')
capacityVariantMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 8, 45, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capacityVariantMismatch.setStatus('current')
if mibBuilder.loadTexts: capacityVariantMismatch.setDescription('The remote node of this link has a lower link capacity. \n             Operating with a reduced effective link capacity.')
licenseRegulatoryBandsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 8, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: licenseRegulatoryBandsTableIndex.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsTableIndex.setDescription('License regulatory bands, used to index the \n             LicenseRegulatoryBandsTable.')
licenseRegulatoryBandsList = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 8, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254), SingleValueConstraint(255))).clone(namedValues=NamedValues(("regInvalid", 0), ("reg158GHz", 1), ("reg258GHz", 2), ("reg358GHz", 3), ("reg458GHzWithRTTT", 4), ("reg558GHz", 5), ("reg658GHz", 6), ("reg754GHz", 7), ("reg854GHz", 8), ("reg954GHz", 9), ("reg1058GHz", 10), ("reg1158GHz", 11), ("reg1254GHz", 12), ("reg1354GHz", 13), ("reg1449GHzPublicSafety", 14), ("reg15", 15), ("reg1659GHz", 16), ("reg1759GHz", 17), ("reg1849GHzPublicSafety", 18), ("reg1958GHz", 19), ("reg2054GHz", 20), ("reg2154GHz", 21), ("reg2258GHz", 22), ("reg23", 23), ("reg2458GHz", 24), ("reg2558GHz", 25), ("reg2654GHz", 26), ("reg2758GHz", 27), ("reg2858GHz", 28), ("reg2958GHz", 29), ("reg3054GHz", 30), ("reg3158GHz", 31), ("reg3249GHzLicensed", 32), ("reg3349GHzETSIBroadbandDisasterRelief", 33), ("reg3458GHz", 34), ("reg3558GHz", 35), ("reg3654GHz", 36), ("reg3758GHz", 37), ("reg3852GHz", 38), ("reg3951GHzETSIBroadbandDisasterRelief", 39), ("reg4054GHz", 40), ("reg4154GHz", 41), ("reg4254GHz", 42), ("reg4354GHz", 43), ("reg4458GHz", 44), ("reg4558GHz", 45), ("reg4658GHz", 46), ("reg4758GHz", 47), ("reg4858GHz", 48), ("reg4958GHz", 49), ("reg5058GHz", 50), ("reg5158GHz", 51), ("reg5258GHz", 52), ("reg5358GHz", 53), ("reg5458GHz", 54), ("reg5558GHz", 55), ("reg5654GHz", 56), ("reg5754GHz", 57), ("reg5858GHz", 58), ("reg5958GHz", 59), ("reg6058GHz", 60), ("reg6149GHz", 61), ("reg6251GHz52GHz", 62), ("reg6352GHz", 63), ("reg6451GHz", 64), ("reg6551GHz", 65), ("reg6651GHz", 66), ("reg6752GHz", 67), ("reg6852GHz", 68), ("reg6952GHz", 69), ("reg7052GHz", 70), ("reg7152GHz", 71), ("reg7252GHz", 72), ("reg7352GHz", 73), ("reg7452GHz", 74), ("reg7552GHz", 75), ("reg7652GHz", 76), ("reg7752GHz", 77), ("reg7849GHz", 78), ("reg7954GHz", 79), ("reg8049GHz", 80), ("reg8147GHz", 81), ("reg8247GHz", 82), ("reg8352GHz", 83), ("reg8451GHz", 84), ("reg8551GHz52GHz", 85), ("reg8652GHz54GHz", 86), ("reg8758GHz", 87), ("reg8849GHz", 88), ("reg8949GHz", 89), ("reg9054GHzParabolicantenna", 90), ("reg9152GHzParabolicantenna", 91), ("reg9251GHzParabolicantenna", 92), ("reg9349GHz", 93), ("reg9449GHz", 94), ("reg9545GHz", 95), ("reg9648GHz", 96), ("reg9752GHz", 97), ("reg9849GHz27dBiantenna", 98), ("reg9949GHz29dBiantenna", 99), ("reg10048GHz", 100), ("reg10158GHz", 101), ("reg102", 102), ("reg103", 103), ("reg10458GHzNoRTTT", 104), ("reg105", 105), ("reg106", 106), ("reg107", 107), ("reg108", 108), ("reg109", 109), ("reg110", 110), ("reg111", 111), ("reg112", 112), ("reg113", 113), ("reg114", 114), ("reg115", 115), ("reg116", 116), ("reg117", 117), ("reg118", 118), ("reg119", 119), ("reg120", 120), ("reg121", 121), ("reg122", 122), ("reg123", 123), ("reg124", 124), ("reg125", 125), ("reg126", 126), ("reg127", 127), ("reg128", 128), ("reg129", 129), ("reg130", 130), ("reg131", 131), ("reg132", 132), ("reg133", 133), ("reg134", 134), ("reg135", 135), ("reg136", 136), ("reg137", 137), ("reg138", 138), ("reg139", 139), ("reg140", 140), ("reg141", 141), ("reg142", 142), ("reg143", 143), ("reg144", 144), ("reg145", 145), ("reg146", 146), ("reg147", 147), ("reg148", 148), ("reg149", 149), ("reg150", 150), ("reg151", 151), ("reg152", 152), ("reg153", 153), ("reg154", 154), ("reg155", 155), ("reg156", 156), ("reg157", 157), ("reg158", 158), ("reg159", 159), ("reg160", 160), ("reg161", 161), ("reg162", 162), ("reg163", 163), ("reg164", 164), ("reg165", 165), ("reg166", 166), ("reg167", 167), ("reg168", 168), ("reg169", 169), ("reg170", 170), ("reg171", 171), ("reg172", 172), ("reg173", 173), ("reg174", 174), ("reg175", 175), ("reg176", 176), ("reg177", 177), ("reg178", 178), ("reg179", 179), ("reg180", 180), ("reg181", 181), ("reg182", 182), ("reg183", 183), ("reg184", 184), ("reg185", 185), ("reg186", 186), ("reg187", 187), ("reg188", 188), ("reg189", 189), ("reg190", 190), ("reg191", 191), ("reg192", 192), ("reg193", 193), ("reg194", 194), ("reg195", 195), ("reg196", 196), ("reg197", 197), ("reg198", 198), ("reg199", 199), ("reg200", 200), ("reg201", 201), ("reg202", 202), ("reg203", 203), ("reg204", 204), ("reg205", 205), ("reg206", 206), ("reg207", 207), ("reg208", 208), ("reg209", 209), ("reg210", 210), ("reg211", 211), ("reg212", 212), ("reg213", 213), ("reg214", 214), ("reg215", 215), ("reg216", 216), ("reg217", 217), ("reg218", 218), ("reg219", 219), ("reg220", 220), ("reg221", 221), ("reg222", 222), ("reg223", 223), ("reg224", 224), ("reg225", 225), ("reg226", 226), ("reg227", 227), ("reg228", 228), ("reg229", 229), ("reg230", 230), ("reg231", 231), ("reg232", 232), ("reg233", 233), ("reg234", 234), ("reg235", 235), ("reg236", 236), ("reg237", 237), ("reg238", 238), ("reg239", 239), ("reg240", 240), ("reg241", 241), ("reg242", 242), ("reg243", 243), ("reg244", 244), ("reg245", 245), ("reg246", 246), ("reg247", 247), ("reg248", 248), ("reg249", 249), ("reg250", 250), ("reg251", 251), ("reg252", 252), ("reg253", 253), ("reg254", 254)) + NamedValues(("reg255", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenseRegulatoryBandsList.setStatus('current')
if mibBuilder.loadTexts: licenseRegulatoryBandsList.setDescription('The list of regulatory bands for which the unit is \n             licensed to operate. A regulatory band prohibits the \n             wireless unit from operating outside the regulated \n             limits. An invalid regulatory band indicates a corrupted \n             license key. NB: a change of state may generate an SNMP \n             trap and/or SMTP email alert.')
targetRange = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: targetRange.setStatus('current')
if mibBuilder.loadTexts: targetRange.setDescription('Initial target range used in installation +/-1, \n             expressed in tenths of a kilometer. When Auto-Ranging \n             this must be set to 0')
rangingMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("auto0to40km", 0), ("auto0to100km", 1), ("auto0to200km", 2), ("auto0to250km", 3), ("targetRange", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rangingMode.setStatus('current')
if mibBuilder.loadTexts: rangingMode.setDescription('Type of ranging to use during installation, either \n             Auto-Ranging or use a selectable Target Range')
installStatusLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("wrongPeer", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installStatusLinked.setStatus('current')
if mibBuilder.loadTexts: installStatusLinked.setDescription('A non-zero value indicates that signalling was received \n             with the wrong MAC address or a mismatched link name. NB: \n             It is very unusual to detect this, because units with \n             mis-configured Target MAC Address will normally fail to \n             establish a wireless link. However, rare circumstances \n             may establish a partial wireless link and detect this \n             situation. NB: A non-zero value on start-up, or a change \n             of value during operation, may generate an SNMP trap \n             and/or SMTP email alert')
installArmState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disarmed", 0), ("armed", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: installArmState.setStatus('current')
if mibBuilder.loadTexts: installArmState.setDescription('Indicates if the unit is being installed. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
tFTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: tFTPServerPortNumber.setDescription('The port number of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
tFTPSoftwareUpgradeFileName = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeFileName.setDescription('Filename of the Software Upgrade to be loaded from the \n             TFTP Server')
tFTPStartSoftwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setStatus('current')
if mibBuilder.loadTexts: tFTPStartSoftwareUpgrade.setDescription("Write '1' to this attribute to start the TFTP software \n             upgrade process. The attribute will be reset to 0 when \n             the upgrade process has finished. Continuing with the \n             software upgrade will cause spectrum management (DSO) \n             channel metrics collection to stop. The wireless unit \n             will no longer search for the optimal operational radio \n             channel. The performance of this wireless link may \n             deterioate over time. If operating in a regulatory band \n             where RADAR detection is mandatory you must complete the \n             software upgrade and reboot the unit. Channel metrics \n             collection will only be restarted after the wireless unit \n             has been rebooted")
tFTPSoftwareUpgradeStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 0), ("uploadinprogress", 1), ("uploadsuccessfulprogrammingFLASH", 2), ("upgradesuccessfulreboottorunthenewsoftwareimage", 3), ("upgradefailed", 4), ("upgradewarning", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatus.setDescription('The current status of the TFTP Software upgrade process')
tFTPSoftwareUpgradeStatusText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusText.setDescription('Descriptive text describing the status of the TFTP \n             Software upgrade process, including any error details')
tFTPSoftwareUpgradeStatusAdditionalText = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setStatus('current')
if mibBuilder.loadTexts: tFTPSoftwareUpgradeStatusAdditionalText.setDescription('Any additional text describing the status of the TFTP \n             Software upgrade process, including any error details')
hTTPAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: hTTPAccessEnabled.setDescription('This controls whether or not HTTP access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the HTTP port. Remote \n             management via HTTPS is not affected by this setting. Any \n             change in this setting will not take effect until the \n             unit has been rebooted. (Factory default = Enabled)')
telnetAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: telnetAccessEnabled.setDescription('This controls whether or not Telnet access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the TELNET port. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = Disabled)')
hTTPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPPortNumber.setStatus('current')
if mibBuilder.loadTexts: hTTPPortNumber.setDescription('This controls the port number for HTTP access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 80)')
hTTPSPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPSPortNumber.setStatus('current')
if mibBuilder.loadTexts: hTTPSPortNumber.setDescription('This controls the port number for HTTPS access. A value \n             of zero will use the default port number. Availability of \n             HTTPS is controlled via the License Key. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 443)')
telnetPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetPortNumber.setStatus('current')
if mibBuilder.loadTexts: telnetPortNumber.setDescription('This controls the port number for TELNET access. A value \n             of zero will use the default port number. Any change in \n             this setting will not take effect until the unit has been \n             rebooted. (Factory default = 23)')
hTTPSAccessEnabled = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hTTPSAccessEnabled.setStatus('current')
if mibBuilder.loadTexts: hTTPSAccessEnabled.setDescription('This controls whether or not HTTPS access is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any requests on the HTTPS port. Remote \n             management via HTTP is not affected by this setting. Any \n             change in this setting will not take effect until the \n             unit has been rebooted. (Factory default = Disabled)')
tFTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: tFTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             tFTPServerInternetAddress.')
tFTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 19), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tFTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: tFTPServerInternetAddress.setDescription('INET address of the TFTP Server from which the TFTP \n             Software Upgrade File Name will be retrieved')
lowestDataModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lowestDataModulationMode.setStatus('current')
if mibBuilder.loadTexts: lowestDataModulationMode.setDescription('The lowest modulation mode at which Ethernet Data \n             traffic will be bridged over the wireless link')
tFTPClient = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPClient.setStatus('current')
if mibBuilder.loadTexts: tFTPClient.setDescription('This controls whether or not TFTP client is enabled, \n             i.e. if this is disabled (0) then the unit will not \n             respond to any TFTP software download requests. (Factory \n             default = Enabled)')
mgmtInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: mgmtInstancedTableNumber.setDescription('Number of entries in the mgmtInstancedTable.')
tFTPServerResolvedInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tFTPServerResolvedInternetAddress.setStatus('current')
if mibBuilder.loadTexts: tFTPServerResolvedInternetAddress.setDescription('IP Address of the TFTP Server.')
installationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 9, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("armWithTones", 0), ("armWithoutTones", 1), ("changeConfigWithoutArming", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: installationMode.setStatus('current')
if mibBuilder.loadTexts: installationMode.setDescription('Determines whether the unit is armed for antenna \n             alignment, and whether it emits audible installation \n             tones to indicate the state and strength of the received \n             signal. Alternatively, configuration changes may be made \n             without arming the unit (typically once a link has \n             already been established). Note: while armed, a unit will \n             have reduced link performance and functionality.')
mgmtInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 9, 24, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: mgmtInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: mgmtInstancedTableIndex.setDescription('Used to index values in the mgmtInstancedTable')
installStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 9, 24, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("wrongPeer", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: installStatus.setStatus('current')
if mibBuilder.loadTexts: installStatus.setDescription('A non-zero value indicates that signalling was received \n             with the wrong MAC address or a mismatched link name. NB: \n             It is very unusual to detect this, because units with \n             mis-configured Target MAC Address will normally fail to \n             establish a wireless link. However, rare circumstances \n             may establish a partial wireless link and detect this \n             situation. NB: A non-zero value on start-up, or a change \n             of value during operation, may generate an SNMP trap \n             and/or SMTP email alert')
linkSymmetry = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("symmetryAdaptive", 0), ("symmetry2to1", 1), ("symmetry1to1", 2), ("symmetry1to2", 3), ("symmetry3to1", 4), ("symmetry1to3", 5), ("symmetry5to1", 6), ("symmetry1to5", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkSymmetry.setStatus('current')
if mibBuilder.loadTexts: linkSymmetry.setDescription('Provides configuration options for sharing the available \n             wireless capacity between the transmit and receive \n             directions. Fixed link symmetry is defined by a ratio of \n             the burst duration for the transmit direction to the \n             burst duration for the receive direction. Permitted \n             settings are 5:1, 3:1, 2:1, 1:1, 1:2, 1:3, 1:5. The 1:1 \n             option provides fixed symmetric operation. The adaptive \n             option selects transmit and receive burst durations \n             automatically in response to the offered Ethernet traffic \n             in each link direction. This attribute is valid only for \n             a unit configured as a TDD Master')
userConfiguredMaxModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("modBpsk63percent", 0), ("modQpsk63percent", 1), ("modQpsk87percent", 2), ("mod16qam63percent", 3), ("mod16qam87percent", 4), ("mod64qam75percent", 5), ("mod64qam92percent", 6), ("mod256qam81percent", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userConfiguredMaxModulationMode.setStatus('current')
if mibBuilder.loadTexts: userConfiguredMaxModulationMode.setDescription('The maximum receive modulation mode controls the MAX \n             mode used for adaptive modulation. NOTE: This attribute \n             is automatically disabled when the installation agent is \n             armed. To disarm the installation agent use the \n             installation wizard')
linkModeOptimization = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("iPTraffic", 0), ("tDMTraffic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkModeOptimization.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimization.setDescription("Optimizes the wireless link behavior for the type of \n             traffic to be carried. In 'IP Traffic' mode, the wireless \n             link will minimize transmission errors by automatically \n             adapting the modulation mode. In 'TDM Traffic' mode, the \n             wireless link will minimize transmission latency and \n             preserve throughput by maintaining a higher modulation \n             mode in the presence of a limited number of errors. The \n             'TDM Traffic' mode is recommended for E1/T1 applications \n             and connectionless protocols.")
txColorCode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3), ("e", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: txColorCode.setStatus('current')
if mibBuilder.loadTexts: txColorCode.setDescription('Transmit Color Code. This attribute need only be \n             considered when the unit is installed in a network of \n             wireless units and where some of the units are operating \n             on the same frequency. In this case, the value would \n             normally be derived by a network planner. In all other \n             cases, it is recommended that this attribute is left at \n             the default value. NOTE: For the link to operate, the \n             value of this parameter must in all cases match the value \n             of the Rx Color Code parameter at the far end of the \n             link.')
rxColorCode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 0), ("b", 1), ("c", 2), ("d", 3), ("e", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxColorCode.setStatus('current')
if mibBuilder.loadTexts: rxColorCode.setDescription('Receive Color Code. This attribute need only be \n             considered when the unit is installed in a network of \n             wireless units and where some of the units are operating \n             on the same frequency. In this case, the value would \n             normally be derived by a network planner. In all other \n             cases, it is recommended that this attribute is left at \n             the default value. NOTE: For the link to operate, the \n             value of this parameter must in all cases match the value \n             of the Tx Color Code parameter at the far end of the \n             link.')
remoteMaximumTransmitPowerLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMaximumTransmitPowerLinked.setStatus('current')
if mibBuilder.loadTexts: remoteMaximumTransmitPowerLinked.setDescription('Maximum transmit power the remote wireless unit is \n             permitted to use when establishing and maintaining the \n             wireless link')
phyControlInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 10, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyControlInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: phyControlInstancedTableNumber.setDescription('Number of entries in the PhyControlInstancedTable.')
phyControlInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 10, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: phyControlInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: phyControlInstancedTableIndex.setDescription('Used to index the PhyControlInstancedTable.')
remoteMaximumTransmitPower = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 10, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setStatus('current')
if mibBuilder.loadTexts: remoteMaximumTransmitPower.setDescription('Maximum transmit power the remote wireless unit is \n             permitted to use when establishing and maintaining the \n             wireless link')
linkLossLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-500, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkLossLinked.setStatus('current')
if mibBuilder.loadTexts: linkLossLinked.setDescription('The wireless link loss expressed in tenths of a dB')
receivePowerLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivePowerLinked.setStatus('current')
if mibBuilder.loadTexts: receivePowerLinked.setDescription('Receive power expressed in tenths of a dBm')
vectorErrorLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vectorErrorLinked.setStatus('current')
if mibBuilder.loadTexts: vectorErrorLinked.setDescription("The vector error measurement compares the received \n             signal's IQ modulation characteristics to an ideal signal \n             to determine the composite error vector magnitude. The \n             value represented by this attribute is the average vector \n             error over the previous second expressed in tenths of a \n             dB")
transmitPowerLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitPowerLinked.setStatus('current')
if mibBuilder.loadTexts: transmitPowerLinked.setDescription('Transmit power expressed in tenths of a dBm')
receiveChannel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 305))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveChannel.setStatus('current')
if mibBuilder.loadTexts: receiveChannel.setDescription('Current active receive channel')
transmitChannel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 305))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitChannel.setStatus('current')
if mibBuilder.loadTexts: transmitChannel.setDescription('Current active transmit channel')
receiveFreqMHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveFreqMHz.setStatus('current')
if mibBuilder.loadTexts: receiveFreqMHz.setDescription('Current receive frequency expressed in integer MHz')
transmitFreqMHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitFreqMHz.setStatus('current')
if mibBuilder.loadTexts: transmitFreqMHz.setDescription('Current transmit frequency expressed in integer MHz')
signalStrengthRatioLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalStrengthRatioLinked.setStatus('current')
if mibBuilder.loadTexts: signalStrengthRatioLinked.setDescription('Signal strength ratio (Vertical / Horizontal) : the \n             number of dB larger the Vertical antenna input is than \n             the Horizontal antenna input expressed in tenths of a dB')
receiveFreqKHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveFreqKHz.setStatus('current')
if mibBuilder.loadTexts: receiveFreqKHz.setDescription('Current receive frequency expressed as KHz')
transmitFreqKHz = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6050000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitFreqKHz.setStatus('current')
if mibBuilder.loadTexts: transmitFreqKHz.setDescription('Current transmit frequency expressed as KHz')
rawReceivePowerLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rawReceivePowerLinked.setStatus('current')
if mibBuilder.loadTexts: rawReceivePowerLinked.setDescription('Raw receive power expressed in tenths of a dBm')
rangeLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rangeLinked.setStatus('current')
if mibBuilder.loadTexts: rangeLinked.setDescription('Distance between the two peer wireless units expressed \n             in tenths of a kilometer')
receiveModulationModeLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationModeLinked.setStatus('current')
if mibBuilder.loadTexts: receiveModulationModeLinked.setDescription('Current active receive modulation mode')
transmitModulationModeLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 28))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitModulationModeLinked.setStatus('current')
if mibBuilder.loadTexts: transmitModulationModeLinked.setDescription('Current active transmit modulation mode')
searchStateLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("registering", 0), ("searching", 1), ("acquiring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: searchStateLinked.setStatus('current')
if mibBuilder.loadTexts: searchStateLinked.setDescription("Search status of the wireless modem. 'Registering' means \n             that the modem has locked to an OFDM signal, and the \n             wireless link is up. 'Searching' means that no wireless \n             signal has been detected. 'Acquiring' means that a \n             wireless signal has been detected, but the modem has not \n             locked to an OFDM signal.")
remoteMACAddressLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMACAddressLinked.setStatus('current')
if mibBuilder.loadTexts: remoteMACAddressLinked.setDescription('MAC Address of the peer wireless unit')
phyInstancedStatusTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyInstancedStatusTableNumber.setStatus('current')
if mibBuilder.loadTexts: phyInstancedStatusTableNumber.setDescription('Number of entries in the phyInstancedStatusTable.')
tempPcb = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 12, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tempPcb.setStatus('current')
if mibBuilder.loadTexts: tempPcb.setDescription('PCB temperature expressed in Celsius')
phyInstancedStatusTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: phyInstancedStatusTableIndex.setStatus('current')
if mibBuilder.loadTexts: phyInstancedStatusTableIndex.setDescription('Used to index the phyInstancedStatusTable.')
linkLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-500, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkLoss.setStatus('current')
if mibBuilder.loadTexts: linkLoss.setDescription('The link loss measurement = Peer Tx_Power(dBm) - Local \n             Rx_Power(dBm) + 2 x Antenna_Pattern(dBi) ')
receivePower = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receivePower.setStatus('current')
if mibBuilder.loadTexts: receivePower.setDescription('Receive power histogram ')
vectorError = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vectorError.setStatus('current')
if mibBuilder.loadTexts: vectorError.setDescription("The vector error measurement compares the received \n             signal's IQ modulation characteristics to an ideal signal \n             to determine the composite error vector magnitude ")
signalStrengthRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: signalStrengthRatio.setStatus('current')
if mibBuilder.loadTexts: signalStrengthRatio.setDescription('Signal strength ratio (Vertical / Horizontal) : the \n             number of dB larger the Vertical antenna input is than \n             the Horizontal antenna input ')
range = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: range.setStatus('current')
if mibBuilder.loadTexts: range.setDescription('Distance between the two peer wireless units')
receiveModulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationMode.setStatus('current')
if mibBuilder.loadTexts: receiveModulationMode.setDescription('Current active receive modulation mode')
transmitModulationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitModulationMode.setStatus('current')
if mibBuilder.loadTexts: transmitModulationMode.setDescription('Current active transmit modulation mode')
searchState = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("registering", 0), ("searching", 1), ("acquiring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: searchState.setStatus('current')
if mibBuilder.loadTexts: searchState.setDescription("Search status of the wireless modem. 'Registering' means \n             that the modem has locked to an OFDM signal, and the \n             wireless link is up. 'Searching' means that no wireless \n             signal has been detected. 'Acquiring' means that a \n             wireless signal has been detected, but the modem has not \n             locked to an OFDM signal.")
remoteMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: remoteMACAddress.setStatus('current')
if mibBuilder.loadTexts: remoteMACAddress.setDescription('MAC Address of the peer wireless unit')
rawReceivePower = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rawReceivePower.setStatus('current')
if mibBuilder.loadTexts: rawReceivePower.setDescription('Raw receive power')
transmitPower = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 12, 19, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitPower.setStatus('current')
if mibBuilder.loadTexts: transmitPower.setDescription('Transmit power histogram ')
unitOutOfCalibration = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("calibrated", 0), ("partialCalibration", 1), ("invalidCalibration", 2), ("bandwidthvariantunsupportedPAsShutdown", 3), ("outOfCalibrationPAsShutdown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitOutOfCalibration.setStatus('current')
if mibBuilder.loadTexts: unitOutOfCalibration.setDescription('The unit is out of calibration')
incompatibleRegulatoryBandsLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("regOK", 0), ("regIncompatibleLicenseKeys", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleRegulatoryBandsLinked.setStatus('current')
if mibBuilder.loadTexts: incompatibleRegulatoryBandsLinked.setDescription('The master and slave units have incompatible regulatory \n             bands. NB: Both units must have compatible license keys')
noWirelessChannelAvailable = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("noWirelessChannelAvailable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: noWirelessChannelAvailable.setStatus('current')
if mibBuilder.loadTexts: noWirelessChannelAvailable.setDescription('Spectrum Management was unable to locate a suitable \n             wireless channel to operate on')
wirelessLinkDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkDisabledWarning.setDescription('The SNMP ifAdminStatus of the wireless interface has \n             disabled wireless traffic')
mainPSUPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPError = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("installedSFPNotLicensed", 1), ("fiberLinkNotEstablishedButLOSNotDetected", 2), ("fiberLinkNotEstablishedAndLOSDetected", 3), ("installedSFPNotSupported", 4), ("sFPInitializationFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPError.setStatus('current')
if mibBuilder.loadTexts: sFPError.setDescription('If the SFP link is not OK, there are five possible \n             causes: Either a SFP has been installed but the license \n             key does not include SFP fiber support, a fiber link \n             could not be established even though no LOS was detected \n             (i.e. an optical carrier was detected, which could be due \n             to a broken TX fiber, or because the link is disabled at \n             the fiber link partner), a fiber link could not be \n             established and LOS is detected (i.e. no optical carrier \n             is detected), the installed SFP is not supported or the \n             installed SFP failed to initialize correctly. NB: a \n             change of status may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch')
incompatibleMasterAndSlaveLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("incompatibleProductVariants", 1), ("differentSoftwareVersionsRunning", 2), ("tDDFrameConfigurationModeMismatch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleMasterAndSlaveLinked.setStatus('current')
if mibBuilder.loadTexts: incompatibleMasterAndSlaveLinked.setDescription('A non-zero value indicates that the master and slave \n             ends of a link are different hardware products, or have \n             different software versions, or have different TDD Frame \n             Configuraton Modes (Standard/Expert) in HCMP topology. \n             NB: It is very unusual to detect this, because \n             incompatible units will normally fail to establish a \n             wireless link. However, some combinations may establish a \n             partial wireless link and detect this situation. NB: A \n             non-zero value may generate an SNMP trap and/or SMTP \n             email alert')
tDDSynchronizationStatus = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("locked", 0), ("holdover", 1), ("holdoverNoGPSSyncIn", 2), ("notSynchronized", 3), ("notSynchronizedNoGPSSyncIn", 4), ("pTPSYNCNotConnected", 5), ("initialising", 6), ("clusterTimingMaster", 7), ("acquiringLock", 8), ("inactive", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationStatus.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationStatus.setDescription('An alarm value (displayed in red) indicates that one of \n             the following conditions has not been met (i) An external \n             timing system is connected or internal timing has been \n             configured. (ii) The timing system is providing a useable \n             reference. (iii) The ODU is locked to this reference.')
auxPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: auxPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
tDDSynchronizationAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ok", 0), ("synchronizationLost", 1), ("referenceSignalLost", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationAlarm.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationAlarm.setDescription('Not Synchronized indicates failure of the external \n             timing system for a period greater than the holdover \n             timer. TDD frame timing will have drifted, and this link \n             may cause interference with other links in a synchronized \n             network. Timing System Failure is an early warning, \n             indicating that 80% of the holdover period has expired.')
linkModeOptimizationMismatchLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("linkModeOptimizationMismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkModeOptimizationMismatchLinked.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimizationMismatchLinked.setDescription('The remote node of this link has been configured with a \n             different link mode optimization')
auxPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: auxPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: auxPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
secureModeAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("secureModeIsActive", 0), ("secureModeIsNotConfigured", 1), ("secureModeIsConfiguredButNotActive", 2), ("secureModeIsNotSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secureModeAlarm.setStatus('current')
if mibBuilder.loadTexts: secureModeAlarm.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
dataBridgingStatusAlarmLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bridgingEnabled", 0), ("bridgingDisabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatusAlarmLinked.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusAlarmLinked.setDescription('Ethernet Data traffic bridging is disabled because the \n             wireless link is not operating at the configured Lowest \n             Data Modulation Mode')
sFPPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: sFPPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFPPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: sFPPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
maxLinkRangeExceededLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("maxLinkRangeOK", 0), ("maxLinkRangeExceeded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxLinkRangeExceededLinked.setStatus('current')
if mibBuilder.loadTexts: maxLinkRangeExceededLinked.setDescription('The measured link range is greater than the maximum \n             allowed by the license key. The link will operate at a \n             reduced capacity while this condition applies. This alarm \n             is only raised if the license specifies a maximum link \n             range and the trial license is not active.')
nIDULanPortDisabledWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("disabledBySNMPifAdminStatus", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortDisabledWarning.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortDisabledWarning.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
nIDULanPortConfigurationMismatch = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noError", 0), ("mismatchDetected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatch.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatch.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch.')
portAllocationMismatchLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("portAllocationOK", 0), ("mismatchinOutofBandRemoteManagementService", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAllocationMismatchLinked.setStatus('current')
if mibBuilder.loadTexts: portAllocationMismatchLinked.setDescription('The local and remote ODUs have different services \n             configured.')
transparentClockSourcePortAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("invalidTransparentClockSourcePort", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: transparentClockSourcePortAlarm.setStatus('current')
if mibBuilder.loadTexts: transparentClockSourcePortAlarm.setDescription('Transparent Clock will not function properly because \n             SFP, the selected clock source port is not FIBER')
alarmInstancedTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: alarmInstancedTableNumber.setStatus('current')
if mibBuilder.loadTexts: alarmInstancedTableNumber.setDescription('Number of entries in the alarmInstancedTable.')
secureLicenseSignatureAlarm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 13, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("licenseisDSA2048signed", 0), ("licenseisDSA1024signed", 1), ("licensesignaturealarmisnotrelevant", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secureLicenseSignatureAlarm.setStatus('current')
if mibBuilder.loadTexts: secureLicenseSignatureAlarm.setDescription("Alarm condition indicates that the unit's license is not \n             secure enough for FIPS approved mode.")
alarmInstancedTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: alarmInstancedTableIndex.setStatus('current')
if mibBuilder.loadTexts: alarmInstancedTableIndex.setDescription('Used to index values in the alarmInstancedTable')
incompatibleMasterAndSlave = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("incompatibleProductVariants", 1), ("differentSoftwareVersionsRunning", 2), ("tDDFrameConfigurationModeMismatch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleMasterAndSlave.setStatus('current')
if mibBuilder.loadTexts: incompatibleMasterAndSlave.setDescription('A non-zero value indicates that the master and slave \n             ends of a link are different hardware products, or have \n             different software versions, or have different TDD Frame \n             Configuraton Modes (Standard/Expert) in HCMP topology. \n             NB: It is very unusual to detect this, because \n             incompatible units will normally fail to establish a \n             wireless link. However, some combinations may establish a \n             partial wireless link and detect this situation. NB: A \n             non-zero value may generate an SNMP trap and/or SMTP \n             email alert')
linkModeOptimizationMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ok", 0), ("linkModeOptimizationMismatch", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linkModeOptimizationMismatch.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimizationMismatch.setDescription('The remote node of this link has been configured with a \n             different link mode optimization')
dataBridgingStatusAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bridgingEnabled", 0), ("bridgingDisabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingStatusAlarm.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusAlarm.setDescription('Ethernet Data traffic bridging is disabled because the \n             wireless link is not operating at the configured Lowest \n             Data Modulation Mode')
maxLinkRangeExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("maxLinkRangeOK", 0), ("maxLinkRangeExceeded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxLinkRangeExceeded.setStatus('current')
if mibBuilder.loadTexts: maxLinkRangeExceeded.setDescription('The measured link range is greater than the maximum \n             allowed by the license key. The link will operate at a \n             reduced capacity while this condition applies. This alarm \n             is only raised if the license specifies a maximum link \n             range and the trial license is not active.')
portAllocationMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("portAllocationOK", 0), ("mismatchinOutofBandRemoteManagementService", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAllocationMismatch.setStatus('current')
if mibBuilder.loadTexts: portAllocationMismatch.setDescription('The local and remote ODUs have different services \n             configured.')
wirelessLinkStatusAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("up", 0), ("down", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkStatusAlarm.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkStatusAlarm.setDescription('Current status of the wireless link. A state of Up on a \n             green background indicates that a wireless link is \n             established')
incompatibleRegulatoryBands = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 13, 27, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("regOK", 0), ("regIncompatibleLicenseKeys", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: incompatibleRegulatoryBands.setStatus('current')
if mibBuilder.loadTexts: incompatibleRegulatoryBands.setDescription('The master and slave units have incompatible regulatory \n             bands. NB: Both units must have compatible license keys')
atpcHcmpMasterTargetRxPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 14, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-80, -30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpcHcmpMasterTargetRxPower.setStatus('current')
if mibBuilder.loadTexts: atpcHcmpMasterTargetRxPower.setDescription('The target Rx power level (dBm) at the HCMP Master that \n             the HCMP Slaves try to reach by automatically adjusting \n             their transmit power. The same value must be set in both \n             the HCMP Master and Slaves as it used by the Slave to set \n             its transmit power accurately before the wireless link is \n             established.')
atpcHcmpMasterTxPower = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 14, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-15, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atpcHcmpMasterTxPower.setStatus('current')
if mibBuilder.loadTexts: atpcHcmpMasterTxPower.setDescription('This must be set to the same value as the Maximum \n             Transmit Power attribute on the HCMP Master. This is \n             required by the HCMP Slave for initial transmit power \n             estimation.')
sMTPEmailAlert = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEmailAlert.setStatus('current')
if mibBuilder.loadTexts: sMTPEmailAlert.setDescription('Simple Mail Transfer Protocol is used to send equipment \n             alerts via email to a specified email address')
sMTPServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: sMTPServerPortNumber.setDescription('Port number of the SMTP server')
sMTPSourceEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPSourceEmailAddress.setDescription("The 'from' email address used when constructing the \n             automatically generated e-mail message")
sMTPDestinationEmailAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPDestinationEmailAddress.setDescription("The 'to' email address used when constructing the \n             automatically generated e-mail message")
sMTPEnabledMessages = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 6), Bits().clone(namedValues=NamedValues(("nIDULanPortUpDown", 0), ("sFPPortUpDown", 1), ("auxPortUpDown", 2), ("mainPSUPortUpDown", 3), ("enabledDiagnosticAlarms", 4), ("dFSImpulseInterference", 5), ("channelChange", 6), ("wirelessPortUpDown", 7), ("listenBeforeTalk", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPEnabledMessages.setStatus('current')
if mibBuilder.loadTexts: sMTPEnabledMessages.setDescription('This controls which SMTP messages the unit will send')
sMTPServerInternetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sMTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sMTPServerInternetAddress.')
sMTPServerInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 8), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sMTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPServerInternetAddress.setDescription('Internet address of the SMTP server')
sMTPServerResolvedInternetAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 15, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sMTPServerResolvedInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sMTPServerResolvedInternetAddress.setDescription('IP Address of the SMTP Server.')
sNMPPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPPortNumber.setDescription('The IP port number used to access the SNMP MIB (i.e. \n             Gets and Sets) (default = 161). NB: A system reboot is \n             required to activate changes to this attribute')
sNMPCommunityString = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPCommunityString.setStatus('current')
if mibBuilder.loadTexts: sNMPCommunityString.setDescription('The SNMP community string. NB: A system reboot is \n             required to activate changes to this attribute')
sNMPTrapTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapTableNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableNumber.setDescription('Number of entries in the sNMPTrapTable.')
sNMPTrapVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("v1", 0), ("v2c", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapVersion.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapVersion.setDescription('The SNMP protocol version to use for SNMP Traps. NB: A \n             system reboot is required to activate changes to this \n             attribute')
sNMPEnabledTraps = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 6), Bits().clone(namedValues=NamedValues(("auxPortUpDown", 0), ("mainPSUPortUpDown", 1), ("authenticationFailure", 2), ("enabledDiagnosticAlarms", 3), ("dFSImpulseInterference", 4), ("channelChange", 5), ("wirelessPortUpDown", 6), ("coldStart", 7), ("listenBeforeTalk", 13), ("nIDULanPortUpDown", 14), ("sFPPortUpDown", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPEnabledTraps.setStatus('current')
if mibBuilder.loadTexts: sNMPEnabledTraps.setDescription('This controls which SNMP Traps the unit will send')
enabledDiagnosticAlarms = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 7), Bits().clone(namedValues=NamedValues(("portState", 0), ("incompatibleMasterAndSlave", 1), ("incompatibleRegulatoryBands", 2), ("maximumLinkRangeExceeded", 3), ("unitOutOfCalibration", 4), ("installArmState", 5), ("installStatus", 6), ("regulatoryBand", 7), ("syslogLocalWrapped", 8), ("syslogLocalNearlyFull", 9), ("syslogDisabledWarning", 10), ("linkModeOptimizationMismatch", 11), ("tDDSynchronizationAlarm", 12), ("wirelessLinkDisabledWarning", 13), ("sNTPSynchronizationFailed", 14), ("noWirelessChannelAvailable", 15), ("licenseSignatureLengthAlarm", 16), ("wirelessLinkStatus", 17), ("tDMAlarms", 18), ("capacityVariantMismatch", 19), ("remainingFullCapacityTrialTime", 20), ("dataBridgingStatus", 21), ("secureModeAlarm", 22), ("syslogClientDisabledWarning", 23)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setStatus('current')
if mibBuilder.loadTexts: enabledDiagnosticAlarms.setDescription("Controls which individual diagnostic alarms are enabled. \n             The unit may be configured to generate SNMP traps and/or \n             SMTP email alerts for these enabled alarms by selecting \n             'Enabled Diagnostic Alarms' on the 'SNMP Enabled Traps' \n             and/or 'SMTP Enabled Messages' attributes")
sNMPSendAllTrapsAtStartup = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 16, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPSendAllTrapsAtStartup.setStatus('current')
if mibBuilder.loadTexts: sNMPSendAllTrapsAtStartup.setDescription('Controls whether cleared traps are reported at start-up \n             as well as raised traps. Only enabled traps will be \n             reported. NB: Traps corresponding to transient events \n             (i.e. not associated with an alarm or status value) are \n             only sent when required and not at start-up.')
sNMPTrapTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNMPTrapTableIndex.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapTableIndex.setDescription('SNMP trap value, used to index the SNMPTrapTable.')
sNMPTrapPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapPortNumber.setDescription('Destination port for SNMP Traps (default=162). NB: A \n             system reboot is required to activate changes to this \n             attribute.')
sNMPTrapInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNMPTrapInternetAddress.')
sNMPTrapInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 5), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapInternetAddress.setDescription('The Internet address to which all SNMP Traps are sent.')
sNMPTrapReceiverEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapReceiverEnabled.setDescription('A value of 0 disables the sending of SNMP trap to \n             corresponding receiver. A value of 1 enables the sending \n             of SNMP trap to corresponding receiver.')
sNMPTrapResolvedInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 16, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNMPTrapResolvedInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNMPTrapResolvedInternetAddress.setDescription('IP Address(es) of the SNMP Trap Server.')
sNTPState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPState.setStatus('current')
if mibBuilder.loadTexts: sNTPState.setDescription('SNTP control state')
sNTPPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 43200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPollInterval.setStatus('current')
if mibBuilder.loadTexts: sNTPPollInterval.setDescription('The SNTP server polling interval')
sNTPSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noSync", 0), ("inSync", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPSync.setStatus('current')
if mibBuilder.loadTexts: sNTPSync.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP')
sNTPLastSync = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPLastSync.setStatus('current')
if mibBuilder.loadTexts: sNTPLastSync.setDescription('Last SNTP sync time')
systemClock = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemClock.setStatus('current')
if mibBuilder.loadTexts: systemClock.setDescription('System clock presented as local time')
timeZone = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50))).clone(namedValues=NamedValues(("gmtMinus1200", 0), ("gmtMinus1130", 1), ("gmtMinus1100", 2), ("gmtMinus1030", 3), ("gmtMinus1000", 4), ("gmtMinus0930", 5), ("gmtMinus0900", 6), ("gmtMinus0830", 7), ("gmtMinus0800", 8), ("gmtMinus0730", 9), ("gmtMinus0700", 10), ("gmtMinus0630", 11), ("gmtMinus0600", 12), ("gmtMinus0530", 13), ("gmtMinus0500", 14), ("gmtMinus0430", 15), ("gmtMinus0400", 16), ("gmtMinus0330", 17), ("gmtMinus0300", 18), ("gmtMinus0230", 19), ("gmtMinus0200", 20), ("gmtMinus0130", 21), ("gmtMinus0100", 22), ("gmtMinus0030", 23), ("gmtZero", 24), ("gmtPlus0030", 25), ("gmtPlus0100", 26), ("gmtPlus0130", 27), ("gmtPlus0200", 28), ("gmtPlus0230", 29), ("gmtPlus0300", 30), ("gmtPlus0330", 31), ("gmtPlus0400", 32), ("gmtPlus0430", 33), ("gmtPlus0500", 34), ("gmtPlus0530", 35), ("gmtPlus0600", 36), ("gmtPlus0630", 37), ("gmtPlus0700", 38), ("gmtPlus0730", 39), ("gmtPlus0800", 40), ("gmtPlus0830", 41), ("gmtPlus0900", 42), ("gmtPlus0930", 43), ("gmtPlus1000", 44), ("gmtPlus1030", 45), ("gmtPlus1100", 46), ("gmtPlus1130", 47), ("gmtPlus1200", 48), ("gmtPlus1230", 49), ("gmtPlus1300", 50)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeZone.setStatus('current')
if mibBuilder.loadTexts: timeZone.setDescription('Time zone offsets from Greenwich Mean Time (GMT)')
daylightSaving = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: daylightSaving.setStatus('current')
if mibBuilder.loadTexts: daylightSaving.setDescription('Daylight Saving Time')
sNTPPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("server1", 0), ("server2", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: sNTPPrimaryServer.setDescription('Specifies the primary SNTP server, determining the order \n             in which the servers are tried.')
sNTPPrimaryServerDeadTime = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setStatus('current')
if mibBuilder.loadTexts: sNTPPrimaryServerDeadTime.setDescription('Time (in seconds) to wait before retrying communications \n             with an unresponsive primary SNTP server. Setting the \n             value to 0 disables the timer.')
sNTPServerRetries = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerRetries.setStatus('current')
if mibBuilder.loadTexts: sNTPServerRetries.setDescription('Number of times the device will retry after an SNTP \n             server fails to respond.')
sNTPServerTimeout = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerTimeout.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTimeout.setDescription('Time (in seconds) the device will wait for a response \n             from an SNTP server.')
sNTPServerTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 17, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerTableNumber.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableNumber.setDescription('Number of entries in the SNTPServerTable.')
sNTPServerTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: sNTPServerTableIndex.setStatus('current')
if mibBuilder.loadTexts: sNTPServerTableIndex.setDescription('Index range for the SNTPServerTable.')
sNTPServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: sNTPServerPortNumber.setDescription('The IP port number of the SNTP server. Defaults to port \n             123.')
sNTPServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerStatus.setStatus('current')
if mibBuilder.loadTexts: sNTPServerStatus.setDescription('Status message reflecting the result of communications \n             with the SNTP server when last polled')
sNTPServerInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: sNTPServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             sNTPServerInternetAddress.')
sNTPServerInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sNTPServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNTPServerInternetAddress.setDescription('The Internet address of a valid SNTP server')
sNTPServerResolvedInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerResolvedInternetAddress.setStatus('current')
if mibBuilder.loadTexts: sNTPServerResolvedInternetAddress.setDescription('IP Address of the SNTP Server.')
sNTPServerAuthenticationProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("mD5", 1), ("sHA1", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerAuthenticationProtocol.setStatus('current')
if mibBuilder.loadTexts: sNTPServerAuthenticationProtocol.setDescription('Authentication protocol to be used for this SNTP server. \n             Options are None (default) or MD5.')
sNTPServerKeyIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 17, 15, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sNTPServerKeyIdentifier.setStatus('current')
if mibBuilder.loadTexts: sNTPServerKeyIdentifier.setDescription('SNTP key identifier. Note: Key 0 is reserved for testing \n             using the well-known key all zeroes.')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("running", 0), ("consoleReboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('current')
if mibBuilder.loadTexts: systemReset.setDescription("Setting this attribute to '1' will cause a system \n             reboot. NB: a system reboot will apply any pending new \n             settings held in memory")
softwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 19, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softwareVersion.setStatus('current')
if mibBuilder.loadTexts: softwareVersion.setDescription('Current software version')
hardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 19, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hardwareVersion.setStatus('current')
if mibBuilder.loadTexts: hardwareVersion.setDescription('Hardware platform version')
secondarySoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 19, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondarySoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: secondarySoftwareVersion.setDescription('Secondary software version, used when the primary \n             software image is invalid or erased')
bootVersion = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 19, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootVersion.setStatus('current')
if mibBuilder.loadTexts: bootVersion.setDescription('Boot code software version')
receiveDataRateLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveDataRateLinked.setStatus('current')
if mibBuilder.loadTexts: receiveDataRateLinked.setDescription('Average data rate over the last one second interval \n             (kbps)')
transmitDataRateLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitDataRateLinked.setStatus('current')
if mibBuilder.loadTexts: transmitDataRateLinked.setDescription('Average data rate over the last one second interval \n             (kbps)')
aggregateDataRateLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregateDataRateLinked.setStatus('current')
if mibBuilder.loadTexts: aggregateDataRateLinked.setDescription('Average data rate over the last one second interval \n             (kbps)')
wirelessLinkAvailabilityLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkAvailabilityLinked.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkAvailabilityLinked.setDescription('Link availability calculated since the last reset of the \n             system counters, as a percentage multiplied by 10000 to \n             give four decimal places of precision')
wirelessLinkStatusLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 0), ("registering", 1), ("searching", 2), ("acquiring", 3), ("radarCAC", 4), ("initialising", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkStatusLinked.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkStatusLinked.setDescription('Current status of the wireless link')
byteErrorRatioLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: byteErrorRatioLinked.setStatus('current')
if mibBuilder.loadTexts: byteErrorRatioLinked.setDescription('Reciprocal of the byte error ratio calculated since the \n             last reset of the system counters')
receiveModulationModeDetailLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("runningAtMaximumReceiveMode", 0), ("runningAtUserConfiguredMaxModulationMode", 1), ("restrictedBecauseInstallationIsArmed", 2), ("restrictedBecauseOfByteErrorsOnTheWirelessLink", 3), ("restrictedBecauseTheLinkParametersAreUpdating", 4), ("restrictedBecauseChannelChangeIsInProgress", 5), ("restrictedDueToTheLowEthernetLinkSpeed", 6), ("runningAtMaximumReceiveModeForChannelBandwidth", 7), ("limitedByTheWirelessConditions", 8), ("restrictedBecauseFullCapabilityTrialLicenseExpired", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationModeDetailLinked.setStatus('current')
if mibBuilder.loadTexts: receiveModulationModeDetailLinked.setDescription('The reason for the current receive modulation mode')
dataBridgingAvailabilityLinked = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingAvailabilityLinked.setStatus('current')
if mibBuilder.loadTexts: dataBridgingAvailabilityLinked.setDescription('Link availability bridging Ethernet Data traffic \n             calculated since the last reset of the system counters, \n             as a percentage multiplied by 10000 to give four decimal \n             places of precision')
pubInstancedStatsTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 20, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pubInstancedStatsTableNumber.setStatus('current')
if mibBuilder.loadTexts: pubInstancedStatsTableNumber.setDescription('Number of entries in the pubInstancedStatsTable.')
pubInstancedStatsTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: pubInstancedStatsTableIndex.setStatus('current')
if mibBuilder.loadTexts: pubInstancedStatsTableIndex.setDescription('Used to index the pubInstancedStatsTable.')
receiveDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveDataRate.setStatus('current')
if mibBuilder.loadTexts: receiveDataRate.setDescription('Histogram of the average link receive data rate. ')
transmitDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: transmitDataRate.setStatus('current')
if mibBuilder.loadTexts: transmitDataRate.setDescription('Histogram of the average link transmit data rate. ')
aggregateDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggregateDataRate.setStatus('current')
if mibBuilder.loadTexts: aggregateDataRate.setDescription('Histogram of the link aggregate data rate. ')
wirelessLinkAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkAvailability.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkAvailability.setDescription('Link availability calculated since the last reset of the \n             system counters')
wirelessLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 0), ("registering", 1), ("searching", 2), ("acquiring", 3), ("radarCAC", 4), ("initialising", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessLinkStatus.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkStatus.setDescription("Current status of the wireless link. A state of 'Up' on \n             a green background indicates that a wireless link is \n             established")
receiveModulationModeDetail = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("runningAtMaximumReceiveMode", 0), ("runningAtUserConfiguredMaxModulationMode", 1), ("restrictedBecauseInstallationIsArmed", 2), ("restrictedBecauseOfByteErrorsOnTheWirelessLink", 3), ("restrictedBecauseTheLinkParametersAreUpdating", 4), ("restrictedBecauseChannelChangeIsInProgress", 5), ("restrictedDueToTheLowEthernetLinkSpeed", 6), ("runningAtMaximumReceiveModeForChannelBandwidth", 7), ("limitedByTheWirelessConditions", 8), ("restrictedBecauseFullCapabilityTrialLicenseExpired", 9), ("acquiringLink", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: receiveModulationModeDetail.setStatus('current')
if mibBuilder.loadTexts: receiveModulationModeDetail.setDescription('A brief description of the reason for the current \n             receive modulation mode')
dataBridgingAvailability = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataBridgingAvailability.setStatus('current')
if mibBuilder.loadTexts: dataBridgingAvailability.setDescription('Link availability for bridging Ethernet Data traffic \n             calculated since the last reset of the system counters')
byteErrorRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: byteErrorRatio.setStatus('current')
if mibBuilder.loadTexts: byteErrorRatio.setDescription('Reciprocal of the byte error ratio calculated since the \n             last reset of the system counters')
wirelessOutEthernetOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessOutEthernetOctets.setStatus('current')
if mibBuilder.loadTexts: wirelessOutEthernetOctets.setDescription('Cumulative total of octets transmitted in data or \n             management service at the wireless interface. This \n             excludes wireless MAC headers, MAC management messages, \n             and Null bytes.')
wirelessOutAllOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessOutAllOctets.setStatus('current')
if mibBuilder.loadTexts: wirelessOutAllOctets.setDescription('Cumulative total of octets transmitted at the wireless \n             interface. This includes data service, management \n             service, wireless MAC headers, MAC management messages, \n             and Null bytes.')
wirelessOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wirelessOutOctets.setStatus('current')
if mibBuilder.loadTexts: wirelessOutOctets.setDescription('Cumulative total of octets including wireless MAC \n             headers transmitted in data or management service at the \n             wireless interface. This excludes MAC management messages \n             and Null bytes.')
erroredSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: erroredSeconds.setStatus('current')
if mibBuilder.loadTexts: erroredSeconds.setDescription('erroredSeconds count for any second period containing \n             one or more codeword errors since the last reset of the \n             system counters.')
severelyErroredSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: severelyErroredSeconds.setStatus('current')
if mibBuilder.loadTexts: severelyErroredSeconds.setDescription('severelyErroredSeconds count for any second period \n             containing ten or more codeword errors since the last \n             reset of the system counters.')
unavailableSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 20, 10, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: unavailableSeconds.setStatus('current')
if mibBuilder.loadTexts: unavailableSeconds.setDescription('unavailableSeconds count for any second when Data \n             Bridging Status = Disabled since the last reset of the \n             system counters. Note erroredSeconds and \n             severelyErroredSeconds are not incremented when the link \n             is unavailable.')
encryptionAlgorithm = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 0), ("pSKAES128bit", 1), ("pSKAES192bit", 2), ("pSKAES256bit", 3), ("tLSRSA", 4), ("tLSPSK128bit", 5), ("tLSPSK256bit", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: encryptionAlgorithm.setStatus('current')
if mibBuilder.loadTexts: encryptionAlgorithm.setDescription('The Encryption Algorithm used by the wireless link. NB: \n             A system reboot is required to activate changes to this \n             attribute. NB: The same Encryption Algorithm must be \n             configured at BOTH ends of the link for it to function \n             correctly. TLS RSA Encryption Algorithm is not compatible \n             with Link Name access method.')
tLSMinimumSecurityLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 22, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("aES128bitTLSRSA", 1), ("aES256bitTLSRSA", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tLSMinimumSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: tLSMinimumSecurityLevel.setDescription('The minimum level of security that is supported on the \n             device')
tDDSynchronizationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 23, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tDDSynchronizationMode.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationMode.setDescription('TDD Synchronization Mode selection')
hCMPMaximumLinkRange = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 23, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(50, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hCMPMaximumLinkRange.setStatus('current')
if mibBuilder.loadTexts: hCMPMaximumLinkRange.setDescription('The maximum link range between the HCMP Master and any \n             HCMP Slave. The same value must be used on both the HCMP \n             Master and its Slaves.')
maximumNumberOfSlaves = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 23, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: maximumNumberOfSlaves.setStatus('current')
if mibBuilder.loadTexts: maximumNumberOfSlaves.setDescription('The maximum number of HCMP Slaves that an HCMP Master \n             can simultaneously connect to. The same value has to be \n             used in both the HCMP Master and its Slaves.')
hCMPLinkSymmetry = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 23, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("symmetry4to1", 0), ("symmetry3to1", 1), ("symmetry2to1", 2), ("symmetry1to1", 3), ("symmetry1to2", 4), ("symmetry1to3", 5), ("symmetry1to4", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hCMPLinkSymmetry.setStatus('current')
if mibBuilder.loadTexts: hCMPLinkSymmetry.setDescription('Provides configuration options for sharing the available \n             wireless capacity among all Slaves between the transmit \n             and receive directions. Option x to y is the ratio of \n             Total Downlink capacity to Total Uplink Capacity. The \n             same value has to be used in both the HCMP Master and its \n             Slaves.')
userTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 25, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userTableNumber.setStatus('current')
if mibBuilder.loadTexts: userTableNumber.setDescription('Number of entries in the userTable')
userTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: userTableIndex.setStatus('current')
if mibBuilder.loadTexts: userTableIndex.setDescription('used to index values in the userTable.')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 67))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('current')
if mibBuilder.loadTexts: userName.setDescription('User name which must be entered, along with the \n             appropriate password, in order to gain access to the \n             system.')
userRole = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("readOnly", 0), ("systemAdministrator", 1), ("securityOfficer", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userRole.setStatus('current')
if mibBuilder.loadTexts: userRole.setDescription('Role of the selected user. A Security Officer has access \n             to and can modify all settings. A System Administrator \n             has access to and can modify all non-security settings. A \n             Read Only user can view settings, but cannot make any \n             changes.')
userEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userEnabled.setStatus('current')
if mibBuilder.loadTexts: userEnabled.setDescription('Enable / Disable the selected user')
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 25, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 67))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('current')
if mibBuilder.loadTexts: userPassword.setDescription('User password, which must be entered in order to gain \n             access to the system.')
syslogClient = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 24, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogClient.setStatus('current')
if mibBuilder.loadTexts: syslogClient.setDescription('Enable or disable the syslog client')
syslogState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 24, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogState.setStatus('current')
if mibBuilder.loadTexts: syslogState.setDescription('The syslog service has been enabled or disabled')
microwaveAdaptiveBandwidth = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: microwaveAdaptiveBandwidth.setStatus('current')
if mibBuilder.loadTexts: microwaveAdaptiveBandwidth.setDescription('Enable support of Microwave Adaptive Bandwidth Protocol. \n             MAB is disabled if link symmetry is configured as \n             Adaptive')
mABNominalModulationMode = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("modAcquisition", 0), ("modBpsk63percent", 1), ("modQpsk63percentSingle", 2), ("modTransient1", 3), ("modQpsk87percentSingle", 4), ("modTransient2", 5), ("mod16qam63percentSingleA", 6), ("modTransient3", 7), ("mod16qam87percentSingle", 8), ("modTransient4", 9), ("mod64qam75percentSingle", 10), ("modTransient5", 11), ("mod64qam92percentSingle", 12), ("modTransient6", 13), ("mod256qam81percentSingle", 14), ("mod16qam63percentSingleB", 15), ("mod16qam63percentDual", 16), ("modTransient7", 17), ("mod16qam87percentDual", 18), ("modTransient8", 19), ("mod64qam75percentDual", 20), ("modTransient9", 21), ("mod64qam92percentDual", 22), ("modTransient10", 23), ("mod256qam81percentDual", 24)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABNominalModulationMode.setStatus('current')
if mibBuilder.loadTexts: mABNominalModulationMode.setDescription('The Nominal modulation mode is the desired modulation \n             mode. MAB VSM packets are generated when the current \n             modulation mode falls below the nominal modulation.')
mABTransmissionInterval = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("transmissionInterval1s", 0), ("transmissionInterval10s", 1), ("transmissionInterval60s", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABTransmissionInterval.setStatus('current')
if mibBuilder.loadTexts: mABTransmissionInterval.setDescription('The minimum interval (in seconds) between successive MAB \n             vendor specific messages (VSM). These VSM are sent when \n             the current transmit capacity falls below the configured \n             MAB Nominal Modulation Mode.')
mABHoldoffPeriod = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABHoldoffPeriod.setStatus('current')
if mibBuilder.loadTexts: mABHoldoffPeriod.setDescription('The period (in seconds) over which transmit capacity is \n             averaged over to determine when the wireless link has \n             degraded')
mABMaintenanceLevel = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABMaintenanceLevel.setStatus('current')
if mibBuilder.loadTexts: mABMaintenanceLevel.setDescription('Maintenance Levels (0-7) determines the destination MAC \n             address of MAB vendor specific messages.')
useVLANForMABProtocol = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noVLANTagging", 0), ("iEEE8021QTaggedCTagType8100", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: useVLANForMABProtocol.setStatus('current')
if mibBuilder.loadTexts: useVLANForMABProtocol.setDescription('This controls whether MAB vendor specific messages (VSM) \n             packets use VLAN tags or not.')
mABProtocolVID = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABProtocolVID.setStatus('current')
if mibBuilder.loadTexts: mABProtocolVID.setDescription('This VLAN VID (0-4094) will be included in MAB vendor \n             specific messages (VSM) packets.')
mABProtocolVLANPriority = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABProtocolVLANPriority.setStatus('current')
if mibBuilder.loadTexts: mABProtocolVLANPriority.setDescription('This VLAN Priority (0-7) will be included in MAB vendor \n             specific messages (VSM) packets.')
mABState = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("degraded", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABState.setStatus('current')
if mibBuilder.loadTexts: mABState.setDescription("Current state of MAB Protocol. A state of 'Normal' on a \n             green background indicates that a wireless link is \n             operating at nominal capacity")
mABNominalTransmitCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABNominalTransmitCapacity.setStatus('current')
if mibBuilder.loadTexts: mABNominalTransmitCapacity.setDescription('The nominal Tx capacity used in MAB Vendor Specific \n             Messages for the selected nominal modulation mode ')
mABCurrentTransmitCapacity = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 26, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mABCurrentTransmitCapacity.setStatus('current')
if mibBuilder.loadTexts: mABCurrentTransmitCapacity.setDescription('The current Tx capacity of the wireless link used in the \n             last MAB Vendor Specific Message transmitted.')
cableDiagnosticsPorts = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 27, 1), Bits().clone(namedValues=NamedValues(("auxPort", 6), ("mainPSUPort", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableDiagnosticsPorts.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsPorts.setDescription('Select ports on which Cable Diagnostics must be \n             executed')
cableDiagnosticsControl = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 27, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("startTest", 0), ("testInProgress", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cableDiagnosticsControl.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsControl.setDescription("Set this attribute to 'Test in Progress' to start a \n             Cable Diagnostics test")
cableDiagnosticsWarning = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 27, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("idle", 0), ("testInProgress", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsWarning.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsWarning.setDescription('Normal Ethernet operation is disrupted when a Cable \n             Diagnostics test is in progress')
cableDiagnosticsResultTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 27, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsResultTableNumber.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableNumber.setDescription('Number of rows in the Cable Diagnostics Result Table.')
cableDiagnosticsResultTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: cableDiagnosticsResultTableIndex.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultTableIndex.setDescription('Cable Diagnostics Port value used to index into the \n             result table.')
cableDiagnosticsResultsDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagnosticsResultsDateTime.setStatus('current')
if mibBuilder.loadTexts: cableDiagnosticsResultsDateTime.setDescription('The Date and Time when a Cable Diagnostics test was last \n             executed')
cableDiagPair1Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair1Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair1Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 1. According to the T658B \n             wiring scheme, pair 1 is pins 4 & 5 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair1Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair1Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair1Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair2Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair2Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair2Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 2. According to the T658B \n             wiring scheme, pair 2 is pins 1 & 2 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair2Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair2Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair2Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair3Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair3Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair3Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 3. According to the T658B \n             wiring scheme, pair 3 is pins 3 & 6 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair3Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair3Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair3Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
cableDiagPair4Results = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 0), ("unknown", 1), ("inProgress", 2), ("notTested", 3), ("openCircuit", 4), ("shortCircuit", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair4Results.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair4Results.setDescription('The result of the most recent execution of Cable \n             Diagnostics on cable pair 4. According to the T658B \n             wiring scheme, pair 4 is pins 7 & 8 on the RJ45 socket on \n             the ODU. Open Circuit is reported when the impedance is \n             greater than 330 ohms. Short Circuit is reported when the \n             impedance is less than 33 ohms. Unknown is reported when \n             a continuous signal is received from the link partner for \n             125 ms, preventing start of the test.')
cableDiagPair4Distance = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 27, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cableDiagPair4Distance.setStatus('current')
if mibBuilder.loadTexts: cableDiagPair4Distance.setDescription('The distance in meters from the ODU to the fault \n             detected on the cable pair during the most recent \n             execution of Cable Diagnostics. Faults in cables longer \n             than 160 meters (525 feet) may not be detected. The error \n             margin is +/-2 meters (6.5 feet).')
deviceMACAddress = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 28, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMACAddress.setStatus('current')
if mibBuilder.loadTexts: deviceMACAddress.setDescription('Device MAC address')
deviceESN = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 28, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceESN.setStatus('current')
if mibBuilder.loadTexts: deviceESN.setDescription('The ESN assigned to this device')
deviceMSN = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 28, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMSN.setStatus('current')
if mibBuilder.loadTexts: deviceMSN.setDescription('The MSN assigned to this device')
authorizationControlTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 29, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: authorizationControlTableNumber.setStatus('current')
if mibBuilder.loadTexts: authorizationControlTableNumber.setDescription('Number of entries in the AuthorizationControlTable.')
authorizationControlTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: authorizationControlTableIndex.setStatus('current')
if mibBuilder.loadTexts: authorizationControlTableIndex.setDescription('Authorization Control Table Index')
whitelistRMMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: whitelistRMMacAddress.setStatus('current')
if mibBuilder.loadTexts: whitelistRMMacAddress.setDescription('MAC Address of Remote Modules.')
whitelistRMEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: whitelistRMEnabled.setStatus('current')
if mibBuilder.loadTexts: whitelistRMEnabled.setDescription('Whether this Remote Module is enabled. Only Enabled \n             Remote Modules are allowed to connect to this device.')
blacklistRMMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: blacklistRMMacAddress.setStatus('current')
if mibBuilder.loadTexts: blacklistRMMacAddress.setDescription('MAC Address of Remote Modules.')
blacklistRMEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 29, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: blacklistRMEnabled.setStatus('current')
if mibBuilder.loadTexts: blacklistRMEnabled.setDescription('Whether this Remote Module is enabled. Only Enabled \n             Remote Modules are black listed; they cannot connect to \n             this ODU.')
dNSResolver = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 30, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dNSResolver.setStatus('current')
if mibBuilder.loadTexts: dNSResolver.setDescription('Enable/Disable DNS Resolver.')
dNSPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 30, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("server1", 0), ("server2", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dNSPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: dNSPrimaryServer.setDescription('Specifies the primary DNS server, determining the order \n             in which the servers are tried.')
dNSServerTableNumber = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 30, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dNSServerTableNumber.setStatus('current')
if mibBuilder.loadTexts: dNSServerTableNumber.setDescription('Number of entries in the DNSServerTable.')
dNSServerTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2)))
if mibBuilder.loadTexts: dNSServerTableIndex.setStatus('current')
if mibBuilder.loadTexts: dNSServerTableIndex.setDescription('Index range for the DNSServerTable.')
dNSServerInternetAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("unknown", 0), ("ipv4", 1), ("ipv6", 2), ("ipv4z", 3), ("ipv6z", 4), ("unknown6", 5), ("unknown7", 6), ("unknown8", 7), ("unknown9", 8), ("unknown10", 9), ("unknown11", 10), ("unknown12", 11), ("unknown13", 12), ("unknown14", 13), ("unknown15", 14), ("unknown16", 15), ("dns", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dNSServerInternetAddressType.setStatus('current')
if mibBuilder.loadTexts: dNSServerInternetAddressType.setDescription('The type of Internet address specified by the associated \n             dNSServerInternetAddress.')
dNSServerInternetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4, 1, 3), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dNSServerInternetAddress.setStatus('current')
if mibBuilder.loadTexts: dNSServerInternetAddress.setDescription('IP Address of the DNS Server which will be used to \n             resolve hostname into IP Addresses .')
dNSServerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 17713, 11, 30, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dNSServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: dNSServerPortNumber.setDescription('UDP Port Number of DNS Service on the Server.')
longitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 96, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: longitude.setStatus('current')
if mibBuilder.loadTexts: longitude.setDescription('The longitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
latitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 96, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: latitude.setStatus('current')
if mibBuilder.loadTexts: latitude.setDescription('The latitude of the unit, measured in decimal degrees. \n             This object is set by the SNMP manager and has no \n             internal function.')
altitude = MibScalar((1, 3, 6, 1, 4, 1, 17713, 11, 96, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: altitude.setStatus('current')
if mibBuilder.loadTexts: altitude.setDescription('The altitude of the unit, measured in meters. This \n             object is set by the SNMP manager and has no internal \n             function.')
channelChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 1)).setObjects(("CAMBIUM-PTP670-MIB", "receiveChannel"))
if mibBuilder.loadTexts: channelChangeTrap.setStatus('current')
if mibBuilder.loadTexts: channelChangeTrap.setDescription('The PTP radio has changed wireless channel.\n                 This has been caused by either\n                 i) mandatory radar avoidance,\n                    a DFS impulsive interference event will also be\n                    detected,\n                 or\n                 ii) Dynamic Spectrum Optimization, (DSO)\n                     DSO improves link performance by selecting the\n                     most appropriate transmit and receive channels\n                     with the lowest level of interference.')
dfsImpulsiveInterferenceTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 2)).setObjects(("CAMBIUM-PTP670-MIB", "receiveChannel"))
if mibBuilder.loadTexts: dfsImpulsiveInterferenceTrap.setStatus('current')
if mibBuilder.loadTexts: dfsImpulsiveInterferenceTrap.setDescription('DFS impulsive interference detected event')
lbtDetectedTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 46)).setObjects(("CAMBIUM-PTP670-MIB", "receiveChannel"))
if mibBuilder.loadTexts: lbtDetectedTrap.setStatus('current')
if mibBuilder.loadTexts: lbtDetectedTrap.setDescription('Listen-Before-Talk (LBT) detected event')
mainPSUPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 3)).setObjects(("CAMBIUM-PTP670-MIB", "mainPSUPortStatus"))
if mibBuilder.loadTexts: mainPSUPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortStatusTrap.setDescription('Current status of the Main PSU Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
mainPSUPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 4)).setObjects(("CAMBIUM-PTP670-MIB", "mainPSUPortDisabledWarning"))
if mibBuilder.loadTexts: mainPSUPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
mainPSUPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 5)).setObjects(("CAMBIUM-PTP670-MIB", "mainPSUPortConfigurationMismatch"))
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: mainPSUPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch')
auxPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 6)).setObjects(("CAMBIUM-PTP670-MIB", "auxPortStatus"))
if mibBuilder.loadTexts: auxPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortStatusTrap.setDescription('Current status of the Aux Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
auxPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 7)).setObjects(("CAMBIUM-PTP670-MIB", "auxPortDisabledWarning"))
if mibBuilder.loadTexts: auxPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
regulatoryBandTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 8)).setObjects(("CAMBIUM-PTP670-MIB", "regulatoryBand"))
if mibBuilder.loadTexts: regulatoryBandTrap.setStatus('current')
if mibBuilder.loadTexts: regulatoryBandTrap.setDescription('The Regulatory Band prohibits the wireless unit from \n             operating outside the regulated limits. An invalid \n             Regulatory Band may be caused by a missing or incorrect \n             License Key, a corrupt MAC Address or an attempt to \n             configure a Regulatory Band not allowed by the License \n             Key or an execution of Reset Configuration. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert.')
installStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 9)).setObjects(("CAMBIUM-PTP670-MIB", "installStatus"))
if mibBuilder.loadTexts: installStatusTrap.setStatus('current')
if mibBuilder.loadTexts: installStatusTrap.setDescription('A non-zero value indicates that signalling was received \n             with the wrong MAC address or a mismatched link name. NB: \n             It is very unusual to detect this, because units with \n             mis-configured Target MAC Address will normally fail to \n             establish a wireless link. However, rare circumstances \n             may establish a partial wireless link and detect this \n             situation. NB: A non-zero value on start-up, or a change \n             of value during operation, may generate an SNMP trap \n             and/or SMTP email alert')
installArmStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 10)).setObjects(("CAMBIUM-PTP670-MIB", "installArmState"))
if mibBuilder.loadTexts: installArmStateTrap.setStatus('current')
if mibBuilder.loadTexts: installArmStateTrap.setDescription('Indicates if the unit is being installed. NB: a change \n             of state may generate an SNMP trap and/or SMTP email \n             alert')
unitOutOfCalibrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 11)).setObjects(("CAMBIUM-PTP670-MIB", "unitOutOfCalibration"))
if mibBuilder.loadTexts: unitOutOfCalibrationTrap.setStatus('current')
if mibBuilder.loadTexts: unitOutOfCalibrationTrap.setDescription('The unit is out of calibration')
auxPortPowerOverEthernetOutputStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 12)).setObjects(("CAMBIUM-PTP670-MIB", "auxPortPowerOverEthernetOutputStatus"))
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatusTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortPowerOverEthernetOutputStatusTrap.setDescription('Current status of the Power Over Ethernet (PoE) output \n             of the Aux port')
incompatibleRegulatoryBandsTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 14)).setObjects(("CAMBIUM-PTP670-MIB", "incompatibleRegulatoryBands"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: incompatibleRegulatoryBandsTrap.setStatus('current')
if mibBuilder.loadTexts: incompatibleRegulatoryBandsTrap.setDescription('The master and slave units have incompatible regulatory \n             bands. NB: Both units must have compatible license keys')
noWirelessChannelAvailableTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 15)).setObjects(("CAMBIUM-PTP670-MIB", "noWirelessChannelAvailable"))
if mibBuilder.loadTexts: noWirelessChannelAvailableTrap.setStatus('current')
if mibBuilder.loadTexts: noWirelessChannelAvailableTrap.setDescription('Spectrum Management was unable to locate a suitable \n             wireless channel to operate on')
wirelessLinkDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 16)).setObjects(("CAMBIUM-PTP670-MIB", "wirelessLinkDisabledWarning"))
if mibBuilder.loadTexts: wirelessLinkDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the wireless interface has \n             disabled wireless traffic')
auxPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 17)).setObjects(("CAMBIUM-PTP670-MIB", "auxPortConfigurationMismatch"))
if mibBuilder.loadTexts: auxPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: auxPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
sFPErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 18)).setObjects(("CAMBIUM-PTP670-MIB", "sFPError"))
if mibBuilder.loadTexts: sFPErrorTrap.setStatus('current')
if mibBuilder.loadTexts: sFPErrorTrap.setDescription('If the SFP link is not OK, there are five possible \n             causes: Either a SFP has been installed but the license \n             key does not include SFP fiber support, a fiber link \n             could not be established even though no LOS was detected \n             (i.e. an optical carrier was detected, which could be due \n             to a broken TX fiber, or because the link is disabled at \n             the fiber link partner), a fiber link could not be \n             established and LOS is detected (i.e. no optical carrier \n             is detected), the installed SFP is not supported or the \n             installed SFP failed to initialize correctly. NB: a \n             change of status may generate an SNMP trap and/or SMTP \n             email alert')
sFPPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 19)).setObjects(("CAMBIUM-PTP670-MIB", "sFPPortStatus"))
if mibBuilder.loadTexts: sFPPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortStatusTrap.setDescription('Current status of the SFP Ethernet link. NB: a change of \n             state may generate an SNMP trap and/or SMTP email alert')
incompatibleMasterAndSlaveTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 20)).setObjects(("CAMBIUM-PTP670-MIB", "incompatibleMasterAndSlave"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: incompatibleMasterAndSlaveTrap.setStatus('current')
if mibBuilder.loadTexts: incompatibleMasterAndSlaveTrap.setDescription('A non-zero value indicates that the master and slave \n             ends of a link are different hardware products, or have \n             different software versions, or have different TDD Frame \n             Configuraton Modes (Standard/Expert) in HCMP topology. \n             NB: It is very unusual to detect this, because \n             incompatible units will normally fail to establish a \n             wireless link. However, some combinations may establish a \n             partial wireless link and detect this situation. NB: A \n             non-zero value may generate an SNMP trap and/or SMTP \n             email alert')
sNTPSyncTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 21)).setObjects(("CAMBIUM-PTP670-MIB", "sNTPSync"))
if mibBuilder.loadTexts: sNTPSyncTrap.setStatus('current')
if mibBuilder.loadTexts: sNTPSyncTrap.setDescription('If SNTP Sync fails then check the server settings in the \n             Remote Management page, or disable SNTP')
tDDSynchronizationAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 22)).setObjects(("CAMBIUM-PTP670-MIB", "tDDSynchronizationAlarm"))
if mibBuilder.loadTexts: tDDSynchronizationAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: tDDSynchronizationAlarmTrap.setDescription('Not Synchronized indicates failure of the external \n             timing system for a period greater than the holdover \n             timer. TDD frame timing will have drifted, and this link \n             may cause interference with other links in a synchronized \n             network. Timing System Failure is an early warning, \n             indicating that 80% of the holdover period has expired.')
sFPPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 23)).setObjects(("CAMBIUM-PTP670-MIB", "sFPPortDisabledWarning"))
if mibBuilder.loadTexts: sFPPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
sFPPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 24)).setObjects(("CAMBIUM-PTP670-MIB", "sFPPortConfigurationMismatch"))
if mibBuilder.loadTexts: sFPPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: sFPPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch. This \n             alarm is only raised if an Out-of-Band Management Mode \n             has been configured.')
linkModeOptimizationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 25)).setObjects(("CAMBIUM-PTP670-MIB", "linkModeOptimizationMismatch"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: linkModeOptimizationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: linkModeOptimizationMismatchTrap.setDescription('The remote node of this link has been configured with a \n             different link mode optimization')
tDMInterfaceStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 26)).setObjects(("CAMBIUM-PTP670-MIB", "tDMInterfaceStatus"))
if mibBuilder.loadTexts: tDMInterfaceStatusTrap.setStatus('current')
if mibBuilder.loadTexts: tDMInterfaceStatusTrap.setDescription("@Current status of the connection to the TDM Box. A \n             state of 'Up' on a green background indicates that the \n             TDM Box is connected OK. When connecting a TDM Box only \n             the Main Ethernet port should be used")
tDMChannelStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 27)).setObjects(("CAMBIUM-PTP670-MIB", "tDMChannelStatus"))
if mibBuilder.loadTexts: tDMChannelStatusTrap.setStatus('current')
if mibBuilder.loadTexts: tDMChannelStatusTrap.setDescription('Current status of the TDM channels. A value of 0 \n             indicates that a TDM channel is established')
tDMChannelLoopbackTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 28)).setObjects(("CAMBIUM-PTP670-MIB", "tDMChannelLoopback"))
if mibBuilder.loadTexts: tDMChannelLoopbackTrap.setStatus('current')
if mibBuilder.loadTexts: tDMChannelLoopbackTrap.setDescription("The loopback status of TDM channels. This is intended \n             for installation testing and should be set to 'None' for \n             normal operation. The wire connections to a unit can be \n             tested by applying a 'Copper' loopback to the local unit. \n             The wireless connection to the remote unit can be tested \n             by applying a 'Wireless' loopback to the remote unit with \n             no loopback on the local unit. NB: a change of state may \n             generate an SNMP trap and/or SMTP email alert")
nIDULanPortStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 29)).setObjects(("CAMBIUM-PTP670-MIB", "nIDULanPortStatus"))
if mibBuilder.loadTexts: nIDULanPortStatusTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortStatusTrap.setDescription('Current status of the NIDU LAN Ethernet link. NB: a \n             change of state may generate an SNMP trap and/or SMTP \n             email alert')
syslogStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 30)).setObjects(("CAMBIUM-PTP670-MIB", "syslogState"))
if mibBuilder.loadTexts: syslogStateTrap.setStatus('current')
if mibBuilder.loadTexts: syslogStateTrap.setDescription('The syslog service has been enabled or disabled')
syslogLocalNearlyFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 31))
if mibBuilder.loadTexts: syslogLocalNearlyFullTrap.setStatus('current')
if mibBuilder.loadTexts: syslogLocalNearlyFullTrap.setDescription('The syslog local log is nearly full (90%)')
syslogLocalWrappedTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 32))
if mibBuilder.loadTexts: syslogLocalWrappedTrap.setStatus('current')
if mibBuilder.loadTexts: syslogLocalWrappedTrap.setDescription('The syslog local log has wrapped')
syslogClientTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 33)).setObjects(("CAMBIUM-PTP670-MIB", "syslogClient"))
if mibBuilder.loadTexts: syslogClientTrap.setStatus('current')
if mibBuilder.loadTexts: syslogClientTrap.setDescription('Enable or disable the syslog client')
secureModeAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 34)).setObjects(("CAMBIUM-PTP670-MIB", "secureModeAlarm"))
if mibBuilder.loadTexts: secureModeAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: secureModeAlarmTrap.setDescription('The secure mode (e.g. FIPS, UC-APL) state of the unit. \n             The secure mode is not configured(1) state indicates that \n             the unit is capable of secure mode operation, and one or \n             more of the following security materials has not been \n             configured: Key Of Keys, Private Key, Public Certificate, \n             DRNG Entropy Status, Wireless Encryption Key. The secure \n             mode mode is configured but not active(2) state indicates \n             that the unit is capable of secure mode operation, and \n             the security material has been configured, but the \n             configuration of interfaces is not consistent with secure \n             mode operation. The secure mode is not supported(3) state \n             indicates that the unit is not capable of secure mode \n             operation. The secure mode capability requires \n             appropriate hardware compatibility, license key and \n             software image.')
dataBridgingStatusAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 35)).setObjects(("CAMBIUM-PTP670-MIB", "dataBridgingStatusAlarm"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: dataBridgingStatusAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: dataBridgingStatusAlarmTrap.setDescription('Ethernet Data traffic bridging is disabled because the \n             wireless link is not operating at the configured Lowest \n             Data Modulation Mode')
licenseRemainingTrialPeriodAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 36)).setObjects(("CAMBIUM-PTP670-MIB", "licenseRemainingTrialPeriodAlarm"))
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: licenseRemainingTrialPeriodAlarmTrap.setDescription('If the full capability trial license period is about to \n             expire then purchase a license upgrade from your \n             reseller.')
capacityVariantMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 37)).setObjects(("CAMBIUM-PTP670-MIB", "capacityVariantMismatch"))
if mibBuilder.loadTexts: capacityVariantMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: capacityVariantMismatchTrap.setDescription('The remote node of this link has a lower link capacity. \n             Operating with a reduced effective link capacity.')
maxLinkRangeExceededTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 38)).setObjects(("CAMBIUM-PTP670-MIB", "maxLinkRangeExceeded"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: maxLinkRangeExceededTrap.setStatus('current')
if mibBuilder.loadTexts: maxLinkRangeExceededTrap.setDescription('The measured link range is greater than the maximum \n             allowed by the license key. The link will operate at a \n             reduced capacity while this condition applies. This alarm \n             is only raised if the license specifies a maximum link \n             range and the trial license is not active.')
tDMConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 39)).setObjects(("CAMBIUM-PTP670-MIB", "tDMConfigurationMismatch"))
if mibBuilder.loadTexts: tDMConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: tDMConfigurationMismatchTrap.setDescription("Current status of the configuration of the TDM Box. A \n             state of 'Ok' on a green background indicates that the \n             TDM Box configuration is matched OK with the remote end.")
nIDULanPortDisabledWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 40)).setObjects(("CAMBIUM-PTP670-MIB", "nIDULanPortDisabledWarning"))
if mibBuilder.loadTexts: nIDULanPortDisabledWarningTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortDisabledWarningTrap.setDescription('The SNMP ifAdminStatus of the interface has disabled \n             Ethernet traffic')
nIDULanPortConfigurationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 41)).setObjects(("CAMBIUM-PTP670-MIB", "nIDULanPortConfigurationMismatch"))
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: nIDULanPortConfigurationMismatchTrap.setDescription('The detection of Ethernet fragments (runt packets) when \n             the link is in full duplex is an indication of an \n             auto-negotiation or forced configuration mismatch.')
portAllocationMismatchTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 44)).setObjects(("CAMBIUM-PTP670-MIB", "portAllocationMismatch"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: portAllocationMismatchTrap.setStatus('current')
if mibBuilder.loadTexts: portAllocationMismatchTrap.setDescription('The local and remote ODUs have different services \n             configured.')
wirelessLinkStatusAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 45)).setObjects(("CAMBIUM-PTP670-MIB", "wirelessLinkStatusAlarm"), ("CAMBIUM-PTP670-MIB", "remoteMACAddress"))
if mibBuilder.loadTexts: wirelessLinkStatusAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: wirelessLinkStatusAlarmTrap.setDescription('Current status of the wireless link. A state of Up on a \n             green background indicates that a wireless link is \n             established')
secureLicenseSignatureAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 17713, 11, 99, 0, 47)).setObjects(("CAMBIUM-PTP670-MIB", "secureLicenseSignatureAlarm"))
if mibBuilder.loadTexts: secureLicenseSignatureAlarmTrap.setStatus('current')
if mibBuilder.loadTexts: secureLicenseSignatureAlarmTrap.setDescription("Alarm condition indicates that the unit's license is not \n             secure enough for FIPS approved mode.")
mibBuilder.exportSymbols("CAMBIUM-PTP670-MIB", receiveFreqMHz=receiveFreqMHz, ptpGroups=ptpGroups, cableDiagPair1Distance=cableDiagPair1Distance, sFPPortSpeedAndDuplex=sFPPortSpeedAndDuplex, erroredSeconds=erroredSeconds, antennaSelection=antennaSelection, licenseRARSupport=licenseRARSupport, sMTPSourceEmailAddress=sMTPSourceEmailAddress, sNMPEnabledTraps=sNMPEnabledTraps, syslogClientTrap=syslogClientTrap, secureModeAlarm=secureModeAlarm, licenseOOBManagementSupport=licenseOOBManagementSupport, vectorError=vectorError, dataBridgingAvailabilityLinked=dataBridgingAvailabilityLinked, sFPPortAutoNegAdvertisement=sFPPortAutoNegAdvertisement, hTTPSPortNumber=hTTPSPortNumber, licenseGroup=licenseGroup, sNTPLastSync=sNTPLastSync, sFPPortDisabledWarning=sFPPortDisabledWarning, linkName=linkName, masterSlaveMode=masterSlaveMode, portAllocationMismatchTrap=portAllocationMismatchTrap, transparentClock=transparentClock, severelyErroredSeconds=severelyErroredSeconds, tDDSynchronizationAlarm=tDDSynchronizationAlarm, authorizationControlTableNumber=authorizationControlTableNumber, tDMChannelLineCode=tDMChannelLineCode, smtp=smtp, transmitModulationModeLinked=transmitModulationModeLinked, configurationGroup=configurationGroup, mABHoldoffPeriod=mABHoldoffPeriod, dfsNineNinePointNinePercentiles=dfsNineNinePointNinePercentiles, tDDControlGroup=tDDControlGroup, bootVersion=bootVersion, sFPPortSyncEMasterSlaveStatus=sFPPortSyncEMasterSlaveStatus, mgmtInstancedTableNumber=mgmtInstancedTableNumber, phyControlInstancedTableNumber=phyControlInstancedTableNumber, systemClock=systemClock, mainPSUPortAutoNegotiation=mainPSUPortAutoNegotiation, tDMChannelStatus=tDMChannelStatus, mainPSUPortAutoNegAdvertisement=mainPSUPortAutoNegAdvertisement, licenseInstancedTableIndex=licenseInstancedTableIndex, tFTPServerInternetAddress=tFTPServerInternetAddress, cableDiagnosticsGroup=cableDiagnosticsGroup, cableDiagnosticsControl=cableDiagnosticsControl, licenseMaxNumberOfTDMChannels=licenseMaxNumberOfTDMChannels, l2CPPriorityQueueMapping=l2CPPriorityQueueMapping, licenseFullCapabilityTrialStatus=licenseFullCapabilityTrialStatus, cableDiagnostics=cableDiagnostics, remoteInternetAddressTypeLinked=remoteInternetAddressTypeLinked, blacklistRMEnabled=blacklistRMEnabled, ethernetStatisticsTxOctets=ethernetStatisticsTxOctets, tFTPClient=tFTPClient, telnetAccessEnabled=telnetAccessEnabled, linkSymmetry=linkSymmetry, cableDiagnosticsResultTableEntry=cableDiagnosticsResultTableEntry, groupID=groupID, tDDSynchronizationMode=tDDSynchronizationMode, encryption=encryption, phyControlInstancedTableEntry=phyControlInstancedTableEntry, receiveModulationModeDetailLinked=receiveModulationModeDetailLinked, sFPPortStatus=sFPPortStatus, smtpGroup=smtpGroup, remoteUnitName=remoteUnitName, configuration=configuration, licenseIEEE1588Support=licenseIEEE1588Support, sFPPortDisabledWarningTrap=sFPPortDisabledWarningTrap, tDMChannelLoopbackTrap=tDMChannelLoopbackTrap, transmitFreqMHz=transmitFreqMHz, authorizationControlGroup=authorizationControlGroup, installStatusTrap=installStatusTrap, remoteMACAddressLinked=remoteMACAddressLinked, sNTPServerPortNumber=sNTPServerPortNumber, tdmTable=tdmTable, tDMConfigurationMismatchTrap=tDMConfigurationMismatchTrap, authorizationControlTableIndex=authorizationControlTableIndex, tDDControl=tDDControl, tFTPStartSoftwareUpgrade=tFTPStartSoftwareUpgrade, mABProtocolVID=mABProtocolVID, iPDSCPPriorityTable=iPDSCPPriorityTable, tdmTableIndex=tdmTableIndex, capacityVariantMismatchLinked=capacityVariantMismatchLinked, maximumTransmitPower=maximumTransmitPower, licenseSecurityLevel=licenseSecurityLevel, auxPortDisabledWarningTrap=auxPortDisabledWarningTrap, dNSServerTableEntry=dNSServerTableEntry, sNTPServerRetries=sNTPServerRetries, searchStateLinked=searchStateLinked, receiveDataRateLinked=receiveDataRateLinked, ethernetInstancedTableEntry=ethernetInstancedTableEntry, whitelistRMMacAddress=whitelistRMMacAddress, tDMInterfaceStatusTrap=tDMInterfaceStatusTrap, hTTPSAccessEnabled=hTTPSAccessEnabled, dataBridgingStatus=dataBridgingStatus, l2CPPriorityTableIndex=l2CPPriorityTableIndex, unitName=unitName, auxPortQLTx=auxPortQLTx, licenseRegulatoryBandsTableEntry=licenseRegulatoryBandsTableEntry, apc=apc, mainPSUPortAutoMdix=mainPSUPortAutoMdix, useVLANForManagementInterfaces=useVLANForManagementInterfaces, cableDiagnosticsPorts=cableDiagnosticsPorts, incompatibleMasterAndSlaveTrap=incompatibleMasterAndSlaveTrap, gatewayIPAddress=gatewayIPAddress, mainPSUPortAllocation=mainPSUPortAllocation, atpcHcmpMasterTxPower=atpcHcmpMasterTxPower, userTableIndex=userTableIndex, syncETrackingState=syncETrackingState, rangeLinked=rangeLinked, nIDULanPortAutoMdix=nIDULanPortAutoMdix, sMTPServerPortNumber=sMTPServerPortNumber, authorizationControlTableEntry=authorizationControlTableEntry, wirelessLinkStatusLinked=wirelessLinkStatusLinked, dSCPManagementPriority=dSCPManagementPriority, byteErrorRatioLinked=byteErrorRatioLinked, sNMPTrapReceiverEnabled=sNMPTrapReceiverEnabled, noWirelessChannelAvailableTrap=noWirelessChannelAvailableTrap, rangingMode=rangingMode, installationMode=installationMode, pubInstancedStatsTableEntry=pubInstancedStatsTableEntry, licenseEncryption=licenseEncryption, subnetMask=subnetMask, linkLossLinked=linkLossLinked, wirelessLinkStatus=wirelessLinkStatus, dNSServerTable=dNSServerTable, sFPPortGigabitMasterSlaveStatus=sFPPortGigabitMasterSlaveStatus, alarmInstancedTable=alarmInstancedTable, mABNominalModulationMode=mABNominalModulationMode, sFPPortQLRx=sFPPortQLRx, licenseTrialPeriod=licenseTrialPeriod, dfsTable=dfsTable, portAllocationMismatch=portAllocationMismatch, incompatibleRegulatoryBandsTrap=incompatibleRegulatoryBandsTrap, tDMChannelLoopback=tDMChannelLoopback, auxPortStatus=auxPortStatus, phyStatus=phyStatus, l2CPPriorityTableEntry=l2CPPriorityTableEntry, licenseAuxiliaryPortSupport=licenseAuxiliaryPortSupport, siteName=siteName, sNTPServerTimeout=sNTPServerTimeout, licenseInstancedTableEntry=licenseInstancedTableEntry, productVariant=productVariant, cableLoss=cableLoss, userRole=userRole, licenseGroupAccess=licenseGroupAccess, ptpTraps=ptpTraps, dNSServerTableIndex=dNSServerTableIndex, dataBridgingStatusAlarmTrap=dataBridgingStatusAlarmTrap, licenseCountry=licenseCountry, hardwareVersion=hardwareVersion, targetRange=targetRange, installArmStateTrap=installArmStateTrap, blacklistRMMacAddress=blacklistRMMacAddress, syslogLocalWrappedTrap=syslogLocalWrappedTrap, vLANManagementVID=vLANManagementVID, hTTPPortNumber=hTTPPortNumber, alarmsGroup=alarmsGroup, configurationInstancedTable=configurationInstancedTable, pubStatsGroup=pubStatsGroup, channelBandwidth=channelBandwidth, cableDiagnosticsResultsDateTime=cableDiagnosticsResultsDateTime, ethernetStatisticsTableNumber=ethernetStatisticsTableNumber, licenseTLSRekey=licenseTLSRekey, bridgeGroup=bridgeGroup, auxPortAllocation=auxPortAllocation, tDMChannelCableLength=tDMChannelCableLength, licenseRemainingTrialPeriodAlarm=licenseRemainingTrialPeriodAlarm, tFTPSoftwareUpgradeFileName=tFTPSoftwareUpgradeFileName, packetsToInternalStack=packetsToInternalStack, linkModeOptimization=linkModeOptimization, ptpTrapPrefix=ptpTrapPrefix, authorizationMethod=authorizationMethod, authorizationControlTable=authorizationControlTable, sNTPSync=sNTPSync, sNMPTrapTableEntry=sNMPTrapTableEntry, l2CPPriorityTable=l2CPPriorityTable, cableDiagPair4Results=cableDiagPair4Results, sntp=sntp, linkLoss=linkLoss, phyInstancedStatusTableEntry=phyInstancedStatusTableEntry, sNTPServerTableNumber=sNTPServerTableNumber, snmpControl=snmpControl, resetGroup=resetGroup, tDDSynchronizationAlarmTrap=tDDSynchronizationAlarmTrap, nIDULanPortDisabledWarningTrap=nIDULanPortDisabledWarningTrap, syslogControl=syslogControl, deviceESN=deviceESN, hCMPMaximumLinkRange=hCMPMaximumLinkRange, sFPPortAcceptedQLRx=sFPPortAcceptedQLRx, hTTPAccessEnabled=hTTPAccessEnabled, unitOutOfCalibration=unitOutOfCalibration, dfsPeaks=dfsPeaks, dNSServerPortNumber=dNSServerPortNumber, mainPSUPortConfigurationMismatch=mainPSUPortConfigurationMismatch, sFPPortQLTx=sFPPortQLTx, nIDULanPortSpeedAndDuplex=nIDULanPortSpeedAndDuplex, ethernetStatisticsTableIndex=ethernetStatisticsTableIndex, userName=userName, ethernetPriorityTableEntry=ethernetPriorityTableEntry, sNTPServerInternetAddress=sNTPServerInternetAddress, configurationInstancedTableEntry=configurationInstancedTableEntry, ethernetStatisticsRxOctets=ethernetStatisticsRxOctets, syncETracking=syncETracking, sNTPServerResolvedInternetAddress=sNTPServerResolvedInternetAddress, auxPortGigabitMasterSlaveStatus=auxPortGigabitMasterSlaveStatus, ethernetStatisticsTableEntry=ethernetStatisticsTableEntry, dataBridgingStatusAlarm=dataBridgingStatusAlarm, cableDiagPair3Results=cableDiagPair3Results, eIRP=eIRP, tDDSynchronizationStatus=tDDSynchronizationStatus, secureModeAlarmTrap=secureModeAlarmTrap, mainPSUPortSyncEMasterSlaveStatus=mainPSUPortSyncEMasterSlaveStatus, tDM=tDM, sNMPv3Enable=sNMPv3Enable, tdmTableNumber=tdmTableNumber, licenseIPv6Support=licenseIPv6Support, iPv6GatewayAddress=iPv6GatewayAddress, licenseGasGroup=licenseGasGroup, cableDiagPair3Distance=cableDiagPair3Distance, maxLinkRangeExceededTrap=maxLinkRangeExceededTrap, linkModeOptimizationMismatchTrap=linkModeOptimizationMismatchTrap, auxPortConfigurationMismatchTrap=auxPortConfigurationMismatchTrap, phyInstancedStatusTableIndex=phyInstancedStatusTableIndex, tFTPSoftwareUpgradeStatusAdditionalText=tFTPSoftwareUpgradeStatusAdditionalText, sNTPServerStatus=sNTPServerStatus, maxLinkRangeExceededLinked=maxLinkRangeExceededLinked, syncESlavePort=syncESlavePort, mainPSUPortSyncERxStatus=mainPSUPortSyncERxStatus, signalStrengthRatioLinked=signalStrengthRatioLinked, ethernetStatisticsRxFramesOversize=ethernetStatisticsRxFramesOversize, licenseRemainingTrialPeriod=licenseRemainingTrialPeriod, phyStatusGroup=phyStatusGroup, enableTransmission=enableTransmission, lowestTDMModulationMode=lowestTDMModulationMode, mPLSTCPriorityTableIndex=mPLSTCPriorityTableIndex, maximumNumberOfSlaves=maximumNumberOfSlaves, iPDSCPPriorityTableIndex=iPDSCPPriorityTableIndex, mABMaintenanceLevel=mABMaintenanceLevel, nIDULanPortAutoNegotiation=nIDULanPortAutoNegotiation, sNTPServerAuthenticationProtocol=sNTPServerAuthenticationProtocol, pubInstancedStatsTableNumber=pubInstancedStatsTableNumber, unitOutOfCalibrationTrap=unitOutOfCalibrationTrap, sNTPServerInternetAddressType=sNTPServerInternetAddressType, txColorCode=txColorCode, capacityVariantMismatch=capacityVariantMismatch, lowestDataModulationMode=lowestDataModulationMode, alarmInstancedTableEntry=alarmInstancedTableEntry, syslogControlGroup=syslogControlGroup, wirelessLinkDisabledWarning=wirelessLinkDisabledWarning, ethernetInstancedTable=ethernetInstancedTable, sFPPortConfigurationMismatchTrap=sFPPortConfigurationMismatchTrap, transparentClockVID=transparentClockVID, transparentClockPort=transparentClockPort, ethernetStatisticsTxFrames=ethernetStatisticsTxFrames)
mibBuilder.exportSymbols("CAMBIUM-PTP670-MIB", atpcHcmpMasterTargetRxPower=atpcHcmpMasterTargetRxPower, channelChangeTrap=channelChangeTrap, ethernetStatisticsRxFramesUndersize=ethernetStatisticsRxFramesUndersize, snmpControlGroup=snmpControlGroup, qOSPriorityScheme=qOSPriorityScheme, packetsFromInternalStack=packetsFromInternalStack, unavailableSeconds=unavailableSeconds, extendedSpectrumScanning=extendedSpectrumScanning, sNTPPrimaryServerDeadTime=sNTPPrimaryServerDeadTime, sFPPortAutoMdix=sFPPortAutoMdix, userTableNumber=userTableNumber, latitude=latitude, tDMInterfaceStatus=tDMInterfaceStatus, ethernetStatisticsTxBroadcasts=ethernetStatisticsTxBroadcasts, licenseRegulatoryBandsTableIndex=licenseRegulatoryBandsTableIndex, licenseUnitSerialNumber=licenseUnitSerialNumber, hCMPLinkSymmetry=hCMPLinkSymmetry, auxPortConfigurationMismatch=auxPortConfigurationMismatch, transmitPowerLinked=transmitPowerLinked, tFTPServerInternetAddressType=tFTPServerInternetAddressType, receiveModulationModeDetail=receiveModulationModeDetail, sNMPPortNumber=sNMPPortNumber, ptp=ptp, mainPSUPortQLRx=mainPSUPortQLRx, cableDiagPair2Results=cableDiagPair2Results, licenseMinimumFirmwareVersion=licenseMinimumFirmwareVersion, secondarySoftwareVersion=secondarySoftwareVersion, dNSGroup=dNSGroup, mPLSTCPriorityQueueMapping=mPLSTCPriorityQueueMapping, receiveModulationMode=receiveModulationMode, mainPSUPortGigabitMasterSlaveStatus=mainPSUPortGigabitMasterSlaveStatus, remoteInternetAddressType=remoteInternetAddressType, sFPPortConfigurationMismatch=sFPPortConfigurationMismatch, l2CPPriorityTableNumber=l2CPPriorityTableNumber, useVLANForMABProtocol=useVLANForMABProtocol, subbandLowestFrequency=subbandLowestFrequency, aggregateDataRateLinked=aggregateDataRateLinked, licenseLongMinimumFirmwareVersion=licenseLongMinimumFirmwareVersion, PYSNMP_MODULE_ID=cambium, bridge=bridge, sNTPServerTableIndex=sNTPServerTableIndex, iPVersion=iPVersion, auxPortSpeedAndDuplex=auxPortSpeedAndDuplex, sMTPEmailAlert=sMTPEmailAlert, dfsTableEntry=dfsTableEntry, tFTPSoftwareUpgradeStatus=tFTPSoftwareUpgradeStatus, rawReceivePowerLinked=rawReceivePowerLinked, ethernetInstancedTableNumber=ethernetInstancedTableNumber, syslogStateTrap=syslogStateTrap, mainPSUPortConfigurationMismatchTrap=mainPSUPortConfigurationMismatchTrap, ethernetStatisticsRxFrames=ethernetStatisticsRxFrames, remoteInternetAddressLinked=remoteInternetAddressLinked, licenseVersion=licenseVersion, dfsGroup=dfsGroup, managementGroup=managementGroup, dataBridgingAvailability=dataBridgingAvailability, cableDiagnosticsResultTableNumber=cableDiagnosticsResultTableNumber, licenseIssueNumber=licenseIssueNumber, supplementary=supplementary, mainPSUPortAcceptedQLRx=mainPSUPortAcceptedQLRx, incompatibleRegulatoryBands=incompatibleRegulatoryBands, longitude=longitude, sNMPTrapInternetAddress=sNMPTrapInternetAddress, secureLicenseSignatureAlarm=secureLicenseSignatureAlarm, mainPSUPortStatusTrap=mainPSUPortStatusTrap, ptpCompliance=ptpCompliance, antennaGain=antennaGain, transmitModulationMode=transmitModulationMode, sNTPPollInterval=sNTPPollInterval, mainPSUPortSSMTx=mainPSUPortSSMTx, localPacketFiltering=localPacketFiltering, unknownNetworkPriorityQueueMapping=unknownNetworkPriorityQueueMapping, dNSPrimaryServer=dNSPrimaryServer, remoteMaximumTransmitPower=remoteMaximumTransmitPower, remoteUnitNameLinked=remoteUnitNameLinked, ethernet=ethernet, unitIdentificationGroup=unitIdentificationGroup, alarmInstancedTableIndex=alarmInstancedTableIndex, sNMPCommunityString=sNMPCommunityString, cableDiagnosticsResultTableIndex=cableDiagnosticsResultTableIndex, mABTransmissionInterval=mABTransmissionInterval, receiveFreqKHz=receiveFreqKHz, pubInstancedStatsTable=pubInstancedStatsTable, frequencyVariant=frequencyVariant, daylightSaving=daylightSaving, accessMethod=accessMethod, nIDULanPortStatus=nIDULanPortStatus, remoteInternetAddress=remoteInternetAddress, sNMPTrapTableNumber=sNMPTrapTableNumber, licenseHCMPSupport=licenseHCMPSupport, vectorErrorLinked=vectorErrorLinked, rawReceivePower=rawReceivePower, linkModeOptimizationMismatchLinked=linkModeOptimizationMismatchLinked, sNTPPrimaryServer=sNTPPrimaryServer, tdmTableEntry=tdmTableEntry, userConfiguredMaxModulationMode=userConfiguredMaxModulationMode, nIDULanPortGigabitMasterSlaveStatus=nIDULanPortGigabitMasterSlaveStatus, subbandHighestFrequency=subbandHighestFrequency, encryptionAlgorithm=encryptionAlgorithm, authorizationControl=authorizationControl, sNMPTrapTableIndex=sNMPTrapTableIndex, notificationsGroup=notificationsGroup, tLSMinimumSecurityLevel=tLSMinimumSecurityLevel, nIDULanPortStatusTrap=nIDULanPortStatusTrap, nIDULanPortAutoNegAdvertisement=nIDULanPortAutoNegAdvertisement, encryptionGroup=encryptionGroup, mgmtInstancedTableIndex=mgmtInstancedTableIndex, transparentClockSourcePortAlarm=transparentClockSourcePortAlarm, dfsImpulsiveInterferenceTrap=dfsImpulsiveInterferenceTrap, licenseInstancedTable=licenseInstancedTable, txMABFrames=txMABFrames, systemReset=systemReset, sNTPServerTableEntry=sNTPServerTableEntry, licenseRegulatoryBandsList=licenseRegulatoryBandsList, auxPortQLRx=auxPortQLRx, regulatoryBand=regulatoryBand, licenseSyncESupport=licenseSyncESupport, telnetPortNumber=telnetPortNumber, vLANManagementPriority=vLANManagementPriority, licenseTDDSyncSupport=licenseTDDSyncSupport, ethernetStatisticsRxBroadcasts=ethernetStatisticsRxBroadcasts, mainPSUPortQLRxOverwrite=mainPSUPortQLRxOverwrite, phyInstancedStatusTableNumber=phyInstancedStatusTableNumber, signalStrengthRatio=signalStrengthRatio, mainPSUPortDisabledWarningTrap=mainPSUPortDisabledWarningTrap, dNSServerTableNumber=dNSServerTableNumber, mABCurrentTransmitCapacity=mABCurrentTransmitCapacity, tFTPSoftwareUpgradeStatusText=tFTPSoftwareUpgradeStatusText, iPDSCPPriorityTableNumber=iPDSCPPriorityTableNumber, secureLicenseSignatureAlarmTrap=secureLicenseSignatureAlarmTrap, sFPPortAllocation=sFPPortAllocation, ethernetPriorityTable=ethernetPriorityTable, cableDiagnosticsResultTable=cableDiagnosticsResultTable, reset=reset, receivePowerLinked=receivePowerLinked, auxPortPowerOverEthernetOutputStatusTrap=auxPortPowerOverEthernetOutputStatusTrap, cableDiagnosticsWarning=cableDiagnosticsWarning, sMTPDestinationEmailAddress=sMTPDestinationEmailAddress, iPDSCPPriorityTableEntry=iPDSCPPriorityTableEntry, syslogState=syslogState, range=range, dfs=dfs, wirelessLinkAvailability=wirelessLinkAvailability, enabledDiagnosticAlarms=enabledDiagnosticAlarms, supplementaryGroup=supplementaryGroup, sFPPortSSMTx=sFPPortSSMTx, dfsMeans=dfsMeans, managementPortWirelessDownAlert=managementPortWirelessDownAlert, licenseNumberOfRegulatoryBands=licenseNumberOfRegulatoryBands, mainPSUPortDisabledWarning=mainPSUPortDisabledWarning, cambium=cambium, iPv6AutoConfiguredLinkLocalAddress=iPv6AutoConfiguredLinkLocalAddress, dataBridgingStatusLinked=dataBridgingStatusLinked, remoteMACAddress=remoteMACAddress, apcGroup=apcGroup, management=management, incompatibleRegulatoryBandsLinked=incompatibleRegulatoryBandsLinked, dNS=dNS, auxPortSSMTx=auxPortSSMTx, iPv6PrefixLength=iPv6PrefixLength, linkModeOptimizationMismatch=linkModeOptimizationMismatch, dataPortPauseFrames=dataPortPauseFrames, phyInstancedStatusTable=phyInstancedStatusTable, licenseSFPPortSupport=licenseSFPPortSupport, sFPPortQLRxOverwrite=sFPPortQLRxOverwrite, sNMPSendAllTrapsAtStartup=sNMPSendAllTrapsAtStartup, sFPPortStatusTrap=sFPPortStatusTrap, sntpGroup=sntpGroup, auxPortSyncEMasterSlaveStatus=auxPortSyncEMasterSlaveStatus, auxPortSyncERxStatus=auxPortSyncERxStatus, phyControlGroup=phyControlGroup, sNMPTrapVersion=sNMPTrapVersion, sFPErrorTrap=sFPErrorTrap, sNTPState=sNTPState, wirelessTopology=wirelessTopology, sMTPEnabledMessages=sMTPEnabledMessages, sNMPTrapResolvedInternetAddress=sNMPTrapResolvedInternetAddress, incompatibleMasterAndSlave=incompatibleMasterAndSlave, altitude=altitude, licenseAdvanceHCMPSupport=licenseAdvanceHCMPSupport, wirelessLinkStatusAlarmTrap=wirelessLinkStatusAlarmTrap, tDMChannelStatusTrap=tDMChannelStatusTrap, wirelessLinkDisabledWarningTrap=wirelessLinkDisabledWarningTrap, ptp670=ptp670, dataBridgingStatusAlarmLinked=dataBridgingStatusAlarmLinked, iPv6Address=iPv6Address, mainPSUPortQLTx=mainPSUPortQLTx, softwareVersion=softwareVersion, noWirelessChannelAvailable=noWirelessChannelAvailable, wirelessLinkAvailabilityLinked=wirelessLinkAvailabilityLinked, pubInstancedStatsTableIndex=pubInstancedStatsTableIndex, transmitFreqKHz=transmitFreqKHz, regulatoryBandTrap=regulatoryBandTrap, configurationInstancedTableIndex=configurationInstancedTableIndex, auxPortAcceptedQLRx=auxPortAcceptedQLRx, phyControlInstancedTableIndex=phyControlInstancedTableIndex, mABNominalTransmitCapacity=mABNominalTransmitCapacity, tDMInterfaceControl=tDMInterfaceControl, sFPPortAutoNegotiation=sFPPortAutoNegotiation, wirelessLinkStatusAlarm=wirelessLinkStatusAlarm, sFPError=sFPError, portAllocationMismatchLinked=portAllocationMismatchLinked, rxColorCode=rxColorCode, licenseRegulatoryBandsTable=licenseRegulatoryBandsTable, productName=productName, wirelessOutOctets=wirelessOutOctets, mainPSUPortStatus=mainPSUPortStatus, auxPortDisabledWarning=auxPortDisabledWarning, unitIdentification=unitIdentification, transmitterChannels=transmitterChannels, sNMPTrapInternetAddressType=sNMPTrapInternetAddressType, mPLSTCPriorityTableNumber=mPLSTCPriorityTableNumber, routerProtocolsGroup=routerProtocolsGroup, byteErrorRatio=byteErrorRatio, syslogClient=syslogClient, licenseInstancedTableNumber=licenseInstancedTableNumber, licenseMaxLinkRange=licenseMaxLinkRange, alarms=alarms, mABState=mABState, mPLSTCPriorityTableEntry=mPLSTCPriorityTableEntry, userEnabled=userEnabled, microwaveAdaptiveBandwidth=microwaveAdaptiveBandwidth, dNSResolver=dNSResolver, licenseRemainingTrialPeriodAlarmTrap=licenseRemainingTrialPeriodAlarmTrap, sNTPSyncTrap=sNTPSyncTrap, routerProtocols=routerProtocols, remoteMaximumTransmitPowerLinked=remoteMaximumTransmitPowerLinked, installStatusLinked=installStatusLinked, aAAControl=aAAControl, ethernetStatisticsDataSource=ethernetStatisticsDataSource, tFTPServerPortNumber=tFTPServerPortNumber, aggregateDataRate=aggregateDataRate, mPLSTCPriorityTable=mPLSTCPriorityTable, sNMPTrapTable=sNMPTrapTable, transparentClockVLAN=transparentClockVLAN, cableDiagPair2Distance=cableDiagPair2Distance, ethernetPriorityTableIndex=ethernetPriorityTableIndex, ethernetInstancedTableIndex=ethernetInstancedTableIndex, sNTPServerTable=sNTPServerTable, sNTPServerKeyIdentifier=sNTPServerKeyIdentifier, deviceMSN=deviceMSN, nIDULanPortDisabledWarning=nIDULanPortDisabledWarning, mABProtocolVLANPriority=mABProtocolVLANPriority, sMTPServerResolvedInternetAddress=sMTPServerResolvedInternetAddress, syslogLocalNearlyFullTrap=syslogLocalNearlyFullTrap, cableDiagPair1Results=cableDiagPair1Results, deviceMACAddress=deviceMACAddress, userTableEntry=userTableEntry, license=license, ptmp=ptmp, transmitChannel=transmitChannel, lbtDetectedTrap=lbtDetectedTrap, syncEEquipmentClock=syncEEquipmentClock, receiveModulationModeLinked=receiveModulationModeLinked)
mibBuilder.exportSymbols("CAMBIUM-PTP670-MIB", userPassword=userPassword, wirelessOutAllOctets=wirelessOutAllOctets, cableDiagPair4Distance=cableDiagPair4Distance, tDMEnabledChannels=tDMEnabledChannels, ethernetGroup=ethernetGroup, tFTPServerResolvedInternetAddress=tFTPServerResolvedInternetAddress, installStatus=installStatus, licenseMinFirmwareVersionPTP650Emulation=licenseMinFirmwareVersionPTP650Emulation, ethernetPriorityQueueMapping=ethernetPriorityQueueMapping, tDMConfigurationMismatch=tDMConfigurationMismatch, iPDSCPPriorityQueueMapping=iPDSCPPriorityQueueMapping, managementNetworkAccessEnabled=managementNetworkAccessEnabled, nIDULanPortConfigurationMismatchTrap=nIDULanPortConfigurationMismatchTrap, tempPcb=tempPcb, licenseCapacity=licenseCapacity, configurationInstancedTableNumber=configurationInstancedTableNumber, dNSServerInternetAddressType=dNSServerInternetAddressType, timeZone=timeZone, transmitDataRateLinked=transmitDataRateLinked, searchState=searchState, versions=versions, dfsTableNumber=dfsTableNumber, iPv4Address=iPv4Address, whitelistRMEnabled=whitelistRMEnabled, phyControlInstancedTable=phyControlInstancedTable, pubStats=pubStats, sFPPortSyncERxStatus=sFPPortSyncERxStatus, userTable=userTable, auxPortPowerOverEthernetOutputStatus=auxPortPowerOverEthernetOutputStatus, transmitDataRate=transmitDataRate, ethernetPriorityTableNumber=ethernetPriorityTableNumber, dNSServerInternetAddress=dNSServerInternetAddress, transmitPower=transmitPower, incompatibleMasterAndSlaveLinked=incompatibleMasterAndSlaveLinked, mgmtInstancedTableEntry=mgmtInstancedTableEntry, sMTPServerInternetAddress=sMTPServerInternetAddress, dfsTableIndex=dfsTableIndex, aAAControlGroup=aAAControlGroup, receivePower=receivePower, maxLinkRangeExceeded=maxLinkRangeExceeded, installArmState=installArmState, capacityVariantMismatchTrap=capacityVariantMismatchTrap, mgmtInstancedTable=mgmtInstancedTable, ethernetStatisticsTable=ethernetStatisticsTable, alarmInstancedTableNumber=alarmInstancedTableNumber, receiveChannel=receiveChannel, mainPSUPortSpeedAndDuplex=mainPSUPortSpeedAndDuplex, sNMPTrapPortNumber=sNMPTrapPortNumber, dataPortWirelessDownAlert=dataPortWirelessDownAlert, tDMGroup=tDMGroup, phyControl=phyControl, ethernetStatisticsRxFramesWithError=ethernetStatisticsRxFramesWithError, sMTPServerInternetAddressType=sMTPServerInternetAddressType, wirelessOutEthernetOctets=wirelessOutEthernetOctets, nIDULanPortConfigurationMismatch=nIDULanPortConfigurationMismatch, receiveDataRate=receiveDataRate, auxPortPowerOverEthernetOutput=auxPortPowerOverEthernetOutput, auxPortStatusTrap=auxPortStatusTrap, oOBPriorityQueueMapping=oOBPriorityQueueMapping, licenseBandwidthCap=licenseBandwidthCap, targetMACAddress=targetMACAddress, versionsGroup=versionsGroup)
