#
# PySNMP MIB module RADLAN-IP (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radlan/RADLAN-IP
# Produced by pysmi-1.1.12 at Thu May 30 02:21:39 2024
# On host fv-az1567-87 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
ipCidrRouteNextHop, ipCidrRouteEntry, ipCidrRouteMask, ipCidrRouteDest, ipCidrRouteTos = mibBuilder.importSymbols("IP-FORWARD-MIB", "ipCidrRouteNextHop", "ipCidrRouteEntry", "ipCidrRouteMask", "ipCidrRouteDest", "ipCidrRouteTos")
ipAddrEntry, = mibBuilder.importSymbols("IP-MIB", "ipAddrEntry")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
rip2IfConfEntry, = mibBuilder.importSymbols("RFC1389-MIB", "rip2IfConfEntry")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Unsigned32, iso, TimeTicks, MibIdentifier, IpAddress, Gauge32, Bits, Counter32, Integer32, ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Unsigned32", "iso", "TimeTicks", "MibIdentifier", "IpAddress", "Gauge32", "Bits", "Counter32", "Integer32", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64")
TruthValue, RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "RowStatus", "TextualConvention", "DisplayString")
DisplayString, = mibBuilder.importSymbols("SNMPv2-TC-v1", "DisplayString")
ipSpec = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 26))
ipSpec.setRevisions(('2005-09-29 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipSpec.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: ipSpec.setLastUpdated('200509290000Z')
if mibBuilder.loadTexts: ipSpec.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: ipSpec.setContactInfo('radlan.com')
if mibBuilder.loadTexts: ipSpec.setDescription('The private MIB module definition for IP MIB.')
rsIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 1), )
if mibBuilder.loadTexts: rsIpAddrTable.setStatus('current')
if mibBuilder.loadTexts: rsIpAddrTable.setDescription('This table is parralel to MIB II IpAddrTable, and is used to\n        add/delete entries to/from that table. In addition it contains\n        private objects.')
rsIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 1, 1), ).setIndexNames((0, "RADLAN-IP", "rsIpAdEntAddr"))
if mibBuilder.loadTexts: rsIpAddrEntry.setStatus('current')
if mibBuilder.loadTexts: rsIpAddrEntry.setDescription("The addressing information for one of this\n            entity's IP addresses.")
rsIpAdEntAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpAdEntAddr.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntAddr.setDescription("The IP address to which this entry's addressing\n            information pertains.")
rsIpAdEntIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntIfIndex.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntIfIndex.setDescription('The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.')
rsIpAdEntNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntNetMask.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntNetMask.setDescription('The subnet mask associated with the IP address of\n            this entry.  The value of the mask is an IP\n            address with all the network bits set to 1 and all\n            the hosts bits set to 0.')
rsIpAdEntForwardIpBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntForwardIpBroadcast.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntForwardIpBroadcast.setDescription(' This variable controls forwarding of IP (sub)net-directed\n          broadcasts destined for an attached sub(net). ')
rsIpAdEntBackupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntBackupAddr.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntBackupAddr.setDescription('In case there are two IP routers in the domain,\n             the address of the second IP router.')
rsIpAdEntStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntStatus.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntStatus.setDescription(' The validity of this entry. Invalid indicates that this entry is\n          invalid in IpAddrTable (MIB II).')
rsIpAdEntBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntBcastAddr.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntBcastAddr.setDescription(' Indicates how the host part of ip subnet broadcast messages will be\n          filled:\n           0 - host part will be filled by 0\n           1 - host part will be filled by 1.')
rsIpAdEntArpServer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntArpServer.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntArpServer.setDescription('Indicates whether the router will reply to incoming ARP requests on\n         this interface, providing the physical address corresponding to this\n         IP interface.')
rsIpAdEntName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntName.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntName.setDescription('The IP Interface name')
rsIpAdEntOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("internal", 3), ("default", 4))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntOwner.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntOwner.setDescription('The IP Interface owner. Static if interface defined by user, dhcp\n            if received by boot protocol like DHCP and internal\n            for internal usage.')
rsIpAdEntAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIpAdEntAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntAdminStatus.setDescription('The IP Interface admin status.')
rsIpAdEntOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIpAdEntOperStatus.setStatus('current')
if mibBuilder.loadTexts: rsIpAdEntOperStatus.setDescription('If active the interface can be used to send and receive frames.')
icmpSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 2))
rsIcmpGenErrMsgEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpGenErrMsgEnable.setStatus('current')
if mibBuilder.loadTexts: rsIcmpGenErrMsgEnable.setDescription('This variable controlls the ability to generate ICMP error messages')
rsIcmpRdTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 2, 2), )
if mibBuilder.loadTexts: rsIcmpRdTable.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdTable.setDescription('This table contains ICMP Router Discovery parameters\n        configurated per IP interface.')
rsIcmpRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1), ).setIndexNames((0, "RADLAN-IP", "rsIcmpRdIpAddr"))
if mibBuilder.loadTexts: rsIcmpRdEntry.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdEntry.setDescription('The ICMP parameters configurated for IP interface.')
rsIcmpRdIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsIcmpRdIpAddr.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdIpAddr.setDescription("The IP address to which this entry's information pertains.")
rsIcmpRdIpAdvertAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 2), IpAddress().clone(hexValue="E0000001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdIpAdvertAddr.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdIpAdvertAddr.setDescription(' The IP destination address to be used for multicast\n              Router Advertisements sent from the interface. The\n              only permissible values are the all-systems multicast\n              address, 224.0.0.1, or the limited-broadcast address,\n              255.255.255.255.')
rsIcmpRdMaxAdvertInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 1800)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdMaxAdvertInterval.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdMaxAdvertInterval.setDescription('The maximum time allowed between sending multicast\n             Router Advertisements from the interface, in seconds.\n             Must be no less than 4 seconds and no greater than 1800\n             seconds.')
rsIcmpRdMinAdvertInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 1800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdMinAdvertInterval.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdMinAdvertInterval.setDescription('The minimum time allowed between sending unsolicited\n             multicast Router Advertisements from the interface, in\n             seconds.  Must be no less than 3 seconds and no greater\n             than rsIcmpRdMaxAdvertInterval.\n             Default: 0.75 * rsIcmpRdMaxAdvertInterval.')
rsIcmpRdAdvertLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 9000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdAdvertLifetime.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdAdvertLifetime.setDescription('The maximum length of time that the advertised addresses\n             are to be considered as valid. Must be no less than\n             rsIcmpRdMaxAdvertInterval and no greater than 9000 seconds.\n             Default: 3 * rsIcmpRdMaxAdvertInterval.')
rsIcmpRdAdvertise = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdAdvertise.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdAdvertise.setDescription('A flag indicating whether or not the address is to be\n              advertised.')
rsIcmpRdPreferenceLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdPreferenceLevel.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdPreferenceLevel.setDescription('The preferability of the address as a default router\n             address, relative to other router addresses on the same\n             subnet.')
rsIcmpRdEntStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsIcmpRdEntStatus.setStatus('current')
if mibBuilder.loadTexts: rsIcmpRdEntStatus.setDescription('Setting of any value to this object set values of\n             all fields to the default values.')
rip2Spec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 3))
arpSpec = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 4))
rsArpDeleteTable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 0), ("deleteArpTab", 1), ("deleteIpArpDynamicEntries", 2), ("deleteIpArpStaticEntries", 3), ("deleteIpArpDelDynamicRefreshStatic", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpDeleteTable.setStatus('current')
if mibBuilder.loadTexts: rsArpDeleteTable.setDescription('Setting to value deleteArpTab(1): deletes the arp table -\n                                              static and dynamic entries\n            deleteIpArpDynamicEntries(2):     delete all dynamic entries\n            deleteIpArpStaticEntries(3):      delete all static entries\n            deleteIpArpDelDynamicRefreshStatic(4) - delete all dynamic -\n                                                    refresh static, thus\n                                                    refrashing FFT.\n            on get returns the last action')
rsArpInactiveTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 40000000)).clone(60000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpInactiveTimeOut.setStatus('current')
if mibBuilder.loadTexts: rsArpInactiveTimeOut.setDescription('This variable defines the maximum time period (in second) that can\n          pass between ARP requests concerning an entry in the ARP table.\n          After this time period, the entry is deleted from the table.')
rsArpProxy = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpProxy.setStatus('current')
if mibBuilder.loadTexts: rsArpProxy.setDescription('When ARP Proxy is enabled, the router can respond to\n          ARP requests for nodes located on a different sub-net,\n          provided they are it its network table. The router responds\n          with its own MAC address.\n          When ARP Proxy is disabled, the router responds only\n          to ARP requests for its own IP addresses.')
rsArpRequestsSent = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsArpRequestsSent.setStatus('current')
if mibBuilder.loadTexts: rsArpRequestsSent.setDescription('Displays how many ARP requests have been sent out to an ARP server\n          for address resolution.')
rsArpRepliesSent = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsArpRepliesSent.setStatus('current')
if mibBuilder.loadTexts: rsArpRepliesSent.setDescription('Displays how many ARP replies have been sent out to an ARP client\n          in response to request packets.')
rsArpProxyRepliesSent = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsArpProxyRepliesSent.setStatus('current')
if mibBuilder.loadTexts: rsArpProxyRepliesSent.setDescription('Displays how many proxy ARP replies have been sent out in response\n          to request packets. A proxy router serving as a gateway to a subnet\n          would respond with a proxy reply.')
rsArpUnresolveTimer = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsArpUnresolveTimer.setStatus('current')
if mibBuilder.loadTexts: rsArpUnresolveTimer.setDescription('Specifies the frequency in seconds in which to send out ARP\n          requests to resolve the Next Hop MAC address.')
rsArpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsArpMibVersion.setStatus('current')
if mibBuilder.loadTexts: rsArpMibVersion.setDescription("MIB's version, the current version is 2.\n          Version 1:\n            rsArpDeleteTable\n                Setting this object to any not-null value has the effect\n                of deleting all entries of the ARP table.\n          Version 2:\n            rsArpDeleteTable\n                Setting to value deleteArpTab(1): deletes the arp table -\n                                                  static and dynamic entries\n                deleteIpArpDynamicEntries(2):     delete all dynamic entries\n                deleteIpArpStaticEntries(3):      delete all static entries\n                deleteIpArpDelDynamicRefreshStatic(4):\n                                                    delete all dynamic -\n                                                    refresh static, thus\n                                                    refrashing FFT.\n                on get returns the last action.\n            New MIB variables support:\n                rsArpRequestsSent\n                rsArpRepliesSent\n                rsArpProxyRepliesSent\n                rsArpUnresolveTimer\n                rsArpMibVersion")
tftp = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 5))
rsTftpRetryTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 1), Integer32().clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTftpRetryTimeOut.setStatus('current')
if mibBuilder.loadTexts: rsTftpRetryTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
rsTftpTotalTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 2), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTftpTotalTimeOut.setStatus('current')
if mibBuilder.loadTexts: rsTftpTotalTimeOut.setDescription(' Total Retransmission time-out value (seconds) ')
rsSendConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSendConfigFile.setStatus('current')
if mibBuilder.loadTexts: rsSendConfigFile.setDescription('The file name include path where the Router Server will put the full\n         configuration. The default destination address will be the sender\n         address.')
rsGetConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsGetConfigFile.setStatus('current')
if mibBuilder.loadTexts: rsGetConfigFile.setDescription('The file name include path where the Router Server will get the full\n         configuration from. The default destination address will be the sender\n         address.')
rsLoadSoftware = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsLoadSoftware.setStatus('current')
if mibBuilder.loadTexts: rsLoadSoftware.setDescription('The file name include path where the Router Server will get the\n         software. The default source address will be the sender address.')
rsFileServerAddress = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsFileServerAddress.setStatus('current')
if mibBuilder.loadTexts: rsFileServerAddress.setDescription('The IP address of the configuration / sw server.')
rsSoftwareDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSoftwareDeviceName.setStatus('current')
if mibBuilder.loadTexts: rsSoftwareDeviceName.setDescription('The Software Device Name specifies a device name, using this Software')
rsSoftwareFileAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 5, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("download", 1), ("upload", 2))).clone('download')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsSoftwareFileAction.setStatus('current')
if mibBuilder.loadTexts: rsSoftwareFileAction.setDescription('Holds the current action done on the software file ')
ipRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 6))
ipRouteLeaking = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 7))
ipRipFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 8))
rsRipEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsRipEnable.setStatus('current')
if mibBuilder.loadTexts: rsRipEnable.setDescription('Enables or disables RIP.')
rsTelnetPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rsTelnetPassword.setStatus('current')
if mibBuilder.loadTexts: rsTelnetPassword.setDescription('')
rlTranslationNameToIpTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 12), )
if mibBuilder.loadTexts: rlTranslationNameToIpTable.setStatus('current')
if mibBuilder.loadTexts: rlTranslationNameToIpTable.setDescription("This table translates IP interfaces's name to\n        IP interface's address")
rlTranslationNameToIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 12, 1), ).setIndexNames((1, "RADLAN-IP", "rlTranslationNameToIpName"))
if mibBuilder.loadTexts: rlTranslationNameToIpEntry.setStatus('current')
if mibBuilder.loadTexts: rlTranslationNameToIpEntry.setDescription('The row definition for this table.')
rlTranslationNameToIpName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTranslationNameToIpName.setStatus('current')
if mibBuilder.loadTexts: rlTranslationNameToIpName.setDescription('The IP Interface name')
rlTranslationNameToIpIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTranslationNameToIpIpAddr.setStatus('current')
if mibBuilder.loadTexts: rlTranslationNameToIpIpAddr.setDescription('The IP Interface address')
rlIpRoutingProtPreference = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 13))
rlOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 14))
rlIpAddrTableMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 26, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpAddrTableMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlIpAddrTableMibVersion.setDescription("The IpAddrTable MIB's version.")
rlIpCidrRouteExtTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 16), )
if mibBuilder.loadTexts: rlIpCidrRouteExtTable.setStatus('current')
if mibBuilder.loadTexts: rlIpCidrRouteExtTable.setDescription('Augmenting ipCidrRouteTable (ip forwarfing information table)\n             for added info as read only')
rlIpCidrRouteExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 16, 1), )
ipCidrRouteEntry.registerAugmentions(("RADLAN-IP", "rlIpCidrRouteExtEntry"))
rlIpCidrRouteExtEntry.setIndexNames(*ipCidrRouteEntry.getIndexNames())
if mibBuilder.loadTexts: rlIpCidrRouteExtEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpCidrRouteExtEntry.setDescription('A row of the table ipCidrRouteTable Extended\n         by this definition.')
rlIpCidrRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("local", 1), ("netmgmt", 2), ("rip", 3), ("ospfInternal", 4), ("ospfExternal", 5), ("ospfAggregateNetRange", 6), ("bgp4Internal", 7), ("bgp4External", 8), ("aggregateRoute", 9), ("other", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpCidrRouteProto.setStatus('current')
if mibBuilder.loadTexts: rlIpCidrRouteProto.setDescription('Added infor for ipCidrRouteTable.\n        extends the info of ipCidrRouteProto to show the route inner protocol.\n        Allowes the user to see which type of route in the protocol\n        e.g. ospf internal, ospf external.')
rlIpStaticRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 17))
rlIpStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 89, 26, 17, 1), )
if mibBuilder.loadTexts: rlIpStaticRouteTable.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteTable.setDescription("This entity's    static (user configured) IP Routing table.\n       entries are MAX-ACCESSible even if not used for forwarding ")
rlIpStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1), ).setIndexNames((0, "RADLAN-IP", "rlIpStaticRouteDest"), (0, "RADLAN-IP", "rlIpStaticRouteMask"), (0, "RADLAN-IP", "rlIpStaticRouteTos"), (0, "RADLAN-IP", "rlIpStaticRouteNextHop"))
if mibBuilder.loadTexts: rlIpStaticRouteEntry.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteEntry.setDescription('A particular Static(user configured) route to  a  particular  destina-\n         tion, under a particular policy.')
rlIpStaticRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteDest.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteDest.setDescription('The destination IP address of this route.\n       This object may not take a Multicast (Class  D)\n       address value.\n       Any assignment (implicit or  otherwise)  of  an\n       instance  of  this  object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       rlIpStaticRouteMask object is not equal to x.')
rlIpStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteMask.setDescription('Indicate the mask to be logical-ANDed with the\n       destination address before being compared to\n       the value in the rlIpStaticRouteDest  field.   For\n       those  systems that do not support arbitrary\n       subnet masks, an agent constructs the value  of\n       the  rlIpStaticRouteMask  by  reference to the IP Ad-\n       dress Class.\n       Any assignment (implicit or  otherwise)  of  an\n       instance of this object to a value x must be\n       rejected if the bitwise logical-AND of  x  with\n       the  value of the corresponding instance of the\n       rlIpStaticRouteDest object is not equal to ipCidrRoute-\n       Dest.')
rlIpStaticRouteTos = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteTos.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteTos.setDescription('See ipCidrRouteTos definition\n        For now only value 0 is valid')
rlIpStaticRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteNextHop.setDescription('On remote routes, the address of the next sys-\n       tem en route; Otherwise, 0.0.0.0.')
rlIpStaticRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpStaticRouteMetric.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteMetric.setDescription('The routing  metric  for  this  route.\n       The semantics of this metric are determined by the user.\n       normal semantic will be next hop count or some administarative distance\n       to create routing policy.')
rlIpStaticRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reject", 1), ("local", 2), ("remote", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpStaticRouteType.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteType.setDescription('The type of route.  Note that local(3)  refers\n       to  a route for which the next hop is the final\n       destination this is the case when user overides the a local interface\n       entry to change it parameters;\n       remote(4) refers to  a  route  for\n       which  the  next  hop is not the final destina-\n       tion.\n       reject (2) refers to a route which, if matched, discards\n       the message as unreachable. This is may be used as a means of\n       correctly aggregating routes, When static routes are distributed (leaked)\n       to other protocols.')
rlIpStaticRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpStaticRouteNextHopAS.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteNextHopAS.setDescription("The Autonomous System Number of the Next  Hop.\n       The  semantics of this object are determined by\n       the routing-protocol specified in  the  route's\n       ipCidrRouteProto  value. When  this object is\n       unknown or not relevant its value should be set\n       to zero.")
rlIpStaticRouteForwardingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteForwardingStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteForwardingStatus.setDescription('active - An indication that the route has implication on routing\n       inactive - the route is a backup route or it is down. It is not used\n                  in forwarding decision.\n       Down means that the Ip interface on which it is configured is down.\n       (Note: ip interface down may be for two reason - its admin status or\n       the L2 interface , on which the ip interface is configured, status')
rlIpStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlIpStaticRouteRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteRowStatus.setDescription('The row status variable, used according to\n       row installation and removal conventions.')
rlIpStaticRouteOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 26, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("dhcp", 2), ("default", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlIpStaticRouteOwner.setStatus('current')
if mibBuilder.loadTexts: rlIpStaticRouteOwner.setDescription('Static - The route is configured over Static IP.\n                 This route is written to configuration files.\n        Dhcp -   The route is Configured by DHCP\n                 (received as part of DHCP configuration)\n                 This route IS NOT written to configuration files\n        Dhcp -   The route is Configured default system config\n                 exist till any other configuration\n                 is applied')
rlIpRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 26, 18))
mibBuilder.exportSymbols("RADLAN-IP", arpSpec=arpSpec, rsIcmpRdEntStatus=rsIcmpRdEntStatus, rlIpStaticRouteDest=rlIpStaticRouteDest, rip2Spec=rip2Spec, rlIpStaticRouteMask=rlIpStaticRouteMask, rlIpStaticRouteType=rlIpStaticRouteType, rsArpProxy=rsArpProxy, rsIpAdEntIfIndex=rsIpAdEntIfIndex, rsIpAdEntNetMask=rsIpAdEntNetMask, rsIpAdEntAdminStatus=rsIpAdEntAdminStatus, rlIpRoutingProtPreference=rlIpRoutingProtPreference, rlIpAddrTableMibVersion=rlIpAddrTableMibVersion, rlIpStaticRoute=rlIpStaticRoute, ipRouteLeaking=ipRouteLeaking, rsIcmpRdMaxAdvertInterval=rsIcmpRdMaxAdvertInterval, rsIpAdEntStatus=rsIpAdEntStatus, rsArpRepliesSent=rsArpRepliesSent, rsRipEnable=rsRipEnable, rlIpRouter=rlIpRouter, rsGetConfigFile=rsGetConfigFile, rsIpAdEntForwardIpBroadcast=rsIpAdEntForwardIpBroadcast, rlIpStaticRouteEntry=rlIpStaticRouteEntry, rsArpProxyRepliesSent=rsArpProxyRepliesSent, rlIpStaticRouteMetric=rlIpStaticRouteMetric, rlTranslationNameToIpEntry=rlTranslationNameToIpEntry, rlIpStaticRouteNextHopAS=rlIpStaticRouteNextHopAS, rsIpAdEntName=rsIpAdEntName, rsIcmpRdPreferenceLevel=rsIcmpRdPreferenceLevel, rsIpAdEntBackupAddr=rsIpAdEntBackupAddr, rsFileServerAddress=rsFileServerAddress, rsArpInactiveTimeOut=rsArpInactiveTimeOut, rlIpStaticRouteForwardingStatus=rlIpStaticRouteForwardingStatus, rlIpStaticRouteRowStatus=rlIpStaticRouteRowStatus, rsIcmpRdAdvertise=rsIcmpRdAdvertise, PYSNMP_MODULE_ID=ipSpec, ipSpec=ipSpec, rsArpMibVersion=rsArpMibVersion, rsIpAdEntArpServer=rsIpAdEntArpServer, rsArpRequestsSent=rsArpRequestsSent, rlIpStaticRouteTos=rlIpStaticRouteTos, rsIpAddrEntry=rsIpAddrEntry, rsSoftwareFileAction=rsSoftwareFileAction, rsSoftwareDeviceName=rsSoftwareDeviceName, rlIpCidrRouteExtEntry=rlIpCidrRouteExtEntry, rsTelnetPassword=rsTelnetPassword, rsIpAdEntOperStatus=rsIpAdEntOperStatus, rsArpUnresolveTimer=rsArpUnresolveTimer, rlTranslationNameToIpTable=rlTranslationNameToIpTable, rsSendConfigFile=rsSendConfigFile, icmpSpec=icmpSpec, rsIcmpRdIpAdvertAddr=rsIcmpRdIpAdvertAddr, rsIpAddrTable=rsIpAddrTable, rlOspf=rlOspf, rsIcmpRdIpAddr=rsIcmpRdIpAddr, rsIcmpRdAdvertLifetime=rsIcmpRdAdvertLifetime, rsTftpTotalTimeOut=rsTftpTotalTimeOut, tftp=tftp, rsIpAdEntOwner=rsIpAdEntOwner, rsIcmpGenErrMsgEnable=rsIcmpGenErrMsgEnable, rlTranslationNameToIpName=rlTranslationNameToIpName, rsIpAdEntBcastAddr=rsIpAdEntBcastAddr, rsIcmpRdTable=rsIcmpRdTable, rlTranslationNameToIpIpAddr=rlTranslationNameToIpIpAddr, rsTftpRetryTimeOut=rsTftpRetryTimeOut, ipRedundancy=ipRedundancy, rlIpCidrRouteProto=rlIpCidrRouteProto, rlIpStaticRouteNextHop=rlIpStaticRouteNextHop, rsIpAdEntAddr=rsIpAdEntAddr, rlIpStaticRouteOwner=rlIpStaticRouteOwner, rsLoadSoftware=rsLoadSoftware, rsIcmpRdMinAdvertInterval=rsIcmpRdMinAdvertInterval, rlIpCidrRouteExtTable=rlIpCidrRouteExtTable, rsArpDeleteTable=rsArpDeleteTable, rsIcmpRdEntry=rsIcmpRdEntry, ipRipFilter=ipRipFilter, rlIpStaticRouteTable=rlIpStaticRouteTable)
