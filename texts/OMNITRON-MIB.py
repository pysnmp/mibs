#
# PySNMP MIB module OMNITRON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/omnitron/OMNITRON-MIB
# Produced by pysmi-1.1.12 at Tue Dec  3 12:39:06 2024
# On host fv-az658-333 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
OstModeType, OstVlanId, omnitron, OstPortNumber, OstPortList, icAgent = mibBuilder.importSymbols("OMNITRON-TC-MIB", "OstModeType", "OstVlanId", "omnitron", "OstPortNumber", "OstPortList", "icAgent")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Counter64, Unsigned32, ModuleIdentity, Integer32, Gauge32, Bits, NotificationType, TimeTicks, MibIdentifier, Counter32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "ModuleIdentity", "Integer32", "Gauge32", "Bits", "NotificationType", "TimeTicks", "MibIdentifier", "Counter32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "ObjectIdentity")
TruthValue, DisplayString, TextualConvention, TimeInterval = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention", "TimeInterval")
omnitronMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 7342, 3))
omnitronMIB.setRevisions(('2015-10-21 12:00', '2015-01-19 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: omnitronMIB.setRevisionsDescriptions(('Added modHwRev and modPcbRev\n                ', 'Initial version of v5.2 MIB.\n                   Updated resetmod and modreset to allow reboot from backup\n                ',))
if mibBuilder.loadTexts: omnitronMIB.setLastUpdated('201510211200Z')
if mibBuilder.loadTexts: omnitronMIB.setOrganization('Omnitron Systems Technology, Inc.')
if mibBuilder.loadTexts: omnitronMIB.setContactInfo('Omnitron Systems Technology, Inc.\n                  38 Tesla\n                  Irvine, CA 92618-4670\n                  USA\n\n             Tel: (949) 250 6510\n             Fax: (949) 250 6514\n          E-mail: info@omnitron-systems.com\n   International: +1 949 250 6510\n\n                  Technical Support and Customer Service\n             Tel: (800) 675 8410\n          E-mail: support@omnitron-systems.com\n   International: +1 949 250 6510')
if mibBuilder.loadTexts: omnitronMIB.setDescription('Omnitron MIB for use with v5.2 iConverter Management Modules\n             and NetOutlook\n\n             Copyright 2015 Omnitron Systems Technology, Inc.\n             All rights reserved\n            ')
prodAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 2))
omnitronConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4))
omnitronProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 5))
managementModule = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 5, 1))
chassis = MibScalar((1, 3, 6, 1, 4, 1, 7342, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassis.setStatus('current')
if mibBuilder.loadTexts: chassis.setDescription('Holds the chassis number of the selected IP')
selfSlot = MibScalar((1, 3, 6, 1, 4, 1, 7342, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfSlot.setStatus('current')
if mibBuilder.loadTexts: selfSlot.setDescription('Holds the slot number of the selected IP')
chassisTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 1, 1), )
if mibBuilder.loadTexts: chassisTable.setStatus('current')
if mibBuilder.loadTexts: chassisTable.setDescription('This a table of chassis and their modules.')
chassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1), ).setIndexNames((0, "OMNITRON-MIB", "chassisnum"), (0, "OMNITRON-MIB", "slotnum"))
if mibBuilder.loadTexts: chassisEntry.setStatus('current')
if mibBuilder.loadTexts: chassisEntry.setDescription('Chassis modules.')
chassisnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisnum.setStatus('current')
if mibBuilder.loadTexts: chassisnum.setDescription('The chassis where the module resides. Ranges in value from 1 - 19.')
slotnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotnum.setStatus('current')
if mibBuilder.loadTexts: slotnum.setDescription('The slot number of the module.\n        For the 19 slot chassis it ranges in value from 1-22.\n        For the 2 slot chassis it ranges in value from 1-2.')
chassistype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassistype.setStatus('current')
if mibBuilder.loadTexts: chassistype.setDescription('Type of chassis:\n        1 = 19 module chassis\n        2 = 2 module chassis\n        3 = 5 module chassis\n        4 = 1 module chassis\n        5 = stand alone chassis\n        6 = 1-module redundant power chassis')
prodtype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prodtype.setStatus('current')
if mibBuilder.loadTexts: prodtype.setDescription('The product type of the module:\n        61 = iConverter NMM\n        64 = iConverter Power Supply (19 Module)\n        65 = iConverter 10FL/T Ethernet\n        66 = iConverter 100 Fx/Tx Ethernet\n        67 = iConverter Fiber/Fiber\n        68 = iConverter 10/100 Ethernet\n        70 = iConverter 2FXM slave\n        72 = iConverter GX/X\n        74 = iConverter Tx/2Tx Ethernet\n        75 = iConverter Gx Gigabit Ethernet\n        76 = iConverter Tx/2Fx Ethernet\n        77 = iConverter T1/E1\n        79 = iConverter 4Tx Ethernet\n        80 = iConverter 10/100M\n        81 = iConverter GX/T Ethernet\n        82 = iConverter Power Supply (5 Module)\n        83 = iConverter GX/F Ethernet\n        84 = iConverter 2FX Ethernet\n        85 = iConverter 10T/2 Ethernet\n        86 = iConverter 10/100VT Ethernet\n        87 = iConverter 4Tx VT\n        88 = iConverter RS 422/485\n        89 = iConverter T3/E3\n        90 = iConverter 10/100M slave\n        92 = iConverter RS 232\n        93 = iConverter GX/TM\n        94 = iConverter GX/TM slave\n        95 = iConverter 2GXM\n        96 = iConverter 2FXM\n        97 = iConverter GM3 2xSFP\n        98 = iConverter 2GXM slave\n        99 = iConverter GM3 2xUTP\n        100= iConverter 10/100M2\n        101= iConverter 2FXM2\n        102= iConverter GM3 SFP/2xUTP\n        103= iConverter 1-Module Redundant Powered Chassis\n        104= iConverter Gx AN\n        105= iConverter GX/TM2\n        106= iConverter 2GX/TM2\n        107= iConverter 4xT1/E1 Mux\n        108= iConverter GM3 2xSFP/UTP\n        109= iConverter GM3 3xSFP\n        110= iConverter X.21\n        112= iConverter GM3 3xUTP\n        113= iConverter GM3 FF/UTP or SFP/UTP\n        114= iConverter CWDM\n        115= iConverter XG\n        117= iConverter TM3\n        119= iConverter 4GT\n        120= iConverter GM4 2xSFP/TP\n        136= iConverter XGT+\n        137= iConverter GM4 5-Port\n        142= iConverter GX/T2\n        143= iConverter GM4-HPoE or GM4-PoE+\n        253= iConverter GM3 2XSFP\n        254= iConverter GM3 1xSFP/2xUTP\n        255= iConverter Unknown')
chassisname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisname.setStatus('current')
if mibBuilder.loadTexts: chassisname.setDescription('The name of the chassis.\n\n        For the M2 modules the max size is 32 octets.\n\n        For the GM3, GM4, XM5 the max size is 64 octets when a module is\n        accessed directly through the serial port, or via its own IP address\n        for Telnet, SSH, or SNMP.\n\n        For the GM3, GM4, XM5 when the object is indirectly accessed via the\n        backplane, through IP-less, or through 802.3ah peer-to-peer the value\n        is truncated to 32 bytes.\n       ')
partnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: partnum.setStatus('current')
if mibBuilder.loadTexts: partnum.setDescription('The part number of the module.')
serialnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialnum.setStatus('current')
if mibBuilder.loadTexts: serialnum.setDescription('The serial number of the module.')
manufdate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: manufdate.setStatus('current')
if mibBuilder.loadTexts: manufdate.setDescription('The date the module was manufactured in form YYYYMMDD.')
softrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: softrev.setStatus('current')
if mibBuilder.loadTexts: softrev.setDescription('The software revision of the module software.')
prodrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prodrev.setStatus('current')
if mibBuilder.loadTexts: prodrev.setDescription('The product revision of the module.')
ledstat = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ledstat.setStatus('current')
if mibBuilder.loadTexts: ledstat.setDescription('The status of any first 32 LEDs on the module, excluding the power LED.\n        If an LED is missing its number is skipped.\n\n        For an eight LED position device the following is the decoding:\n        ledstat.7 is the top LED position\n        ledstat.6 is the second LED position\n        ledstat.5 is the third LED position\n        ledstat.4 is the fourth LED position\n        ledstat.3 is the fifth LED position\n        ledstat.2 is the sixth LED position\n        ledstat.1 is the seventh LED position\n        ledstat.0 is the eighth and bottom LED position\n\n        For devices that have 32 or less LEDs this object contains all\n        the LEDs. For those devices that have more than 32 LEDs, LEDs 33\n        and above are only covered by the modExpLedStatus object.\n       ')
switchstat = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchstat.setStatus('current')
if mibBuilder.loadTexts: switchstat.setDescription('The status of any DIP switches on the module.\n        DIP switch 1 is switchstat.0,\n        DIP switch 2 is switchstat.1,\n        DIP switch 3 is switchstat.2, etc.\n\n        DIP switch bank 1 is switches 0-7\n        DIP switch bank 2 is switches 8-15\n\n        Front panel switches start at switchstat.7 for the top switch,\n        switchstat.6 for the next switch, etc.')
extended1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended1.setStatus('current')
if mibBuilder.loadTexts: extended1.setDescription('General extended status for the module. Normally this is the\n        actual setting of the DIP switch selection.')
extended2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended2.setStatus('current')
if mibBuilder.loadTexts: extended2.setDescription('General extended status for the module')
extended3 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended3.setStatus('current')
if mibBuilder.loadTexts: extended3.setDescription('General extended status for the module')
extended4 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended4.setStatus('current')
if mibBuilder.loadTexts: extended4.setDescription('General extended status for the module')
extended5 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended5.setStatus('current')
if mibBuilder.loadTexts: extended5.setDescription('General extended status for the module')
extended6 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: extended6.setStatus('current')
if mibBuilder.loadTexts: extended6.setDescription('General extended status for the module')
resetmod = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetmod.setStatus('current')
if mibBuilder.loadTexts: resetmod.setDescription('Writing to this variable resets the module.  This variable is a write only.\n\n        Writing a zero (0) will reboot to the current working application image\n\n        Writing a one (1) will reboot to the backup application image if\n         available\n       ')
wrswitch = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wrswitch.setStatus('current')
if mibBuilder.loadTexts: wrswitch.setDescription('Writing to this variable updates the module switch settings.\n        See switchstat above for the explanation.')
modulename = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 1, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modulename.setStatus('current')
if mibBuilder.loadTexts: modulename.setDescription('The name of the module')
enhancedchassisTable = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 2, 1))
moduleCount = MibScalar((1, 3, 6, 1, 4, 1, 7342, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: moduleCount.setStatus('current')
if mibBuilder.loadTexts: moduleCount.setDescription('The number of modules in the chassis table')
moduleTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2), )
if mibBuilder.loadTexts: moduleTable.setStatus('current')
if mibBuilder.loadTexts: moduleTable.setDescription('This a table of modules in the enhances chassis table. It contains as many\n                 entries as specified by moduleCount')
moduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: moduleEntry.setStatus('current')
if mibBuilder.loadTexts: moduleEntry.setDescription('Chassis modules.')
modchassnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchassnum.setStatus('current')
if mibBuilder.loadTexts: modchassnum.setDescription('The chassis where the module resides.')
modslotnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modslotnum.setStatus('current')
if mibBuilder.loadTexts: modslotnum.setDescription('The slot number within a chassis.')
modchasstype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchasstype.setStatus('current')
if mibBuilder.loadTexts: modchasstype.setDescription('The type of chassis in which the module resides.')
modprodtype = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modprodtype.setStatus('current')
if mibBuilder.loadTexts: modprodtype.setDescription('The chassis where the module resides.')
modsoftrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modsoftrev.setStatus('current')
if mibBuilder.loadTexts: modsoftrev.setDescription('The modules software revision.')
modprodrev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modprodrev.setStatus('current')
if mibBuilder.loadTexts: modprodrev.setDescription('The modules product revision.')
modreset = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modreset.setStatus('current')
if mibBuilder.loadTexts: modreset.setDescription('Writing to this variable resets the module.  This variable is a write only.\n\n        Writing a zero (0) will reboot to the current working application image\n\n        Writing a one (1) will reboot to the backup application image if\n         available\n       ')
modnumports = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modnumports.setStatus('current')
if mibBuilder.loadTexts: modnumports.setDescription('The number of ports in this module.')
modchassname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modchassname.setStatus('current')
if mibBuilder.loadTexts: modchassname.setDescription('The name of the chassis in which the individual module resides in.\n\n        For the M2 modules the max size is 32 octets.\n\n        For the GM3, GM4, XM5 the max size is 64 octets when a module is\n        accessed directly through the serial port, or via its own IP address\n        for Telnet, SSH, or SNMP.\n\n        For the GM3, GM4, XM5 when the object is indirectly accessed via the\n        backplane, through IP-less, or through 802.3ah peer-to-peer the value\n        is truncated to 32 bytes.\n       ')
modpartnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modpartnum.setStatus('current')
if mibBuilder.loadTexts: modpartnum.setDescription('The model of the individual module.')
modserialnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: modserialnum.setStatus('current')
if mibBuilder.loadTexts: modserialnum.setDescription('The serial number of the individual module.')
modmanufdate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: modmanufdate.setStatus('current')
if mibBuilder.loadTexts: modmanufdate.setDescription('The manufacturing date of the individual module.')
modname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modname.setStatus('current')
if mibBuilder.loadTexts: modname.setDescription('The name of the individual module.')
modportvlan = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modportvlan.setStatus('current')
if mibBuilder.loadTexts: modportvlan.setDescription('The portvlan map of an individual module. The low order bits encode the possible values.\n    The following are the connection paths that exists between the ports on the module:\n        Used on types 69, 72, 81, 83, 84, 86\n            bit0 - Port 1 to Port 2\n            bit1 - Port 1 to Backplane Port A\n            bit2 - Port 1 to Backplane Port B\n            bit3 - Port 2 to Backplane Port A\n            bit4 - Port 2 to Backplane Port B\n            bit5 - Backplane Port A to Backplane Port B\n        Used on types 70, 80, 90, 93, 94, 95, 96, 98, 100, 101, 105, 106\n            bit0 - Port 1 to Port 2\n            bit1 - Port 1 to Backplane Port A\n            bit2 - Port 1 to Backplane Port B\n            bit3 - Port 2 to Backplane Port A\n            bit4 - Port 2 to Backplane Port B\n            bit5 - Backplane Port A to Backplane Port B\n            bit6 - Port 1 to Mgt\n            bit7 - Port 2 to Mgt\n            bit8 - Backplane A to Mgt\n            bit9 - Backplane B to Mgt\n        Used on types 102, 108, 109, 112\n            bit0 - Port 1-2-3 interconnect\n            bit1 - Port 1-2-3 to Backplane Port A\n            bit2 - Port 1-2-3 to Backplane Port B\n            bit3 - Backplane Port A to Backplane Port B\n            bit4 - Port 1 to Mgt\n            bit5 - Port 2 to Mgt\n            bit6 - Port 3 to Mgt\n            bit7 - Backplane A to Mgt\n            bit8 - Backplane B to Mgt\n        Used on types 97, 99, 113\n            bit0 - Port 1 to Port 2\n            bit1 - Port 1 to Backplane Port A\n            bit2 - Port 1 to Backplane Port B\n            bit3 - Port 2 to Backplane Port A\n            bit4 - Port 2 to Backplane Port B\n            bit5 - Backplane Port A to Backplane Port B\n            bit6 - Port 1 to Mgt\n            bit7 - Port 2 to Mgt\n            bit8 - Backplane A to Mgt\n            bit9 - Backplane B to Mgt\n        Used on types 79, 87\n            bit0 - Port 1-2-3-4 interconnect\n            bit1 - Port 1-2-3-4 to backplane A\n            bit2 - Port 1-2-3-4 to backplane B\n            bite 3 Backplane A to Backplane B\n        Used on type 103\n            bit0 - Port A to Backplane A\n            bit1 - Port A to Backplane B\n            bit2 - Port B to Backplane A\n            bit3 - Port B to Backplane B\n            bit4 - Port A to Port B')
modextfeaturebits = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modextfeaturebits.setStatus('current')
if mibBuilder.loadTexts: modextfeaturebits.setDescription("The module's extended features bits.\n                 The bit definitions are:\n                 bit0 - module is capable of being field upgradeable\n                 bit1 - module supports MIB Statistics\n                 bit2 - module supports Memory I/O extended registers\n                 bit3 - module supports Tag Vlan feature\n                 bit4 - module configured as Secure Slave\n                 bit5 - module configured as Secure Proxy\n                 bit6 - module configured as Secure Master\n                 bit7 - module supports 802.3ah OAM Client\n                 bit8 - module supports SFP parameters for port1\n                 bit9 - module supports SFP parameters for port2\n                 bit10 - module supports SFP parameters for port3\n                 bit11 - module supports SFP parameters for port4\n                 bit12 - module supports AH event notification\n                 bit13 - 1-module redundant power chassis supports contact closure status\n                 bit14 - 1-module redundant power chassis supports power over ethernet\n                 bit15 - 1-module redundant power chassis RJ45 connector is installed\n                 bit16 - 1-module redundant power chassis fan is installed\n                 bit17 - when this bit is on the module is a remote slave\n                 bit18 - module supports unidirectional on port1\n                 bit19 - module supports unidirectional on port2\n                 bit20 - module supports unidirectional on port3\n                 bit21 - extended power supply\n                 bit22 - module supports SNMPv3\n                 bit23 - module is NMM2 capable\n                 bit24 - fan is installed\n                 bit25 - generic module class supports 802.1ag/Y.1731\n                 bit26 - module GM3 class supports 802.1ag/Y.1731\n                 bit27 - module GM4 class\n                 bit28 - port 1 is an XFP port\n                 bit29 - port 2 is an XFP port\n                 ")
modswbuildnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modswbuildnum.setStatus('current')
if mibBuilder.loadTexts: modswbuildnum.setDescription("The module's software build number.")
modenable802dot1qProcessing = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modenable802dot1qProcessing.setStatus('current')
if mibBuilder.loadTexts: modenable802dot1qProcessing.setDescription('Enables or disables 802_1q processing.\n                0 = disable\n                1 = enable')
modtagsubstitution = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modtagsubstitution.setStatus('current')
if mibBuilder.loadTexts: modtagsubstitution.setDescription('Enables or disables substitution of 802_1q tags.\n                 Currently not implemented\n                 by any supported module')
modcommitVLANchanges = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modcommitVLANchanges.setStatus('current')
if mibBuilder.loadTexts: modcommitVLANchanges.setDescription('VLAN information is applied to the module and data saved\n                 to persistent storage.  This variable is a write only.')
modvlanTableClear = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modvlanTableClear.setStatus('current')
if mibBuilder.loadTexts: modvlanTableClear.setDescription('VLAN table for the module Vlan table to be cleared.  This variable is a write only.')
modcommitNMMCfgChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modcommitNMMCfgChanges.setStatus('current')
if mibBuilder.loadTexts: modcommitNMMCfgChanges.setDescription('Management module configuration information is applied to the module and data saved\n                 to persistent storage.  This variable is a write only.')
modLM80volts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80volts.setStatus('current')
if mibBuilder.loadTexts: modLM80volts.setDescription('8 bits each of PS1 Voltage(msB), PS2 Voltage, Total Voltage and an unused byte(lsB).\n                1-module redundant power chassis.')
modLM80currents = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80currents.setStatus('current')
if mibBuilder.loadTexts: modLM80currents.setDescription('8 bits each of PS1 Current(msB) (mA/10), PS2 Current, Total Current and an\n                unused byte(lsB).  1-module redundant power chassis.')
modLM80misc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modLM80misc.setStatus('current')
if mibBuilder.loadTexts: modLM80misc.setDescription('8 bits each of Temperature(msB) .5C/bit and 2 unused byte(lsB).  1-module redundant power chassis.')
modRestoreFactoryDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modRestoreFactoryDefaults.setStatus('current')
if mibBuilder.loadTexts: modRestoreFactoryDefaults.setDescription('Management module configuration information is restored to factory\n        defaults.  This variable is a write only. Different types of restore\n        defaults are supported:\n\n        restoreFactoryDefaults(0,1)     Restores factory defaults\n        restoreLocalDefaults(2)         Restores defaults from local file\n        restorePreviousConfig(3)        Restores the previously saved\n                                          configuration. This is useful to regress\n                                          to a known working setup.\n        restoreFactoryDefaultsKeepIp(4) Restores factory defaults but keeps IP\n                                           based settings\n        restoreLocalDefaultsKeepIp(5)   Restores defaults from local file but\n                                           keeps IP based settings.\n        restorePreviousConfigKeepIp(6)  Restores the previously saved\n                                           configuration but keeps IP based\n                                           settings.\n       ')
coreStatusOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: coreStatusOnly.setStatus('current')
if mibBuilder.loadTexts: coreStatusOnly.setDescription('Enable(1) or disable(0) Core Status Only.')
ingressPolicingType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ingressPolicingType.setStatus('current')
if mibBuilder.loadTexts: ingressPolicingType.setDescription('Sets the module global policy used to count bytes for bandwidth\n        calculation purposes. This is available on the GM3 & GM4. This is\n        not available on the XM5.\n\n        1 = L1 includes all bytes in frame, interframe gap and preamble\n        2 = L2 includes all bytes in frame, including Layer 2 header and CRC\n        3 = L3 includes Layer 3 information only, excludes Layer 2 header and CRC\n       ')
vlanservicetag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanservicetag.setStatus('current')
if mibBuilder.loadTexts: vlanservicetag.setDescription('Value for service tag.')
defaultForwardingMap = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: defaultForwardingMap.setStatus('current')
if mibBuilder.loadTexts: defaultForwardingMap.setDescription('Bit vector for default forwarding map where:\n            bit0 - Port 1\n            bit1 - Port 2\n            bit2 - Port 3\n            bit3 - Port 4\n            bit4 - Port BPA\n            bit5 - Port BPB')
modFpgaRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modFpgaRev.setStatus('current')
if mibBuilder.loadTexts: modFpgaRev.setDescription('The current revision of the FPGA.')
modExpPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpPartNumber.setStatus('current')
if mibBuilder.loadTexts: modExpPartNumber.setDescription('The expanded part number of the individual module.\n\n        The modpartnum object indicates the compressed version of the\n        part number name. If this field is not supported in a module it is\n        left as a null length string.\n       ')
modExpSoftwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpSoftwareRev.setStatus('current')
if mibBuilder.loadTexts: modExpSoftwareRev.setDescription("The expanded software revision of the individual module.\n\n        This object allows for an enhanced version of the software revision\n        that include a major and minor component. Major and Minor are always\n        numeric values while the rev value can be a number or an alpha. For\n        instance: 1.0, 1.1, 3.2A, 1.1.2.\n\n        The two digit modsoftrev object includes the major and minor revision.\n        A modsoftrev of '32' would be shown in this object as '3.2'. This object\n        allows the minor number to be expanded beyond a single digit as shown\n        above by '3.2A' above, even though modsoftrev would be '32'.\n\n\n        The modswbuildnum is independent of this scheme, but the complete\n        revision is sometimes referred together as a concatenated value. For\n        instance is '3.2A' is the sofware rev and '1234' is the build number, the\n        concatenated value is '3.2A.1234'.\n       ")
modExpLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 33), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modExpLedStatus.setStatus('current')
if mibBuilder.loadTexts: modExpLedStatus.setDescription('This object is the expanded LED status of the individual module. This\n        object reflects the state, color, and blinking rate of each individual\n        LED.\n\n        Each LED is represented by a single octet. The first octet in the\n        string is the first LED, the second octet in the string is the\n        second LED, until the last LED. The length of the object indicates\n        the number of LEDs of the modules. Non-installed (missing) LEDs return\n        a value of all zeros.\n\n        Each octet is encoded in the following way:\n\n        Bits 0:1 indicate the LED color and state\n           0x0 = LED is off\n           0x1 = LED is amber\n           0x2 = LED is green\n           0x3 = LED is both amber and green (red)\n\n        Bits 2:4 indicate the LED blinking frequency\n           0x0 = LED is solid\n           0x1 = LED is blinking at 10 Hz\n           0x2 = LED is blinking at 5 Hz\n           0x3 = LED is blinking at 2 Hz\n           0x4 = LED is blinking at 1 Hz\n           0x5 = LED is blinking at 1/2 Hz\n\n        Bits 5:7 are currently undefined and return 0x0 for this product\n        revision.\n       ')
modHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 34), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modHwRev.setStatus('current')
if mibBuilder.loadTexts: modHwRev.setDescription('The current hardware revision of the module.')
modPcbRev = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 2, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: modPcbRev.setStatus('current')
if mibBuilder.loadTexts: modPcbRev.setDescription('The current PCB revision of the module.')
moduleMgtCfgTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3), )
if mibBuilder.loadTexts: moduleMgtCfgTable.setStatus('current')
if mibBuilder.loadTexts: moduleMgtCfgTable.setDescription('This is a table of the management module configuration variables.')
moduleMgtCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: moduleMgtCfgEntry.setStatus('current')
if mibBuilder.loadTexts: moduleMgtCfgEntry.setDescription('Chassis modules.')
sysAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysAdminStatus.setStatus('current')
if mibBuilder.loadTexts: sysAdminStatus.setDescription("This variable provides the status for a management module's ability to make\n                changes to the system. In backplane slave, a management module cannot make\n                system modification.  Modifications must be performed from a management\n                module acting as a backplane master.\n\n                0 = read only (can only view configuration settings)\n                1 = read-write (can view and modify configuration settings).")
sysDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(19, 19)).setFixedLength(19)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDateTime.setStatus('current')
if mibBuilder.loadTexts: sysDateTime.setDescription('This variable provides the date and time in display format:\n                    nn/dd/yyyy hh:mm:ss\n                    where nn = 2 digit month, dd = 2 digit day, yyyy = 4 digit year\n                          hh - 2 digit hour 0-23, mm = 2 digit minutes 0-59, ss = 2 digit secs 0-59')
macAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddr.setStatus('current')
if mibBuilder.loadTexts: macAddr.setDescription('MAC address of the management module')
ipAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddr.setStatus('current')
if mibBuilder.loadTexts: ipAddr.setDescription('IP of the management module')
subnetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetmask.setStatus('current')
if mibBuilder.loadTexts: subnetmask.setDescription('subnetmask for the management module')
gateway = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gateway.setStatus('current')
if mibBuilder.loadTexts: gateway.setDescription('IP address for the gateway the management module will use.')
readCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: readCommunity.setStatus('current')
if mibBuilder.loadTexts: readCommunity.setDescription('SNMP read community name.')
writeCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: writeCommunity.setStatus('current')
if mibBuilder.loadTexts: writeCommunity.setDescription('SNMP set community name.')
mychassnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mychassnum.setStatus('current')
if mibBuilder.loadTexts: mychassnum.setDescription('NMMs chassis number.')
mmname = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mmname.setStatus('current')
if mibBuilder.loadTexts: mmname.setDescription('Management Modules chassis name.\n\n        For the M2 modules the max size is 32 octets.\n\n        For the GM3, GM4, XM5 the max size is 64 octets when a module is\n        accessed directly through the serial port, or via its own IP address\n        for Telnet, SSH, or SNMP.\n\n        For the GM3, GM4, XM5 when the object is indirectly accessed via the\n        backplane, through IP-less, or through 802.3ah peer-to-peer the value\n        is truncated to 32 bytes.\n       ')
traphost1 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost1.setStatus('current')
if mibBuilder.loadTexts: traphost1.setDescription('NMMs traphost1 IP address.')
traphost2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost2.setStatus('current')
if mibBuilder.loadTexts: traphost2.setDescription('NMMs traphost2 IP address.')
traphost3 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost3.setStatus('current')
if mibBuilder.loadTexts: traphost3.setDescription('NMMs traphost3 IP address.')
traphost4 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost4.setStatus('current')
if mibBuilder.loadTexts: traphost4.setDescription('NMMs traphost4 IP address.')
traphost5 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 15), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost5.setStatus('current')
if mibBuilder.loadTexts: traphost5.setDescription('NMMs traphost5 IP address.')
traphost6 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost6.setStatus('current')
if mibBuilder.loadTexts: traphost6.setDescription('NMMs traphost6 IP address.')
traphost7 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost7.setStatus('current')
if mibBuilder.loadTexts: traphost7.setDescription('NMMs traphost7 IP address.')
traphost8 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: traphost8.setStatus('current')
if mibBuilder.loadTexts: traphost8.setDescription('NMMs traphost8 IP address.')
sysloc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysloc.setStatus('current')
if mibBuilder.loadTexts: sysloc.setDescription('Management Modules system location.\n\n        For the M2 modules the max size is 32 octets.\n\n        For the GM3, GM4, XM5 the max size is 64 octets when a module is\n        accessed directly through the serial port, or via its own IP address\n        for Telnet, SSH, or SNMP.\n\n        For the GM3, GM4, XM5 when the object is indirectly accessed via the\n        backplane, through IP-less, or through 802.3ah peer-to-peer the value\n        is truncated to 32 bytes.\n       ')
syscon = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syscon.setStatus('current')
if mibBuilder.loadTexts: syscon.setDescription('Management Modules system Contact information.\n\n        For the M2 modules the max size is 32 octets.\n\n        For the GM3, GM4, XM5 the max size is 64 octets when a module is\n        accessed directly through the serial port, or via its own IP address\n        for Telnet, SSH, or SNMP.\n\n        For the GM3, GM4, XM5 when the object is indirectly accessed via the\n        backplane, through IP-less, or through 802.3ah peer-to-peer the value\n        is truncated to 32 bytes.\n       ')
serialpass = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialpass.setStatus('current')
if mibBuilder.loadTexts: serialpass.setDescription('NMMs serial interface password.')
telnetpass = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: telnetpass.setStatus('current')
if mibBuilder.loadTexts: telnetpass.setDescription('NMMs telnet interface password.')
ftppasswrd = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ftppasswrd.setStatus('current')
if mibBuilder.loadTexts: ftppasswrd.setDescription('NMMs ftp password.')
keepAliveInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: keepAliveInterval.setStatus('current')
if mibBuilder.loadTexts: keepAliveInterval.setDescription('This the interval used by the NMM to send out keep alive traps.')
vlanIdOst = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 25), OstVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanIdOst.setStatus('current')
if mibBuilder.loadTexts: vlanIdOst.setDescription('Management module VLAN tagged packet ID.')
nmmCfgSerialBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmCfgSerialBaudrate.setStatus('current')
if mibBuilder.loadTexts: nmmCfgSerialBaudrate.setDescription('This variable defines the baud rate for the serial interface to the NMM.\n                 Where:\n                   1 = 300 bps\n                   2 = 1200 bps\n                   3 = 2400 bps\n                   4 = 4800 bps\n                   5 = 9600 bps\n                   6 = 19200 bps\n                   7 = 38400 bps\n                   8 = 57600 bps\n                   9 = 115200 bps')
enabledFunctions = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enabledFunctions.setStatus('current')
if mibBuilder.loadTexts: enabledFunctions.setDescription('This variable defines which special functions are enabled at the NMM.\n                 Where:\n                    0x01 = Keep Alive trap enabled\n                    0x02 = Telnet enabled\n                    0x04 = FTP enabled\n                    0x08 = switch reload enabled\n                    0x10 = VLAN enabled\n                    0x20 = sw1 block enabled\n                    0x40 = DHCP client enabled\n                    0x80 = Trap 99 processing enabled')
enableSNMPFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPFunction.setStatus('current')
if mibBuilder.loadTexts: enableSNMPFunction.setDescription('This variable defines whether the SNMP Agent is enabled at the NMM.\n                 Where:\n                   00 = SNMP disabled\n                   01 = SNMP enabled')
nmmCfgState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmCfgState.setStatus('current')
if mibBuilder.loadTexts: nmmCfgState.setDescription('This variable defines the state of the configuration changes made to the NMM.\n                 Where:\n                   0x00 = No changes\n                   0x02 = Changes Pending (not saved in Flash)\n                   0x04 = Saved in Flash, Pending NMM reboot')
nmmSecureMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmSecureMode.setStatus('current')
if mibBuilder.loadTexts: nmmSecureMode.setDescription('This variable defines the mode the Management module will operate in when configured for SECURE COMMUNICATIONS.\n                 Where:\n                   0x00 = No Secure Communications\n                   0x01 = Secure Proxy\n                   0x02 = Secure Slave\n                   0x03 = Secure Master')
nmmSecureConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmSecureConnState.setStatus('current')
if mibBuilder.loadTexts: nmmSecureConnState.setDescription('This variable returns the secure connection state between the proxy and secure slave.\n                 Where:\n                   0x00 = Not connected\n                   0x01 = Connection Pending\n                   0x02 = Connection established\n                   0x03 = Connection terminating')
nmmIpProtocolState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmIpProtocolState.setStatus('current')
if mibBuilder.loadTexts: nmmIpProtocolState.setDescription('This variable defines whether the IP protocol is active or disabled.\n                 0 = Active\n                 1 = Disabled')
nmmIpDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmIpDisabled.setStatus('current')
if mibBuilder.loadTexts: nmmIpDisabled.setDescription("This variable defines the configuration value for IP protocol's desired state.\n                 0 = ipActive\n                 1 = ipDisabled")
vlanPri = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPri.setStatus('current')
if mibBuilder.loadTexts: vlanPri.setDescription('Management module VLAN tagged packet priority.')
enableSNMPWrites = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPWrites.setStatus('current')
if mibBuilder.loadTexts: enableSNMPWrites.setDescription('Permit SNMP SET operations.')
cpuVoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuVoltageIn.setStatus('current')
if mibBuilder.loadTexts: cpuVoltageIn.setDescription('voltage input to cpu.')
cpuVoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuVoltageOut.setStatus('current')
if mibBuilder.loadTexts: cpuVoltageOut.setDescription('Voltage out from the cpu.')
cpuTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuTemperature.setStatus('current')
if mibBuilder.loadTexts: cpuTemperature.setDescription('The ambient temperature of the CPU.')
nmmSecureSlaveSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 19))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nmmSecureSlaveSlot.setStatus('current')
if mibBuilder.loadTexts: nmmSecureSlaveSlot.setDescription('The slot number of the secure slave in the remote chassis when configured for SECURE COMMUNICATIONS.')
dhcpIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 40), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpIpAddr.setStatus('current')
if mibBuilder.loadTexts: dhcpIpAddr.setDescription('IP of the management module as assigned by a DHCP server')
dhcpSubnetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 41), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpSubnetmask.setStatus('current')
if mibBuilder.loadTexts: dhcpSubnetmask.setDescription('subnetmask of the management module as assigned by a DHCP server')
dhcpGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 42), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpGateway.setStatus('current')
if mibBuilder.loadTexts: dhcpGateway.setDescription('Gateway IP address of the management module as assigned by a DHCP Server')
nmmOAMmgmtMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nmmOAMmgmtMode.setStatus('current')
if mibBuilder.loadTexts: nmmOAMmgmtMode.setDescription('This variable configures the protocol the Management module will use to communicate\n                 with remote chassis when operating in secure mode.\n                 Where:\n                   0x01 = (OAM_OFF)         No Secure Communications protocol\n                   0x02 = (Auto SECURE_OAM) Use OST proprietary protocol, force remote to switch if not in the OAM_OFF mode\n                   0x03 = (Auto AH_OAM)     Use AH protocol, force remote to switch if not in the OAM_OFF mode\n                   0x04 = (SECURE_OAM)      Use OST proprietary protocol, remote is not forced to switch and must match modes to connect\n                   0x05 = (AH_OAM)          Use AH protocol, remote is not forced to switch and must match modes to connect')
customertag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: customertag.setStatus('current')
if mibBuilder.loadTexts: customertag.setDescription('Value for customer tag.')
servicetag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: servicetag.setStatus('current')
if mibBuilder.loadTexts: servicetag.setDescription('Value for service tag.')
cnodeControl = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnodeControl.setStatus('current')
if mibBuilder.loadTexts: cnodeControl.setDescription('Controls whether the module is operating as a Cnode.')
cnodeCIR = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cnodeCIR.setStatus('current')
if mibBuilder.loadTexts: cnodeCIR.setDescription('Cnode CIR\n                   Where: 1 =  64 Kbps\n                          2 = 128 Kbps\n                          3 = 192 Kbps')
enableSNMPv3Function = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: enableSNMPv3Function.setStatus('current')
if mibBuilder.loadTexts: enableSNMPv3Function.setDescription('This variable defines whether the SNMPv3 Agent is enabled at the NMM.\n                 Where:\n                   00 = SNMP disabled\n                   01 = SNMP enabled')
slaveWrite = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveWrite.setStatus('current')
if mibBuilder.loadTexts: slaveWrite.setDescription('This variable defines whether the module should be allowed to make\n                 configurations to itself when in the chassis slave mode.\n                 Where:\n                   00 = slaveWrite disabled\n                   01 = slaveWrite enabled')
snmpTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapType.setStatus('current')
if mibBuilder.loadTexts: snmpTrapType.setDescription('This variable defines which version of SNMP traps are supported, where:\n                   1 = SNMPv1 traps\n                   2 = SNMPv2c traps\n                   3 = SNMPv3 traps')
capsMask = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 51), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: capsMask.setStatus('current')
if mibBuilder.loadTexts: capsMask.setDescription('Capablility bits for this management module.')
slaveTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveTraps.setStatus('current')
if mibBuilder.loadTexts: slaveTraps.setDescription('This variable defines whether the module should be allowed to\n                 transmit traps out ethernet ports eventhough it is not a chassis master.\n                 Where:\n                   00 = slaveTraps disabled\n                   01 = slaveTraps enabled')
slaveTrapsForward = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slaveTrapsForward.setStatus('current')
if mibBuilder.loadTexts: slaveTrapsForward.setDescription('This variable defines whether the module should be allowed to\n                 forward traps to the chassis master when module is a chassis slave. Default is forward.\n                 Where:\n                   00 = slaveTrapsForward disabled\n                   01 = slaveTrapsForward enabled')
ipAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 54), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipAddr2.setStatus('current')
if mibBuilder.loadTexts: ipAddr2.setDescription('IP 2 of the management module')
subnetmask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 55), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subnetmask2.setStatus('current')
if mibBuilder.loadTexts: subnetmask2.setDescription('subnetmask 2 for the management module')
gateway2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 56), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gateway2.setStatus('current')
if mibBuilder.loadTexts: gateway2.setDescription('IP address for the gateway 2 the management module will use.')
ipaddrEVCassociation = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 57), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipaddrEVCassociation.setStatus('current')
if mibBuilder.loadTexts: ipaddrEVCassociation.setDescription('*** This object is deprecated ***\n\n        EVC associated with ipaddr 1.\n       ')
ipaddr2EVCassociation = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 58), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipaddr2EVCassociation.setStatus('current')
if mibBuilder.loadTexts: ipaddr2EVCassociation.setDescription('*** This object is deprecated ***\n\n        EVC associated with ipaddr 2.\n       ')
bootpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 59), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpEnable.setStatus('current')
if mibBuilder.loadTexts: bootpEnable.setDescription('Enable or disable BOOTP.')
tftpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 60), TruthValue().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpEnable.setStatus('current')
if mibBuilder.loadTexts: tftpEnable.setDescription('Enable or disable TFTP.')
tftpServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 61), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: tftpServerIpAddress.setDescription('TFTP server IP address.')
dhcptftpServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 62), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcptftpServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: dhcptftpServerIpAddress.setDescription('TFTP Server IP address as assigned by a DHCP Server')
tftpFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 63), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFileName.setStatus('current')
if mibBuilder.loadTexts: tftpFileName.setDescription('Selects the TFTP file name.')
modeType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 64), OstModeType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modeType.setStatus('current')
if mibBuilder.loadTexts: modeType.setDescription('Sets the module Mode Type to normal, AP, or SP.')
dhcpPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 65), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpPortNumber.setStatus('current')
if mibBuilder.loadTexts: dhcpPortNumber.setDescription('Sets the DHCP port number.\n                 2 port module:  1=None, 2=Port 1, 3=Port 2, 4=BP A, 5=BP B\n                 3 port module:  1=None, 2=Port 1, 3=Port 2, 4=Port 3, 5=BP A, 6=BP B\n                 5 ports and higher modules: 1=None, 2..n+1 = Port 1..n\n       ')
dhcpTagVid = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 66), OstVlanId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpTagVid.setStatus('current')
if mibBuilder.loadTexts: dhcpTagVid.setDescription('Sets the DHCP Tag VLAN ID.')
trapSrcIpSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 67), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapSrcIpSelect.setStatus('current')
if mibBuilder.loadTexts: trapSrcIpSelect.setDescription('Selects the trap source address, IP1(1) or IP2(2).')
muxGroupDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 68), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: muxGroupDefaults.setStatus('current')
if mibBuilder.loadTexts: muxGroupDefaults.setDescription("This object when written sets the Mux Grouping defaults for a management\n        module. When read the value always returns 'false'.\n\n        Writing this sets the Mux Group EVC and bandwidth profile configurations.\n       ")
portFwdCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 69), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("all", 0), ("port1", 1), ("port2", 2), ("backplaneA", 3), ("backplaneB", 4))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFwdCpu.setStatus('current')
if mibBuilder.loadTexts: portFwdCpu.setDescription('This object enables forwarding of managment traffic from the selected\n        ports only for M2 modules only. Management traffic from ports not defined\n        is dropped.\n\n        all(0)                      Management traffic forwarded from all ports\n        port1(1)                    Management traffic forwarded from Port 1 only\n        port2(2)                    Management traffic forwarded from Port 2 only\n        backplaneA(3)               Management traffic forwarded from BP A only\n        backplaneB(4)               Management traffic forwarded from BP B only\n       ')
portFwdCpuList = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 3, 1, 70), OstPortList().clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portFwdCpuList.setStatus('current')
if mibBuilder.loadTexts: portFwdCpuList.setDescription('This object enables forwarding of managment traffic from the selected\n        ports only for M3, M4, and M5 modules only. Management traffic from\n        ports not defined is dropped.\n       ')
modulePortsTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4), )
if mibBuilder.loadTexts: modulePortsTable.setStatus('current')
if mibBuilder.loadTexts: modulePortsTable.setDescription('This a table of Ports per module. There are as many entries as\n                 specified by modnumports in the moduleEntry')
modulePortsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: modulePortsEntry.setStatus('current')
if mibBuilder.loadTexts: modulePortsEntry.setDescription('Ports per module table.')
portnum = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 1), OstPortNumber())
if mibBuilder.loadTexts: portnum.setStatus('current')
if mibBuilder.loadTexts: portnum.setDescription('Used to get or set state of port.')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("undefined", 0), ("disabled", 1), ("enabled", 2), ("unused", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portState.setStatus('current')
if mibBuilder.loadTexts: portState.setDescription('Used to get or set state of port.')
portEgressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgressRate.setStatus('current')
if mibBuilder.loadTexts: portEgressRate.setDescription('Used to get or set the port throughput limit selection.\n    The following are the limits are enforced by module type:\n        Used on types 80, 96, 70, 90, 86, 84, 87 (lower limit=0, upper limit=7)\n        where:\n        0 = 100 Mbps\n        1 = 128 kbps\n        2 = 256 kbps\n        3 = 512 kbps\n        4 = 1 Mbps\n        5 = 2 Mbps\n        6 = 4 Mbps\n        7 = 8 Mbps\n        Used on types 100, 101 (lower limit=1, upper limit=20)\n        where:\n        1 = 64 kbps\n        2 = 128 kbps\n        3 = 256 kbps\n        4 = 512 kbps\n        5 = 768 kbps\n        6 = 1 Mbps\n        7 = 2 Mbps\n        8 = 3 Mbps\n        9 = 4 Mbps\n        10 = 5 Mbps\n        11 = 6 Mbps\n        12 = 7 Mbps\n        13 = 8 Mbps\n        14 = 9 Mbps\n        15 = 10 Mbps\n        16 = 20 Mbps\n        17 = 30 Mbps\n        18 = 40 Mbps\n        19 = 50 Mbps\n        20 = 100 Mbps\n        Used on types 105, 106 (lower limit=1, upper limit=33)\n        1 = 64 kbps\n        2 = 128 kbps\n        3 = 256 kbps\n        4 = 512 kbps\n        5 = 768 kbps\n        6 = 1 Mbps\n        7 = 2 Mbps\n        8 = 3 Mbps\n        9 = 4 Mbps\n        10 = 5 Mbps\n        11 = 6 Mbps\n        12 = 7 Mbps\n        13 = 8 Mbps\n        14 = 9 Mbps\n        15 = 10 Mbps\n        16 = 20 Mbps\n        17 = 30 Mbps\n        18 = 40 Mbps\n        19 = 50 Mbps\n        20 = 60 Mbps\n        21 = 70 Mbps\n        22 = 80 Mbps\n        23 = 90 Mbps\n        24 = 100 Mbps\n        25 = 200 Mbps\n        26 = 300 Mbps\n        27 = 400 Mbps\n        28 = 500 Mbps\n        29 = 600 Mbps\n        30 = 700 Mbps\n        31 = 800 Mbps\n        32 = 900 Mbps\n        33 = 1000 Mbps\n        Types 97, 99, 102, 108, 109, 112, 113 use numeric values in kpbs\n        with a lower limit of 64 and an upper limit of 1,000,000.\n        Types not listed have no limit.')
portpriority = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portpriority.setStatus('current')
if mibBuilder.loadTexts: portpriority.setDescription('Used to get or set port user-priority.')
portcanonicalformatIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portcanonicalformatIndicator.setStatus('current')
if mibBuilder.loadTexts: portcanonicalformatIndicator.setDescription('Used to get or set port cfi.  Currently not used and defaulted to 0')
portvlanidentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portvlanidentifier.setStatus('current')
if mibBuilder.loadTexts: portvlanidentifier.setDescription('Used to get or set port VID.')
portmlistcriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portmlistcriteria.setStatus('current')
if mibBuilder.loadTexts: portmlistcriteria.setDescription('Used to get or set port membership criteria.')
portingresssecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portingresssecurity.setStatus('current')
if mibBuilder.loadTexts: portingresssecurity.setDescription('Used to get or set port ingress security.')
portegresspolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portegresspolicy.setStatus('current')
if mibBuilder.loadTexts: portegresspolicy.setDescription('Used to get or set port egress policy.')
portIngressRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRate.setStatus('current')
if mibBuilder.loadTexts: portIngressRate.setDescription('Used to get or set the port throughput limit selection.\n    The following are the limits are enforced by module type:\n        Used on types 80, 96, 70, 90, 86, 84, 87 (lower limit=0, upper limit=7)\n        where:\n        0 = 100 Mbps\n        1 = 128 kbps\n        2 = 256 kbps\n        3 = 512 kbps\n        4 = 1 Mbps\n        5 = 2 Mbps\n        6 = 4 Mbps\n        7 = 8 Mbps\n        Used on types 100, 101 (lower limit=64, upper limit=100,000)\n        Values are number of kbps per second, i.e. rate = value x 1000, units in bps\n        Used on types 97, 99, 102, 105, 106, 108, 109, 112, 113 (lower limit=64, upper limit=1,000,000)\n        Values are number of kbps per second, i.e. rate = value x 1000, units in bps\n        Types not listed have no limit.')
portSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSpeed.setStatus('current')
if mibBuilder.loadTexts: portSpeed.setDescription('Used to get the port speed.\n                    0 = undefined\n                    1 = speed10Mbps\n                    2 = speed100Mbps\n                    3 = speed1Gbps\n                    4 = speed10Gbps')
portUnidirectionalAhOamEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portUnidirectionalAhOamEnable.setStatus('current')
if mibBuilder.loadTexts: portUnidirectionalAhOamEnable.setDescription('Used to get/set the unidirectional support.\n                    0 = uniDisabled\n                    1 = uniEnabled')
portIngressRateDropOrPause = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRateDropOrPause.setStatus('current')
if mibBuilder.loadTexts: portIngressRateDropOrPause.setDescription('Used to get/set behavior on overflow.\n                    0 = undefined\n                    1 = inDrop\n                    2 = inPause')
portIngressRateCBS = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 256000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portIngressRateCBS.setStatus('current')
if mibBuilder.loadTexts: portIngressRateCBS.setDescription('Used to get or set the port throughput limit selection.')
portL2CPmgntProcessing = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portL2CPmgntProcessing.setStatus('current')
if mibBuilder.loadTexts: portL2CPmgntProcessing.setDescription('Used to get or set the port L2Cp processing method.\n                    0 = undefined\n                    1 = inDrop\n                    2 = inForward\n                    3 = inTunnel')
portEgressQosPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portEgressQosPolicy.setStatus('current')
if mibBuilder.loadTexts: portEgressQosPolicy.setDescription('Used to get or set the port egress QoS Policy.\n                    0 = undefined\n                    1 = fairWeight\n                    2 = starving')
portAccessType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAccessType.setStatus('current')
if mibBuilder.loadTexts: portAccessType.setDescription('Used to get or set the port access type.\n                    0 = undefined\n                    1 = tunnel\n                    2 = access\n                    3 = trunk')
portStatsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portStatsClear.setStatus('current')
if mibBuilder.loadTexts: portStatsClear.setDescription('Used to clear the statistics table for this port')
portLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkState.setStatus('current')
if mibBuilder.loadTexts: portLinkState.setDescription('Reports the link state of the port.\n                        0 = No link\n                        1 = Linked')
portDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("undefined", 0), ("halfDuplex", 1), ("fullDuplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDuplex.setStatus('current')
if mibBuilder.loadTexts: portDuplex.setDescription('The object indcates the linked port duplex mode.\n\n        undefined(0)         Port is not linked or state of duplex is unknown\n        halfDuplex(1)        Port is linked at half duplex\n        fullDuplex(2)        Port is linked at full duplex\n       ')
portMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 4, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(17, 17)).setFixedLength(17)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMacAddress.setStatus('current')
if mibBuilder.loadTexts: portMacAddress.setDescription("MAC address of the port. If a MAC address doesn't exist on a\n                 port the value returned is all zeros.")
portStatsTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5), )
if mibBuilder.loadTexts: portStatsTable.setStatus('current')
if mibBuilder.loadTexts: portStatsTable.setDescription('This a table of Statistics per port.')
portStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portStatsEntry.setStatus('current')
if mibBuilder.loadTexts: portStatsEntry.setDescription('extended module statitical information.')
txOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctets.setStatus('current')
if mibBuilder.loadTexts: txOctets.setDescription('Statistics counter - Object name explains its usage.')
txDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDropPkts.setStatus('current')
if mibBuilder.loadTexts: txDropPkts.setDescription('Statistics counter - Object name explains its usage.')
txBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: txBroadcastPkts.setDescription('Statistics counter - Object name explains its usage.')
txMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: txMulticastPkts.setDescription('Statistics counter - Object name explains its usage.')
txUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: txUnicastPkts.setDescription('Statistics counter - Object name explains its usage.')
txGoodPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txGoodPkts.setStatus('current')
if mibBuilder.loadTexts: txGoodPkts.setDescription('Statistics counter - Object name explains its usage.')
txErrorPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txErrorPkts.setStatus('current')
if mibBuilder.loadTexts: txErrorPkts.setDescription('Statistics counter - Object name explains its usage.')
txPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txPausePkts.setStatus('current')
if mibBuilder.loadTexts: txPausePkts.setDescription('Statistics counter - Object name explains its usage.')
txCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txCollisions.setStatus('current')
if mibBuilder.loadTexts: txCollisions.setDescription('Statistics counter - Object name explains its usage.')
txSingleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txSingleCollision.setStatus('current')
if mibBuilder.loadTexts: txSingleCollision.setDescription('Statistics counter - Object name explains its usage.')
txMultipleCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txMultipleCollision.setStatus('current')
if mibBuilder.loadTexts: txMultipleCollision.setDescription('Statistics counter - Object name explains its usage.')
txDeferedTransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDeferedTransmit.setStatus('current')
if mibBuilder.loadTexts: txDeferedTransmit.setDescription('Statistics counter - Object name explains its usage.')
txLateCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txLateCollision.setStatus('current')
if mibBuilder.loadTexts: txLateCollision.setDescription('Statistics counter - Object name explains its usage.')
txExcessiveCollision = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txExcessiveCollision.setStatus('current')
if mibBuilder.loadTexts: txExcessiveCollision.setDescription('Statistics counter - Object name explains its usage.')
txDroppedEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txDroppedEvents.setStatus('current')
if mibBuilder.loadTexts: txDroppedEvents.setDescription('Statistics counter - Object name explains its usage.')
rxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctets.setStatus('current')
if mibBuilder.loadTexts: rxOctets.setDescription('Statistics counter - Object name explains its usage.')
rxDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxDropPkts.setStatus('current')
if mibBuilder.loadTexts: rxDropPkts.setDescription('Statistics counter - Object name explains its usage.')
rxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: rxBroadcastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: rxMulticastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxUnicastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUnicastPkts.setStatus('current')
if mibBuilder.loadTexts: rxUnicastPkts.setDescription('Statistics counter - Object name explains its usage.')
rxGoodPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxGoodPkts.setStatus('current')
if mibBuilder.loadTexts: rxGoodPkts.setDescription('Statistics counter - Object name explains its usage.')
rxTotalPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxTotalPkts.setStatus('current')
if mibBuilder.loadTexts: rxTotalPkts.setDescription('Statistics counter - Object name explains its usage.')
rxErrorPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxErrorPkts.setStatus('current')
if mibBuilder.loadTexts: rxErrorPkts.setDescription('Statistics counter - Object name explains its usage.')
rxPausePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPausePkts.setStatus('current')
if mibBuilder.loadTexts: rxPausePkts.setDescription('Statistics counter - Object name explains its usage.')
rxUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: rxUndersizePkts.setDescription('Statistics counter - Object name explains its usage.')
rxOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOversizePkts.setStatus('current')
if mibBuilder.loadTexts: rxOversizePkts.setDescription('Statistics counter - Object name explains its usage.')
rxFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFragments.setStatus('current')
if mibBuilder.loadTexts: rxFragments.setDescription('Statistics counter - Object name explains its usage.')
rxJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxJabbers.setStatus('current')
if mibBuilder.loadTexts: rxJabbers.setDescription('Statistics counter - Object name explains its usage.')
rxAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxAlignmentErrors.setStatus('current')
if mibBuilder.loadTexts: rxAlignmentErrors.setDescription('Statistics counter - Object name explains its usage.')
rxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxFCSErrors.setStatus('current')
if mibBuilder.loadTexts: rxFCSErrors.setDescription('Statistics counter - Object name explains its usage.')
rxSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxSymbolErrors.setStatus('current')
if mibBuilder.loadTexts: rxSymbolErrors.setDescription('Statistics counter - Object name explains its usage.')
rxCRCAlignErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxCRCAlignErrors.setStatus('current')
if mibBuilder.loadTexts: rxCRCAlignErrors.setDescription('Statistics counter - Object name explains its usage.')
rxPackets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets64.setStatus('current')
if mibBuilder.loadTexts: rxPackets64.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets65to127 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets65to127.setStatus('current')
if mibBuilder.loadTexts: rxPackets65to127.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets128to255 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets128to255.setStatus('current')
if mibBuilder.loadTexts: rxPackets128to255.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets256to511 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets256to511.setStatus('current')
if mibBuilder.loadTexts: rxPackets256to511.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets512to1023 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets512to1023.setStatus('current')
if mibBuilder.loadTexts: rxPackets512to1023.setDescription('Statistics counter - packets of octet count in object name.')
rxPackets1024to1518 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPackets1024to1518.setStatus('current')
if mibBuilder.loadTexts: rxPackets1024to1518.setDescription('Statistics counter - packets of octet count in object name.')
txOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txOctets64.setStatus('current')
if mibBuilder.loadTexts: txOctets64.setDescription('64 bit octet transmission counter.')
rxOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 5, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxOctets64.setStatus('current')
if mibBuilder.loadTexts: rxOctets64.setDescription('64 bit octet receive counter.')
moduleVLANTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6), )
if mibBuilder.loadTexts: moduleVLANTable.setStatus('current')
if mibBuilder.loadTexts: moduleVLANTable.setDescription('This a table of VLAN entries per module. There is a\n                 maximum of 64 valid entries in the table')
moduleVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "index"))
if mibBuilder.loadTexts: moduleVLANEntry.setStatus('current')
if mibBuilder.loadTexts: moduleVLANEntry.setDescription('VLAN module table.')
index = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: index.setStatus('current')
if mibBuilder.loadTexts: index.setDescription('Used to get or set elements in the vlan table entry.')
validityflag = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: validityflag.setStatus('current')
if mibBuilder.loadTexts: validityflag.setDescription('Used to set or delete a VLAN table entry.\n        0 = entry does not exists or is to be deleted,\n        1 = entry to be created or re-activated (in the case the entry\n            was modified, the module needs to be notified of the change.\n            This would constitute a re-activation.')
vlanidentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanidentifier.setStatus('current')
if mibBuilder.loadTexts: vlanidentifier.setDescription('Used to set or get the vlan identifier.\n                valid settable range is 0-4095')
port1Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port1Membership.setStatus('current')
if mibBuilder.loadTexts: port1Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
port2Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port2Membership.setStatus('current')
if mibBuilder.loadTexts: port2Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
port3Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port3Membership.setStatus('current')
if mibBuilder.loadTexts: port3Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
port4Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port4Membership.setStatus('current')
if mibBuilder.loadTexts: port4Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
port5Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port5Membership.setStatus('current')
if mibBuilder.loadTexts: port5Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
port6Membership = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: port6Membership.setStatus('current')
if mibBuilder.loadTexts: port6Membership.setDescription("Used to set or get the port's membership in the specified vlan.\n            0 = not a member\n            1 = include in membership")
portAHTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7), )
if mibBuilder.loadTexts: portAHTable.setStatus('current')
if mibBuilder.loadTexts: portAHTable.setDescription('This is a table of AH parameter entries per port.')
portAHEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portAHEntry.setStatus('current')
if mibBuilder.loadTexts: portAHEntry.setDescription('AH port table.')
ahEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahEnabled.setStatus('current')
if mibBuilder.loadTexts: ahEnabled.setDescription('Used to get or set the state of the AH protocol over specified port.\n            0 = disable - this port is not actively using the AH protocol\n            1 = enabled - this port is actively using the AH protocol')
ahLpbkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLpbkMode.setStatus('current')
if mibBuilder.loadTexts: ahLpbkMode.setDescription('Used to get or set the state of the OAM remote loopback.\n            0 = off - remote loopback is not active\n            1 = on  - remote loopback has been activated')
ahLocalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLocalMode.setStatus('current')
if mibBuilder.loadTexts: ahLocalMode.setDescription('Used to get or set the mode AH OAM Client.\n            0 = PASSIVE - Does not initiate discovery or remote loopbacks\n            1 = ACTIVE  - Initiates discovery process and may initiate remote loopbacks\n            2 = PASSIVE, PROTECTED - Same as PASSIVE but disallows configuration requests from link partner using AH extensions\n            3 = ACTIVE,  PROTECTED - Same as ACTIVE but disallows configuration requests from link partner using AH extensions')
ahRemoteMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteMode.setStatus('current')
if mibBuilder.loadTexts: ahRemoteMode.setDescription('Used to get or set the mode AH OAM Client.\n            0 = PASSIVE - Does not initiate discovery or remote loopbacks\n            1 = ACTIVE  - Initiates discovery process and may initiate remote loopbacks\n            2 = PASSIVE, PROTECTED - Same as PASSIVE but disallows configuration requests from link partner using AH extensions\n            3 = ACTIVE,  PROTECTED - Same as ACTIVE but disallows configuration requests from link partner using AH extensions')
ahLocalMuxState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalMuxState.setStatus('current')
if mibBuilder.loadTexts: ahLocalMuxState.setDescription('Used to get local multiplexer state.\n            0 = FWD - Multiplexer passes MAC client frames to subordinate sublayer\n            1 = DISCARD  - Multiplexer discards MAC client frames')
ahRemoteMuxState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteMuxState.setStatus('current')
if mibBuilder.loadTexts: ahRemoteMuxState.setDescription('Used to get remote multiplexer state.\n            0 = FWD     - Multiplexer passes MAC client frames to subordinate sublayer\n            1 = DISCARD - Multiplexer discards MAC client frames')
ahLocalParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalParserState.setStatus('current')
if mibBuilder.loadTexts: ahLocalParserState.setDescription('Used to get local parser state.\n            0 = FWD      - Parser passes received non-OAMPDUs to subordinate sublayer\n            1 = LOOPBACK - Parser passes received non-OAMPDUs to Multiplexer during remote loopback test\n            2 = DISCARD  - Parser discards received non-OAMPDUs')
ahRemoteParserState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteParserState.setStatus('current')
if mibBuilder.loadTexts: ahRemoteParserState.setDescription('Used to get remote parser state.\n            0 = FWD      - Parser passes received non-OAMPDUs to subordinate sublayer\n            1 = LOOPBACK - Parser passes received non-OAMPDUs to Multiplexer during remote loopback test\n            2 = DISCARD  - Parser discards received non-OAMPDUs')
ahLocalSupportVar = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalSupportVar.setStatus('current')
if mibBuilder.loadTexts: ahLocalSupportVar.setDescription('Used to get local configured features supported in bit encoded value.\n\n        where:\n          bit0 = OAM Mode\n          bit1 = Unidirectional support\n          bit2 = Loopback Support\n          bit3 = interprets link events\n          bit4 = Variable Retrieval\n          bit5 = Critical Event\n       ')
ahLocalLinkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalLinkFlags.setStatus('current')
if mibBuilder.loadTexts: ahLocalLinkFlags.setDescription('Used to get Link Event status in bit encoded value.\n            where:\n                bit0  = Link Fault\n                bit1  = Dying Gasp\n                bit2  = Critical Event\n                bit3  = Local Evaluating\n                bit4  = Local Stable\n                bit5  = Remote Evaluating\n                bit6  = Remote Stable')
ahLocalLpbkTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahLocalLpbkTimeout.setStatus('current')
if mibBuilder.loadTexts: ahLocalLpbkTimeout.setDescription('Used to get/set Remote Loopback timeout.\n            Value is in seconds with range 0 - 300.')
ahRemoteSupportVar = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteSupportVar.setStatus('current')
if mibBuilder.loadTexts: ahRemoteSupportVar.setDescription('Used to get remote configured features supported in bit encoded value.\n\n        where:\n          bit0 = OAM Mode\n          bit1 = Unidirectional support\n          bit2 = Loopback Support\n          bit3 = interprets link events\n          bit4 = Variable Retrieval\n          bit5 = Critical Event\n       ')
ahRemoteLinkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLinkFlags.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLinkFlags.setDescription('Used to get Link Event status in bit encoded value.\n                bit0  = Link Fault\n                bit1  = Dying Gasp\n                bit2  = Critical Event\n                bit3  = Local Evaluating\n                bit4  = Local Stable\n                bit5  = Remote Evaluating\n                bit6  = Remote Stable')
ahRemoteLpbkTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLpbkTimeout.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLpbkTimeout.setDescription('Used to get/set Remote Loopback timeout.\n            Value is in seconds with range 0 - 300.')
ahLocalOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahLocalOUI.setStatus('current')
if mibBuilder.loadTexts: ahLocalOUI.setDescription('Used to get the Organizational Unique ID of the local port.')
ahRemoteOUI = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteOUI.setStatus('current')
if mibBuilder.loadTexts: ahRemoteOUI.setDescription('Used to get the Organizational Unique ID of the remote port.')
ahErroredSymbolPeriodWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredSymbolPeriodWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredSymbolPeriodWindow.setDescription('Used to get or set errored symbol period window for the local port.')
ahErroredSymbolPeriodThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 18), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredSymbolPeriodThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredSymbolPeriodThreshold.setDescription('Used to get or set errored symbol period threshold for the local port.')
ahErroredFrameWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameWindow.setDescription('Used to get or set the errored symbol window for the local port.')
ahErroredFrameThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameThreshold.setDescription('Used to get or set the errored symbol threshold for the local port.')
ahErroredFramePeriodWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFramePeriodWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFramePeriodWindow.setDescription('Used to get or set the errored frame period window for the local port.')
ahErroredFramePeriodThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFramePeriodThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFramePeriodThreshold.setDescription('Used to get or set the errored frame period threshold for the local port.')
ahErroredFrameSecondsWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 900))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameSecondsWindow.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameSecondsWindow.setDescription('Used to get or set the errored frame seconds window for the local port.')
ahErroredFrameSecondsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahErroredFrameSecondsThreshold.setStatus('current')
if mibBuilder.loadTexts: ahErroredFrameSecondsThreshold.setDescription('Used to get or set the errored frame seconds threshold for the local port.')
ahRemoteLinkPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahRemoteLinkPort.setStatus('current')
if mibBuilder.loadTexts: ahRemoteLinkPort.setDescription('Used to get the port number of the remote partner.\n            Value is in the Range 1-5.  A zero port number indicates no connection or not supported')
ahSymbolErrorRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahSymbolErrorRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahSymbolErrorRunningTotal.setDescription('This object indicates the 802.3ah Symbol Error Running Total value from\n        the last OAM sublayer reset or clear operation.\n\n        A value of zero indicates that no symbol errors have been detected since\n        the last reset or clear. For each symbol error detected the value of the\n        object increments.\n       ')
ahSymbolErrorEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahSymbolErrorEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahSymbolErrorEventTotal.setDescription('This object indicates the number of 802.3ah Errored Symbol Period Event\n        TLVs that have been generated since the OAM sublayer was reset or the\n        counters have been cleared.\n\n        A value of zero indicates that no Errored Symbol Period Event TLVs\n        have been generated. For each Errored Symbol Period Event TLV generated\n        the value of the object increments.\n       ')
ahFrameErrorRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameErrorRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameErrorRunningTotal.setDescription('This object indicates the sum of the 802.3ah errored frames that have been\n        detected since the OAM sublayer was reset or clear operation.\n\n        A value of zero indicates that no errored frames have been detected since\n        the last reset or clear. For each errored frame the value of the\n        object increments.\n       ')
ahFrameErrorEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameErrorEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameErrorEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Event TLVs\n        that have been generated since the OAM sublayer was reset or the\n        counters have been cleared.\n\n        A value of zero indicates that no Errored Frame Event TLVs\n        have been generated. For each Errored Frame Event Event TLV generated\n        the value of the object increments.\n       ')
ahFramePeriodRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFramePeriodRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFramePeriodRunningTotal.setDescription('This object indicates the sum of 802.3ah the frame errors that\n        have been detected that have been since the OAM sublayer was reset or\n        clear operation.\n\n        A value of zero indicates that no errored frames have been detected since\n        the last reset or clear. For each errored frame the value of the\n        object increments.\n       ')
ahFramePeriodEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFramePeriodEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFramePeriodEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Period Event\n        TLVs that have been generated since the OAM sublayer was reset or the\n        counters have been cleared.\n\n        A value of zero indicates that no Errored Frame Period Event TLVs\n        have been generated. For each Errored Symbol Period Event TLV generated\n        the value of the object increments.\n       ')
ahFrameSecondsSummaryRunningTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 32), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameSecondsSummaryRunningTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameSecondsSummaryRunningTotal.setDescription('This object indicates the sum of the 802.3ah errored frame seconds that\n        have been detected that have been since the OAM sublayer was reset or\n        clear operation.\n\n        A value of zero indicates that no errored frame seconds have been detected\n        since the last reset or clear. For each errored frame the value of the\n        object increments.\n       ')
ahFrameSecondsSummaryEventTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 33), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ahFrameSecondsSummaryEventTotal.setStatus('current')
if mibBuilder.loadTexts: ahFrameSecondsSummaryEventTotal.setDescription('This object indicates the number of 802.3ah Errored Frame Seconds\n        Summary Event TLVs that have been generated since the OAM sublayer was\n        reset or the counters have been cleared.\n\n        A value of zero indicates that no Errored Frame Seconds Summary Event\n        TLVs have been generated. For each Errored Symbol Period Event TLV\n        generated the value of the object increments.\n       ')
ahClearStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 34), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahClearStatistics.setStatus('current')
if mibBuilder.loadTexts: ahClearStatistics.setDescription("This object when written clears the 802.3ah statistic counters associated with\n        a specific port. When read the value always returns 'false'.\n\n        Writing this value does not change any items in the configuration table.\n       ")
ahTransmissionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 35), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 100))).setUnits('Frames/sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahTransmissionRate.setStatus('current')
if mibBuilder.loadTexts: ahTransmissionRate.setDescription('This object sets maximum 802.3ah PDU transmission rate. The default\n        value is 10 (10 frames per second)\n       ')
ahCriticalEventMode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahCriticalEventMode.setStatus('current')
if mibBuilder.loadTexts: ahCriticalEventMode.setDescription('Used to get or set the state of the local critical event mode.\n            0 = local critical events not enabled\n            1 = local critical events are enabled\n       ')
ahCriticalEventTrapList = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 7, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 45))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ahCriticalEventTrapList.setStatus('current')
if mibBuilder.loadTexts: ahCriticalEventTrapList.setDescription("Used to the SNMP traps which will cause the generation of\n        a local critical event. It is a list of zero or more trap numbers\n        separated by a comma or range, '..'.\n\n        Example values:\n         5\n         5,110,112\n         100..110\n         5,110,90..95,100..105\n\n        The default value is an emtpy string, no SNMP traps generate a local\n        critical event.\n       ")
portSFPTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8), )
if mibBuilder.loadTexts: portSFPTable.setStatus('current')
if mibBuilder.loadTexts: portSFPTable.setDescription('This is a table of AH parameter entries per port.')
portSFPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "portnum"))
if mibBuilder.loadTexts: portSFPEntry.setStatus('current')
if mibBuilder.loadTexts: portSFPEntry.setDescription('SFP port table.')
portSFPstatus = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPstatus.setStatus('current')
if mibBuilder.loadTexts: portSFPstatus.setDescription('Used to get present or absence of SFP device.\n                    0 = undefined\n                    1 = notPresent\n                    2 = present')
portSFPpageA0 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPpageA0.setStatus('current')
if mibBuilder.loadTexts: portSFPpageA0.setDescription('Used to get SFP device EEPROM address A0')
portSFPpageA2 = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSFPpageA2.setStatus('current')
if mibBuilder.loadTexts: portSFPpageA2.setDescription('Used to get SFP device EEPROM address A2')
portSfpBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpBitRate.setStatus('current')
if mibBuilder.loadTexts: portSfpBitRate.setDescription('SFP Bitrate in Mbps')
portSfpVendorName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorName.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorName.setDescription('SFP Vendor Name')
portSfpVendorPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorPartNumber.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorPartNumber.setDescription('SFP Vendor Name')
portSfpVendorSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVendorSerialNumber.setStatus('current')
if mibBuilder.loadTexts: portSfpVendorSerialNumber.setDescription('SFP Serial Number')
portSfpDateCode = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpDateCode.setStatus('current')
if mibBuilder.loadTexts: portSfpDateCode.setDescription('SFP Date Code')
portSfpTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpTemperature.setStatus('current')
if mibBuilder.loadTexts: portSfpTemperature.setDescription('SFP tempearture in degrees Centigrade')
portSfpVcc = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpVcc.setStatus('current')
if mibBuilder.loadTexts: portSfpVcc.setDescription('SFP VCC in volts')
portSfpBiasCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpBiasCurrent.setStatus('current')
if mibBuilder.loadTexts: portSfpBiasCurrent.setDescription('SFP Bias Current in millamps')
portSfpTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpTxPower.setStatus('current')
if mibBuilder.loadTexts: portSfpTxPower.setDescription('SFP Transmission power in dBm')
portSfpRxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 8, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSfpRxPower.setStatus('current')
if mibBuilder.loadTexts: portSfpRxPower.setDescription('SFP Transmission power in dBm')
userTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9), )
if mibBuilder.loadTexts: userTable.setStatus('current')
if mibBuilder.loadTexts: userTable.setDescription('This is a table of SNMPv3 users.')
userEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "userIndex"))
if mibBuilder.loadTexts: userEntry.setStatus('current')
if mibBuilder.loadTexts: userEntry.setDescription('User table entry.')
userIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: userIndex.setStatus('current')
if mibBuilder.loadTexts: userIndex.setDescription('User table index')
snmpv3UserName = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3UserName.setStatus('current')
if mibBuilder.loadTexts: snmpv3UserName.setDescription('SNMPv3 user name.')
snmpv3SecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3SecurityLevel.setStatus('current')
if mibBuilder.loadTexts: snmpv3SecurityLevel.setDescription('SNMPv3 security level\n                    0 = undefined\n                    1 = no authentication/no privacy\n                    2 = authentication/no privacy\n                    3 = authentication/privacy')
snmpv3AuthPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3AuthPassword.setStatus('current')
if mibBuilder.loadTexts: snmpv3AuthPassword.setDescription('SNMPv3 user authentication password.')
snmpv3PrivPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3PrivPassword.setStatus('current')
if mibBuilder.loadTexts: snmpv3PrivPassword.setDescription('SNMPv3 user privacy password.')
snmpv3UserType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpv3UserType.setStatus('current')
if mibBuilder.loadTexts: snmpv3UserType.setDescription('SNMPv3 User Type\n                    0 = undefined\n                    1 = admin\n                    2 = read-write\n                    3 = read-only\n                    4 = deny')
ostProtocolStatusTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10), )
if mibBuilder.loadTexts: ostProtocolStatusTable.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusTable.setDescription('This table supports the Serial, Telnet, FTP user session status.')
ostProtocolStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"), (0, "OMNITRON-MIB", "userIndex"), (0, "OMNITRON-MIB", "ostProtocolStatusIndex"))
if mibBuilder.loadTexts: ostProtocolStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusEntry.setDescription('This is a user protocol table entry.')
ostProtocolStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ostProtocolStatusIndex.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusIndex.setDescription('An index that is used to identify a specific user protocol session.\n\n        The index should remain constant until the session is closed.\n       ')
ostProtocolStatusType = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("serial", 1), ("telnet", 2), ("ftp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusType.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusType.setDescription('This object indicates the specific user protocol session identity\n        state.\n\n        serial    (1)  User protocol session type is the serial port\n        telnet    (2)  User protocol session type is TELNET\n        ftp       (3)  User protocol session type is FTP\n       ')
ostProtocolStatusState = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("lockedout", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusState.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusState.setDescription('This object indicates the status of the specific user protocol session\n        state.\n\n        inactive(1)   User is currently inactive (reserved value, not used)\n        active(2)     User is currently authenticated and active\n        lockedout(3)  User is currently locked out for authentication and\n                      cannot become active until the locked out timeout\n                      expires and the user status goes back to idle.\n       ')
ostProtocoManagementPort = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notDefined", 1), ("mgt1", 2), ("mgt2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocoManagementPort.setStatus('current')
if mibBuilder.loadTexts: ostProtocoManagementPort.setDescription("This object indicates the status of the specific user protocol session\n        state. It is not applicable to the 'serial' interface or to a\n        session type that is locked out. In these cases the object is returned\n        with a value of 'notDefined'.\n\n        notDefined(1)  Management port is unknown or undefined\n        mgt1(2)        Management Port 1 association\n        mgt2(3)        Management Port 2 association\n\n       ")
ostProtocolStatusIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusIpAddress.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusIpAddress.setDescription("This object indicates the IP address of the specific user protocol\n        session. It is not applicable to the 'serial' interface or to a\n        session type that is locked out. In these cases this object is returned\n        as '0.0.0.0'.\n       ")
ostProtocolStatusSessionOpenLockTime = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 10, 1, 6), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostProtocolStatusSessionOpenLockTime.setStatus('current')
if mibBuilder.loadTexts: ostProtocolStatusSessionOpenLockTime.setDescription('The object indicates the time a specific user protocol session has\n        been open or is locked out, in 0.01 seconds, based upon the value of\n        ostProtocolStatusState.\n       ')
ostEnvironmentalStatusTable = MibTable((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11), )
if mibBuilder.loadTexts: ostEnvironmentalStatusTable.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalStatusTable.setDescription('This table supports the module environmental status objects.')
ostEnvironmentalStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1), ).setIndexNames((0, "OMNITRON-MIB", "modchassnum"), (0, "OMNITRON-MIB", "modslotnum"))
if mibBuilder.loadTexts: ostEnvironmentalStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalStatusEntry.setDescription('This is an environmental table entry.')
ostEnvironmentalPs1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1Status.setDescription('This object indicates the status of Power Supply PS1 or PSA.\n\n        notApplicable(0)        Power Supply PS1/PSA is not supported\n        notInstalled(1)         Power Supply PS1/PSA is not installed\n        installedNotPowered(2)  Power Supply PS1/PSA is installed, but not powered\n        installedPowered(3)     Power Supply PS1/PSA is installed and powered\n       ')
ostEnvironmentalPs1VoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 2), Integer32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageIn.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageIn.setDescription('This object indicates PS1/PSA voltage input in millivolts.\n\n        A value of zero indicates that no voltage is applied or the power\n        supply is incapable of supplying a voltage input reading.\n       ')
ostEnvironmentalPs1VoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 3), Unsigned32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1VoltageOut.setDescription('This object indicates PS1/PSA voltage output in millivolts.\n\n        A value of zero indicates that no voltage is output or the power\n        supply is incapable of supplying a voltage output reading.\n       ')
ostEnvironmentalPs1CurrentOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 4), Unsigned32()).setUnits('milliamps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs1CurrentOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs1CurrentOut.setDescription('This object indicates PS1/PSA current output in millianmps.\n\n        A value of zero indicates that no current is output or the power\n        supply is incapable of supplying a current output reading.\n       ')
ostEnvironmentalPs2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2Status.setDescription('This object indicates the status of Power Supply PS2 or PSB.\n\n        notApplicable(0)        Power Supply PS2/PSB is not supported\n        notInstalled(1)         Power Supply PS2/PSB is not installed\n        installedNotPowered(2)  Power Supply PS2/PSB is installed, but not powered\n        installedPowered(3)     Power Supply PS2/PSB is installed and powered\n       ')
ostEnvironmentalPs2VoltageIn = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 6), Integer32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageIn.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageIn.setDescription('This object indicates PS2/PSB voltage input in millivolts.\n\n        A value of zero indicates that no voltage is applied or the power\n        supply is incapable of supplying a voltage input reading.\n       ')
ostEnvironmentalPs2VoltageOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 7), Unsigned32()).setUnits('millivolts').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2VoltageOut.setDescription('This object indicates PS2/PSB voltage output in millivolts.\n\n        A value of zero indicates that no voltage is output or the power\n        supply is incapable of supplying a voltage output reading.\n       ')
ostEnvironmentalPs2CurrentOut = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 8), Unsigned32()).setUnits('milliamps').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalPs2CurrentOut.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalPs2CurrentOut.setDescription('This object indicates PS2/PSB current output in millianmps.\n\n        A value of zero indicates that no current is output or the power\n        supply is incapable of supplying a current output reading.\n       ')
ostEnvironmentalTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 9), Integer32()).setUnits('degrees centigrade').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalTemperature.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalTemperature.setDescription('This object indicates the module internal ambient temperature in\n        degrees centigrade.\n\n        A value of zero indicates that the current temperature is 0 degrees or\n        the module incapable of supplying a temperature reading.\n       ')
ostEnvironmentalFan1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan1Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan1Status.setDescription('This object indicates the status of Fan 1.\n\n        notApplicable(0)        Fan 1 is not supported\n        notInstalled(1)         Fan 1 is not installed\n        installedNotPowered(2)  Fan 1 is installed, but not powered\n        installedPowered(3)     Fan 1 is installed and powered\n       ')
ostEnvironmentalFan1Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 11), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan1Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan1Speed.setDescription('This object indicates the speed of Fan 1 in RPM (revolutions per minute)\n\n        A value of zero indicates that the current fan speed is 0 RPM or\n        the fan is not supported or installed.\n       ')
ostEnvironmentalFan2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan2Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan2Status.setDescription('This object indicates the status of Fan 2.\n\n        notApplicable(0)        Fan 2 is not supported\n        notInstalled(1)         Fan 2 is not installed\n        installedNotPowered(2)  Fan 2 is installed, but not powered\n        installedPowered(3)     Fan 2 is installed and powered\n       ')
ostEnvironmentalFan2Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 13), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan2Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan2Speed.setDescription('This object indicates the speed of Fan 2 in RPM (revolutions per minute)\n\n        A value of zero indicates that the current fan speed is 0 RPM or\n        the fan is not supported or installed.\n       ')
ostEnvironmentalFan3Status = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("notInstalled", 1), ("installedNotPowered", 2), ("installedPowered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan3Status.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan3Status.setDescription('This object indicates the status of Fan 3.\n\n        notApplicable(0)        Fan 3 is not supported\n        notInstalled(1)         Fan 3 is not installed\n        installedNotPowered(2)  Fan 3 is installed, but not powered\n        installedPowered(3)     Fan 3 is installed and powered\n       ')
ostEnvironmentalFan3Speed = MibTableColumn((1, 3, 6, 1, 4, 1, 7342, 2, 1, 11, 1, 15), Unsigned32()).setUnits('rpm').setMaxAccess("readonly")
if mibBuilder.loadTexts: ostEnvironmentalFan3Speed.setStatus('current')
if mibBuilder.loadTexts: ostEnvironmentalFan3Speed.setDescription('This object indicates the speed of Fan 3 in RPM (revolutions per minute)\n\n        A value of zero indicates that the current fan speed is 0 RPM or\n        the fan is not supported or installed.\n       ')
omnitronCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4, 1))
omnitronGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 7342, 4, 2))
omnitronCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 7342, 4, 1, 1)).setObjects(("OMNITRON-MIB", "omnitronGroup"), ("OMNITRON-MIB", "omnitronSFPGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronCompliance = omnitronCompliance.setStatus('current')
if mibBuilder.loadTexts: omnitronCompliance.setDescription('The compliance statement for OMNITRON iConverter modules.')
omnitronGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 7342, 4, 2, 1))
for _omnitronGroup_obj in [[("OMNITRON-MIB", "chassis"), ("OMNITRON-MIB", "selfSlot"), ("OMNITRON-MIB", "chassisnum"), ("OMNITRON-MIB", "slotnum"), ("OMNITRON-MIB", "chassistype"), ("OMNITRON-MIB", "prodtype"), ("OMNITRON-MIB", "chassisname"), ("OMNITRON-MIB", "partnum"), ("OMNITRON-MIB", "serialnum"), ("OMNITRON-MIB", "manufdate"), ("OMNITRON-MIB", "softrev"), ("OMNITRON-MIB", "prodrev"), ("OMNITRON-MIB", "ledstat"), ("OMNITRON-MIB", "switchstat"), ("OMNITRON-MIB", "extended1"), ("OMNITRON-MIB", "extended2"), ("OMNITRON-MIB", "extended3"), ("OMNITRON-MIB", "extended4"), ("OMNITRON-MIB", "extended5"), ("OMNITRON-MIB", "extended6"), ("OMNITRON-MIB", "resetmod"), ("OMNITRON-MIB", "wrswitch"), ("OMNITRON-MIB", "modulename"), ("OMNITRON-MIB", "moduleCount"), ("OMNITRON-MIB", "modchassnum"), ("OMNITRON-MIB", "modslotnum"), ("OMNITRON-MIB", "modchasstype"), ("OMNITRON-MIB", "modprodtype"), ("OMNITRON-MIB", "modsoftrev"), ("OMNITRON-MIB", "modprodrev"), ("OMNITRON-MIB", "modreset"), ("OMNITRON-MIB", "modnumports"), ("OMNITRON-MIB", "modchassname"), ("OMNITRON-MIB", "modpartnum"), ("OMNITRON-MIB", "modserialnum"), ("OMNITRON-MIB", "modmanufdate"), ("OMNITRON-MIB", "modname"), ("OMNITRON-MIB", "modportvlan"), ("OMNITRON-MIB", "modextfeaturebits"), ("OMNITRON-MIB", "modswbuildnum"), ("OMNITRON-MIB", "modenable802dot1qProcessing"), ("OMNITRON-MIB", "modtagsubstitution"), ("OMNITRON-MIB", "modcommitVLANchanges"), ("OMNITRON-MIB", "modvlanTableClear"), ("OMNITRON-MIB", "modcommitNMMCfgChanges"), ("OMNITRON-MIB", "modLM80volts"), ("OMNITRON-MIB", "modLM80currents"), ("OMNITRON-MIB", "modLM80misc"), ("OMNITRON-MIB", "modRestoreFactoryDefaults"), ("OMNITRON-MIB", "sysAdminStatus"), ("OMNITRON-MIB", "sysDateTime"), ("OMNITRON-MIB", "macAddr"), ("OMNITRON-MIB", "ipAddr"), ("OMNITRON-MIB", "subnetmask"), ("OMNITRON-MIB", "gateway"), ("OMNITRON-MIB", "readCommunity"), ("OMNITRON-MIB", "writeCommunity"), ("OMNITRON-MIB", "mychassnum"), ("OMNITRON-MIB", "mmname"), ("OMNITRON-MIB", "traphost1"), ("OMNITRON-MIB", "traphost2"), ("OMNITRON-MIB", "traphost3"), ("OMNITRON-MIB", "traphost4"), ("OMNITRON-MIB", "traphost5"), ("OMNITRON-MIB", "traphost6"), ("OMNITRON-MIB", "traphost7"), ("OMNITRON-MIB", "traphost8"), ("OMNITRON-MIB", "sysloc"), ("OMNITRON-MIB", "syscon"), ("OMNITRON-MIB", "serialpass"), ("OMNITRON-MIB", "telnetpass"), ("OMNITRON-MIB", "ftppasswrd"), ("OMNITRON-MIB", "keepAliveInterval"), ("OMNITRON-MIB", "vlanIdOst"), ("OMNITRON-MIB", "nmmCfgSerialBaudrate"), ("OMNITRON-MIB", "enabledFunctions"), ("OMNITRON-MIB", "enableSNMPFunction"), ("OMNITRON-MIB", "nmmCfgState"), ("OMNITRON-MIB", "nmmSecureMode"), ("OMNITRON-MIB", "nmmSecureConnState"), ("OMNITRON-MIB", "nmmIpProtocolState"), ("OMNITRON-MIB", "nmmIpDisabled"), ("OMNITRON-MIB", "vlanPri"), ("OMNITRON-MIB", "enableSNMPWrites"), ("OMNITRON-MIB", "cpuVoltageIn"), ("OMNITRON-MIB", "cpuVoltageOut"), ("OMNITRON-MIB", "cpuTemperature"), ("OMNITRON-MIB", "nmmSecureSlaveSlot"), ("OMNITRON-MIB", "dhcpIpAddr"), ("OMNITRON-MIB", "dhcpSubnetmask"), ("OMNITRON-MIB", "dhcpGateway"), ("OMNITRON-MIB", "nmmOAMmgmtMode"), ("OMNITRON-MIB", "customertag"), ("OMNITRON-MIB", "servicetag"), ("OMNITRON-MIB", "cnodeControl"), ("OMNITRON-MIB", "cnodeCIR"), ("OMNITRON-MIB", "enableSNMPv3Function"), ("OMNITRON-MIB", "slaveWrite"), ("OMNITRON-MIB", "snmpTrapType"), ("OMNITRON-MIB", "capsMask"), ("OMNITRON-MIB", "slaveTraps"), ("OMNITRON-MIB", "slaveTrapsForward"), ("OMNITRON-MIB", "coreStatusOnly"), ("OMNITRON-MIB", "ingressPolicingType"), ("OMNITRON-MIB", "vlanservicetag"), ("OMNITRON-MIB", "defaultForwardingMap"), ("OMNITRON-MIB", "modFpgaRev"), ("OMNITRON-MIB", "modExpPartNumber"), ("OMNITRON-MIB", "modExpSoftwareRev"), ("OMNITRON-MIB", "modExpLedStatus"), ("OMNITRON-MIB", "modHwRev"), ("OMNITRON-MIB", "modPcbRev"), ("OMNITRON-MIB", "ipAddr2"), ("OMNITRON-MIB", "subnetmask2"), ("OMNITRON-MIB", "gateway2"), ("OMNITRON-MIB", "ipaddrEVCassociation"), ("OMNITRON-MIB", "ipaddr2EVCassociation"), ("OMNITRON-MIB", "bootpEnable"), ("OMNITRON-MIB", "tftpEnable"), ("OMNITRON-MIB", "tftpServerIpAddress"), ("OMNITRON-MIB", "dhcptftpServerIpAddress"), ("OMNITRON-MIB", "tftpFileName"), ("OMNITRON-MIB", "modeType"), ("OMNITRON-MIB", "dhcpPortNumber"), ("OMNITRON-MIB", "dhcpTagVid"), ("OMNITRON-MIB", "trapSrcIpSelect"), ("OMNITRON-MIB", "muxGroupDefaults"), ("OMNITRON-MIB", "portFwdCpu"), ("OMNITRON-MIB", "portFwdCpuList"), ("OMNITRON-MIB", "portState"), ("OMNITRON-MIB", "portEgressRate"), ("OMNITRON-MIB", "portpriority"), ("OMNITRON-MIB", "portcanonicalformatIndicator"), ("OMNITRON-MIB", "portvlanidentifier"), ("OMNITRON-MIB", "portmlistcriteria"), ("OMNITRON-MIB", "portingresssecurity"), ("OMNITRON-MIB", "portegresspolicy"), ("OMNITRON-MIB", "portIngressRate"), ("OMNITRON-MIB", "portSpeed"), ("OMNITRON-MIB", "portUnidirectionalAhOamEnable"), ("OMNITRON-MIB", "portIngressRateDropOrPause"), ("OMNITRON-MIB", "portIngressRateCBS"), ("OMNITRON-MIB", "portL2CPmgntProcessing"), ("OMNITRON-MIB", "portEgressQosPolicy"), ("OMNITRON-MIB", "portAccessType"), ("OMNITRON-MIB", "portStatsClear"), ("OMNITRON-MIB", "portLinkState"), ("OMNITRON-MIB", "portDuplex"), ("OMNITRON-MIB", "portMacAddress"), ("OMNITRON-MIB", "txOctets"), ("OMNITRON-MIB", "txDropPkts"), ("OMNITRON-MIB", "txBroadcastPkts"), ("OMNITRON-MIB", "txMulticastPkts"), ("OMNITRON-MIB", "txUnicastPkts"), ("OMNITRON-MIB", "txGoodPkts"), ("OMNITRON-MIB", "txErrorPkts"), ("OMNITRON-MIB", "txPausePkts"), ("OMNITRON-MIB", "txCollisions"), ("OMNITRON-MIB", "txSingleCollision"), ("OMNITRON-MIB", "txMultipleCollision"), ("OMNITRON-MIB", "txDeferedTransmit"), ("OMNITRON-MIB", "txLateCollision"), ("OMNITRON-MIB", "txExcessiveCollision"), ("OMNITRON-MIB", "txDroppedEvents"), ("OMNITRON-MIB", "rxOctets"), ("OMNITRON-MIB", "rxDropPkts"), ("OMNITRON-MIB", "rxBroadcastPkts"), ("OMNITRON-MIB", "rxMulticastPkts"), ("OMNITRON-MIB", "rxUnicastPkts"), ("OMNITRON-MIB", "rxGoodPkts"), ("OMNITRON-MIB", "rxTotalPkts"), ("OMNITRON-MIB", "rxErrorPkts"), ("OMNITRON-MIB", "rxPausePkts"), ("OMNITRON-MIB", "rxUndersizePkts"), ("OMNITRON-MIB", "rxOversizePkts"), ("OMNITRON-MIB", "rxFragments"), ("OMNITRON-MIB", "rxJabbers"), ("OMNITRON-MIB", "rxAlignmentErrors"), ("OMNITRON-MIB", "rxFCSErrors"), ("OMNITRON-MIB", "rxSymbolErrors"), ("OMNITRON-MIB", "rxCRCAlignErrors"), ("OMNITRON-MIB", "rxPackets64"), ("OMNITRON-MIB", "rxPackets65to127"), ("OMNITRON-MIB", "rxPackets128to255"), ("OMNITRON-MIB", "rxPackets256to511"), ("OMNITRON-MIB", "rxPackets512to1023"), ("OMNITRON-MIB", "rxPackets1024to1518"), ("OMNITRON-MIB", "txOctets64"), ("OMNITRON-MIB", "rxOctets64"), ("OMNITRON-MIB", "validityflag"), ("OMNITRON-MIB", "vlanidentifier"), ("OMNITRON-MIB", "port1Membership"), ("OMNITRON-MIB", "port2Membership"), ("OMNITRON-MIB", "port3Membership"), ("OMNITRON-MIB", "port4Membership"), ("OMNITRON-MIB", "port5Membership"), ("OMNITRON-MIB", "port6Membership"), ("OMNITRON-MIB", "ahEnabled"), ("OMNITRON-MIB", "ahLpbkMode"), ("OMNITRON-MIB", "ahLocalMode"), ("OMNITRON-MIB", "ahRemoteMode"), ("OMNITRON-MIB", "ahLocalMuxState"), ("OMNITRON-MIB", "ahRemoteMuxState"), ("OMNITRON-MIB", "ahLocalParserState"), ("OMNITRON-MIB", "ahRemoteParserState"), ("OMNITRON-MIB", "ahLocalSupportVar"), ("OMNITRON-MIB", "ahLocalLinkFlags"), ("OMNITRON-MIB", "ahLocalLpbkTimeout"), ("OMNITRON-MIB", "ahRemoteSupportVar"), ("OMNITRON-MIB", "ahRemoteLinkFlags"), ("OMNITRON-MIB", "ahRemoteLpbkTimeout"), ("OMNITRON-MIB", "ahLocalOUI"), ("OMNITRON-MIB", "ahRemoteOUI"), ("OMNITRON-MIB", "ahErroredSymbolPeriodWindow"), ("OMNITRON-MIB", "ahErroredSymbolPeriodThreshold"), ("OMNITRON-MIB", "ahErroredFrameWindow"), ("OMNITRON-MIB", "ahErroredFrameThreshold"), ("OMNITRON-MIB", "ahErroredFramePeriodWindow"), ("OMNITRON-MIB", "ahErroredFramePeriodThreshold"), ("OMNITRON-MIB", "ahErroredFrameSecondsWindow"), ("OMNITRON-MIB", "ahErroredFrameSecondsThreshold"), ("OMNITRON-MIB", "ahRemoteLinkPort"), ("OMNITRON-MIB", "ahSymbolErrorRunningTotal"), ("OMNITRON-MIB", "ahSymbolErrorEventTotal"), ("OMNITRON-MIB", "ahFrameErrorRunningTotal"), ("OMNITRON-MIB", "ahFrameErrorEventTotal"), ("OMNITRON-MIB", "ahFramePeriodRunningTotal"), ("OMNITRON-MIB", "ahFramePeriodEventTotal"), ("OMNITRON-MIB", "ahFrameSecondsSummaryRunningTotal"), ("OMNITRON-MIB", "ahFrameSecondsSummaryEventTotal"), ("OMNITRON-MIB", "ahClearStatistics"), ("OMNITRON-MIB", "ahTransmissionRate"), ("OMNITRON-MIB", "ahCriticalEventMode"), ("OMNITRON-MIB", "ahCriticalEventTrapList"), ("OMNITRON-MIB", "snmpv3UserName"), ("OMNITRON-MIB", "snmpv3SecurityLevel"), ("OMNITRON-MIB", "snmpv3AuthPassword"), ("OMNITRON-MIB", "snmpv3PrivPassword"), ("OMNITRON-MIB", "snmpv3UserType"), ("OMNITRON-MIB", "ostProtocolStatusType"), ("OMNITRON-MIB", "ostProtocolStatusState"), ("OMNITRON-MIB", "ostProtocoManagementPort"), ("OMNITRON-MIB", "ostProtocolStatusIpAddress"), ("OMNITRON-MIB", "ostProtocolStatusSessionOpenLockTime"), ("OMNITRON-MIB", "ostEnvironmentalPs1Status"), ("OMNITRON-MIB", "ostEnvironmentalPs1VoltageIn"), ("OMNITRON-MIB", "ostEnvironmentalPs1VoltageOut"), ("OMNITRON-MIB", "ostEnvironmentalPs1CurrentOut"), ("OMNITRON-MIB", "ostEnvironmentalPs2Status"), ("OMNITRON-MIB", "ostEnvironmentalPs2VoltageIn"), ("OMNITRON-MIB", "ostEnvironmentalPs2VoltageOut"), ("OMNITRON-MIB", "ostEnvironmentalPs2CurrentOut"), ("OMNITRON-MIB", "ostEnvironmentalTemperature"), ("OMNITRON-MIB", "ostEnvironmentalFan1Status"), ("OMNITRON-MIB", "ostEnvironmentalFan1Speed")], [("OMNITRON-MIB", "ostEnvironmentalFan2Status"), ("OMNITRON-MIB", "ostEnvironmentalFan2Speed"), ("OMNITRON-MIB", "ostEnvironmentalFan3Status"), ("OMNITRON-MIB", "ostEnvironmentalFan3Speed")]]:
    if getattr(mibBuilder, 'version', 0) < (4, 4, 2):
        # WARNING: leading objects get lost here!
        omnitronGroup = omnitronGroup.setObjects(*_omnitronGroup_obj)
    else:
        omnitronGroup = omnitronGroup.setObjects(*_omnitronGroup_obj, **dict(append=True))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronGroup = omnitronGroup.setStatus('current')
if mibBuilder.loadTexts: omnitronGroup.setDescription('A collection of Omnitron objects.')
omnitronSFPGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 7342, 4, 2, 2)).setObjects(("OMNITRON-MIB", "portSFPstatus"), ("OMNITRON-MIB", "portSFPpageA0"), ("OMNITRON-MIB", "portSFPpageA2"), ("OMNITRON-MIB", "portSfpBitRate"), ("OMNITRON-MIB", "portSfpVendorName"), ("OMNITRON-MIB", "portSfpVendorPartNumber"), ("OMNITRON-MIB", "portSfpVendorSerialNumber"), ("OMNITRON-MIB", "portSfpDateCode"), ("OMNITRON-MIB", "portSfpTemperature"), ("OMNITRON-MIB", "portSfpVcc"), ("OMNITRON-MIB", "portSfpBiasCurrent"), ("OMNITRON-MIB", "portSfpTxPower"), ("OMNITRON-MIB", "portSfpRxPower"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    omnitronSFPGroup = omnitronSFPGroup.setStatus('current')
if mibBuilder.loadTexts: omnitronSFPGroup.setDescription('A collection of Omnitron port SFP objects.')
mibBuilder.exportSymbols("OMNITRON-MIB", traphost7=traphost7, ahErroredFramePeriodWindow=ahErroredFramePeriodWindow, ahRemoteMode=ahRemoteMode, vlanservicetag=vlanservicetag, ahSymbolErrorRunningTotal=ahSymbolErrorRunningTotal, rxPausePkts=rxPausePkts, chassisEntry=chassisEntry, moduleVLANTable=moduleVLANTable, prodrev=prodrev, extended3=extended3, ahRemoteLinkFlags=ahRemoteLinkFlags, modtagsubstitution=modtagsubstitution, portFwdCpu=portFwdCpu, portSfpDateCode=portSfpDateCode, ostEnvironmentalFan1Speed=ostEnvironmentalFan1Speed, modFpgaRev=modFpgaRev, ipaddrEVCassociation=ipaddrEVCassociation, rxMulticastPkts=rxMulticastPkts, servicetag=servicetag, ahFrameSecondsSummaryRunningTotal=ahFrameSecondsSummaryRunningTotal, portSFPTable=portSFPTable, portSFPEntry=portSFPEntry, rxPackets128to255=rxPackets128to255, sysAdminStatus=sysAdminStatus, ahLocalMode=ahLocalMode, ostEnvironmentalStatusEntry=ostEnvironmentalStatusEntry, ahCriticalEventTrapList=ahCriticalEventTrapList, ostEnvironmentalFan3Status=ostEnvironmentalFan3Status, ostEnvironmentalFan3Speed=ostEnvironmentalFan3Speed, portSfpBitRate=portSfpBitRate, portSFPpageA0=portSFPpageA0, snmpTrapType=snmpTrapType, ahFrameErrorRunningTotal=ahFrameErrorRunningTotal, macAddr=macAddr, modchassname=modchassname, rxCRCAlignErrors=rxCRCAlignErrors, ahFrameSecondsSummaryEventTotal=ahFrameSecondsSummaryEventTotal, traphost5=traphost5, rxPackets512to1023=rxPackets512to1023, coreStatusOnly=coreStatusOnly, cnodeCIR=cnodeCIR, dhcptftpServerIpAddress=dhcptftpServerIpAddress, moduleMgtCfgEntry=moduleMgtCfgEntry, selfSlot=selfSlot, modLM80volts=modLM80volts, portSFPstatus=portSFPstatus, txErrorPkts=txErrorPkts, ahTransmissionRate=ahTransmissionRate, rxFCSErrors=rxFCSErrors, ahFramePeriodRunningTotal=ahFramePeriodRunningTotal, rxPackets1024to1518=rxPackets1024to1518, ahLocalSupportVar=ahLocalSupportVar, traphost1=traphost1, snmpv3PrivPassword=snmpv3PrivPassword, portcanonicalformatIndicator=portcanonicalformatIndicator, ipaddr2EVCassociation=ipaddr2EVCassociation, nmmCfgState=nmmCfgState, moduleMgtCfgTable=moduleMgtCfgTable, portMacAddress=portMacAddress, omnitronGroup=omnitronGroup, portStatsEntry=portStatsEntry, portAHEntry=portAHEntry, chassistype=chassistype, chassisTable=chassisTable, omnitronProducts=omnitronProducts, rxFragments=rxFragments, chassisname=chassisname, cpuVoltageOut=cpuVoltageOut, portStatsClear=portStatsClear, dhcpTagVid=dhcpTagVid, portSFPpageA2=portSFPpageA2, ahErroredSymbolPeriodThreshold=ahErroredSymbolPeriodThreshold, extended4=extended4, portSfpVendorSerialNumber=portSfpVendorSerialNumber, moduleEntry=moduleEntry, modeType=modeType, nmmIpDisabled=nmmIpDisabled, sysDateTime=sysDateTime, traphost2=traphost2, enableSNMPv3Function=enableSNMPv3Function, rxDropPkts=rxDropPkts, partnum=partnum, nmmCfgSerialBaudrate=nmmCfgSerialBaudrate, modLM80currents=modLM80currents, modenable802dot1qProcessing=modenable802dot1qProcessing, modswbuildnum=modswbuildnum, subnetmask2=subnetmask2, portUnidirectionalAhOamEnable=portUnidirectionalAhOamEnable, switchstat=switchstat, modExpPartNumber=modExpPartNumber, defaultForwardingMap=defaultForwardingMap, chassis=chassis, ostEnvironmentalStatusTable=ostEnvironmentalStatusTable, muxGroupDefaults=muxGroupDefaults, rxOctets=rxOctets, portIngressRateCBS=portIngressRateCBS, ahLocalOUI=ahLocalOUI, tftpFileName=tftpFileName, port2Membership=port2Membership, ostProtocolStatusEntry=ostProtocolStatusEntry, modcommitNMMCfgChanges=modcommitNMMCfgChanges, txSingleCollision=txSingleCollision, modRestoreFactoryDefaults=modRestoreFactoryDefaults, ostProtocolStatusState=ostProtocolStatusState, customertag=customertag, rxAlignmentErrors=rxAlignmentErrors, userIndex=userIndex, vlanPri=vlanPri, modvlanTableClear=modvlanTableClear, nmmSecureConnState=nmmSecureConnState, portSfpTxPower=portSfpTxPower, txBroadcastPkts=txBroadcastPkts, sysloc=sysloc, ahErroredFrameSecondsWindow=ahErroredFrameSecondsWindow, slotnum=slotnum, port4Membership=port4Membership, omnitronCompliance=omnitronCompliance, moduleVLANEntry=moduleVLANEntry, portIngressRate=portIngressRate, txOctets=txOctets, ahRemoteLpbkTimeout=ahRemoteLpbkTimeout, portSfpVendorName=portSfpVendorName, port5Membership=port5Membership, writeCommunity=writeCommunity, bootpEnable=bootpEnable, txOctets64=txOctets64, omnitronMIB=omnitronMIB, vlanIdOst=vlanIdOst, dhcpGateway=dhcpGateway, cnodeControl=cnodeControl, modnumports=modnumports, mychassnum=mychassnum, rxErrorPkts=rxErrorPkts, ostEnvironmentalFan1Status=ostEnvironmentalFan1Status, softrev=softrev, txDeferedTransmit=txDeferedTransmit, ostEnvironmentalFan2Status=ostEnvironmentalFan2Status, rxTotalPkts=rxTotalPkts, ostEnvironmentalPs1CurrentOut=ostEnvironmentalPs1CurrentOut, ostEnvironmentalPs1VoltageOut=ostEnvironmentalPs1VoltageOut, traphost4=traphost4, vlanidentifier=vlanidentifier, ahLocalParserState=ahLocalParserState, ahRemoteSupportVar=ahRemoteSupportVar, modextfeaturebits=modextfeaturebits, ingressPolicingType=ingressPolicingType, portFwdCpuList=portFwdCpuList, slaveWrite=slaveWrite, nmmIpProtocolState=nmmIpProtocolState, extended6=extended6, resetmod=resetmod, modname=modname, portegresspolicy=portegresspolicy, modreset=modreset, traphost8=traphost8, slaveTrapsForward=slaveTrapsForward, ahLocalLinkFlags=ahLocalLinkFlags, ftppasswrd=ftppasswrd, modHwRev=modHwRev, portSfpRxPower=portSfpRxPower, rxUndersizePkts=rxUndersizePkts, keepAliveInterval=keepAliveInterval, rxJabbers=rxJabbers, snmpv3UserType=snmpv3UserType, ahFrameErrorEventTotal=ahFrameErrorEventTotal, mmname=mmname, ostEnvironmentalPs1Status=ostEnvironmentalPs1Status, wrswitch=wrswitch, portLinkState=portLinkState, nmmSecureMode=nmmSecureMode, extended1=extended1, ahLocalLpbkTimeout=ahLocalLpbkTimeout, portSfpTemperature=portSfpTemperature, nmmOAMmgmtMode=nmmOAMmgmtMode, enableSNMPWrites=enableSNMPWrites, rxPackets256to511=rxPackets256to511, rxSymbolErrors=rxSymbolErrors, userEntry=userEntry, modchassnum=modchassnum, ahRemoteOUI=ahRemoteOUI, ostProtocolStatusIndex=ostProtocolStatusIndex, serialnum=serialnum, nmmSecureSlaveSlot=nmmSecureSlaveSlot, portStatsTable=portStatsTable, trapSrcIpSelect=trapSrcIpSelect, managementModule=managementModule, portEgressRate=portEgressRate, tftpServerIpAddress=tftpServerIpAddress, ostEnvironmentalPs2VoltageOut=ostEnvironmentalPs2VoltageOut, ahSymbolErrorEventTotal=ahSymbolErrorEventTotal, ostEnvironmentalFan2Speed=ostEnvironmentalFan2Speed, portSfpBiasCurrent=portSfpBiasCurrent, ledstat=ledstat, omnitronCompliances=omnitronCompliances, ahErroredFramePeriodThreshold=ahErroredFramePeriodThreshold, ostEnvironmentalPs2VoltageIn=ostEnvironmentalPs2VoltageIn, modPcbRev=modPcbRev, traphost6=traphost6, ostProtocolStatusIpAddress=ostProtocolStatusIpAddress, ahRemoteMuxState=ahRemoteMuxState, ahCriticalEventMode=ahCriticalEventMode, portingresssecurity=portingresssecurity, txCollisions=txCollisions, prodtype=prodtype, port1Membership=port1Membership, modcommitVLANchanges=modcommitVLANchanges, ostProtocolStatusSessionOpenLockTime=ostProtocolStatusSessionOpenLockTime, index=index, modprodtype=modprodtype, userTable=userTable, ahRemoteParserState=ahRemoteParserState, ostEnvironmentalTemperature=ostEnvironmentalTemperature, txGoodPkts=txGoodPkts, ostProtocolStatusType=ostProtocolStatusType, modchasstype=modchasstype, portmlistcriteria=portmlistcriteria, portL2CPmgntProcessing=portL2CPmgntProcessing, snmpv3AuthPassword=snmpv3AuthPassword, extended5=extended5, slaveTraps=slaveTraps, rxPackets65to127=rxPackets65to127, prodAgent=prodAgent, portpriority=portpriority, modprodrev=modprodrev, portnum=portnum, ahErroredFrameSecondsThreshold=ahErroredFrameSecondsThreshold, modExpLedStatus=modExpLedStatus, txExcessiveCollision=txExcessiveCollision, ahRemoteLinkPort=ahRemoteLinkPort, portIngressRateDropOrPause=portIngressRateDropOrPause, rxPackets64=rxPackets64, portAHTable=portAHTable, moduleTable=moduleTable, chassisnum=chassisnum, rxUnicastPkts=rxUnicastPkts, txMultipleCollision=txMultipleCollision, portSpeed=portSpeed, subnetmask=subnetmask, txPausePkts=txPausePkts, ahFramePeriodEventTotal=ahFramePeriodEventTotal, ahErroredFrameWindow=ahErroredFrameWindow, rxOversizePkts=rxOversizePkts, PYSNMP_MODULE_ID=omnitronMIB, cpuVoltageIn=cpuVoltageIn, portDuplex=portDuplex, txLateCollision=txLateCollision, modulePortsTable=modulePortsTable, gateway2=gateway2, port6Membership=port6Membership, portvlanidentifier=portvlanidentifier, modulename=modulename, ahClearStatistics=ahClearStatistics, port3Membership=port3Membership, modpartnum=modpartnum)
mibBuilder.exportSymbols("OMNITRON-MIB", portAccessType=portAccessType, txDropPkts=txDropPkts, ahLpbkMode=ahLpbkMode, ostEnvironmentalPs2Status=ostEnvironmentalPs2Status, ostEnvironmentalPs2CurrentOut=ostEnvironmentalPs2CurrentOut, snmpv3UserName=snmpv3UserName, serialpass=serialpass, ipAddr2=ipAddr2, ahEnabled=ahEnabled, modLM80misc=modLM80misc, txUnicastPkts=txUnicastPkts, omnitronGroups=omnitronGroups, ahErroredSymbolPeriodWindow=ahErroredSymbolPeriodWindow, rxGoodPkts=rxGoodPkts, rxOctets64=rxOctets64, traphost3=traphost3, modulePortsEntry=modulePortsEntry, omnitronSFPGroup=omnitronSFPGroup, capsMask=capsMask, readCommunity=readCommunity, ostEnvironmentalPs1VoltageIn=ostEnvironmentalPs1VoltageIn, moduleCount=moduleCount, portSfpVcc=portSfpVcc, omnitronConformance=omnitronConformance, modmanufdate=modmanufdate, portSfpVendorPartNumber=portSfpVendorPartNumber, rxBroadcastPkts=rxBroadcastPkts, tftpEnable=tftpEnable, dhcpSubnetmask=dhcpSubnetmask, gateway=gateway, ahLocalMuxState=ahLocalMuxState, dhcpPortNumber=dhcpPortNumber, enableSNMPFunction=enableSNMPFunction, txMulticastPkts=txMulticastPkts, manufdate=manufdate, modportvlan=modportvlan, modExpSoftwareRev=modExpSoftwareRev, telnetpass=telnetpass, dhcpIpAddr=dhcpIpAddr, syscon=syscon, txDroppedEvents=txDroppedEvents, extended2=extended2, snmpv3SecurityLevel=snmpv3SecurityLevel, modslotnum=modslotnum, ahErroredFrameThreshold=ahErroredFrameThreshold, enabledFunctions=enabledFunctions, ostProtocolStatusTable=ostProtocolStatusTable, portEgressQosPolicy=portEgressQosPolicy, modsoftrev=modsoftrev, cpuTemperature=cpuTemperature, validityflag=validityflag, enhancedchassisTable=enhancedchassisTable, ostProtocoManagementPort=ostProtocoManagementPort, portState=portState, ipAddr=ipAddr, modserialnum=modserialnum)
