#
# PySNMP MIB module RADLAN-TIMESYNCHRONIZATION-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/radlan/RADLAN-TIMESYNCHRONIZATION-MIB
# Produced by pysmi-1.1.12 at Mon Jun  3 03:08:17 2024
# On host fv-az736-440 platform Linux version 6.5.0-1021-azure by user runner
# Using Python version 3.10.14 (main, May  8 2024, 15:05:35) [GCC 11.4.0]
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
TruthValue, = mibBuilder.importSymbols("RADLAN-SNMPv2", "TruthValue")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter64, iso, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, ModuleIdentity, MibIdentifier, TimeTicks, NotificationType, Gauge32, Bits, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter64", "iso", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "ModuleIdentity", "MibIdentifier", "TimeTicks", "NotificationType", "Gauge32", "Bits", "IpAddress")
RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TextualConvention")
DisplayString, = mibBuilder.importSymbols("SNMPv2-TC-v1", "DisplayString")
rlTimeSynchronization = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 92))
rlTimeSynchronization.setRevisions(('2003-11-23 00:24',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlTimeSynchronization.setRevisionsDescriptions(('Initial revision',))
if mibBuilder.loadTexts: rlTimeSynchronization.setLastUpdated('200408030024Z')
if mibBuilder.loadTexts: rlTimeSynchronization.setOrganization('Radlan Computer Communication Ltd.')
if mibBuilder.loadTexts: rlTimeSynchronization.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlTimeSynchronization.setDescription('The MIB module describes the private MIB for SNTP & TIME definitions.')
rlTimeSyncMethodMode = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92, 1))
rlSntpNtpClient = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92, 2))
rlSntpNtpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92, 2, 1))
rlSntpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92, 2, 2))
rlNtpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 92, 2, 3))
class NTPTimeStamp(TextualConvention, OctetString):
    reference = "D.L. Mills, 'Network Time Protocol (Version 3)',\n                      RFC-1305, March 1992, Section 3.1"
    description = 'NTP timestamps are represented as a 64-bit\n                      unsigned fixed-point number, in seconds relative to\n                      00:00 on 1 January 1900.  The integer part is in the\n                      first 32 bits and the fraction part is in the last\n                      32 bits.'
    status = 'current'
    displayHint = '4d.4d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class NTPSignedTimeValue(TextualConvention, OctetString):
    description = 'The time in seconds that could represent signed\n                      quantities like time delay with respect to some\n                      source.  This textual-convention is specific to RADLAN\n                      implementation of NTP where 32-bit integers are used\n                      for such quantities.  The signed integer part is in\n                      the first 16 bits and the fraction part is in the\n                      last 16 bits.'
    status = 'current'
    displayHint = '2d.2d'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

class NTPStratum(TextualConvention, Integer32):
    reference = "D.L. Mills, 'Network Time Protocol (Version 3)',\n                      RFC-1305, March 1992, Section 2.2"
    description = 'Indicates the stratum of the clock.  The stratum\n                      defines the accuracy of a time server.  Higher the\n                      stratum, lower the accuracy.\n                      0, unspecified\n                      1, primary reference (e.g., calibrated atomic clock,\n                         radio clock)\n                      2-255, secondary reference (via NTP)'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

rlTimeSyncMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTimeSyncMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlTimeSyncMibVersion.setDescription('TimeSync Mib Version.')
rndTimeSyncManagedTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedTime.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedTime.setDescription('The time will be sent in the format hhmmss')
rndTimeSyncManagedDate = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedDate.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedDate.setDescription('The date will be sent in the format ddmmyy')
rndTimeSyncManagedDateTime = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rndTimeSyncManagedDateTime.setStatus('current')
if mibBuilder.loadTexts: rndTimeSyncManagedDateTime.setDescription('The date and time will be sent in the format ddmmyyhhmmss')
rlTimeSyncMethod = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("sntp", 2), ("ntp", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeSyncMethod.setStatus('current')
if mibBuilder.loadTexts: rlTimeSyncMethod.setDescription('Method to be used for time synchronization in the device.')
rlTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZone.setStatus('current')
if mibBuilder.loadTexts: rlTimeZone.setDescription('Offset from Greenwich time (format [+/-]hh:mm).')
rlTimeZoneCode = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeZoneCode.setStatus('current')
if mibBuilder.loadTexts: rlTimeZoneCode.setDescription('Code definition for current TimeZone.')
rlDaylightSavingTimeMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("recurring", 1), ("date", 2), ("none", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeMode.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeMode.setDescription('Daylight Saving Time - Recurring/Date/None.')
rlDaylightSavingTimeStart = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeStart.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeStart.setDescription('Daylight Saving Time start date.\n                     In recurring mode: week wday month hh:mm\n                     In date mode:      month day year hh:mm\n                     week:  0-6  (0=First, 6=Last)\n                     wday:  1-7  (Sunday-Saturday)\n                     month: 1-12 (January-December)\n                     day:   1-31\n                     year:  0-99 (2000-2099)\n                     hh:    0-23 (hours)\n                     mm:    0-59 (minutes)')
rlDaylightSavingTimeEnd = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeEnd.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeEnd.setDescription('Daylight Saving Time end date.\n                     In recurring mode: week wday month hh:mm\n                     In date mode:      month day year hh:mm\n                     week:  0-6  (0=First, 6=Last)\n                     wday:  1-7  (Sunday-Saturday)\n                     month: 1-12 (January-December)\n                     day:   1-31\n                     year:  0-99 (2000-2099)\n                     hh:    0-23 (hours)\n                     mm:    0-59 (minutes)')
rlDaylightSavingTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 11), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeOffset.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeOffset.setDescription('Daylight Saving Time - The number of minutes to add to\n                     the clock during summer time.')
rlDaylightSavingTimeCode = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlDaylightSavingTimeCode.setStatus('current')
if mibBuilder.loadTexts: rlDaylightSavingTimeCode.setDescription('Code definition for current Daylight Saving Time.')
rlTZDSTOffset = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlTZDSTOffset.setStatus('current')
if mibBuilder.loadTexts: rlTZDSTOffset.setDescription('Local Time Zone and Daylight Saving Time offset\n                     in seconds.')
rlSntpNtpMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpMibVersion.setDescription('SntpNtp Mib Version.')
rlSntpNtpConfigMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("unicast", 2), ("anycast", 3), ("multicast", 4), ("unicastAnycast", 5), ("unicastMulticast", 6), ("anycastMulticast", 7), ("unicastAnycastMulticast", 8))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigMode.setDescription('Current configuration operational mode of SNTP/NTP client.')
rlSntpNtpConfigSysStratum = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSysStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSysStratum.setDescription('The stratum of the local clock. If the value is set\n                     to 1, i.e., this is a primary reference, then the\n                     Primary-Clock procedure described in Section 3.4.6,\n                     in RFC-1305 is invoked.')
rlSntpNtpConfigPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 4), Integer32().clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpNtpConfigPollInterval.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPollInterval.setDescription('Period of time (in seconds) between succesive attempts to\n                     perform an update via SNTP.')
rlSntpNtpConfigPrimaryPollSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvAddr.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvAddr.setDescription('Ip Address of a trusted SNTP server for polling.')
rlSntpNtpConfigPrimaryPollSrvMrid = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvMrid.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvMrid.setDescription('The mrid of the primary server.')
rlSntpNtpConfigPrimaryPollSrvIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvIfIndex.setDescription('The interface addressed of the primary server.')
rlSntpNtpConfigPrimaryPollSrvStratum = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 8), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigPrimaryPollSrvStratum.setDescription('The stratum of the primary polling server.')
rlSntpNtpConfigSyncSrvAddr = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvAddr.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvAddr.setDescription('Ip Address of the synced server.')
rlSntpNtpConfigSyncSrvMrid = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvMrid.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvMrid.setDescription('The mrid of the synced server.')
rlSntpNtpConfigSyncSrvIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvIfIndex.setDescription('The interface addressed of the synced server.')
rlSntpNtpConfigSyncSrvType = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("unicast", 2), ("anycast", 3), ("broadcast", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvType.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvType.setDescription('Synced server type.')
rlSntpNtpConfigSyncSrvStratum = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 13), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigSyncSrvStratum.setDescription('The stratum of the synced server.')
rlSntpNtpConfigRetryTimeout = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigRetryTimeout.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigRetryTimeout.setDescription('SNTP/NTP requests Retry Interval.')
rlSntpNtpConfigRetryCnt = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpNtpConfigRetryCnt.setStatus('current')
if mibBuilder.loadTexts: rlSntpNtpConfigRetryCnt.setDescription('SNTP/NTP requests Retry Count.')
rlSntpClientMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("active", 2), ("passive", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpClientMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpClientMode.setDescription('Current operational mode of SNTP client.')
rlSntpUnicastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpUnicastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpUnicastAdminState.setDescription('SNTP Unicast Administrative state - Enable/Disable SNTP.\n                     In case of reinitializing polling or time\n                     synchronization this MIB is modified. The MIB can\n                     be enabled even thought it is already enabled.')
rlSntpBroadcastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastAdminState.setDescription('SNTP Broadcast Administrative state - Enable/Disable SNTP.\n                     In case of reinitializing polling or time\n                     synchronization this MIB is modified. The MIB can\n                     be enabled even thought it is already enabled.')
rlSntpAnycastAdminState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastAdminState.setDescription('SNTP Anycast Administrative state - Enable/Disable SNTP.\n                     In case of reinitializing polling or time\n                     synchronization this MIB is modified. The MIB can\n                     be enabled even thought it is already enabled.')
rlSntpUnicastPollState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpUnicastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpUnicastPollState.setDescription('SNTP Unicast poll state - TRUE for polled.')
rlSntpBroadcastPollState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastPollState.setDescription('SNTP Broadcast poll state - TRUE for polled.')
rlSntpAnycastPollState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastPollState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastPollState.setDescription('SNTP Anycast poll state - TRUE for polled.')
rlSntpAuthenticationState = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationState.setDescription('SNTP authentication state- Enable/Disable SNTP.')
rlTimeValidFlag = MibScalar((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlTimeValidFlag.setStatus('current')
if mibBuilder.loadTexts: rlTimeValidFlag.setDescription('Is time valid.')
rlSntpConfigBroadcastTable = MibTable((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10), )
if mibBuilder.loadTexts: rlSntpConfigBroadcastTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigBroadcastTable.setDescription('A table containing broadcast mode information per\n                     interface.')
rlSntpBroadcastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1), ).setIndexNames((0, "RADLAN-TIMESYNCHRONIZATION-MIB", "rlSntpBroadcastIfIndex"))
if mibBuilder.loadTexts: rlSntpBroadcastEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastEntry.setDescription('Private paramters for interface:\n                     sntp status, broadcast mode.')
rlSntpBroadcastIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpBroadcastIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastIfIndex.setDescription('The interface addressed by this entry.')
rlSntpBroadcastIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastIfAdminState.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastIfAdminState.setDescription('SNTP interface Adminstrative state- Enable/Disable SNTP.\n                     In case of reinitializing polling or time\n                     synchronization this MIB is modified. The MIB can\n                     be enabled even thought it is already enabled.')
rlSntpBroadcastMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("receive", 2), ("send", 3), ("receiveSend", 4))).clone('receiveSend')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastMode.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastMode.setDescription('SNTP/NTP Broadcast Mode.\n                     none        - no broadcast SNTP packets are received or sent.\n                     Receive     - host only receive SNTP packets that were sent\n                                   to broadcast address (were not directed to\n                                   the host). This is multicast mode in the RFC.\n                     Send        - host only send SNTP packets and wait for replies\n                                   directed to the host. This is anycast mode in\n                                   the RFC.\n                     ReceiveSend - host receive broadcast messages (destination\n                                   is broadcast address in the received messages)\n                                   and send SNTP packets to wait for replies\n                                   directed to the host (destination address\n                                   of the reply is the host address). This mode\n                                   combines anycast and multicast modes in the\n                                   RFC.')
rlSntpBroadcastPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpBroadcastStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 6), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastStratum.setDescription('The stratum of this server.')
rlSntpBroadcastLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 7), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastLastResp.setDescription('SNTP Broadcast Last Response Time')
rlSntpBroadcastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastStatus.setDescription('The Operational State of the remote IP Address of\n                     the SNTP Broadcast.\n                     unknown     - requests were not sent yet.\n                     inProcess   - replies were not received yet.\n                     up          - server sent SNTP packets.\n                     down        - server stopped sending SNTP packets.')
rlSntpBroadcastOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 9), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastOffset.setDescription("The estimated offset of the server's clock relative to\n                 the local clock, in seconds.  The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpBroadcastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 10), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpBroadcastDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastDelay.setDescription("The estimated round-trip delay of the server's clock\n                 relative to the local clock over the network path\n                 between them, in seconds. The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpBroadcastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 10, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpBroadcastRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpBroadcastRowStatus.setDescription('The Status of this SNTP broadcast interface\n                     information.')
rlSntpConfigAnycastTable = MibTable((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11), )
if mibBuilder.loadTexts: rlSntpConfigAnycastTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigAnycastTable.setDescription('A table containing anycast information per\n                     interface.')
rlSntpAnycastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1), ).setIndexNames((0, "RADLAN-TIMESYNCHRONIZATION-MIB", "rlSntpAnycastIfIndex"))
if mibBuilder.loadTexts: rlSntpAnycastEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastEntry.setDescription('Private paramters for interface:\n                     server info.')
rlSntpAnycastIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 1), Integer32())
if mibBuilder.loadTexts: rlSntpAnycastIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastIfIndex.setDescription('The interface addressed by this entry.')
rlSntpAnycastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpAnycastStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastStratum.setDescription('The stratum of this server.')
rlSntpAnycastLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 4), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastLastResp.setDescription('SNTP Anycast Last Response Time')
rlSntpAnycastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastStatus.setDescription('The Operational State of the remote IP Address of\n                     the SNTP Anycast.\n                     unknown     - requests were not sent yet.\n                     inProcess   - replies were not received yet.\n                     up          - server sent SNTP packets.\n                     down        - server stopped sending SNTP packets.')
rlSntpAnycastOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 6), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastOffset.setDescription("The estimated offset of the server's clock relative to\n                 the local clock, in seconds.  The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpAnycastDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 7), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpAnycastDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastDelay.setDescription("The estimated round-trip delay of the server's clock\n                 relative to the local clock over the network path\n                 between them, in seconds. The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpAnycastRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 11, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAnycastRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAnycastRowStatus.setDescription('The Status of this SNTP anycast interface\n                     information.')
rlSntpConfigServerTable = MibTable((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12), )
if mibBuilder.loadTexts: rlSntpConfigServerTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigServerTable.setDescription('A table containing trusted SNTP servers to be queried in\n                     unicast or broadcast mode.')
rlSntpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1), ).setIndexNames((0, "RADLAN-TIMESYNCHRONIZATION-MIB", "rlSntpServerAddress"))
if mibBuilder.loadTexts: rlSntpServerEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerEntry.setDescription('A trusted server.')
rlSntpServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 1), IpAddress())
if mibBuilder.loadTexts: rlSntpServerAddress.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerAddress.setDescription('Ip Address of a trusted SNTP server.')
rlSntpServerPolled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerPolled.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerPolled.setDescription('TRUE if participating in polling cycle, else FALSE.')
rlSntpServerStratum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 3), NTPStratum()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerStratum.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerStratum.setDescription('The stratum of this server.')
rlSntpServerLastResp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 4), NTPTimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerLastResp.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerLastResp.setDescription('SNTP Server Last Response Time')
rlSntpServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("inProcess", 2), ("up", 3), ("down", 4))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServerStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerStatus.setDescription('The Operational State of the remote IP Address of\n                     the SNTP Server.\n                     unknown     - requests were not sent yet.\n                     inProcess   - replies were not received yet.\n                     up          - server sent SNTP packets.\n                     down        - server stopped sending SNTP packets.')
rlSntpServersOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 6), NTPTimeStamp()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServersOffset.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersOffset.setDescription("The estimated offset of the server's clock relative to\n                 the local clock, in seconds.  The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpServersDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 7), NTPSignedTimeValue()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSntpServersDelay.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersDelay.setDescription("The estimated round-trip delay of the server's clock\n                 relative to the local clock over the network path\n                 between them, in seconds. The host determines the\n                 value of this object using the algorithm described in\n                 RFC 2030.")
rlSntpServersKeyIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServersKeyIdentifier.setStatus('current')
if mibBuilder.loadTexts: rlSntpServersKeyIdentifier.setDescription('Authentication key identifier. The valid range is\n                     1-4294967295.\n                     Value zero, means no authentication is being done.')
rlSntpServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 12, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpServerRowStatus.setDescription('The Status of this SNTP server information.')
rlSntpConfigAuthenticationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13), )
if mibBuilder.loadTexts: rlSntpConfigAuthenticationTable.setStatus('current')
if mibBuilder.loadTexts: rlSntpConfigAuthenticationTable.setDescription('A table authentication keys.')
rlSntpAuthenticationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13, 1), ).setIndexNames((0, "RADLAN-TIMESYNCHRONIZATION-MIB", "rlSntpAuthenticationKeyID"))
if mibBuilder.loadTexts: rlSntpAuthenticationEntry.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationEntry.setDescription('Keys information for authenticationof NTP packets.')
rlSntpAuthenticationKeyID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyID.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyID.setDescription('The key identifier. Valid rabge for key identifier\n                     is 1-4294967295.')
rlSntpAuthenticationKeyValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyValue.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyValue.setDescription('Key value.')
rlSntpAuthenticationKeyState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationKeyState.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationKeyState.setDescription('Authentication key state - Enable/Disable key.')
rlSntpAuthenticationRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 92, 2, 2, 13, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSntpAuthenticationRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlSntpAuthenticationRowStatus.setDescription('The Status of this Authentication key information.')
mibBuilder.exportSymbols("RADLAN-TIMESYNCHRONIZATION-MIB", rndTimeSyncManagedTime=rndTimeSyncManagedTime, rlSntpAuthenticationKeyID=rlSntpAuthenticationKeyID, rlSntpAuthenticationRowStatus=rlSntpAuthenticationRowStatus, rlSntpNtpConfigRetryTimeout=rlSntpNtpConfigRetryTimeout, rlSntpConfig=rlSntpConfig, rlSntpNtpConfigPrimaryPollSrvMrid=rlSntpNtpConfigPrimaryPollSrvMrid, rlSntpAuthenticationKeyValue=rlSntpAuthenticationKeyValue, rlSntpAnycastStatus=rlSntpAnycastStatus, rlSntpBroadcastAdminState=rlSntpBroadcastAdminState, rlSntpBroadcastMode=rlSntpBroadcastMode, rlSntpNtpConfigPrimaryPollSrvIfIndex=rlSntpNtpConfigPrimaryPollSrvIfIndex, rlTimeZone=rlTimeZone, rlSntpAnycastAdminState=rlSntpAnycastAdminState, rlSntpNtpConfigRetryCnt=rlSntpNtpConfigRetryCnt, rlSntpAnycastPollState=rlSntpAnycastPollState, rlSntpServersOffset=rlSntpServersOffset, rlSntpAnycastDelay=rlSntpAnycastDelay, NTPTimeStamp=NTPTimeStamp, rlSntpNtpConfigSyncSrvType=rlSntpNtpConfigSyncSrvType, rlSntpBroadcastPollState=rlSntpBroadcastPollState, rlSntpNtpConfigSyncSrvStratum=rlSntpNtpConfigSyncSrvStratum, rlDaylightSavingTimeStart=rlDaylightSavingTimeStart, rlSntpBroadcastStatus=rlSntpBroadcastStatus, rlSntpNtpConfigPrimaryPollSrvStratum=rlSntpNtpConfigPrimaryPollSrvStratum, rlSntpAuthenticationState=rlSntpAuthenticationState, rlSntpServerPolled=rlSntpServerPolled, rlDaylightSavingTimeMode=rlDaylightSavingTimeMode, rlSntpServerEntry=rlSntpServerEntry, rlSntpNtpConfigMode=rlSntpNtpConfigMode, rlSntpBroadcastRowStatus=rlSntpBroadcastRowStatus, rlNtpConfig=rlNtpConfig, rndTimeSyncManagedDate=rndTimeSyncManagedDate, rlSntpServerRowStatus=rlSntpServerRowStatus, rlSntpBroadcastEntry=rlSntpBroadcastEntry, rlDaylightSavingTimeCode=rlDaylightSavingTimeCode, PYSNMP_MODULE_ID=rlTimeSynchronization, rlSntpUnicastPollState=rlSntpUnicastPollState, rlSntpConfigBroadcastTable=rlSntpConfigBroadcastTable, rlSntpAnycastAddress=rlSntpAnycastAddress, rlDaylightSavingTimeEnd=rlDaylightSavingTimeEnd, rlSntpServerLastResp=rlSntpServerLastResp, rlSntpClientMode=rlSntpClientMode, rlSntpAnycastEntry=rlSntpAnycastEntry, rlDaylightSavingTimeOffset=rlDaylightSavingTimeOffset, rlSntpServersDelay=rlSntpServersDelay, rlSntpNtpClient=rlSntpNtpClient, rlTimeSyncMibVersion=rlTimeSyncMibVersion, rlSntpBroadcastIfAdminState=rlSntpBroadcastIfAdminState, rlSntpBroadcastDelay=rlSntpBroadcastDelay, rlSntpConfigAnycastTable=rlSntpConfigAnycastTable, rlSntpAnycastStratum=rlSntpAnycastStratum, rlSntpNtpConfigPollInterval=rlSntpNtpConfigPollInterval, rlSntpAnycastOffset=rlSntpAnycastOffset, rlSntpBroadcastIfIndex=rlSntpBroadcastIfIndex, rlSntpBroadcastPolled=rlSntpBroadcastPolled, rlSntpBroadcastLastResp=rlSntpBroadcastLastResp, rlSntpServerStratum=rlSntpServerStratum, rlSntpServersKeyIdentifier=rlSntpServersKeyIdentifier, rlSntpServerStatus=rlSntpServerStatus, rlSntpAuthenticationKeyState=rlSntpAuthenticationKeyState, NTPSignedTimeValue=NTPSignedTimeValue, rlSntpAnycastIfIndex=rlSntpAnycastIfIndex, rlTimeSyncMethod=rlTimeSyncMethod, rlSntpNtpConfigSyncSrvIfIndex=rlSntpNtpConfigSyncSrvIfIndex, rlSntpBroadcastAddress=rlSntpBroadcastAddress, rlSntpNtpConfigSyncSrvMrid=rlSntpNtpConfigSyncSrvMrid, rlTimeSyncMethodMode=rlTimeSyncMethodMode, rlSntpBroadcastOffset=rlSntpBroadcastOffset, rlSntpAnycastLastResp=rlSntpAnycastLastResp, rlTZDSTOffset=rlTZDSTOffset, rlSntpAuthenticationEntry=rlSntpAuthenticationEntry, NTPStratum=NTPStratum, rlSntpNtpConfig=rlSntpNtpConfig, rlTimeZoneCode=rlTimeZoneCode, rlTimeSynchronization=rlTimeSynchronization, rlSntpAnycastRowStatus=rlSntpAnycastRowStatus, rlSntpBroadcastStratum=rlSntpBroadcastStratum, rlSntpServerAddress=rlSntpServerAddress, rlSntpConfigAuthenticationTable=rlSntpConfigAuthenticationTable, rlSntpNtpConfigSyncSrvAddr=rlSntpNtpConfigSyncSrvAddr, rlSntpUnicastAdminState=rlSntpUnicastAdminState, rlSntpNtpConfigSysStratum=rlSntpNtpConfigSysStratum, rlSntpNtpConfigPrimaryPollSrvAddr=rlSntpNtpConfigPrimaryPollSrvAddr, rlSntpNtpMibVersion=rlSntpNtpMibVersion, rlTimeValidFlag=rlTimeValidFlag, rlSntpConfigServerTable=rlSntpConfigServerTable, rndTimeSyncManagedDateTime=rndTimeSyncManagedDateTime)
