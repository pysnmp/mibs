#
# PySNMP MIB module FLEXDSR04 (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/2wcom/FLEXDSR04
# Produced by pysmi-1.1.12 at Tue Sep 17 09:56:27 2024
# On host fv-az1427-100 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.14 (main, Jul 16 2024, 19:03:10) [GCC 11.4.0]
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysContact, sysDescr, sysName, sysLocation = mibBuilder.importSymbols("SNMPv2-MIB", "sysContact", "sysDescr", "sysName", "sysLocation")
MibIdentifier, Counter32, ObjectIdentity, Gauge32, Bits, Unsigned32, ModuleIdentity, IpAddress, Counter64, Integer32, iso, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "ObjectIdentity", "Gauge32", "Bits", "Unsigned32", "ModuleIdentity", "IpAddress", "Counter64", "Integer32", "iso", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
TruthValue, TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString", "DateAndTime")
eventTimeStamp, Integer32d1, commonGroup, Integer32d2, FaultOK, FloatString, mibRelease, eventCounter, commonVarbindsCompliance, eventPriority = mibBuilder.importSymbols("TWOWCOM-COMMONVARBINDS", "eventTimeStamp", "Integer32d1", "commonGroup", "Integer32d2", "FaultOK", "FloatString", "mibRelease", "eventCounter", "commonVarbindsCompliance", "eventPriority")
other, dvbDecoder, encoder, decoder, dvbEncoder = mibBuilder.importSymbols("TWOWCOM-SMI", "other", "dvbDecoder", "encoder", "decoder", "dvbEncoder")
flexDSR04 = ModuleIdentity((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4))
flexDSR04.setRevisions(('2019-11-11 13:00', '2017-01-30 10:00', '2016-11-01 16:00', '2016-09-26 15:00', '2014-06-25 17:00', '2014-05-16 12:00', '2014-03-06 16:00', '2014-02-13 09:00', '2012-10-26 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: flexDSR04.setRevisionsDescriptions(('asciiCommand added', 'Version 1.7\r\n\t\t\t\t- status audioTsError added\r\n\t\t\t\t- spelling aoipIcecastInputDataEvntSettings', 'Version 1.6\r\n\t\t\t\t- obsolete etr290ConformityEvent, etr290ConformityEventEnable', 'Version 1.5\r\n\t\t\t\t- DTE status for UECP Data', 'Version 1.4\r\n\t\t\t\t- status for dual IP input stream', 'Version 1.3\r\n\t\t\t\t- added optoInputTable (1.3.6.1.4.1.21529.3.2.4.4.7.10)\r\n\t\t\t\t- new event: optoInputEvent (1.3.6.1.4.1.21529.3.2.4.0.17)\r\n\t\t\t\t- new event: sfnClockEvent (1.3.6.1.4.1.21529.3.2.4.0.18)', 'Version 1.2\r\n\t\t\t\t- added tsOverIp             (1.3.6.1.4.1.21529.3.2.4.4.2.11)\r\n\t\t\t\t- added rtpUdpInputDataTabel (1.3.6.1.4.1.21529.3.2.4.4.3.3)\r\n\t\t\t\t- added OIDs in audioTable   (1.3.6.1.4.1.21529.3.2.4.4.4.1.1.11-14)\r\n\t\t\t\t- added sfnState             (1.3.6.1.4.1.21529.3.2.4.4.9)', 'Version 1.1\r\n\t\t\t\t- added audioTsTable (1.3.6.1.4.1.21529.3.2.4.4.4.2)', 'Version 1.0\r\n\t\t\t\t- Initial release',))
if mibBuilder.loadTexts: flexDSR04.setLastUpdated('201911111300Z')
if mibBuilder.loadTexts: flexDSR04.setOrganization('2wcom Systems GmbH')
if mibBuilder.loadTexts: flexDSR04.setContactInfo('2wcom Systems GmbH\r\n\t\t\t\tc/o Ralf Magnussen\r\n\t\t\t\tAm Sophienhof 8\r\n\t\t\t\t24941 Flensburg\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tTel: +49 461 662830-37\r\n\t\t\t\tFax: +49 461 662830-11\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tWEB: www.2wcom.com')
if mibBuilder.loadTexts: flexDSR04.setDescription('FlexDSR04+ MIB')
class InputSource(TextualConvention, Integer32):
    description = 'Input source type'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("notAssigned", 0), ("tsTuner", 1), ("tsAsi", 2), ("tsIp", 3), ("aoipUdp", 4), ("aoipIcecast", 5), ("internalStorage", 6))

class ServiceMode(TextualConvention, Integer32):
    description = 'Description.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("noTransportstream", 0), ("automatic", 1), ("manual", 2))

flexDSR04Events = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0))
tunerRfPowerEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 1)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "rfPowerValue"), ("FLEXDSR04", "tunerRfPowerEventValue"), ("FLEXDSR04", "tunerRfPowerEventTolerance"), ("FLEXDSR04", "tunerAlarmType"), ("FLEXDSR04", "tunerAlarmActive"))
if mibBuilder.loadTexts: tunerRfPowerEvent.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEvent.setDescription('Signals the status of the SAT tuner RF power')
tunerCnEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 2)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "cnValue"), ("FLEXDSR04", "tunerCnEventMinValue"), ("FLEXDSR04", "tunerAlarmType"), ("FLEXDSR04", "tunerAlarmActive"))
if mibBuilder.loadTexts: tunerCnEvent.setStatus('current')
if mibBuilder.loadTexts: tunerCnEvent.setDescription('Signals the status of the SAT tuner C/N value')
tunerBerEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 3)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "viterbiLdpcBerValue"), ("FLEXDSR04", "tunerBerEventMaxValue"), ("FLEXDSR04", "tunerAlarmType"), ("FLEXDSR04", "tunerAlarmActive"))
if mibBuilder.loadTexts: tunerBerEvent.setStatus('current')
if mibBuilder.loadTexts: tunerBerEvent.setDescription('Signals the status of the SAT tuner Viterbi/LDPC value')
tunerTsSyncEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 4)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "tsSyncType"), ("FLEXDSR04", "tsSyncState"), ("FLEXDSR04", "tsSyncAlarmActive"))
if mibBuilder.loadTexts: tunerTsSyncEvent.setStatus('current')
if mibBuilder.loadTexts: tunerTsSyncEvent.setDescription('Signals the SYNC status of the TS received via the SAT tuner')
asiTsSyncEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 5)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "tsSyncType"), ("FLEXDSR04", "tsSyncState"), ("FLEXDSR04", "tsSyncAlarmActive"))
if mibBuilder.loadTexts: asiTsSyncEvent.setStatus('current')
if mibBuilder.loadTexts: asiTsSyncEvent.setDescription('Signals the SYNC status of the TS received via the ASI input')
ipTsSyncEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 6)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "tsSyncType"), ("FLEXDSR04", "tsSyncState"), ("FLEXDSR04", "tsSyncAlarmActive"))
if mibBuilder.loadTexts: ipTsSyncEvent.setStatus('current')
if mibBuilder.loadTexts: ipTsSyncEvent.setDescription('Signals the SYNC status of the TS received via the IP 1000Base-T interface')
etr290ConformityEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 7)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "etr290Conformity"), ("FLEXDSR04", "etr290ConformityAlarmActive"))
if mibBuilder.loadTexts: etr290ConformityEvent.setStatus('obsolete')
if mibBuilder.loadTexts: etr290ConformityEvent.setDescription('Signals the ETR 290 conformity of the currently active TS')
aoipUdpInputDataEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 8)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "udpInputDataChannel"), ("FLEXDSR04", "udpInputDataState"), ("FLEXDSR04", "udpInputDataAlarmActive"))
if mibBuilder.loadTexts: aoipUdpInputDataEvent.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEvent.setDescription('Signals the input data status for Audio over IP (UDP)')
aoipIcecastInputDataEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 9)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "icecastInputDataServer"), ("FLEXDSR04", "icecastInputDataState"), ("FLEXDSR04", "icecastInputDataAlarmActive"))
if mibBuilder.loadTexts: aoipIcecastInputDataEvent.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEvent.setDescription('Signals the input data status for Audio over IP (Icecast)')
audioEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 10)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "audioChannel"), ("FLEXDSR04", "audioStatus"), ("FLEXDSR04", "audioAlarmActive"))
if mibBuilder.loadTexts: audioEvent.setStatus('current')
if mibBuilder.loadTexts: audioEvent.setDescription('Signals the audio data status (presence/absence of audio data)')
audioLevelEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 11)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "audioChannel"), ("FLEXDSR04", "audioLevel"), ("FLEXDSR04", "audioLevelEventMinValue"), ("FLEXDSR04", "audioLevelAlarmActive"))
if mibBuilder.loadTexts: audioLevelEvent.setStatus('current')
if mibBuilder.loadTexts: audioLevelEvent.setDescription('Signals the status of the audio level (silence detection)')
dteEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 12)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "dtePort"), ("FLEXDSR04", "dteDataAvailable"), ("FLEXDSR04", "dteAlarmActive"))
if mibBuilder.loadTexts: dteEvent.setStatus('current')
if mibBuilder.loadTexts: dteEvent.setDescription('Signals the status of the DTE (ancillary) data')
internalStorageEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 13)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "internalStorageState"))
if mibBuilder.loadTexts: internalStorageEvent.setStatus('current')
if mibBuilder.loadTexts: internalStorageEvent.setDescription('Signals the status of the internal storage')
caseTemperatureEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 14)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "caseTemperature"), ("FLEXDSR04", "caseTemperatureEventMaxValue"), ("FLEXDSR04", "caseTemperatureAlarmActive"))
if mibBuilder.loadTexts: caseTemperatureEvent.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureEvent.setDescription('Signals the case temperature status')
inputSourceEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 15)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "outputType"), ("FLEXDSR04", "currentInputSourceOrder"), ("FLEXDSR04", "currentInputSourceType"))
if mibBuilder.loadTexts: inputSourceEvent.setStatus('current')
if mibBuilder.loadTexts: inputSourceEvent.setDescription('Signals the current input source for the different outputs')
remoteControlUploadEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 16)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "remoteControlUploadType"), ("FLEXDSR04", "remoteControlUploadError"), ("FLEXDSR04", "remoteControlUploadGroup"), ("FLEXDSR04", "remoteControlUploadFile"))
if mibBuilder.loadTexts: remoteControlUploadEvent.setStatus('current')
if mibBuilder.loadTexts: remoteControlUploadEvent.setDescription('Description.')
optoInputEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 17)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "optoInputNumber"), ("FLEXDSR04", "optoInputState"))
if mibBuilder.loadTexts: optoInputEvent.setStatus('current')
if mibBuilder.loadTexts: optoInputEvent.setDescription('Signals changes in optical coupler input state')
sfnClockEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 18)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "sfn1ppsErrorState"), ("FLEXDSR04", "sfn10MHzErrorState"))
if mibBuilder.loadTexts: sfnClockEvent.setStatus('current')
if mibBuilder.loadTexts: sfnClockEvent.setDescription('Signals changes in sfn clock state (first error (1PPS/10MHz) or no error)')
ipPerEvent = NotificationType((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 0, 19)).setObjects(("SNMPv2-MIB", "sysDescr"), ("SNMPv2-MIB", "sysName"), ("SNMPv2-MIB", "sysLocation"), ("TWOWCOM-COMMONVARBINDS", "eventTimeStamp"), ("TWOWCOM-COMMONVARBINDS", "eventPriority"), ("TWOWCOM-COMMONVARBINDS", "eventCounter"), ("FLEXDSR04", "ipPerEventMode"), ("FLEXDSR04", "ipPerEventValue"), ("FLEXDSR04", "tsIpModePER"))
if mibBuilder.loadTexts: ipPerEvent.setStatus('current')
if mibBuilder.loadTexts: ipPerEvent.setDescription('Signals the status of the IP PER value')
inputSourceSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1))
audioOutput1Table = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1), )
if mibBuilder.loadTexts: audioOutput1Table.setStatus('current')
if mibBuilder.loadTexts: audioOutput1Table.setDescription('Defining the main source and the (up to) three backup sources for the audio output 1')
audioOutput1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1, 1), ).setIndexNames((0, "FLEXDSR04", "audioOutput1Index"))
if mibBuilder.loadTexts: audioOutput1Entry.setStatus('current')
if mibBuilder.loadTexts: audioOutput1Entry.setDescription('Defining one source for the audio output 1')
audioOutput1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioOutput1Index.setStatus('current')
if mibBuilder.loadTexts: audioOutput1Index.setDescription('Index of input source for audio output 1')
audioOutput1Order = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3), ("backup3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioOutput1Order.setStatus('current')
if mibBuilder.loadTexts: audioOutput1Order.setDescription('Order of input source for audio output 1 (main source or backup 1-3)')
audioOutput1InputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput1InputSource.setStatus('current')
if mibBuilder.loadTexts: audioOutput1InputSource.setDescription('Input source for audio output 1')
audioOutput1InputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput1InputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: audioOutput1InputSourceEnabled.setDescription('Input source enabled state for audio output 1 \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
audioOutput2Table = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2), )
if mibBuilder.loadTexts: audioOutput2Table.setStatus('current')
if mibBuilder.loadTexts: audioOutput2Table.setDescription('Defining the main source and the (up to) three backup sources for the audio output 2')
audioOutput2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2, 1), ).setIndexNames((0, "FLEXDSR04", "audioOutput2Index"))
if mibBuilder.loadTexts: audioOutput2Entry.setStatus('current')
if mibBuilder.loadTexts: audioOutput2Entry.setDescription('Defining one source for the audio output 2')
audioOutput2Index = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioOutput2Index.setStatus('current')
if mibBuilder.loadTexts: audioOutput2Index.setDescription('Index of input source for audio output 2')
audioOutput2Order = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3), ("backup3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioOutput2Order.setStatus('current')
if mibBuilder.loadTexts: audioOutput2Order.setDescription('Order of input source for audio output 2 (main source or backup 1-3)')
audioOutput2InputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput2InputSource.setStatus('current')
if mibBuilder.loadTexts: audioOutput2InputSource.setDescription('Input source for audio output 2')
audioOutput2InputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput2InputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: audioOutput2InputSourceEnabled.setDescription('Input source enabled state for audio output 2 \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
audioOutput3Table = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3), )
if mibBuilder.loadTexts: audioOutput3Table.setStatus('current')
if mibBuilder.loadTexts: audioOutput3Table.setDescription('Defining the main source and the (up to) three backup sources for the audio output 2')
audioOutput3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3, 1), ).setIndexNames((0, "FLEXDSR04", "audioOutput3Index"))
if mibBuilder.loadTexts: audioOutput3Entry.setStatus('current')
if mibBuilder.loadTexts: audioOutput3Entry.setDescription('Defining one source for the audio output 2')
audioOutput3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioOutput3Index.setStatus('current')
if mibBuilder.loadTexts: audioOutput3Index.setDescription('Index of input source for audio output 2')
audioOutput3Order = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3), ("backup3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioOutput3Order.setStatus('current')
if mibBuilder.loadTexts: audioOutput3Order.setDescription('Order of input source for audio output 2 (main source or backup 1-3)')
audioOutput3InputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput3InputSource.setStatus('current')
if mibBuilder.loadTexts: audioOutput3InputSource.setDescription('Input source for audio output 2')
audioOutput3InputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 3, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput3InputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: audioOutput3InputSourceEnabled.setDescription('Input source enabled state for audio output 2 \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
audioOutput4Table = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4), )
if mibBuilder.loadTexts: audioOutput4Table.setStatus('current')
if mibBuilder.loadTexts: audioOutput4Table.setDescription('Defining the main source and the (up to) three backup sources for the audio output 2')
audioOutput4Entry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4, 1), ).setIndexNames((0, "FLEXDSR04", "audioOutput4Index"))
if mibBuilder.loadTexts: audioOutput4Entry.setStatus('current')
if mibBuilder.loadTexts: audioOutput4Entry.setDescription('Defining one source for the audio output 2')
audioOutput4Index = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioOutput4Index.setStatus('current')
if mibBuilder.loadTexts: audioOutput4Index.setDescription('Index of input source for audio output 2')
audioOutput4Order = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3), ("backup3", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioOutput4Order.setStatus('current')
if mibBuilder.loadTexts: audioOutput4Order.setDescription('Order of input source for audio output 2 (main source or backup 1-3)')
audioOutput4InputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput4InputSource.setStatus('current')
if mibBuilder.loadTexts: audioOutput4InputSource.setDescription('Input source for audio output 2')
audioOutput4InputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 4, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioOutput4InputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: audioOutput4InputSourceEnabled.setDescription('Input source enabled state for audio output 2 \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
asiOutputTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5), )
if mibBuilder.loadTexts: asiOutputTable.setStatus('current')
if mibBuilder.loadTexts: asiOutputTable.setDescription('Defining the main source and the (up to) two backup sources for the ASI output')
asiOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5, 1), ).setIndexNames((0, "FLEXDSR04", "asiOutputIndex"))
if mibBuilder.loadTexts: asiOutputEntry.setStatus('current')
if mibBuilder.loadTexts: asiOutputEntry.setDescription('Defining one source for the ASI output')
asiOutputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: asiOutputIndex.setStatus('current')
if mibBuilder.loadTexts: asiOutputIndex.setDescription('Index of input source for the ASI output')
asiOutputOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: asiOutputOrder.setStatus('current')
if mibBuilder.loadTexts: asiOutputOrder.setDescription('Order of input source for the ASI output (main source or backup 1-2)')
asiOutputInputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiOutputInputSource.setStatus('current')
if mibBuilder.loadTexts: asiOutputInputSource.setDescription('Input source for the ASI output')
asiOutputInputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 5, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiOutputInputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: asiOutputInputSourceEnabled.setDescription('Input source enabled state for the ASI output \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
ipOutputTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6), )
if mibBuilder.loadTexts: ipOutputTable.setStatus('current')
if mibBuilder.loadTexts: ipOutputTable.setDescription('Defining the main source and the (up to) two backup sources for the IP 1000Base-T output')
ipOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6, 1), ).setIndexNames((0, "FLEXDSR04", "ipOutputIndex"))
if mibBuilder.loadTexts: ipOutputEntry.setStatus('current')
if mibBuilder.loadTexts: ipOutputEntry.setDescription('Defining one source for the IP 1000Base-T output')
ipOutputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: ipOutputIndex.setStatus('current')
if mibBuilder.loadTexts: ipOutputIndex.setDescription('Index of input source for the IP 1000Base-T output')
ipOutputOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mainSource", 1), ("backup1", 2), ("backup2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipOutputOrder.setStatus('current')
if mibBuilder.loadTexts: ipOutputOrder.setDescription('Order of input source for the IP 1000Base-T output (main source or backup 1-2)')
ipOutputInputSource = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6, 1, 3), InputSource()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipOutputInputSource.setStatus('current')
if mibBuilder.loadTexts: ipOutputInputSource.setDescription('Input source for the IP 1000Base-T output')
ipOutputInputSourceEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 6, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipOutputInputSourceEnabled.setStatus('current')
if mibBuilder.loadTexts: ipOutputInputSourceEnabled.setDescription('Input source enabled state for the IP 1000Base-T output \r\n\t\t\t\t(allows to temporarily disable an input source without the need to alter the input sources itself - by disabling e.g. the main source you can test the functionality of the first backup source, as it will automatically be activated when the main source gets disabled)')
switchCriteria = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10))
switchCriteriaTunerRfPower = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1))
scTunerRfPowerEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerRfPowerEnabled.setStatus('current')
if mibBuilder.loadTexts: scTunerRfPowerEnabled.setDescription('Use the tuner RF power as a parameter to decide whether to switch the input source')
scTunerRfPowerValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1, 2), Integer32()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerRfPowerValue.setStatus('current')
if mibBuilder.loadTexts: scTunerRfPowerValue.setDescription('RF power reference value')
scTunerRfPowerTolerance = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1, 3), Unsigned32()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerRfPowerTolerance.setStatus('current')
if mibBuilder.loadTexts: scTunerRfPowerTolerance.setDescription('RF power tolerance (amount of allowed variation of the actual RF power value compared to the reference value)')
scTunerRfPowerT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerRfPowerT1.setStatus('current')
if mibBuilder.loadTexts: scTunerRfPowerT1.setDescription('The time period for which the value must be incorrect before the input source will get switched to the next available backup source')
scTunerRfPowerT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 1, 5), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerRfPowerT2.setStatus('current')
if mibBuilder.loadTexts: scTunerRfPowerT2.setDescription('The time period for which the value must be OK before the input source may switch back to this source')
switchCriteriaTunerCn = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 2))
scTunerCnEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerCnEnabled.setStatus('current')
if mibBuilder.loadTexts: scTunerCnEnabled.setDescription('Use the tuner C/N value as a parameter to decide whether to switch the input source')
scTunerCnMinValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 2, 2), Integer32()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerCnMinValue.setStatus('current')
if mibBuilder.loadTexts: scTunerCnMinValue.setDescription('Tuner C/N minimum value considered OK')
scTunerCnT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 2, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerCnT1.setStatus('current')
if mibBuilder.loadTexts: scTunerCnT1.setDescription('The time period for which the value must be incorrect before the input source will get switched to the next available backup source')
scTunerCnT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 2, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerCnT2.setStatus('current')
if mibBuilder.loadTexts: scTunerCnT2.setDescription('The time period for which the value must be OK before the input source may switch back to this source')
switchCriteriaTunerBer = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 3))
scTunerBerEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 3, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerBerEnabled.setStatus('current')
if mibBuilder.loadTexts: scTunerBerEnabled.setDescription('Use the tuner Viterbi/LDPC value as a parameter to decide whether to switch the input source')
scTunerBerMaxValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 3, 2), FloatString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerBerMaxValue.setStatus('current')
if mibBuilder.loadTexts: scTunerBerMaxValue.setDescription('Tuner BER maximum value considered OK')
scTunerBerT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 3, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerBerT1.setStatus('current')
if mibBuilder.loadTexts: scTunerBerT1.setDescription('The time period for which the value must be incorrect before the input source will get switched to the next available backup source')
scTunerBerT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 3, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerBerT2.setStatus('current')
if mibBuilder.loadTexts: scTunerBerT2.setDescription('The time period for which the value must be OK before the input source may switch back to this source')
switchCriteriaTunerTsSync = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 4))
scTunerTsSyncEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 4, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerTsSyncEnabled.setStatus('current')
if mibBuilder.loadTexts: scTunerTsSyncEnabled.setDescription('Use the TS sync status from the transport stream received via the SAT tuner as a parameter to decide whether to switch the input source')
scTunerTsSyncT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 4, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerTsSyncT1.setStatus('current')
if mibBuilder.loadTexts: scTunerTsSyncT1.setDescription('The time period for which the status must be faulty before the input source will get switched to the next available backup source')
scTunerTsSyncT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 4, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scTunerTsSyncT2.setStatus('current')
if mibBuilder.loadTexts: scTunerTsSyncT2.setDescription('The time period for which the status must be OK before the input source may switch back to this source')
switchCriteriaAsiTsSync = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 5))
scAsiTsSyncEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 5, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAsiTsSyncEnabled.setStatus('current')
if mibBuilder.loadTexts: scAsiTsSyncEnabled.setDescription('Use the TS sync status from the transport stream received via the ASI input as a parameter to decide whether to switch the input source')
scAsiTsSyncT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 5, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAsiTsSyncT1.setStatus('current')
if mibBuilder.loadTexts: scAsiTsSyncT1.setDescription('The time period for which the status must be faulty before the input source will get switched to the next available backup source')
scAsiTsSyncT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 5, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAsiTsSyncT2.setStatus('current')
if mibBuilder.loadTexts: scAsiTsSyncT2.setDescription('The time period for which the status must be OK before the input source may switch back to this source')
switchCriteriaIpTsSync = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 6))
scIpTsSyncEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 6, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpTsSyncEnabled.setStatus('current')
if mibBuilder.loadTexts: scIpTsSyncEnabled.setDescription('Use the TS sync status from the transport stream received via the IP 1000Base-T input as a parameter to decide whether to switch the input source')
scIpTsSyncT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 6, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpTsSyncT1.setStatus('current')
if mibBuilder.loadTexts: scIpTsSyncT1.setDescription('The time period for which the status must be faulty before the input source will get switched to the next available backup source')
scIpTsSyncT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 6, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpTsSyncT2.setStatus('current')
if mibBuilder.loadTexts: scIpTsSyncT2.setDescription('The time period for which the status must be OK before the input source may switch back to this source')
switchCriteriaAudioOverIpUdp = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 7))
scAudioOverIpUdpEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 7, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpUdpEnabled.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpUdpEnabled.setDescription('Use the presence/absence of Audio over IP (UDP) input data as a parameter to decide whether to switch the input source')
scAudioOverIpUdpT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 7, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpUdpT1.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpUdpT1.setDescription('The time period for which the status must be faulty before the input source will get switched to the next available backup source')
scAudioOverIpUdpT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 7, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpUdpT2.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpUdpT2.setDescription('The time period for which the status must be OK before the input source may switch back to this source')
switchCriteriaAudioOverIpIcecast = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 8))
scAudioOverIpIcecastEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 8, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpIcecastEnabled.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpIcecastEnabled.setDescription('Use the presence/absence of Audio over IP (Icecast) input data as a parameter to decide whether to switch the input source')
scAudioOverIpIcecastT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 8, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpIcecastT1.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpIcecastT1.setDescription('The time period for which the status must be faulty before the input source will get switched to the next available backup source')
scAudioOverIpIcecastT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 8, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scAudioOverIpIcecastT2.setStatus('current')
if mibBuilder.loadTexts: scAudioOverIpIcecastT2.setDescription('The time period for which the status must be OK before the input source may switch back to this source')
switchCriteriaInternalStorage = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 9))
scInternalStorageEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 9, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scInternalStorageEnabled.setStatus('current')
if mibBuilder.loadTexts: scInternalStorageEnabled.setDescription('Use the status of the internal storage as a parameter to decide whether to switch the input source')
switchCriteriaIpPer = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10))
scIpPerEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpPerEnabled.setStatus('current')
if mibBuilder.loadTexts: scIpPerEnabled.setDescription('Use the IP PER value as a parameter to decide whether to switch the input source')
scIpPerMode = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("combinedStream", 1), ("mainStream", 2), ("bothStreams", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpPerMode.setStatus('current')
if mibBuilder.loadTexts: scIpPerMode.setDescription('Selecting the stream to measure PER')
scIpPerValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10, 3), FloatString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpPerValue.setStatus('current')
if mibBuilder.loadTexts: scIpPerValue.setDescription('IP PER value considered OK')
scIpPerT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpPerT1.setStatus('current')
if mibBuilder.loadTexts: scIpPerT1.setDescription('The time period for which the value must be incorrect before the input source will get switched to the next available backup source')
scIpPerT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 1, 10, 10, 5), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: scIpPerT2.setStatus('current')
if mibBuilder.loadTexts: scIpPerT2.setDescription('The time period for which the value must be OK before the input source may switch back to this source')
interfaceSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3))
xlrInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1))
xlrVolumeTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1), )
if mibBuilder.loadTexts: xlrVolumeTable.setStatus('current')
if mibBuilder.loadTexts: xlrVolumeTable.setDescription('Audio level adjustment for the different audio outputs')
xlrVolumeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1), ).setIndexNames((0, "FLEXDSR04", "xlrVolumeIndex"))
if mibBuilder.loadTexts: xlrVolumeEntry.setStatus('current')
if mibBuilder.loadTexts: xlrVolumeEntry.setDescription('Audio level adjustment for one audio output')
xlrVolumeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: xlrVolumeIndex.setStatus('current')
if mibBuilder.loadTexts: xlrVolumeIndex.setDescription('Index of XLR volume')
xlrVolumePort = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("audio1", 1), ("audio2", 2), ("audio3", 3), ("audio4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: xlrVolumePort.setStatus('current')
if mibBuilder.loadTexts: xlrVolumePort.setDescription('XLR volume port / audio output (Audio1 or Audio2)')
xlrVolumeAnalog = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1, 3), Integer32d1().subtype(subtypeSpec=ValueRangeConstraint(-360, 60))).setUnits('db').setMaxAccess("readwrite")
if mibBuilder.loadTexts: xlrVolumeAnalog.setStatus('current')
if mibBuilder.loadTexts: xlrVolumeAnalog.setDescription('Analog level adjustment')
xlrVolumeDigital = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1, 4), Integer32d1().subtype(subtypeSpec=ValueRangeConstraint(-360, 60))).setUnits('db').setMaxAccess("readwrite")
if mibBuilder.loadTexts: xlrVolumeDigital.setStatus('current')
if mibBuilder.loadTexts: xlrVolumeDigital.setDescription('Digital level adjustment')
xlrOutputType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("analog", 2), ("digital", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: xlrOutputType.setStatus('current')
if mibBuilder.loadTexts: xlrOutputType.setDescription('Description.')
audioLowPass15kHz = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 1, 99), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioLowPass15kHz.setStatus('current')
if mibBuilder.loadTexts: audioLowPass15kHz.setDescription('Enable/disable 15 kHz audio low pass filter')
headphoneInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 2))
headphoneVolume = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 2, 1), Integer32d1().subtype(subtypeSpec=ValueRangeConstraint(-360, 60))).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: headphoneVolume.setStatus('current')
if mibBuilder.loadTexts: headphoneVolume.setDescription('Headphone volume')
headphoneAudioChannel = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("audio1", 1), ("audio2", 2), ("audio3", 3), ("audio4", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: headphoneAudioChannel.setStatus('current')
if mibBuilder.loadTexts: headphoneAudioChannel.setDescription('Audio channel to monitor via the headphone')
dteInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3))
dteInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3, 1), )
if mibBuilder.loadTexts: dteInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: dteInterfaceTable.setDescription('Settings for the different DTE ports')
dteInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3, 1, 1), ).setIndexNames((0, "FLEXDSR04", "dteInterfaceIndex"))
if mibBuilder.loadTexts: dteInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: dteInterfaceEntry.setDescription('Settings for one DTE port')
dteInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)))
if mibBuilder.loadTexts: dteInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: dteInterfaceIndex.setDescription('Index of DTE interface settings')
dteInterfacePort = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("dteFront", 1), ("dte1", 2), ("dte2", 3), ("dte3", 4), ("dte4", 5), ("dte5", 6), ("dte6", 7), ("dte7", 8), ("dte8", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteInterfacePort.setStatus('current')
if mibBuilder.loadTexts: dteInterfacePort.setDescription('DTE port')
dteInterfaceBaudrate = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1200, 1200), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ))).setUnits('baud').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dteInterfaceBaudrate.setStatus('current')
if mibBuilder.loadTexts: dteInterfaceBaudrate.setDescription('DTE baud rate')
state = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4))
tunerState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1))
rfPowerValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 1), Integer32()).setUnits('dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: rfPowerValue.setStatus('current')
if mibBuilder.loadTexts: rfPowerValue.setDescription('Current RF power value')
cnValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 2), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: cnValue.setStatus('current')
if mibBuilder.loadTexts: cnValue.setDescription('Current C/N value')
cfoErrorValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 3), Integer32d2()).setUnits('MHz').setMaxAccess("readonly")
if mibBuilder.loadTexts: cfoErrorValue.setStatus('current')
if mibBuilder.loadTexts: cfoErrorValue.setDescription('Current CFO (Center Frequency Offset) value')
agcState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 4), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: agcState.setStatus('current')
if mibBuilder.loadTexts: agcState.setDescription('Current AGC (automatic gain control) state')
ceState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 5), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ceState.setStatus('current')
if mibBuilder.loadTexts: ceState.setDescription('Current CE state')
symTimeState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 6), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: symTimeState.setStatus('current')
if mibBuilder.loadTexts: symTimeState.setDescription('Current symbol time state')
carrierState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 7), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: carrierState.setStatus('current')
if mibBuilder.loadTexts: carrierState.setDescription('Current carrier state')
fecLockedState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 8), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fecLockedState.setStatus('current')
if mibBuilder.loadTexts: fecLockedState.setDescription('Current FEC locked state')
lockedState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 9), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lockedState.setStatus('current')
if mibBuilder.loadTexts: lockedState.setDescription('Current Tuner locked state')
punctureRate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: punctureRate.setStatus('current')
if mibBuilder.loadTexts: punctureRate.setDescription('Current puncture rate')
viterbiLdpcBerValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 11), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: viterbiLdpcBerValue.setStatus('current')
if mibBuilder.loadTexts: viterbiLdpcBerValue.setDescription('Current Viterbi/LDPC BER value')
rsBchBerValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 12), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rsBchBerValue.setStatus('current')
if mibBuilder.loadTexts: rsBchBerValue.setDescription('Current RS/BCH BER value')
tunerAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 20), )
if mibBuilder.loadTexts: tunerAlarmTable.setStatus('current')
if mibBuilder.loadTexts: tunerAlarmTable.setDescription('Status of the different tuner alarms')
tunerAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 20, 1), ).setIndexNames((0, "FLEXDSR04", "tunerAlarmIndex"))
if mibBuilder.loadTexts: tunerAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: tunerAlarmEntry.setDescription('Status of one tuner alarm')
tunerAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: tunerAlarmIndex.setStatus('current')
if mibBuilder.loadTexts: tunerAlarmIndex.setDescription('Index of the tuner alarm')
tunerAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rfPowerAlarm", 1), ("cnAlarm", 2), ("berAlarm", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunerAlarmType.setStatus('current')
if mibBuilder.loadTexts: tunerAlarmType.setDescription('Type of tuner alarm')
tunerAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 1, 20, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tunerAlarmActive.setStatus('current')
if mibBuilder.loadTexts: tunerAlarmActive.setDescription('State of the tuner alarm (active/inactive)')
tsState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2))
nid = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nid.setStatus('current')
if mibBuilder.loadTexts: nid.setDescription('Current DVB network ID')
tunerDatarate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 2), Integer32()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: tunerDatarate.setStatus('current')
if mibBuilder.loadTexts: tunerDatarate.setDescription('Current tuner input TS data rate')
asiDatarate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 3), Integer32()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: asiDatarate.setStatus('current')
if mibBuilder.loadTexts: asiDatarate.setDescription('Current ASI input TS data rate')
ipDatarate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 4), Integer32()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipDatarate.setStatus('current')
if mibBuilder.loadTexts: ipDatarate.setDescription('Current IP 1000Base-T input TS data rate')
etr290Conformity = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 5), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etr290Conformity.setStatus('current')
if mibBuilder.loadTexts: etr290Conformity.setDescription('Current ETR290 conformity (only basic checks)')
etr290ConformityAlarmActive = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: etr290ConformityAlarmActive.setStatus('current')
if mibBuilder.loadTexts: etr290ConformityAlarmActive.setDescription('State of the ETR290 conformity alarm (active/inactive)')
tsSyncTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10), )
if mibBuilder.loadTexts: tsSyncTable.setStatus('current')
if mibBuilder.loadTexts: tsSyncTable.setDescription('Current TS sync state of the different TS input streams')
tsSyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10, 1), ).setIndexNames((0, "FLEXDSR04", "tsSyncIndex"))
if mibBuilder.loadTexts: tsSyncEntry.setStatus('current')
if mibBuilder.loadTexts: tsSyncEntry.setDescription('Current TS sync state of one TS input stream')
tsSyncIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: tsSyncIndex.setStatus('current')
if mibBuilder.loadTexts: tsSyncIndex.setDescription('Transport stream index')
tsSyncType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tunerTs", 1), ("asiTs", 2), ("ipTs", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsSyncType.setStatus('current')
if mibBuilder.loadTexts: tsSyncType.setDescription('Transport Stream input type')
tsSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10, 1, 3), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsSyncState.setStatus('current')
if mibBuilder.loadTexts: tsSyncState.setDescription('Transport Stream Sync state')
tsSyncAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 10, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsSyncAlarmActive.setStatus('current')
if mibBuilder.loadTexts: tsSyncAlarmActive.setDescription('State of the Transport Stream Sync alarm (active/inactive)')
tsOverIp = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11))
tsIpSync = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpSync.setStatus('current')
if mibBuilder.loadTexts: tsIpSync.setDescription('TS Sync for IP 1000Base-T active. ')
tsIpPacketPerIpPacket = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketPerIpPacket.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketPerIpPacket.setDescription('TS packet(s) per IP packet')
tsIpBufferlevel1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 3), Integer32()).setUnits('ms').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBufferlevel1.setStatus('current')
if mibBuilder.loadTexts: tsIpBufferlevel1.setDescription('Buffer level (configured)')
tsIpBufferlevel2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 4), Integer32()).setUnits('ms').setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBufferlevel2.setStatus('current')
if mibBuilder.loadTexts: tsIpBufferlevel2.setDescription('Buffer level (time measured) ')
tsIpBufferlevel3 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBufferlevel3.setStatus('current')
if mibBuilder.loadTexts: tsIpBufferlevel3.setDescription('Buffer level (TS packets measured)')
tsIpBufferReset = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBufferReset.setStatus('current')
if mibBuilder.loadTexts: tsIpBufferReset.setDescription('Buffer reset counter')
tsIpPacketDropped = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketDropped.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketDropped.setDescription('IP packets dropped')
tsIpPacketReordered = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketReordered.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketReordered.setDescription('IP packets reordered')
tsIpPacketRestored = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketRestored.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketRestored.setDescription('IP packets restored (FEC)')
tsIpPacketUnrecoverable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketUnrecoverable.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketUnrecoverable.setDescription('IP packets unrecoverable (FEC)')
tsIpFecL = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpFecL.setStatus('current')
if mibBuilder.loadTexts: tsIpFecL.setDescription('FEC column count L')
tsIpFecD = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpFecD.setStatus('current')
if mibBuilder.loadTexts: tsIpFecD.setDescription('FEC row count D')
tsIpPacketDuplicate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPacketDuplicate.setStatus('current')
if mibBuilder.loadTexts: tsIpPacketDuplicate.setDescription('IP packets twice received (FEC)')
tsIpPER = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 14), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPER.setStatus('current')
if mibBuilder.loadTexts: tsIpPER.setDescription('Packet error rate')
tsIpPLR = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 15), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpPLR.setStatus('current')
if mibBuilder.loadTexts: tsIpPLR.setDescription('Packet loss rate')
tsIpErroneousPacketrate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 16), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpErroneousPacketrate.setStatus('current')
if mibBuilder.loadTexts: tsIpErroneousPacketrate.setDescription('Received packets with CRC errors')
tsIpDualInput = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 17))
tsIpBackupPER = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 17, 1), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBackupPER.setStatus('current')
if mibBuilder.loadTexts: tsIpBackupPER.setDescription('Packet error rate of second input stream')
tsIpBackupPLR = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 17, 2), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBackupPLR.setStatus('current')
if mibBuilder.loadTexts: tsIpBackupPLR.setDescription('Packet loss rate of second input stream')
tsIpBackupErroneousPacketrate = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 17, 3), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpBackupErroneousPacketrate.setStatus('current')
if mibBuilder.loadTexts: tsIpBackupErroneousPacketrate.setDescription('Received packets of second input stream with CRC errors')
tsIpCombinedPER = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 17, 4), FloatString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tsIpCombinedPER.setStatus('current')
if mibBuilder.loadTexts: tsIpCombinedPER.setDescription('Packet error rate after packet restoration (FEC and dual input)')
tsIpModePER = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 2, 11, 18), FloatString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tsIpModePER.setStatus('current')
if mibBuilder.loadTexts: tsIpModePER.setDescription('Packet error rate of selected mode for events')
audioOverIpState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3))
udpInputDataTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1), )
if mibBuilder.loadTexts: udpInputDataTable.setStatus('current')
if mibBuilder.loadTexts: udpInputDataTable.setDescription('State of the Audio over IP (UDP) input data channels')
udpInputDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1, 1), ).setIndexNames((0, "FLEXDSR04", "udpInputDataIndex"))
if mibBuilder.loadTexts: udpInputDataEntry.setStatus('current')
if mibBuilder.loadTexts: udpInputDataEntry.setDescription('State of one Audio over IP (UDP) input data channel')
udpInputDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: udpInputDataIndex.setStatus('current')
if mibBuilder.loadTexts: udpInputDataIndex.setDescription('Audio over IP (UDP) input data channel index')
udpInputDataChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("channel1", 1), ("channel2", 2), ("channel3", 3), ("channel4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpInputDataChannel.setStatus('current')
if mibBuilder.loadTexts: udpInputDataChannel.setDescription('Audio over IP (UDP) input data channel')
udpInputDataState = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1, 1, 3), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpInputDataState.setStatus('current')
if mibBuilder.loadTexts: udpInputDataState.setDescription('Audio over IP (UDP) input data channel state (presence/absence of input data)')
udpInputDataAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: udpInputDataAlarmActive.setStatus('current')
if mibBuilder.loadTexts: udpInputDataAlarmActive.setDescription('State of the Audio over IP (UDP) input data channel alarm (active/inactive)')
icecastInputDataTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2), )
if mibBuilder.loadTexts: icecastInputDataTable.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataTable.setDescription('State of the Audio over IP (Icecast) input data servers')
icecastInputDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2, 1), ).setIndexNames((0, "FLEXDSR04", "icecastInputDataIndex"))
if mibBuilder.loadTexts: icecastInputDataEntry.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataEntry.setDescription('State of one Audio over IP (Icecast) input data server')
icecastInputDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: icecastInputDataIndex.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataIndex.setDescription('Audio over IP (Icecast) input data server index')
icecastInputDataServer = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("server1", 1), ("server2", 2), ("server3", 3), ("server4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: icecastInputDataServer.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataServer.setDescription('Audio over IP (Icecast) input data server')
icecastInputDataState = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2, 1, 3), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icecastInputDataState.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataState.setDescription('Audio over IP (Icecast) input data server state (presence/absence of input data)')
icecastInputDataAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icecastInputDataAlarmActive.setStatus('current')
if mibBuilder.loadTexts: icecastInputDataAlarmActive.setDescription('State of the Audio over IP (Icecast) input data server alarm (active/inactive)')
rtpUdpInputDataTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3), )
if mibBuilder.loadTexts: rtpUdpInputDataTable.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataTable.setDescription('State of the Audio over IP (RTP/UDP) connections')
rtpUdpInputDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1), ).setIndexNames((0, "FLEXDSR04", "rtpUdpInputDataIndex"))
if mibBuilder.loadTexts: rtpUdpInputDataEntry.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataEntry.setDescription('State of the Audio over IP (RTP/UDP) connection')
rtpUdpInputDataIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: rtpUdpInputDataIndex.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataIndex.setDescription('State of the Audio over IP (RTP/UDP) connection index')
rtpUdpInputDataPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1, 2), Integer32()).setUnits('1/sec').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpUdpInputDataPackets.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataPackets.setDescription('Packets/sec')
rtpUdpInputDataRtpDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1, 3), Integer32()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpUdpInputDataRtpDataRate.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataRtpDataRate.setDescription('RTP data rate')
rtpUdpInputDataIpRawDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1, 4), Integer32()).setUnits('bit/s').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpUdpInputDataIpRawDataRate.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataIpRawDataRate.setDescription('IP raw data rate')
rtpUdpInputDataRtpPacketloss = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtpUdpInputDataRtpPacketloss.setStatus('current')
if mibBuilder.loadTexts: rtpUdpInputDataRtpPacketloss.setDescription('RTP packet loss counter')
audioState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4))
audioTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1), )
if mibBuilder.loadTexts: audioTable.setStatus('current')
if mibBuilder.loadTexts: audioTable.setDescription('State of the different audio channels')
audioEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1), ).setIndexNames((0, "FLEXDSR04", "audioIndex"))
if mibBuilder.loadTexts: audioEntry.setStatus('current')
if mibBuilder.loadTexts: audioEntry.setDescription('State of one audio channel')
audioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioIndex.setStatus('current')
if mibBuilder.loadTexts: audioIndex.setDescription('Audio channel index')
audioChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("audio1", 1), ("audio2", 2), ("audio3", 3), ("audio4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioChannel.setStatus('current')
if mibBuilder.loadTexts: audioChannel.setDescription('Audio channel')
audioStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 3), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioStatus.setStatus('current')
if mibBuilder.loadTexts: audioStatus.setDescription('presence/absence of audio data\r\n\t\t\t\tok        -> audio is ok\r\n\t\t\t\tfault     -> audio is not ok')
audioVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mpeg1", 1), ("mpeg2", 2), ("ac3", 3), ("mpeg4", 4), ("aptX", 5), ("linearPCM", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioVersion.setStatus('current')
if mibBuilder.loadTexts: audioVersion.setDescription('Audio version')
audioLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("layer1", 1), ("layer2", 2), ("layer3", 3), ("aac", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioLayer.setStatus('current')
if mibBuilder.loadTexts: audioLayer.setDescription('Audio layer')
audioBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioBitRate.setStatus('current')
if mibBuilder.loadTexts: audioBitRate.setDescription('Audio bit rate')
audioSampleRate = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioSampleRate.setStatus('current')
if mibBuilder.loadTexts: audioSampleRate.setDescription('Audio sample rate')
audioAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioAlarmActive.setStatus('current')
if mibBuilder.loadTexts: audioAlarmActive.setDescription('State of the audio alarm (inactive/active - presence/absence of audio data)')
audioLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 9), Integer32d1()).setUnits('dBFS').setMaxAccess("readonly")
if mibBuilder.loadTexts: audioLevel.setStatus('current')
if mibBuilder.loadTexts: audioLevel.setDescription('Current audio level')
audioLevelAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioLevelAlarmActive.setStatus('current')
if mibBuilder.loadTexts: audioLevelAlarmActive.setDescription('State of the audio level alarm (inactive/active - silence detection)')
audioNoDataAvailabe = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioNoDataAvailabe.setStatus('current')
if mibBuilder.loadTexts: audioNoDataAvailabe.setDescription('Everytime a empty audio frame is send out, because of no input data.')
audioDecoderResets = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioDecoderResets.setStatus('current')
if mibBuilder.loadTexts: audioDecoderResets.setDescription('Decoder reset counter')
audioBufferlevel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioBufferlevel.setStatus('current')
if mibBuilder.loadTexts: audioBufferlevel.setDescription('Audio decoder buffer level')
audioPLLlevel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1000, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioPLLlevel.setStatus('current')
if mibBuilder.loadTexts: audioPLLlevel.setDescription('Audio PLL speed indicator')
audioTsError = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioTsError.setStatus('current')
if mibBuilder.loadTexts: audioTsError.setDescription('Transportstream Error Counter')
audioTsTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2), )
if mibBuilder.loadTexts: audioTsTable.setStatus('current')
if mibBuilder.loadTexts: audioTsTable.setDescription('Description.')
audioTsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2, 1), ).setIndexNames((0, "FLEXDSR04", "audioTsIndex"))
if mibBuilder.loadTexts: audioTsEntry.setStatus('current')
if mibBuilder.loadTexts: audioTsEntry.setDescription('Description.')
audioTsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioTsIndex.setStatus('current')
if mibBuilder.loadTexts: audioTsIndex.setDescription('Description.')
audioTsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2, 1, 2), ServiceMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioTsMode.setStatus('current')
if mibBuilder.loadTexts: audioTsMode.setDescription('Selected service mode')
audioTsService = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioTsService.setStatus('current')
if mibBuilder.loadTexts: audioTsService.setDescription('Service name')
audioTsPID = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioTsPID.setStatus('current')
if mibBuilder.loadTexts: audioTsPID.setDescription('PID of the audio stream')
dteState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5))
dteTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1), )
if mibBuilder.loadTexts: dteTable.setStatus('current')
if mibBuilder.loadTexts: dteTable.setDescription('State of the different DTE outputs (data present/absent)')
dteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1), ).setIndexNames((0, "FLEXDSR04", "dteIndex"))
if mibBuilder.loadTexts: dteEntry.setStatus('current')
if mibBuilder.loadTexts: dteEntry.setDescription('State of one DTE output (data present/absent)')
dteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: dteIndex.setStatus('current')
if mibBuilder.loadTexts: dteIndex.setDescription('DTE index')
dtePort = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("dte1", 1), ("dte2", 2), ("dte3", 3), ("dte4", 4), ("dte5", 5), ("dte6", 6), ("dte7", 7), ("dte8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dtePort.setStatus('current')
if mibBuilder.loadTexts: dtePort.setDescription('DTE port')
dteDataAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteDataAvailable.setStatus('current')
if mibBuilder.loadTexts: dteDataAvailable.setDescription('presence/absence of DTE data')
dteAlarmActive = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteAlarmActive.setStatus('current')
if mibBuilder.loadTexts: dteAlarmActive.setDescription('State of the DTE alarm (presence/absence of data)')
dteUecpPI = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpPI.setStatus('current')
if mibBuilder.loadTexts: dteUecpPI.setDescription('Current RDS PI value')
dteUecpPS = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpPS.setStatus('current')
if mibBuilder.loadTexts: dteUecpPS.setDescription('Current RDS PS')
dteUecpRT = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpRT.setStatus('current')
if mibBuilder.loadTexts: dteUecpRT.setDescription('Current RDS RadioText (RT)')
dteUecpTA = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpTA.setStatus('current')
if mibBuilder.loadTexts: dteUecpTA.setDescription('Current RDS TA (0/1)')
dteUecpTP = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpTP.setStatus('current')
if mibBuilder.loadTexts: dteUecpTP.setDescription('Current RDS TP (0/1)')
dteUecpPTY = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpPTY.setStatus('current')
if mibBuilder.loadTexts: dteUecpPTY.setDescription('Current RDS PTY')
dteUecpCT = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 5, 1, 1, 11), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteUecpCT.setStatus('current')
if mibBuilder.loadTexts: dteUecpCT.setDescription('Current RDS CT')
inputSourceState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6))
currentInputSourceTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1), )
if mibBuilder.loadTexts: currentInputSourceTable.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceTable.setDescription('Type of input source currently used for the different outputs and its state')
currentInputSourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1), ).setIndexNames((0, "FLEXDSR04", "currentInputSourceIndex"))
if mibBuilder.loadTexts: currentInputSourceEntry.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceEntry.setDescription('Type of input source currently used for one output and its state')
currentInputSourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6)))
if mibBuilder.loadTexts: currentInputSourceIndex.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceIndex.setDescription('Output type index')
outputType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("audioOutput1", 1), ("audioOutput2", 2), ("audioOutput3", 3), ("audioOutput4", 4), ("asiOutput", 5), ("ipOutput", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: outputType.setStatus('current')
if mibBuilder.loadTexts: outputType.setDescription('Output type')
currentInputSourceState = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1, 3), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentInputSourceState.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceState.setDescription('State of the currently active input source')
currentInputSourceOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("temporaryMasterSource", 1), ("mainSource", 2), ("backup1", 3), ("backup2", 4), ("backup3", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentInputSourceOrder.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceOrder.setDescription('Order of the currently active input source (main source or backup)')
currentInputSourceType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 6, 1, 1, 5), InputSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentInputSourceType.setStatus('current')
if mibBuilder.loadTexts: currentInputSourceType.setDescription('Type of the currently active input source')
deviceState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7))
internalStorageState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 1), FaultOK()).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageState.setStatus('current')
if mibBuilder.loadTexts: internalStorageState.setDescription('State of the internal storage')
internalStorageFreeMemory = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 2), Integer32()).setUnits('KB').setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageFreeMemory.setStatus('current')
if mibBuilder.loadTexts: internalStorageFreeMemory.setDescription('Available free memory in the internal storage')
caseTemperature = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 3), Integer32()).setUnits('degree Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: caseTemperature.setStatus('current')
if mibBuilder.loadTexts: caseTemperature.setDescription('Current case temperature')
caseTemperatureAlarmActive = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: caseTemperatureAlarmActive.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureAlarmActive.setDescription('State of the case temperature alarm (active/inactive)')
optoInputTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 10), )
if mibBuilder.loadTexts: optoInputTable.setStatus('current')
if mibBuilder.loadTexts: optoInputTable.setDescription('Table of the optical coupler state')
optoInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 10, 1), ).setIndexNames((0, "FLEXDSR04", "optoInputIndex"))
if mibBuilder.loadTexts: optoInputEntry.setStatus('current')
if mibBuilder.loadTexts: optoInputEntry.setDescription('One optical coupler state')
optoInputIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: optoInputIndex.setStatus('current')
if mibBuilder.loadTexts: optoInputIndex.setDescription('Optical coupler index')
optoInputNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: optoInputNumber.setStatus('current')
if mibBuilder.loadTexts: optoInputNumber.setDescription('Optical coupler number')
optoInputState = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: optoInputState.setStatus('current')
if mibBuilder.loadTexts: optoInputState.setDescription('Optical coupler state')
internalStorageTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11), )
if mibBuilder.loadTexts: internalStorageTable.setStatus('current')
if mibBuilder.loadTexts: internalStorageTable.setDescription('Table of the internal storage usage')
internalStorageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1), ).setIndexNames((0, "FLEXDSR04", "internalStorageIndex"))
if mibBuilder.loadTexts: internalStorageEntry.setStatus('current')
if mibBuilder.loadTexts: internalStorageEntry.setDescription('Description.')
internalStorageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: internalStorageIndex.setStatus('current')
if mibBuilder.loadTexts: internalStorageIndex.setDescription('Description.')
internalStorageSection = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("device", 1), ("audio1", 2), ("audio2", 3), ("audio3", 4), ("audio4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageSection.setStatus('current')
if mibBuilder.loadTexts: internalStorageSection.setDescription('Section of the internal storage')
internalStorageFree = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1, 3), Integer32()).setUnits('MB').setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageFree.setStatus('current')
if mibBuilder.loadTexts: internalStorageFree.setDescription('Amount of available free memory')
internalStorageQuota = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1, 4), Integer32()).setUnits('MB').setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageQuota.setStatus('current')
if mibBuilder.loadTexts: internalStorageQuota.setDescription('Assigned storage quota or total memory size')
internalStorageQuotaUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 7, 11, 1, 5), Integer32()).setUnits('MB').setMaxAccess("readonly")
if mibBuilder.loadTexts: internalStorageQuotaUsed.setStatus('current')
if mibBuilder.loadTexts: internalStorageQuotaUsed.setDescription('Amount of memory used')
eventParams = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8))
remoteControlUploadEventParams = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8, 1))
remoteControlUploadType = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("firmware", 1), ("configuration", 2), ("audio", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: remoteControlUploadType.setStatus('current')
if mibBuilder.loadTexts: remoteControlUploadType.setDescription('Type of remote control upload')
remoteControlUploadError = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crcError", 1), ("storageQuotaExceeded", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: remoteControlUploadError.setStatus('current')
if mibBuilder.loadTexts: remoteControlUploadError.setDescription('Type of remote control upload error')
remoteControlUploadGroup = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8, 1, 3), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: remoteControlUploadGroup.setStatus('current')
if mibBuilder.loadTexts: remoteControlUploadGroup.setDescription('Group name used for remote control upload')
remoteControlUploadFile = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 8, 1, 4), OctetString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: remoteControlUploadFile.setStatus('current')
if mibBuilder.loadTexts: remoteControlUploadFile.setDescription('Name of file tried to upload via remote control')
sfnState = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9))
sfnActive = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnActive.setStatus('current')
if mibBuilder.loadTexts: sfnActive.setDescription('SFN mode active')
sfn1ppsErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfn1ppsErrorCount.setStatus('current')
if mibBuilder.loadTexts: sfn1ppsErrorCount.setDescription('1PPS error counter')
sfn10MHzErrorCount = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfn10MHzErrorCount.setStatus('current')
if mibBuilder.loadTexts: sfn10MHzErrorCount.setDescription('10MHz error counter')
sfnBufferlevel = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnBufferlevel.setStatus('current')
if mibBuilder.loadTexts: sfnBufferlevel.setDescription('SFN buffer level')
sfnResetCount = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnResetCount.setStatus('current')
if mibBuilder.loadTexts: sfnResetCount.setDescription('SFN reset counter')
sfnTransmissionDelay = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 6), Integer32()).setUnits('us').setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnTransmissionDelay.setStatus('current')
if mibBuilder.loadTexts: sfnTransmissionDelay.setDescription('Transmission delay')
sfnGlobalDelay = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 7), Integer32()).setUnits('us').setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnGlobalDelay.setStatus('current')
if mibBuilder.loadTexts: sfnGlobalDelay.setDescription('Global delay')
sfnAccuracy = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 8), Integer32d1()).setUnits('us').setMaxAccess("readonly")
if mibBuilder.loadTexts: sfnAccuracy.setStatus('current')
if mibBuilder.loadTexts: sfnAccuracy.setDescription('Accuracy of SFN')
sfn1ppsErrorState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 9), TruthValue()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: sfn1ppsErrorState.setStatus('current')
if mibBuilder.loadTexts: sfn1ppsErrorState.setDescription('1PPS error detected')
sfn10MHzErrorState = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 4, 9, 10), TruthValue()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: sfn10MHzErrorState.setStatus('current')
if mibBuilder.loadTexts: sfn10MHzErrorState.setDescription('10MHz error detected')
flexDSR04EventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5))
tunerRfPowerEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1))
tunerRfPowerEventValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1, 1), Integer32()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerRfPowerEventValue.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEventValue.setDescription('RF power reference value')
tunerRfPowerEventTolerance = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1, 2), Integer32()).setUnits('dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerRfPowerEventTolerance.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEventTolerance.setDescription('RF power tolerance (amount of allowed variation of the actual RF power value compared to the reference value)')
tunerRfPowerEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerRfPowerEventT1.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEventT1.setDescription('The time period for which the value must be incorrect before the alarm will get triggered')
tunerRfPowerEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerRfPowerEventT2.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
tunerRfPowerEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerRfPowerEventEnable.setStatus('current')
if mibBuilder.loadTexts: tunerRfPowerEventEnable.setDescription('Enable the monitoring for this parameter')
tunerCnEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 2))
tunerCnEventMinValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 2, 1), Integer32()).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerCnEventMinValue.setStatus('current')
if mibBuilder.loadTexts: tunerCnEventMinValue.setDescription('Tuner C/N minimum value considered OK')
tunerCnEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 2, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerCnEventT1.setStatus('current')
if mibBuilder.loadTexts: tunerCnEventT1.setDescription('The time period for which the value must be incorrect before the alarm will get triggered')
tunerCnEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 2, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerCnEventT2.setStatus('current')
if mibBuilder.loadTexts: tunerCnEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
tunerCnEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 2, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerCnEventEnable.setStatus('current')
if mibBuilder.loadTexts: tunerCnEventEnable.setDescription('Enable the monitoring for this parameter')
tunerBerEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 3))
tunerBerEventMaxValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 3, 1), FloatString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerBerEventMaxValue.setStatus('current')
if mibBuilder.loadTexts: tunerBerEventMaxValue.setDescription('Tuner BER maximum value considered OK')
tunerBerEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 3, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerBerEventT1.setStatus('current')
if mibBuilder.loadTexts: tunerBerEventT1.setDescription('The time period for which the value must be incorrect before the alarm will get triggered')
tunerBerEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 3, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerBerEventT2.setStatus('current')
if mibBuilder.loadTexts: tunerBerEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
tunerBerEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 3, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerBerEventEnable.setStatus('current')
if mibBuilder.loadTexts: tunerBerEventEnable.setDescription('Enable the monitoring for this parameter')
tunerTsSyncEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 4))
tunerTsSyncEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 4, 1), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerTsSyncEventT1.setStatus('current')
if mibBuilder.loadTexts: tunerTsSyncEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
tunerTsSyncEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 4, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerTsSyncEventT2.setStatus('current')
if mibBuilder.loadTexts: tunerTsSyncEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
tunerTsSyncEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 4, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tunerTsSyncEventEnable.setStatus('current')
if mibBuilder.loadTexts: tunerTsSyncEventEnable.setDescription('Enable the monitoring for this parameter')
asiTsSyncEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 5))
asiTsSyncEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 5, 1), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiTsSyncEventT1.setStatus('current')
if mibBuilder.loadTexts: asiTsSyncEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
asiTsSyncEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 5, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiTsSyncEventT2.setStatus('current')
if mibBuilder.loadTexts: asiTsSyncEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
asiTsSyncEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 5, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asiTsSyncEventEnabled.setStatus('current')
if mibBuilder.loadTexts: asiTsSyncEventEnabled.setDescription('Enable the monitoring for this parameter')
ipTsSyncEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 6))
ipTsSyncEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 6, 1), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipTsSyncEventT1.setStatus('current')
if mibBuilder.loadTexts: ipTsSyncEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
ipTsSyncEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 6, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipTsSyncEventT2.setStatus('current')
if mibBuilder.loadTexts: ipTsSyncEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
ipTsSyncEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 6, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipTsSyncEventEnabled.setStatus('current')
if mibBuilder.loadTexts: ipTsSyncEventEnabled.setDescription('Enable the monitoring for this parameter')
etr290ConformityEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 7))
etr290ConformityEventEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 7, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: etr290ConformityEventEnable.setStatus('obsolete')
if mibBuilder.loadTexts: etr290ConformityEventEnable.setDescription('Enable the monitoring for this parameter')
aoipUdpInputDataEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8))
aoipUdpInputDataEventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1), )
if mibBuilder.loadTexts: aoipUdpInputDataEventTable.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventTable.setDescription('Settings for the different Audio over IP (UDP) channel alarms')
aoipUdpInputDataEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1), ).setIndexNames((0, "FLEXDSR04", "aoipUdpInputDataEventIndex"))
if mibBuilder.loadTexts: aoipUdpInputDataEventEntry.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventEntry.setDescription('Settings for one Audio over IP (UDP) channel alarm')
aoipUdpInputDataEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: aoipUdpInputDataEventIndex.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventIndex.setDescription('Audio over IP (UDP) channel index')
aoipUdpInputDataEventChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("channel1", 1), ("channel2", 2), ("channel3", 3), ("channel4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aoipUdpInputDataEventChannel.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventChannel.setDescription('Audio over IP (UDP) channel')
aoipUdpInputDataEventT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipUdpInputDataEventT1.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
aoipUdpInputDataEventT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipUdpInputDataEventT2.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
aoipUdpInputDataEventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 8, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipUdpInputDataEventEnabled.setStatus('current')
if mibBuilder.loadTexts: aoipUdpInputDataEventEnabled.setDescription('Enable the monitoring for this parameter')
aoipIcecastInputDataEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9))
aoipIcecastInputDataEventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1), )
if mibBuilder.loadTexts: aoipIcecastInputDataEventTable.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventTable.setDescription('Settings for the different Audio over IP (Icecast) server alarms')
aoipIcecastInputDataEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1), ).setIndexNames((0, "FLEXDSR04", "aoipIcecastInputDataEventIndex"))
if mibBuilder.loadTexts: aoipIcecastInputDataEventEntry.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventEntry.setDescription('Settings for one Audio over IP (Icecast) server alarm')
aoipIcecastInputDataEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: aoipIcecastInputDataEventIndex.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventIndex.setDescription('Audio over IP (Icecast) server index')
aoipIcecastInputDataEventServer = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("server1", 1), ("server2", 2), ("server3", 3), ("server4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aoipIcecastInputDataEventServer.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventServer.setDescription('Audio over IP (Icecast) server')
aoipIcecastInputDataEventT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipIcecastInputDataEventT1.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
aoipIcecastInputDataEventT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipIcecastInputDataEventT2.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
aoipIcecastInputDataEventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 9, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aoipIcecastInputDataEventEnabled.setStatus('current')
if mibBuilder.loadTexts: aoipIcecastInputDataEventEnabled.setDescription('Enable the monitoring for this parameter')
audioEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10))
audioEventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1), )
if mibBuilder.loadTexts: audioEventTable.setStatus('current')
if mibBuilder.loadTexts: audioEventTable.setDescription('Settings for the different audio alarms (presence/absence of audio data)')
audioEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1), ).setIndexNames((0, "FLEXDSR04", "audioEventIndex"))
if mibBuilder.loadTexts: audioEventEntry.setStatus('current')
if mibBuilder.loadTexts: audioEventEntry.setDescription('Settings for one audio alarm')
audioEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioEventIndex.setStatus('current')
if mibBuilder.loadTexts: audioEventIndex.setDescription('Audio channel index')
audioEventChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("audio1", 1), ("audio2", 2), ("audio3", 3), ("audio4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioEventChannel.setStatus('current')
if mibBuilder.loadTexts: audioEventChannel.setDescription('Audio channel')
audioEventT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioEventT1.setStatus('current')
if mibBuilder.loadTexts: audioEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
audioEventT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioEventT2.setStatus('current')
if mibBuilder.loadTexts: audioEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
audioEventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 10, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioEventEnabled.setStatus('current')
if mibBuilder.loadTexts: audioEventEnabled.setDescription('Enable the monitoring for this parameter')
audioLevelEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11))
audioLevelEventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1), )
if mibBuilder.loadTexts: audioLevelEventTable.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventTable.setDescription('Settings for the different audio level alarms (silence detection)')
audioLevelEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1), ).setIndexNames((0, "FLEXDSR04", "audioLevelEventIndex"))
if mibBuilder.loadTexts: audioLevelEventEntry.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventEntry.setDescription('Settings for one audio level alarm')
audioLevelEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: audioLevelEventIndex.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventIndex.setDescription('Description.')
audioLevelEventChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("audio1", 1), ("audio2", 2), ("audio3", 3), ("audio4", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: audioLevelEventChannel.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventChannel.setDescription('Description.')
audioLevelEventMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 3), Integer32()).setUnits('dBFS').setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioLevelEventMinValue.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventMinValue.setDescription('Minimum audio level considered not to be silence')
audioLevelEventT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioLevelEventT1.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventT1.setDescription('The time period for which the value must be faulty before the alarm will get triggered')
audioLevelEventT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 5), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioLevelEventT2.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
audioLevelEventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 11, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: audioLevelEventEnabled.setStatus('current')
if mibBuilder.loadTexts: audioLevelEventEnabled.setDescription('Enable the monitoring for this parameter')
dteEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12))
dteEventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1), )
if mibBuilder.loadTexts: dteEventTable.setStatus('current')
if mibBuilder.loadTexts: dteEventTable.setDescription('Settings for the different DTE alarms (presence/absence of DTE data)')
dteEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1), ).setIndexNames((0, "FLEXDSR04", "dteEventIndex"))
if mibBuilder.loadTexts: dteEventEntry.setStatus('current')
if mibBuilder.loadTexts: dteEventEntry.setDescription('Settings for one DTE alarm')
dteEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: dteEventIndex.setStatus('current')
if mibBuilder.loadTexts: dteEventIndex.setDescription('DTE port index')
dteEventPort = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("dte1", 1), ("dte2", 2), ("dte3", 3), ("dte4", 4), ("dte5", 5), ("dte6", 6), ("dte7", 7), ("dte8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dteEventPort.setStatus('current')
if mibBuilder.loadTexts: dteEventPort.setDescription('DTE port')
dteEventT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1, 3), Integer32()).setUnits('min').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dteEventT1.setStatus('current')
if mibBuilder.loadTexts: dteEventT1.setDescription('The time period for which the status must be faulty before the alarm will get triggered')
dteEventT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1, 4), Integer32()).setUnits('min').setMaxAccess("readwrite")
if mibBuilder.loadTexts: dteEventT2.setStatus('current')
if mibBuilder.loadTexts: dteEventT2.setDescription('The time period for which the status must be OK before the alarm will be retracted')
dteEventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 12, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dteEventEnabled.setStatus('current')
if mibBuilder.loadTexts: dteEventEnabled.setDescription('Enable the monitoring for this parameter')
internalStorageEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 13))
internalStorageEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 13, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: internalStorageEventEnabled.setStatus('current')
if mibBuilder.loadTexts: internalStorageEventEnabled.setDescription('Enable the monitoring for this parameter')
caseTemperatureEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 14))
caseTemperatureEventMaxValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 14, 1), Integer32()).setUnits('degree Celsius').setMaxAccess("readwrite")
if mibBuilder.loadTexts: caseTemperatureEventMaxValue.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureEventMaxValue.setDescription('Maximum case temperature value considered OK')
caseTemperatureEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 14, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: caseTemperatureEventT1.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureEventT1.setDescription('The time period for which the value must be faulty before the alarm will get triggered')
caseTemperatureEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 14, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caseTemperatureEventT2.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
caseTemperatureEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 14, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: caseTemperatureEventEnabled.setStatus('current')
if mibBuilder.loadTexts: caseTemperatureEventEnabled.setDescription('Enable the monitoring for this parameter')
sfnClockEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 18))
sfnClockEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 18, 1), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfnClockEventT1.setStatus('current')
if mibBuilder.loadTexts: sfnClockEventT1.setDescription('The time period for which the value must be faulty before the alarm will get triggered')
sfnClockEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 18, 2), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfnClockEventT2.setStatus('current')
if mibBuilder.loadTexts: sfnClockEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
sfnClockEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 18, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sfnClockEventEnabled.setStatus('current')
if mibBuilder.loadTexts: sfnClockEventEnabled.setDescription('Enable the monitoring for this parameter')
ipPerEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19))
ipPerEventMode = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("combinedStream", 1), ("mainStream", 2), ("bothStreams", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPerEventMode.setStatus('current')
if mibBuilder.loadTexts: ipPerEventMode.setDescription('Selecting the stream to measure PER')
ipPerEventValue = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19, 2), FloatString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPerEventValue.setStatus('current')
if mibBuilder.loadTexts: ipPerEventValue.setDescription('IP PER value considered OK')
ipPerEventT1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPerEventT1.setStatus('current')
if mibBuilder.loadTexts: ipPerEventT1.setDescription('The time period for which the value must be faulty before the alarm will get triggered')
ipPerEventT2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19, 4), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPerEventT2.setStatus('current')
if mibBuilder.loadTexts: ipPerEventT2.setDescription('The time period for which the value must be OK before the alarm will be retracted')
ipPerEventEnabled = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 19, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipPerEventEnabled.setStatus('current')
if mibBuilder.loadTexts: ipPerEventEnabled.setDescription('Enable the monitoring for this parameter')
generalEventSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90))
flexDSR04EventTable = MibTable((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1), )
if mibBuilder.loadTexts: flexDSR04EventTable.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventTable.setDescription('Description.')
flexDSR04EventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1, 1), ).setIndexNames((0, "FLEXDSR04", "flexDSR04EventIndex"))
if mibBuilder.loadTexts: flexDSR04EventEntry.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventEntry.setDescription('Description.')
flexDSR04EventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 19)))
if mibBuilder.loadTexts: flexDSR04EventIndex.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventIndex.setDescription('Index of event entry')
flexDSR04EventType = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("tunerRfPowerEvent", 1), ("tunerCnEvent", 2), ("tunerBerEvent", 3), ("tunerTsSyncEvent", 4), ("asiTsSyncEvent", 5), ("ipTsSyncEvent", 6), ("aoipUdpInputDataEvent", 8), ("aoipIcecastInputDataEvent", 9), ("audioEvent", 10), ("audioLevelEvent", 11), ("dteEvent", 12), ("internalStorageEvent", 13), ("caseTemperatureEvent", 14), ("inputSourceEvent", 15), ("remoteControlUploadEvent", 16), ("optoInputEvent", 17), ("sfnClockEvent", 18), ("ipPerEvent", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: flexDSR04EventType.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventType.setDescription('event type')
flexDSR04EventPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flexDSR04EventPriority.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventPriority.setDescription('Priority of the event')
flexDSR04EventEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 90, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: flexDSR04EventEnabled.setStatus('current')
if mibBuilder.loadTexts: flexDSR04EventEnabled.setDescription('Enable/disable sending of the events to the specified trap destination(s)')
allEventsEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 5, 99), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allEventsEnable.setStatus('current')
if mibBuilder.loadTexts: allEventsEnable.setDescription('Enable/disable signaling of all events')
control = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6))
networkSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1))
tcpIp = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1))
hostname = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostname.setStatus('current')
if mibBuilder.loadTexts: hostname.setDescription('Host name')
ip = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ip.setStatus('current')
if mibBuilder.loadTexts: ip.setDescription('Device IP address')
subnetmask = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: subnetmask.setStatus('current')
if mibBuilder.loadTexts: subnetmask.setDescription('Subnet mask')
gateway = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gateway.setStatus('current')
if mibBuilder.loadTexts: gateway.setDescription('IP address of the gateway')
primaryDns = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: primaryDns.setStatus('current')
if mibBuilder.loadTexts: primaryDns.setDescription('IP address of primary DNS')
secondaryDns = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: secondaryDns.setStatus('current')
if mibBuilder.loadTexts: secondaryDns.setDescription('IP address of secondary DNS')
snmpSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 2))
snmpTrapIP1 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapIP1.setStatus('current')
if mibBuilder.loadTexts: snmpTrapIP1.setDescription('IP address of first SNMP manager')
snmpTrapIP2 = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapIP2.setStatus('current')
if mibBuilder.loadTexts: snmpTrapIP2.setDescription('IP address of second SNMP manager')
snmpTrapIP1Enable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 2, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapIP1Enable.setStatus('current')
if mibBuilder.loadTexts: snmpTrapIP1Enable.setDescription('Enable/disable sending of events to first SNMP manager')
snmpTrapIP2Enable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 2, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapIP2Enable.setStatus('current')
if mibBuilder.loadTexts: snmpTrapIP2Enable.setDescription('Enable/disable sending of events to second SNMP manager')
sntpSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3))
sntpFirstServerIP = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpFirstServerIP.setStatus('current')
if mibBuilder.loadTexts: sntpFirstServerIP.setDescription('IP address of first SNTP server')
sntpSecondServerIP = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpSecondServerIP.setStatus('current')
if mibBuilder.loadTexts: sntpSecondServerIP.setDescription('IP address of second SNTP server')
sntpUpdateInterval = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3, 3), Integer32()).setUnits('sec').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpUpdateInterval.setStatus('current')
if mibBuilder.loadTexts: sntpUpdateInterval.setDescription('SNTP update interval')
sntpTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpTimeOffset.setStatus('current')
if mibBuilder.loadTexts: sntpTimeOffset.setDescription('Local time offset')
sntpUpdateEnable = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 3, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpUpdateEnable.setStatus('current')
if mibBuilder.loadTexts: sntpUpdateEnable.setDescription('Enable/disable real time clock update via SNTP')
httpSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 4))
httpPort = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 1, 4, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: httpPort.setStatus('current')
if mibBuilder.loadTexts: httpPort.setDescription('HTTP port')
commands = MibIdentifier((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 10))
reStartDevice = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 10, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: reStartDevice.setStatus('current')
if mibBuilder.loadTexts: reStartDevice.setDescription('Set to 1 to perform a restart of the device (will internally be reset to 0)')
asciiCommand = MibScalar((1, 3, 6, 1, 4, 1, 21529, 3, 2, 4, 6, 10, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asciiCommand.setStatus('current')
if mibBuilder.loadTexts: asciiCommand.setDescription("Set a new ASCII command e.g. 'AUDIO1_F0CP 100'")
mibBuilder.exportSymbols("FLEXDSR04", dteUecpPI=dteUecpPI, internalStorageEvent=internalStorageEvent, audioOutput1InputSource=audioOutput1InputSource, scTunerRfPowerValue=scTunerRfPowerValue, audioOutput3InputSourceEnabled=audioOutput3InputSourceEnabled, audioLevel=audioLevel, sntpSettings=sntpSettings, tunerBerEventEnable=tunerBerEventEnable, tcpIp=tcpIp, aoipUdpInputDataEventTable=aoipUdpInputDataEventTable, scAudioOverIpUdpT2=scAudioOverIpUdpT2, switchCriteriaIpPer=switchCriteriaIpPer, tunerTsSyncEvent=tunerTsSyncEvent, remoteControlUploadFile=remoteControlUploadFile, tunerTsSyncEventEnable=tunerTsSyncEventEnable, remoteControlUploadEvent=remoteControlUploadEvent, udpInputDataIndex=udpInputDataIndex, audioEventTable=audioEventTable, flexDSR04Events=flexDSR04Events, sfn10MHzErrorCount=sfn10MHzErrorCount, tunerTsSyncEventSettings=tunerTsSyncEventSettings, switchCriteriaInternalStorage=switchCriteriaInternalStorage, sntpTimeOffset=sntpTimeOffset, scTunerTsSyncT1=scTunerTsSyncT1, tunerDatarate=tunerDatarate, optoInputEvent=optoInputEvent, dtePort=dtePort, audioOutput4InputSource=audioOutput4InputSource, audioOutput1InputSourceEnabled=audioOutput1InputSourceEnabled, aoipIcecastInputDataEventT1=aoipIcecastInputDataEventT1, icecastInputDataEntry=icecastInputDataEntry, scAudioOverIpIcecastT1=scAudioOverIpIcecastT1, scInternalStorageEnabled=scInternalStorageEnabled, scTunerBerMaxValue=scTunerBerMaxValue, sfnClockEventT2=sfnClockEventT2, internalStorageTable=internalStorageTable, switchCriteriaTunerTsSync=switchCriteriaTunerTsSync, subnetmask=subnetmask, ipPerEvent=ipPerEvent, tsIpPacketDuplicate=tsIpPacketDuplicate, audioOverIpState=audioOverIpState, sfnClockEvent=sfnClockEvent, tsIpBufferlevel1=tsIpBufferlevel1, switchCriteriaTunerRfPower=switchCriteriaTunerRfPower, audioEventSettings=audioEventSettings, audioLayer=audioLayer, optoInputNumber=optoInputNumber, aoipUdpInputDataEventSettings=aoipUdpInputDataEventSettings, ipOutputTable=ipOutputTable, tunerCnEventT1=tunerCnEventT1, audioOutput4InputSourceEnabled=audioOutput4InputSourceEnabled, scIpPerEnabled=scIpPerEnabled, tunerRfPowerEventEnable=tunerRfPowerEventEnable, dteEventEntry=dteEventEntry, scTunerTsSyncEnabled=scTunerTsSyncEnabled, currentInputSourceOrder=currentInputSourceOrder, flexDSR04EventPriority=flexDSR04EventPriority, caseTemperatureEventMaxValue=caseTemperatureEventMaxValue, aoipIcecastInputDataEventSettings=aoipIcecastInputDataEventSettings, rtpUdpInputDataRtpPacketloss=rtpUdpInputDataRtpPacketloss, scTunerRfPowerEnabled=scTunerRfPowerEnabled, dteEventT1=dteEventT1, rsBchBerValue=rsBchBerValue, scTunerRfPowerT2=scTunerRfPowerT2, flexDSR04EventEnabled=flexDSR04EventEnabled, tsIpPacketUnrecoverable=tsIpPacketUnrecoverable, eventParams=eventParams, scIpTsSyncT2=scIpTsSyncT2, switchCriteriaIpTsSync=switchCriteriaIpTsSync, tsState=tsState, nid=nid, audioAlarmActive=audioAlarmActive, internalStorageEntry=internalStorageEntry, tunerAlarmEntry=tunerAlarmEntry, primaryDns=primaryDns, internalStorageIndex=internalStorageIndex, scAudioOverIpIcecastT2=scAudioOverIpIcecastT2, xlrInterface=xlrInterface, tsIpErroneousPacketrate=tsIpErroneousPacketrate, icecastInputDataState=icecastInputDataState, generalEventSettings=generalEventSettings, dteEntry=dteEntry, scTunerCnMinValue=scTunerCnMinValue, dteInterface=dteInterface, audioOutput3Order=audioOutput3Order, scIpTsSyncT1=scIpTsSyncT1, scTunerRfPowerTolerance=scTunerRfPowerTolerance, tsIpPacketReordered=tsIpPacketReordered, ipPerEventMode=ipPerEventMode, remoteControlUploadError=remoteControlUploadError, internalStorageFree=internalStorageFree, tsSyncState=tsSyncState, currentInputSourceState=currentInputSourceState, audioTsTable=audioTsTable, ipPerEventT2=ipPerEventT2, sfnBufferlevel=sfnBufferlevel, internalStorageQuotaUsed=internalStorageQuotaUsed, xlrOutputType=xlrOutputType, udpInputDataAlarmActive=udpInputDataAlarmActive, headphoneAudioChannel=headphoneAudioChannel, punctureRate=punctureRate, audioTable=audioTable, audioBufferlevel=audioBufferlevel, rtpUdpInputDataEntry=rtpUdpInputDataEntry, scTunerCnEnabled=scTunerCnEnabled, dteUecpTP=dteUecpTP, audioEventIndex=audioEventIndex, dteEventEnabled=dteEventEnabled, dteIndex=dteIndex, switchCriteriaTunerCn=switchCriteriaTunerCn, audioLevelEventEntry=audioLevelEventEntry, tunerTsSyncEventT1=tunerTsSyncEventT1, dteUecpPS=dteUecpPS, switchCriteriaAudioOverIpIcecast=switchCriteriaAudioOverIpIcecast, tsIpFecL=tsIpFecL, aoipIcecastInputDataEventIndex=aoipIcecastInputDataEventIndex, inputSourceEvent=inputSourceEvent, sntpFirstServerIP=sntpFirstServerIP, scIpTsSyncEnabled=scIpTsSyncEnabled, dteInterfacePort=dteInterfacePort, flexDSR04EventType=flexDSR04EventType, aoipIcecastInputDataEventServer=aoipIcecastInputDataEventServer, icecastInputDataServer=icecastInputDataServer, tsIpBufferReset=tsIpBufferReset, ipTsSyncEventEnabled=ipTsSyncEventEnabled, tunerBerEventSettings=tunerBerEventSettings, asiTsSyncEventEnabled=asiTsSyncEventEnabled, sfnState=sfnState, asiOutputIndex=asiOutputIndex, xlrVolumeEntry=xlrVolumeEntry, sntpUpdateInterval=sntpUpdateInterval, xlrVolumePort=xlrVolumePort, sfnActive=sfnActive, optoInputTable=optoInputTable, aoipIcecastInputDataEventEnabled=aoipIcecastInputDataEventEnabled, ipOutputEntry=ipOutputEntry, audioLevelEventTable=audioLevelEventTable, aoipIcecastInputDataEventTable=aoipIcecastInputDataEventTable, tsIpFecD=tsIpFecD, scTunerRfPowerT1=scTunerRfPowerT1, tunerRfPowerEventTolerance=tunerRfPowerEventTolerance, audioLevelEventT2=audioLevelEventT2, aoipUdpInputDataEventChannel=aoipUdpInputDataEventChannel, rtpUdpInputDataRtpDataRate=rtpUdpInputDataRtpDataRate, currentInputSourceTable=currentInputSourceTable, dteState=dteState, snmpTrapIP2=snmpTrapIP2, sfnClockEventT1=sfnClockEventT1, audioOutput1Index=audioOutput1Index, gateway=gateway, dteInterfaceIndex=dteInterfaceIndex, tunerAlarmTable=tunerAlarmTable, dteEventT2=dteEventT2, networkSettings=networkSettings, currentInputSourceEntry=currentInputSourceEntry, scAudioOverIpIcecastEnabled=scAudioOverIpIcecastEnabled, allEventsEnable=allEventsEnable, tsIpBackupPLR=tsIpBackupPLR, remoteControlUploadType=remoteControlUploadType, cnValue=cnValue, audioEventT2=audioEventT2, audioOutput3InputSource=audioOutput3InputSource, inputSourceState=inputSourceState, scTunerBerEnabled=scTunerBerEnabled, asiTsSyncEventT2=asiTsSyncEventT2, ipTsSyncEventT2=ipTsSyncEventT2, flexDSR04=flexDSR04, audioOutput2Index=audioOutput2Index, tsIpBackupPER=tsIpBackupPER, outputType=outputType, audioLevelEventMinValue=audioLevelEventMinValue, tunerCnEventMinValue=tunerCnEventMinValue, audioLevelEvent=audioLevelEvent, audioOutput4Index=audioOutput4Index, audioOutput4Order=audioOutput4Order, PYSNMP_MODULE_ID=flexDSR04, flexDSR04EventEntry=flexDSR04EventEntry, sfnTransmissionDelay=sfnTransmissionDelay, scAsiTsSyncT1=scAsiTsSyncT1, tsIpDualInput=tsIpDualInput, ipOutputInputSource=ipOutputInputSource, snmpTrapIP1=snmpTrapIP1, audioEventChannel=audioEventChannel, audioOutput1Table=audioOutput1Table, tunerBerEventMaxValue=tunerBerEventMaxValue, etr290ConformityEventEnable=etr290ConformityEventEnable, internalStorageEventEnabled=internalStorageEventEnabled, aoipUdpInputDataEvent=aoipUdpInputDataEvent, audioEvent=audioEvent, scAsiTsSyncT2=scAsiTsSyncT2, audioLowPass15kHz=audioLowPass15kHz, sfnClockEventSettings=sfnClockEventSettings, scTunerCnT1=scTunerCnT1, aoipUdpInputDataEventT2=aoipUdpInputDataEventT2, ipPerEventEnabled=ipPerEventEnabled, internalStorageEventSettings=internalStorageEventSettings, flexDSR04EventSettings=flexDSR04EventSettings, audioTsService=audioTsService, internalStorageFreeMemory=internalStorageFreeMemory, scTunerTsSyncT2=scTunerTsSyncT2, tunerCnEventT2=tunerCnEventT2, tunerBerEventT1=tunerBerEventT1, ipOutputInputSourceEnabled=ipOutputInputSourceEnabled, aoipUdpInputDataEventT1=aoipUdpInputDataEventT1, flexDSR04EventTable=flexDSR04EventTable, aoipIcecastInputDataEventEntry=aoipIcecastInputDataEventEntry, audioOutput3Entry=audioOutput3Entry, audioEventEnabled=audioEventEnabled, audioNoDataAvailabe=audioNoDataAvailabe, caseTemperatureEventT1=caseTemperatureEventT1, switchCriteria=switchCriteria, ip=ip, dteEventIndex=dteEventIndex, audioLevelEventEnabled=audioLevelEventEnabled, remoteControlUploadEventParams=remoteControlUploadEventParams, xlrVolumeIndex=xlrVolumeIndex, snmpTrapIP1Enable=snmpTrapIP1Enable, tsIpPacketPerIpPacket=tsIpPacketPerIpPacket, sfn10MHzErrorState=sfn10MHzErrorState, tsSyncEntry=tsSyncEntry, tsIpPER=tsIpPER, rtpUdpInputDataPackets=rtpUdpInputDataPackets, tsIpPacketDropped=tsIpPacketDropped, internalStorageState=internalStorageState, tsIpBackupErroneousPacketrate=tsIpBackupErroneousPacketrate, sfn1ppsErrorCount=sfn1ppsErrorCount, caseTemperatureEventSettings=caseTemperatureEventSettings, tsIpSync=tsIpSync, switchCriteriaAsiTsSync=switchCriteriaAsiTsSync, dteUecpCT=dteUecpCT, audioOutput1Entry=audioOutput1Entry, dteInterfaceTable=dteInterfaceTable, scIpPerValue=scIpPerValue, tunerAlarmIndex=tunerAlarmIndex, internalStorageSection=internalStorageSection, currentInputSourceIndex=currentInputSourceIndex, asiOutputEntry=asiOutputEntry, tunerAlarmActive=tunerAlarmActive, tsSyncType=tsSyncType, caseTemperatureEventEnabled=caseTemperatureEventEnabled, audioPLLlevel=audioPLLlevel, tsSyncAlarmActive=tsSyncAlarmActive, sfnAccuracy=sfnAccuracy, rtpUdpInputDataTable=rtpUdpInputDataTable, audioSampleRate=audioSampleRate, rtpUdpInputDataIndex=rtpUdpInputDataIndex, tsSyncIndex=tsSyncIndex, rfPowerValue=rfPowerValue, optoInputEntry=optoInputEntry, ipTsSyncEventT1=ipTsSyncEventT1, control=control, tsIpPLR=tsIpPLR, etr290ConformityEventSettings=etr290ConformityEventSettings, agcState=agcState)
mibBuilder.exportSymbols("FLEXDSR04", audioOutput4Entry=audioOutput4Entry, ipPerEventValue=ipPerEventValue, dteInterfaceBaudrate=dteInterfaceBaudrate, audioOutput2InputSource=audioOutput2InputSource, xlrVolumeAnalog=xlrVolumeAnalog, deviceState=deviceState, secondaryDns=secondaryDns, asiOutputOrder=asiOutputOrder, dteUecpPTY=dteUecpPTY, hostname=hostname, flexDSR04EventIndex=flexDSR04EventIndex, optoInputState=optoInputState, etr290ConformityEvent=etr290ConformityEvent, audioStatus=audioStatus, dteInterfaceEntry=dteInterfaceEntry, etr290ConformityAlarmActive=etr290ConformityAlarmActive, tsIpBufferlevel2=tsIpBufferlevel2, sntpSecondServerIP=sntpSecondServerIP, xlrVolumeTable=xlrVolumeTable, udpInputDataEntry=udpInputDataEntry, dteUecpTA=dteUecpTA, scIpPerT2=scIpPerT2, internalStorageQuota=internalStorageQuota, audioOutput1Order=audioOutput1Order, switchCriteriaTunerBer=switchCriteriaTunerBer, httpSettings=httpSettings, etr290Conformity=etr290Conformity, viterbiLdpcBerValue=viterbiLdpcBerValue, caseTemperatureEventT2=caseTemperatureEventT2, ceState=ceState, commands=commands, ipTsSyncEventSettings=ipTsSyncEventSettings, dteAlarmActive=dteAlarmActive, tunerBerEvent=tunerBerEvent, tunerCnEventSettings=tunerCnEventSettings, dteEventSettings=dteEventSettings, carrierState=carrierState, tunerRfPowerEvent=tunerRfPowerEvent, ipPerEventT1=ipPerEventT1, aoipUdpInputDataEventEnabled=aoipUdpInputDataEventEnabled, tsIpBufferlevel3=tsIpBufferlevel3, tunerBerEventT2=tunerBerEventT2, ipOutputOrder=ipOutputOrder, audioLevelEventT1=audioLevelEventT1, audioLevelEventIndex=audioLevelEventIndex, optoInputIndex=optoInputIndex, audioLevelEventChannel=audioLevelEventChannel, tsOverIp=tsOverIp, audioEventT1=audioEventT1, scAudioOverIpUdpT1=scAudioOverIpUdpT1, audioOutput4Table=audioOutput4Table, scAudioOverIpUdpEnabled=scAudioOverIpUdpEnabled, icecastInputDataIndex=icecastInputDataIndex, tunerCnEvent=tunerCnEvent, aoipIcecastInputDataEvent=aoipIcecastInputDataEvent, audioTsMode=audioTsMode, udpInputDataTable=udpInputDataTable, asiOutputInputSource=asiOutputInputSource, aoipUdpInputDataEventEntry=aoipUdpInputDataEventEntry, audioChannel=audioChannel, tsSyncTable=tsSyncTable, aoipUdpInputDataEventIndex=aoipUdpInputDataEventIndex, aoipIcecastInputDataEventT2=aoipIcecastInputDataEventT2, scIpPerMode=scIpPerMode, rtpUdpInputDataIpRawDataRate=rtpUdpInputDataIpRawDataRate, sfnGlobalDelay=sfnGlobalDelay, audioIndex=audioIndex, caseTemperature=caseTemperature, audioDecoderResets=audioDecoderResets, ipTsSyncEvent=ipTsSyncEvent, tsIpModePER=tsIpModePER, headphoneVolume=headphoneVolume, audioOutput2Table=audioOutput2Table, tsIpPacketRestored=tsIpPacketRestored, fecLockedState=fecLockedState, audioTsPID=audioTsPID, tunerRfPowerEventValue=tunerRfPowerEventValue, ipDatarate=ipDatarate, snmpTrapIP2Enable=snmpTrapIP2Enable, scTunerCnT2=scTunerCnT2, asiTsSyncEvent=asiTsSyncEvent, asiOutputInputSourceEnabled=asiOutputInputSourceEnabled, audioOutput3Index=audioOutput3Index, audioLevelAlarmActive=audioLevelAlarmActive, headphoneInterface=headphoneInterface, tunerRfPowerEventSettings=tunerRfPowerEventSettings, icecastInputDataTable=icecastInputDataTable, tunerState=tunerState, caseTemperatureEvent=caseTemperatureEvent, udpInputDataChannel=udpInputDataChannel, httpPort=httpPort, ServiceMode=ServiceMode, tunerAlarmType=tunerAlarmType, audioEntry=audioEntry, dteEventPort=dteEventPort, audioTsIndex=audioTsIndex, tsIpCombinedPER=tsIpCombinedPER, state=state, xlrVolumeDigital=xlrVolumeDigital, asiTsSyncEventT1=asiTsSyncEventT1, scIpPerT1=scIpPerT1, scTunerBerT1=scTunerBerT1, udpInputDataState=udpInputDataState, audioLevelEventSettings=audioLevelEventSettings, dteDataAvailable=dteDataAvailable, tunerCnEventEnable=tunerCnEventEnable, audioOutput3Table=audioOutput3Table, currentInputSourceType=currentInputSourceType, asciiCommand=asciiCommand, icecastInputDataAlarmActive=icecastInputDataAlarmActive, caseTemperatureAlarmActive=caseTemperatureAlarmActive, asiDatarate=asiDatarate, InputSource=InputSource, snmpSettings=snmpSettings, sfn1ppsErrorState=sfn1ppsErrorState, asiOutputTable=asiOutputTable, symTimeState=symTimeState, sntpUpdateEnable=sntpUpdateEnable, asiTsSyncEventSettings=asiTsSyncEventSettings, dteTable=dteTable, sfnClockEventEnabled=sfnClockEventEnabled, tunerRfPowerEventT1=tunerRfPowerEventT1, cfoErrorValue=cfoErrorValue, tunerTsSyncEventT2=tunerTsSyncEventT2, ipPerEventSettings=ipPerEventSettings, ipOutputIndex=ipOutputIndex, audioOutput2InputSourceEnabled=audioOutput2InputSourceEnabled, dteUecpRT=dteUecpRT, remoteControlUploadGroup=remoteControlUploadGroup, scAsiTsSyncEnabled=scAsiTsSyncEnabled, sfnResetCount=sfnResetCount, lockedState=lockedState, audioBitRate=audioBitRate, audioEventEntry=audioEventEntry, inputSourceSettings=inputSourceSettings, audioTsError=audioTsError, reStartDevice=reStartDevice, tunerRfPowerEventT2=tunerRfPowerEventT2, dteEvent=dteEvent, switchCriteriaAudioOverIpUdp=switchCriteriaAudioOverIpUdp, audioTsEntry=audioTsEntry, interfaceSettings=interfaceSettings, dteEventTable=dteEventTable, audioVersion=audioVersion, audioOutput2Entry=audioOutput2Entry, audioOutput2Order=audioOutput2Order, scTunerBerT2=scTunerBerT2, audioState=audioState)
