#
# PySNMP MIB module LANTRONIX-SLC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///home/runner/work/mibs/mibs/src/vendor/lantronix/LANTRONIX-SLC-MIB.mib
# Produced by pysmi-1.1.12 at Wed Dec  4 17:56:53 2024
# On host fv-az2036-124 platform Linux version 6.5.0-1025-azure by user runner
# Using Python version 3.10.15 (main, Sep  9 2024, 03:02:45) [GCC 11.4.0]
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
products, = mibBuilder.importSymbols("LANTRONIX-MIB", "products")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Counter64, ModuleIdentity, IpAddress, NotificationType, Bits, Counter32, MibIdentifier, iso, Gauge32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter64", "ModuleIdentity", "IpAddress", "NotificationType", "Bits", "Counter32", "MibIdentifier", "iso", "Gauge32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Unsigned32")
TextualConvention, MacAddress, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString")
slc = ModuleIdentity((1, 3, 6, 1, 4, 1, 244, 1, 1))
slc.setRevisions(('2016-04-17 00:00', '2015-02-24 00:00', '2014-07-10 00:00', '2013-12-06 00:00', '2013-02-20 00:00', '2010-04-07 00:00', '2010-01-19 00:00', '2009-12-09 00:00', '2008-01-09 00:00', '2007-06-25 00:00', '2007-02-20 00:00', '2007-02-07 00:00', '2006-10-20 00:00', '2006-07-14 00:00', '2006-05-12 00:00', '2006-02-13 00:00', '2005-10-03 00:00', '2005-06-09 00:00', '2004-12-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: slc.setRevisionsDescriptions(('Added slc*IPv6 objects for new IPv6-related support, \n                  added slcNetEthIfMacAddress, slcServSysRPMLogSize, \n                  slcServSysOtherLogSize, slcServSSHDSAKeys, \n                  slcDevPortCfgMinimizeLatency, slcDevPortCfgTelnetSoftIAC, \n                  slcDevPortCfgSendTermString, slcDevPortCfgTerminationString, \n                  slcDevPortCfgPowerManagementSeq, slcDevPortCfgPowerSupplies, \n                  slcDevPortCfgToggleDTR, slcDevPortCfgTokenAction,\n                  slcDevPortCfgTokenSendString, slcDevPortCfgTokenPowerSupply, \n                  slcDevPortCfgTokenPowerAction, and slcDevRPM section.', 'Added slcServSSHTimeoutDataDirection, \n                  slcServTelnetTimeoutDataDirection, slcDevPortCfgUSBVBUS,  \n                  slcDevPortCfgAssertDTR, slcDevPortCfgPortType, \n                  slcDevPortCfgTelnetTimeoutDataDirection, \n                  slcDevPortCfgSSHTimeoutDataDirection, \n                  slcDevPortCfgTCPTimeoutDataDirection, \n                  slcDevPortCfgIdleTimeoutMessage, \n                  slcDevPortCfgNumberOfSessionsMessage, and\n                  slcSystemWebServer.', 'Added slcNetSecurityFIPSMode, slcDevPortCfgDevPrompt, \n                  slcDevPortCfgDevNumOutlets, slcDevPortCfgDevNumExpOutlets, \n                  slcDevIntModem section, slcEventSDCardAction, and \n                  slcEventNoDialToneAlarm.', 'Added slcDevPortCfgReversePinout.', 'Added slcNetVPN section, slcServSNMPv1v2, slcServSNMPNMS2, \n                  slcServSiteDialbackRetries, slcAuthLDAPUserFilter, \n                  slcAuthLDAPGroupFilter, slcAuthLDAPGroupMembershipAttr, \n                  slcAuthLDAPGroupMembershipDN, slcAuthRADIUSUseVSA, \n                  slcAuthGroups section, slcDevConGroup, \n                  slcDevPortCfgDialbackRetries, slcDevPortCfgGroup, \n                  slcDevPortCfgIPMask, slcPCCardCfgDialbackRetries, \n                  slcPCCardCfgGroup, slcDevUSBCfgDialbackRetries, \n                  slcDevUSBCfgDialtoneCheck, slcDevUSBCfgGroup, \n                  slcSystemModelString, slcSystemWebGroup, \n                  slcSystemWebInterface, slcSystemInternalTempLow, \n                  slcSystemInternalTempHigh, slcSystemCalibrateTemp, \n                  slcSystemWebBanner, slcDevPortErrorStatus, and \n                  slcEventDevicePortError.', 'Added slcDevPortCfgCHAPAuthLocalUsers, slcDevPortCfgUseSites,\n                  slcPCCardCfgCHAPAuthLocalUsers, slcPCCardCfgUseSites, \n                  slcDevUSBCfgCHAPAuthLocalUsers, slcDevUSBCfgUseSites, and \n                  the slcServSite section.', 'Added slcDevPortCfgUSBState, slcDevPortCfgUSBLogTo, \n                  slcDevPortCfgUSBMaxFiles, slcDevPortCfgUSBMaxSize, \n                  slcDevUSB section and slcEventUSBAction.', 'Added slcNetEthIfMTU, slcNetEthIPv6, slcNetEthBonding, \n                  slcServTelnetTelnetOut, slcServWebTermDeployment, \n                  slcServWebTermBufSize, slcServSMTPSender, \n                  slcAuthLocalAllowReuse, slcAuthLocalReuseHistory, \n                  slcAuthLocalPasswordLifetime, slcAuthLocalWarningPeriod, \n                  slcAuthLocalMaxLoginAttempts, slcAuthLocalLockoutPeriod, \n                  slcAuthLocalMultipleSysadminLogins,\n                  slcAuthLocalSysadminConsoleOnly, slcAuthNISDialback, \n                  slcAuthNISDialbackNum, slcAuthLDAPBindWithLogin, \n                  slcAuthLDAPUseLDAPSchema, slcAuthLDAPDialback, \n                  slcAuthLDAPDialbackNum, slcAuthRADIUSDialback, \n                  slcAuthRADIUSDialbackNum, slcAuthKerbDialback, \n                  slcAuthKerbDialbackNum, slcAuthTACACSDialback, \n                  slcAuthTACACSDialbackNum, slcAuthRemoteUserMenu, \n                  slcAuthRemoteUserLocked, slcAuthRemoteUserDialback, \n                  slcAuthRemoteUserDialbackNum, slcDevConNumberShowLines, \n                  slcDevPortCfgNumberShowLines, slcDevPortCfgViewPortLog, \n                  slcDevPortCfgPortLogSeq, slcDevPortCfgMaxDirectConnects, \n                  slcDevPortCfgTelnetTimeout, slcDevPortCfgSSHTimeout,\n                  slcDevPortCfgTCPTimeout, slcDevPortCfgCBCPClientType,\n                  slcDevPortCfgCBCPServerAllowNoCallback,\n                  slcDevPortCfgDialbackDelay, slcPCCardCfgCBCPClientType, \n                  slcPCCardCfgCBCPServerAllowNoCallback,\n                  slcPCCardCfgDialbackDelay, slcSystemSSHPreAuthBanner, \n                  slcSystemSiteRackRow, slcSystemSiteRackCluster, \n                  slcSystemSiteRack, slcSystemLCDScreens, \n                  slcSystemLCDUserStrLine1, slcSystemLCDUserStrLine2, \n                  slcSystemLCDScrolling, slcSystemLCDScrollDelay, \n                  slcSystemLCDIdleDelay, slcSystemInternalTemp, \n                  slcSystemWebProtocol, slcSystemWebCipher, \n                  slcEventPCCardAction and slcEventSLCInternalTemp.', 'Added slcServSNMPv3ReadWriteUser, slcServSNMPv3Security, \n                  slcServSNMPv3Authentication, slcServSNMPv3Encryption, \n                  slcServHostList objects, slcAuthNISEscapeSeq, \n                  slcAuthNISBreakSeq, slcAuthLDAPEscapeSeq, \n                  slcAuthLDAPBreakSeq, slcAuthRADIUSEscapeSeq, \n                  slcAuthRADIUSBreakSeq, slcAuthKerbEscapeSeq, \n                  slcAuthKerbBreakSeq, slcAuthTACACSEscapeSeq, \n                  slcAuthTACACSBreakSeq, slcAuthRemoteUserEscapeSeq, \n                  slcAuthRemoteUserBreakSeq, slcDevConShowLines, \n                  slcDevPortCfgHostList, slcPCCardCfgHostList, \n                  slcDevPortCfgDevLowTemp, slcDevPortCfgDevHighTemp, \n                  slcDevPortCfgDevTemperature, slcDevPortCfgDevLowHumidity, \n                  slcDevPortCfgDevHighHumidity, slcDevPortCfgDevHumidity, \n                  slcDevPortCfgDevTraps, slcDevPortCfgShowLines, \n                  slcSystemWebGadget, slcSystemAction, \n                  slcEventDevicePortDevice* notifications.', 'Added slcNetEthAlternateGateway, slcNetEthPingIPAddress, \n                  slcNetEthPingInterface, slcNetEthPingDelay, \n                  slcNetEthPingFailed, slcServSNMPTrapCommunity, \n                  slcServSNMPAlarmDelay, slcServPhoneHome section,\n                  slcDevPortCfgWebColumns, slcDevPortCfgWebRows and \n                  slcDevPortCfgSyslogState.', 'Added slcDevPortCfgSLMLoggingState, slcDevPortCfgSLMNMS, \n                  slcDevPortCfgSLMByteThresh and slcDevPortCfgSLMTimeFrame.', 'Added slcNetEthIfIPv6Addr and slcNetEthIfIPv6PrefixLength.', 'Added slcNetFirewallRuleset* objects, slcNetFirewallMapping* \n                  objects, slcAuthLDAPEncrypt, slcAuthTACACSServer2, \n                  slcAuthTACACSServer3, slcDevPortCfgDODAuth, \n                  slcDevPortCfgDODCHAPHost, slcPCCardCfgDODAuth, and \n                  slcPCCardCfgDODCHAPHost.  Obsoleted slcNetFirewallReject, \n                  slcNetFirewallPing, slcNetFirewallSSH, slcNetFirewallTelnet, \n                  slcNetFirewallHTTP, slcNetFirewallHTTPS and \n                  slcNetFirewallSMBCIFS.  Added dialinAndDialondemand(6) to \n                  slcDevPortCfgModemState and slcPCCardCfgModemState.', 'Added slcServSysRemoteServer2, slcServAuditInSystemLog, \n                  slcAuthLocalState, slcAuthLocalOrder, \n                  slcAuthLocalComplexPasswords, slcAuthLocalUseNextMethod, \n                  slcAuthRemoteUserListenPorts, slcAuthRemoteUserDataPorts, \n                  slcAuthRemoteUserClearPorts, slcAuthRemoteAuthListOnly, \n                  slcDevPortCfgIdleTimeout, slcDevPortCfgRestartDelay, \n                  slcDevPortCfgCallerIdLogging, slcDevPortCfgCallerIdATCmd, \n                  slcPCCardCfgIdleTimeout, slcPCCardCfgRestartDelay, \n                  slcPCCardCfgCallerIdLogging, slcPCCardCfgCallerIdATCmd. \n                  Added dialondemand(5) to slcDevPortCfgModemState and \n                  slcPCCardCfgModemState.', 'Added slcNetEthDomain, slcServNTPLocalServer2, \n                  slcServNTPLocalServer3, slcServSSHV1Incoming, \n                  slcAuthNISSlave4, slcAuthNISSlave5, \n                  slcPCCardCfgGSMPPPCompression, slcPCCardCfgGSMAutoAcquireDNS,\n                  slcPCCardCfgGSMDialoutMode, slcPCCardCfgGSMContextID, \n                  slcPCCardCfgGSMBearerService.  Obsoleted \n                  slcPCCardCfgGSMNetworkName.', 'Added SLCAuthRemote group.  Added slcServAuditIncludeCLI, \n                  slcAuthLocalUserGroup, slcAuthLocalUserRights, \n                  slcAuthNISGroup, slcAuthNISRights, slcAuthNISMenu, \n                  slcAuthNISListenPorts, slcAuthNISDataPorts, \n                  slcAuthNISClearPorts, slcAuthLDAPGroup, slcAuthLDAPRights, \n                  slcAuthLDAPMenu, slcAuthLDAPListenPorts, \n                  slcAuthLDAPDataPorts, slcAuthLDAPClearPorts, \n                  slcAuthRADIUSGroup, slcAuthRADIUSRights, slcAuthRADIUSMenu, \n                  slcAuthRADIUSListenPorts, slcAuthRADIUSDataPorts, \n                  slcAuthRADIUSClearPorts, slcAuthKerbGroup, slcAuthKerbRights, \n                  slcAuthKerbMenu, slcAuthKerbListenPorts, \n                  slcAuthKerbDataPorts, slcAuthKerbClearPorts, \n                  slcAuthTACACSGroup, slcAuthTACACSRights, slcAuthTACACSMenu, \n                  slcAuthTACACSListenPorts, slcAuthTACACSDataPorts, \n                  slcAuthTACACSClearPorts, slcDevGlobalMaxDirect, \n                  slcSystemWebTimeout, slcPCCardCfgTelnetState, \n                  slcPCCardCfgTelnetPort, slcPCCardCfgTelnetAuth, \n                  slcPCCardCfgSSHState, slcPCCardCfgSSHPort, \n                  slcPCCardCfgSSHAuth, slcPCCardCfgTCPState, \n                  slcPCCardCfgTCPPort, slcPCCardCfgTCPAuth, slcPCCardCfgGSMPIN, \n                  slcPCCardCfgGSMNetworkName.  Added slcEventDevicePortSLMData \n                  and slcEventDevicePortSLMConfig traps.  Added Textual \n                  Convention UserGroup and UserRights.  Obsoleted \n                  slcDevGlobalListenPorts, slcDevGlobalDataPorts and\n                  slcDevGlobalClearPorts.', 'Added slcServSSHPort.', 'Added slcServSSHTimeout, slcServSSHWebSSH, \n                  slcServSNMPReadOnlyCommunity, slcServSNMPReadWriteCommunity, \n                  slcDevPortCfgAction, slcDevPortCfgEmailSend, \n                  slcDevPortCfgBanner, slcPCCardCfgISDNChannel, \n                  slcPCCardCfgISDNChannelNum, slcConnDurationStr, slcConnIdle,\n                  slcConnIdleStr, slcConnSourceIP, slcSystemWelcomeBanner, \n                  slcSystemLoginBanner, slcSystemLogoutBanner. \n                  Added sftp(3) to slcSystemLoadVia.', 'Initial version.',))
if mibBuilder.loadTexts: slc.setLastUpdated('201604170000Z')
if mibBuilder.loadTexts: slc.setOrganization('Lantronix, Inc.')
if mibBuilder.loadTexts: slc.setContactInfo('Lantronix Technical Support\n                  167 Technology Drive \n                  Irvine, CA 92618 USA \n                  +1 800 526-8766 \n                  snmp@lantronix.com')
if mibBuilder.loadTexts: slc.setDescription('MIB module for managing Lantronix Secure Console Managers \n                  and Advanced Console Managers')
class EnabledState(TextualConvention, Integer32):
    description = 'The enabled/disabled state of an SLC feature.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disabled", 1), ("enabled", 2))

class AuthOrder(TextualConvention, Integer32):
    description = 'Authentication order for a remote authentication method.  \n                If the authentication method is disabled, AuthOrder = 0.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 6)

class SyslogLevel(TextualConvention, Integer32):
    description = 'Syslog logging levels'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("off", 1), ("info", 2), ("warning", 3), ("error", 4), ("debug", 5))

class UserGroup(TextualConvention, Integer32):
    description = 'The group assigned to a user.  Each group has a set of user \n                 rights associated with it.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("default", 1), ("power", 2), ("administrators", 3), ("custom", 4))

class UserRights(TextualConvention, OctetString):
    description = 'The rights assigned to a user.  Each group has a set of user \n                 rights associated with it.  The string is a comma-separated \n                 list of rights:\n                   ad - full administrative rights\n                   do - Device Ports operations\n                   dp - configure Device Ports\n                   dr - Diagnostics and Reports\n                   dt - configure Date and Time\n                   fc - manage Firmware and Configurations\n                   lu - configure Local Users\n                   md - configure Internal Modem\n                   nt - configure Networking\n                   pc - configure PC Card\n                   ra - configure Remote Authentication\n                   rp - manage Remote Power Managers\n                   rs - Reboot or Shutdown the SLC\n                   sd - manage SD Card\n                   sk - configure SSH Keys\n                   sn - configure Secure Ltx Network\n                   sv - configure Services\n                   ub - configure USB Devices\n                   um - configure User Menus\n                   wb - Web Access'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class TimeoutDataDirection(TextualConvention, Integer32):
    description = 'The direction of data used to determine if a connection has \n                 timed out.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("incomingNetwork", 1), ("outgoingNetwork", 2), ("bothDirections", 3))

class RPMTowerIndex(TextualConvention, Integer32):
    description = 'The unique identifier for an RPM tower or unit.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2)

class RPMOutletIndex(TextualConvention, Integer32):
    description = 'The unique identifier for an RPM outlet.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 60)

slcNetwork = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1))
slcServices = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2))
slcAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3))
slcDevices = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4))
slcConnections = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 5))
slcSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 6))
slcNetEth = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1))
slcNetEthIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfNumber.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfNumber.setDescription('The number of entries in the Ethernet interface table.')
slcNetEthIfTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2), )
if mibBuilder.loadTexts: slcNetEthIfTable.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfTable.setDescription('Table of Ethernet network entries.  The number of entries is \n                 given by the value of slcNetEthIfNumber.')
slcNetEthIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcNetEthIfIndex"))
if mibBuilder.loadTexts: slcNetEthIfEntry.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfEntry.setDescription('An entry with the attributes for each Ethernet interface.  Ethernet \n         Port Eth1 is always index 1, and Eth2 is always index 2.')
slcNetEthIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfIndex.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfIndex.setDescription('Reference index for each Ethernet interface.')
slcNetEthIfSource = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("dhcp", 2), ("bootp", 3), ("static", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfSource.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfSource.setDescription('The state/source for the IP Address and subnet mask for the \n                 Ethernet interface.')
slcNetEthIfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("autoNegotiate", 1), ("halfDuplex10mbit", 2), ("fullDuplex10mbit", 3), ("halfDuplex100mbit", 4), ("fullDuplex100mbit", 5), ("halfDuplex1000mbit", 6), ("fullDuplex1000mbit", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfMode.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfMode.setDescription('The speed and duplex for the Ethernet interface.')
slcNetEthIfIPv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 4), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfIPv6Addr.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfIPv6Addr.setDescription('The IPv6 Address for each Ethernet interface.')
slcNetEthIfIPv6PrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)))
if mibBuilder.loadTexts: slcNetEthIfIPv6PrefixLength.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfIPv6PrefixLength.setDescription('The length of the prefix for slcNetEthIfIPv6Addr (in bits).')
slcNetEthIfMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfMTU.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfMTU.setDescription('The Maximum Transmission Unit for the Ethernet interface.')
slcNetEthIfMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 2, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIfMacAddress.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIfMacAddress.setDescription('The MAC Address for the Ethernet interface.')
slcNetEthGateway = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthGateway.setStatus('current')
if mibBuilder.loadTexts: slcNetEthGateway.setDescription('The gateway for routing non-Eth1 and non-Eth2 network IPv4 \n                 traffic.')
slcNetEthGatewayPrecedence = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dhcp", 1), ("default", 2), ("gprs", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthGatewayPrecedence.setStatus('current')
if mibBuilder.loadTexts: slcNetEthGatewayPrecedence.setDescription('The gateway to give precedence to, if both a static gateway \n                 is set, and a gateway is acquired via DHCP or a GPRS Modem.')
slcNetEthKeepaliveStartProbes = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthKeepaliveStartProbes.setStatus('current')
if mibBuilder.loadTexts: slcNetEthKeepaliveStartProbes.setDescription('TCP keepalive timer: number of seconds to wait before sending \n                 out the initial probe.')
slcNetEthKeepaliveNumberOfProbes = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthKeepaliveNumberOfProbes.setStatus('current')
if mibBuilder.loadTexts: slcNetEthKeepaliveNumberOfProbes.setDescription('TCP keepalive timer: number of probes to send out after the \n                 initial probe.')
slcNetEthKeepaliveInterval = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthKeepaliveInterval.setStatus('current')
if mibBuilder.loadTexts: slcNetEthKeepaliveInterval.setDescription('TCP keepalive timer: number of seconds between probes.')
slcNetEthIPForwarding = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 8), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIPForwarding.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIPForwarding.setDescription('If enabled, IP forwarding is used.')
slcNetEthDNS1 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS1.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS1.setDescription('The IPv4 Address of DNS server #1.')
slcNetEthDNS2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS2.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS2.setDescription('The IPv4 Address of DNS server #2.')
slcNetEthDNS3 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS3.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS3.setDescription('The IPv4 Address of DNS server #3.')
slcNetEthDomain = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDomain.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDomain.setDescription('The SLC domain name.')
slcNetEthAlternateGateway = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthAlternateGateway.setStatus('current')
if mibBuilder.loadTexts: slcNetEthAlternateGateway.setDescription('The alternate gateway for routing non-Eth1 and non-Eth2 \n                 network traffic.  The alternate gateway is used if an \n                 IP Address usually accessible through the default gateway \n                 fails to return one or more pings.')
slcNetEthPingIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthPingIPAddress.setStatus('current')
if mibBuilder.loadTexts: slcNetEthPingIPAddress.setDescription('The IP Address to ping to determine if the alternate gateway \n                 should be used.')
slcNetEthPingInterface = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet1", 1), ("ethernet2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthPingInterface.setStatus('current')
if mibBuilder.loadTexts: slcNetEthPingInterface.setDescription('The Ethernet interface used to determine if the alternate \n                 gateway should be used.')
slcNetEthPingDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthPingDelay.setStatus('current')
if mibBuilder.loadTexts: slcNetEthPingDelay.setDescription('The delay, in seconds, between pings used to determine if the \n                 alternate gateway should be used.')
slcNetEthPingFailed = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 250))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthPingFailed.setStatus('current')
if mibBuilder.loadTexts: slcNetEthPingFailed.setDescription('The number of pings with no response required for the \n                 alternate gateway to be used.')
slcNetEthBonding = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("activeBackup", 2), ("aggregation", 3), ("adaptiveLoadBalancing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthBonding.setStatus('current')
if mibBuilder.loadTexts: slcNetEthBonding.setDescription('The Ethernet network redundancy/load balancing setting.')
slcNetEthIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 19), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthIPv6.setStatus('current')
if mibBuilder.loadTexts: slcNetEthIPv6.setDescription('If enabled, IPv6 is enabled.')
slcNetEthGatewayIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 20), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthGatewayIPv6.setStatus('current')
if mibBuilder.loadTexts: slcNetEthGatewayIPv6.setDescription('The default gateway for routing non-Eth1 and non-Eth2 IPv6 \n                 network traffic.')
slcNetEthDNS1IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 21), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS1IPv6.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS1IPv6.setDescription('The IPv6 Address of DNS server #1.')
slcNetEthDNS2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 22), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS2IPv6.setDescription('The IPv6 Address of DNS server #2.')
slcNetEthDNS3IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 23), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthDNS3IPv6.setStatus('current')
if mibBuilder.loadTexts: slcNetEthDNS3IPv6.setDescription('The IPv6 Address of DNS server #3.')
slcNetEthPreferIPv4DNS = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 1, 24), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetEthPreferIPv4DNS.setStatus('current')
if mibBuilder.loadTexts: slcNetEthPreferIPv4DNS.setDescription('If enabled, IPv4 DNS records will be preferred when DNS \n                 hostname lookups are performed. Otherwise IPv6 records will \n                 be preferred (when IPv6 is enabled).')
slcNetFirewall = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2))
slcNetFirewallState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallState.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallState.setDescription('If enabled, network traffic is filtered.')
slcNetFirewallReject = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("return", 1), ("ignore", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallReject.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallReject.setDescription("If enabled, returns a 'connection denied' message on blocked \n                 ports.  If disabled, ignores attempts to connect to a blocked \n                 port.  This object is deprecated.")
slcNetFirewallPing = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallPing.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallPing.setDescription('If enabled, the SLC is invisible to pings.  This object is \n                deprecated.')
slcNetFirewallSSH = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallSSH.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallSSH.setDescription('If enabled, the SSH port is open.  If disabled, the SSH \n                 port is blocked to network traffic.  This object is \n                 deprecated.')
slcNetFirewallTelnet = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 5), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallTelnet.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallTelnet.setDescription('If enabled, the Telnet port is open.  If disabled, the Telnet \n                 port is blocked to network traffic.  This object is \n                 deprecated.')
slcNetFirewallHTTP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 6), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallHTTP.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallHTTP.setDescription('If enabled, the HTTP port is open.  If disabled, the HTTP \n                 port is blocked to network traffic.  This object is \n                 deprecated.')
slcNetFirewallHTTPS = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallHTTPS.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallHTTPS.setDescription('If enabled, the HTTPS port is open.  If disabled, the HTTPS \n                 port is blocked to network traffic.  This object is \n                 deprecated.')
slcNetFirewallSMBCIFS = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 8), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallSMBCIFS.setStatus('obsolete')
if mibBuilder.loadTexts: slcNetFirewallSMBCIFS.setDescription('If enabled, the SMBCIFS port is open.  If disabled, the \n                 SMBCIFS port is blocked to network traffic.  This object is \n                 deprecated.')
slcNetFirewallRulesetNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallRulesetNumber.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetNumber.setDescription('The number of entries in the IP Filter Ruleset table.')
slcNetFirewallRulesetTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10), )
if mibBuilder.loadTexts: slcNetFirewallRulesetTable.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetTable.setDescription('Table of IP Filter Rulesets.  The number of entries is \n                 given by the value of slcNetFirewallRulesetNumber.')
slcNetFirewallRulesetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcNetFirewallRulesetIndex"))
if mibBuilder.loadTexts: slcNetFirewallRulesetEntry.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetEntry.setDescription('An entry with all the attributes, including the rules, for \n                 an IP Filter Ruleset.')
slcNetFirewallRulesetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallRulesetIndex.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetIndex.setDescription('Reference index for each IP Filter Ruleset.')
slcNetFirewallRulesetName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallRulesetName.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetName.setDescription('The name assigned to the IP Filter Ruleset.')
slcNetFirewallRulesetNumRules = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallRulesetNumRules.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetNumRules.setDescription('The number of rules in the slcNetFirewallRulesetRules string.')
slcNetFirewallRulesetRules = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 10, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallRulesetRules.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallRulesetRules.setDescription('The IP Filter rules that are defined for the Ruleset.  The \n                 rule format is <IP>/<Mask Bits>;<Protocol>;<Ports>;<Action> \n                 and rules are separated by a colon.  If the string is \n                 truncated because of system limitations, the string will be \n                 terminated with two colons.')
slcNetFirewallMappingNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallMappingNumber.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingNumber.setDescription('The number of entries in the IP Filter Mapping table.')
slcNetFirewallMappingTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12), )
if mibBuilder.loadTexts: slcNetFirewallMappingTable.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingTable.setDescription('Table of mappings between IP Filter Rulesets and interfaces.  \n                 The number of entries is given by the value of \n                 slcNetFirewallMappingNumber.')
slcNetFirewallMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcNetFirewallMappingIndex"))
if mibBuilder.loadTexts: slcNetFirewallMappingEntry.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingEntry.setDescription('An entry defining an interface that has an IP Filter Ruleset \n                 assigned to it.  The interface can be either an Ethernet \n                 interface or a PC Card or Device Port modem.')
slcNetFirewallMappingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallMappingIndex.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingIndex.setDescription('Reference index for each IP Filter mapping.')
slcNetFirewallMappingIfac = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ethernet1", 1), ("ethernet2", 2), ("upperPCCard", 3), ("lowerPCCard", 4), ("devicePort", 5), ("usbPort", 6), ("internalModem", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallMappingIfac.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingIfac.setDescription('The interface which has an IP Filter Ruleset assigned to it.  \n                 If the interface is devicePort or usbPort, \n                 slcNetFirewallMappingIfacId defines which Device Port or USB \n                 Port (with an attached modem) the Ruleset is assigned to.')
slcNetFirewallMappingIfacId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallMappingIfacId.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingIfacId.setDescription('The identifier for a Device Port if slcNetFirewallMappingIfac \n                 equals devicePort(5), or the identifier for a USB Port if\n                 slcNetFirewallMappingIfac equals usbPort.  Otherwise equals \n                 zero.')
slcNetFirewallMappingRuleset = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 2, 12, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetFirewallMappingRuleset.setStatus('current')
if mibBuilder.loadTexts: slcNetFirewallMappingRuleset.setDescription('The name of the IP Filter Ruleset assigned to the interface.')
slcNetRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3))
slcNetRouteRIPState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteRIPState.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteRIPState.setDescription('If enabled, the Routing Information Protocol (RIP) is used.')
slcNetRouteRIPVersion = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("oneAndTwo", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteRIPVersion.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteRIPVersion.setDescription('The version of RIP being used.')
slcNetRouteStaticState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticState.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticState.setDescription('If enabled, static routing is used.')
slcNetRouteStaticNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticNumber.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticNumber.setDescription('The number of entries in the Static Routes table.')
slcNetRouteStaticTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5), )
if mibBuilder.loadTexts: slcNetRouteStaticTable.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticTable.setDescription('Table of static route entries.  The number of entries is \n                 given by the value of slcNetRouteStaticNumber.')
slcNetRouteStaticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcNetRouteStaticIndex"))
if mibBuilder.loadTexts: slcNetRouteStaticEntry.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticEntry.setDescription('An entry with the IP Address, subnet mask, and gateway \n                 for a static route.')
slcNetRouteStaticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticIndex.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticIndex.setDescription('Reference index for each static route.')
slcNetRouteStaticIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticIP.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticIP.setDescription('The IP Address for the static route.')
slcNetRouteStaticMask = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticMask.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticMask.setDescription('The subnet mask for the static route.')
slcNetRouteStaticGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 3, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetRouteStaticGateway.setStatus('current')
if mibBuilder.loadTexts: slcNetRouteStaticGateway.setDescription('The gateway for the static route.')
slcNetVPN = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4))
slcNetVPNTunnel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNTunnel.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNTunnel.setDescription('If enabled, the SLC is configured to initiate a VPN tunnel.')
slcNetVPNStatus = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNStatus.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNStatus.setDescription('A string giving the current status of the VPN tunnel.')
slcNetVPNName = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNName.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNName.setDescription('The name of the VPN tunnel.')
slcNetVPNEthPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet1", 1), ("ethernet2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNEthPort.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNEthPort.setDescription('The Ethernet interface used for the VPN tunnel.')
slcNetVPNRemoteHost = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNRemoteHost.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNRemoteHost.setDescription('The IP Address of the host on the remote side of the tunnel.')
slcNetVPNRemoteId = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNRemoteId.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNRemoteId.setDescription('How the remote host should be identified for authentication.')
slcNetVPNRemoteHop = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNRemoteHop.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNRemoteHop.setDescription("If the remote host is behind a gateway, this specifies the \n                 IP Address of the gateway's public network interface.")
slcNetVPNRemoteSubnet = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNRemoteSubnet.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNRemoteSubnet.setDescription('One or more subnets behind the remote host, expressed in \n                 CIDR notation (IP Address/mask bits).  Multiple subnets are \n                 separated by a comma.')
slcNetVPNLocalId = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNLocalId.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNLocalId.setDescription('How the SLC should be identified for authentication.')
slcNetVPNLocalHop = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNLocalHop.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNLocalHop.setDescription("If the SLC is behind a gateway, this specifies the \n                 IP Address of the gateway's public network interface.")
slcNetVPNLocalSubnet = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNLocalSubnet.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNLocalSubnet.setDescription('One or more subnets behind the SLC, expressed in \n                 CIDR notation (IP Address/mask bits).  Multiple subnets are \n                 separated by a comma.')
slcNetVPNIKENegotiation = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("aggressive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNIKENegotiation.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNIKENegotiation.setDescription('The type of mode used by the SLC and the remote host for the \n                 IKE protocol, which exchanges security options between two \n                 hosts which want to communicate via IPSec.')
slcNetVPNIKEEncryption = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("tripledes", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNIKEEncryption.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNIKEEncryption.setDescription('The type of encryption used for IKE negotiation.')
slcNetVPNIKEAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("sha1", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNIKEAuthentication.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNIKEAuthentication.setDescription('The type of authentication used for IKE negotiation.')
slcNetVPNIKEDHGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("dhg2", 2), ("dhg5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNIKEDHGroup.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNIKEDHGroup.setDescription('The type of Diffie-Hellman Group used for IKE negotiation.')
slcNetVPNESPEncryption = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("tripledes", 2), ("aes", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNESPEncryption.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNESPEncryption.setDescription('The type of encryption used for encrypting data sent through \n                 the tunnel.')
slcNetVPNESPAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("sha1", 2), ("md5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNESPAuthentication.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNESPAuthentication.setDescription('The type of authentication used for authenticating data sent \n                 through the VPN tunnel.')
slcNetVPNESPDHGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("any", 1), ("dhg2", 2), ("dhg5", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNESPDHGroup.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNESPDHGroup.setDescription('The type of Diffie-Hellman Group used for the key exchange \n                 for data sent through the tunnel.')
slcNetVPNAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rsaPublicKey", 1), ("preSharedKey", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNAuthentication.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNAuthentication.setDescription('The type of authentication used by the host on each side of \n                 the tunnel to verify the identify of the other host.')
slcNetVPNPerfectForwardSecrecy = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 20), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNPerfectForwardSecrecy.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNPerfectForwardSecrecy.setDescription('When a new IPSec SA is negotiated after the IPSec SA lifetime \n                 expires, a new Diffie-Hellman key exchange can be performed \n                 to generate a new session key to be used to encrypt the data \n                 being sent through the tunnel. If this is enabled, it provides \n                 greater security, since the old session keys are destroyed.')
slcNetVPNModeConfigClient = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 21), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNModeConfigClient.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNModeConfigClient.setDescription('If this is enabled, the SLC can receive network configuration \n                 from the remote host. This allows the remote host to assign \n                 an IP address/netmask to the SLC side of the VPN tunnel.')
slcNetVPNXAUTHClient = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 22), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNXAUTHClient.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNXAUTHClient.setDescription('If this is enabled, the SLC will send authentication \n                 credentials to the remote host if they are requested. \n                 XAUTH, or Extended Authentication, can be used as an \n                 additional security measure on top of the Pre-Shared Key \n                 or RSA Public Key.')
slcNetVPNXAUTHClientLogin = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 4, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetVPNXAUTHClientLogin.setStatus('current')
if mibBuilder.loadTexts: slcNetVPNXAUTHClientLogin.setDescription('If slcNetVPNXAUTHClientLogin is enabled, this is the login \n                 used for authentication.')
slcNetSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 5))
slcNetSecurityFIPSMode = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 1, 5, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcNetSecurityFIPSMode.setStatus('current')
if mibBuilder.loadTexts: slcNetSecurityFIPSMode.setDescription('If enabled, the SLC is running in FIPS mode.')
slcServNTP = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1))
slcServNTPState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPState.setStatus('current')
if mibBuilder.loadTexts: slcServNTPState.setDescription('If enabled, NTP is used to synchronize SLC time with a \n                 network time server.')
slcServNTPSynchronize = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("broadcast", 1), ("poll", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPSynchronize.setStatus('current')
if mibBuilder.loadTexts: slcServNTPSynchronize.setDescription('The method used by the SLC to synchronize time: receive \n                 broadcasts from the NTP server, or poll the NTP server.')
slcServNTPPoll = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("public", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPPoll.setStatus('current')
if mibBuilder.loadTexts: slcServNTPPoll.setDescription('If slcServNTPSynchronize is set to poll, indicates whether \n                 a local server or a public server is used as the NTP server.')
slcServNTPServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPServer.setStatus('current')
if mibBuilder.loadTexts: slcServNTPServer.setDescription('The IPv4 Address of the local or public NTP server.')
slcServNTPLocalServer2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPLocalServer2.setStatus('current')
if mibBuilder.loadTexts: slcServNTPLocalServer2.setDescription('The IPv4 Address of the 2nd local NTP server.')
slcServNTPLocalServer3 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPLocalServer3.setStatus('current')
if mibBuilder.loadTexts: slcServNTPLocalServer3.setDescription('The IPv4 Address of the 3rd local NTP server.')
slcServNTPServerIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 7), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPServerIPv6.setStatus('current')
if mibBuilder.loadTexts: slcServNTPServerIPv6.setDescription('The IPv6 Address of the local NTP server.')
slcServNTPLocalServer2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 8), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPLocalServer2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcServNTPLocalServer2IPv6.setDescription('The IPv6 Address of the 2nd local NTP server.')
slcServNTPLocalServer3IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 1, 9), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNTPLocalServer3IPv6.setStatus('current')
if mibBuilder.loadTexts: slcServNTPLocalServer3IPv6.setDescription('The IPv6 Address of the 3rd local NTP server.')
slcServSyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2))
slcServSysNetworkLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 1), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysNetworkLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysNetworkLevel.setDescription('The logging level for Network messages.')
slcServSysServicesLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 2), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysServicesLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysServicesLevel.setDescription('The logging level for Services messages.')
slcServSysAuthLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 3), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysAuthLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysAuthLevel.setDescription('The logging level for Authentication messages.')
slcServSysDevPortLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 4), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysDevPortLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysDevPortLevel.setDescription('The logging level for Device Port messages.')
slcServSysDiagLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 5), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysDiagLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysDiagLevel.setDescription('The logging level for Diagnostic messages.')
slcServSysGeneralLevel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 6), SyslogLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysGeneralLevel.setStatus('current')
if mibBuilder.loadTexts: slcServSysGeneralLevel.setDescription('The logging level for General system messages.')
slcServSysRemoteServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysRemoteServer.setStatus('current')
if mibBuilder.loadTexts: slcServSysRemoteServer.setDescription('The IPv4 Address of the remote Syslog Server.')
slcServSysRemoteServer2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysRemoteServer2.setStatus('current')
if mibBuilder.loadTexts: slcServSysRemoteServer2.setDescription('The IPv4 Address of the secondary remote Syslog Server.')
slcServSysRemoteServerIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 9), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysRemoteServerIPv6.setStatus('current')
if mibBuilder.loadTexts: slcServSysRemoteServerIPv6.setDescription('The IPv6 Address of the remote Syslog Server.')
slcServSysRemoteServer2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 10), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysRemoteServer2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcServSysRemoteServer2IPv6.setDescription('The IPv6 Address of the secondary remote Syslog Server.')
slcServSysRPMLogSize = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 40))).setUnits('Kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysRPMLogSize.setStatus('current')
if mibBuilder.loadTexts: slcServSysRPMLogSize.setDescription('The maximum size in Kilobytes that RPM logs can grow to \n                 before they are pruned.  When the file is pruned, it will\n                 be pruned to 50% of the RPM Log Size.')
slcServSysOtherLogSize = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 2, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 40))).setUnits('Kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSysOtherLogSize.setStatus('current')
if mibBuilder.loadTexts: slcServSysOtherLogSize.setDescription('The maximum size in Kilobytes that all logs other than RPM \n                 logs can grow to before they are pruned.  When the file is \n                 pruned, it will be pruned to 50% of the RPM Log Size.')
slcServAuditLog = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 3))
slcServAuditState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 3, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServAuditState.setStatus('current')
if mibBuilder.loadTexts: slcServAuditState.setDescription('If enabled, logs all configuration changes to an audit log.')
slcServAuditSize = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 500))).setUnits('Kilobytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServAuditSize.setStatus('current')
if mibBuilder.loadTexts: slcServAuditSize.setDescription('The maximum size of the audit login in Kilobytes.')
slcServAuditIncludeCLI = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 3, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServAuditIncludeCLI.setStatus('current')
if mibBuilder.loadTexts: slcServAuditIncludeCLI.setDescription('If enabled, all CLI commands are included in the audit log in \n                 addition to a description of the configuration change.')
slcServAuditInSystemLog = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 3, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServAuditInSystemLog.setStatus('current')
if mibBuilder.loadTexts: slcServAuditInSystemLog.setDescription('If enabled, all audit log entries are also sent to the system \n                 log.')
slcServSSH = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4))
slcServSSHState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHState.setStatus('current')
if mibBuilder.loadTexts: slcServSSHState.setDescription('If enabled, allows logins to the SLC CLI via SSH.')
slcServSSHTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHTimeout.setStatus('current')
if mibBuilder.loadTexts: slcServSSHTimeout.setDescription('The timeout (in minutes) for SSH connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcServSSHWebSSH = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHWebSSH.setStatus('current')
if mibBuilder.loadTexts: slcServSSHWebSSH.setDescription('If enabled, allows Web SSH access to the CLI and the \n                 Device Ports.')
slcServSSHPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHPort.setStatus('current')
if mibBuilder.loadTexts: slcServSSHPort.setDescription('The TCP Port number for incoming SSH sessions to the SLC CLI.')
slcServSSHV1Incoming = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 5), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHV1Incoming.setStatus('current')
if mibBuilder.loadTexts: slcServSSHV1Incoming.setDescription('If enabled, incoming SSH version 1 connections are allowed.')
slcServSSHTimeoutDataDirection = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 6), TimeoutDataDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHTimeoutDataDirection.setStatus('current')
if mibBuilder.loadTexts: slcServSSHTimeoutDataDirection.setDescription('If slcServSSHTimeout is enabled, this setting indicates the \n                 direction of data used to determine if the connection has \n                 timed out.')
slcServSSHDSAKeys = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 4, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSSHDSAKeys.setStatus('current')
if mibBuilder.loadTexts: slcServSSHDSAKeys.setDescription('If enabled, SSH will support DSA keys for incoming and \n                 outgoing connections.')
slcServTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5))
slcServTelnetState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServTelnetState.setStatus('current')
if mibBuilder.loadTexts: slcServTelnetState.setDescription('If enabled, allows logins to the SLC CLI via Telnet.')
slcServTelnetTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServTelnetTimeout.setStatus('current')
if mibBuilder.loadTexts: slcServTelnetTimeout.setDescription('The timeout (in minutes) for Telnet connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcServTelnetWebTelnet = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServTelnetWebTelnet.setStatus('current')
if mibBuilder.loadTexts: slcServTelnetWebTelnet.setDescription('If enabled, allows Web Telnet access to the CLI and the \n                 Device Ports.')
slcServTelnetTelnetOut = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServTelnetTelnetOut.setStatus('current')
if mibBuilder.loadTexts: slcServTelnetTelnetOut.setDescription('If enabled, allows outgoing Telnet connections.')
slcServTelnetTimeoutDataDirection = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 5, 5), TimeoutDataDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServTelnetTimeoutDataDirection.setStatus('current')
if mibBuilder.loadTexts: slcServTelnetTimeoutDataDirection.setDescription('If slcServTelnetTimeout is enabled, this setting indicates \n                 the direction of data used to determine if the connection \n                 has timed out.')
slcServSNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6))
slcServSNMPState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPState.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPState.setDescription('Enables the SNMP agent on the SLC.')
slcServSNMPTraps = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 2), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPTraps.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPTraps.setDescription('If enabled, the SLC sends traps for key events.')
slcServSNMPNMS = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPNMS.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPNMS.setDescription('The IPv4 Address of the Network Management System (NMS).')
slcServSNMPLocation = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPLocation.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPLocation.setDescription('The SNMP location for the SLC.')
slcServSNMPContact = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPContact.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPContact.setDescription('The SNMP contact for the SLC.')
slcServSNMPv3User = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv3User.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv3User.setDescription('The user name for read-only access to the SLC via SNMP v3.')
slcServSNMPReadOnlyCommunity = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPReadOnlyCommunity.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPReadOnlyCommunity.setDescription('The SNMP read-only community for SNMP versions 1 and 2.')
slcServSNMPReadWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPReadWriteCommunity.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPReadWriteCommunity.setDescription('The SNMP read-write community for SNMP versions 1 and 2.')
slcServSNMPTrapCommunity = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPTrapCommunity.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPTrapCommunity.setDescription('The SNMP trap community for SNMP versions 1 and 2.')
slcServSNMPAlarmDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPAlarmDelay.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPAlarmDelay.setDescription('The delay, in seconds, between traps that are sent out for \n                 alarm conditions.')
slcServSNMPv3ReadWriteUser = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv3ReadWriteUser.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv3ReadWriteUser.setDescription('The user name for read-write access to the SLC via SNMP v3.')
slcServSNMPv3Security = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAuthNoEncrypt", 1), ("authNoEncrypt", 2), ("authEncrypt", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv3Security.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv3Security.setDescription('The security model used for SNMP v3: insecure authentication \n                 and no packet encryption, secure authentication and no packet \n                 encryption, secure authentication and packet encryption.')
slcServSNMPv3Authentication = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("md5", 1), ("sha", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv3Authentication.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv3Authentication.setDescription('When slcServSNMPv3Security is set to authNoEncrypt or \n                 authEncrypt, the type of authentication used.')
slcServSNMPv3Encryption = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("des", 1), ("aes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv3Encryption.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv3Encryption.setDescription('When slcServSNMPv3Security is set to authEncrypt, the type \n                 of encryption used.')
slcServSNMPv1v2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPv1v2.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPv1v2.setDescription('If enabled, SNMP version 1 and version 2 (which use the \n                 Read-Only and Read-Write Communities) is enabled.')
slcServSNMPNMS2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPNMS2.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPNMS2.setDescription('The IPv4 Address of the 2nd Network Management System (NMS).')
slcServSNMPNMSIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 17), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPNMSIPv6.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPNMSIPv6.setDescription('The IPv6 Address of the Network Management System (NMS).')
slcServSNMPNMS2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 6, 18), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSNMPNMS2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcServSNMPNMS2IPv6.setDescription('The IPv6 Address of the 2nd Network Management System (NMS).')
slcServSMTP = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 7))
slcServSMTPServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 7, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSMTPServer.setStatus('current')
if mibBuilder.loadTexts: slcServSMTPServer.setDescription('The IP Address of the SMTP (email) server.')
slcServSMTPSender = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 7, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSMTPSender.setStatus('current')
if mibBuilder.loadTexts: slcServSMTPSender.setDescription("The sender's email address for emails sent from the SLC.")
slcServNFS = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8))
slcServNFSMountTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1), )
if mibBuilder.loadTexts: slcServNFSMountTable.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountTable.setDescription('Table of NFS Mounts.')
slcServNFSMountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcServNFSMountIndex"))
if mibBuilder.loadTexts: slcServNFSMountEntry.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountEntry.setDescription("An entry containing a NFS Mount and it's attributes.")
slcServNFSMountIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNFSMountIndex.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountIndex.setDescription('Reference index for each NFS Mount.')
slcServNFSMountRemoteDir = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNFSMountRemoteDir.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountRemoteDir.setDescription('The remote directory of the NFS Mount, in the format \n                 <remote server>:/<remote directory>.')
slcServNFSMountLocalDir = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNFSMountLocalDir.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountLocalDir.setDescription('The directory in the SLC on which the remote directory is \n                 mounted.')
slcServNFSMountReadWrite = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNFSMountReadWrite.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountReadWrite.setDescription('If enabled, the remote NFS directory is mounted read-write. \n                 If disabled, the remote NFS directory is mounted read-only.')
slcServNFSMountMount = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 8, 1, 1, 5), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServNFSMountMount.setStatus('current')
if mibBuilder.loadTexts: slcServNFSMountMount.setDescription('If enabled, the remote NFS directory is configured to be \n                 mounted.  If disabled, the remote NFS directory will not be \n                 mounted, or will be unmounted if is is mounted.')
slcServCIFS = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 9))
slcServCIFSState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 9, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServCIFSState.setStatus('current')
if mibBuilder.loadTexts: slcServCIFSState.setDescription('If enabled, the SLC exports a CIFS share containing system \n                 logs, Device Port logs, and saved SLC configurations.')
slcServCIFSEth1 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 9, 2), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServCIFSEth1.setStatus('current')
if mibBuilder.loadTexts: slcServCIFSEth1.setDescription('If enabled, the CIFS share is exported on the Eth1 interface.')
slcServCIFSEth2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 9, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServCIFSEth2.setStatus('current')
if mibBuilder.loadTexts: slcServCIFSEth2.setDescription('If enabled, the CIFS share is exported on the Eth2 interface.')
slcServCIFSWorkgroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 9, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServCIFSWorkgroup.setStatus('current')
if mibBuilder.loadTexts: slcServCIFSWorkgroup.setDescription('The SMB/CIFS workgroup that the CIFS share is associated with.')
slcServSLCNetwork = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10))
slcServSLCNetSearch = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("subnet", 2), ("manual", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSLCNetSearch.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetSearch.setDescription('Indicates how to search for SLCs on the network: by searching \n                 a list of manually entered IP Addresses, by broadcasting on \n                 the local subnet, or both.')
slcServSLCNetNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSLCNetNumber.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetNumber.setDescription('The number of entries in the SLC Network Manual IP Address table.')
slcServSLCNetTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 3), )
if mibBuilder.loadTexts: slcServSLCNetTable.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetTable.setDescription('Table of manually entered IP Address entries.  The number of \n                 entries is given by the value of slcServSLCNetNumber.')
slcServSLCNetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 3, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcServSLCNetIndex"))
if mibBuilder.loadTexts: slcServSLCNetEntry.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetEntry.setDescription('An entry containing an IP Address for searching the SLC Network.')
slcServSLCNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSLCNetIndex.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetIndex.setDescription('Reference index for each manual IP Address.')
slcServSLCNetIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 10, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSLCNetIP.setStatus('current')
if mibBuilder.loadTexts: slcServSLCNetIP.setDescription('The IP Address to search for in the SLC Network.')
slcServPhoneHome = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 11))
slcServPhoneHomeState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 11, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServPhoneHomeState.setStatus('current')
if mibBuilder.loadTexts: slcServPhoneHomeState.setDescription('Enables the Phone Home feature.')
slcServPhoneHomeIP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 11, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServPhoneHomeIP.setStatus('current')
if mibBuilder.loadTexts: slcServPhoneHomeIP.setDescription('The IP Address used for Phone Home communication.')
slcServHostList = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12))
slcServHostListNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListNumber.setStatus('current')
if mibBuilder.loadTexts: slcServHostListNumber.setDescription('The number of entries in the Host List table.')
slcServHostListTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2), )
if mibBuilder.loadTexts: slcServHostListTable.setStatus('current')
if mibBuilder.loadTexts: slcServHostListTable.setDescription('Table of Host Lists.  The number of entries is given by the \n                 value of slcServHostListNumber.')
slcServHostListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcServHostListIndex"))
if mibBuilder.loadTexts: slcServHostListEntry.setStatus('current')
if mibBuilder.loadTexts: slcServHostListEntry.setDescription('An entry containing a Host List, used for Dial-in connections \n                 on a Device Port or PC Card modem.')
slcServHostListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListIndex.setStatus('current')
if mibBuilder.loadTexts: slcServHostListIndex.setDescription('Reference index for each Host List.')
slcServHostListName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListName.setStatus('current')
if mibBuilder.loadTexts: slcServHostListName.setDescription('The unique name assigned to the Host List.')
slcServHostListRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListRetryCount.setStatus('current')
if mibBuilder.loadTexts: slcServHostListRetryCount.setDescription('The number of times to retry connections to an individual host \n                 within the Host List.')
slcServHostListAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListAuth.setStatus('current')
if mibBuilder.loadTexts: slcServHostListAuth.setDescription('If enabled, authentication is enabled for the hosts in the \n                 Host List.')
slcServHostListNumHosts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListNumHosts.setStatus('current')
if mibBuilder.loadTexts: slcServHostListNumHosts.setDescription('The number of individual hosts in the Host List.')
slcServHostListHosts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 12, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServHostListHosts.setStatus('current')
if mibBuilder.loadTexts: slcServHostListHosts.setDescription("A string containing all hosts in the Host List; the entry for \n                 each host is separated by a ';'.  Each host entry is formatted \n                 as follows: '<Host>,<Protocol>,<TCP Port>,<Escape Sequence>;'.")
slcServWebTerm = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 13))
slcServWebTermDeployment = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("javaWebStart", 1), ("applet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServWebTermDeployment.setStatus('current')
if mibBuilder.loadTexts: slcServWebTermDeployment.setDescription('The method used to launch the Java Terminal for Web SSH and \n                 Web Telnet. This object is deprecated.')
slcServWebTermBufSize = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(24, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServWebTermBufSize.setStatus('current')
if mibBuilder.loadTexts: slcServWebTermBufSize.setDescription('The number of lines in the Java Terminal buffer.')
slcServSite = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14))
slcServSiteNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteNumber.setStatus('current')
if mibBuilder.loadTexts: slcServSiteNumber.setDescription('The number of entries in the Sites table.')
slcServSiteTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2), )
if mibBuilder.loadTexts: slcServSiteTable.setStatus('current')
if mibBuilder.loadTexts: slcServSiteTable.setDescription('Table of Sites.  The number of entries is given by the \n                 value of slcServSiteNumber.')
slcServSiteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcServSiteIndex"))
if mibBuilder.loadTexts: slcServSiteEntry.setStatus('current')
if mibBuilder.loadTexts: slcServSiteEntry.setDescription('An entry containing a Site, used for connections on a \n                 Device Port or PC Card/USB modem.')
slcServSiteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteIndex.setStatus('current')
if mibBuilder.loadTexts: slcServSiteIndex.setDescription('Reference index for each Site.')
slcServSiteName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteName.setStatus('current')
if mibBuilder.loadTexts: slcServSiteName.setDescription('The unique name assigned to the Site.')
slcServSitePort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("devicePort", 2), ("upperPCCard", 3), ("lowerPCCard", 4), ("usbPort", 5), ("internalModem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSitePort.setStatus('current')
if mibBuilder.loadTexts: slcServSitePort.setDescription('The port the Site is assigned to.  If the port is devicePort \n                 or usbPort, slcServSitePortId defines which Device Port or USB \n                 Port (with an attached modem) the port is assigned to.')
slcServSitePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSitePortId.setStatus('current')
if mibBuilder.loadTexts: slcServSitePortId.setDescription('The identifier for a Device Port if slcServSitePort equals \n                 devicePort(1), or the identifier for a USB Port if \n                 slcServSitePort equals usbPort(5).  Otherwise equals zero.')
slcServSiteLoginHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteLoginHost.setStatus('current')
if mibBuilder.loadTexts: slcServSiteLoginHost.setDescription('For PPP or text authentication on dialin, the user login or \n                 CHAP host to use for authentication.  If authentication is \n                 successful, the rest of the site parameters will be used for \n                 the connection.')
slcServSiteCHAPSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteCHAPSecret.setStatus('current')
if mibBuilder.loadTexts: slcServSiteCHAPSecret.setDescription('For PPP authentication on dialin, the CHAP secret to use for \n                 authentication.')
slcServSiteTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteTimeout.setStatus('current')
if mibBuilder.loadTexts: slcServSiteTimeout.setDescription('The timeout (in minutes) for text connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcServSiteLocalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteLocalIP.setStatus('current')
if mibBuilder.loadTexts: slcServSiteLocalIP.setDescription('For PPP connections, the local IP Address - all zeros if it \n                 should be negotiated.')
slcServSiteRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteRemoteIP.setStatus('current')
if mibBuilder.loadTexts: slcServSiteRemoteIP.setDescription('For PPP connections, the remote IP Address - all zeros if it \n                 should be negotiated.')
slcServSiteStaticRouteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteStaticRouteIP.setStatus('current')
if mibBuilder.loadTexts: slcServSiteStaticRouteIP.setDescription('For Dial-on-Demand PPP connections, the static route \n                 IP Address for the remote network.')
slcServSiteStaticRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteStaticRouteMask.setStatus('current')
if mibBuilder.loadTexts: slcServSiteStaticRouteMask.setDescription('For Dial-on-Demand PPP connections, the static route \n                 subnet mask for the remote network.')
slcServSiteStaticRouteGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteStaticRouteGateway.setStatus('current')
if mibBuilder.loadTexts: slcServSiteStaticRouteGateway.setDescription('For Dial-on-Demand PPP connections, the static route \n                 gateway for the remote network.')
slcServSiteDialoutNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialoutNum.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialoutNum.setDescription('The phone number to use for dial-out connections.')
slcServSiteDialoutLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialoutLogin.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialoutLogin.setDescription('For dial-out connections, the login to use for authenticating \n                 to the remote peer; or on dial-in, the login to use if the \n                 remote peer requests authentication (for example, a two way \n                 CHAP handshake).')
slcServSiteDialback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialback.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialback.setDescription('If enabled, the site has permission to use modem dialback.')
slcServSiteDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialbackNum.setDescription('The phone number to use for dial-back connections.')
slcServSiteDialbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 17), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialbackDelay.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialbackDelay.setDescription('For Dial-back, specifies the delay between the dial-in and \n                 dial-out portion of the dialing sequence.')
slcServSiteIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 18), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: slcServSiteIdleTimeout.setDescription('The timeout (in seconds) for dial-in and dial-on-demand PPP \n                 connections.  If no traffic is received for the PPP connection \n                 in the time defined by the idle timeout, the PPP connection \n                 will be terminated.  A value of 0 indicates that timeouts are \n                 disabled.')
slcServSiteRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 19), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcServSiteRestartDelay.setDescription('The delay (in seconds) to wait before restarting dial-out or \n                 dial-on-demand PPP connections.')
slcServSiteCBCPServerAllowNoCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 20), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteCBCPServerAllowNoCallback.setStatus('current')
if mibBuilder.loadTexts: slcServSiteCBCPServerAllowNoCallback.setDescription('If enabled, the SLC will allow the PPP peer to select the \n                 No Callback option during CBCP negotiation.')
slcServSiteNATState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 21), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteNATState.setStatus('current')
if mibBuilder.loadTexts: slcServSiteNATState.setDescription('If enabled, use NAT (Network Address Translation) to allow \n                 dial-in and dial-back users to access the network connected \n                 to Eth1 and Eth2.')
slcServSiteDialbackRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 2, 14, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcServSiteDialbackRetries.setStatus('current')
if mibBuilder.loadTexts: slcServSiteDialbackRetries.setDescription('For Dial-back, specifies the number of times the SLC will \n                 retry the dial-out portion of the dialing sequence if the \n                 first attempt to dial-out fails.')
slcAuthLocal = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1))
slcAuthLocalNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalNumber.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalNumber.setDescription('The number of entries in the Local Users table.')
slcAuthLocalUsersTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2), )
if mibBuilder.loadTexts: slcAuthLocalUsersTable.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUsersTable.setDescription('Table of Local Users entries.  The number of entries \n                 is given by the value of slcAuthLocalNumber.')
slcAuthLocalUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcAuthLocalUserIndex"))
if mibBuilder.loadTexts: slcAuthLocalUserEntry.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserEntry.setDescription("An entry containing a Local Users and it's attributes.")
slcAuthLocalUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserIndex.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserIndex.setDescription('Reference index for each Local User.')
slcAuthLocalUserLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 33))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserLogin.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserLogin.setDescription("The login for the Local User.  If the user account is locked \n                 (cannot login), the login is appended with a '*' character.")
slcAuthLocalUserUID = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserUID.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserUID.setDescription('The unique user identifier number for the Local User.')
slcAuthLocalUserListenPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Local \n                 User has permission to access via 'connect listen'.")
slcAuthLocalUserDataPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Local \n                 User has permission to access via 'connect direct'.")
slcAuthLocalUserClearPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which the Local \n                 User has permission to clear.')
slcAuthLocalUserEscapeSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserEscapeSeq.setDescription('The character sequence which the Local User uses to terminate \n                 connections to Device Ports.')
slcAuthLocalUserBreakSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserBreakSeq.setDescription('The character sequence which the Local User uses to send a \n                 break sequence.')
slcAuthLocalUserMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserMenu.setDescription("The custom user menu defined for the Local User.  If this is \n                 empty, there is no menu defined for the Local User.  The menu \n                 name is followed by a slash '/' character and either a 'y' if \n                 the menu is automatically displayed at login, or a 'n' if it \n                 is not automatically displayed at login.")
slcAuthLocalUserDialback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 10), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserDialback.setDescription('If enabled, the Local User has permission to use modem dialback.')
slcAuthLocalUserDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserDialbackNum.setDescription('The dialback number defined for the Local User.')
slcAuthLocalUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 12), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserGroup.setDescription('The group assigned to the Local User.')
slcAuthLocalUserRights = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 13), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserRights.setDescription('The rights assigned to the Local User.')
slcAuthLocalUserPwdExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 14), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserPwdExpires.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserPwdExpires.setDescription("If enabled, the local user's password will expire.")
slcAuthLocalUserChangePwd = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserChangePwd.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserChangePwd.setDescription('If enabled, the local user can change their password.')
slcAuthLocalUserChangePwdNextLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 2, 1, 16), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUserChangePwdNextLogin.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUserChangePwdNextLogin.setDescription('If enabled, the local user must change their password at \n                 their next login.')
slcAuthLocalState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalState.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalState.setDescription('If enabled, Local Users are used for authentication.')
slcAuthLocalOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 4), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalOrder.setDescription('The authentication order of Local Users in authentication \n                 methods.')
slcAuthLocalComplexPasswords = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 5), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalComplexPasswords.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalComplexPasswords.setDescription('If enabled, Local Users are required to use complex passwords \n                 that are at least 8 characters long and contain at least one \n                 uppercase character, one lowercase character, one digit, and \n                 one non-alphanumeric character.')
slcAuthLocalUseNextMethod = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 6), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalUseNextMethod.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalUseNextMethod.setDescription('This object applies to all authentication methods, not just \n                 Local Users.  If enabled, authentication will occur using \n                 all methods, in the order of their precedence, until a \n                 successful authentication occurs.  If disabled, only the \n                 first authentication method that responds will be used.')
slcAuthLocalAllowReuse = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalAllowReuse.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalAllowReuse.setDescription('If enabled, local users can reuse old passwords.')
slcAuthLocalReuseHistory = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalReuseHistory.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalReuseHistory.setDescription('The number of passwords a local user must use before reusing \n                 an old password.')
slcAuthLocalPasswordLifetime = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setUnits('days').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalPasswordLifetime.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalPasswordLifetime.setDescription('The number of days until a password expires.')
slcAuthLocalWarningPeriod = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setUnits('days').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalWarningPeriod.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalWarningPeriod.setDescription('The number of days before a password expires that a local \n                 user is warned about the expiring password.  A value of 0 \n                 indicates that this feature is disabled.')
slcAuthLocalMaxLoginAttempts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalMaxLoginAttempts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalMaxLoginAttempts.setDescription('The number of times a local user can attempt to log in \n                 unsuccessfully before the SLC locks the user out.  A value \n                 of 0 indicates that this feature is disabled.')
slcAuthLocalLockoutPeriod = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 90))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalLockoutPeriod.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalLockoutPeriod.setDescription('The number of minutes the locked-out user must wait before \n                 trying to log in to to the SLC again.  A value of 0 indicates \n                 that this feature is disabled.')
slcAuthLocalMultipleSysadminLogins = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 13), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalMultipleSysadminLogins.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalMultipleSysadminLogins.setDescription('If enabled, multiple sysadmin logins to the web are allowed.')
slcAuthLocalSysadminConsoleOnly = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 1, 14), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLocalSysadminConsoleOnly.setStatus('current')
if mibBuilder.loadTexts: slcAuthLocalSysadminConsoleOnly.setDescription('If enabled, the sysadmin can only access the SLC via the \n                 Console Port.')
slcAuthNIS = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2))
slcAuthNISState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISState.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISState.setDescription('If enabled, NIS is used for authentication.')
slcAuthNISOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 2), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISOrder.setDescription('The authentication order of NIS in remote authentication methods.')
slcAuthNISDomain = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISDomain.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISDomain.setDescription('The NIS domain.')
slcAuthNISBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISBroadcast.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISBroadcast.setDescription('If enabled, the SLC broadcasts for the NIS server.')
slcAuthNISMaster = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISMaster.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISMaster.setDescription('The IP Address of the NIS master server.')
slcAuthNISSlave1 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISSlave1.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISSlave1.setDescription('The IP Address of the NIS slave server #1.')
slcAuthNISSlave2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISSlave2.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISSlave2.setDescription('The IP Address of the NIS slave server #2.')
slcAuthNISSlave3 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISSlave3.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISSlave3.setDescription('The IP Address of the NIS slave server #3.')
slcAuthNISGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 9), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISGroup.setDescription('The group assigned to NIS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthNISRights = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 10), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISRights.setDescription('The rights assigned to NIS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthNISMenu = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISMenu.setDescription('The custom user menu defined for all NIS users who login \n                 to the SLC.  If this is empty, there is no menu defined for \n                 NIS Users.')
slcAuthNISListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via NIS have permission to access via \n                 'connect listen'.")
slcAuthNISDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via NIS have permission to access via \n                 'connect direct'.")
slcAuthNISClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which users \n                 authenticated via NIS have permission to clear.')
slcAuthNISSlave4 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISSlave4.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISSlave4.setDescription('The IP Address of the NIS slave server #4.')
slcAuthNISSlave5 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 16), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISSlave5.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISSlave5.setDescription('The IP Address of the NIS slave server #5.')
slcAuthNISEscapeSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISEscapeSeq.setDescription('The character sequence which the NIS user uses to terminate \n                 connections to Device Ports.')
slcAuthNISBreakSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISBreakSeq.setDescription('The character sequence which the NIS user uses to send a \n                 break sequence.')
slcAuthNISDialback = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 19), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISDialback.setDescription('If enabled, NIS users have permission to use modem dialback.')
slcAuthNISDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 2, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthNISDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthNISDialbackNum.setDescription('The dialback number defined for NIS users.')
slcAuthLDAP = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3))
slcAuthLDAPState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPState.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPState.setDescription('If enabled, LDAP is used for authentication.')
slcAuthLDAPOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 2), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPOrder.setDescription('The authentication order of LDAP in remote authentication methods.')
slcAuthLDAPServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPServer.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPServer.setDescription('The IPv4 Address of the LDAP server.')
slcAuthLDAPBase = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPBase.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPBase.setDescription('The LDAP Base.')
slcAuthLDAPBindName = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPBindName.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPBindName.setDescription('The LDAP Bind Name.')
slcAuthLDAPPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPPort.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPPort.setDescription('The LDAP TCP Port Number.')
slcAuthLDAPADSupport = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPADSupport.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPADSupport.setDescription('If enabled, Active Directory support is enabled for LDAP.')
slcAuthLDAPGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 8), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPGroup.setDescription('The group assigned to LDAP users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthLDAPRights = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 9), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPRights.setDescription('The rights assigned to LDAP users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthLDAPMenu = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPMenu.setDescription('The custom user menu defined for all LDAP users who login \n                 to the SLC.  If this is empty, there is no menu defined for \n                 LDAP Users.')
slcAuthLDAPListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via LDAP have permission to access via \n                 'connect listen'.")
slcAuthLDAPDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via LDAP have permission to access via \n                 'connect direct'.")
slcAuthLDAPClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which users \n                 authenticated via LDAP have permission to clear.')
slcAuthLDAPEncrypt = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 14), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPEncrypt.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPEncrypt.setDescription('If enabled, encrypt messages between the SLC and the LDAP \n                 server.')
slcAuthLDAPEscapeSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPEscapeSeq.setDescription('The character sequence which the LDAP user uses to terminate \n                 connections to Device Ports.')
slcAuthLDAPBreakSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPBreakSeq.setDescription('The character sequence which the LDAP user uses to send a \n                 break sequence.')
slcAuthLDAPBindWithLogin = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 17), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPBindWithLogin.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPBindWithLogin.setDescription('If enabled, bind to the LDAP server using the current login \n                 and password.  The $login token in slcAuthLDAPBindName will \n                 be replaced with the current login.')
slcAuthLDAPUseLDAPSchema = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 18), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPUseLDAPSchema.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPUseLDAPSchema.setDescription('If enabled, attributes and permissions for remote users are \n                 retrieved from an LDAP server.')
slcAuthLDAPDialback = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 19), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPDialback.setDescription('If enabled, LDAP users have permission to use modem dialback.')
slcAuthLDAPDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPDialbackNum.setDescription('The dialback number defined for LDAP users.')
slcAuthLDAPUserFilter = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPUserFilter.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPUserFilter.setDescription('The attribute used by the LDAP server for user logins.')
slcAuthLDAPGroupFilter = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPGroupFilter.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPGroupFilter.setDescription('The objectclass used by the LDAP server for groups.')
slcAuthLDAPGroupMembershipAttr = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPGroupMembershipAttr.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPGroupMembershipAttr.setDescription('The attribute used by the LDAP server for group membership. \n                 This attribute may be use to search for a name (ie, msmith) \n                 or a Distinguished Name \n                 (ie, uid=msmith,ou=People,dc=lantronix,dc=com).')
slcAuthLDAPGroupMembershipDN = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 24), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPGroupMembershipDN.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPGroupMembershipDN.setDescription('If enabled, the string given by slcAuthLDAPGroupMembershipAttr \n                 is a Distinguished Name (DN).  Otherwise the string is a name.')
slcAuthLDAPServer2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 25), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPServer2.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPServer2.setDescription('The IPv4 Address of the secondary/backup LDAP server.')
slcAuthLDAPServerIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 26), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPServerIPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPServerIPv6.setDescription('The IPv6 Address of the LDAP server.')
slcAuthLDAPServer2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 3, 27), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthLDAPServer2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthLDAPServer2IPv6.setDescription('The IPv6 Address of the secondary/backup LDAP server.')
slcAuthRADIUS = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4))
slcAuthRADIUSState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSState.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSState.setDescription('If enabled, RADIUS is used for authentication.')
slcAuthRADIUSOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 2), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSOrder.setDescription('The authentication order of RADIUS in remote authentication methods.')
slcAuthRADIUSTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSTimeout.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSTimeout.setDescription('The RADIUS Timeout in seconds.  A value of 0 indicates \n                 that timeouts are disabled.')
slcAuthRADIUSServerTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4), )
if mibBuilder.loadTexts: slcAuthRADIUSServerTable.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSServerTable.setDescription('Table of RADIUS servers.')
slcAuthRADIUSServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcAuthRADIUSServerIndex"))
if mibBuilder.loadTexts: slcAuthRADIUSServerEntry.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSServerEntry.setDescription("An entry containing a RADIUS server and it's parameters.")
slcAuthRADIUSServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSServerIndex.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSServerIndex.setDescription('Reference index for each RADIUS server.')
slcAuthRADIUSServer = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSServer.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSServer.setDescription('The IPv4 Address of the RADIUS server.')
slcAuthRADIUSPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSPort.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSPort.setDescription('The RADIUS Server TCP Port Number.')
slcAuthRADIUSServerIPv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 4, 1, 4), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSServerIPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSServerIPv6.setDescription('The IPv6 Address of the RADIUS server.')
slcAuthRADIUSGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 5), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSGroup.setDescription('The group assigned to RADIUS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthRADIUSRights = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 6), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSRights.setDescription('The rights assigned to RADIUS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthRADIUSMenu = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSMenu.setDescription('The custom user menu defined for all RADIUS users who login \n                 to the SLC.  If this is empty, there is no menu defined for \n                 RADIUS Users.')
slcAuthRADIUSListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via RADIUS have permission to access via \n                 'connect listen'.")
slcAuthRADIUSDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via RADIUS have permission to access via \n                 'connect direct'.")
slcAuthRADIUSClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which users \n                 authenticated via RADIUS have permission to clear.')
slcAuthRADIUSEscapeSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSEscapeSeq.setDescription('The character sequence which the RADIUS user uses to terminate \n                 connections to Device Ports.')
slcAuthRADIUSBreakSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSBreakSeq.setDescription('The character sequence which the RADIUS user uses to send a \n                 break sequence.')
slcAuthRADIUSDialback = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 13), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSDialback.setDescription('If enabled, RADIUS users have permission to use modem dialback.')
slcAuthRADIUSDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSDialbackNum.setDescription('The dialback number defined for RADIUS users.')
slcAuthRADIUSUseVSA = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 4, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRADIUSUseVSA.setStatus('current')
if mibBuilder.loadTexts: slcAuthRADIUSUseVSA.setDescription('If enabled, the SLC will obtain remote user attributes \n                 (group/permissions and port access) from the RADIUS server \n                 via the Vendor-Specific Attribute (VSA).')
slcAuthKerberos = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5))
slcAuthKerbState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbState.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbState.setDescription('If enabled, Kerberos is used for authentication.')
slcAuthKerbOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 2), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbOrder.setDescription('The authentication order of Kerberos in remote authentication methods.')
slcAuthKerbRealm = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbRealm.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbRealm.setDescription('The Kerberos Realm.')
slcAuthKerbKDC = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbKDC.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbKDC.setDescription('The Kerberos KDC.')
slcAuthKerbKDCIP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbKDCIP.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbKDCIP.setDescription('The IPv4 Address of the Kerberos Key Distribution Server.')
slcAuthKerbKDCPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbKDCPort.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbKDCPort.setDescription('The Kerberos KDC Port Number.')
slcAuthKerbUseLDAP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbUseLDAP.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbUseLDAP.setDescription('If enabled, LDAP is used for lookups.')
slcAuthKerbGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 8), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbGroup.setDescription('The group assigned to Kerberos users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthKerbRights = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 9), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbRights.setDescription('The rights assigned to Kerberos users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthKerbMenu = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbMenu.setDescription('The custom user menu defined for all Kerberos users who login \n                 to the SLC.  If this is empty, there is no menu defined for \n                 Kerberos Users.')
slcAuthKerbListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via Kerberos have permission to access via \n                 'connect listen'.")
slcAuthKerbDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via Kerberos have permission to access via \n                 'connect direct'.")
slcAuthKerbClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which users \n                 authenticated via Kerberos have permission to clear.')
slcAuthKerbEscapeSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbEscapeSeq.setDescription('The character sequence which the Kerberos user uses to \n                 terminate connections to Device Ports.')
slcAuthKerbBreakSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbBreakSeq.setDescription('The character sequence which the Kerberos user uses to send a \n                 break sequence.')
slcAuthKerbDialback = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 16), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbDialback.setDescription('If enabled, Kerberos users have permission to use modem dialback.')
slcAuthKerbDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbDialbackNum.setDescription('The dialback number defined for Kerberos users.')
slcAuthKerbKDCIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 5, 18), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthKerbKDCIPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthKerbKDCIPv6.setDescription('The IPv6 Address of the Kerberos Key Distribution Server.')
slcAuthTACACS = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6))
slcAuthTACACSState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSState.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSState.setDescription('If enabled, TACACS is used for authentication.')
slcAuthTACACSOrder = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 2), AuthOrder()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSOrder.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSOrder.setDescription('The authentication order of TACACS in remote authentication methods.')
slcAuthTACACSServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServer.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServer.setDescription('The IPv4 Address of the first TACACS server.')
slcAuthTACACSEncrypt = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 4), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSEncrypt.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSEncrypt.setDescription('If enabled, encrypt messages between the SLC and the TACACS server.')
slcAuthTACACSGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 5), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSGroup.setDescription('The group assigned to TACACS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthTACACSRights = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 6), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSRights.setDescription('The rights assigned to TACACS users who login to the SLC and \n                 do not have group/rights defined in the Remote User database.')
slcAuthTACACSMenu = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSMenu.setDescription('The custom user menu defined for all TACACS users who login \n                 to the SLC.  If this is empty, there is no menu defined for \n                 TACACS Users.')
slcAuthTACACSListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via TACACS have permission to access via \n                 'connect listen'.")
slcAuthTACACSDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which users \n                 authenticated via TACACS have permission to access via \n                 'connect direct'.")
slcAuthTACACSClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which users \n                 authenticated via TACACS have permission to clear.')
slcAuthTACACSServer2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServer2.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServer2.setDescription('The IPv4 Address of the second TACACS server.')
slcAuthTACACSServer3 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServer3.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServer3.setDescription('The IPv4 Address of the third TACACS server.')
slcAuthTACACSEscapeSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSEscapeSeq.setDescription('The character sequence which the TACACS user uses to terminate \n                 connections to Device Ports.')
slcAuthTACACSBreakSeq = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSBreakSeq.setDescription('The character sequence which the TACACS user uses to send a \n                 break sequence.')
slcAuthTACACSDialback = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSDialback.setDescription('If enabled, TACACS users have permission to use modem dialback.')
slcAuthTACACSDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSDialbackNum.setDescription('The dialback number defined for TACACS users.')
slcAuthTACACSAuthService = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pppPAP", 1), ("pppCHAP", 2), ("asciiLogin", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSAuthService.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSAuthService.setDescription('The type of service used to pass the authentications tokens \n                 (e.g., login and password) between the SLC and the TACACS+ \n                 server.')
slcAuthTACACSServerIPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 18), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServerIPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServerIPv6.setDescription('The IPv6 Address of the first TACACS server.')
slcAuthTACACSServer2IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 19), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServer2IPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServer2IPv6.setDescription('The IPv6 Address of the second TACACS server.')
slcAuthTACACSServer3IPv6 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 6, 20), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthTACACSServer3IPv6.setStatus('current')
if mibBuilder.loadTexts: slcAuthTACACSServer3IPv6.setDescription('The IPv6 Address of the third TACACS server.')
slcAuthRemote = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7))
slcAuthRemoteNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteNumber.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteNumber.setDescription('The number of entries in the Remote Users table.')
slcAuthRemoteUsersTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2), )
if mibBuilder.loadTexts: slcAuthRemoteUsersTable.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUsersTable.setDescription('Table of Remote Users entries.  The number of entries \n                 is given by the value of slcAuthRemoteNumber.')
slcAuthRemoteUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcAuthRemoteUserIndex"))
if mibBuilder.loadTexts: slcAuthRemoteUserEntry.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserEntry.setDescription('An entry containing a Remote User and its attributes.')
slcAuthRemoteUserIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserIndex.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserIndex.setDescription('Reference index for each Remote User.')
slcAuthRemoteUserLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserLogin.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserLogin.setDescription('The login for the Remote User.')
slcAuthRemoteUserGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 3), UserGroup()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserGroup.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserGroup.setDescription('The group assigned to the Remote User.')
slcAuthRemoteUserRights = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 4), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserRights.setDescription('The rights assigned to the Remote User.')
slcAuthRemoteUserListenPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Remote \n                 User has permission to access via 'connect listen'.")
slcAuthRemoteUserDataPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Remote \n                 User has permission to access via 'connect direct'.")
slcAuthRemoteUserClearPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which the Remote \n                 User has permission to clear.')
slcAuthRemoteUserEscapeSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserEscapeSeq.setDescription('The character sequence which the Remote User uses to terminate \n                 connections to Device Ports.')
slcAuthRemoteUserBreakSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserBreakSeq.setDescription('The character sequence which the Remote User uses to send a \n                 break sequence.')
slcAuthRemoteUserMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserMenu.setDescription("The custom user menu defined for the Remote User.  If this is \n                 empty, there is no menu defined for the Remote User.  The menu \n                 name is followed by a slash '/' character and either a 'y' if \n                 the menu is automatically displayed at login, or a 'n' if it \n                 is not automatically displayed at login.")
slcAuthRemoteUserLocked = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 11), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserLocked.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserLocked.setDescription("If enabled, the Remote User's account is locked (blocked).")
slcAuthRemoteUserDialback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 12), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserDialback.setDescription('If enabled, the Remote User has permission to use modem dialback.')
slcAuthRemoteUserDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteUserDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteUserDialbackNum.setDescription('The dialback number defined for the Remote User.')
slcAuthRemoteAuthListOnly = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 7, 3), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthRemoteAuthListOnly.setStatus('current')
if mibBuilder.loadTexts: slcAuthRemoteAuthListOnly.setDescription('If enabled, remote users who log into the SLC will only be \n                 authenticated if they are listed in the remote user list.')
slcAuthGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8))
slcAuthGroupsNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupsNumber.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupsNumber.setDescription('The number of entries in the Groups table.')
slcAuthGroupsTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2), )
if mibBuilder.loadTexts: slcAuthGroupsTable.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupsTable.setDescription('Table of Groups entries.  The number of entries \n                 is given by the value of slcAuthGroupsNumber.')
slcAuthGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcAuthGroupIndex"))
if mibBuilder.loadTexts: slcAuthGroupEntry.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupEntry.setDescription('An entry containing a Remote User and its attributes.')
slcAuthGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupIndex.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupIndex.setDescription('Reference index for each Group.')
slcAuthGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupName.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupName.setDescription('The name for the Group.')
slcAuthGroupRights = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 3), UserRights()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupRights.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupRights.setDescription('The rights assigned to the Group.')
slcAuthGroupListenPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupListenPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupListenPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Group \n                 has permission to access via 'connect listen'.")
slcAuthGroupDataPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupDataPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupDataPorts.setDescription("The Device Ports and PC Card slots/USB ports which the Group \n                 has permission to access via 'connect direct'.")
slcAuthGroupClearPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupClearPorts.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupClearPorts.setDescription('The Device Ports and PC Card slots/USB ports which the Group \n                 has permission to clear.')
slcAuthGroupEscapeSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupEscapeSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupEscapeSeq.setDescription('The character sequence which the Group uses to terminate \n                 connections to Device Ports.')
slcAuthGroupBreakSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupBreakSeq.setDescription('The character sequence which the Group uses to send a \n                 break sequence.')
slcAuthGroupMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupMenu.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupMenu.setDescription("The custom user menu defined for the Group.  If this is \n                 empty, there is no menu defined for the Group.  The menu \n                 name is followed by a slash '/' character and either a 'y' if \n                 the menu is automatically displayed at login, or a 'n' if it \n                 is not automatically displayed at login.")
slcAuthGroupDialback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 10), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupDialback.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupDialback.setDescription('If enabled, the Group has permission to use modem dialback.')
slcAuthGroupDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 3, 8, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcAuthGroupDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcAuthGroupDialbackNum.setDescription('The dialback number defined for the Group.')
slcDevConsolePort = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1))
slcDevConBaud = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(300, 300), ValueRangeConstraint(600, 600), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConBaud.setStatus('current')
if mibBuilder.loadTexts: slcDevConBaud.setDescription('The baud rate of the Console Port.')
slcDevConDataBits = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(7, 7), ValueRangeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConDataBits.setStatus('current')
if mibBuilder.loadTexts: slcDevConDataBits.setDescription('The data bits of the Console Port.')
slcDevConStopBits = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConStopBits.setStatus('current')
if mibBuilder.loadTexts: slcDevConStopBits.setDescription('The stop bits of the Console Port.')
slcDevConParity = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConParity.setStatus('current')
if mibBuilder.loadTexts: slcDevConParity.setDescription('The parity of the Console Port.')
slcDevConFlowControl = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("rtscts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConFlowControl.setStatus('current')
if mibBuilder.loadTexts: slcDevConFlowControl.setDescription('The flow control of the Console Port.')
slcDevConTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevConTimeout.setDescription('The timeout (in minutes) for logins to the Console Port.  \n                 A value of 0 indicates that timeouts are disabled.')
slcDevConShowLines = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConShowLines.setStatus('current')
if mibBuilder.loadTexts: slcDevConShowLines.setDescription('If enabled, upon connecting to the Console Port, a series of \n                 characters (or lines) output to the Console Port before it \n                 was connected to are displayed.')
slcDevConNumberShowLines = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConNumberShowLines.setStatus('current')
if mibBuilder.loadTexts: slcDevConNumberShowLines.setDescription('If slcDevConShowLines is enabled, the number of lines that \n                 are displayed upon connecting to the Console Port.')
slcDevConGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevConGroup.setStatus('current')
if mibBuilder.loadTexts: slcDevConGroup.setDescription('The group or groups that may access the Console Port.')
slcDevDevicePorts = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2))
slcDevPortGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1))
slcDevGlobalListenPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalListenPorts.setStatus('obsolete')
if mibBuilder.loadTexts: slcDevGlobalListenPorts.setDescription("The Device Ports which remotely authenticated users have \n                 permission to access via 'connect listen'.  This object has \n                 been replaced by permissions for each remote authentication \n                 method: slcAuthNISListenPorts, slcAuthLDAPListenPorts, \n                 slcAuthRADIUSListenPorts, slcAuthKerbListenPorts, \n                 slcAuthTACACSListenPorts.")
slcDevGlobalDataPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalDataPorts.setStatus('obsolete')
if mibBuilder.loadTexts: slcDevGlobalDataPorts.setDescription("The Device Ports which remotely authenticated users have \n                 permission to access via 'connect direct'.  This object has \n                 been replaced by permissions for each remote authentication \n                 method: slcAuthNISDataPorts, slcAuthLDAPDataPorts, \n                 slcAuthRADIUSDataPorts, slcAuthKerbDataPorts, \n                 slcAuthTACACSDataPorts.")
slcDevGlobalClearPorts = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalClearPorts.setStatus('obsolete')
if mibBuilder.loadTexts: slcDevGlobalClearPorts.setDescription('The Device Ports which remotely authenticated users have \n                 permission to clear.  This object has been replaced by \n                 permissions for each remote authentication method: \n                 slcAuthNISClearPorts, slcAuthLDAPClearPorts, \n                 slcAuthRADIUSClearPorts, slcAuthKerbClearPorts, \n                 slcAuthTACACSClearPorts.')
slcDevGlobalStartTelnetPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalStartTelnetPort.setStatus('current')
if mibBuilder.loadTexts: slcDevGlobalStartTelnetPort.setDescription('The starting TCP port for Telnet in connections \n                 to Device Ports.')
slcDevGlobalStartSSHPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalStartSSHPort.setStatus('current')
if mibBuilder.loadTexts: slcDevGlobalStartSSHPort.setDescription('The starting TCP port for SSH in connections \n                 to Device Ports.')
slcDevGlobalStartTCPPort = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalStartTCPPort.setStatus('current')
if mibBuilder.loadTexts: slcDevGlobalStartTCPPort.setDescription('The starting TCP port for TCP in connections \n                 to Device Ports.')
slcDevGlobalMaxDirect = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevGlobalMaxDirect.setStatus('obsolete')
if mibBuilder.loadTexts: slcDevGlobalMaxDirect.setDescription('The maximum number of direct connects allowed for each \n                 Device Port.')
slcDevPortConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2))
slcDevPortCfgNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(24, 24), ValueRangeConstraint(32, 32), ValueRangeConstraint(40, 40), ValueRangeConstraint(48, 48), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNumber.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNumber.setDescription('The number of entries in the Device Port Configuration table.')
slcDevPortCfgTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2), )
if mibBuilder.loadTexts: slcDevPortCfgTable.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTable.setDescription('Table for managing Device Port configuration.  The number of \n                 entries is given by the value of slcDevPortCfgNumber.')
slcDevPortCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevPortId"))
if mibBuilder.loadTexts: slcDevPortCfgEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEntry.setDescription('An entry containing all configuration settings for a Device Port.')
slcDevPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortId.setStatus('current')
if mibBuilder.loadTexts: slcDevPortId.setDescription('The identifier for a Device Port.')
slcDevPortCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgName.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgName.setDescription('The name of the Device Port.')
slcDevPortCfgDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("none", 1), ("slp8", 2), ("slp16", 3), ("slp8Exp8", 4), ("slp8Exp16", 5), ("slp16Exp8", 6), ("slp16Exp16", 7), ("sensorsoft", 8), ("servertech", 9), ("rpm", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevice.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevice.setDescription("The device that is connected to the Device Port. The 'slp*' \n                 and 'servertech' values are deprecated and have been replaced \n                 by the RPM functionality.")
slcDevPortCfgDevLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevLogin.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevLogin.setDescription('The login used to authenticate to the device connected \n                 to the Device Port.')
slcDevPortCfgBreakSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgBreakSeq.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgBreakSeq.setDescription('The character sequence for the Device Port to send a break.')
slcDevPortCfgTelnetState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 6), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetState.setDescription('If enabled, Telnet connections to the Device Port are allowed.')
slcDevPortCfgTelnetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetPort.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetPort.setDescription('TCP Port number for Telnet in connections.')
slcDevPortCfgTelnetAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 8), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetAuth.setDescription('If enabled, the user is required to authenticate to access \n                 a Device Port with Telnet.')
slcDevPortCfgSSHState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 9), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSSHState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSSHState.setDescription('If enabled, SSH connections to the Device Port are allowed.')
slcDevPortCfgSSHPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSSHPort.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSSHPort.setDescription('TCP Port number for SSH in connections.')
slcDevPortCfgSSHAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 11), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSSHAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSSHAuth.setDescription('If enabled, the user is required to authenticate to access \n                 a Device Port with SSH.')
slcDevPortCfgTCPState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 12), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTCPState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTCPState.setDescription('If enabled, TCP connections to the Device Port are allowed.')
slcDevPortCfgTCPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTCPPort.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTCPPort.setDescription('TCP Port number for TCP in connections.')
slcDevPortCfgTCPAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 14), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTCPAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTCPAuth.setDescription('If enabled, the user is required to authenticate to access \n                 a Device Port with TCP.')
slcDevPortCfgIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgIP.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgIP.setDescription('The IP Address for Telnet, SSH or TCP in to a Device Port.')
slcDevPortCfgBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(300, 300), ValueRangeConstraint(600, 600), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgBaud.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgBaud.setDescription('The baud rate of the Device Port.')
slcDevPortCfgDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(7, 7), ValueRangeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDataBits.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDataBits.setDescription('The data bits of the Device Port.')
slcDevPortCfgStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgStopBits.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgStopBits.setDescription('The stop bits of the Device Port.')
slcDevPortCfgParity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgParity.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgParity.setDescription('The parity of the Device Port.')
slcDevPortCfgFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("rtscts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgFlowControl.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgFlowControl.setDescription('The flow control of the Device Port.')
slcDevPortCfgLogins = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 21), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgLogins.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgLogins.setDescription('If enabled, authentication is required to access a serial \n                 device connected to a Device Port.')
slcDevPortCfgConnectDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 22), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgConnectDSR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgConnectDSR.setDescription('If enabled, the Device Port only establishes a connection if \n                 DSR (Data Set Ready) transitions to an asserted state.')
slcDevPortCfgDisconnectDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 23), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDisconnectDSR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDisconnectDSR.setDescription('If enabled, and a connection to a Device Port is currently \n                 in session, the connection will be terminated if DSR (Data \n                 Set Ready) transitions to a de-asserted state.')
slcDevPortCfgModemState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("dialout", 2), ("dialin", 3), ("dialback", 4), ("dialondemand", 5), ("dialinAndDialondemand", 6), ("dialinHostList", 7), ("cbcpServer", 8), ("cbcpClient", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgModemState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgModemState.setDescription('For an external modem attached to the Device Port, indicates \n                 how the modem will be used.')
slcDevPortCfgModemMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("text", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgModemMode.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgModemMode.setDescription('For an external modem attached to the Device Port, the \n                 mode: PPP (for Dial-in and Dial-out) and text (for Dial-in \n                 and Dial-back).')
slcDevPortCfgLocalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 26), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgLocalIP.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgLocalIP.setDescription('For PPP connections, the local IP Address - all zeros if it \n                 should be negotiated.')
slcDevPortCfgRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 27), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgRemoteIP.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgRemoteIP.setDescription('For PPP connections, the remote IP Address - all zeros if it \n                 should be negotiated.')
slcDevPortCfgAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgAuth.setDescription('For PPP connections, the type of authentication to be used.')
slcDevPortCfgCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 29), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCHAPHost.setDescription('For PPP connections with CHAP authentication, the host (for \n                 Unix) or user (for Windows) to use.')
slcDevPortCfgInitScript = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgInitScript.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgInitScript.setDescription('The initialization script for an external modem.')
slcDevPortCfgTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTimeout.setDescription('The timeout (in minutes) for text connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevPortCfgDialoutNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 32), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialoutNum.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialoutNum.setDescription('The phone number to use for dial-out connections.')
slcDevPortCfgDialoutLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 33), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialoutLogin.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialoutLogin.setDescription('The login to use for dial-out connections.')
slcDevPortCfgDialbackMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("usernumber", 1), ("fixed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialbackMode.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialbackMode.setDescription('For dial-back connections, defines the phone number to call: \n                 a number associated with the authenticated user, or a fixed \n                 number associated with the Device Port.')
slcDevPortCfgDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 35), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialbackNum.setDescription('The phone number to use for dial-back connections.')
slcDevPortCfgNATState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 36), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNATState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNATState.setDescription('If enabled, use NAT (Network Address Translation) to allow \n                 dial-in and dial-back users to access the network connected \n                 to Eth1 and Eth2.')
slcDevPortCfgLocalState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 37), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgLocalState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgLocalState.setDescription('If enabled, local logging is enabled for the Device Port.')
slcDevPortCfgNFSFileState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 38), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNFSFileState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNFSFileState.setDescription('If enabled, NFS File logging is enabled for the Device Port.')
slcDevPortCfgNFSDir = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 39), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNFSDir.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNFSDir.setDescription('The local directory of a NFS mount to use for logging.')
slcDevPortCfgNFSMaxFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNFSMaxFiles.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNFSMaxFiles.setDescription('The maximum number of files to use for NFS file logging.')
slcDevPortCfgNFSMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 41), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNFSMaxSize.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNFSMaxSize.setDescription('The maximum size of each file (in bytes) for NFS File logging.')
slcDevPortCfgEmailState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 42), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailState.setDescription("If enabled, Token and Data Detection (previously called \n                 'Email Logging') is enabled for the Device Port.")
slcDevPortCfgEmailTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bytecnt", 1), ("textstring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailTrigger.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailTrigger.setDescription("The type of trigger to use for Token and Data Detection \n                 (previously called 'Email Logging') - number of data bytes \n                 received, or token/character string received.")
slcDevPortCfgEmailByteThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailByteThresh.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailByteThresh.setDescription("When Token and Data Detection (previously called 'Email \n                 Logging') is configured to trigger on a data byte count, \n                 the number of bytes required to trigger an action.")
slcDevPortCfgEmailDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 45), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailDelay.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), a time limit of how long the device port will \n                 capture data after the data trigger is detected and before \n                 closing the log file and performing the selected actions. \n                 This setting is now called 'Action Delay'.")
slcDevPortCfgEmailRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 46), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailRestartDelay.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), the period of time, after performing the \n                 selected actions, during which the device port will ignore \n                 additional characters received.")
slcDevPortCfgEmailTextString = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 47), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailTextString.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailTextString.setDescription("When Token and Data Detection (previously called 'Email \n                 Logging') is configured to trigger on a character string, \n                 this defines the character string that will trigger an action.")
slcDevPortCfgEmailTo = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 48), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailTo.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailTo.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), if the Email action is enabled, this object \n                 defines the list of emails to send email notification to.")
slcDevPortCfgEmailSubject = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 49), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailSubject.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailSubject.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), if the Email action is enabled, this object \n                 defines the subject to include with email notification.")
slcDevPortCfgPCCardState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 50), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPCCardState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPCCardState.setDescription('If enabled, PC Card logging is enabled for the Device Port. \n                 This value will be undefined if the SLC does not have PC Card \n                 slots.')
slcDevPortCfgPCCardLogTo = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upperSlot", 1), ("lowerSlot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPCCardLogTo.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPCCardLogTo.setDescription('For PC Card logging, which PC Card slot to use for logging. \n                 This value will be undefined if the SLC does not have PC Card \n                 slots.')
slcDevPortCfgPCCardMaxFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPCCardMaxFiles.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPCCardMaxFiles.setDescription('The maximum number of files to use for PC Card logging. \n                 This value will be undefined if the SLC does not have PC Card \n                 slots.')
slcDevPortCfgPCCardMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPCCardMaxSize.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPCCardMaxSize.setDescription('The maximum size of each file (in bytes) for PC Card logging. \n                 This value will be undefined if the SLC does not have PC Card \n                 slots.')
slcDevPortCfgAction = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("zeroPortCounters", 2), ("clearLocalLog", 3), ("terminateConnections", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slcDevPortCfgAction.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgAction.setDescription('Performs an action on a Device Port.  A read of this object \n                 always returns the value noAction(1).  Setting this object \n                 to zeroPortCounters(2) will reset all port counters given in \n                 slcDevPortStateTable.  Setting this object to clearLocalLog(3) \n                 will clear the local logging buffer.  Setting this object to \n                 terminateConnections(4) will terminate all connections \n                 associated with the Device Port.')
slcDevPortCfgEmailSend = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("email", 1), ("snmptrap", 2), ("both", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgEmailSend.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgEmailSend.setDescription('When a trigger is received, the type of notification to send: \n                 email, SNMP trap, or email and SNMP trap.  This object is \n                 deprecated; instead refer to slcDevPortCfgTokenAction.')
slcDevPortCfgBanner = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 56), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgBanner.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgBanner.setDescription('The banner displayed when the Device Port is connected to via \n                 SSH or Telnet.')
slcDevPortCfgIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 57), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgIdleTimeout.setDescription('The timeout (in seconds) for dial-in and dial-on-demand PPP \n                 connections.  If no traffic is received for the PPP connection \n                 in the time defined by the idle timeout, the PPP connection \n                 will be terminated.  A value of 0 indicates that timeouts are \n                 disabled.')
slcDevPortCfgRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 58), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgRestartDelay.setDescription('The delay (in seconds) to wait before restarting dial-out or \n                 dial-on-demand PPP connections.')
slcDevPortCfgCallerIdLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 59), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCallerIdLogging.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCallerIdLogging.setDescription('If enabled, caller id logging is enabled for a modem dial-in \n                 connection.')
slcDevPortCfgCallerIdATCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 60), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCallerIdATCmd.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCallerIdATCmd.setDescription('The modem AT command required to initiate caller id logging \n                 by the modem.')
slcDevPortCfgDODAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDODAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDODAuth.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, the type of authentication to be used for \n                 Dial-on-Demand.')
slcDevPortCfgDODCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 62), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDODCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDODCHAPHost.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, with CHAP authentication for Dial-on-Demand, \n                 the host (for Unix) or user (for Windows) to use.')
slcDevPortCfgSLMLoggingState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 63), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSLMLoggingState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSLMLoggingState.setDescription('If enabled, SLM logging is enabled for the Device Port.')
slcDevPortCfgSLMNMS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 64), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSLMNMS.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSLMNMS.setDescription('The IP Addresses of up to three SNMP Network Management \n                 Stations defined used for SLM Logging.  Multiple IP Addresses \n                 will be separated by a comma.')
slcDevPortCfgSLMByteThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 65), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSLMByteThresh.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSLMByteThresh.setDescription('The number of bytes required to trigger SLM logging.')
slcDevPortCfgSLMTimeFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 66), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSLMTimeFrame.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSLMTimeFrame.setDescription('The time frame for SLM logging, in seconds.')
slcDevPortCfgWebColumns = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 67), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgWebColumns.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgWebColumns.setDescription('The number of columns in the Web SSH or Telnet window for \n                 this Device Port.')
slcDevPortCfgWebRows = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 68), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgWebRows.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgWebRows.setDescription('The number of rows in the Web SSH or Telnet window for \n                 this Device Port.')
slcDevPortCfgSyslogState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 69), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSyslogState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSyslogState.setDescription('If enabled, Syslog logging is enabled for the Device Port.')
slcDevPortCfgHostList = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 70), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgHostList.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgHostList.setDescription('When slcDevPortCfgModemState is set to dialinHostList, the \n                 name of the Host List used for Dial-in.')
slcDevPortCfgDevLowTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 71), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevLowTemp.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevLowTemp.setDescription('The low temperature limit, in Celsius, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, 9999 will be returned.')
slcDevPortCfgDevHighTemp = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 72), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevHighTemp.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevHighTemp.setDescription('The high temperature limit, in Celsius, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, 9999 will be returned.')
slcDevPortCfgDevTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 73), OctetString()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevTemperature.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevTemperature.setDescription('The actual temperature, in Celsius, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, an empty string will be returned.')
slcDevPortCfgDevLowHumidity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevLowHumidity.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevLowHumidity.setDescription('The low humidty limit, in percentage, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, 9999 will be returned.')
slcDevPortCfgDevHighHumidity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 75), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevHighHumidity.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevHighHumidity.setDescription('The high humidty limit, in percentage, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, 9999 will be returned.')
slcDevPortCfgDevHumidity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 76), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevHumidity.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevHumidity.setDescription('The actual humidity, in percentage, for the device \n                 connected to this Device Port.  If the temperature is not \n                 applicable, an empty string will be returned.')
slcDevPortCfgDevTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 77), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevTraps.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevTraps.setDescription('If enabled, traps will be sent when one of the limits for the \n                 device connected to this Device Port are exceeded.')
slcDevPortCfgShowLines = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 78), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgShowLines.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgShowLines.setDescription('If enabled, upon connecting to the Device Port, a series of \n                 characters (or lines) output to the Device Port before it \n                 was connected to are displayed.')
slcDevPortCfgNumberShowLines = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 79), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNumberShowLines.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNumberShowLines.setDescription('If slcDevPortCfgShowLines is enabled, the number of lines that \n                 are displayed upon connecting to the Device Port.')
slcDevPortCfgViewPortLog = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 80), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgViewPortLog.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgViewPortLog.setDescription("If enabled, upon using 'connect direct' to a Device Port, \n                 the slcDevPortCfgPortLogSeq key sequence can be typed to \n                 view the end of the port log for the current Device Port, \n                 or a different Device Port.")
slcDevPortCfgPortLogSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 81), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPortLogSeq.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPortLogSeq.setDescription('The character sequence to view the port log for the Device \n                 Port.')
slcDevPortCfgMaxDirectConnects = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 82), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgMaxDirectConnects.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgMaxDirectConnects.setDescription('The maximum number of direct connects at the CLI for the \n                 Device Port.')
slcDevPortCfgTelnetTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 83), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1800))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetTimeout.setDescription('The timeout (in seconds) for Telnet connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevPortCfgSSHTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 84), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1800))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSSHTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSSHTimeout.setDescription('The timeout (in seconds) for SSH connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevPortCfgTCPTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 85), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1800))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTCPTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTCPTimeout.setDescription('The timeout (in seconds) for TCP connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevPortCfgCBCPClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adminDefined", 1), ("userDefined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCBCPClientType.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCBCPClientType.setDescription('When slcDevPortCfgModemState is set to cbcpClient, the \n                 preferred type of dialback number to use for CBCP negotiation.')
slcDevPortCfgCBCPServerAllowNoCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 87), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCBCPServerAllowNoCallback.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCBCPServerAllowNoCallback.setDescription('If enabled and slcDevPortCfgModemState is set to cbcpServer, \n                 the SLC will allow the PPP peer to select the No Callback \n                 option during CBCP negotiation.')
slcDevPortCfgDialbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 88), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialbackDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialbackDelay.setDescription('When slcDevPortCfgModemState is set to dialback or cbcpServer, \n                 specifies the delay between the dial-in and dial-out portion \n                 of the dialing sequence.')
slcDevPortCfgUSBState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 89), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUSBState.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUSBState.setDescription('If enabled, USB logging is enabled for the Device Port.  This \n                 value will be undefined if the SLC does not have USB Ports.')
slcDevPortCfgUSBLogTo = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 90), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUSBLogTo.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUSBLogTo.setDescription('For USB logging, which USB port to use for logging. This \n                 value will be undefined if the SLC does not have USB Ports.')
slcDevPortCfgUSBMaxFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 91), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUSBMaxFiles.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUSBMaxFiles.setDescription('The maximum number of files to use for USB logging. This \n                 value will be undefined if the SLC does not have USB Ports.')
slcDevPortCfgUSBMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 92), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUSBMaxSize.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUSBMaxSize.setDescription('The maximum size of each file (in bytes) for USB logging. This \n                 value will be undefined if the SLC does not have USB Ports.')
slcDevPortCfgCHAPAuthLocalUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 93), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgCHAPAuthLocalUsers.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgCHAPAuthLocalUsers.setDescription('If enabled, the local user list (login and password) is used \n                 to validate the CHAP host and secret sent by a remote PPP \n                 peer for CHAP authentication, instead of using the CHAP host \n                 and secret associated with a modem.')
slcDevPortCfgUseSites = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 94), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUseSites.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUseSites.setDescription('If enabled, sites (a set of site-oriented modem parameters \n                 that can be activated by various modem-related events such \n                 as authentication, outbound traffic for Dial-on-demand \n                 connections, etc.) will be used instead of the parameters \n                 configured for the modem.')
slcDevPortCfgDialbackRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 95), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDialbackRetries.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDialbackRetries.setDescription('When slcDevPortCfgModemState is set to dialback or cbcpServer, \n                 specifies the number of times the SLC will retry the dial-out \n                 portion of the dialing sequence if the first attempt to \n                 dial-out fails.')
slcDevPortCfgGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 96), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgGroup.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgGroup.setDescription('The group or groups that may access the Device Port.')
slcDevPortCfgIPMask = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 97), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgIPMask.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgIPMask.setDescription('The network mask associated with slcDevPortCfgIPMask.')
slcDevPortCfgDevPrompt = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 98), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevPrompt.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevPrompt.setDescription('If the device port is connected to a SLP or ServerTech CDU, \n                 specifies the prompt that is configured for the SLP or \n                 ServerTech CDU. This object is deprecated, and has been \n                 replaced by the RPM functionality.')
slcDevPortCfgDevNumOutlets = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 99), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevNumOutlets.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevNumOutlets.setDescription('If the device port is connected to a ServerTech CDU, specifies\n                 the number of outlets on the primary/master ServerTech unit. \n                 This object is deprecated, and has been replaced by the RPM \n                 functionality.')
slcDevPortCfgDevNumExpOutlets = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 100), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgDevNumExpOutlets.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgDevNumExpOutlets.setDescription('If the device port is connected to a ServerTech CDU, specifies\n                 the number of outlets on the expansion ServerTech unit. This \n                 object is deprecated, and has been replaced by the RPM \n                 functionality.')
slcDevPortCfgReversePinout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 101), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgReversePinout.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgReversePinout.setDescription('If enabled, swaps the positions of the serial lines, such \n                 that the direction of data or the signal is reversed.  \n                 For instance, TX is swapped with RX.  Enabling Reverse \n                 Pinout facilitates connections to Cisco and Sun style RS-45 \n                 console ports using a straight through Ethernet patch cable, \n                 without the need for a rolled cable or adapter.  Note that \n                 all Lantronix serial adapters are intended to be used with \n                 Reverse Pinout disabled.')
slcDevPortCfgUSBVBUS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 102), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgUSBVBUS.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgUSBVBUS.setDescription('For SLC8000 USB Device Ports only. If enabled, the USB VBUS \n                 signal provides power to the USB device attached to a device \n                 port. Disabling VBUS will power down the device as long as it \n                 is bus-powered instead of self-powered.')
slcDevPortCfgAssertDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 103), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgAssertDTR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgAssertDTR.setDescription('For RJ45 Device Ports only. By default, DTR is asserted on a \n                 device port nearly all of the time (except momentarily when a \n                 port is opened for operations).  Unchecking this option will \n                 deassert DTR, simulating a cable disconnection for the device \n                 that is connected to a device port.')
slcDevPortCfgPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rj45", 1), ("usb", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPortType.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPortType.setDescription('Indicates the connector type on the device port: RJ45 or USB.')
slcDevPortCfgTelnetTimeoutDataDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 105), TimeoutDataDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetTimeoutDataDirection.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetTimeoutDataDirection.setDescription('If slcDevPortCfgTelnetTimeout is enabled, this setting \n                 indicates the direction of data used to determine if the \n                 connection has timed out.')
slcDevPortCfgSSHTimeoutDataDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 106), TimeoutDataDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSSHTimeoutDataDirection.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSSHTimeoutDataDirection.setDescription('If slcDevPortCfgSSHTimeout is enabled, this setting indicates \n                 the direction of data used to determine if the connection has \n                 timed out.')
slcDevPortCfgTCPTimeoutDataDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 107), TimeoutDataDirection()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTCPTimeoutDataDirection.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTCPTimeoutDataDirection.setDescription('If slcDevPortCfgTCPTimeout is enabled, this setting indicates \n                 the direction of data used to determine if the connection has \n                 timed out.')
slcDevPortCfgIdleTimeoutMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 108), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgIdleTimeoutMessage.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgIdleTimeoutMessage.setDescription('If enabled, a message will be displayed to a user when their \n                 connection to a device port will be terminated soon due to \n                 the connection being idle.')
slcDevPortCfgNumberOfSessionsMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 109), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgNumberOfSessionsMessage.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgNumberOfSessionsMessage.setDescription('If enabled, a message will be displayed to a user when \n                 connecting to a device port that indicates how many users \n                 are currently connected to the device port.')
slcDevPortCfgMinimizeLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 110), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgMinimizeLatency.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgMinimizeLatency.setDescription('If enabled, device port latency will be minimized by \n                 reducing read delays.')
slcDevPortCfgTelnetSoftIAC = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 111), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTelnetSoftIAC.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTelnetSoftIAC.setDescription('If enabled, the Telnet server will not block waiting for \n                 the initial Telnet protocol IAC option responses.')
slcDevPortCfgSendTermString = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 112), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgSendTermString.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgSendTermString.setDescription('If enabled, and a slcDevPortCfgTerminationString is defined, \n                 when a network connection to a device port is terminated, the \n                 termination string is sent to the device connected to the \n                 device port.  The string should be defined so that it sends \n                 the the appropriate command(s) to the device to terminate any \n                 active user sessions.')
slcDevPortCfgTerminationString = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 113), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTerminationString.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTerminationString.setDescription('The termination string sent to the device connected to the \n                 device port if slcDevPortCfgSendTermString is enabled.')
slcDevPortCfgPowerManagementSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 114), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPowerManagementSeq.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPowerManagementSeq.setDescription('The key sequence that displays the Power Management menu \n                 when a user is connected to a device port.')
slcDevPortCfgPowerSupplies = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 115), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgPowerSupplies.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgPowerSupplies.setDescription("A string that describes the managed power supplies configured \n                 for the device port. A device port can have up to four power \n                 supplies that provide power for the device connected to the \n                 device port.  The string is a comma separated list of power\n                 supplies formatted: '<Power Suppy Name>(RPM Id/Outlet Id)'.")
slcDevPortCfgToggleDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 116), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgToggleDTR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgToggleDTR.setDescription('Applies to RJ45 device ports only.  If enabled, when a user \n                 disconnects from a device port, DTR will be toggled.  This  \n                 feature can be used when a serial connection requires DSR to \n                 be active for the attached device to connect.  In this case, \n                 toggling DTR will end any active connection on the device.')
slcDevPortCfgTokenAction = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 117), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTokenAction.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTokenAction.setDescription('For Token and Data Detection, a string containing one or more \n                 actions that will be performed if a data trigger occurs:\n                 syslog, email, trap, sendstring, powersupply.')
slcDevPortCfgTokenSendString = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 118), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTokenSendString.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTokenSendString.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), if the Send String action is enabled, this object \n                 defines the string to send to the device connected to the \n                 device port.")
slcDevPortCfgTokenPowerSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 119), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTokenPowerSupply.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTokenPowerSupply.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), if the Control Power Supply action is enabled, \n                 this object defines the name of the managed power supply to \n                 perform an action on. This string can be 'all' for all \n                 managed power supplies associated with the device port, or \n                 an individual power supply name.")
slcDevPortCfgTokenPowerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 2, 2, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("turnOff", 1), ("turnOn", 2), ("cyclePower", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortCfgTokenPowerAction.setStatus('current')
if mibBuilder.loadTexts: slcDevPortCfgTokenPowerAction.setDescription("For Token and Data Detection (previously called 'Email \n                 Logging'), if the Control Power Supply action is enabled, \n                 this object defines the action to take on \n                 slcDevPortCfgTokenPowerSupply.")
slcDevPortState = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3))
slcDevPortStateNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(24, 24), ValueRangeConstraint(32, 32), ValueRangeConstraint(40, 40), ValueRangeConstraint(48, 48), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateNumber.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateNumber.setDescription('The number of entries in the Device Port State table.')
slcDevPortStateTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2), )
if mibBuilder.loadTexts: slcDevPortStateTable.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateTable.setDescription('Table of Device Port state entries.  The number of \n                 entries is given by the value of slcDevPortStateNumber.')
slcDevPortStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevPortStateIndex"))
if mibBuilder.loadTexts: slcDevPortStateEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateEntry.setDescription('An entry containing all state information for a Device Port.')
slcDevPortStateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateIndex.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateIndex.setDescription('Reference index for each Device Port State entry.')
slcDevPortStateBytesInput = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 2), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateBytesInput.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateBytesInput.setDescription('The number of bytes input to the Device Port since boot or \n                 the last time Device Port statistics were zeroed.')
slcDevPortStateBytesOutput = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 3), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateBytesOutput.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateBytesOutput.setDescription('The number of bytes output from the Device Port since boot or \n                 the last time Device Port statistics were zeroed.')
slcDevPortStateFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateFramingErrors.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateFramingErrors.setDescription('The number of framing errors for the Device Port since boot or \n                 the last time Device Port statistics were zeroed.')
slcDevPortStateParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateParityErrors.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateParityErrors.setDescription('The number of parity errors for the Device Port since boot or \n                 the last time Device Port statistics were zeroed.')
slcDevPortStateOverrunErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateOverrunErrors.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateOverrunErrors.setDescription('The number of overrun errors for the Device Port since boot or \n                 the last time Device Port statistics were zeroed.')
slcDevPortStateFlowControlViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateFlowControlViolations.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateFlowControlViolations.setDescription('The number of flow control violations for the Device Port \n                 since boot or the last time Device Port statistics were \n                 zeroed.')
slcDevPortStateDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 8), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateDSR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateDSR.setDescription('If enabled, Data Set Ready is enabled for the Device Port.')
slcDevPortStateDTR = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 9), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateDTR.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateDTR.setDescription('If enabled, Data Terminal Ready is enabled for the Device Port.')
slcDevPortStateCTS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 10), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateCTS.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateCTS.setDescription('If enabled, Clear To Send is enabled for the Device Port.')
slcDevPortStateRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 11), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateRTS.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateRTS.setDescription('If enabled, Request To Send is enabled for the Device Port.')
slcDevPortStateCD = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 2, 3, 2, 1, 12), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStateCD.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStateCD.setDescription('If enabled, Carrier Detect is enabled for the Device Port.')
slcDevPCCard = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3))
slcPCCardCfgTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1), )
if mibBuilder.loadTexts: slcPCCardCfgTable.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTable.setDescription('Table of PC Card configuration entries.  There are two entries \n                 in the table, index (1) for the upper PC Card slot, and index \n                 (2) for the lower PC Card slot.  This table will be empty if \n                 the SLC does not have PC Card slots.')
slcPCCardCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcPCCardCfgIndex"))
if mibBuilder.loadTexts: slcPCCardCfgEntry.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgEntry.setDescription('An entry containing all configuration settings for a PC Card Slot.')
slcPCCardCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgIndex.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgIndex.setDescription('Reference index for each PC Card Configuration entry.')
slcPCCardCfgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("storage", 2), ("modem", 3), ("isdn", 4), ("wireless", 5), ("gsmmodem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCardType.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCardType.setDescription('The type of PC Card in the slot.')
slcPCCardCfgCardId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCardId.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCardId.setDescription('The identifying string of the card in the slot.')
slcPCCardCfgBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(300, 300), ValueRangeConstraint(600, 600), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgBaud.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgBaud.setDescription('For ISDN and modem cards, the baud rate.')
slcPCCardCfgDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(7, 7), ValueRangeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDataBits.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDataBits.setDescription('For ISDN and modem cards, the data bits.')
slcPCCardCfgStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgStopBits.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgStopBits.setDescription('For ISDN and modem cards, the stop bits.')
slcPCCardCfgParity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgParity.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgParity.setDescription('For ISDN and modem cards, the parity.')
slcPCCardCfgFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("rtscts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgFlowControl.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgFlowControl.setDescription('For ISDN and modem cards, the flow control.')
slcPCCardCfgModemState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("dialout", 2), ("dialin", 3), ("dialback", 4), ("dialondemand", 5), ("dialinAndDialondemand", 6), ("dialinHostList", 7), ("cbcpServer", 8), ("cbcpClient", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgModemState.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgModemState.setDescription('For ISDN and modem cards, indicates how the modem will be used.')
slcPCCardCfgModemMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("text", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgModemMode.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgModemMode.setDescription('For ISDN and modem cards, the mode: PPP (for Dial-in and \n                 Dial-out) and text (for Dial-in and Dial-back).')
slcPCCardCfgLocalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgLocalIP.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgLocalIP.setDescription('For PPP connections, the local IP Address (all zeros if it \n                 should be negotiated).')
slcPCCardCfgRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgRemoteIP.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgRemoteIP.setDescription('For PPP connections, the remote IP Address (all zeros if it \n                 should be negotiated).')
slcPCCardCfgAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgAuth.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgAuth.setDescription('For PPP connections, the type of authentication to be used.')
slcPCCardCfgCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCHAPHost.setDescription('For PPP connections with CHAP authentication, the host (for \n                 Unix) or user (for Windows) to use.')
slcPCCardCfgInitScript = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgInitScript.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgInitScript.setDescription('The initialization script for an external modem.')
slcPCCardCfgTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTimeout.setDescription('The timeout (in minutes) for text connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcPCCardCfgDialoutNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialoutNum.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialoutNum.setDescription('The phone number to use for dial-out connections.')
slcPCCardCfgDialoutLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialoutLogin.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialoutLogin.setDescription('The login to use for dial-out connections.')
slcPCCardCfgDialbackMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("usernumber", 1), ("fixed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialbackMode.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialbackMode.setDescription('For dial-back connections, defines the phone number to call: \n                 a number associated with the authenticated user, or a fixed \n                 number associated with the Device Port.')
slcPCCardCfgDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialbackNum.setDescription('The phone number to use for dial-back connections.')
slcPCCardCfgNATState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 21), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgNATState.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgNATState.setDescription('If enabled, use NAT (Network Address Translation) to allow \n                 dial-in and dial-back users to access the network connected\n                 to Eth1 and Eth2.')
slcPCCardCfgStorageFS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notmounted", 1), ("ext2", 2), ("fat", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgStorageFS.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgStorageFS.setDescription('For storage cards, the type of filesystem on the card.')
slcPCCardCfgISDNChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgISDNChannel.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgISDNChannel.setDescription('The channel on the ISDN card to use, either 1 or 2.')
slcPCCardCfgISDNChannelNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgISDNChannelNum.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgISDNChannelNum.setDescription('The phone number associated with the selected ISDN channel.')
slcPCCardCfgTelnetState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 25), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTelnetState.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTelnetState.setDescription('If enabled, Telnet connections to the modem/ISDN PC Card \n                 are allowed.')
slcPCCardCfgTelnetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTelnetPort.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTelnetPort.setDescription('TCP Port number for Telnet connections directly to the \n                 modem/ISDN PC Card.')
slcPCCardCfgTelnetAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 27), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTelnetAuth.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTelnetAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the modem/ISDN PC Card with Telnet.')
slcPCCardCfgSSHState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 28), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgSSHState.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgSSHState.setDescription('If enabled, SSH connections to the modem/ISDN PC Card \n                 are allowed.')
slcPCCardCfgSSHPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgSSHPort.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgSSHPort.setDescription('TCP Port number for SSH connections directly to the \n                 modem/ISDN PC Card.')
slcPCCardCfgSSHAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 30), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgSSHAuth.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgSSHAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the modem/ISDN PC Card with SSH.')
slcPCCardCfgTCPState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 31), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTCPState.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTCPState.setDescription('If enabled, TCP connections to the modem/ISDN PC Card \n                 are allowed.')
slcPCCardCfgTCPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTCPPort.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTCPPort.setDescription('TCP Port number for TCP connections directly to the \n                 modem/ISDN PC Card.')
slcPCCardCfgTCPAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 33), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgTCPAuth.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgTCPAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the modem/ISDN PC Card with TCP.')
slcPCCardCfgGSMPIN = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 34), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMPIN.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMPIN.setDescription('The PIN associated with the GSM/GPRS PC Card modem.')
slcPCCardCfgGSMNetworkName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 35), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMNetworkName.setStatus('obsolete')
if mibBuilder.loadTexts: slcPCCardCfgGSMNetworkName.setDescription('The Network Name associated with the GSM/GPRS PC Card modem.')
slcPCCardCfgGSMPPPCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 36), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMPPPCompression.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMPPPCompression.setDescription('If enabled, PPP compression is enabled for GSM/GPRS PC Card \n                 modem connections.')
slcPCCardCfgGSMAutoAcquireDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 37), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMAutoAcquireDNS.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMAutoAcquireDNS.setDescription('If enabled, DNS servers will be acquired vi GSM/GPRS PC Card \n                 modem PPP connections.')
slcPCCardCfgGSMDialoutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gprs", 1), ("gsm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMDialoutMode.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMDialoutMode.setDescription('The mode to be used for GSM/GPRS PC Card modems configured \n                 for dialout.')
slcPCCardCfgGSMContextID = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 39), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMContextID.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMContextID.setDescription('The Context Id string used for GSM/GPRS PC Card modems \n                 configured for GPRS dialout mode.')
slcPCCardCfgGSMBearerService = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 40), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGSMBearerService.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGSMBearerService.setDescription('The Bearer Service Type string used for GSM/GPRS PC Card \n                 modems configured for GSM dialin/dialout mode.')
slcPCCardCfgIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgIdleTimeout.setDescription('The timeout (in seconds) for dial-in and dial-on-demand PPP \n                 connections.  If no traffic is received for the PPP connection \n                 in the time defined by the idle timeout, the PPP connection \n                 will be terminated.  A value of 0 indicates that timeouts are \n                 disabled.')
slcPCCardCfgRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 42), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgRestartDelay.setDescription('The delay (in seconds) to wait before restarting dial-out or \n                 dial-on-demand PPP connections.')
slcPCCardCfgCallerIdLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 43), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCallerIdLogging.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCallerIdLogging.setDescription('If enabled, caller id logging is enabled for a modem dial-in \n                 connection.')
slcPCCardCfgCallerIdATCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 44), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCallerIdATCmd.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCallerIdATCmd.setDescription('The modem AT command required to initiate caller id logging \n                 by the modem.')
slcPCCardCfgDODAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDODAuth.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDODAuth.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, the type of authentication to be used for \n                 Dial-on-Demand.')
slcPCCardCfgDODCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 46), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDODCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDODCHAPHost.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, with CHAP authentication for Dial-on-Demand, \n                 the host (for Unix) or user (for Windows) to use.')
slcPCCardCfgHostList = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 47), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgHostList.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgHostList.setDescription('When slcPCCardCfgModemState is set to dialinHostList, the \n                 name of the Host List used for Dial-in.')
slcPCCardCfgCBCPClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adminDefined", 1), ("userDefined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCBCPClientType.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCBCPClientType.setDescription('When slcPCCardCfgModemState is set to cbcpClient, the \n                 preferred type of dialback number to use for CBCP negotiation.')
slcPCCardCfgCBCPServerAllowNoCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 49), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCBCPServerAllowNoCallback.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCBCPServerAllowNoCallback.setDescription('If enabled and slcPCCardCfgModemState is set to cbcpServer, \n                 the SLC will allow the PPP peer to select the No Callback \n                 option during CBCP negotiation.')
slcPCCardCfgDialbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 50), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialbackDelay.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialbackDelay.setDescription('When slcPCCardCfgModemState is set to dialback or cbcpServer, \n                 specifies the delay between the dial-in and dial-out portion \n                 of the dialing sequence.')
slcPCCardCfgCHAPAuthLocalUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 51), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgCHAPAuthLocalUsers.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgCHAPAuthLocalUsers.setDescription('If enabled, the local user list (login and password) is used \n                 to validate the CHAP host and secret sent by a remote PPP \n                 peer for CHAP authentication, instead of using the CHAP host \n                 and secret associated with a modem.')
slcPCCardCfgUseSites = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 52), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgUseSites.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgUseSites.setDescription('If enabled, sites (a set of site-oriented modem parameters \n                 that can be activated by various modem-related events such \n                 as authentication, outbound traffic for Dial-on-demand \n                 connections, etc.) will be used instead of the parameters \n                 configured for the modem.')
slcPCCardCfgDialbackRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgDialbackRetries.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgDialbackRetries.setDescription('When slcPCCardCfgModemState is set to dialback or cbcpServer, \n                 specifies the number of times the SLC will retry the dial-out \n                 portion of the dialing sequence if the first attempt to \n                 dial-out fails.')
slcPCCardCfgGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 3, 1, 1, 54), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardCfgGroup.setStatus('current')
if mibBuilder.loadTexts: slcPCCardCfgGroup.setDescription('The group or groups that may access the PC Card slot.')
slcDevPowerSupply = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 4))
slcDevPowerSupplyType = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("acOnePowerSupply", 1), ("acTwoPowerSupplies", 2), ("dcTwoPowerSupplies", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPowerSupplyType.setStatus('current')
if mibBuilder.loadTexts: slcDevPowerSupplyType.setDescription('The type of power supply for the SLC.')
slcDevPowerSupplyA = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPowerSupplyA.setStatus('current')
if mibBuilder.loadTexts: slcDevPowerSupplyA.setDescription('The status of Power Supply A.')
slcDevPowerSupplyB = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("notInstalled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPowerSupplyB.setStatus('current')
if mibBuilder.loadTexts: slcDevPowerSupplyB.setDescription('The status of Power Supply B.')
slcDevUSB = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5))
slcDevUSBState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 1), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBState.setDescription('If enabled, the USB devices connected to the SLC will be \n                 accessible. This value will be undefined if the SLC does \n                 not have USB Ports.')
slcDevUSBCfgTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2), )
if mibBuilder.loadTexts: slcDevUSBCfgTable.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTable.setDescription('Table of USB configuration entries.  There is one entry in the \n                 table, index (1) for USB port 1.  This table will be empty if \n                 the SLC does not have USB Ports.')
slcDevUSBCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevUSBId"))
if mibBuilder.loadTexts: slcDevUSBCfgEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgEntry.setDescription('An entry containing all configuration settings for a USB port.')
slcDevUSBId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBId.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBId.setDescription('The identifier for a USB Port (1 indicates USB Port U1).')
slcDevUSBCfgCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("storage", 2), ("modem", 3), ("isdn", 4), ("wireless", 5), ("gsmmodem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCardType.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCardType.setDescription('The type of USB device in the port.')
slcDevUSBCfgCardId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCardId.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCardId.setDescription('The identifying string of the device in the port.')
slcDevUSBCfgStorageFS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notmounted", 1), ("ext2", 2), ("fat", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgStorageFS.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgStorageFS.setDescription('For thumb drives, the type of filesystem on the card.')
slcDevUSBCfgBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(300, 300), ValueRangeConstraint(600, 600), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(2400, 2400), ValueRangeConstraint(4800, 4800), ValueRangeConstraint(9600, 9600), ValueRangeConstraint(19200, 19200), ValueRangeConstraint(38400, 38400), ValueRangeConstraint(57600, 57600), ValueRangeConstraint(115200, 115200), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgBaud.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgBaud.setDescription('For modem cards, the baud rate.')
slcDevUSBCfgDataBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(7, 7), ValueRangeConstraint(8, 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDataBits.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDataBits.setDescription('For modem cards, the data bits.')
slcDevUSBCfgStopBits = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgStopBits.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgStopBits.setDescription('For modem cards, the stop bits.')
slcDevUSBCfgParity = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgParity.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgParity.setDescription('For modem cards, the parity.')
slcDevUSBCfgFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("xonxoff", 2), ("rtscts", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgFlowControl.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgFlowControl.setDescription('For modem cards, the flow control.')
slcDevUSBCfgModemState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("dialout", 2), ("dialin", 3), ("dialback", 4), ("dialondemand", 5), ("dialinAndDialondemand", 6), ("dialinHostList", 7), ("cbcpServer", 8), ("cbcpClient", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgModemState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgModemState.setDescription('For modem cards, indicates how the modem will be used.')
slcDevUSBCfgModemMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("text", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgModemMode.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgModemMode.setDescription('For modem cards, the mode: PPP (for Dial-in and \n                 Dial-out) and text (for Dial-in and Dial-back).')
slcDevUSBCfgLocalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgLocalIP.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgLocalIP.setDescription('For PPP connections, the local IP Address (all zeros if it \n                 should be negotiated).')
slcDevUSBCfgRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgRemoteIP.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgRemoteIP.setDescription('For PPP connections, the remote IP Address (all zeros if it \n                 should be negotiated).')
slcDevUSBCfgAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgAuth.setDescription('For PPP connections, the type of authentication to be used.')
slcDevUSBCfgCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCHAPHost.setDescription('For PPP connections with CHAP authentication, the host (for \n                 Unix) or user (for Windows) to use.')
slcDevUSBCfgDODAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDODAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDODAuth.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, the type of authentication to be used for \n                 Dial-on-Demand.')
slcDevUSBCfgDODCHAPHost = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDODCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDODCHAPHost.setDescription('For PPP connections that are configured for both Dial-in and \n                 Dial-on-Demand, with CHAP authentication for Dial-on-Demand, \n                 the host (for Unix) or user (for Windows) to use.')
slcDevUSBCfgInitScript = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgInitScript.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgInitScript.setDescription('The initialization script for a modem.')
slcDevUSBCfgTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTimeout.setDescription('The timeout (in minutes) for text connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevUSBCfgDialoutNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialoutNum.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialoutNum.setDescription('The phone number to use for dial-out connections.')
slcDevUSBCfgDialoutLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialoutLogin.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialoutLogin.setDescription('The login to use for dial-out connections.')
slcDevUSBCfgDialbackMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("usernumber", 1), ("fixed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialbackMode.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialbackMode.setDescription('For dial-back connections, defines the phone number to call: \n                 a number associated with the authenticated user, or a fixed \n                 number associated with the Device Port.')
slcDevUSBCfgDialbackNum = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 23), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialbackNum.setDescription('The phone number to use for dial-back connections.')
slcDevUSBCfgDialbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 24), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialbackDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialbackDelay.setDescription('When slcDevUSBCfgModemState is set to dialback or cbcpServer, \n                 specifies the delay between the dial-in and dial-out portion \n                 of the dialing sequence.')
slcDevUSBCfgNATState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 25), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgNATState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgNATState.setDescription('If enabled, use NAT (Network Address Translation) to allow \n                 dial-in and dial-back users to access the network connected\n                 to Eth1 and Eth2.')
slcDevUSBCfgIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 26), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgIdleTimeout.setDescription('The timeout (in seconds) for dial-in and dial-on-demand PPP \n                 connections.  If no traffic is received for the PPP connection \n                 in the time defined by the idle timeout, the PPP connection \n                 will be terminated.  A value of 0 indicates that timeouts are \n                 disabled.')
slcDevUSBCfgRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 27), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgRestartDelay.setDescription('The delay (in seconds) to wait before restarting dial-out or \n                 dial-on-demand PPP connections.')
slcDevUSBCfgCallerIdLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 28), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCallerIdLogging.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCallerIdLogging.setDescription('If enabled, caller id logging is enabled for a modem dial-in \n                 connection.')
slcDevUSBCfgCallerIdATCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 29), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCallerIdATCmd.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCallerIdATCmd.setDescription('The modem AT command required to initiate caller id logging \n                 by the modem.')
slcDevUSBCfgHostList = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgHostList.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgHostList.setDescription('When slcDevUSBCfgModemState is set to dialinHostList, the \n                 name of the Host List used for Dial-in.')
slcDevUSBCfgCBCPClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("adminDefined", 1), ("userDefined", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCBCPClientType.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCBCPClientType.setDescription('When slcDevUSBCfgModemState is set to cbcpClient, the \n                 preferred type of dialback number to use for CBCP negotiation.')
slcDevUSBCfgCBCPServerAllowNoCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 32), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCBCPServerAllowNoCallback.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCBCPServerAllowNoCallback.setDescription('If enabled and slcDevUSBCfgModemState is set to cbcpServer, \n                 the SLC will allow the PPP peer to select the No Callback \n                 option during CBCP negotiation.')
slcDevUSBCfgTelnetState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 33), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTelnetState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTelnetState.setDescription('If enabled, Telnet connections to the USB modem are allowed.')
slcDevUSBCfgTelnetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTelnetPort.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTelnetPort.setDescription('TCP Port number for Telnet connections directly to the \n                 USB modem.')
slcDevUSBCfgTelnetAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 35), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTelnetAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTelnetAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the USB modem with Telnet.')
slcDevUSBCfgSSHState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 36), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgSSHState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgSSHState.setDescription('If enabled, SSH connections to the USB modem are allowed.')
slcDevUSBCfgSSHPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgSSHPort.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgSSHPort.setDescription('TCP Port number for SSH connections directly to the USB modem.')
slcDevUSBCfgSSHAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 38), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgSSHAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgSSHAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the USB modem with SSH.')
slcDevUSBCfgTCPState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 39), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTCPState.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTCPState.setDescription('If enabled, TCP connections to the USB modem are allowed.')
slcDevUSBCfgTCPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTCPPort.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTCPPort.setDescription('TCP Port number for TCP connections directly to the USB modem.')
slcDevUSBCfgTCPAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 41), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgTCPAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgTCPAuth.setDescription('If enabled, the user is required to authenticate to access \n                 the USB modem with TCP.')
slcDevUSBCfgGSMPIN = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 42), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMPIN.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMPIN.setDescription('The PIN associated with the GSM/GPRS modem.')
slcDevUSBCfgGSMPPPCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 43), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMPPPCompression.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMPPPCompression.setDescription('If enabled, PPP compression is enabled GSM/GPRS modem \n                 connections.')
slcDevUSBCfgGSMAutoAcquireDNS = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 44), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMAutoAcquireDNS.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMAutoAcquireDNS.setDescription('If enabled, DNS servers will be acquired vi GSM/GPRS modem \n                 PPP connections.')
slcDevUSBCfgGSMDialoutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("gprs", 1), ("gsm", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMDialoutMode.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMDialoutMode.setDescription('The mode to be used for GSM/GPRS modems configured for \n                 dialout.')
slcDevUSBCfgGSMContextID = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 46), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMContextID.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMContextID.setDescription('The Context Id string used for GSM/GPRS modems configured \n                 for GPRS dialout mode.')
slcDevUSBCfgGSMBearerService = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 47), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGSMBearerService.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGSMBearerService.setDescription('The Bearer Service Type string used for GSM/GPRS modems \n                 configured for GSM dialin/dialout mode.')
slcDevUSBCfgCHAPAuthLocalUsers = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 48), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgCHAPAuthLocalUsers.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgCHAPAuthLocalUsers.setDescription('If enabled, the local user list (login and password) is used \n                 to validate the CHAP host and secret sent by a remote PPP \n                 peer for CHAP authentication, instead of using the CHAP host \n                 and secret associated with a modem.')
slcDevUSBCfgUseSites = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 49), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgUseSites.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgUseSites.setDescription('If enabled, sites (a set of site-oriented modem parameters \n                 that can be activated by various modem-related events such \n                 as authentication, outbound traffic for Dial-on-demand \n                 connections, etc.) will be used instead of the parameters \n                 configured for the modem.')
slcDevUSBCfgDialbackRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialbackRetries.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialbackRetries.setDescription('When slcDevUSBCfgModemState is set to dialback or cbcpServer, \n                 specifies the number of times the SLC will retry the dial-out \n                 portion of the dialing sequence if the first attempt to \n                 dial-out fails.')
slcDevUSBCfgDialtoneCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgDialtoneCheck.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgDialtoneCheck.setDescription('The time (in minutes) between checks for a modem dialtone.  \n                 A value of 0 indicates that dialtone checks are disabled.')
slcDevUSBCfgGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 5, 2, 1, 52), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevUSBCfgGroup.setStatus('current')
if mibBuilder.loadTexts: slcDevUSBCfgGroup.setDescription('The group or groups that may access the USB port.')
slcDevIntModem = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6))
slcDevIntModemModemState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("dialout", 2), ("dialin", 3), ("dialback", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemModemState.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemModemState.setDescription('For the SLC internal modem, indicates how the modem will \n                 be used.')
slcDevIntModemModemMode = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ppp", 1), ("text", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemModemMode.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemModemMode.setDescription('For the SLC internal modem, the mode: PPP (for Dial-in and \n                 Dial-out) and text (for Dial-in and Dial-back).')
slcDevIntModemLocalIP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemLocalIP.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemLocalIP.setDescription('For PPP connections, the local IP Address - all zeros if it \n                 should be negotiated.')
slcDevIntModemRemoteIP = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemRemoteIP.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemRemoteIP.setDescription('For PPP connections, the remote IP Address - all zeros if it \n                 should be negotiated.')
slcDevIntModemAuth = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pap", 1), ("chap", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemAuth.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemAuth.setDescription('For PPP connections, the type of authentication to be used.')
slcDevIntModemCHAPHost = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemCHAPHost.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemCHAPHost.setDescription('For PPP connections with CHAP authentication, the host (for \n                 Unix) or user (for Windows) to use.')
slcDevIntModemInitScript = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemInitScript.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemInitScript.setDescription('The initialization script for an internal modem.')
slcDevIntModemTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemTimeout.setDescription('The timeout (in minutes) for text connections.  A value \n                 of 0 indicates that timeouts are disabled.')
slcDevIntModemDialoutNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialoutNum.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialoutNum.setDescription('The phone number to use for dial-out connections.')
slcDevIntModemDialoutLogin = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialoutLogin.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialoutLogin.setDescription('The login to use for dial-out connections.')
slcDevIntModemDialbackMode = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("usernumber", 1), ("fixed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialbackMode.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialbackMode.setDescription('For dial-back connections, defines the phone number to call: \n                 a number associated with the authenticated user, or a fixed \n                 number associated with the internal modem.')
slcDevIntModemDialbackNum = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialbackNum.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialbackNum.setDescription('The phone number to use for dial-back connections.')
slcDevIntModemDialbackRetries = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialbackRetries.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialbackRetries.setDescription('When slcDevIntModemModemState is set to dialback, \n                 specifies the number of times the SLC will retry the dial-out \n                 portion of the dialing sequence if the first attempt to \n                 dial-out fails.')
slcDevIntModemDialbackDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 14), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialbackDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialbackDelay.setDescription('When slcDevIntModemModemState is set to dialback, \n                 specifies the delay between the dial-in and dial-out portion \n                 of the dialing sequence.')
slcDevIntModemCallerIdLogging = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 15), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemCallerIdLogging.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemCallerIdLogging.setDescription('If enabled, caller id logging is enabled for a modem dial-in \n                 connection.')
slcDevIntModemCallerIdATCmd = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemCallerIdATCmd.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemCallerIdATCmd.setDescription('The modem AT command required to initiate caller id logging \n                 by the modem.')
slcDevIntModemUseSites = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 17), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemUseSites.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemUseSites.setDescription('If enabled, sites (a set of site-oriented modem parameters \n                 that can be activated by various modem-related events such \n                 as authentication, outbound traffic for Dial-on-demand \n                 connections, etc.) will be used instead of the parameters \n                 configured for the modem.')
slcDevIntModemGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemGroup.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemGroup.setDescription('The group or groups that may access the internal modem \n                 connection.')
slcDevIntModemIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 19), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemIdleTimeout.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemIdleTimeout.setDescription('The timeout (in seconds) for dial-in and dial-on-demand PPP \n                 connections.  If no traffic is received for the PPP connection \n                 in the time defined by the idle timeout, the PPP connection \n                 will be terminated.  A value of 0 indicates that timeouts are \n                 disabled.')
slcDevIntModemRestartDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 20), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemRestartDelay.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemRestartDelay.setDescription('The delay (in seconds) to wait before restarting dial-out or \n                 dial-on-demand PPP connections.')
slcDevIntModemNATState = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 21), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemNATState.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemNATState.setDescription('If enabled, use NAT (Network Address Translation) to allow \n                 dial-in and dial-back users to access the network connected \n                 to Eth1 and Eth2.')
slcDevIntModemDialtoneCheck = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 6, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevIntModemDialtoneCheck.setStatus('current')
if mibBuilder.loadTexts: slcDevIntModemDialtoneCheck.setDescription('The time (in minutes) between checks for a modem dialtone.  \n                 A value of 0 indicates that dialtone checks are disabled.')
slcDevRPM = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7))
slcDevRPMCfgTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1), )
if mibBuilder.loadTexts: slcDevRPMCfgTable.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMCfgTable.setDescription('Table of RPM configuration entries.')
slcDevRPMCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevRPMId"))
if mibBuilder.loadTexts: slcDevRPMCfgEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMCfgEntry.setDescription('An entry containing all configuration settings for an RPM,\n                 as well as some top level status information for the RPM.')
slcDevRPMId = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMId.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMId.setDescription('The unique identifier for an RPM device.')
slcDevRPMName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMName.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMName.setDescription('The name of the RPM.')
slcDevRPMVendorModel = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMVendorModel.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMVendorModel.setDescription('The manufacture and model of the RPM.')
slcDevRPMManagedVia = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("serial", 1), ("network", 2), ("snmp", 3), ("usb", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMManagedVia.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMManagedVia.setDescription('The method of control for managing the RPM.')
slcDevRPMIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMIPAddress.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMIPAddress.setDescription('For SNMP and network managed RPMs, the IP Address of the RPM.')
slcDevRPMPort = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMPort.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMPort.setDescription('For network managed RPMs, the TCP port to use to connect to \n                 the RPM.  For USB managed RPMs, the USB port the device is \n                 connected to (0 indicates a port on the front of the SLC). \n                 For serially managed RPMs, the RJ45 device port the device is \n                 connected to.')
slcDevRPMDriverOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMDriverOpts.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMDriverOpts.setDescription('Any driver options that are configured for the RPM. This \n                 option is mostly used for the USB vendor and product id.')
slcDevRPMStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMStatus.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMStatus.setDescription("The current status for the RPM; for example, 'OL' to \n                 indicate 'Online' for a UPS.  This object may be blank if \n                 the device does not report a status, or if the device is \n                 not in an error state.")
slcDevRPMFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMFirmwareVersion.setDescription('The current firmware version of the RPM.  This object may be \n                 blank if the device does not report its firmware version.')
slcDevRPMSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMSerialNumber.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMSerialNumber.setDescription('The serial number of the RPM.  This object may be blank if \n                 the device does not report its serial number.')
slcDevRPMMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMMACAddress.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMMACAddress.setDescription('The hardware address of the ethernet port of the RPM. \n                 This object may be blank if the device does not report \n                 its MAC address.')
slcDevRPMNumOutlets = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMNumOutlets.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMNumOutlets.setDescription('The number of power outlets that the RPM has.')
slcDevRPMOutletsOn = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMOutletsOn.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletsOn.setDescription('The number of RPM outlets that are currently turned on. \n                 A negative value indicates that the RPM does not report \n                 how many outlets are turned on.')
slcDevRPMSNMPReadComm = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMSNMPReadComm.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMSNMPReadComm.setDescription('For SNMP managed RPMs, the SNMP read (get) community.')
slcDevRPMAdminLogin = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMAdminLogin.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMAdminLogin.setDescription('For serial or network managed RPMs, the administrator login.')
slcDevRPMLogStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMLogStatus.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMLogStatus.setDescription('Indicates how frequently the status for the RPM is logged. \n                 A value of 0 indicates that logging is disabled.')
slcDevRPMCriticalSNMPTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 17), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMCriticalSNMPTraps.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMCriticalSNMPTraps.setDescription('If enabled, indicates that the slcEventRPMAction trap will \n                 be sent for critical events for the RPM.')
slcDevRPMCriticalEmails = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMCriticalEmails.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMCriticalEmails.setDescription('An email address to send emails to for critical events for \n                 the RPM.')
slcDevRPMProvidesSLCPower = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 19), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMProvidesSLCPower.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMProvidesSLCPower.setDescription('If enabled, indicates that the RPM provides power to the SLC.')
slcDevRPMOnLowBattery = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("shutdownThisUPS", 1), ("shutdownAllUPS", 2), ("allowBatteryToFail", 3), ("shutdownSLCUPS", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMOnLowBattery.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOnLowBattery.setDescription("Indicates the action taken when a UPS is on battery and \n                 reaches a 'low battery' state.  Applies to UPS devices only.")
slcDevRPMShutdownOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMShutdownOrder.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMShutdownOrder.setDescription("If a UPS reaches a 'low battery' state and its\n                 slcDevRPMOnLowBattery setting is shutdownAllUPS, this\n                 indicates the order in which this RPM will be shutdown as\n                 all UPSes are shutdown.  All UPSes with a shutdown order of \n                 '1' will be shutdown first, followed by all UPSes with a \n                 shutdown order of '2', etc. Shutdown orders are in the range \n                 of 1 to 49, with 50 being reserved for UPSes that provide \n                 power to the SLC - they will always be shutdown last. \n                 A value of 0 indicates that this UPS will not be shutdown. \n                 Applies to UPS devices only.")
slcDevRPMLoad = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1000))).setUnits('tenths of a percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMLoad.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMLoad.setDescription('The current load of the RPM expressed as a percentage. \n                  The value is in tenths of a percent.  A negative value \n                  indicates that the RPM does not report load values.')
slcDevRPMLoadOverThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1000))).setUnits('tenths of a percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMLoadOverThreshold.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMLoadOverThreshold.setDescription('The load when the RPM switches to an overload condition, \n                  expressed as a percentage.  The value is in tenths of a \n                  percent.  A negative value indicates that the RPM does not \n                  report over load threshold values.')
slcDevRPMBatteryCharge = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 1000))).setUnits('tenths of a percent').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMBatteryCharge.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMBatteryCharge.setDescription('The current battery charge for the the RPM, expressed as \n                  a percentage.  The value is in tenths of a percent.  A \n                  negative value indicates that the RPM does not report \n                  battery charge values.')
slcDevRPMBatteryRuntime = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 25), TimeTicks()).setUnits('hundredths of seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMBatteryRuntime.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMBatteryRuntime.setDescription('The number of seconds in the RPM remaining battery life.\n                  A value of 0 indicates that the RPM does not report battery \n                  runtime values.')
slcDevRPMBeeperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 26), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMBeeperStatus.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMBeeperStatus.setDescription('If enabled, indicates that the RPM beeper is enabled. \n                 A value of 0 indicates that the RPM does not report beeper\n                 status.')
slcDevRPMTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 27), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMTemperature.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMTemperature.setDescription('The internal temperature of the RPM, given in Celsius. \n                 A value of less than or equal to zero indicates that the \n                 RPM does not report temperature values.')
slcDevRPMUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 1, 1, 28), TimeTicks()).setUnits('hundredths of seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMUptime.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMUptime.setDescription('The number of seconds the RPM has been up.  A value of 0 \n                  indicates that the RPM does not report uptime values.')
slcDevRPMStatusTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2), )
if mibBuilder.loadTexts: slcDevRPMStatusTable.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMStatusTable.setDescription('Table of RPM status entries.')
slcDevRPMStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevRPMId"), (0, "LANTRONIX-SLC-MIB", "RPMTowerIndex"))
if mibBuilder.loadTexts: slcDevRPMStatusEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMStatusEntry.setDescription('An entry containing status information for an RPM. The SLC\n                 supports up to two towers or units per RPM.')
slcDevRPMCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 1), Integer32()).setUnits('tenths of Amps').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMCurrent.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMCurrent.setDescription('The total current level, in tenths of Amps, for all outlets,\n                 on a given RPM tower or unit. If the value is negative, the \n                 RPM does not report current for the tower or unit.')
slcDevRPMInputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 2), Integer32()).setUnits('tenths of Volts').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMInputVoltage.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMInputVoltage.setDescription('The input voltage, in tenths of Volts, on a given RPM tower \n                 or unit. If the value is negative, the RPM does not report \n                 input voltage for the tower or unit.')
slcDevRPMApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 3), Integer32()).setUnits('tenths of Volt-Amps').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMApparentPower.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMApparentPower.setDescription('The apparent power, in tenths of Volt-Amps, on a given RPM \n                 tower or unit. If the value is negative, the RPM does not \n                 report apparent power for the tower or unit.')
slcDevRPMNominalApparentPower = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 4), Integer32()).setUnits('tenths of Volt-Amps').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMNominalApparentPower.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMNominalApparentPower.setDescription('The nominal apparent power, in tenths of Volt-Amps, on a \n                 given RPM tower or unit. If the value is negative, the RPM \n                 does not report nominal apparent power for the tower or unit.')
slcDevRPMRealPower = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 5), Integer32()).setUnits('tenths of Watts').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMRealPower.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMRealPower.setDescription('The real power, in tenths of Watts, on a given RPM tower or \n                 unit. If the value is negative, the RPM does not report \n                 real power for the tower or unit.')
slcDevRPMNominalRealPower = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 2, 1, 6), Integer32()).setUnits('tenths of Watts').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMNominalRealPower.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMNominalRealPower.setDescription('The nominal real power, in tenths of Watts, on a given RPM \n                 tower or unit. If the value is negative, the RPM does not \n                 report nominal real power for the tower or unit.')
slcDevRPMOutletTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3), )
if mibBuilder.loadTexts: slcDevRPMOutletTable.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletTable.setDescription('Table of RPM outlet status and control entries.')
slcDevRPMOutletEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcDevRPMId"), (0, "LANTRONIX-SLC-MIB", "RPMOutletIndex"))
if mibBuilder.loadTexts: slcDevRPMOutletEntry.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletEntry.setDescription('An entry containing status and control for outlets on an RPM.')
slcDevRPMOutletName = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMOutletName.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletName.setDescription('The current name of the RPM outlet.  This will be blank if \n                 the RPM device does not report outlet names.')
slcDevRPMOutletState = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("off", 2), ("on", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMOutletState.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletState.setDescription('The current state of the RPM outlet.')
slcDevRPMOutletCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3, 1, 3), Integer32()).setUnits('tenths of Amps').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevRPMOutletCurrent.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletCurrent.setDescription('The current level, in tenths of Amps, for the RPM outlet.  \n                 This will be negative if the RPM does not report current\n                 values for the outlet.')
slcDevRPMOutletAction = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 4, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noAction", 1), ("turnOff", 2), ("turnOn", 3), ("cyclePower", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slcDevRPMOutletAction.setStatus('current')
if mibBuilder.loadTexts: slcDevRPMOutletAction.setDescription('Performs an action to change the state of an outlet on an \n                 RPM.  A read of this object always returns the value \n                 noAction(1). If the RPM supports individual outlet control, \n                 a command will be sent to the RPM to change the outlet state. \n                 Requests for invalid outlets or RPMs that do not support \n                 individual outlet control will return an error.')
slcConnNumber = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnNumber.setStatus('current')
if mibBuilder.loadTexts: slcConnNumber.setDescription('The number of entries in the Connections table.')
slcConnTable = MibTable((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2), )
if mibBuilder.loadTexts: slcConnTable.setStatus('current')
if mibBuilder.loadTexts: slcConnTable.setDescription('Table of connection entries.  The number of entries is given \n                 by the value of slcConnNumber.')
slcConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1), ).setIndexNames((0, "LANTRONIX-SLC-MIB", "slcConnIndex"))
if mibBuilder.loadTexts: slcConnEntry.setStatus('current')
if mibBuilder.loadTexts: slcConnEntry.setDescription('An entry containing a connection.')
slcConnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnIndex.setStatus('current')
if mibBuilder.loadTexts: slcConnIndex.setDescription('Reference index for each connection.')
slcConnEndPt1 = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnEndPt1.setStatus('current')
if mibBuilder.loadTexts: slcConnEndPt1.setDescription('A description of one of the end points of the connection.')
slcConnEndPt2 = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnEndPt2.setStatus('current')
if mibBuilder.loadTexts: slcConnEndPt2.setDescription('A description of one of the end points of the connection.')
slcConnFlow = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bidirectional", 1), ("endpt1toendpt2", 2), ("endpt2toendpt1", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnFlow.setStatus('current')
if mibBuilder.loadTexts: slcConnFlow.setDescription('The direction that data is flowing in the connection.')
slcConnUser = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnUser.setStatus('current')
if mibBuilder.loadTexts: slcConnUser.setDescription('The user that initiated the connection.')
slcConnDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 6), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnDuration.setStatus('current')
if mibBuilder.loadTexts: slcConnDuration.setDescription('The duration, in seconds, that the connection has existed.')
slcConnDurationStr = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnDurationStr.setStatus('current')
if mibBuilder.loadTexts: slcConnDurationStr.setDescription('The duration, formatted in hours:minutes:seconds, that the \n                 connection has existed.')
slcConnIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 8), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnIdle.setStatus('current')
if mibBuilder.loadTexts: slcConnIdle.setDescription('The amount of time that the connection has been idle, \n                 in seconds.')
slcConnIdleStr = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnIdleStr.setStatus('current')
if mibBuilder.loadTexts: slcConnIdleStr.setDescription('The amount of time that the connection has been idle,\n                 formatted in hours:minutes:seconds.')
slcConnSourceIP = MibTableColumn((1, 3, 6, 1, 4, 1, 244, 1, 1, 5, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcConnSourceIP.setStatus('current')
if mibBuilder.loadTexts: slcConnSourceIP.setDescription('For network (Telnet and SSH) connections into the SLC, the \n                 source IP Address.')
slcSystemModel = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemModel.setStatus('current')
if mibBuilder.loadTexts: slcSystemModel.setDescription('The model of the SLC: SLC8, SLC16, SLC32, SLC48, SLC8008, \n                 SLC8016, SLC8024, SLC8032, SLC8040, SLC8048.')
slcSystemSerialNo = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemSerialNo.setStatus('current')
if mibBuilder.loadTexts: slcSystemSerialNo.setDescription('The serial number of the SLC.')
slcSystemFWRev = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemFWRev.setStatus('current')
if mibBuilder.loadTexts: slcSystemFWRev.setDescription('The firmware version of the SLC.')
slcSystemLoadVia = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ftp", 1), ("tftp", 2), ("sftp", 3), ("slm", 4), ("https", 5), ("nfs", 6), ("pccard", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLoadVia.setStatus('current')
if mibBuilder.loadTexts: slcSystemLoadVia.setDescription('The method used for firmware updates.')
slcSystemFTPServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemFTPServer.setStatus('current')
if mibBuilder.loadTexts: slcSystemFTPServer.setDescription('The IP Address of the FTP/TFTP server used for firmware \n                 updates, and for saving and restoring configurations.')
slcSystemFTPPath = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemFTPPath.setStatus('current')
if mibBuilder.loadTexts: slcSystemFTPPath.setDescription('The path on the FTP server used for firmware updates, and \n                 for saving and restoring configurations.')
slcSystemKeypadLock = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 7), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemKeypadLock.setStatus('current')
if mibBuilder.loadTexts: slcSystemKeypadLock.setDescription('If enabled, the LCD keypad is locked for editing \n                 configuration.  The keys can only be used to view settings.')
slcSystemTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemTimeZone.setStatus('current')
if mibBuilder.loadTexts: slcSystemTimeZone.setDescription('The time zone of the SLC.')
slcSystemWelcomeBanner = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWelcomeBanner.setStatus('current')
if mibBuilder.loadTexts: slcSystemWelcomeBanner.setDescription('The banner displayed before the login prompt.')
slcSystemLoginBanner = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLoginBanner.setStatus('current')
if mibBuilder.loadTexts: slcSystemLoginBanner.setDescription('The banner displayed after successful login.')
slcSystemLogoutBanner = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLogoutBanner.setStatus('current')
if mibBuilder.loadTexts: slcSystemLogoutBanner.setDescription('The banner displayed after logout.')
slcSystemWebTimeout = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 120), ))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebTimeout.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebTimeout.setDescription('The timeout (in minutes) for web sessions.  A value of 0 \n                 indicates that timeouts are disabled.')
slcSystemWebGadget = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 13), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebGadget.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebGadget.setDescription('If enabled, iGoogle Gadget web content is enabled.')
slcSystemAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("rebootSLC", 2), ("shutdownSLC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slcSystemAction.setStatus('current')
if mibBuilder.loadTexts: slcSystemAction.setDescription('Performs an action on the SLC.  A read of this object always \n                 returns the value noAction(1).  Setting this object to \n                 rebootSLC(2) will terminate all connections and reboot the \n                 SLC.  Setting this object to shutdownSLC(3) will terminate \n                 all connections and shutdown the SLC so it can be powered off.')
slcSystemSSHPreAuthBanner = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemSSHPreAuthBanner.setStatus('current')
if mibBuilder.loadTexts: slcSystemSSHPreAuthBanner.setDescription('The banner displayed prior to SSH authentication.')
slcSystemSiteRackRow = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemSiteRackRow.setStatus('current')
if mibBuilder.loadTexts: slcSystemSiteRackRow.setDescription('The identifier of the row of racks in a data center \n                 containing the SLC.')
slcSystemSiteRackCluster = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemSiteRackCluster.setStatus('current')
if mibBuilder.loadTexts: slcSystemSiteRackCluster.setDescription('The identifier of the group of racks in a given row \n                 (slcSystemSiteRackRow) containing the SLC.')
slcSystemSiteRack = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemSiteRack.setStatus('current')
if mibBuilder.loadTexts: slcSystemSiteRack.setDescription('The identifier of the rack in a given rack group\n                 (slcSystemSiteRackCluster) containing the SLC.')
slcSystemLCDScreens = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDScreens.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDScreens.setDescription('A string describing the enabled LCD screens, in the order they \n                 are displayed.  Each screen is separated by a comma.  The \n                 possible screens are Current Time, Network, Console, Release, \n                 Date/Time, Device Ports, Location, Temperature and User \n                 Strings.')
slcSystemLCDUserStrLine1 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDUserStrLine1.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDUserStrLine1.setDescription('For the LCD screen User Strings, this is the first line \n                 displayed on the LCD.')
slcSystemLCDUserStrLine2 = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDUserStrLine2.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDUserStrLine2.setDescription('For the LCD screen User Strings, this is the second line \n                 displayed on the LCD.')
slcSystemLCDScrolling = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 22), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDScrolling.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDScrolling.setDescription('If enabled, the LCD automatically scrolls through the \n                 enabled screens.')
slcSystemLCDScrollDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDScrollDelay.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDScrollDelay.setDescription('If LCD scrolling is enabled (slcSystemLCDScrolling), the \n                 delay in seconds between displaying screens.')
slcSystemLCDIdleDelay = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 60))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemLCDIdleDelay.setStatus('current')
if mibBuilder.loadTexts: slcSystemLCDIdleDelay.setDescription('If LCD scrolling is enabled (slcSystemLCDScrolling), the \n                 number of seconds after keypad input before auto-scrolling \n                 restarts.')
slcSystemInternalTemp = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 25), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemInternalTemp.setStatus('current')
if mibBuilder.loadTexts: slcSystemInternalTemp.setDescription('The internal temperature of the SLC, given in Celsius. \n                 A value of 9999 is returned if an error is encountered \n                 reading the temperature.')
slcSystemWebProtocol = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tlsv1SSLv3", 1), ("tlsv1SSLv3SSLv2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebProtocol.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebProtocol.setDescription('The protocol used by the web server.  This setting is no \n                 longer available; the web server is configured to only \n                 support the TLS protocol.')
slcSystemWebCipher = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("highMedium", 1), ("highMediumLow", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebCipher.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebCipher.setDescription('The strength of the cipher used by the web server.  A cipher \n                 with high strength uses 256, 168 or 128 bits; a cipher with \n                 medium strength uses 128 bits; a cipher with low strength \n                 uses 64 or 56 bits.')
slcSystemModelString = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemModelString.setStatus('current')
if mibBuilder.loadTexts: slcSystemModelString.setDescription('A string that describes the SLC model: \n                 <Model>-<Power Supply>-<PCCard or USB>')
slcSystemWebGroup = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 29), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebGroup.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebGroup.setDescription('The group or groups that may access the web.')
slcSystemWebInterface = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebInterface.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebInterface.setDescription('A string describing the interfaces the web is available on; \n                 for example: Eth1,Eth2,PPP.')
slcSystemWebBanner = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 31), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebBanner.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebBanner.setDescription('The banner on the web home page.')
slcSystemInternalTempLow = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 32), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemInternalTempLow.setStatus('current')
if mibBuilder.loadTexts: slcSystemInternalTempLow.setDescription('The minimum acceptable internal temperature for the SLC, \n                 in Celsius.')
slcSystemInternalTempHigh = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 33), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemInternalTempHigh.setStatus('current')
if mibBuilder.loadTexts: slcSystemInternalTempHigh.setDescription('The maximum acceptable internal temperature for the SLC, \n                 in Celsius.')
slcSystemCalibrateTemp = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 34), Integer32()).setUnits('Celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemCalibrateTemp.setStatus('current')
if mibBuilder.loadTexts: slcSystemCalibrateTemp.setDescription('An offset in Celsius for calibrating the internal temperature \n                 of the SLC.')
slcSystemWebServer = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 6, 35), EnabledState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSystemWebServer.setStatus('current')
if mibBuilder.loadTexts: slcSystemWebServer.setDescription('If enabled, the web server will run and listen on TCP \n                 ports 80 and 443 (all requests to port 80 are redirected \n                 to port 443).')
slcEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 0))
slcEventObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 244, 1, 1, 7))
slcPowerSupplyId = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("powerSupplyA", 1), ("powerSupplyB", 2), ("primaryInlet", 3), ("secondaryInlet", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPowerSupplyId.setStatus('current')
if mibBuilder.loadTexts: slcPowerSupplyId.setDescription('The identifier of the power supply in a slcEventPowerSupply \n                 trap.')
slcPowerSupplyAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("powerSupplyFailed", 1), ("powerSupplyRestored", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPowerSupplyAction.setStatus('current')
if mibBuilder.loadTexts: slcPowerSupplyAction.setDescription('The action that occurred for a power supply in a \n                 slcEventPowerSupply trap.')
slcDevPortNumBytes = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 3), Integer32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortNumBytes.setStatus('current')
if mibBuilder.loadTexts: slcDevPortNumBytes.setDescription('The number of bytes received on a Device Port to trigger a \n                 slcEventDevicePortData or slcEventDevicePortSLMData trap.')
slcDevPortData = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortData.setStatus('current')
if mibBuilder.loadTexts: slcDevPortData.setDescription('The character data received on a Device Port to trigger a \n                 slcEventDevicePortData trap.')
slcDevPortStartByte = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortStartByte.setStatus('current')
if mibBuilder.loadTexts: slcDevPortStartByte.setDescription('The starting byte within the logging buffer of data received \n                 on a Device Port, which triggered a slcEventDevicePortSLMData \n                 trap.')
slcDevPortTimeFrame = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 6), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortTimeFrame.setStatus('current')
if mibBuilder.loadTexts: slcDevPortTimeFrame.setDescription('The time frame, in seconds, after which a \n                 slcEventDevicePortSLMData trap is sent to the SLM to trigger \n                 retrieval of Device Port data.')
slcDevPortDeviceErrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lowPower", 1), ("damageOrTamper", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortDeviceErrorStatus.setStatus('current')
if mibBuilder.loadTexts: slcDevPortDeviceErrorStatus.setDescription('The status returned when an error occurs in a device connected \n                 to a Device Port.')
slcHostname = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcHostname.setStatus('current')
if mibBuilder.loadTexts: slcHostname.setDescription('The hostname of the SLC sending the trap.')
slcPCCardSlot = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("upperSlot", 1), ("lowerSlot", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardSlot.setStatus('current')
if mibBuilder.loadTexts: slcPCCardSlot.setDescription('The PC Card slot indicated for the trap.')
slcPCCardAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("cardInserted", 1), ("cardRemoved", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardAction.setStatus('current')
if mibBuilder.loadTexts: slcPCCardAction.setDescription('The action that occurred on a PC Card slot.')
slcPCCardType = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("storage", 2), ("modem", 3), ("isdn", 4), ("wireless", 5), ("gsmmodem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcPCCardType.setStatus('current')
if mibBuilder.loadTexts: slcPCCardType.setDescription('The type of card inserted in a PC Card slot.')
slcUSBAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("deviceInserted", 1), ("deviceRemoved", 2), ("noModemDialTone", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcUSBAction.setStatus('current')
if mibBuilder.loadTexts: slcUSBAction.setDescription('The action that occurred on a USB Port.')
slcUSBType = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("storage", 2), ("modem", 3), ("isdn", 4), ("wireless", 5), ("gsmmodem", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcUSBType.setStatus('current')
if mibBuilder.loadTexts: slcUSBType.setDescription('The type of device inserted in a USB Port.')
slcDevPortErrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dataDrop", 1), ("invalidIOConfiguration", 2), ("errorIOModules", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcDevPortErrorStatus.setStatus('current')
if mibBuilder.loadTexts: slcDevPortErrorStatus.setDescription('The status returned when an error occurs in a Device Port. \n                 dataDrop applies to a specific Device Port and is sent when \n                 a Device Port is required to discard data in order to keep \n                 data moving for all connections to the Device Port. \n                 invalidIOConfiguration and errorIOModules apply to all \n                 Device Ports.  invalidIOConfiguration is sent when the I/O \n                 modules installed in a SLC are in an invalid configuration. \n                 errorIOModules is sent when an error is detected in one or \n                 more I/O modules.')
slcSDCardAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("deviceInserted", 1), ("deviceRemoved", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcSDCardAction.setStatus('current')
if mibBuilder.loadTexts: slcSDCardAction.setDescription('The action that occurred on the SD Card slot.')
slcRPMAction = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcRPMAction.setStatus('current')
if mibBuilder.loadTexts: slcRPMAction.setDescription('The action that occurred on a Remote Power Manager.')
slcEventHost = MibScalar((1, 3, 6, 1, 4, 1, 244, 1, 1, 7, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slcEventHost.setStatus('current')
if mibBuilder.loadTexts: slcEventHost.setDescription('The name or IP address of a host in a SLC event.')
slcEventPowerSupply = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 1)).setObjects(("LANTRONIX-SLC-MIB", "slcPowerSupplyId"), ("LANTRONIX-SLC-MIB", "slcPowerSupplyAction"))
if mibBuilder.loadTexts: slcEventPowerSupply.setStatus('current')
if mibBuilder.loadTexts: slcEventPowerSupply.setDescription('The SNMP trap that is generated when a power supply fails \n                 or is restored.')
slcEventSysadminPassword = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 2))
if mibBuilder.loadTexts: slcEventSysadminPassword.setStatus('current')
if mibBuilder.loadTexts: slcEventSysadminPassword.setDescription('The SNMP trap that is generated when the sysadmin user \n                 password is changed.')
slcEventSLCShutdown = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 3))
if mibBuilder.loadTexts: slcEventSLCShutdown.setStatus('current')
if mibBuilder.loadTexts: slcEventSLCShutdown.setDescription('The SNMP trap that is generated when the SLC is shutdown.')
slcEventDevicePortData = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 4)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortNumBytes"), ("LANTRONIX-SLC-MIB", "slcDevPortData"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgEmailTextString"), ("LANTRONIX-SLC-MIB", "slcHostname"))
if mibBuilder.loadTexts: slcEventDevicePortData.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortData.setDescription('The SNMP trap that is generated when data is received on a \n                 Device Port, and the Device Port has been configured to \n                 generate a trap when a specified number of bytes \n                 (slcDevPortNumBytes) or a specified sequence of bytes \n                 (slcDevPortCfgEmailTextString) is received.  \n                 slcDevPortData is the actual data received.')
slcEventDevicePortSLMData = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 5)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortNumBytes"), ("LANTRONIX-SLC-MIB", "slcDevPortStartByte"))
if mibBuilder.loadTexts: slcEventDevicePortSLMData.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortSLMData.setDescription('The SNMP trap that is generated when data is received on a \n                 Device Port, and the Device Port has been configured to \n                 generate a trap designated for the Secure Lantronix Management \n                 Appliance (SLM) when a specified number of bytes is received \n                 or a specified time frame is passed.  This trap is only sent \n                 to the SLM.')
slcEventDevicePortSLMConfig = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 6)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortNumBytes"), ("LANTRONIX-SLC-MIB", "slcDevPortTimeFrame"))
if mibBuilder.loadTexts: slcEventDevicePortSLMConfig.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortSLMConfig.setDescription('The SNMP trap that is generated when the SLM logging \n                 configuration is changed for a Device Port, and the Device \n                 Port has been configured to generate a trap designated for \n                 the Secure Lantronix Management Appliance (SLM).  This trap \n                 specifies the new SLM logging configuration for the Device \n                 Port, and is only sent to the SLM.')
slcEventDevicePortDeviceLowTemp = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 7)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevTemperature"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevLowTemp"))
if mibBuilder.loadTexts: slcEventDevicePortDeviceLowTemp.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortDeviceLowTemp.setDescription('The SNMP trap that is generated when the low temperature \n                 limit for a sensor connected to a Device Port is exceeded.')
slcEventDevicePortDeviceHighTemp = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 8)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevTemperature"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevHighTemp"))
if mibBuilder.loadTexts: slcEventDevicePortDeviceHighTemp.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortDeviceHighTemp.setDescription('The SNMP trap that is generated when the high temperature \n                 limit for a sensor connected to a Device Port is exceeded.')
slcEventDevicePortDeviceLowHumidity = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 9)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevHumidity"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevLowHumidity"))
if mibBuilder.loadTexts: slcEventDevicePortDeviceLowHumidity.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortDeviceLowHumidity.setDescription('The SNMP trap that is generated when the low humidity \n                 limit for a sensor connected to a Device Port is exceeded.')
slcEventDevicePortDeviceHighHumidity = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 10)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevHumidity"), ("LANTRONIX-SLC-MIB", "slcDevPortCfgDevHighHumidity"))
if mibBuilder.loadTexts: slcEventDevicePortDeviceHighHumidity.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortDeviceHighHumidity.setDescription('The SNMP trap that is generated when the high humidity \n                 limit for a sensor connected to a Device Port is exceeded.')
slcEventDevicePortDeviceError = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 11)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortDeviceErrorStatus"))
if mibBuilder.loadTexts: slcEventDevicePortDeviceError.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortDeviceError.setDescription('The SNMP trap that is generated when an error occurs on a \n                 device connected to a Device Port.')
slcEventPCCardAction = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 12)).setObjects(("LANTRONIX-SLC-MIB", "slcPCCardSlot"), ("LANTRONIX-SLC-MIB", "slcPCCardAction"), ("LANTRONIX-SLC-MIB", "slcPCCardType"))
if mibBuilder.loadTexts: slcEventPCCardAction.setStatus('current')
if mibBuilder.loadTexts: slcEventPCCardAction.setDescription('The SNMP trap that is generated when an event occurs on one \n                 of the PC Card slots.')
slcEventSLCInternalTemp = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 13)).setObjects(("LANTRONIX-SLC-MIB", "slcSystemInternalTemp"))
if mibBuilder.loadTexts: slcEventSLCInternalTemp.setStatus('current')
if mibBuilder.loadTexts: slcEventSLCInternalTemp.setDescription('The SNMP trap that is generated when the internal temperature \n                 of the SLC is outside of the acceptable operating range.')
slcEventUSBAction = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 14)).setObjects(("LANTRONIX-SLC-MIB", "slcDevUSBId"), ("LANTRONIX-SLC-MIB", "slcUSBAction"), ("LANTRONIX-SLC-MIB", "slcUSBType"))
if mibBuilder.loadTexts: slcEventUSBAction.setStatus('current')
if mibBuilder.loadTexts: slcEventUSBAction.setDescription('The SNMP trap that is generated when an event occurs on one \n                 of the USB Ports.')
slcEventDevicePortError = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 15)).setObjects(("LANTRONIX-SLC-MIB", "slcDevPortId"), ("LANTRONIX-SLC-MIB", "slcDevPortErrorStatus"))
if mibBuilder.loadTexts: slcEventDevicePortError.setStatus('current')
if mibBuilder.loadTexts: slcEventDevicePortError.setDescription('The SNMP trap that is generated when an error occurs on a \n                 a Device Port, or across all Device Ports.  If an error \n                 occurs across all Device Ports, slcDevPortId will be 1 (one).')
slcEventSDCardAction = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 16)).setObjects(("LANTRONIX-SLC-MIB", "slcSDCardAction"))
if mibBuilder.loadTexts: slcEventSDCardAction.setStatus('current')
if mibBuilder.loadTexts: slcEventSDCardAction.setDescription('The SNMP trap that is generated when an event occurs on the \n                 SD Card slot.')
slcEventNoDialToneAlarm = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 17))
if mibBuilder.loadTexts: slcEventNoDialToneAlarm.setStatus('current')
if mibBuilder.loadTexts: slcEventNoDialToneAlarm.setDescription('The SNMP trap that is generated when an event indicates \n                 that a no-dial-tone condition on the internal modem exists.')
slcEventRPMAction = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 18)).setObjects(("LANTRONIX-SLC-MIB", "slcDevRPMName"), ("LANTRONIX-SLC-MIB", "slcRPMAction"))
if mibBuilder.loadTexts: slcEventRPMAction.setStatus('current')
if mibBuilder.loadTexts: slcEventRPMAction.setDescription('The SNMP trap that is generated when an event occurs on one \n                 of the Remote Power Manager (UPS or PDU) devices.')
slcEventPingHostFails = NotificationType((1, 3, 6, 1, 4, 1, 244, 1, 1, 0, 19)).setObjects(("LANTRONIX-SLC-MIB", "slcEventHost"))
if mibBuilder.loadTexts: slcEventPingHostFails.setStatus('current')
if mibBuilder.loadTexts: slcEventPingHostFails.setDescription('The SNMP trap that is generated when the SLC is monitoring \n                 a host with regular pings and the SLC is unable to ping the \n                 host.  The trap includes either the name or the IP address \n                 of the failed host.')
mibBuilder.exportSymbols("LANTRONIX-SLC-MIB", slcDevUSBCfgSSHState=slcDevUSBCfgSSHState, slcDevConShowLines=slcDevConShowLines, slcPCCardAction=slcPCCardAction, slcDevRPMNumOutlets=slcDevRPMNumOutlets, slcNetEthGateway=slcNetEthGateway, slcPCCardCfgGSMPIN=slcPCCardCfgGSMPIN, slcDevPortCfgEmailByteThresh=slcDevPortCfgEmailByteThresh, slcDevIntModemTimeout=slcDevIntModemTimeout, slcDevRPMCfgEntry=slcDevRPMCfgEntry, slcEventDevicePortData=slcEventDevicePortData, slcNetVPNTunnel=slcNetVPNTunnel, slcPCCardCfgCallerIdLogging=slcPCCardCfgCallerIdLogging, slcServSSHTimeout=slcServSSHTimeout, slcDevPortStartByte=slcDevPortStartByte, slcDevUSBCfgAuth=slcDevUSBCfgAuth, slcDevPortCfgLogins=slcDevPortCfgLogins, slcDevConBaud=slcDevConBaud, slcDevPortCfgTCPAuth=slcDevPortCfgTCPAuth, slcSystemLogoutBanner=slcSystemLogoutBanner, slcDevConParity=slcDevConParity, slcAuthLocalMultipleSysadminLogins=slcAuthLocalMultipleSysadminLogins, slcAuthLDAPGroupFilter=slcAuthLDAPGroupFilter, slcDevPortCfgNumberOfSessionsMessage=slcDevPortCfgNumberOfSessionsMessage, slcAuthRADIUSClearPorts=slcAuthRADIUSClearPorts, slcDevPortNumBytes=slcDevPortNumBytes, slcDevRPMLoad=slcDevRPMLoad, slcAuthLocalUserUID=slcAuthLocalUserUID, slcDevUSBCfgStopBits=slcDevUSBCfgStopBits, slcNetRouteRIPVersion=slcNetRouteRIPVersion, slcPCCardCfgIdleTimeout=slcPCCardCfgIdleTimeout, slcDevUSBCfgDialbackRetries=slcDevUSBCfgDialbackRetries, slcDevPortCfgParity=slcDevPortCfgParity, slcPCCardCfgCardId=slcPCCardCfgCardId, slcServSiteCHAPSecret=slcServSiteCHAPSecret, slcDevRPMMACAddress=slcDevRPMMACAddress, slcConnections=slcConnections, slcAuthLDAPState=slcAuthLDAPState, slcAuthKerbKDC=slcAuthKerbKDC, slcNetEthPreferIPv4DNS=slcNetEthPreferIPv4DNS, slcDevIntModemAuth=slcDevIntModemAuth, slcNetVPNESPEncryption=slcNetVPNESPEncryption, slcDevPortCfgEmailTextString=slcDevPortCfgEmailTextString, slcDevPortCfgModemState=slcDevPortCfgModemState, slcAuthKerbDialback=slcAuthKerbDialback, slcAuthGroups=slcAuthGroups, slcDevPortCfgViewPortLog=slcDevPortCfgViewPortLog, slcPCCardCfgGroup=slcPCCardCfgGroup, slcDevPortCfgRemoteIP=slcDevPortCfgRemoteIP, slcDevPortCfgTCPTimeout=slcDevPortCfgTCPTimeout, slcDevUSBCfgCallerIdATCmd=slcDevUSBCfgCallerIdATCmd, slcConnSourceIP=slcConnSourceIP, slcDevRPMApparentPower=slcDevRPMApparentPower, slcPCCardCfgIndex=slcPCCardCfgIndex, slcSystemLCDUserStrLine2=slcSystemLCDUserStrLine2, slcEventObjects=slcEventObjects, slcNetFirewallReject=slcNetFirewallReject, slcPCCardCfgStorageFS=slcPCCardCfgStorageFS, slcNetFirewallMappingIfac=slcNetFirewallMappingIfac, slcServNTPServer=slcServNTPServer, slcDevPortCfgLocalState=slcDevPortCfgLocalState, slcDevUSBCfgCardType=slcDevUSBCfgCardType, slcAuthGroupRights=slcAuthGroupRights, slcAuthLDAPBase=slcAuthLDAPBase, slcAuthRemoteUserDataPorts=slcAuthRemoteUserDataPorts, slcNetVPNLocalSubnet=slcNetVPNLocalSubnet, slcDevGlobalListenPorts=slcDevGlobalListenPorts, slcServAuditSize=slcServAuditSize, slcAuthLDAPEncrypt=slcAuthLDAPEncrypt, slcAuthNISGroup=slcAuthNISGroup, slcDevPortCfgTelnetPort=slcDevPortCfgTelnetPort, slcDevIntModemNATState=slcDevIntModemNATState, slcPCCardCfgTimeout=slcPCCardCfgTimeout, slcDevUSBCfgTimeout=slcDevUSBCfgTimeout, slcDevConGroup=slcDevConGroup, slcDevRPMCurrent=slcDevRPMCurrent, slcDevIntModemDialbackMode=slcDevIntModemDialbackMode, slcPCCardCfgInitScript=slcPCCardCfgInitScript, slcNetEthKeepaliveNumberOfProbes=slcNetEthKeepaliveNumberOfProbes, slcDevUSBCfgRestartDelay=slcDevUSBCfgRestartDelay, slcDevPortCfgTCPPort=slcDevPortCfgTCPPort, slcSystemSiteRackCluster=slcSystemSiteRackCluster, slcServHostList=slcServHostList, slcDevPortCfgEmailDelay=slcDevPortCfgEmailDelay, slcServSysRemoteServer2IPv6=slcServSysRemoteServer2IPv6, slcNetVPNXAUTHClientLogin=slcNetVPNXAUTHClientLogin, slcAuthTACACSServer3IPv6=slcAuthTACACSServer3IPv6, slcNetEthIfMode=slcNetEthIfMode, slcDevPortCfgCBCPServerAllowNoCallback=slcDevPortCfgCBCPServerAllowNoCallback, slcSystemCalibrateTemp=slcSystemCalibrateTemp, slcDevPortCfgSLMLoggingState=slcDevPortCfgSLMLoggingState, slcDevUSBCfgDialbackDelay=slcDevUSBCfgDialbackDelay, slcAuthKerbDataPorts=slcAuthKerbDataPorts, slcAuthGroupDataPorts=slcAuthGroupDataPorts, slcAuthLocalUserDataPorts=slcAuthLocalUserDataPorts, slcDevUSBCfgCBCPClientType=slcDevUSBCfgCBCPClientType, slcDevPortCfgDialoutNum=slcDevPortCfgDialoutNum, slcServSiteStaticRouteMask=slcServSiteStaticRouteMask, slcAuthRADIUSServerIndex=slcAuthRADIUSServerIndex, slcDevPortStateParityErrors=slcDevPortStateParityErrors, slcAuthTACACSDataPorts=slcAuthTACACSDataPorts, slcNetEthDNS2=slcNetEthDNS2, slcAuthLocalUserBreakSeq=slcAuthLocalUserBreakSeq, slcServSiteNATState=slcServSiteNATState, slcEventSysadminPassword=slcEventSysadminPassword, slcAuthRADIUSServer=slcAuthRADIUSServer, slcServSysNetworkLevel=slcServSysNetworkLevel, slcDevConStopBits=slcDevConStopBits, slcDevPortCfgDevNumOutlets=slcDevPortCfgDevNumOutlets, slcDevUSBCfgDialbackMode=slcDevUSBCfgDialbackMode, slcAuthKerbKDCPort=slcAuthKerbKDCPort, slcDevPortCfgDevHighTemp=slcDevPortCfgDevHighTemp, slcDevPortCfgDialbackDelay=slcDevPortCfgDialbackDelay, slcSystemWelcomeBanner=slcSystemWelcomeBanner, slcServSNMPLocation=slcServSNMPLocation, slcPCCardCfgSSHState=slcPCCardCfgSSHState, slcSystemWebServer=slcSystemWebServer, slcDevPortStateEntry=slcDevPortStateEntry, slcServTelnet=slcServTelnet, UserRights=UserRights, slcAuthNISRights=slcAuthNISRights, slcDevIntModemInitScript=slcDevIntModemInitScript, slcConnUser=slcConnUser, slcServSNMPv3Encryption=slcServSNMPv3Encryption, slcServSiteCBCPServerAllowNoCallback=slcServSiteCBCPServerAllowNoCallback, slcSystemFWRev=slcSystemFWRev, slcEventSLCShutdown=slcEventSLCShutdown, slcAuthGroupIndex=slcAuthGroupIndex, slcServNTPState=slcServNTPState, slcDevPortCfgGroup=slcDevPortCfgGroup, slcServNFSMountLocalDir=slcServNFSMountLocalDir, slcDevPortCfgInitScript=slcDevPortCfgInitScript, slcDevUSBCfgTelnetState=slcDevUSBCfgTelnetState, slcDevUSBCfgDialoutLogin=slcDevUSBCfgDialoutLogin, slcAuthLDAPServer=slcAuthLDAPServer, slcDevPortCfgIdleTimeout=slcDevPortCfgIdleTimeout, slcDevPowerSupplyType=slcDevPowerSupplyType, slcSystemWebGroup=slcSystemWebGroup, slcNetVPNAuthentication=slcNetVPNAuthentication, slcPCCardCfgRestartDelay=slcPCCardCfgRestartDelay, slcDevUSBCfgTelnetAuth=slcDevUSBCfgTelnetAuth, slcNetRouting=slcNetRouting, slcDevRPMOutletTable=slcDevRPMOutletTable, slcDevGlobalStartTelnetPort=slcDevGlobalStartTelnetPort, slcNetEthDNS3=slcNetEthDNS3, slcServSiteRemoteIP=slcServSiteRemoteIP, slcAuthLocalUserDialback=slcAuthLocalUserDialback, slcAuthKerberos=slcAuthKerberos, slcServSitePort=slcServSitePort, slcAuthRemoteUserGroup=slcAuthRemoteUserGroup, slcAuthRADIUSDialbackNum=slcAuthRADIUSDialbackNum, slcDevPortStateFlowControlViolations=slcDevPortStateFlowControlViolations, slcAuthNISMaster=slcAuthNISMaster, slcAuthRADIUSMenu=slcAuthRADIUSMenu, slcAuthLDAPGroupMembershipAttr=slcAuthLDAPGroupMembershipAttr, slcNetEthGatewayPrecedence=slcNetEthGatewayPrecedence, slcPCCardCfgDataBits=slcPCCardCfgDataBits, slcSystemWebBanner=slcSystemWebBanner, slcAuthRADIUSTimeout=slcAuthRADIUSTimeout, slcPCCardCfgModemState=slcPCCardCfgModemState, slcSystemWebCipher=slcSystemWebCipher, slcConnIndex=slcConnIndex, slcServWebTermBufSize=slcServWebTermBufSize, slcDevPortCfgNFSMaxFiles=slcDevPortCfgNFSMaxFiles, slcDevPortCfgSyslogState=slcDevPortCfgSyslogState, slcPCCardCfgCBCPServerAllowNoCallback=slcPCCardCfgCBCPServerAllowNoCallback, slcDevPortCfgUSBState=slcDevPortCfgUSBState, slcDevPortCfgBaud=slcDevPortCfgBaud, slcAuthRemoteUserRights=slcAuthRemoteUserRights, slcDevPortCfgToggleDTR=slcDevPortCfgToggleDTR, slcDevPortCfgAuth=slcDevPortCfgAuth, slcPCCardCfgNATState=slcPCCardCfgNATState, slcDevRPMBatteryRuntime=slcDevRPMBatteryRuntime, slcDevUSBCfgGroup=slcDevUSBCfgGroup, slcDevRPMOutletsOn=slcDevRPMOutletsOn, slcDevPortStateFramingErrors=slcDevPortStateFramingErrors, slcServAuditState=slcServAuditState, slcDevPortCfgHostList=slcDevPortCfgHostList, slcServSMTPServer=slcServSMTPServer, slcNetEthIfIndex=slcNetEthIfIndex, slcPCCardCfgCallerIdATCmd=slcPCCardCfgCallerIdATCmd, slcEventSLCInternalTemp=slcEventSLCInternalTemp, slcAuthNISEscapeSeq=slcAuthNISEscapeSeq, slcNetEthDNS1IPv6=slcNetEthDNS1IPv6, slcServPhoneHomeIP=slcServPhoneHomeIP, slcDevPortCfgPortType=slcDevPortCfgPortType, slcDevPortStateIndex=slcDevPortStateIndex, slcServSiteStaticRouteIP=slcServSiteStaticRouteIP, slcEventDevicePortError=slcEventDevicePortError, slcNetRouteStaticEntry=slcNetRouteStaticEntry, slcEventNoDialToneAlarm=slcEventNoDialToneAlarm, slcNetFirewallSSH=slcNetFirewallSSH, slcServSNMPNMS2IPv6=slcServSNMPNMS2IPv6, slcDevPortCfgSSHAuth=slcDevPortCfgSSHAuth, slcAuthKerbState=slcAuthKerbState, slcSystemKeypadLock=slcSystemKeypadLock, slcServTelnetTimeout=slcServTelnetTimeout, slcAuthLocalState=slcAuthLocalState, slcDevPortCfgDevLowTemp=slcDevPortCfgDevLowTemp, slcEvents=slcEvents, slcDevUSBCfgBaud=slcDevUSBCfgBaud, slcPCCardCfgDODAuth=slcPCCardCfgDODAuth, slcDevRPMName=slcDevRPMName, slcDevPortStateNumber=slcDevPortStateNumber, slcDevUSBCfgModemState=slcDevUSBCfgModemState, slcSystemModelString=slcSystemModelString, slcDevRPMProvidesSLCPower=slcDevRPMProvidesSLCPower, slcSystemLCDIdleDelay=slcSystemLCDIdleDelay, slcNetSecurityFIPSMode=slcNetSecurityFIPSMode, slcServSysOtherLogSize=slcServSysOtherLogSize, slcNetSecurity=slcNetSecurity, slcPCCardCfgModemMode=slcPCCardCfgModemMode, slcDevPortCfgDisconnectDSR=slcDevPortCfgDisconnectDSR, slcDevPortDeviceErrorStatus=slcDevPortDeviceErrorStatus, slcDevIntModemDialtoneCheck=slcDevIntModemDialtoneCheck, slcPCCardCfgDialbackRetries=slcPCCardCfgDialbackRetries, slcServSiteDialbackNum=slcServSiteDialbackNum, slcAuthTACACSOrder=slcAuthTACACSOrder, slcAuthLDAPUserFilter=slcAuthLDAPUserFilter, AuthOrder=AuthOrder, slcAuthNISSlave5=slcAuthNISSlave5, slcAuthLDAPClearPorts=slcAuthLDAPClearPorts, slcDevPortStateDSR=slcDevPortStateDSR, slcNetFirewallRulesetName=slcNetFirewallRulesetName, slcNetVPN=slcNetVPN, slcDevPowerSupply=slcDevPowerSupply, slcDevUSBCfgCallerIdLogging=slcDevUSBCfgCallerIdLogging, slcAuth=slcAuth, slcServSNMPContact=slcServSNMPContact, slcServAuditInSystemLog=slcServAuditInSystemLog, slcDevRPMStatusEntry=slcDevRPMStatusEntry, slcServSiteLocalIP=slcServSiteLocalIP, slcDevPortCfgPowerSupplies=slcDevPortCfgPowerSupplies, slcServSNMPNMSIPv6=slcServSNMPNMSIPv6, slcDevGlobalStartTCPPort=slcDevGlobalStartTCPPort, slcServSSHV1Incoming=slcServSSHV1Incoming, slcDevRPMCriticalEmails=slcDevRPMCriticalEmails, slcNetVPNPerfectForwardSecrecy=slcNetVPNPerfectForwardSecrecy, slcEventSDCardAction=slcEventSDCardAction, slcNetEthIfMacAddress=slcNetEthIfMacAddress, slcAuthRADIUSListenPorts=slcAuthRADIUSListenPorts, slcDevDevicePorts=slcDevDevicePorts, slcAuthLocalUserIndex=slcAuthLocalUserIndex, slcEventDevicePortDeviceLowTemp=slcEventDevicePortDeviceLowTemp, slcAuthLocalReuseHistory=slcAuthLocalReuseHistory, slcAuthGroupsNumber=slcAuthGroupsNumber, slcDevPortCfgSSHTimeoutDataDirection=slcDevPortCfgSSHTimeoutDataDirection, slcServSNMPState=slcServSNMPState, slcPCCardCfgDialbackMode=slcPCCardCfgDialbackMode, slcAuthRADIUSBreakSeq=slcAuthRADIUSBreakSeq, slcDevPortCfgDevHighHumidity=slcDevPortCfgDevHighHumidity, slcServNFSMountReadWrite=slcServNFSMountReadWrite, slcPCCardCfgGSMNetworkName=slcPCCardCfgGSMNetworkName, slcSystemAction=slcSystemAction, slcAuthTACACSServer2IPv6=slcAuthTACACSServer2IPv6)
mibBuilder.exportSymbols("LANTRONIX-SLC-MIB", slcServTelnetTelnetOut=slcServTelnetTelnetOut, slcDevPortCfgCallerIdLogging=slcDevPortCfgCallerIdLogging, slcServSNMPv3Security=slcServSNMPv3Security, slcNetRouteStaticIndex=slcNetRouteStaticIndex, slcPowerSupplyAction=slcPowerSupplyAction, slcNetEthPingFailed=slcNetEthPingFailed, slcDevPowerSupplyA=slcDevPowerSupplyA, slcAuthRemoteUserDialbackNum=slcAuthRemoteUserDialbackNum, slcAuthLocalUserEntry=slcAuthLocalUserEntry, slcAuthLDAPDataPorts=slcAuthLDAPDataPorts, slcServWebTermDeployment=slcServWebTermDeployment, slcServHostListEntry=slcServHostListEntry, slcAuthTACACSState=slcAuthTACACSState, slcDevPortCfgEmailTrigger=slcDevPortCfgEmailTrigger, slcAuthKerbGroup=slcAuthKerbGroup, slcAuthTACACS=slcAuthTACACS, slcNetEthBonding=slcNetEthBonding, slcAuthLocalAllowReuse=slcAuthLocalAllowReuse, slcDevPortCfgNFSFileState=slcDevPortCfgNFSFileState, slcPCCardCfgGSMBearerService=slcPCCardCfgGSMBearerService, slcServNFSMountIndex=slcServNFSMountIndex, slcAuthKerbClearPorts=slcAuthKerbClearPorts, slcDevRPMOutletCurrent=slcDevRPMOutletCurrent, slcServSSH=slcServSSH, slcServNFSMountMount=slcServNFSMountMount, slcDevIntModemIdleTimeout=slcDevIntModemIdleTimeout, slcAuthKerbRealm=slcAuthKerbRealm, slcSystemModel=slcSystemModel, slcServSite=slcServSite, slcDevIntModemDialoutNum=slcDevIntModemDialoutNum, slcDevIntModemModemMode=slcDevIntModemModemMode, slcAuthKerbListenPorts=slcAuthKerbListenPorts, slcPCCardCfgSSHAuth=slcPCCardCfgSSHAuth, UserGroup=UserGroup, slcServNTPLocalServer2IPv6=slcServNTPLocalServer2IPv6, slcAuthLDAPGroup=slcAuthLDAPGroup, slcDevPortCfgNumberShowLines=slcDevPortCfgNumberShowLines, slcNetVPNLocalId=slcNetVPNLocalId, slcDevPortStateCTS=slcDevPortStateCTS, slcServSiteIndex=slcServSiteIndex, slcAuthLocalUserGroup=slcAuthLocalUserGroup, slcDevUSBCfgGSMPIN=slcDevUSBCfgGSMPIN, slcDevPortCfgPowerManagementSeq=slcDevPortCfgPowerManagementSeq, slcNetEthIfTable=slcNetEthIfTable, slcAuthRADIUS=slcAuthRADIUS, slcAuthRADIUSEscapeSeq=slcAuthRADIUSEscapeSeq, slcPowerSupplyId=slcPowerSupplyId, slcDevUSBCfgGSMBearerService=slcDevUSBCfgGSMBearerService, slcDevIntModemGroup=slcDevIntModemGroup, slcAuthKerbBreakSeq=slcAuthKerbBreakSeq, slcDevUSBCfgGSMContextID=slcDevUSBCfgGSMContextID, slcDevRPM=slcDevRPM, slcServSiteTable=slcServSiteTable, slcDevIntModemRemoteIP=slcDevIntModemRemoteIP, slcAuthNISListenPorts=slcAuthNISListenPorts, slcNetFirewallRulesetNumber=slcNetFirewallRulesetNumber, slcDevUSBCfgDialoutNum=slcDevUSBCfgDialoutNum, slcNetFirewallMappingTable=slcNetFirewallMappingTable, slcDevRPMIPAddress=slcDevRPMIPAddress, slcDevPortTimeFrame=slcDevPortTimeFrame, slcAuthTACACSGroup=slcAuthTACACSGroup, slcDevPortCfgTable=slcDevPortCfgTable, slcDevRPMUptime=slcDevRPMUptime, slcHostname=slcHostname, slcAuthLocalUserMenu=slcAuthLocalUserMenu, slcSystemLCDUserStrLine1=slcSystemLCDUserStrLine1, slcPCCardCfgAuth=slcPCCardCfgAuth, slcAuthNISOrder=slcAuthNISOrder, slcAuthRADIUSDataPorts=slcAuthRADIUSDataPorts, slcDevPortConfig=slcDevPortConfig, slcSystemLCDScreens=slcSystemLCDScreens, slcDevUSBCfgGSMPPPCompression=slcDevUSBCfgGSMPPPCompression, slcAuthLDAPEscapeSeq=slcAuthLDAPEscapeSeq, slcServNFSMountEntry=slcServNFSMountEntry, slcNetVPNIKEDHGroup=slcNetVPNIKEDHGroup, slcRPMAction=slcRPMAction, slcAuthRemoteUserEscapeSeq=slcAuthRemoteUserEscapeSeq, slcAuthRemoteUserListenPorts=slcAuthRemoteUserListenPorts, slcDevPortCfgDevice=slcDevPortCfgDevice, slcDevPortData=slcDevPortData, slcServWebTerm=slcServWebTerm, slcDevPortCfgName=slcDevPortCfgName, slcServSSHWebSSH=slcServSSHWebSSH, slcServCIFSEth2=slcServCIFSEth2, slcDevUSBCfgTCPState=slcDevUSBCfgTCPState, slcNetEthIPForwarding=slcNetEthIPForwarding, slcDevPortCfgDevTemperature=slcDevPortCfgDevTemperature, slcDevPortCfgSLMNMS=slcDevPortCfgSLMNMS, slcDevRPMOutletName=slcDevRPMOutletName, slcDevConsolePort=slcDevConsolePort, slcDevPortCfgPCCardState=slcDevPortCfgPCCardState, slcServSysRemoteServer2=slcServSysRemoteServer2, slcNetEthPingDelay=slcNetEthPingDelay, slcDevIntModemUseSites=slcDevIntModemUseSites, slcDevPortCfgCHAPHost=slcDevPortCfgCHAPHost, slcDevPortCfgRestartDelay=slcDevPortCfgRestartDelay, slcDevPortCfgTokenPowerAction=slcDevPortCfgTokenPowerAction, slcDevPortCfgPortLogSeq=slcDevPortCfgPortLogSeq, slcPCCardCfgSSHPort=slcPCCardCfgSSHPort, slcServSLCNetIndex=slcServSLCNetIndex, slcDevices=slcDevices, slcPCCardCfgLocalIP=slcPCCardCfgLocalIP, slcAuthNISSlave4=slcAuthNISSlave4, slcAuthTACACSRights=slcAuthTACACSRights, slcDevPortCfgDevLogin=slcDevPortCfgDevLogin, slcAuthLDAPBindName=slcAuthLDAPBindName, slcAuthRADIUSOrder=slcAuthRADIUSOrder, slcConnIdleStr=slcConnIdleStr, slcDevRPMNominalRealPower=slcDevRPMNominalRealPower, slcDevUSBCfgGSMAutoAcquireDNS=slcDevUSBCfgGSMAutoAcquireDNS, slcAuthLDAPServer2=slcAuthLDAPServer2, slcServHostListTable=slcServHostListTable, slcServSiteRestartDelay=slcServSiteRestartDelay, slcDevPortCfgTCPTimeoutDataDirection=slcDevPortCfgTCPTimeoutDataDirection, slcDevPortCfgDevHumidity=slcDevPortCfgDevHumidity, slcNetEthPingInterface=slcNetEthPingInterface, slcNetEthKeepaliveInterval=slcNetEthKeepaliveInterval, slcConnIdle=slcConnIdle, slcEventUSBAction=slcEventUSBAction, slcAuthLocalComplexPasswords=slcAuthLocalComplexPasswords, slcEventPCCardAction=slcEventPCCardAction, slcPCCardCfgGSMAutoAcquireDNS=slcPCCardCfgGSMAutoAcquireDNS, slcServSysGeneralLevel=slcServSysGeneralLevel, slcDevIntModem=slcDevIntModem, slcServSiteDialbackRetries=slcServSiteDialbackRetries, slcNetVPNEthPort=slcNetVPNEthPort, slcDevRPMTemperature=slcDevRPMTemperature, slcDevPortCfgPCCardMaxFiles=slcDevPortCfgPCCardMaxFiles, slcServHostListNumber=slcServHostListNumber, slcNetVPNRemoteHost=slcNetVPNRemoteHost, slcDevPortCfgWebColumns=slcDevPortCfgWebColumns, slcDevGlobalMaxDirect=slcDevGlobalMaxDirect, slcDevUSBCfgRemoteIP=slcDevUSBCfgRemoteIP, slcAuthLocalSysadminConsoleOnly=slcAuthLocalSysadminConsoleOnly, slcServHostListNumHosts=slcServHostListNumHosts, slcDevConDataBits=slcDevConDataBits, slcEventDevicePortDeviceHighTemp=slcEventDevicePortDeviceHighTemp, slcAuthGroupDialback=slcAuthGroupDialback, slcServSiteDialoutNum=slcServSiteDialoutNum, slcNetEthIfSource=slcNetEthIfSource, slcAuthLocalUserLogin=slcAuthLocalUserLogin, slcAuthKerbRights=slcAuthKerbRights, slcServSiteDialbackDelay=slcServSiteDialbackDelay, slcConnTable=slcConnTable, slcNetVPNRemoteId=slcNetVPNRemoteId, slcDevRPMId=slcDevRPMId, slcDevGlobalClearPorts=slcDevGlobalClearPorts, slcNetRouteRIPState=slcNetRouteRIPState, slcAuthRemoteUserBreakSeq=slcAuthRemoteUserBreakSeq, slcDevConNumberShowLines=slcDevConNumberShowLines, slcServNTPLocalServer3IPv6=slcServNTPLocalServer3IPv6, slcDevGlobalDataPorts=slcDevGlobalDataPorts, slcNetEthDNS3IPv6=slcNetEthDNS3IPv6, slcAuthGroupBreakSeq=slcAuthGroupBreakSeq, slcNetEthKeepaliveStartProbes=slcNetEthKeepaliveStartProbes, slcServNTPServerIPv6=slcServNTPServerIPv6, slcSystemTimeZone=slcSystemTimeZone, slcDevRPMOutletAction=slcDevRPMOutletAction, slcDevPortCfgTelnetState=slcDevPortCfgTelnetState, slcDevUSBCfgLocalIP=slcDevUSBCfgLocalIP, slcNetFirewallRulesetNumRules=slcNetFirewallRulesetNumRules, slcConnEndPt2=slcConnEndPt2, slcDevPortCfgSSHTimeout=slcDevPortCfgSSHTimeout, EnabledState=EnabledState, slcNetFirewallRulesetTable=slcNetFirewallRulesetTable, slcAuthLocalWarningPeriod=slcAuthLocalWarningPeriod, slcServSMTPSender=slcServSMTPSender, slcAuthLDAPDialbackNum=slcAuthLDAPDialbackNum, slcServCIFSEth1=slcServCIFSEth1, slcServSNMPTraps=slcServSNMPTraps, slcDevPortCfgSLMByteThresh=slcDevPortCfgSLMByteThresh, slcDevPortStateDTR=slcDevPortStateDTR, slcAuthRemote=slcAuthRemote, slcDevRPMManagedVia=slcDevRPMManagedVia, slcConnDurationStr=slcConnDurationStr, slcDevIntModemDialbackNum=slcDevIntModemDialbackNum, slcAuthTACACSMenu=slcAuthTACACSMenu, slcAuthTACACSDialback=slcAuthTACACSDialback, slcAuthRADIUSServerEntry=slcAuthRADIUSServerEntry, slcDevPortStateCD=slcDevPortStateCD, slcDevRPMDriverOpts=slcDevRPMDriverOpts, slcPCCardCfgGSMDialoutMode=slcPCCardCfgGSMDialoutMode, slcDevRPMStatusTable=slcDevRPMStatusTable, slcServSNMP=slcServSNMP, slcAuthRemoteUserIndex=slcAuthRemoteUserIndex, SyslogLevel=SyslogLevel, slcPCCardCfgCBCPClientType=slcPCCardCfgCBCPClientType, slcDevPortCfgEmailTo=slcDevPortCfgEmailTo, slcAuthTACACSEncrypt=slcAuthTACACSEncrypt, slcServCIFSState=slcServCIFSState, slcAuthRemoteUsersTable=slcAuthRemoteUsersTable, slcDevPortCfgTokenPowerSupply=slcDevPortCfgTokenPowerSupply, slcDevPowerSupplyB=slcDevPowerSupplyB, slcSystemLoadVia=slcSystemLoadVia, slcDevPortCfgSendTermString=slcDevPortCfgSendTermString, slcAuthRemoteUserEntry=slcAuthRemoteUserEntry, slcUSBType=slcUSBType, slcAuthLDAPBreakSeq=slcAuthLDAPBreakSeq, slcNetEth=slcNetEth, slcAuthLDAPDialback=slcAuthLDAPDialback, slcDevPCCard=slcDevPCCard, slcAuthRADIUSRights=slcAuthRADIUSRights, slcDevIntModemCallerIdLogging=slcDevIntModemCallerIdLogging, slcNetVPNRemoteHop=slcNetVPNRemoteHop, slcDevPortCfgDataBits=slcDevPortCfgDataBits, slcServSiteDialoutLogin=slcServSiteDialoutLogin, slcAuthRemoteNumber=slcAuthRemoteNumber, slcDevPortCfgTelnetSoftIAC=slcDevPortCfgTelnetSoftIAC, slcDevRPMLogStatus=slcDevRPMLogStatus, slcAuthLocalNumber=slcAuthLocalNumber, slcAuthGroupMenu=slcAuthGroupMenu, slcServHostListIndex=slcServHostListIndex, slcNetEthAlternateGateway=slcNetEthAlternateGateway, slcNetFirewallMappingIndex=slcNetFirewallMappingIndex, slcDevPortStateRTS=slcDevPortStateRTS, slcDevRPMFirmwareVersion=slcDevRPMFirmwareVersion, slcServSysDevPortLevel=slcServSysDevPortLevel, slcDevPortCfgDevPrompt=slcDevPortCfgDevPrompt, slcDevPortCfgSSHState=slcDevPortCfgSSHState, slcSystemLoginBanner=slcSystemLoginBanner, slcDevPortCfgDODAuth=slcDevPortCfgDODAuth, slcDevPortCfgEntry=slcDevPortCfgEntry, slcDevPortCfgIPMask=slcDevPortCfgIPMask, slcDevPortCfgEmailSend=slcDevPortCfgEmailSend, slcDevUSBCfgUseSites=slcDevUSBCfgUseSites, slcServSysRemoteServerIPv6=slcServSysRemoteServerIPv6, slcAuthLDAPUseLDAPSchema=slcAuthLDAPUseLDAPSchema, slcUSBAction=slcUSBAction, slcAuthTACACSServerIPv6=slcAuthTACACSServerIPv6, slcServSiteEntry=slcServSiteEntry, slcDevPortCfgStopBits=slcDevPortCfgStopBits, slcDevPortCfgDialbackMode=slcDevPortCfgDialbackMode, slcServNTP=slcServNTP, slcServNTPLocalServer3=slcServNTPLocalServer3, slc=slc, slcAuthTACACSClearPorts=slcAuthTACACSClearPorts, slcPCCardCfgTelnetPort=slcPCCardCfgTelnetPort, slcNetwork=slcNetwork, slcDevUSBCfgModemMode=slcDevUSBCfgModemMode, slcServCIFS=slcServCIFS, slcDevRPMInputVoltage=slcDevRPMInputVoltage, slcDevUSBCfgTable=slcDevUSBCfgTable, slcSystemWebInterface=slcSystemWebInterface, slcDevPortCfgUSBMaxFiles=slcDevPortCfgUSBMaxFiles, slcDevUSBState=slcDevUSBState, slcDevRPMPort=slcDevRPMPort, slcDevPortStateBytesInput=slcDevPortStateBytesInput, slcServSSHTimeoutDataDirection=slcServSSHTimeoutDataDirection, slcConnDuration=slcConnDuration, slcNetRouteStaticNumber=slcNetRouteStaticNumber, slcSystemLCDScrollDelay=slcSystemLCDScrollDelay, TimeoutDataDirection=TimeoutDataDirection, slcDevUSBCfgTCPPort=slcDevUSBCfgTCPPort, slcPCCardCfgRemoteIP=slcPCCardCfgRemoteIP)
mibBuilder.exportSymbols("LANTRONIX-SLC-MIB", slcPCCardCfgEntry=slcPCCardCfgEntry, slcNetEthIfMTU=slcNetEthIfMTU, slcServAuditIncludeCLI=slcServAuditIncludeCLI, slcDevPortCfgNumber=slcDevPortCfgNumber, slcAuthLocalUserChangePwdNextLogin=slcAuthLocalUserChangePwdNextLogin, slcSystem=slcSystem, slcServSyslog=slcServSyslog, slcDevPortCfgUSBMaxSize=slcDevPortCfgUSBMaxSize, slcDevPortState=slcDevPortState, slcServSiteName=slcServSiteName, slcServSNMPAlarmDelay=slcServSNMPAlarmDelay, slcDevPortStateTable=slcDevPortStateTable, slcDevPortCfgTelnetTimeout=slcDevPortCfgTelnetTimeout, slcDevUSBCfgCBCPServerAllowNoCallback=slcDevUSBCfgCBCPServerAllowNoCallback, slcNetFirewallTelnet=slcNetFirewallTelnet, slcDevPortCfgDODCHAPHost=slcDevPortCfgDODCHAPHost, slcNetFirewallRulesetIndex=slcNetFirewallRulesetIndex, slcDevUSBCfgCardId=slcDevUSBCfgCardId, slcEventDevicePortSLMData=slcEventDevicePortSLMData, slcSystemSiteRack=slcSystemSiteRack, slcNetEthIfIPv6Addr=slcNetEthIfIPv6Addr, slcAuthLDAPPort=slcAuthLDAPPort, slcServNTPPoll=slcServNTPPoll, slcDevRPMBatteryCharge=slcDevRPMBatteryCharge, slcServSLCNetTable=slcServSLCNetTable, slcAuthRemoteUserLogin=slcAuthRemoteUserLogin, slcDevPortCfgDevLowHumidity=slcDevPortCfgDevLowHumidity, slcServSNMPReadOnlyCommunity=slcServSNMPReadOnlyCommunity, slcServHostListAuth=slcServHostListAuth, slcAuthKerbKDCIP=slcAuthKerbKDCIP, slcDevGlobalStartSSHPort=slcDevGlobalStartSSHPort, slcNetVPNName=slcNetVPNName, slcAuthTACACSServer3=slcAuthTACACSServer3, slcDevPortCfgBanner=slcDevPortCfgBanner, slcDevIntModemRestartDelay=slcDevIntModemRestartDelay, slcEventPowerSupply=slcEventPowerSupply, slcNetEthIfIPv6PrefixLength=slcNetEthIfIPv6PrefixLength, slcDevUSBCfgCHAPAuthLocalUsers=slcDevUSBCfgCHAPAuthLocalUsers, slcAuthNISBreakSeq=slcAuthNISBreakSeq, slcNetVPNIKEAuthentication=slcNetVPNIKEAuthentication, slcDevRPMCriticalSNMPTraps=slcDevRPMCriticalSNMPTraps, slcConnFlow=slcConnFlow, slcNetEthPingIPAddress=slcNetEthPingIPAddress, slcServSiteIdleTimeout=slcServSiteIdleTimeout, slcPCCardCfgDialoutLogin=slcPCCardCfgDialoutLogin, slcNetEthIfNumber=slcNetEthIfNumber, slcAuthRemoteUserDialback=slcAuthRemoteUserDialback, slcNetEthIPv6=slcNetEthIPv6, slcDevRPMNominalApparentPower=slcDevRPMNominalApparentPower, slcAuthRADIUSUseVSA=slcAuthRADIUSUseVSA, slcAuthLDAPListenPorts=slcAuthLDAPListenPorts, slcPCCardCfgHostList=slcPCCardCfgHostList, slcServSNMPNMS2=slcServSNMPNMS2, slcSystemSiteRackRow=slcSystemSiteRackRow, slcServSLCNetSearch=slcServSLCNetSearch, RPMOutletIndex=RPMOutletIndex, slcServPhoneHomeState=slcServPhoneHomeState, slcAuthRADIUSState=slcAuthRADIUSState, slcAuthLDAPGroupMembershipDN=slcAuthLDAPGroupMembershipDN, slcDevIntModemLocalIP=slcDevIntModemLocalIP, slcNetVPNIKENegotiation=slcNetVPNIKENegotiation, PYSNMP_MODULE_ID=slc, slcDevPortCfgUSBLogTo=slcDevPortCfgUSBLogTo, slcDevIntModemDialoutLogin=slcDevIntModemDialoutLogin, slcDevPortCfgCallerIdATCmd=slcDevPortCfgCallerIdATCmd, slcDevPortErrorStatus=slcDevPortErrorStatus, slcServSysRPMLogSize=slcServSysRPMLogSize, slcAuthNISDataPorts=slcAuthNISDataPorts, slcDevConFlowControl=slcDevConFlowControl, slcAuthTACACSBreakSeq=slcAuthTACACSBreakSeq, slcServSNMPReadWriteCommunity=slcServSNMPReadWriteCommunity, slcDevPortCfgNATState=slcDevPortCfgNATState, slcPCCardCfgGSMContextID=slcPCCardCfgGSMContextID, slcNetFirewallMappingNumber=slcNetFirewallMappingNumber, slcServSMTP=slcServSMTP, slcServPhoneHome=slcServPhoneHome, slcDevPortCfgDevTraps=slcDevPortCfgDevTraps, slcAuthLocalUserRights=slcAuthLocalUserRights, slcAuthRADIUSServerTable=slcAuthRADIUSServerTable, slcAuthTACACSAuthService=slcAuthTACACSAuthService, slcDevPortCfgTokenAction=slcDevPortCfgTokenAction, slcServTelnetState=slcServTelnetState, slcDevIntModemDialbackDelay=slcDevIntModemDialbackDelay, slcServSNMPTrapCommunity=slcServSNMPTrapCommunity, slcDevIntModemCHAPHost=slcDevIntModemCHAPHost, slcNetRouteStaticMask=slcNetRouteStaticMask, slcSystemInternalTempLow=slcSystemInternalTempLow, slcDevIntModemModemState=slcDevIntModemModemState, slcNetEthIfEntry=slcNetEthIfEntry, slcAuthLDAP=slcAuthLDAP, slcNetEthDomain=slcNetEthDomain, slcDevPortCfgLocalIP=slcDevPortCfgLocalIP, slcDevPortCfgCHAPAuthLocalUsers=slcDevPortCfgCHAPAuthLocalUsers, slcDevRPMRealPower=slcDevRPMRealPower, slcEventDevicePortDeviceError=slcEventDevicePortDeviceError, slcConnEntry=slcConnEntry, slcAuthLocalUserListenPorts=slcAuthLocalUserListenPorts, slcAuthNISSlave1=slcAuthNISSlave1, slcAuthLocalUserClearPorts=slcAuthLocalUserClearPorts, slcDevPortCfgMinimizeLatency=slcDevPortCfgMinimizeLatency, slcPCCardCfgTCPPort=slcPCCardCfgTCPPort, slcDevUSBCfgDODCHAPHost=slcDevUSBCfgDODCHAPHost, slcServNFSMountRemoteDir=slcServNFSMountRemoteDir, slcConnNumber=slcConnNumber, slcPCCardSlot=slcPCCardSlot, slcPCCardCfgParity=slcPCCardCfgParity, slcDevPortCfgDialbackRetries=slcDevPortCfgDialbackRetries, slcAuthKerbKDCIPv6=slcAuthKerbKDCIPv6, slcServSNMPv3User=slcServSNMPv3User, slcServSiteDialback=slcServSiteDialback, slcEventDevicePortSLMConfig=slcEventDevicePortSLMConfig, slcSystemFTPServer=slcSystemFTPServer, slcDevPortCfgTerminationString=slcDevPortCfgTerminationString, slcSystemSerialNo=slcSystemSerialNo, slcDevPortCfgTokenSendString=slcDevPortCfgTokenSendString, slcAuthLocalUserEscapeSeq=slcAuthLocalUserEscapeSeq, slcDevPortCfgReversePinout=slcDevPortCfgReversePinout, slcPCCardCfgDialoutNum=slcPCCardCfgDialoutNum, slcDevPortCfgAction=slcDevPortCfgAction, slcNetFirewallRulesetRules=slcNetFirewallRulesetRules, slcServSNMPv1v2=slcServSNMPv1v2, slcDevRPMSNMPReadComm=slcDevRPMSNMPReadComm, slcDevUSBCfgSSHPort=slcDevUSBCfgSSHPort, slcSystemWebProtocol=slcSystemWebProtocol, slcServSLCNetNumber=slcServSLCNetNumber, slcServNFS=slcServNFS, slcAuthRADIUSGroup=slcAuthRADIUSGroup, slcDevPortId=slcDevPortId, slcDevRPMShutdownOrder=slcDevRPMShutdownOrder, slcPCCardCfgTelnetState=slcPCCardCfgTelnetState, slcDevPortCfgNFSMaxSize=slcDevPortCfgNFSMaxSize, slcDevPortCfgSLMTimeFrame=slcDevPortCfgSLMTimeFrame, slcDevUSBCfgInitScript=slcDevUSBCfgInitScript, slcServHostListHosts=slcServHostListHosts, slcDevPortCfgDevNumExpOutlets=slcDevPortCfgDevNumExpOutlets, slcPCCardCfgTable=slcPCCardCfgTable, slcDevPortCfgBreakSeq=slcDevPortCfgBreakSeq, slcSystemWebGadget=slcSystemWebGadget, slcServSiteStaticRouteGateway=slcServSiteStaticRouteGateway, slcDevPortCfgTelnetAuth=slcDevPortCfgTelnetAuth, slcServCIFSWorkgroup=slcServCIFSWorkgroup, slcAuthNIS=slcAuthNIS, slcServices=slcServices, slcDevPortCfgAssertDTR=slcDevPortCfgAssertDTR, slcDevUSBCfgParity=slcDevUSBCfgParity, slcNetEthGatewayIPv6=slcNetEthGatewayIPv6, slcServSysRemoteServer=slcServSysRemoteServer, slcDevPortCfgCBCPClientType=slcDevPortCfgCBCPClientType, slcSystemInternalTemp=slcSystemInternalTemp, slcPCCardCfgGSMPPPCompression=slcPCCardCfgGSMPPPCompression, slcAuthLDAPBindWithLogin=slcAuthLDAPBindWithLogin, slcPCCardCfgCardType=slcPCCardCfgCardType, slcAuthNISDialback=slcAuthNISDialback, slcDevPortStateOverrunErrors=slcDevPortStateOverrunErrors, slcNetFirewallRulesetEntry=slcNetFirewallRulesetEntry, slcNetVPNStatus=slcNetVPNStatus, slcAuthNISMenu=slcAuthNISMenu, slcPCCardCfgStopBits=slcPCCardCfgStopBits, slcPCCardCfgDialbackNum=slcPCCardCfgDialbackNum, slcNetFirewallMappingIfacId=slcNetFirewallMappingIfacId, slcAuthNISSlave3=slcAuthNISSlave3, slcServSiteLoginHost=slcServSiteLoginHost, slcAuthLDAPADSupport=slcAuthLDAPADSupport, slcSystemLCDScrolling=slcSystemLCDScrolling, slcDevPortCfgDialbackNum=slcDevPortCfgDialbackNum, slcPCCardCfgBaud=slcPCCardCfgBaud, slcAuthKerbEscapeSeq=slcAuthKerbEscapeSeq, slcAuthLDAPServer2IPv6=slcAuthLDAPServer2IPv6, slcAuthLDAPMenu=slcAuthLDAPMenu, slcDevIntModemCallerIdATCmd=slcDevIntModemCallerIdATCmd, slcAuthGroupDialbackNum=slcAuthGroupDialbackNum, slcPCCardCfgISDNChannelNum=slcPCCardCfgISDNChannelNum, slcDevRPMVendorModel=slcDevRPMVendorModel, slcSystemSSHPreAuthBanner=slcSystemSSHPreAuthBanner, slcEventDevicePortDeviceLowHumidity=slcEventDevicePortDeviceLowHumidity, slcAuthGroupName=slcAuthGroupName, slcAuthNISDialbackNum=slcAuthNISDialbackNum, slcPCCardCfgDODCHAPHost=slcPCCardCfgDODCHAPHost, slcDevRPMBeeperStatus=slcDevRPMBeeperStatus, slcDevPortCfgIdleTimeoutMessage=slcDevPortCfgIdleTimeoutMessage, slcDevRPMStatus=slcDevRPMStatus, slcDevUSBId=slcDevUSBId, slcDevUSBCfgTCPAuth=slcDevUSBCfgTCPAuth, slcNetFirewallPing=slcNetFirewallPing, slcPCCardCfgISDNChannel=slcPCCardCfgISDNChannel, slcPCCardCfgUseSites=slcPCCardCfgUseSites, slcServSSHDSAKeys=slcServSSHDSAKeys, slcEventHost=slcEventHost, slcServSNMPNMS=slcServSNMPNMS, slcDevPortCfgUSBVBUS=slcDevPortCfgUSBVBUS, slcAuthRADIUSPort=slcAuthRADIUSPort, slcAuthNISDomain=slcAuthNISDomain, slcNetVPNESPDHGroup=slcNetVPNESPDHGroup, slcServSysDiagLevel=slcServSysDiagLevel, slcServSysAuthLevel=slcServSysAuthLevel, slcConnEndPt1=slcConnEndPt1, slcServSiteTimeout=slcServSiteTimeout, slcServTelnetTimeoutDataDirection=slcServTelnetTimeoutDataDirection, slcDevRPMLoadOverThreshold=slcDevRPMLoadOverThreshold, slcNetFirewallState=slcNetFirewallState, slcSystemWebTimeout=slcSystemWebTimeout, slcPCCardType=slcPCCardType, slcEventPingHostFails=slcEventPingHostFails, slcAuthKerbDialbackNum=slcAuthKerbDialbackNum, slcServNFSMountTable=slcServNFSMountTable, slcDevRPMOutletEntry=slcDevRPMOutletEntry, slcEventDevicePortDeviceHighHumidity=slcEventDevicePortDeviceHighHumidity, slcServSNMPv3Authentication=slcServSNMPv3Authentication, slcPCCardCfgDialbackDelay=slcPCCardCfgDialbackDelay, slcPCCardCfgTCPAuth=slcPCCardCfgTCPAuth, slcDevPortCfgEmailSubject=slcDevPortCfgEmailSubject, slcDevUSBCfgIdleTimeout=slcDevUSBCfgIdleTimeout, slcDevPortCfgTelnetTimeoutDataDirection=slcDevPortCfgTelnetTimeoutDataDirection, slcPCCardCfgFlowControl=slcPCCardCfgFlowControl, slcServSSHPort=slcServSSHPort, slcAuthTACACSServer=slcAuthTACACSServer, slcNetFirewall=slcNetFirewall, slcNetVPNRemoteSubnet=slcNetVPNRemoteSubnet, slcAuthLocalUseNextMethod=slcAuthLocalUseNextMethod, slcNetFirewallMappingEntry=slcNetFirewallMappingEntry, slcAuthGroupClearPorts=slcAuthGroupClearPorts, slcDevPortCfgTCPState=slcDevPortCfgTCPState, slcAuthKerbUseLDAP=slcAuthKerbUseLDAP, slcDevUSBCfgHostList=slcDevUSBCfgHostList, slcAuthLocal=slcAuthLocal, slcNetFirewallSMBCIFS=slcNetFirewallSMBCIFS, slcNetVPNXAUTHClient=slcNetVPNXAUTHClient, slcNetVPNIKEEncryption=slcNetVPNIKEEncryption, slcNetRouteStaticGateway=slcNetRouteStaticGateway, slcDevPortCfgPCCardMaxSize=slcDevPortCfgPCCardMaxSize, slcAuthKerbOrder=slcAuthKerbOrder, slcDevUSBCfgFlowControl=slcDevUSBCfgFlowControl, slcServNTPLocalServer2=slcServNTPLocalServer2, slcDevRPMAdminLogin=slcDevRPMAdminLogin, slcSystemFTPPath=slcSystemFTPPath, slcDevPortCfgIP=slcDevPortCfgIP, slcAuthLocalUserDialbackNum=slcAuthLocalUserDialbackNum, slcDevRPMSerialNumber=slcDevRPMSerialNumber, slcNetVPNModeConfigClient=slcNetVPNModeConfigClient, slcAuthNISClearPorts=slcAuthNISClearPorts, slcAuthGroupEscapeSeq=slcAuthGroupEscapeSeq, slcAuthGroupListenPorts=slcAuthGroupListenPorts, slcDevUSBCfgDODAuth=slcDevUSBCfgDODAuth, slcAuthRemoteUserMenu=slcAuthRemoteUserMenu, slcNetRouteStaticTable=slcNetRouteStaticTable, slcDevPortCfgModemMode=slcDevPortCfgModemMode, slcDevUSB=slcDevUSB, slcSDCardAction=slcSDCardAction, slcServHostListRetryCount=slcServHostListRetryCount, slcAuthNISState=slcAuthNISState, slcDevUSBCfgEntry=slcDevUSBCfgEntry, slcAuthTACACSServer2=slcAuthTACACSServer2, slcDevUSBCfgTelnetPort=slcDevUSBCfgTelnetPort, slcPCCardCfgCHAPHost=slcPCCardCfgCHAPHost)
mibBuilder.exportSymbols("LANTRONIX-SLC-MIB", slcPCCardCfgTCPState=slcPCCardCfgTCPState, RPMTowerIndex=RPMTowerIndex, slcAuthGroupsTable=slcAuthGroupsTable, slcDevUSBCfgCHAPHost=slcDevUSBCfgCHAPHost, slcAuthLDAPServerIPv6=slcAuthLDAPServerIPv6, slcNetVPNESPAuthentication=slcNetVPNESPAuthentication, slcServSLCNetIP=slcServSLCNetIP, slcAuthKerbMenu=slcAuthKerbMenu, slcEventRPMAction=slcEventRPMAction, slcAuthTACACSDialbackNum=slcAuthTACACSDialbackNum, slcAuthLocalPasswordLifetime=slcAuthLocalPasswordLifetime, slcAuthRemoteAuthListOnly=slcAuthRemoteAuthListOnly, slcDevPortCfgSSHPort=slcDevPortCfgSSHPort, slcServSNMPv3ReadWriteUser=slcServSNMPv3ReadWriteUser, slcServSLCNetEntry=slcServSLCNetEntry, slcNetFirewallHTTPS=slcNetFirewallHTTPS, slcDevPortCfgUseSites=slcDevPortCfgUseSites, slcDevPortCfgDialoutLogin=slcDevPortCfgDialoutLogin, slcAuthTACACSListenPorts=slcAuthTACACSListenPorts, slcDevPortCfgTimeout=slcDevPortCfgTimeout, slcDevPortCfgFlowControl=slcDevPortCfgFlowControl, slcNetEthDNS1=slcNetEthDNS1, slcNetFirewallMappingRuleset=slcNetFirewallMappingRuleset, slcAuthRemoteUserLocked=slcAuthRemoteUserLocked, slcDevRPMCfgTable=slcDevRPMCfgTable, slcNetFirewallHTTP=slcNetFirewallHTTP, slcDevPortCfgPCCardLogTo=slcDevPortCfgPCCardLogTo, slcServHostListName=slcServHostListName, slcDevPortCfgMaxDirectConnects=slcDevPortCfgMaxDirectConnects, slcPCCardCfgCHAPAuthLocalUsers=slcPCCardCfgCHAPAuthLocalUsers, slcAuthRemoteUserClearPorts=slcAuthRemoteUserClearPorts, slcDevPortCfgWebRows=slcDevPortCfgWebRows, slcDevUSBCfgDataBits=slcDevUSBCfgDataBits, slcDevPortCfgEmailRestartDelay=slcDevPortCfgEmailRestartDelay, slcDevRPMOutletState=slcDevRPMOutletState, slcNetEthDNS2IPv6=slcNetEthDNS2IPv6, slcDevUSBCfgStorageFS=slcDevUSBCfgStorageFS, slcServSSHState=slcServSSHState, slcPCCardCfgTelnetAuth=slcPCCardCfgTelnetAuth, slcDevPortCfgShowLines=slcDevPortCfgShowLines, slcAuthGroupEntry=slcAuthGroupEntry, slcAuthLocalUserChangePwd=slcAuthLocalUserChangePwd, slcDevRPMOnLowBattery=slcDevRPMOnLowBattery, slcDevPortStateBytesOutput=slcDevPortStateBytesOutput, slcAuthLocalUsersTable=slcAuthLocalUsersTable, slcAuthLDAPRights=slcAuthLDAPRights, slcDevUSBCfgSSHAuth=slcDevUSBCfgSSHAuth, slcDevUSBCfgDialtoneCheck=slcDevUSBCfgDialtoneCheck, slcNetRouteStaticState=slcNetRouteStaticState, slcServSiteNumber=slcServSiteNumber, slcServAuditLog=slcServAuditLog, slcServNTPSynchronize=slcServNTPSynchronize, slcDevConTimeout=slcDevConTimeout, slcDevUSBCfgGSMDialoutMode=slcDevUSBCfgGSMDialoutMode, slcNetRouteStaticIP=slcNetRouteStaticIP, slcAuthLDAPOrder=slcAuthLDAPOrder, slcDevUSBCfgDialbackNum=slcDevUSBCfgDialbackNum, slcAuthLocalOrder=slcAuthLocalOrder, slcServSitePortId=slcServSitePortId, slcServSLCNetwork=slcServSLCNetwork, slcAuthLocalMaxLoginAttempts=slcAuthLocalMaxLoginAttempts, slcAuthRADIUSServerIPv6=slcAuthRADIUSServerIPv6, slcAuthRADIUSDialback=slcAuthRADIUSDialback, slcDevIntModemDialbackRetries=slcDevIntModemDialbackRetries, slcServTelnetWebTelnet=slcServTelnetWebTelnet, slcAuthLocalLockoutPeriod=slcAuthLocalLockoutPeriod, slcServSysServicesLevel=slcServSysServicesLevel, slcAuthNISSlave2=slcAuthNISSlave2, slcDevPortCfgNFSDir=slcDevPortCfgNFSDir, slcSystemInternalTempHigh=slcSystemInternalTempHigh, slcNetVPNLocalHop=slcNetVPNLocalHop, slcAuthNISBroadcast=slcAuthNISBroadcast, slcDevUSBCfgNATState=slcDevUSBCfgNATState, slcDevPortGlobal=slcDevPortGlobal, slcAuthTACACSEscapeSeq=slcAuthTACACSEscapeSeq, slcDevPortCfgEmailState=slcDevPortCfgEmailState, slcAuthLocalUserPwdExpires=slcAuthLocalUserPwdExpires, slcDevPortCfgConnectDSR=slcDevPortCfgConnectDSR)
